<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>Makefile.am</source>
    <document_content><![CDATA[
SUBDIRS = amortizingbonds asian averageois barrieroption basismodels \
          callablebonds catbonds commodities convertiblebonds coupons credit \
          exoticoptions finitedifferences forward fx inflation lattices \
          math mcbasket models processes risk shortrate swaptions \
          termstructures variancegamma varianceoption volatility

AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp

libExperimental_la_SOURCES =

libExperimental_la_LIBADD = \
    amortizingbonds/libAmortizingBonds.la \
    asian/libAsian.la \
    averageois/libAverageOIS.la \
    barrieroption/libBarrierOption.la \
    basismodels/libBasisModels.la \
    callablebonds/libCallableBonds.la \
    catbonds/libCatBonds.la \
    commodities/libCommodities.la \
    convertiblebonds/libConvertibleBonds.la \
    coupons/libCoupons.la \
    credit/libCredit.la \
    exoticoptions/libExoticOptions.la \
    finitedifferences/libMultiDimFDM.la \
    forward/libForward.la \
    fx/libFX.la \
    inflation/libInflation.la \
    lattices/libLattices.la \
    math/libMath.la \
    mcbasket/libMcBasket.la \
    models/libModels.la \
    processes/libProcesses.la \
    risk/libRisk.la \
    shortrate/libShortRate.la \
    swaptions/libSwaptions.la \
    termstructures/libTermStructures.la \
    variancegamma/libVarianceGamma.la \
    varianceoption/libVarianceOption.la \
    volatility/libVolatility.la

noinst_LTLIBRARIES = libExperimental.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="2">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/amortizingbonds/all.hpp>
#include <ql/experimental/asian/all.hpp>
#include <ql/experimental/averageois/all.hpp>
#include <ql/experimental/barrieroption/all.hpp>
#include <ql/experimental/basismodels/all.hpp>
#include <ql/experimental/callablebonds/all.hpp>
#include <ql/experimental/catbonds/all.hpp>
#include <ql/experimental/commodities/all.hpp>
#include <ql/experimental/convertiblebonds/all.hpp>
#include <ql/experimental/coupons/all.hpp>
#include <ql/experimental/credit/all.hpp>
#include <ql/experimental/exoticoptions/all.hpp>
#include <ql/experimental/finitedifferences/all.hpp>
#include <ql/experimental/forward/all.hpp>
#include <ql/experimental/fx/all.hpp>
#include <ql/experimental/inflation/all.hpp>
#include <ql/experimental/lattices/all.hpp>
#include <ql/experimental/math/all.hpp>
#include <ql/experimental/mcbasket/all.hpp>
#include <ql/experimental/models/all.hpp>
#include <ql/experimental/processes/all.hpp>
#include <ql/experimental/risk/all.hpp>
#include <ql/experimental/shortrate/all.hpp>
#include <ql/experimental/swaptions/all.hpp>
#include <ql/experimental/termstructures/all.hpp>
#include <ql/experimental/variancegamma/all.hpp>
#include <ql/experimental/varianceoption/all.hpp>
#include <ql/experimental/volatility/all.hpp>
]]></document_content>
  </document>
  <document index="3">
    <source>amortizingbonds/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    amortizingcmsratebond.hpp \
    amortizingfixedratebond.hpp \
    amortizingfloatingratebond.hpp

cpp_files = \
    amortizingcmsratebond.cpp \
    amortizingfixedratebond.cpp \
    amortizingfloatingratebond.cpp

if UNITY_BUILD

nodist_libAmortizingBonds_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libAmortizingBonds_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libAmortizingBonds.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="4">
    <source>amortizingbonds/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/amortizingbonds/amortizingcmsratebond.hpp>
#include <ql/experimental/amortizingbonds/amortizingfixedratebond.hpp>
#include <ql/experimental/amortizingbonds/amortizingfloatingratebond.hpp>

]]></document_content>
  </document>
  <document index="5">
    <source>amortizingbonds/amortizingcmsratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/amortizingbonds/amortizingcmsratebond.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    AmortizingCmsRateBond::AmortizingCmsRateBond(
                                    Natural settlementDays,
                                    const std::vector<Real>& notionals,
                                    const Schedule& schedule,
                                    const ext::shared_ptr<SwapIndex>& index,
                                    const DayCounter& paymentDayCounter,
                                    BusinessDayConvention paymentConvention,
                                    Natural fixingDays,
                                    const std::vector<Real>& gearings,
                                    const std::vector<Spread>& spreads,
                                    const std::vector<Rate>& caps,
                                    const std::vector<Rate>& floors,
                                    bool inArrears,
                                    const Date& issueDate)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = CmsLeg(schedule, index)
            .withNotionals(notionals)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears);

        addRedemptionsToCashflows();

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");

        registerWith(index);
    }

}
]]></document_content>
  </document>
  <document index="6">
    <source>amortizingbonds/amortizingcmsratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file amortizingcmsratebond.hpp
    \brief amortizing CMS-rate bond
*/

#ifndef quantlib_amortizing_cms_rate_bond_hpp
#define quantlib_amortizing_cms_rate_bond_hpp

#include <ql/instruments/bond.hpp>

namespace QuantLib {

    class Schedule;
    class SwapIndex;

    //! amortizing CMS-rate bond
    class AmortizingCmsRateBond : public Bond {
      public:
        AmortizingCmsRateBond(
                    Natural settlementDays,
                    const std::vector<Real>& notionals,
                    const Schedule& schedule,
                    const ext::shared_ptr<SwapIndex>& index,
                    const DayCounter& paymentDayCounter,
                    BusinessDayConvention paymentConvention = Following,
                    Natural fixingDays = Null<Natural>(),
                    const std::vector<Real>& gearings =
                                                    std::vector<Real>(1, 1.0),
                    const std::vector<Spread>& spreads =
                                                  std::vector<Spread>(1, 0.0),
                    const std::vector<Rate>& caps = std::vector<Rate>(),
                    const std::vector<Rate>& floors = std::vector<Rate>(),
                    bool inArrears = false,
                    const Date& issueDate = Date());
    };

}

#endif
]]></document_content>
  </document>
  <document index="7">
    <source>amortizingbonds/amortizingfixedratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/amortizingbonds/amortizingfixedratebond.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    AmortizingFixedRateBond::AmortizingFixedRateBond(
                                      Natural settlementDays,
                                      const std::vector<Real>& notionals,
                                      const Schedule& schedule,
                                      const std::vector<Rate>& coupons,
                                      const DayCounter& accrualDayCounter,
                                      BusinessDayConvention paymentConvention,
                                      const Date& issueDate,
                                      const Period& exCouponPeriod,
                                      const Calendar& exCouponCalendar,
                                      const BusinessDayConvention exCouponConvention,
                                      bool exCouponEndOfMonth)
    : Bond(settlementDays, schedule.calendar(), issueDate),
      frequency_(schedule.tenor().frequency()),
      dayCounter_(accrualDayCounter) {

        maturityDate_ = schedule.endDate();

        cashflows_ = FixedRateLeg(schedule)
            .withNotionals(notionals)
            .withCouponRates(coupons, accrualDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows();

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
    }

    namespace  {

        std::pair<Integer,Integer> daysMinMax(const Period& p) {
            switch (p.units()) {
              case Days:
                return std::make_pair(p.length(), p.length());
              case Weeks:
                return std::make_pair(7*p.length(), 7*p.length());
              case Months:
                return std::make_pair(28*p.length(), 31*p.length());
              case Years:
                return std::make_pair(365*p.length(), 366*p.length());
              default:
                QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
            }
        }

        bool isSubPeriod(const Period& subPeriod,
                         const Period& superPeriod,
                         Integer& numSubPeriods) {

            std::pair<Integer, Integer> superDays(daysMinMax(superPeriod));
            std::pair<Integer, Integer> subDays(daysMinMax(subPeriod));

            //obtain the approximate time ratio
            Real minPeriodRatio =
                ((Real)superDays.first)/((Real)subDays.second);
            Real maxPeriodRatio =
                ((Real)superDays.second)/((Real)subDays.first);
            auto lowRatio = static_cast<Integer>(std::floor(minPeriodRatio));
            auto highRatio = static_cast<Integer>(std::ceil(maxPeriodRatio));

            try {
                for(Integer i=lowRatio; i <= highRatio; ++i) {
                    Period testPeriod = subPeriod * i;
                    if(testPeriod == superPeriod) {
                        numSubPeriods = i;
                        return true;
                    }
                }
            } catch(Error&) {
                return false;
            }

            return false;
        }

        Schedule sinkingSchedule(const Date& startDate,
                                 const Period& maturityTenor,
                                 const Frequency& sinkingFrequency,
                                 const Calendar& paymentCalendar) {
            Period freqPeriod(sinkingFrequency);
            Date maturityDate(startDate + maturityTenor);
            Schedule retVal(startDate, maturityDate, freqPeriod,
                            paymentCalendar, Unadjusted, Unadjusted,
                            DateGeneration::Backward, false);
            return retVal;
        }

        std::vector<Real> sinkingNotionals(const Period& maturityTenor,
                                           const Frequency& sinkingFrequency,
                                           Rate couponRate,
                                           Real initialNotional) {
            Period freqPeriod(sinkingFrequency);
            Integer nPeriods;
            QL_REQUIRE(isSubPeriod(freqPeriod, maturityTenor, nPeriods),
                       "Bond frequency is incompatible with the maturity tenor");

            std::vector<Real> notionals(nPeriods+1);
            notionals.front() = initialNotional;
            Real coupon = couponRate / static_cast<Real>(sinkingFrequency);
            Real compoundedInterest = 1.0;
            Real totalValue = std::pow(1.0+coupon, nPeriods);
            for(Size i = 0; i < (Size)nPeriods-1; ++i) {
                compoundedInterest *= (1.0 + coupon);
                Real currentNotional = 0.0;
                if(coupon < 1.0e-12) {
                    currentNotional =
                       initialNotional*(1.0 - (i+1.0)/nPeriods);
                }
                else {
                    currentNotional =
                       initialNotional*(compoundedInterest - (compoundedInterest-1.0)/(1.0 - 1.0/totalValue));
                }
                notionals[i+1] = currentNotional;
            }
            notionals.back() = 0.0;
            return notionals;
        }

    }


    AmortizingFixedRateBond::AmortizingFixedRateBond(
                                      Natural settlementDays,
                                      const Calendar& calendar,
                                      Real initialFaceAmount,
                                      const Date& startDate,
                                      const Period& bondTenor,
                                      const Frequency& sinkingFrequency,
                                      const Rate coupon,
                                      const DayCounter& accrualDayCounter,
                                      BusinessDayConvention paymentConvention,
                                      const Date& issueDate)
    : Bond(settlementDays, calendar, issueDate),
      frequency_(sinkingFrequency),
      dayCounter_(accrualDayCounter) {

        QL_REQUIRE(bondTenor.length() > 0,
                   "bond tenor must be positive. "
                   << bondTenor << " is not allowed.");
        maturityDate_ = startDate + bondTenor;

        cashflows_ =
            FixedRateLeg(sinkingSchedule(startDate, bondTenor,
                                         sinkingFrequency, calendar))
            .withNotionals(sinkingNotionals(bondTenor,
                                            sinkingFrequency, coupon,
                                            initialFaceAmount))
            .withCouponRates(coupon, accrualDayCounter)
            .withPaymentAdjustment(paymentConvention);

        addRedemptionsToCashflows();
    }

    AmortizingFixedRateBond::AmortizingFixedRateBond(
                                      Natural settlementDays,
                                      const std::vector<Real>& notionals,
                                      const Schedule& schedule,
                                      const std::vector<InterestRate>& coupons,
                                      BusinessDayConvention paymentConvention,
                                      const Date& issueDate,
                                      const Calendar& paymentCalendar,
                                      const Period& exCouponPeriod,
                                      const Calendar& exCouponCalendar,
                                      const BusinessDayConvention exCouponConvention,
                                      bool exCouponEndOfMonth)
    : Bond(settlementDays,
        paymentCalendar==Calendar() ? schedule.calendar() : paymentCalendar,
        issueDate),
      frequency_(schedule.tenor().frequency()),
      dayCounter_(coupons[0].dayCounter()) {

        maturityDate_ = schedule.endDate();

        cashflows_ = FixedRateLeg(schedule)
            .withNotionals(notionals)
            .withCouponRates(coupons)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows();

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
    }

}
]]></document_content>
  </document>
  <document index="8">
    <source>amortizingbonds/amortizingfixedratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file amortizingfixedratebond.hpp
    \brief amortizing fixed-rate bond
*/

#ifndef quantlib_amortizing_fixed_rate_bond_hpp
#define quantlib_amortizing_fixed_rate_bond_hpp

#include <ql/instruments/bond.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/interestrate.hpp>

namespace QuantLib {

    class Schedule;

    //! amortizing fixed-rate bond
    class AmortizingFixedRateBond : public Bond {
      public:
        AmortizingFixedRateBond(Natural settlementDays,
                                const std::vector<Real>& notionals,
                                const Schedule& schedule,
                                const std::vector<Rate>& coupons,
                                const DayCounter& accrualDayCounter,
                                BusinessDayConvention paymentConvention = Following,
                                const Date& issueDate = Date(),
                                const Period& exCouponPeriod = Period(),
                                const Calendar& exCouponCalendar = Calendar(),
                                BusinessDayConvention exCouponConvention = Unadjusted,
                                bool exCouponEndOfMonth = false);
        /*! Automatically generates a set of equal coupons, with an
            amortizing bond.  The coupons are equal and the accrual
            daycount is only used for quoting/settlement purposes -
            not for calculating the coupons.
        */
        AmortizingFixedRateBond(Natural settlementDays,
                                const Calendar& calendar,
                                Real faceAmount,
                                const Date& startDate,
                                const Period& bondTenor,
                                const Frequency& sinkingFrequency,
                                Rate coupon,
                                const DayCounter& accrualDayCounter,
                                BusinessDayConvention paymentConvention = Following,
                                const Date& issueDate = Date());
        AmortizingFixedRateBond(Natural settlementDays,
                                const std::vector<Real>& notionals,
                                const Schedule& schedule,
                                const std::vector<InterestRate>& coupons,
                                BusinessDayConvention paymentConvention = Following,
                                const Date& issueDate = Date(),
                                const Calendar& paymentCalendar = Calendar(),
                                const Period& exCouponPeriod = Period(),
                                const Calendar& exCouponCalendar = Calendar(),
                                BusinessDayConvention exCouponConvention = Unadjusted,
                                bool exCouponEndOfMonth = false);
        Frequency frequency() const { return frequency_; }
        const DayCounter& dayCounter() const { return dayCounter_; }
      protected:
        Frequency frequency_;
        DayCounter dayCounter_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>amortizingbonds/amortizingfloatingratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/amortizingbonds/amortizingfloatingratebond.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    AmortizingFloatingRateBond::AmortizingFloatingRateBond(
                                    Natural settlementDays,
                                    const std::vector<Real>& notionals,
                                    const Schedule& schedule,
                                    const ext::shared_ptr<IborIndex>& index,
                                    const DayCounter& paymentDayCounter,
                                    BusinessDayConvention paymentConvention,
                                    Natural fixingDays,
                                    const std::vector<Real>& gearings,
                                    const std::vector<Spread>& spreads,
                                    const std::vector<Rate>& caps,
                                    const std::vector<Rate>& floors,
                                    bool inArrears,
                                    const Date& issueDate,
                                    const Period& exCouponPeriod,
                                    const Calendar& exCouponCalendar,
                                    const BusinessDayConvention exCouponConvention,
                                    bool exCouponEndOfMonth)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = IborLeg(schedule, index)
            .withNotionals(notionals)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth)
            .inArrears(inArrears);

        addRedemptionsToCashflows();

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");

        registerWith(index);
    }

}
]]></document_content>
  </document>
  <document index="10">
    <source>amortizingbonds/amortizingfloatingratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file amortizingfloatingratebond.hpp
    \brief amortizing floating-rate bond
*/

#ifndef quantlib_amortizing_floating_rate_bond_hpp
#define quantlib_amortizing_floating_rate_bond_hpp

#include <ql/instruments/bond.hpp>

namespace QuantLib {

    class Schedule;
    class IborIndex;

    //! amortizing floating-rate bond (possibly capped and/or floored)
    class AmortizingFloatingRateBond : public Bond {
      public:
        AmortizingFloatingRateBond(Natural settlementDays,
                                   const std::vector<Real>& notional,
                                   const Schedule& schedule,
                                   const ext::shared_ptr<IborIndex>& index,
                                   const DayCounter& accrualDayCounter,
                                   BusinessDayConvention paymentConvention = Following,
                                   Natural fixingDays = Null<Natural>(),
                                   const std::vector<Real>& gearings = std::vector<Real>(1, 1.0),
                                   const std::vector<Spread>& spreads = std::vector<Spread>(1, 0.0),
                                   const std::vector<Rate>& caps = std::vector<Rate>(),
                                   const std::vector<Rate>& floors = std::vector<Rate>(),
                                   bool inArrears = false,
                                   const Date& issueDate = Date(),
                                   const Period& exCouponPeriod = Period(),
                                   const Calendar& exCouponCalendar = Calendar(),
                                   BusinessDayConvention exCouponConvention = Unadjusted,
                                   bool exCouponEndOfMonth = false);
    };

}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>asian/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    analytic_cont_geom_av_price_heston.hpp \
    analytic_discr_geom_av_price_heston.hpp

cpp_files = \
    analytic_cont_geom_av_price_heston.cpp \
    analytic_discr_geom_av_price_heston.cpp

if UNITY_BUILD

nodist_libAsian_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libAsian_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libAsian.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="12">
    <source>asian/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/asian/analytic_cont_geom_av_price_heston.hpp>
#include <ql/experimental/asian/analytic_discr_geom_av_price_heston.hpp>

]]></document_content>
  </document>
  <document index="13">
    <source>asian/analytic_cont_geom_av_price_heston.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/asian/analytic_cont_geom_av_price_heston.hpp>
#include <utility>

namespace QuantLib {

    class AnalyticContinuousGeometricAveragePriceAsianHestonEngine::Integrand {
      private:
        Real t_, T_, K_, logK_;
        Size cutoff_;
        const AnalyticContinuousGeometricAveragePriceAsianHestonEngine* const parent_;
        Real xiRightLimit_;
        std::complex<Real> i_;

      public:
        Integrand(Real T,
                  Size cutoff,
                  Real K,
                  const AnalyticContinuousGeometricAveragePriceAsianHestonEngine* const parent,
                  Real xiRightLimit) : t_(0.0), T_(T), K_(K), logK_(std::log(K)), cutoff_(cutoff),
                                       parent_(parent), xiRightLimit_(xiRightLimit), i_(std::complex<Real>(0.0, 1.0)) {}

        double operator()(double xi) const {
            double xiDash = (0.5+1e-8+0.5*xi) * xiRightLimit_; // Map xi to full range

            std::complex<Real> inner1 = parent_->Phi(1.0 + xiDash*i_, 0, T_, t_, cutoff_);
            std::complex<Real> inner2 = - K_*parent_->Phi(xiDash*i_, 0, T_, t_, cutoff_);

            return 0.5*xiRightLimit_*std::real((inner1 + inner2) * std::exp(-xiDash*logK_*i_) / (xiDash*i_));
        }
    };

    class AnalyticContinuousGeometricAveragePriceAsianHestonEngine::DcfIntegrand {
      private:
        Real t_, T_, denominator_;
        const Handle<YieldTermStructure> riskFreeRate_;
        const Handle<YieldTermStructure> dividendYield_;
      public:
        DcfIntegrand(Real t,
                     Real T,
                     Handle<YieldTermStructure> riskFreeRate,
                     Handle<YieldTermStructure> dividendYield)
        : t_(t), T_(T), riskFreeRate_(std::move(riskFreeRate)),
          dividendYield_(std::move(dividendYield)) {
            denominator_ = std::log(riskFreeRate_->discount(t_)) - std::log(dividendYield_->discount(t_));
        }

        double operator()(double u) const {
            double uDash = (0.5+1e-8+0.5*u) * (T_ - t_) + t_; // Map u to full range
            return 0.5*(T_ - t_)*(-std::log(riskFreeRate_->discount(uDash))
                               + std::log(dividendYield_->discount(uDash)) + denominator_);
        }
    };


    AnalyticContinuousGeometricAveragePriceAsianHestonEngine::
        AnalyticContinuousGeometricAveragePriceAsianHestonEngine(
            ext::shared_ptr<HestonProcess> process, Size summationCutoff, Real xiRightLimit)
    : process_(std::move(process)), a3_(0.0), a4_(0.0), a5_(0.0), summationCutoff_(summationCutoff),
      xiRightLimit_(xiRightLimit), integrator_(128) {
        registerWith(process_);

        v0_ = process_->v0();
        rho_ = process_->rho();
        kappa_ = process_->kappa();
        theta_ = process_->theta();
        sigma_ = process_->sigma();
        s0_ = process_->s0();

        riskFreeRate_ = process_->riskFreeRate();
        dividendYield_ = process_->dividendYield();

        // Some of the required constant intermediate variables can be calculated now
        // (although anything depending on T will need to be calculated dynamically later)
        a1_ = 2.0 * v0_ / (sigma_*sigma_);
        a2_ = 2.0 * kappa_ * theta_ / (sigma_*sigma_);
    }

    std::complex<Real> AnalyticContinuousGeometricAveragePriceAsianHestonEngine::z1_f(
            const std::complex<Real>& s, const std::complex<Real>& w, Real T) const {
        return s*s*(1-rho_*rho_)/(2*T*T);
    }

    std::complex<Real> AnalyticContinuousGeometricAveragePriceAsianHestonEngine::z2_f(
            const std::complex<Real>& s, const std::complex<Real>& w, Real T) const {
        return s*(2*rho_*kappa_ - sigma_)/(2*sigma_*T) + s*w*(1-rho_*rho_)/T;
    }

    std::complex<Real> AnalyticContinuousGeometricAveragePriceAsianHestonEngine::z3_f(
            const std::complex<Real>& s, const std::complex<Real>& w, Real T) const {
        return s*rho_/(sigma_*T) + 0.5*w*(2*rho_*kappa_ - sigma_)/sigma_ + 0.5*w*w*(1-rho_*rho_);
    }

    std::complex<Real> AnalyticContinuousGeometricAveragePriceAsianHestonEngine::z4_f(
            const std::complex<Real>& s, const std::complex<Real>& w) const {
        return w*rho_/sigma_;
    }

    std::complex<Real> AnalyticContinuousGeometricAveragePriceAsianHestonEngine::f(const std::complex<Real>& z1,
                                                                                   const std::complex<Real>& z2,
                                                                                   const std::complex<Real>& z3,
                                                                                   const std::complex<Real>& z4,
                                                                                   int n, // Can't use Size here as n can be negative
                                                                                   Real tau) const {;
        std::complex<Real> result;

        // This equation is highly recursive, use dynamic programming with a mutable variable
        // to record the results of previous calls
        if (n<2) {
            if (n<0) {
                result = 0.0;
            } else if (n==0) {
                result = 1.0;
            } else {
                result = 0.5*(kappa_ - z4*sigma_*sigma_)*tau;
            }
        } else {
            std::complex<Real> fMinusN[4];
            Real prefactor = -0.5*sigma_*sigma_*tau*tau / (n*(n-1));

            // For each offset, look up the value in the map and only evaluate function if it's not there
            for (int offset=1; offset<5; offset++) {
                int location = n-offset;
                std::map<int, std::complex<Real> >::const_iterator position = fLookupTable_.find(location);
                if (position != fLookupTable_.end()) {
                    std::complex<Real> value = position->second;
                    fMinusN[offset-1] = value;
                } else {
                    fMinusN[offset-1] = f(z1, z2, z3, z4, location, tau);
                }
            }

            result = prefactor * (z1*tau*tau*fMinusN[3] + z2*tau*fMinusN[2] + (z3 - 0.5*kappa_*kappa_/(sigma_*sigma_))*fMinusN[1]);
        }

        // Store this value in our mutable lookup map
        fLookupTable_[n] = result;

        return result;
    };

    std::pair<std::complex<Real>, std::complex<Real> >
        AnalyticContinuousGeometricAveragePriceAsianHestonEngine::F_F_tilde(
            const std::complex<Real>& z1,
            const std::complex<Real>& z2,
            const std::complex<Real>& z3,
            const std::complex<Real>& z4,
            Real tau,
            Size cutoff) const {
        std::complex<Real> temp = 0.0;
        std::complex<Real> runningSum1 = 0.0;
        std::complex<Real> runningSum2 = 0.0;

        for (Size i=0; i<cutoff; i++) {
            temp = f(z1, z2, z3, z4, i, tau);
            runningSum1 += temp;
            runningSum2 += temp*double(i)/tau;
        }

        std::pair<std::complex<Real>, std::complex<Real> > result(runningSum1, runningSum2);

        return result;
    };

    std::complex<Real> AnalyticContinuousGeometricAveragePriceAsianHestonEngine::Phi(
            const std::complex<Real>& s,
            const std::complex<Real>& w,
            Real T,
            Real t,
            Size cutoff) const {
        Real tau = T - t;

        std::complex<Real> z1 = z1_f(s, w, T);
        std::complex<Real> z2 = z2_f(s, w, T);
        std::complex<Real> z3 = z3_f(s, w, T);
        std::complex<Real> z4 = z4_f(s, w);

        // Clear the mutable lookup map before calling fLookupTable
        fLookupTable_ = std::map<int, std::complex<Real> >();
        std::pair<std::complex<Real>, std::complex<Real> > temp = F_F_tilde(z1, z2, z3, z4, tau, cutoff);

        std::complex<Real> F, F_tilde;
        F = temp.first;
        F_tilde = temp.second;

        return std::exp(-a1_*F_tilde/F - a2_*std::log(F) + a3_*s + a4_*w + a5_);
    }

    void AnalyticContinuousGeometricAveragePriceAsianHestonEngine::calculate() const {
        QL_REQUIRE(arguments_.averageType == Average::Geometric,
                   "not a geometric average option");
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real strike = payoff->strike();
        Date exercise = arguments_.exercise->lastDate();

        Time expiryTime = this->process_->time(exercise);
        QL_REQUIRE(expiryTime >= 0.0, "Expiry Date cannot be in the past");

        Real expiryDcf = riskFreeRate_->discount(expiryTime);
        Real expiryDividendDiscount = dividendYield_->discount(expiryTime);

        // TODO: extend to cover seasoned options (discussed in paper)
        Time startTime = 0.0;

        // These parameters only need to be calculated once per pricing, but are
        // functions of t and T so need to be reset in calculate()
        Time t = startTime;
        Time T = expiryTime;
        Time tau = T - t;
        Real logS0 = std::log(s0_->value());

        // To deal with non-constant rates and dividends, we reformulate Eq.s (14) to (17) with
        // r_ --> (r(t) - q(t)), which gives the new expressions for a3 and a4 used below
        Real dcf = riskFreeRate_->discount(T) / riskFreeRate_->discount(t);
        Real qdcf = dividendYield_->discount(T) / dividendYield_->discount(t);
        DcfIntegrand dcfIntegrand = DcfIntegrand(t, T, riskFreeRate_, dividendYield_);
        Real integratedDcf = integrator_(dcfIntegrand);

        a3_ = (tau*logS0 + integratedDcf)/T - kappa_*theta_*rho_*tau*tau/(2*sigma_*T) - rho_*tau*v0_/(sigma_*T);
        a4_ = logS0*qdcf/dcf - rho_*v0_/sigma_ + rho_*kappa_*theta_*tau/sigma_;
        a5_ = (kappa_*v0_ + kappa_*kappa_*theta_*tau) / (sigma_*sigma_);

        // Calculate the two terms in eq (29) - Phi(1,0) is real (asian forward) but need to type convert
        Real term1 = 0.5 * (std::real(Phi(1,0, T, t, summationCutoff_)) - strike);

        Integrand integrand(T, summationCutoff_, strike, this, xiRightLimit_);
        Real term2 = integrator_(integrand) / M_PI;

        // Apply the payoff functions
        Real value = 0.0;
        switch (payoff->optionType()){
            case Option::Call:
                value = expiryDcf * (term1 + term2);
                break;
            case Option::Put:
                value = expiryDcf * (-term1 + term2);
                break;
            default:
                QL_FAIL("unknown option type");
            }

        results_.value = value;

        results_.additionalResults["dcf"] = expiryDcf;
        results_.additionalResults["qf"] = expiryDividendDiscount;
        results_.additionalResults["s0"] = s0_->value();
        results_.additionalResults["strike"] = strike;
        results_.additionalResults["expiryTime"] = expiryTime;
        results_.additionalResults["exercise"] = exercise;

        results_.additionalResults["term1"] = term1;
        results_.additionalResults["term2"] = term2;
        results_.additionalResults["xiRightLimit"] = xiRightLimit_;
        results_.additionalResults["summationCutoff"] = summationCutoff_;

        results_.additionalResults["a1"] = a1_;
        results_.additionalResults["a2"] = a2_;
        results_.additionalResults["a3"] = a3_;
        results_.additionalResults["a4"] = a4_;
        results_.additionalResults["a5"] = a5_;
    }
}
]]></document_content>
  </document>
  <document index="14">
    <source>asian/analytic_cont_geom_av_price_heston.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytic_cont_geom_av_price.hpp
    \brief Analytic engine for continuous geometric average price Asian
           in the Heston model
*/

#ifndef quantlib_analytic_continuous_geometric_average_price_asian_heston_engine_hpp
#define quantlib_analytic_continuous_geometric_average_price_asian_heston_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/integrals/simpsonintegral.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! Pricing engine for European continuous geometric average price Asian
    /*! This class implements a continuous geometric average price
        Asian option with European exercise under the Heston stochastic
        vol model where spot and variance follow the processes

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d) S dt +\sqrt{v} S dW_1 \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dW_1 dW_2 &=& \rho dt \\
        \end{array}
        \f]

        References:

        Implements the analytical solution for continuous geometric Asian
        options developed in "Pricing of geometric Asian options under
        Heston's stochastic volatility model", B. Kim & I. S. Wee, Quantative
        Finance 14:10, 1795-1809 (2014)

        \ingroup asianengines

        \test
        - the correctness of the returned value is tested by reproducing
              results in Table 1 and Table 4 of the paper

        \todo handle seasoned options
    */
    class AnalyticContinuousGeometricAveragePriceAsianHestonEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        explicit AnalyticContinuousGeometricAveragePriceAsianHestonEngine(
            ext::shared_ptr<HestonProcess> process,
            Size summationCutoff = 50,
            Real xiRightLimit = 100.0);
        void calculate() const override;

        // Phi, defined in eq (25). Must be public so the integrand can access it (Could
        // use friend functions I think, but perhaps overkill?)
        std::complex<Real> Phi(const std::complex<Real>& s,
                               const std::complex<Real>& w,
                               Real T, Real t = 0.0, Size cutoff = 50) const;

      private:
        // Initial process params
        Real v0_, rho_, kappa_, theta_, sigma_;
        Handle<YieldTermStructure> dividendYield_;
        Handle<YieldTermStructure> riskFreeRate_;
        Handle<Quote> s0_;

        ext::shared_ptr<HestonProcess> process_;

        // Some intermediate calculation constant parameters
        Real a1_, a2_;
        mutable Real a3_, a4_, a5_;

        // A lookup table for the reuslts of f() to avoid repeated calls
        mutable std::map<int, std::complex<Real> > fLookupTable_;

        // Cutoff parameters for summation (19), (20) and for integral (29)
        Size summationCutoff_;
        Real xiRightLimit_;

        // Integrator for equation (29)
        GaussLegendreIntegration integrator_;

        // Integrands
        class Integrand;
        class DcfIntegrand;

        // Equations (13)
        std::complex<Real> z1_f(const std::complex<Real>& s, const std::complex<Real>& w, Real T) const;
        std::complex<Real> z2_f(const std::complex<Real>& s, const std::complex<Real>& w, Real T) const;
        std::complex<Real> z3_f(const std::complex<Real>& s, const std::complex<Real>& w, Real T) const;
        std::complex<Real> z4_f(const std::complex<Real>& s, const std::complex<Real>& w) const;

        // Equations (19), (20)
        std::pair<std::complex<Real>, std::complex<Real> > F_F_tilde(
                                        const std::complex<Real>& z1,
                                        const std::complex<Real>& z2,
                                        const std::complex<Real>& z3,
                                        const std::complex<Real>& z4,
                                        Real tau,
                                        Size cutoff = 50) const;

        // Equation (21)
        std::complex<Real> f(const std::complex<Real>& z1,
                             const std::complex<Real>& z2,
                             const std::complex<Real>& z3,
                             const std::complex<Real>& z4,
                             int n,
                             Real tau) const;
    };
}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>asian/analytic_discr_geom_av_price_heston.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020, 2021 Jack Gillett

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/asian/analytic_discr_geom_av_price_heston.hpp>
#include <utility>

namespace QuantLib {

    // A class to perform the integrations in Eqs (23) and (24)
    class AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::Integrand {
      private:
        Real t_, T_, K_, logK_;
        Size kStar_;
        const std::vector<Time> t_n_, tauK_;
        const AnalyticDiscreteGeometricAveragePriceAsianHestonEngine* const parent_;
        Real xiRightLimit_;
        std::complex<Real> i_;

      public:
        Integrand(Real t,
                  Real T,
                  Size kStar,
                  std::vector<Time> t_n,
                  std::vector<Time> tauK,
                  Real K,
                  const AnalyticDiscreteGeometricAveragePriceAsianHestonEngine* const parent,
                  Real xiRightLimit)
        : t_(t), T_(T), K_(K), logK_(std::log(K)), kStar_(kStar), t_n_(std::move(t_n)),
          tauK_(std::move(tauK)), parent_(parent), xiRightLimit_(xiRightLimit),
          i_(std::complex<Real>(0.0, 1.0)) {}

        double operator()(double xi) const {
            double xiDash = (0.5+1e-8+0.5*xi) * xiRightLimit_; // Map xi to full range

            std::complex<Real> inner1 = parent_->Phi(1.0 + xiDash*i_, 0, t_, T_, kStar_, t_n_, tauK_);
            std::complex<Real> inner2 = -K_*parent_->Phi(xiDash*i_, 0, t_, T_, kStar_, t_n_, tauK_);

            return 0.5*xiRightLimit_*std::real((inner1 + inner2) * std::exp(-xiDash*logK_*i_) / (xiDash*i_));
        }
    };


    AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::
        AnalyticDiscreteGeometricAveragePriceAsianHestonEngine(
            ext::shared_ptr<HestonProcess> process, Real xiRightLimit)
    : process_(std::move(process)), xiRightLimit_(xiRightLimit), integrator_(128) {
        registerWith(process_);

        v0_ = process_->v0();
        rho_ = process_->rho();
        kappa_ = process_->kappa();
        theta_ = process_->theta();
        sigma_ = process_->sigma();
        s0_ = process_->s0();
        logS0_ = std::log(s0_->value());

        riskFreeRate_ = process_->riskFreeRate();
        dividendYield_ = process_->dividendYield();
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::F(
            const std::complex<Real>& z1,
            const std::complex<Real>& z2,
            Time tau) const {
        std::complex<Real> temp = std::sqrt(kappa_*kappa_-2.0*z1*sigma_*sigma_);
        if (std::abs(kappa_*kappa_-2.0*sigma_*sigma_) < 1e-8) {
            return 1.0 + 0.5*(kappa_-z2*sigma_*sigma_);
        } else {
            return cosh(0.5*tau*temp) + (kappa_-z2*sigma_*sigma_)*sinh(0.5*tau*temp)/temp;
        }
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::F_tilde(
            const std::complex<Real>& z1,
            const std::complex<Real>& z2,
            Time tau) const {
        std::complex<Real> temp = std::sqrt(kappa_*kappa_ - 2.0*z1*sigma_*sigma_);
        return 0.5*temp*sinh(0.5*tau*temp) + 0.5*(kappa_ - z2*sigma_*sigma_)*cosh(0.5*tau*temp);
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::z(
            const std::complex<Real>& s, const std::complex<Real>& w, Size k, Size n) const {
        auto k_ = double(k);
        auto n_ = double(n);
        std::complex<Real> term1 = (2*rho_*kappa_ - sigma_)*((n_-k_+1)*s + n_*w)/(2*sigma_*n_);
        std::complex<Real> term2 = (1-rho_*rho_)*pow(((n_-k_+1)*s + n_*w), 2)/(2*n_*n_);

        return term1 + term2;
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::omega(
            const std::complex<Real>& s, const std::complex<Real>& w, Size k, Size kStar, Size n) const {
        if (k==kStar) {
            return 0;
        } else if (k==n+1) {
            return rho_*w/sigma_;
        } else {
            return rho_*s/(sigma_*n);
        }
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::a(
            const std::complex<Real>& s,
            const std::complex<Real>& w,
            Time t, Time T, Size kStar,
            const std::vector<Time>& t_n) const {
        auto kStar_ = double(kStar);
        auto n_ = double(t_n.size());
        Real temp = -rho_*kappa_*theta_/sigma_;

        Time summation = 0.0;
        Real summation2 = 0.0;
        for (Size i=kStar+1; i<=t_n.size(); i++) {
            summation += t_n[i-1];
            summation2 += tkr_tk_[i-1];
        }
        // This is Eq (16) modified for non-constant rates
        std::complex<Real> term1 = (s*(n_-kStar_)/n_ + w)*(logS0_ - rho_*v0_/sigma_ - t*temp - tr_t_);
        std::complex<Real> term2 = temp*(s*summation/n_ + w*T) + w*Tr_T_ + summation2*s/n_;

        return term1 + term2;
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::omega_tilde(
            const std::complex<Real>& s,
            const std::complex<Real>& w,
            Size k, Size kStar, Size n,
            const std::vector<Time>& tauK) const {
        std::complex<Real> omega_k = omega(s, w, k, kStar, n);
        if (k==n+1) {
            return omega_k;
        } else {
            Time dTauk = tauK[k+1] - tauK[k];
            std::complex<Real> z_kp1 = z(s, w, k+1, n);

            // omega_tilde calls itself recursivly, use lookup map to avoid extreme slowdown when k large
            std::complex<Real> omega_kp1 = 0.0;

            std::map<Size, std::complex<Real> >::const_iterator position = omegaTildeLookupTable_.find(k+1);

            if (position != omegaTildeLookupTable_.end()) {
                std::complex<Real> value = position->second;
                omega_kp1 = value;
            } else {
                omega_kp1 = omega_tilde(s, w, k+1, kStar, n, tauK);
            }

            std::complex<Real> ratio = F_tilde(z_kp1,omega_kp1,dTauk)/F(z_kp1,omega_kp1,dTauk);
            std::complex<Real> result = omega_k + kappa_/pow(sigma_,2) - 2.0*ratio/pow(sigma_,2);

            // Store this value in our mutable lookup map
            omegaTildeLookupTable_[k] = result;

            return result;
        }
    }

    std::complex<Real> AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::Phi(
            const std::complex<Real> s,
            const std::complex<Real> w,
            Time t, Time T, Size kStar,
            const std::vector<Time>& t_n,
            const std::vector<Time>& tauK) const {

        // Clear the mutable lookup map before evaluating Phi
        omegaTildeLookupTable_ = std::map<Size, std::complex<Real> >();

        Size n = t_n.size();
        std::complex<Real> aTerm = a(s, w, t, T, kStar, t_n);
        std::complex<Real> omegaTerm = v0_*omega_tilde(s, w, kStar, kStar, n, tauK);
        Real term3 = kappa_*kappa_*theta_*(T-t)/pow(sigma_,2);

        std::complex<Real> summation = 0.0;
        for (Size i=kStar+1; i<=n+1; i++) {
            Real dTau = tauK[i] - tauK[i-1];
            std::complex<Real> z_k = z(s, w, i, n);
            std::complex<Real> omega_tilde_k = omega_tilde(s, w, i, kStar, n, tauK);

            summation += std::log(F(z_k, omega_tilde_k, dTau));
        }
        std::complex<Real> term4 = 2*kappa_*theta_*summation/pow(sigma_,2);

        return std::exp(aTerm + omegaTerm + term3 - term4);
}

    void AnalyticDiscreteGeometricAveragePriceAsianHestonEngine::calculate() const {
        /* this engine cannot really check for the averageType==Geometric
           since it can be used as control variate for the Arithmetic version
        QL_REQUIRE(arguments_.averageType == Average::Geometric,
                   "not a geometric average option");
        */
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        Real runningLog;
        Size pastFixings;
        if (arguments_.averageType == Average::Geometric) {
            QL_REQUIRE(arguments_.runningAccumulator>0.0,
                       "positive running product required: "
                       << arguments_.runningAccumulator << " not allowed");
            runningLog = std::log(arguments_.runningAccumulator);
            pastFixings = arguments_.pastFixings;
        } else {  // it is being used as control variate
            runningLog = 0.0;
            pastFixings = 0;
        }

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real strike = payoff->strike();
        Date exercise = arguments_.exercise->lastDate();

        Time expiryTime = this->process_->time(exercise);
        QL_REQUIRE(expiryTime >= 0.0, "Expiry Date cannot be in the past");

        Real expiryDcf = riskFreeRate_->discount(expiryTime);

        Time startTime = 0.0;
        std::vector<Time> fixingTimes, tauK;
        for (auto& fixingDate : arguments_.fixingDates) {
            fixingTimes.push_back(this->process_->time(fixingDate));
        }
        std::sort(fixingTimes.begin(), fixingTimes.end());
        tauK = fixingTimes;

        // tauK is just a vector of the sorted future fixing times (ie. from the kStar element
        // onwards), with t pushed on the front and T pushed on the back!
        tauK.insert(tauK.begin(), startTime);
        tauK.push_back(expiryTime);

        // In the paper, seasoned asians are dealt with by letting the start time variable be greater
        // than 0. We can achieve the same by fixing the start time to 0.0, but attaching 'dummy'
        // fixing times at t=-1 for each past fixing, at the front of the fixing times arrays
        for (Size i=0; i<pastFixings; i++) {
            fixingTimes.insert(fixingTimes.begin(), -1.0);
            tauK.insert(tauK.begin(), -1.0);
        }

        Size kStar = pastFixings;

        // Need the log of some discount factors to calculate the r-adjusted a factor (Eq 16)
        tr_t_ = 0;
        Tr_T_ = 0;
        tkr_tk_ = std::vector<Real>();
        tr_t_ = -std::log(riskFreeRate_->discount(startTime) / dividendYield_->discount(startTime));
        Tr_T_ = -std::log(riskFreeRate_->discount(expiryTime) / dividendYield_->discount(expiryTime));
        for (double fixingTime : fixingTimes) {
            if (fixingTime < 0) {
                tkr_tk_.push_back(1.0);
            } else {
                tkr_tk_.push_back(-std::log(riskFreeRate_->discount(fixingTime) /
                                            dividendYield_->discount(fixingTime)));
            }
        }

        // To account for seasoning, we need to calculate an 'adjusted' strike (Eq 6)
        Real prefactor = std::exp(runningLog / fixingTimes.size());
        Real adjustedStrike = strike / prefactor;

        // Calculate the two terms in eq (23) - Phi(1,0) is real (asian forward) but need to type convert
        Real term1 = 0.5 * (std::real(Phi(1,0, startTime, expiryTime, kStar, fixingTimes, tauK)) - adjustedStrike);

        Integrand integrand(startTime, expiryTime, kStar, fixingTimes, tauK, adjustedStrike, this, xiRightLimit_);
        Real term2 = integrator_(integrand) / M_PI;

        // Apply the payoff functions
        Real value = 0.0;
        switch (payoff->optionType()){
            case Option::Call:
                value = expiryDcf * prefactor * (term1 + term2);
                break;
            case Option::Put:
                value = expiryDcf * prefactor * (-term1 + term2);
                break;
            default:
                QL_FAIL("unknown option type");
            }

        results_.value = value;

        results_.additionalResults["dcf"] = expiryDcf;
        results_.additionalResults["s0"] = s0_->value();
        results_.additionalResults["strike"] = strike;
        results_.additionalResults["expiryTime"] = expiryTime;
        results_.additionalResults["term1"] = term1;
        results_.additionalResults["term2"] = term2;
        results_.additionalResults["xiRightLimit"] = xiRightLimit_;
        results_.additionalResults["fixingTimes"] = fixingTimes;
        results_.additionalResults["tauK"] = tauK;
        results_.additionalResults["adjustedStrike"] = adjustedStrike;
        results_.additionalResults["prefactor"] = prefactor;
        results_.additionalResults["kStar"] = kStar;
    }
}
]]></document_content>
  </document>
  <document index="16">
    <source>asian/analytic_discr_geom_av_price_heston.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytic_cont_geom_av_price.hpp
    \brief Analytic engine for continuous geometric average price Asian
           in the Heston model
*/

#ifndef quantlib_analytic_discrete_geometric_average_price_asian_heston_engine_hpp
#define quantlib_analytic_discrete_geometric_average_price_asian_heston_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! Pricing engine for European discrete geometric average price Asian
    /*! This class implements a discrete geometric average price
        Asian option with European exercise under the Heston stochastic
        vol model where spot and variance follow the processes

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d) S dt +\sqrt{v} S dW_1 \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dW_1 dW_2 &=& \rho dt \\
        \end{array}
        \f]

        References:

        Implements the analytical solution for continuous geometric Asian
        options developed in "A Recursive Method for Discretely Monitored
        Geometric Asian Option Prices", B. Kim, J. Kim, J. Kim & I. S. Wee,
        Bull. Korean Math. Soc. 53, 733-749 (2016)

        \ingroup asianengines

        \test
        - the correctness of the returned value is tested by reproducing
              results in Tables 1, 2 and 3 of the paper

        \todo handle seasoned options
    */
    class AnalyticDiscreteGeometricAveragePriceAsianHestonEngine
        : public DiscreteAveragingAsianOption::engine {
      public:
        explicit AnalyticDiscreteGeometricAveragePriceAsianHestonEngine(
            ext::shared_ptr<HestonProcess> process, Real xiRightLimit = 100.0);
        void calculate() const override;

        // Equation (21) - must be public so the integrand can access it.
        std::complex<Real> Phi(std::complex<Real> s,
                               std::complex<Real> w,
                               Time t,
                               Time T,
                               Size kStar,
                               const std::vector<Time>& t_n,
                               const std::vector<Time>& tauK) const;

      private:
        // Initial process params
        Real v0_, rho_, kappa_, theta_, sigma_, logS0_;
        Handle<YieldTermStructure> dividendYield_;
        Handle<YieldTermStructure> riskFreeRate_;
        Handle<Quote> s0_;

        ext::shared_ptr<HestonProcess> process_;

        // A lookup table for the reuslts of omega_tilde() to avoid repeated calls for given Phi call
        mutable std::map<Size, std::complex<Real> > omegaTildeLookupTable_;

        // Cutoff parameter for integral in Eqs (23) and (24)
        Real xiRightLimit_;

        // Integrator for equation (23) and (24)
        GaussLegendreIntegration integrator_;

        // Integrand
        class Integrand;

        // We need to set up several variables inside calculate as they depend on fixing times. Rather
        // than pass them between a, omega, F etc. which makes for very messy method signatures, we
        // make them mutable class properties instead.
        mutable Real tr_t_;
        mutable Real Tr_T_;
        mutable std::vector<Real> tkr_tk_;

        // Equation (11)
        std::complex<Real> F(const std::complex<Real>& z1,
                             const std::complex<Real>& z2,
                             Time tau) const;

        std::complex<Real> F_tilde(const std::complex<Real>& z1,
                                   const std::complex<Real>& z2,
                                   Time tau) const;

        // Equation (14)
        std::complex<Real> z(const std::complex<Real>& s,
                             const std::complex<Real>& w,
                             Size k, Size n) const;

        // Equation (15)
        std::complex<Real> omega(const std::complex<Real>& s,
                                 const std::complex<Real>& w,
                                 Size k, Size kStar, Size n) const;

        // Equation (16)
        std::complex<Real> a(const std::complex<Real>& s,
                             const std::complex<Real>& w,
                             Time t, Time T, Size kStar,
                             const std::vector<Time>& t_n) const;

        // Equation (19)
        std::complex<Real> omega_tilde(const std::complex<Real>& s,
                                       const std::complex<Real>& w,
                                       Size k, Size kStar, Size n,
                                       const std::vector<Time>& tauK) const;
    };
}


#endif
]]></document_content>
  </document>
  <document index="17">
    <source>averageois/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    averageoiscouponpricer.hpp \
    arithmeticaverageois.hpp \
    arithmeticoisratehelper.hpp \
    makearithmeticaverageois.hpp

cpp_files = \
    averageoiscouponpricer.cpp \
    arithmeticaverageois.cpp \
    arithmeticoisratehelper.cpp \
    makearithmeticaverageois.cpp

if UNITY_BUILD

nodist_libAverageOIS_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libAverageOIS_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libAverageOIS.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="18">
    <source>averageois/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/averageois/averageoiscouponpricer.hpp>
#include <ql/experimental/averageois/arithmeticaverageois.hpp>
#include <ql/experimental/averageois/arithmeticoisratehelper.hpp>
#include <ql/experimental/averageois/makearithmeticaverageois.hpp>

]]></document_content>
  </document>
  <document index="19">
    <source>averageois/arithmeticaverageois.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/experimental/averageois/arithmeticaverageois.hpp>
#include <ql/experimental/averageois/averageoiscouponpricer.hpp>
#include <utility>

namespace QuantLib {

    ArithmeticAverageOIS::ArithmeticAverageOIS(Type type,
                                               Real nominal,
                                               const Schedule& fixedLegSchedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               ext::shared_ptr<OvernightIndex> overnightIndex,
                                               const Schedule& overnightLegSchedule,
                                               Spread spread,
                                               Real meanReversionSpeed,
                                               Real volatility,
                                               bool byApprox)
    : Swap(2), type_(type), nominals_(std::vector<Real>(1, nominal)),
      fixedLegPaymentFrequency_(fixedLegSchedule.tenor().frequency()),
      overnightLegPaymentFrequency_(overnightLegSchedule.tenor().frequency()),
      fixedRate_(fixedRate), fixedDC_(std::move(fixedDC)),
      overnightIndex_(std::move(overnightIndex)), spread_(spread), byApprox_(byApprox),
      mrs_(meanReversionSpeed), vol_(volatility) {

        initialize(fixedLegSchedule, overnightLegSchedule);
    }

    ArithmeticAverageOIS::ArithmeticAverageOIS(Type type,
                                               std::vector<Real> nominals,
                                               const Schedule& fixedLegSchedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               ext::shared_ptr<OvernightIndex> overnightIndex,
                                               const Schedule& overnightLegSchedule,
                                               Spread spread,
                                               Real meanReversionSpeed,
                                               Real volatility,
                                               bool byApprox)
    : Swap(2), type_(type), nominals_(std::move(nominals)),
      fixedLegPaymentFrequency_(fixedLegSchedule.tenor().frequency()),
      overnightLegPaymentFrequency_(overnightLegSchedule.tenor().frequency()),
      fixedRate_(fixedRate), fixedDC_(std::move(fixedDC)),
      overnightIndex_(std::move(overnightIndex)), spread_(spread), byApprox_(byApprox),
      mrs_(meanReversionSpeed), vol_(volatility) {

        initialize(fixedLegSchedule, overnightLegSchedule);
    }

    void ArithmeticAverageOIS::initialize(const Schedule& fixedLegSchedule,
                                          const Schedule& overnightLegSchedule) {
        if (fixedDC_==DayCounter())
            fixedDC_ = overnightIndex_->dayCounter();
        legs_[0] = FixedRateLeg(fixedLegSchedule)
            .withNotionals(nominals_)
            .withCouponRates(fixedRate_, fixedDC_);

        legs_[1] = OvernightLeg(overnightLegSchedule, overnightIndex_)
            .withNotionals(nominals_)
            .withSpreads(spread_);

        ext::shared_ptr<FloatingRateCouponPricer> arithmeticPricer(
                new ArithmeticAveragedOvernightIndexedCouponPricer(mrs_, vol_, byApprox_));

        for (auto& i : legs_[1]) {
            ext::shared_ptr<OvernightIndexedCoupon> c =
                ext::dynamic_pointer_cast<OvernightIndexedCoupon>(i);
            c->setPricer(arithmeticPricer);
        }

        for (Size j=0; j<2; ++j) {
            for (auto& i : legs_[j])
                registerWith(i);
        }

        switch (type_) {
          case Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          case Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          default:
            QL_FAIL("Unknown overnight-swap type");
        }
    }

    Real ArithmeticAverageOIS::fairRate() const {
        static Spread basisPoint = 1.0e-4;
        calculate();
        return fixedRate_ - NPV_/(fixedLegBPS()/basisPoint);
    }

    Spread ArithmeticAverageOIS::fairSpread() const {
        static Spread basisPoint = 1.0e-4;
        calculate();
        return spread_ - NPV_/(overnightLegBPS()/basisPoint);
    }

    Real ArithmeticAverageOIS::fixedLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real ArithmeticAverageOIS::overnightLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real ArithmeticAverageOIS::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real ArithmeticAverageOIS::overnightLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>averageois/arithmeticaverageois.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file arithmeticaverageois.hpp
    \brief Overnight index swap paying arithmetic average of overnight vs. fixed
*/

#ifndef quantlib_arithmetic_average_ois_hpp
#define quantlib_arithmetic_average_ois_hpp

#include <ql/instruments/swap.hpp>
#include <ql/time/daycounter.hpp>

namespace QuantLib {

    class Schedule;
    class OvernightIndex;

    //! Arithemtic Average OIS: fix vs arithmetic average of overnight rate
    class ArithmeticAverageOIS : public Swap {
      public:
        ArithmeticAverageOIS(Type type,
                             Real nominal,
                             const Schedule& fixedLegSchedule,
                             Rate fixedRate,
                             DayCounter fixedDC,
                             ext::shared_ptr<OvernightIndex> overnightIndex,
                             const Schedule& overnightLegSchedule,
                             Spread spread = 0.0,
                             Real meanReversionSpeed = 0.03,
                             Real volatility = 0.00, // NO convexity adjustment by default
                             bool byApprox = false); // TRUE to use Katsumi Takada approximation
        ArithmeticAverageOIS(Type type,
                             std::vector<Real> nominals,
                             const Schedule& fixedLegSchedule,
                             Rate fixedRate,
                             DayCounter fixedDC,
                             ext::shared_ptr<OvernightIndex> overnightIndex,
                             const Schedule& overnightLegSchedule,
                             Spread spread = 0.0,
                             Real meanReversionSpeed = 0.03,
                             Real volatility = 0.00, // NO convexity adjustment by default
                             bool byApprox = false); // TRUE to use Katsumi Takada approximation
        //! \name Inspectors
        //@{
        Type type() const { return type_; }
        Real nominal() const;
        std::vector<Real> nominals() const { return nominals_; }

        //const Schedule& schedule() { return schedule_; }
        Frequency fixedLegPaymentFrequency() { return fixedLegPaymentFrequency_; }
        Frequency overnightLegPaymentFrequency() { return overnightLegPaymentFrequency_; }

        Rate fixedRate() const { return fixedRate_; }
        const DayCounter& fixedDayCount() { return fixedDC_; }

        const ext::shared_ptr<OvernightIndex>& overnightIndex() { return overnightIndex_; }
        Spread spread() const { return spread_; }

        const Leg& fixedLeg() const { return legs_[0]; }
        const Leg& overnightLeg() const { return legs_[1]; }
        //@}

        //! \name Results
        //@{
        Real fixedLegBPS() const;
        Real fixedLegNPV() const;
        Real fairRate() const;

        Real overnightLegBPS() const;
        Real overnightLegNPV() const;
        Spread fairSpread() const;
        //@}
      private:
        void initialize(const Schedule& fixedLegSchedule,
                        const Schedule& overnightLegSchedule);
        Type type_;
        std::vector<Real> nominals_;

        Frequency fixedLegPaymentFrequency_;
        Frequency overnightLegPaymentFrequency_;
        //Schedule schedule_;

        Rate fixedRate_;
        DayCounter fixedDC_;

        ext::shared_ptr<OvernightIndex> overnightIndex_;
        Spread spread_;

        bool byApprox_;
        Real mrs_;
        Real vol_;
    };


    // inline

    inline Real ArithmeticAverageOIS::nominal() const {
        QL_REQUIRE(nominals_.size()==1, "varying nominals");
        return nominals_[0];
    }

}

#endif
]]></document_content>
  </document>
  <document index="21">
    <source>averageois/arithmeticoisratehelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/averageois/arithmeticoisratehelper.hpp>
#include <ql/experimental/averageois/makearithmeticaverageois.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        void no_deletion(YieldTermStructure*) {}
    }

    ArithmeticOISRateHelper::ArithmeticOISRateHelper(Natural settlementDays,
                                                     const Period& tenor, // swap maturity
                                                     Frequency fixedLegPaymentFrequency,
                                                     const Handle<Quote>& fixedRate,
                                                     ext::shared_ptr<OvernightIndex> overnightIndex,
                                                     Frequency overnightLegPaymentFrequency,
                                                     Handle<Quote> spread,
                                                     Real meanReversionSpeed,
                                                     Real volatility,
                                                     bool byApprox,
                                                     Handle<YieldTermStructure> discount)
    : RelativeDateRateHelper(fixedRate), settlementDays_(settlementDays), tenor_(tenor),
      overnightIndex_(std::move(overnightIndex)), discountHandle_(std::move(discount)),
      fixedLegPaymentFrequency_(fixedLegPaymentFrequency),
      overnightLegPaymentFrequency_(overnightLegPaymentFrequency), spread_(std::move(spread)),
      mrs_(meanReversionSpeed), vol_(volatility), byApprox_(byApprox) {
        registerWith(overnightIndex_);
        registerWith(discountHandle_);
        registerWith(spread_);
        initializeDates();
    }

    void ArithmeticOISRateHelper::initializeDates() {

        // dummy OvernightIndex with curve/swap arguments
        // review here
        ext::shared_ptr<IborIndex> clonedIborIndex =
            overnightIndex_->clone(termStructureHandle_);
        ext::shared_ptr<OvernightIndex> clonedOvernightIndex =
            ext::dynamic_pointer_cast<OvernightIndex>(clonedIborIndex);

       swap_ = MakeArithmeticAverageOIS(tenor_, clonedOvernightIndex, 0.0)
                .withDiscountingTermStructure(discountRelinkableHandle_)
                .withSettlementDays(settlementDays_)
                .withFixedLegPaymentFrequency(fixedLegPaymentFrequency_)
                .withOvernightLegPaymentFrequency(overnightLegPaymentFrequency_)
                .withArithmeticAverage(mrs_, vol_, byApprox_);
        
        earliestDate_ = swap_->startDate();
        latestDate_ = swap_->maturityDate();
    }

    void ArithmeticOISRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, no_deletion);
        termStructureHandle_.linkTo(temp, observer);

        if (discountHandle_.empty())
            discountRelinkableHandle_.linkTo(temp, observer);
        else
            discountRelinkableHandle_.linkTo(*discountHandle_, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    Real ArithmeticOISRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        // we didn't register as observers - force calculation
        swap_->recalculate();
        //return swap_->fairRate();
        // weak implementation... to be improved
        static const Spread basisPoint = 1.0e-4;
        Real floatingLegNPV = swap_->overnightLegNPV();
        Spread spread = spread_.empty() ? 0.0 : spread_->value();
        Real spreadNPV = swap_->overnightLegBPS() / basisPoint*spread;
        Real totNPV = -(floatingLegNPV + spreadNPV);
        Real result = totNPV / (swap_->fixedLegBPS() / basisPoint);
        return result;
    }

    void ArithmeticOISRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<ArithmeticOISRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="22">
    <source>averageois/arithmeticoisratehelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file arithmeticoisratehelper.hpp
    \brief Arithmetic Average Overnight Indexed Swap rate helpers
*/

#ifndef quantlib_arithmeticoisratehelper_hpp
#define quantlib_arithmeticoisratehelper_hpp

#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/experimental/averageois/arithmeticaverageois.hpp>

namespace QuantLib {

    //! Rate helper for bootstrapping over Overnight Indexed Swap rates
    class ArithmeticOISRateHelper : public RelativeDateRateHelper {
      public:
        ArithmeticOISRateHelper(
            Natural settlementDays,
            const Period& tenor, // swap maturity
            Frequency fixedLegPaymentFrequency,
            const Handle<Quote>& fixedRate,
            ext::shared_ptr<OvernightIndex> overnightIndex,
            Frequency overnightLegPaymentFrequency,
            Handle<Quote> spread,
            Real meanReversionSpeed = 0.03,
            Real volatility = 0.00, // NO convexity adjustment by default
            bool byApprox = false,  // TRUE to use Katsumi Takada approximation
            // exogenous discounting curve
            Handle<YieldTermStructure> discountingCurve = Handle<YieldTermStructure>());
        //! \name RateHelper interface
        //@{
          Real impliedQuote() const override;
          void setTermStructure(YieldTermStructure*) override;
          //@}
          //! \name inspectors
          //@{
          ext::shared_ptr<ArithmeticAverageOIS> swap() const { return swap_; }
          //@}
          //! \name Visitability
          //@{
          void accept(AcyclicVisitor&) override;
          //@}
        protected:
          void initializeDates() override;

          Natural settlementDays_;
          Period tenor_;
          ext::shared_ptr<OvernightIndex> overnightIndex_;

          ext::shared_ptr<ArithmeticAverageOIS> swap_;
          RelinkableHandle<YieldTermStructure> termStructureHandle_;

          Handle<YieldTermStructure> discountHandle_;
          RelinkableHandle<YieldTermStructure> discountRelinkableHandle_;

          Frequency fixedLegPaymentFrequency_;
          Frequency overnightLegPaymentFrequency_;
          Handle<Quote> spread_;

          Real mrs_;
          Real vol_;
          bool byApprox_;
 
    };

}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>averageois/averageoiscouponpricer.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/averageois/averageoiscouponpricer.hpp>
#include <cmath>

using std::vector;
using std::exp;
using std::pow;
using std::log;

namespace QuantLib {

    void ArithmeticAveragedOvernightIndexedCouponPricer::initialize(
                                            const FloatingRateCoupon& coupon) {
        coupon_ = dynamic_cast<const OvernightIndexedCoupon*>(&coupon);
        QL_ENSURE(coupon_, "wrong coupon type");
    }

    Rate ArithmeticAveragedOvernightIndexedCouponPricer::swapletRate() const {

        ext::shared_ptr<OvernightIndex> index =
            ext::dynamic_pointer_cast<OvernightIndex>(coupon_->index());

        const vector<Date>& fixingDates = coupon_->fixingDates();
        const vector<Time>& dt = coupon_->dt();

        Size n = dt.size(),
            i = 0;

        Real accumulatedRate = 0.0;

        // already fixed part
        Date today = Settings::instance().evaluationDate();
        while (i < n && fixingDates[i] < today) {
            // rate must have been fixed
            Rate pastFixing = IndexManager::instance().getHistory(
                index->name())[fixingDates[i]];
            QL_REQUIRE(pastFixing != Null<Real>(),
                "Missing " << index->name() <<
                " fixing for " << fixingDates[i]);
            accumulatedRate += pastFixing*dt[i];
            ++i;
        }

        // today is a border case
        if (i < n && fixingDates[i] == today) {
            // might have been fixed
            try {
                Rate pastFixing = IndexManager::instance().getHistory(
                    index->name())[fixingDates[i]];
                if (pastFixing != Null<Real>()) {
                    accumulatedRate += pastFixing*dt[i];
                    ++i;
                }
                else {
                    ;   // fall through and forecast
                }
            }
            catch (Error&) {
                ;       // fall through and forecast
            }
        }

        /* forward part using telescopic property in order
        to avoid the evaluation of multiple forward fixings
        (approximation proposed by Katsumi Takada)*/
        if (byApprox_ && i < n) {
            Handle<YieldTermStructure> curve =
                index->forwardingTermStructure();
            QL_REQUIRE(!curve.empty(),
                "null term structure set to this instance of " <<
                index->name());

            const vector<Date>& dates = coupon_->valueDates();
            DiscountFactor startDiscount = curve->discount(dates[i]);
            DiscountFactor endDiscount = curve->discount(dates[n]);

            accumulatedRate += log(startDiscount / endDiscount) - 
                convAdj1(curve->timeFromReference(dates[i]),
                         curve->timeFromReference(dates[n])) -
                convAdj2(curve->timeFromReference(dates[i]),
                         curve->timeFromReference(dates[n]));
        }
        // otherwise
        else if (i < n){
            Handle<YieldTermStructure> curve =
                index->forwardingTermStructure();
            QL_REQUIRE(!curve.empty(),
                "null term structure set to this instance of " <<
                index->name());

            const vector<Date>& dates = coupon_->valueDates();
            Time te = curve->timeFromReference(dates[n]);
            while (i < n) {
                // forcast fixing
                Rate forecastFixing = index->fixing(fixingDates[i]);
                Time ti1 = curve->timeFromReference(dates[i]);
                Time ti2 = curve->timeFromReference(dates[i + 1]);
                /*convexity adjustment due to payment dalay of each
                overnight fixing, supposing an Hull-White short rate model*/
                Real convAdj = exp( 0.5*pow(vol_, 2.0) / pow(mrs_, 3.0)*
                    (exp(2 * mrs_*ti1) - 1)*
                    (exp(-mrs_*ti2) - exp(-mrs_*te))*
                    (exp(-mrs_*ti2) - exp(-mrs_*ti1)) );
                accumulatedRate += convAdj*(1 + forecastFixing*dt[i]) - 1;
                ++i;
            }
        }

        Rate rate = accumulatedRate / coupon_->accrualPeriod();
        return coupon_->gearing() * rate + coupon_->spread();
    }

    Real ArithmeticAveragedOvernightIndexedCouponPricer::convAdj1(
                                                    Time ts, Time te) const {
        return vol_ * vol_ / (4.0 * pow(mrs_, 3.0)) *
            (1.0 - exp(-2.0*mrs_*ts)) *
            pow((1.0 - exp(-mrs_*(te - ts))), 2.0);
    }

    Real ArithmeticAveragedOvernightIndexedCouponPricer::convAdj2(
                                                    Time ts, Time te) const {
        return vol_ * vol_ / (2.0 * pow(mrs_, 2.0)) * ((te - ts) -
            pow(1.0 - exp(-mrs_*(te - ts)), 2.0) / mrs_ -
            (1.0 - exp(-2.0*mrs_*(te - ts))) / (2.0 * mrs_));
    }

}

]]></document_content>
  </document>
  <document index="24">
    <source>averageois/averageoiscouponpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file averageoiscouponpricer.hpp
    \brief pricer for arithmetically-averaged overnight-indexed coupons
*/

#ifndef quantlib_average_ois_coupon_pricer_hpp
#define quantlib_average_ois_coupon_pricer_hpp

#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>

namespace QuantLib {

    /*! pricer for arithmetically averaged overnight indexed coupons
    Reference: Katsumi Takada 2011, Valuation of Arithmetically Average of
    Fed Funds Rates and Construction of the US Dollar Swap Yield Curve
    */
    class ArithmeticAveragedOvernightIndexedCouponPricer
                                         : public FloatingRateCouponPricer {
    public:
        explicit ArithmeticAveragedOvernightIndexedCouponPricer(
            Real meanReversion = 0.03,
            Real volatility = 0.00, // NO convexity adjustment by default
            bool byApprox = false) // TRUE to use Katsumi Takada approximation
        : byApprox_(byApprox), mrs_(meanReversion), vol_(volatility) {}

        explicit ArithmeticAveragedOvernightIndexedCouponPricer(
            bool byApprox)  // Simplified constructor assuming no convexity correction
        : ArithmeticAveragedOvernightIndexedCouponPricer(0.03, 0.0, byApprox) {}

        void initialize(const FloatingRateCoupon& coupon) override;
        Rate swapletRate() const override;
        Real swapletPrice() const override { QL_FAIL("swapletPrice not available"); }
        Real capletPrice(Rate) const override { QL_FAIL("capletPrice not available"); }
        Rate capletRate(Rate) const override { QL_FAIL("capletRate not available"); }
        Real floorletPrice(Rate) const override { QL_FAIL("floorletPrice not available"); }
        Rate floorletRate(Rate) const override { QL_FAIL("floorletRate not available"); }

      protected:
        Real convAdj1(Time ts, Time te) const;
        Real convAdj2(Time ts, Time te) const;
        const OvernightIndexedCoupon* coupon_;
        bool byApprox_;
        Real mrs_;
        Real vol_;

    };

}

#endif
]]></document_content>
  </document>
  <document index="25">
    <source>averageois/makearithmeticaverageois.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/averageois/makearithmeticaverageois.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    MakeArithmeticAverageOIS::MakeArithmeticAverageOIS(
                     const Period& swapTenor,
                     const ext::shared_ptr<OvernightIndex>& overnightIndex,
                     Rate fixedRate,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), overnightIndex_(overnightIndex),
      fixedRate_(fixedRate), forwardStart_(forwardStart),
      settlementDays_(2),
      calendar_(overnightIndex->fixingCalendar()),
      fixedLegPaymentFrequency_(Annual),
      overnightLegPaymentFrequency_(Annual),
      rule_(DateGeneration::Backward),
      // any value here for endOfMonth_ would not be actually used
      isDefaultEOM_(true),
      byApprox_(false),
      mrs_(0.03),
      vol_(0.00),
      type_(Swap::Payer), nominal_(1.0),
      overnightSpread_(0.0),
      fixedDayCount_(overnightIndex->dayCounter()) {}

    MakeArithmeticAverageOIS::operator ArithmeticAverageOIS() const {
        ext::shared_ptr<ArithmeticAverageOIS> ois = *this;
        return *ois;
    }

    MakeArithmeticAverageOIS::operator ext::shared_ptr<ArithmeticAverageOIS>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = calendar_.adjust(refDate);
            Date spotDate = calendar_.advance(refDate,
                                              settlementDays_*Days);
            startDate = spotDate+forwardStart_;
            if (forwardStart_.length()<0)
                startDate = calendar_.adjust(startDate, Preceding);
            else
                startDate = calendar_.adjust(startDate, Following);
        }

        // OIS end of month default
        bool usedEndOfMonth = 
            isDefaultEOM_ ? calendar_.isEndOfMonth(startDate) : endOfMonth_;

        Date endDate = terminationDate_;
        if (endDate == Date()) {
            if (usedEndOfMonth)
                endDate = calendar_.advance(startDate,
                                            swapTenor_,
                                            ModifiedFollowing,
                                            usedEndOfMonth);
            else
                endDate = startDate + swapTenor_;
        }

        Schedule fixedLegSchedule(startDate, endDate,
                          Period(fixedLegPaymentFrequency_),
                          calendar_,
                          ModifiedFollowing,
                          ModifiedFollowing,
                          rule_,
                          usedEndOfMonth);

        Schedule overnightLegSchedule(startDate, endDate,
                          Period(overnightLegPaymentFrequency_),
                          calendar_,
                          ModifiedFollowing,
                          ModifiedFollowing,
                          rule_,
                          usedEndOfMonth);

        Rate usedFixedRate = fixedRate_;
        if (fixedRate_ == Null<Rate>()) {
            ArithmeticAverageOIS temp(type_, nominal_,
                                      fixedLegSchedule,
                                      0.0, // fixed rate
                                      fixedDayCount_,
                                      overnightIndex_,
                                      overnightLegSchedule,
                                      overnightSpread_,
                                      mrs_, vol_, byApprox_);
            if (engine_ == nullptr) {
                Handle<YieldTermStructure> disc =
                                    overnightIndex_->forwardingTermStructure();
                QL_REQUIRE(!disc.empty(),
                           "null term structure set to this instance of " <<
                           overnightIndex_->name());
                bool includeSettlementDateFlows = false;
                ext::shared_ptr<PricingEngine> engine(new
                    DiscountingSwapEngine(disc, includeSettlementDateFlows));
                temp.setPricingEngine(engine);
            } else
                temp.setPricingEngine(engine_);

            usedFixedRate = temp.fairRate();
        }

        ext::shared_ptr<ArithmeticAverageOIS> ois(new
            ArithmeticAverageOIS(type_, nominal_,
                                 fixedLegSchedule,
                                 usedFixedRate, fixedDayCount_,
                                 overnightIndex_,
                                 overnightLegSchedule,
                                 overnightSpread_,
                                 mrs_, vol_, byApprox_));

        if (engine_ == nullptr) {
            Handle<YieldTermStructure> disc =
                                overnightIndex_->forwardingTermStructure();
            bool includeSettlementDateFlows = false;
            ext::shared_ptr<PricingEngine> engine(new
                DiscountingSwapEngine(disc, includeSettlementDateFlows));
            ois->setPricingEngine(engine);
        } else
            ois->setPricingEngine(engine_);

        return ois;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::receiveFixed(bool flag) {
        type_ = flag ? Swap::Receiver : Swap::Payer;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withType(Swap::Type type) {
        type_ = type;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withSettlementDays(Natural settlementDays) {
        settlementDays_ = settlementDays;
        effectiveDate_ = Date();
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withTerminationDate(const Date& terminationDate) {
        terminationDate_ = terminationDate;
        swapTenor_ = Period();
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withFixedLegPaymentFrequency(Frequency f) {
        fixedLegPaymentFrequency_ = f;
        if (fixedLegPaymentFrequency_ == Once)
            rule_ = DateGeneration::Zero;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withOvernightLegPaymentFrequency(Frequency f) {
        overnightLegPaymentFrequency_ = f;
        if (overnightLegPaymentFrequency_ == Once)
            rule_ = DateGeneration::Zero;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withRule(DateGeneration::Rule r) {
        rule_ = r;
        if (r==DateGeneration::Zero) {
            fixedLegPaymentFrequency_ = Once;
            overnightLegPaymentFrequency_ = Once;
        }
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withDiscountingTermStructure(
                                        const Handle<YieldTermStructure>& d) {
        bool includeSettlementDateFlows = false;
        engine_ = ext::shared_ptr<PricingEngine>(new
            DiscountingSwapEngine(d, includeSettlementDateFlows));
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withFixedLegDayCount(const DayCounter& dc) {
        fixedDayCount_ = dc;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withEndOfMonth(bool flag) {
        endOfMonth_ = flag;
        isDefaultEOM_ = false;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withOvernightLegSpread(Spread sp) {
        overnightSpread_ = sp;
        return *this;
    }

    MakeArithmeticAverageOIS& MakeArithmeticAverageOIS::withArithmeticAverage(
                                            Real meanReversionSpeed,
                                            Real volatility,
                                            bool byApprox) {
        mrs_ = meanReversionSpeed;
        vol_ = volatility;
        byApprox_ = byApprox;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="26">
    <source>averageois/makearithmeticaverageois.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Stefano Fondi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makeois.hpp
    \brief Helper class to instantiate overnight indexed swaps.
*/

#ifndef quantlib_makearithmeticaverageois_hpp
#define quantlib_makearithmeticaverageois_hpp

#include <ql/experimental/averageois/arithmeticaverageois.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! helper class
    /*! This class provides a more comfortable way
        to instantiate arithemtic average overnight indexed swaps.
    */
    class MakeArithmeticAverageOIS {
      public:
        MakeArithmeticAverageOIS(const Period& swapTenor,
                const ext::shared_ptr<OvernightIndex>& overnightIndex,
                Rate fixedRate = Null<Rate>(),
                const Period& fwdStart = 0*Days);

        operator ArithmeticAverageOIS() const;
        operator ext::shared_ptr<ArithmeticAverageOIS>() const;

        MakeArithmeticAverageOIS& receiveFixed(bool flag = true);
        MakeArithmeticAverageOIS& withType(Swap::Type type);
        MakeArithmeticAverageOIS& withNominal(Real n);

        MakeArithmeticAverageOIS& withSettlementDays(Natural settlementDays);
        MakeArithmeticAverageOIS& withEffectiveDate(const Date&);
        MakeArithmeticAverageOIS& withTerminationDate(const Date&);
        MakeArithmeticAverageOIS& withRule(DateGeneration::Rule r);

        MakeArithmeticAverageOIS& withFixedLegPaymentFrequency(Frequency f);
        MakeArithmeticAverageOIS& withOvernightLegPaymentFrequency(Frequency f);
        MakeArithmeticAverageOIS& withEndOfMonth(bool flag = true);

        MakeArithmeticAverageOIS& withFixedLegDayCount(const DayCounter& dc);

        MakeArithmeticAverageOIS& withOvernightLegSpread(Spread sp);

        MakeArithmeticAverageOIS& withDiscountingTermStructure(
                  const Handle<YieldTermStructure>& discountingTermStructure);
        MakeArithmeticAverageOIS& withPricingEngine(
                              const ext::shared_ptr<PricingEngine>& engine);
        MakeArithmeticAverageOIS& withArithmeticAverage(
                                       Real meanReversionSpeed = 0.03,
                                       Real volatility = 0.00, // NO convexity adjustment by default
                                       bool byApprox = false); // TRUE to use Katsumi Takada approximation
      private:
        Period swapTenor_;
        ext::shared_ptr<OvernightIndex> overnightIndex_;
        Rate fixedRate_;
        Period forwardStart_;

        Natural settlementDays_;
        Date effectiveDate_, terminationDate_;
        Calendar calendar_;

        Frequency fixedLegPaymentFrequency_;
        Frequency overnightLegPaymentFrequency_;
        DateGeneration::Rule rule_;
        bool endOfMonth_, isDefaultEOM_;

        bool byApprox_;
        Real mrs_;
        Real vol_;

        Swap::Type type_;
        Real nominal_;

        Spread overnightSpread_;
        DayCounter fixedDayCount_;

        ext::shared_ptr<PricingEngine> engine_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="27">
    <source>barrieroption/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    analyticdoublebarrierbinaryengine.hpp \
	analyticdoublebarrierengine.hpp \
	mcdoublebarrierengine.hpp \
    binomialdoublebarrierengine.hpp \
    discretizeddoublebarrieroption.hpp \
    doublebarrieroption.hpp \
    doublebarriertype.hpp \
    perturbativebarrieroptionengine.hpp \
    quantodoublebarrieroption.hpp \
    vannavolgabarrierengine.hpp \
    vannavolgadoublebarrierengine.hpp \
    vannavolgainterpolation.hpp \
    wulinyongdoublebarrierengine.hpp

cpp_files = \
    analyticdoublebarrierbinaryengine.cpp \
	analyticdoublebarrierengine.cpp \
	mcdoublebarrierengine.cpp \
    discretizeddoublebarrieroption.cpp \
    doublebarrieroption.cpp \
    doublebarriertype.cpp \
    perturbativebarrieroptionengine.cpp \
    quantodoublebarrieroption.cpp \
    vannavolgabarrierengine.cpp \
    wulinyongdoublebarrierengine.cpp

if UNITY_BUILD

nodist_libBarrierOption_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libBarrierOption_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libBarrierOption.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="28">
    <source>barrieroption/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/mcdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/binomialdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/discretizeddoublebarrieroption.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/doublebarriertype.hpp>
#include <ql/experimental/barrieroption/perturbativebarrieroptionengine.hpp>
#include <ql/experimental/barrieroption/quantodoublebarrieroption.hpp>
#include <ql/experimental/barrieroption/vannavolgabarrierengine.hpp>
#include <ql/experimental/barrieroption/vannavolgadoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/vannavolgainterpolation.hpp>
#include <ql/experimental/barrieroption/wulinyongdoublebarrierengine.hpp>

]]></document_content>
  </document>
  <document index="29">
    <source>barrieroption/analyticdoublebarrierbinaryengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.hpp>
#include <utility>

using std::fabs;

namespace QuantLib {

   // number of iterations ...
   static Real PI= 3.14159265358979323846264338327950;

    // calc helper object 
    class AnalyticDoubleBarrierBinaryEngine_helper
    {
    
    public:
        AnalyticDoubleBarrierBinaryEngine_helper(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const ext::shared_ptr<CashOrNothingPayoff> &payoff,
             const DoubleBarrierOption::arguments &arguments):
        process_(process),
        payoff_(payoff),
        arguments_(arguments)
        {
        }

        Real payoffAtExpiry(Real spot, Real variance,
                            DoubleBarrier::Type barrierType,
                            Size maxIteration = 100,
                            Real requiredConvergence = 1e-8);
        Real payoffKIKO(Real spot, Real variance,
                        DoubleBarrier::Type barrierType,
                        Size maxIteration = 1000,
                        Real requiredConvergence = 1e-8);

    private:

        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process_;
        const ext::shared_ptr<CashOrNothingPayoff> &payoff_;
        const DoubleBarrierOption::arguments &arguments_;
    };


    // helper object methods
    Real AnalyticDoubleBarrierBinaryEngine_helper::payoffAtExpiry(
         Real spot, Real variance, DoubleBarrier::Type barrierType,
         Size maxIteration, Real requiredConvergence)
    {
        QL_REQUIRE(spot>0.0,
                   "positive spot value required");

        QL_REQUIRE(variance>=0.0,
                   "negative variance not allowed");

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        QL_REQUIRE(residualTime>0.0,
                   "expiration time must be > 0");

        // Option::Type type   = payoff_->optionType(); // this is not used ?
        Real cash = payoff_->cashPayoff();
        Real barrier_lo = arguments_.barrier_lo;
        Real barrier_hi = arguments_.barrier_hi;

        Real sigmaq = variance/residualTime;
        Real r = process_->riskFreeRate()->zeroRate(residualTime, Continuous,
                                             NoFrequency);
        Real q = process_->dividendYield()->zeroRate(residualTime,
                                                   Continuous, NoFrequency);
        Real b = r - q;

        Real alpha = -0.5 * ( 2*b/sigmaq - 1);
        Real beta = -0.25 * std::pow(( 2*b/sigmaq - 1), 2) - 2 * r/sigmaq;
        Real Z = std::log(barrier_hi / barrier_lo);
        Real factor = ((2*PI*cash)/std::pow(Z,2)); // common factor
        Real lo_alpha = std::pow(spot/barrier_lo, alpha); 
        Real hi_alpha = std::pow(spot/barrier_hi, alpha); 

        Real tot = 0, term = 0;
        for (Size i = 1 ; i < maxIteration ; ++i)
        {
           Real term1 = (lo_alpha-std::pow(-1.0, (int)i)*hi_alpha) /
                              (std::pow(alpha,2)+std::pow(i*PI/Z, 2));
           Real term2 = std::sin(i*PI/Z * std::log(spot/barrier_lo));
           Real term3 = std::exp(-0.5*(std::pow(i*PI/Z,2)-beta)*variance);
           term = factor * i * term1 * term2 * term3;
           tot += term;
        }

        // Check if convergence is sufficiently fast (for extreme parameters with big alpha the convergence can be very
        // poor, see for example Hui "One-touch double barrier binary option value")
        QL_REQUIRE(std::fabs(term) < requiredConvergence, "serie did not converge sufficiently fast");

        if (barrierType == DoubleBarrier::KnockOut)
           return std::max(tot, 0.0); // KO
        else {
           Rate discount = process_->riskFreeRate()->discount(
                                             arguments_.exercise->lastDate());
           QL_REQUIRE(discount>0.0,
                        "positive discount required");
           return std::max(cash * discount - tot, 0.0); // KI
        }
    }

    // helper object methods
    Real AnalyticDoubleBarrierBinaryEngine_helper::payoffKIKO(
         Real spot, Real variance, DoubleBarrier::Type barrierType,
         Size maxIteration, Real requiredConvergence)
    {
        QL_REQUIRE(spot>0.0,
                   "positive spot value required");

        QL_REQUIRE(variance>=0.0,
                   "negative variance not allowed");

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        QL_REQUIRE(residualTime>0.0,
                   "expiration time must be > 0");

        Real cash = payoff_->cashPayoff();
        Real barrier_lo = arguments_.barrier_lo;
        Real barrier_hi = arguments_.barrier_hi;
        if (barrierType == DoubleBarrier::KOKI)
           std::swap(barrier_lo, barrier_hi);

        Real sigmaq = variance/residualTime;
        Real r = process_->riskFreeRate()->zeroRate(residualTime, Continuous,
                                             NoFrequency);
        Real q = process_->dividendYield()->zeroRate(residualTime,
                                                   Continuous, NoFrequency);
        Real b = r - q;

        Real alpha = -0.5 * ( 2*b/sigmaq - 1);
        Real beta = -0.25 * std::pow(( 2*b/sigmaq - 1), 2) - 2 * r/sigmaq;
        Real Z = std::log(barrier_hi / barrier_lo);
        Real log_S_L = std::log(spot / barrier_lo);

        Real tot = 0, term = 0;
        for (Size i = 1 ; i < maxIteration ; ++i)
        {
            Real factor = std::pow(i*PI/Z,2)-beta;
            Real term1 = (beta - std::pow(i*PI/Z,2) * std::exp(-0.5*factor*variance)) / factor;
            Real term2 = std::sin(i * PI/Z * log_S_L);
            term = (2.0/(i*PI)) * term1 * term2;
            tot += term;
        }
        tot += 1 - log_S_L / Z;
        tot *= cash*std::pow(spot/barrier_lo, alpha);

        // Check if convergence is sufficiently fast
        QL_REQUIRE(fabs(term) < requiredConvergence, "serie did not converge sufficiently fast");

        return std::max(tot, 0.0);
    }

    AnalyticDoubleBarrierBinaryEngine::AnalyticDoubleBarrierBinaryEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticDoubleBarrierBinaryEngine::calculate() const {

        if (arguments_.barrierType == DoubleBarrier::KIKO ||
            arguments_.barrierType == DoubleBarrier::KOKI) {
            ext::shared_ptr<AmericanExercise> ex =
                ext::dynamic_pointer_cast<AmericanExercise>(
                                                   arguments_.exercise);
            QL_REQUIRE(ex, "KIKO/KOKI options must have American exercise");
            QL_REQUIRE(ex->dates()[0] <=
                       process_->blackVolatility()->referenceDate(),
                       "American option with window exercise not handled yet");
        } else {
            ext::shared_ptr<EuropeanExercise> ex =
                ext::dynamic_pointer_cast<EuropeanExercise>(
                                                   arguments_.exercise);
            QL_REQUIRE(ex, "non-European exercise given");
        }
        ext::shared_ptr<CashOrNothingPayoff> payoff =
            ext::dynamic_pointer_cast<CashOrNothingPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "a cash-or-nothing payoff must be given");

        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        Real variance =
            process_->blackVolatility()->blackVariance(
                                             arguments_.exercise->lastDate(),
                                             payoff->strike());
        Real barrier_lo = arguments_.barrier_lo;
        Real barrier_hi = arguments_.barrier_hi;
        DoubleBarrier::Type barrierType = arguments_.barrierType;
        QL_REQUIRE(barrier_lo>0.0,
                   "positive low barrier value required");
        QL_REQUIRE(barrier_hi>0.0,
                   "positive high barrier value required");
        QL_REQUIRE(barrier_lo < barrier_hi,
                   "barrier_lo must be < barrier_hi");
        QL_REQUIRE(barrierType == DoubleBarrier::KnockIn ||
                   barrierType == DoubleBarrier::KnockOut ||
                   barrierType == DoubleBarrier::KIKO ||
                   barrierType == DoubleBarrier::KOKI,
                   "Unsupported barrier type");

        // degenerate cases
        switch (barrierType) {
          case DoubleBarrier::KnockOut:
            if (spot <= barrier_lo || spot >= barrier_hi) {
                // knocked out, no value
                results_.value = 0;
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;

          case DoubleBarrier::KnockIn:
            if (spot <= barrier_lo || spot >= barrier_hi) {
                // knocked in - pays
                results_.value = payoff->cashPayoff();
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;

          case DoubleBarrier::KIKO:
            if (spot >= barrier_hi) {
                // knocked out, no value
                results_.value = 0;
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            } else if (spot <= barrier_lo) {
                // knocked in, pays
                results_.value = payoff->cashPayoff();
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;

          case DoubleBarrier::KOKI:
            if (spot <= barrier_lo) {
                // knocked out, no value
                results_.value = 0;
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            } else if (spot >= barrier_hi) {
                // knocked in, pays
                results_.value = payoff->cashPayoff();
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;
        }

        AnalyticDoubleBarrierBinaryEngine_helper helper(process_,
           payoff, arguments_);
        switch (barrierType)
        {
          case DoubleBarrier::KnockOut:
          case DoubleBarrier::KnockIn:
            results_.value = helper.payoffAtExpiry(spot, variance, barrierType);
            break;

          case DoubleBarrier::KIKO:
          case DoubleBarrier::KOKI:
            results_.value = helper.payoffKIKO(spot, variance, barrierType);
            break;
        }
    }

}

]]></document_content>
  </document>
  <document index="30">
    <source>barrieroption/analyticdoublebarrierbinaryengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdoublebarrierbinaryengine.hpp
    \brief analytic binary double barrier (one-touch double barrier) option engine
*/

#ifndef quantlib_binary_double_barrier_engine_hpp
#define quantlib_binary_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic pricing engine for double barrier binary options
    /*! This engine implements C.H.Hui series ("One-Touch Double Barrier 
        Binary Option Values", Applied Financial Economics 6/1996), as
        described in "The complete guide to option pricing formulas 2nd Ed", 
        E.G. Haug, McGraw-Hill, p.180

        The Knock In part of KI+KO and KO+KI options pays at hit, while the
        Double Knock In pays at end. 
        This engine thus requires European esercise for Double Knock options, 
        and American exercise for KIKO/KOKI.

        \ingroup barrierengines

        greeks are calculated by simple numeric derivation

        \test
        - the correctness of the returned value is tested by reproducing 
          results available in literature.
    */
    class AnalyticDoubleBarrierBinaryEngine : public DoubleBarrierOption::engine {
      public:
        explicit AnalyticDoubleBarrierBinaryEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="31">
    <source>barrieroption/analyticdoublebarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierengine.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <utility>

namespace QuantLib {

    AnalyticDoubleBarrierEngine::AnalyticDoubleBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series)
    : process_(std::move(process)), series_(series) {
        registerWith(process_);
    }

    void AnalyticDoubleBarrierEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "this engine handles only european options");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real strike = payoff->strike();
        QL_REQUIRE(strike>0.0,
                   "strike must be positive");

        Real spot = underlying();
        QL_REQUIRE(spot >= 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(spot), "barrier(s) already touched");

        DoubleBarrier::Type barrierType = arguments_.barrierType;

        if (triggered(spot)) {
           if (barrierType == DoubleBarrier::KnockIn)
               results_.value = vanillaEquivalent();  // knocked in
           else
               results_.value = 0.0;  // knocked out
        } else {
           switch (payoff->optionType()) {
             case Option::Call:
               switch (barrierType) {
                 case DoubleBarrier::KnockIn:
                   results_.value = callKI();
                   break;
                 case DoubleBarrier::KnockOut:
                   results_.value = callKO();
                   break;
                 case DoubleBarrier::KIKO:
                 case DoubleBarrier::KOKI:
                   QL_FAIL("unsupported double-barrier type: "
                           << barrierType);
                 default:
                   QL_FAIL("unknown double-barrier type: "
                           << barrierType);
               }
               break;
             case Option::Put:
               switch (barrierType) {
                 case DoubleBarrier::KnockIn:
                   results_.value = putKI();
                   break;
                 case DoubleBarrier::KnockOut:
                   results_.value = putKO();
                   break;
                 case DoubleBarrier::KIKO:
                 case DoubleBarrier::KOKI:
                   QL_FAIL("unsupported double-barrier type: "
                           << barrierType);
                 default:
                   QL_FAIL("unknown double-barrier type: "
                           << barrierType);
               }
               break;
             default:
               QL_FAIL("unknown type");
           }
        }
    }


    Real AnalyticDoubleBarrierEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticDoubleBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticDoubleBarrierEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticDoubleBarrierEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticDoubleBarrierEngine::volatilitySquared() const {
        return volatility() * volatility();
    }

    Real AnalyticDoubleBarrierEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Real AnalyticDoubleBarrierEngine::barrierLo() const {
        return arguments_.barrier_lo;
    }

    Real AnalyticDoubleBarrierEngine::barrierHi() const {
        return arguments_.barrier_hi;
    }

    Rate AnalyticDoubleBarrierEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticDoubleBarrierEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticDoubleBarrierEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor AnalyticDoubleBarrierEngine::dividendDiscount() const {
        return process_->dividendYield()->discount(residualTime());
    }

    Rate AnalyticDoubleBarrierEngine::costOfCarry() const {
        return riskFreeRate() - dividendYield();
    }

    Real AnalyticDoubleBarrierEngine::vanillaEquivalent() const {
        // Call KI equates to vanilla - callKO
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        Real forwardPrice = underlying() * dividendDiscount() / riskFreeDiscount();
        BlackCalculator black(payoff, forwardPrice, stdDeviation(), riskFreeDiscount());
        Real vanilla = black.value();
        if (vanilla < 0.0)
           vanilla = 0.0;
        return vanilla;
    }

    Real AnalyticDoubleBarrierEngine::callKO() const {
       // N.B. for flat barriers mu3=mu1 and mu2=0
       Real mu1 = 2 * costOfCarry() / volatilitySquared() + 1;
       Real bsigma = (costOfCarry() + volatilitySquared() / 2.0) * residualTime() / stdDeviation();

       Real acc1 = 0;
       Real acc2 = 0;
       for (int n = -series_ ; n <= series_ ; ++n) {
          Real L2n = std::pow(barrierLo(), 2 * n);
          Real U2n = std::pow(barrierHi(), 2 * n);
          Real d1 = std::log( underlying()* U2n / (strike() * L2n) ) / stdDeviation() + bsigma;
          Real d2 = std::log( underlying()* U2n / (barrierHi() * L2n) ) / stdDeviation() + bsigma;
          Real d3 = std::log( std::pow(barrierLo(), 2 * n + 2) / (strike() * underlying() * U2n) ) / stdDeviation() + bsigma;
          Real d4 = std::log( std::pow(barrierLo(), 2 * n + 2) / (barrierHi() * underlying() * U2n) ) / stdDeviation() + bsigma;

          acc1 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1 ) * 
                  (f_(d1) - f_(d2)) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1 ) * 
                  (f_(d3) - f_(d4));

          acc2 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1-2) * 
                  (f_(d1 - stdDeviation()) - f_(d2 - stdDeviation())) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1-2 ) * 
                  (f_(d3-stdDeviation()) - f_(d4-stdDeviation()));
       }

       Real rend = std::exp(-dividendYield() * residualTime());
       Real kov = underlying() * rend * acc1 - strike() * riskFreeDiscount() * acc2;
       return std::max(0.0, kov);
    }
    
    Real AnalyticDoubleBarrierEngine::callKI() const {
        // Call KI equates to vanilla - callKO
        return std::max(0.0, vanillaEquivalent() - callKO());
    }

    Real AnalyticDoubleBarrierEngine::putKO() const {
       Real mu1 = 2 * costOfCarry() / volatilitySquared() + 1;
       Real bsigma = (costOfCarry() + volatilitySquared() / 2.0) * residualTime() / stdDeviation();

       Real acc1 = 0;
       Real acc2 = 0;
       for (int n = -series_ ; n <= series_ ; ++n) {
          Real L2n = std::pow(barrierLo(), 2 * n);
          Real U2n = std::pow(barrierHi(), 2 * n);
          Real y1 = std::log( underlying()* U2n / (std::pow(barrierLo(), 2 * n + 1)) ) / stdDeviation() + bsigma;
          Real y2 = std::log( underlying()* U2n / (strike() * L2n) ) / stdDeviation() + bsigma;
          Real y3 = std::log( std::pow(barrierLo(), 2 * n + 2) / (barrierLo() * underlying() * U2n) ) / stdDeviation() + bsigma;
          Real y4 = std::log( std::pow(barrierLo(), 2 * n + 2) / (strike() * underlying() * U2n) ) / stdDeviation() + bsigma;

          acc1 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1-2) * 
                  (f_(y1 - stdDeviation()) - f_(y2 - stdDeviation())) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1-2 ) * 
                  (f_(y3-stdDeviation()) - f_(y4-stdDeviation()));

          acc2 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1 ) * 
                  (f_(y1) - f_(y2)) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1 ) * 
                  (f_(y3) - f_(y4));

       }

       Real rend = std::exp(-dividendYield() * residualTime());
       Real kov = strike() * riskFreeDiscount() * acc1 - underlying() * rend  * acc2;
       return std::max(0.0, kov);
    }
    
    Real AnalyticDoubleBarrierEngine::putKI() const {
        // Put KI equates to vanilla - putKO
        return std::max(0.0, vanillaEquivalent() - putKO());
    }

    
}

]]></document_content>
  </document>
  <document index="32">
    <source>barrieroption/analyticdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdoublebarrierengine.hpp
    \brief Analytic double barrier european option engines

  ! Valid only if strike is in barrier range
*/

#ifndef quantlib_analytic_double_barrier_engine_hpp
#define quantlib_analytic_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for double barrier european options using analytical formulae
    /*! The formulas are taken from "The complete guide to option pricing formulas 2nd Ed",
         E.G. Haug, McGraw-Hill, p.156 and following.
         Implements the Ikeda and Kunitomo series (see "Pricing Options with 
         Curved Boundaries" Mathematical Finance 2/1992").
         This code handles only flat barriers

        \ingroup barrierengines

        \note the formula holds only when strike is in the barrier range

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        explicit AnalyticDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series = 5);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        int series_;
        // helper methods
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real volatilitySquared() const;
        Real barrierLo() const;
        Real barrierHi() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        Rate costOfCarry() const;
        DiscountFactor dividendDiscount() const;
        Real vanillaEquivalent() const;
        Real callKO() const;
        Real putKO() const;
        Real callKI() const;
        Real putKI() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="33">
    <source>barrieroption/binomialdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file binomialdoublebarrierengine.hpp
    \brief Binomial Double Barrier option engine
*/

#ifndef quantlib_binomial_double_barrier_engine_hpp
#define quantlib_binomial_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/discretizeddoublebarrieroption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/lattices/binomialtree.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for double barrier options using binomial trees
    /*! \ingroup barrierengines

        \note This engine requires a the discretized option classes. 
        By default uses a standard binomial implementation, but it can
        also work with DiscretizedDermanKaniDoubleBarrierOption to
        implement a Derman-Kani optimization.

        \test the correctness of the returned values is tested by
              checking it against analytic results.
    */
    template <class T, class D = DiscretizedDoubleBarrierOption>
    class BinomialDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        BinomialDoubleBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                    Size timeSteps)
        : process_(std::move(process)), timeSteps_(timeSteps) {
            QL_REQUIRE(timeSteps>0,
                       "timeSteps must be positive, " << timeSteps <<
                       " not allowed");
            registerWith(process_);
        }
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_;
    };


    // template definitions

    template <class T, class D>
    void BinomialDoubleBarrierEngine<T,D>::calculate() const {

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();

        Real s0 = process_->stateVariable()->value();
        QL_REQUIRE(s0 > 0.0, "negative or null underlying given");
        Volatility v = process_->blackVolatility()->blackVol(
            arguments_.exercise->lastDate(), s0);
        Date maturityDate = arguments_.exercise->lastDate();
        Rate r = process_->riskFreeRate()->zeroRate(maturityDate,
            rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->zeroRate(maturityDate,
            divdc, Continuous, NoFrequency);
        Date referenceDate = process_->riskFreeRate()->referenceDate();

        // binomial trees with constant coefficient
        Handle<YieldTermStructure> flatRiskFree(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, r, rfdc)));
        Handle<YieldTermStructure> flatDividends(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, q, divdc)));
        Handle<BlackVolTermStructure> flatVol(
            ext::shared_ptr<BlackVolTermStructure>(
                new BlackConstantVol(referenceDate, volcal, v, voldc)));

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Time maturity = rfdc.yearFraction(referenceDate, maturityDate);

        ext::shared_ptr<StochasticProcess1D> bs(
                         new GeneralizedBlackScholesProcess(
                                      process_->stateVariable(),
                                      flatDividends, flatRiskFree, flatVol));

        TimeGrid grid(maturity, timeSteps_);

        ext::shared_ptr<T> tree(new T(bs, maturity, timeSteps_,
                                        payoff->strike()));

        ext::shared_ptr<BlackScholesLattice<T> > lattice(
            new BlackScholesLattice<T>(tree, r, maturity, timeSteps_));
        
        D option(arguments_, *process_, grid);
        option.initialize(lattice, maturity);

        // Partial derivatives calculated from various points in the
        // binomial tree 
        // (see J.C.Hull, "Options, Futures and other derivatives", 6th edition, pp 397/398)

        // Rollback to third-last step, and get underlying prices (s2) &
        // option values (p2) at this point
        option.rollback(grid[2]);
        Array va2(option.values());
        QL_ENSURE(va2.size() == 3, "Expect 3 nodes in grid at second step");
        Real p2u = va2[2]; // up
        Real p2m = va2[1]; // mid
        Real p2d = va2[0]; // down (low)
        Real s2u = lattice->underlying(2, 2); // up price
        Real s2m = lattice->underlying(2, 1); // middle price
        Real s2d = lattice->underlying(2, 0); // down (low) price

        // calculate gamma by taking the first derivate of the two deltas
        Real delta2u = (p2u - p2m)/(s2u-s2m);
        Real delta2d = (p2m-p2d)/(s2m-s2d);
        Real gamma = (delta2u - delta2d) / ((s2u-s2d)/2);

        // Rollback to second-last step, and get option values (p1) at
        // this point
        option.rollback(grid[1]);
        Array va(option.values());
        QL_ENSURE(va.size() == 2, "Expect 2 nodes in grid at first step");
        Real p1u = va[1];
        Real p1d = va[0];
        Real s1u = lattice->underlying(1, 1); // up (high) price
        Real s1d = lattice->underlying(1, 0); // down (low) price

        Real delta = (p1u - p1d) / (s1u - s1d);

        // Finally, rollback to t=0
        option.rollback(0.0);
        Real p0 = option.presentValue();

        results_.value = p0;
        results_.delta = delta;
        results_.gamma = gamma;
        // theta can be approximated by calculating the numerical derivative
        // between mid value at third-last step and at t0. The underlying price
        // is the same, only time varies.
        results_.theta = (p2m - p0) / grid[2];
    }

}


#endif
]]></document_content>
  </document>
  <document index="34">
    <source>barrieroption/discretizeddoublebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/barrieroption/discretizeddoublebarrieroption.hpp>
#include <vector>

namespace QuantLib {

    DiscretizedDoubleBarrierOption::DiscretizedDoubleBarrierOption(
                                         const DoubleBarrierOption::arguments& args,
                                         const StochasticProcess& process,
                                         const TimeGrid& grid)
    : arguments_(args), vanilla_(arguments_, process, grid)  {
        QL_REQUIRE(args.exercise->dates().size(), "specify at least one stopping date");

        stoppingTimes_.resize(args.exercise->dates().size());
        for (Size i=0; i<stoppingTimes_.size(); ++i) {
            stoppingTimes_[i] =
                process.time(args.exercise->date(i));
            if (!grid.empty()) {
                // adjust to the given grid
                stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);
            }
        }
    }

    void DiscretizedDoubleBarrierOption::reset(Size size) {
        vanilla_.initialize(method(), time());
        values_ = Array(size, 0.0);
        adjustValues();
    }

    void DiscretizedDoubleBarrierOption::postAdjustValuesImpl() {
        if (arguments_.barrierType!=DoubleBarrier::KnockOut) {
            vanilla_.rollback(time());
        }
        Array grid = method()->grid(time());
        checkBarrier(values_, grid);
    }

    void DiscretizedDoubleBarrierOption::checkBarrier(Array &optvalues, const Array &grid) const {

        Time now = time();
        bool endTime = isOnTime(stoppingTimes_.back());
        bool stoppingTime = false;         
        switch (arguments_.exercise->type()) {
          case Exercise::American:
            if (now <= stoppingTimes_[1] &&
                now >= stoppingTimes_[0])
                stoppingTime = true;
            break;
          case Exercise::European:
            if (isOnTime(stoppingTimes_[0]))
                stoppingTime = true;
            break;
          case Exercise::Bermudan:
              for (double i : stoppingTimes_) {
                  if (isOnTime(i)) {
                      stoppingTime = true;
                      break;
                  }
              }
            break;
          default:
            QL_FAIL("invalid option type");
        }
        for (Size j=0; j<optvalues.size(); j++) {
            switch (arguments_.barrierType) {
              case DoubleBarrier::KnockIn:
                  if (grid[j] <= arguments_.barrier_lo) {
                     // knocked in dn
                     if (stoppingTime) {
                         optvalues[j] = std::max(vanilla()[j],
                                      (*arguments_.payoff)(grid[j]));
                     }
                     else
                         optvalues[j] = vanilla()[j]; 
                  }
                  else if (grid[j] >= arguments_.barrier_hi) {
                     // knocked in up
                     if (stoppingTime) {
                         optvalues[j] = std::max(vanilla()[j],
                                      (*arguments_.payoff)(grid[j]));
                     }
                     else
                         optvalues[j] = vanilla()[j]; 
                  }
                  else if (endTime)
                      optvalues[j] = arguments_.rebate;
                  break;
              case DoubleBarrier::KnockOut:
                  if (grid[j] <= arguments_.barrier_lo)
                      optvalues[j] = arguments_.rebate; // knocked out lo
                  else if (grid[j] >= arguments_.barrier_hi)
                     optvalues[j] = arguments_.rebate; // knocked out hi
                  else if (stoppingTime)
                      optvalues[j] = std::max(optvalues[j],
                                     (*arguments_.payoff)(grid[j]));
                  break;
              case DoubleBarrier::KIKO:
                  // low barrier is KI, high is KO
                  if (grid[j] <= arguments_.barrier_lo) {
                     // knocked in dn
                     if (stoppingTime) {
                         optvalues[j] = std::max(vanilla()[j],
                                      (*arguments_.payoff)(grid[j]));
                     }
                     else
                         optvalues[j] = vanilla()[j];
                  }
                  else if (grid[j] >= arguments_.barrier_hi)
                     optvalues[j] = arguments_.rebate; // knocked out hi
                  else if (endTime)
                      optvalues[j] = arguments_.rebate;
                  break;
              case DoubleBarrier::KOKI:
                  // low barrier is KO, high is KI
                  if (grid[j] <= arguments_.barrier_lo)
                      optvalues[j] = arguments_.rebate; // knocked out lo
                  else if (grid[j] >= arguments_.barrier_hi) {
                     // knocked in up
                     if (stoppingTime) {
                         optvalues[j] = std::max(vanilla()[j],
                                      (*arguments_.payoff)(grid[j]));
                     }
                     else
                         optvalues[j] = vanilla()[j];
                  }
                  else if (endTime)
                      optvalues[j] = arguments_.rebate;
                  break;
              default:
                  QL_FAIL("invalid barrier type");
            }
        }
    }



    DiscretizedDermanKaniDoubleBarrierOption::DiscretizedDermanKaniDoubleBarrierOption(
                                         const DoubleBarrierOption::arguments& args,
                                         const StochasticProcess& process,
                                         const TimeGrid& grid)
    : unenhanced_(args, process, grid) {
    }

    void DiscretizedDermanKaniDoubleBarrierOption::reset(Size size) {
        unenhanced_.initialize(method(), time());
        values_ = Array(size, 0.0);
        adjustValues();
    }

    void DiscretizedDermanKaniDoubleBarrierOption::postAdjustValuesImpl() {
        unenhanced_.rollback(time());

        Array grid = method()->grid(time());
        unenhanced_.checkBarrier(values_, grid); // compute payoffs
        adjustBarrier(values_, grid);
    }

    void DiscretizedDermanKaniDoubleBarrierOption::adjustBarrier(Array &optvalues, const Array &grid) {
        Real barrier_lo = unenhanced_.arguments().barrier_lo;
        Real barrier_hi = unenhanced_.arguments().barrier_hi;
        Real rebate = unenhanced_.arguments().rebate;
        switch (unenhanced_.arguments().barrierType) {
           case DoubleBarrier::KnockIn:
              for (Size j=0; j<optvalues.size()-1; ++j) {
                  if (grid[j]<=barrier_lo && grid[j+1] > barrier_lo) {
                     // grid[j+1] above barrier_lo, grid[j] under (in),
                     // interpolate optvalues[j+1]
                     Real ltob = (barrier_lo-grid[j]);
                     Real htob = (grid[j+1]-barrier_lo);
                     Real htol = (grid[j+1]-grid[j]);
                     Real u1 = unenhanced_.values()[j+1];
                     Real t1 = unenhanced_.vanilla()[j+1];
                     optvalues[j+1] = std::max(0.0, (ltob*t1+htob*u1)/htol); // derman std
                  }
                  else if (grid[j] < barrier_hi && grid[j+1] >= barrier_hi) {
                     // grid[j+1] above barrier_hi (in), grid[j] under, 
                     // interpolate optvalues[j]
                     Real ltob = (barrier_hi-grid[j]);
                     Real htob = (grid[j+1]-barrier_hi);
                     Real htol = (grid[j+1]-grid[j]);
                     Real u = unenhanced_.values()[j];
                     Real t = unenhanced_.vanilla()[j];
                     optvalues[j] = std::max(0.0, (ltob*u+htob*t)/htol); // derman std
                  }
              }
              break;
           case DoubleBarrier::KnockOut:
              for (Size j=0; j<optvalues.size()-1; ++j) {
                  if (grid[j]<=barrier_lo && grid[j+1] > barrier_lo) {
                     // grid[j+1] above barrier_lo, grid[j] under (out),
                     // interpolate optvalues[j+1]
                     Real a = (barrier_lo-grid[j])*rebate;
                     Real b = (grid[j+1]-barrier_lo)*unenhanced_.values()[j+1];
                     Real c = (grid[j+1]-grid[j]);
                     optvalues[j+1] = std::max(0.0, (a+b)/c);
                  }
                  else if (grid[j] < barrier_hi && grid[j+1] >= barrier_hi) {
                     // grid[j+1] above barrier_hi (out), grid[j] under, 
                     // interpolate optvalues[j]
                     Real a = (barrier_hi-grid[j])*unenhanced_.values()[j];
                     Real b = (grid[j+1]-barrier_hi)*rebate;
                     Real c = (grid[j+1]-grid[j]);
                     optvalues[j] = std::max(0.0, (a+b)/c);
                  }
              }
              break;
           default:
              QL_FAIL("unsupported barrier type");
              break;
        }
    }

}
]]></document_content>
  </document>
  <document index="35">
    <source>barrieroption/discretizeddoublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedbarrieroption.hpp
    \brief discretized barrier option
*/

#ifndef quantlib_discretized_double_barrier_option_h
#define quantlib_discretized_double_barrier_option_h

#include <ql/discretizedasset.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/pricingengines/vanilla/discretizedvanillaoption.hpp>

namespace QuantLib {

    //! Standard discretized option helper class
    /*! This class is used with the BinomialDoubleBarrierEngine to
        implement a standard binomial algorithm for double barrier
        options
    */
    class DiscretizedDoubleBarrierOption : public DiscretizedAsset {
      public:
        DiscretizedDoubleBarrierOption(const DoubleBarrierOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        const Array& vanilla() const { 
            return vanilla_.values(); 
        }

        const DoubleBarrierOption::arguments& arguments() const {
           return arguments_;
        }

        std::vector<Time> mandatoryTimes() const override { return stoppingTimes_; }

        void checkBarrier(Array &optvalues, const Array &grid) const;
      protected:
        void postAdjustValuesImpl() override;

      private:
        DoubleBarrierOption::arguments arguments_;
        std::vector<Time> stoppingTimes_;
        DiscretizedVanillaOption vanilla_; 
    };

    //! Derman-Kani-Ergener-Bardhan discretized option helper class
    /*! This class is used with the BinomialDoubleBarrierEngine to
        implement the enhanced binomial algorithm of E.Derman, I.Kani,
        D.Ergener, I.Bardhan ("Enhanced Numerical Methods for Options with
        Barriers", 1995)

        \note This algorithm is only suitable if the payoff can be approximated 
        linearly, e.g. is not usable for cash-or-nothing payoffs.
    */
    class DiscretizedDermanKaniDoubleBarrierOption : public DiscretizedAsset {
      public:
        DiscretizedDermanKaniDoubleBarrierOption(const DoubleBarrierOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        std::vector<Time> mandatoryTimes() const override { return unenhanced_.mandatoryTimes(); }

      protected:
        void postAdjustValuesImpl() override;

      private:
        void adjustBarrier(Array &optvalues, const Array &grid);
        DiscretizedDoubleBarrierOption unenhanced_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="36">
    <source>barrieroption/doublebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierengine.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/exercise.hpp>
#include <memory>

namespace QuantLib {

    DoubleBarrierOption::DoubleBarrierOption(
        DoubleBarrier::Type barrierType,
        Real barrier_lo,
        Real barrier_hi,
        Real rebate,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrier_lo_(barrier_lo), 
      barrier_hi_(barrier_hi), rebate_(rebate) {}

    void DoubleBarrierOption::setupArguments(PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<DoubleBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier_lo = barrier_lo_;
        moreArgs->barrier_hi = barrier_hi_;
        moreArgs->rebate = rebate_;
    }


    Volatility DoubleBarrierOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
            engine.reset(new AnalyticDoubleBarrierEngine(newProcess));
            break;
          case Exercise::American:
          case Exercise::Bermudan:
            QL_FAIL("engine not available for non-European barrier option");
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }


    DoubleBarrierOption::arguments::arguments()
    : barrierType(DoubleBarrier::Type(-1)), barrier_lo(Null<Real>()),
      barrier_hi(Null<Real>()), rebate(Null<Real>()) {}

    void DoubleBarrierOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        QL_REQUIRE(barrierType == DoubleBarrier::KnockIn ||
                   barrierType == DoubleBarrier::KnockOut ||
                   barrierType == DoubleBarrier::KIKO ||
                   barrierType == DoubleBarrier::KOKI,
                   "Invalid barrier type");

        QL_REQUIRE(barrier_lo != Null<Real>(), "no low barrier given");
        QL_REQUIRE(barrier_hi != Null<Real>(), "no high barrier given");
        QL_REQUIRE(rebate != Null<Real>(), "no rebate given");
    }

    bool DoubleBarrierOption::engine::triggered(Real underlying) const {
        return underlying <= arguments_.barrier_lo || underlying >= arguments_.barrier_hi;
    }

}

]]></document_content>
  </document>
  <document index="37">
    <source>barrieroption/doublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file doublebarrieroption.hpp
    \brief double Barrier european option on a single asset
*/

#ifndef quantlib_double_barrier_option_hpp
#define quantlib_double_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/experimental/barrieroption/doublebarriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! %Double Barrier option on a single asset.
    /*! The analytic pricing engine will be used if none if passed.

        \ingroup instruments
    */
    class DoubleBarrierOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        DoubleBarrierOption(DoubleBarrier::Type barrierType,
                      Real barrier_lo,
                      Real barrier_hi,
                      Real rebate,
                      const ext::shared_ptr<StrikedTypePayoff>& payoff,
                      const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;
        /*! \warning see VanillaOption for notes on implied-volatility
                     calculation.
        */
        Volatility impliedVolatility(
             Real price,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy = 1.0e-4,
             Size maxEvaluations = 100,
             Volatility minVol = 1.0e-7,
             Volatility maxVol = 4.0) const;
      protected:
        // arguments
        DoubleBarrier::Type barrierType_;
        Real barrier_lo_;
        Real barrier_hi_;
        Real rebate_;
    };

    //! %Arguments for double barrier option calculation
    class DoubleBarrierOption::arguments : public OneAssetOption::arguments {
      public:
        arguments();
        DoubleBarrier::Type barrierType;
        Real barrier_lo;
        Real barrier_hi;
        Real rebate;
        void validate() const override;
    };

    //! %Double-Barrier-option %engine base class
    class DoubleBarrierOption::engine
        : public GenericEngine<DoubleBarrierOption::arguments,
                               DoubleBarrierOption::results> {
      protected:
        bool triggered(Real underlying) const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>barrieroption/doublebarriertype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/barrieroption/doublebarriertype.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             DoubleBarrier::Type type) {
        switch (type) {
          case DoubleBarrier::KnockIn:
            return out << "KnockIn";
          case DoubleBarrier::KnockOut:
            return out << "KnockOut";
          case DoubleBarrier::KIKO:
            return out << "KI lo+KO up";
          case DoubleBarrier::KOKI:
            return out << "KO lo+KI up";
          default:
            QL_FAIL("unknown DoubleBarrier::Type (" << Integer(type) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="39">
    <source>barrieroption/doublebarriertype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file doublebarriertype.hpp
    \brief Double Barrier type
*/

#ifndef quantlib_double_barrier_type_hpp
#define quantlib_double_barrier_type_hpp

#include <ql/qldefines.hpp>
#include <ostream>

namespace QuantLib {

    //! Placeholder for enumerated barrier types
    struct DoubleBarrier {
        enum Type {
           KnockIn,
           KnockOut,
           KIKO,     //! lower barrier KI, upper KO
           KOKI      //! lower barrier KO, upper KI
        };
    };

    std::ostream& operator<<(std::ostream& out,
                             DoubleBarrier::Type type);

}

#endif
]]></document_content>
  </document>
  <document index="40">
    <source>barrieroption/mcdoublebarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/barrieroption/mcdoublebarrierengine.hpp>
#include <utility>

namespace QuantLib {

    DoubleBarrierPathPricer::DoubleBarrierPathPricer(DoubleBarrier::Type barrierType,
                                                     Real barrierLow,
                                                     Real barrierHigh,
                                                     Real rebate,
                                                     Option::Type type,
                                                     Real strike,
                                                     std::vector<DiscountFactor> discounts)
    : barrierType_(barrierType), barrierLow_(barrierLow), barrierHigh_(barrierHigh),
      rebate_(rebate), payoff_(type, strike), discounts_(std::move(discounts)) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
        QL_REQUIRE(barrierLow>0.0,
                   "low barrier less/equal zero not allowed");
        QL_REQUIRE(barrierHigh>0.0,
                   "high barrier less/equal zero not allowed");
    }

    Real DoubleBarrierPathPricer::operator()(const Path& path) const {
        static Size null = Null<Size>();
        Size n = path.length();
        QL_REQUIRE(n>1, "the path cannot be empty");

        bool isOptionActive = false;
        Size knockNode = null;
        Real terminal_price = path.back();
        Real new_asset_price;
        Size i;

        switch (barrierType_) {
            case DoubleBarrier::KnockOut:
                isOptionActive = true;
                for (i = 0; i < n-1; i++) {
                    new_asset_price = path[i + 1];

                    if (new_asset_price >= barrierHigh_ || new_asset_price <= barrierLow_){
                        isOptionActive = false;
                        if (knockNode == null)
                            knockNode = i+1;
                        break;
                    }
                }
                break;
            case DoubleBarrier::KnockIn:
                isOptionActive = false;
                for (i = 0; i < n-1; i++) {
                    new_asset_price = path[i + 1];

                    if (new_asset_price >= barrierHigh_ || new_asset_price <= barrierLow_){
                        isOptionActive = true;
                        if (knockNode == null)
                            knockNode = i+1;
                        break;
                    }
                }
                break;
            default:
                QL_FAIL("unknown barrier type");
        }

        if (isOptionActive) {
            return payoff_(terminal_price) * discounts_.back();
        } else {
            switch (barrierType_) {
                case DoubleBarrier::KnockOut:
                    return rebate_*discounts_[knockNode];
                case DoubleBarrier::KnockIn:
                    return rebate_*discounts_.back();
                default:
                    QL_FAIL("unknown barrier type");
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="41">
    <source>barrieroption/mcdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcdoublebarrierengine.hpp
    \brief Monte Carlo barrier option engines
*/

#ifndef quantlib_mc_double_barrier_engines_hpp
#define quantlib_mc_double_barrier_engines_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCDoubleBarrierEngine : public DoubleBarrierOption::engine,
                                  public McSimulation<SingleVariate,RNG,S> {
      public:
        typedef typename McSimulation<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        // constructor
        MCDoubleBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                              Size timeSteps,
                              Size timeStepsPerYear,
                              bool brownianBridge,
                              bool antithetic,
                              Size requiredSamples,
                              Real requiredTolerance,
                              Size maxSamples,
                              BigNatural seed);
        void calculate() const override {
            Real spot = process_->x0();
            QL_REQUIRE(spot >= 0.0, "negative or null underlying given");
            QL_REQUIRE(!triggered(spot), "barrier touched");
            McSimulation<SingleVariate,RNG,S>::calculate(requiredTolerance_,
                                                         requiredSamples_,
                                                         maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if (RNG::allowsErrorEstimate)
            results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {
            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(grid.size()-1,seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        // data members
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool antithetic_;
        bool brownianBridge_;
        BigNatural seed_;
    };

    //! Monte Carlo double-barrier-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCDoubleBarrierEngine {
      public:
        explicit MakeMCDoubleBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCDoubleBarrierEngine& withSteps(Size steps);
        MakeMCDoubleBarrierEngine& withStepsPerYear(Size steps);
        MakeMCDoubleBarrierEngine& withBrownianBridge(bool b = true);
        MakeMCDoubleBarrierEngine& withAntitheticVariate(bool b = true);
        MakeMCDoubleBarrierEngine& withSamples(Size samples);
        MakeMCDoubleBarrierEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDoubleBarrierEngine& withMaxSamples(Size samples);
        MakeMCDoubleBarrierEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool brownianBridge_, antithetic_;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };

    class DoubleBarrierPathPricer : public PathPricer<Path> {
      public:
        DoubleBarrierPathPricer(DoubleBarrier::Type barrierType,
                                Real barrierLow,
                                Real barrieHigh,
                                Real rebate,
                                Option::Type type,
                                Real strike,
                                std::vector<DiscountFactor> discounts);
        Real operator()(const Path& path) const override;

      private:
        DoubleBarrier::Type barrierType_;
        Real barrierLow_;
        Real barrierHigh_;
        Real rebate_;
        PlainVanillaPayoff payoff_;
        std::vector<DiscountFactor> discounts_;
    };

    // template definitions

    template <class RNG, class S>
    inline MCDoubleBarrierEngine<RNG, S>::MCDoubleBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(process_);
    }

    template <class RNG, class S>
    inline TimeGrid MCDoubleBarrierEngine<RNG,S>::timeGrid() const {

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCDoubleBarrierEngine<RNG,S>::path_pricer_type>
    MCDoubleBarrierEngine<RNG,S>::pathPricer() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        TimeGrid grid = timeGrid();
        std::vector<DiscountFactor> discounts(grid.size());
        for (Size i=0; i<grid.size(); i++)
            discounts[i] = process_->riskFreeRate()->discount(grid[i]);

        return ext::shared_ptr<
                    typename MCDoubleBarrierEngine<RNG,S>::path_pricer_type>(
            new DoubleBarrierPathPricer(
                arguments_.barrierType,
                arguments_.barrier_lo,
                arguments_.barrier_hi,
                arguments_.rebate,
                payoff->optionType(),
                payoff->strike(),
                discounts));
        }

        template <class RNG, class S>
        inline MakeMCDoubleBarrierEngine<RNG, S>::MakeMCDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process)
        : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
          steps_(Null<Size>()), stepsPerYear_(Null<Size>()), samples_(Null<Size>()),
          maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

        template <class RNG, class S>
        inline MakeMCDoubleBarrierEngine<RNG, S>&
        MakeMCDoubleBarrierEngine<RNG, S>::withSteps(Size steps) {
            steps_ = steps;
            return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCDoubleBarrierEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCDoubleBarrierEngine<RNG,S>(process_,
                                   steps_,
                                   stepsPerYear_,
                                   brownianBridge_,
                                   antithetic_,
                                   samples_,
                                   tolerance_,
                                   maxSamples_,
                                   seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="42">
    <source>barrieroption/perturbativebarrieroptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file perturbativebarrieroptionengine.hpp
    \brief perturbative barrier-option engine
*/

#ifndef quantlib_perturbative_barrier_option_engine_hpp
#define quantlib_perturbative_barrier_option_engine_hpp

#include <ql/instruments/barrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! perturbative barrier-option engine
    /*! This engine implements the approach described in
        <http://www.econ.univpm.it/recchioni/finance/w3/>.

        \warning This was reported to fail tests on Mac OS X 10.8.4.

        \ingroup barrierengines
    */
    class PerturbativeBarrierOptionEngine : public BarrierOption::engine  {
      public:
        explicit PerturbativeBarrierOptionEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>,
                                                 Natural order = 1,
                                                 bool zeroGamma = false);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Natural order_;
        bool zeroGamma_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="43">
    <source>barrieroption/quantodoublebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/barrieroption/quantodoublebarrieroption.hpp>

namespace QuantLib {

    QuantoDoubleBarrierOption::QuantoDoubleBarrierOption(
                        DoubleBarrier::Type barrierType,
                        Real barrier_lo,
                        Real barrier_hi,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise)
    : DoubleBarrierOption(barrierType, barrier_lo, barrier_hi, rebate, payoff, exercise) {}

    Real QuantoDoubleBarrierOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoDoubleBarrierOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoDoubleBarrierOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoDoubleBarrierOption::setupExpired() const {
        DoubleBarrierOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoDoubleBarrierOption::fetchResults(
                                      const PricingEngine::results* r) const {
        DoubleBarrierOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoDoubleBarrierOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="44">
    <source>barrieroption/quantodoublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantodoublebarrieroption.hpp
    \brief Quanto version of a double barrier option
*/

#ifndef quantlib_quanto_double_barrier_option_hpp
#define quantlib_quanto_double_barrier_option_hpp

#include <ql/instruments/quantovanillaoption.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>

namespace QuantLib {

    //! Quanto version of a double barrier option
    /*! \ingroup instruments */
    class QuantoDoubleBarrierOption : public DoubleBarrierOption {
      public:
        typedef DoubleBarrierOption::arguments arguments;
        typedef QuantoOptionResults<DoubleBarrierOption::results> results;
        QuantoDoubleBarrierOption(
                        DoubleBarrier::Type barrierType,
                        Real barrier_lo,
                        Real barrier_hi,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise
            );
        //! \name greeks
        //@{
        Real qvega() const;
        Real qrho() const;
        Real qlambda() const;
        //@}
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        // results
        mutable Real qvega_, qrho_, qlambda_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="45">
    <source>barrieroption/vannavolgabarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/barrieroption/vannavolgabarrierengine.hpp>
#include <ql/experimental/barrieroption/vannavolgainterpolation.hpp>
#include <ql/experimental/fx/blackdeltacalculator.hpp>
#include <ql/math/matrix.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

using std::pow;
using std::log;
using std::sqrt;

namespace QuantLib {

    VannaVolgaBarrierEngine::VannaVolgaBarrierEngine(Handle<DeltaVolQuote> atmVol,
                                                     Handle<DeltaVolQuote> vol25Put,
                                                     Handle<DeltaVolQuote> vol25Call,
                                                     Handle<Quote> spotFX,
                                                     Handle<YieldTermStructure> domesticTS,
                                                     Handle<YieldTermStructure> foreignTS,
                                                     const bool adaptVanDelta,
                                                     const Real bsPriceWithSmile)
    : atmVol_(std::move(atmVol)), vol25Put_(std::move(vol25Put)), vol25Call_(std::move(vol25Call)),
      T_(atmVol_->maturity()), spotFX_(std::move(spotFX)), domesticTS_(std::move(domesticTS)),
      foreignTS_(std::move(foreignTS)), adaptVanDelta_(adaptVanDelta),
      bsPriceWithSmile_(bsPriceWithSmile) {
        QL_REQUIRE(vol25Put_->delta() == -0.25, "25 delta put is required by vanna volga method");
        QL_REQUIRE(vol25Call_->delta() == 0.25, "25 delta call is required by vanna volga method");

        QL_REQUIRE(vol25Put_->maturity() == vol25Call_->maturity() &&
                       vol25Put_->maturity() == atmVol_->maturity(),
                   "Maturity of 3 vols are not the same");

        QL_REQUIRE(!domesticTS_.empty(), "domestic yield curve is not defined");
        QL_REQUIRE(!foreignTS_.empty(), "foreign yield curve is not defined");

        registerWith(atmVol_);
        registerWith(vol25Put_);
        registerWith(vol25Call_);
        registerWith(spotFX_);
        registerWith(domesticTS_);
        registerWith(foreignTS_);
    }

    void VannaVolgaBarrierEngine::calculate() const {

        QL_REQUIRE(arguments_.barrierType == Barrier::UpIn || arguments_.barrierType == Barrier::UpOut ||
            arguments_.barrierType == Barrier::DownIn || arguments_.barrierType == Barrier::DownOut,
            "Invalid barrier type");

        const Real sigmaShift_vega = 0.0001;
        const Real sigmaShift_volga = 0.0001;
        const Real spotShift_delta = 0.0001 * spotFX_->value();
        const Real sigmaShift_vanna = 0.0001;

        Handle<Quote> x0Quote(
            ext::make_shared<SimpleQuote>(spotFX_->value())); //used for shift
        Handle<Quote> atmVolQuote(
            ext::make_shared<SimpleQuote>(atmVol_->value())); //used for shift

        ext::shared_ptr<BlackVolTermStructure> blackVolTS =
            ext::make_shared<BlackConstantVol>(
                Settings::instance().evaluationDate(),
                NullCalendar(), atmVolQuote, Actual365Fixed());
        ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
            ext::make_shared<BlackScholesMertonProcess>(
                                 x0Quote,
                                 foreignTS_,
                                 domesticTS_,
                                 Handle<BlackVolTermStructure>(blackVolTS));

        ext::shared_ptr<PricingEngine> engineBS =
            ext::make_shared<AnalyticBarrierEngine>(stochProcess);

        BlackDeltaCalculator blackDeltaCalculatorAtm(
                        Option::Call, atmVol_->deltaType(), x0Quote->value(),
                        domesticTS_->discount(T_), foreignTS_->discount(T_),
                        atmVol_->value() * sqrt(T_));
        Real atmStrike = blackDeltaCalculatorAtm.atmStrike(atmVol_->atmType());

        Real call25Vol = vol25Call_->value();
        Real put25Vol = vol25Put_->value();

        BlackDeltaCalculator blackDeltaCalculatorPut25(Option::Put, vol25Put_->deltaType(), x0Quote->value(), 
                                                      domesticTS_->discount(T_), foreignTS_->discount(T_),
                                                      put25Vol * sqrt(T_));
        Real put25Strike = blackDeltaCalculatorPut25.strikeFromDelta(-0.25);
        BlackDeltaCalculator blackDeltaCalculatorCall25(Option::Call, vol25Call_->deltaType(), x0Quote->value(), 
                                                      domesticTS_->discount(T_), foreignTS_->discount(T_),
                                                      call25Vol * sqrt(T_));
        Real call25Strike = blackDeltaCalculatorCall25.strikeFromDelta(0.25);


        //here use vanna volga interpolated smile to price vanilla
        std::vector<Real> strikes;
        std::vector<Real> vols;
        strikes.push_back(put25Strike);
        vols.push_back(put25Vol);
        strikes.push_back(atmStrike);
        vols.push_back(atmVol_->value());
        strikes.push_back(call25Strike);
        vols.push_back(call25Vol);
        VannaVolga vannaVolga(x0Quote->value(), domesticTS_->discount(T_), foreignTS_->discount(T_), T_);
        Interpolation interpolation = vannaVolga.interpolate(strikes.begin(), strikes.end(), vols.begin());
        interpolation.enableExtrapolation();
        const ext::shared_ptr<StrikedTypePayoff> payoff =
                                        ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        Real strikeVol = interpolation(payoff->strike());

        //vanilla option price
        Real vanillaOption = blackFormula(payoff->optionType(), payoff->strike(), 
                                      x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_), 
                                      strikeVol * sqrt(T_),
                                      domesticTS_->discount(T_));

        //spot > barrier up&out 0
        if(x0Quote->value() >= arguments_.barrier && arguments_.barrierType == Barrier::UpOut){
            results_.value = 0.0;
            results_.additionalResults["VanillaPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierInPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierOutPrice"] = 0.0;
        }
        //spot > barrier up&in vanilla
        else if(x0Quote->value() >= arguments_.barrier && arguments_.barrierType == Barrier::UpIn){
            results_.value = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["VanillaPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierInPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierOutPrice"] = 0.0;
        }
        //spot < barrier down&out 0
        else if(x0Quote->value() <= arguments_.barrier && arguments_.barrierType == Barrier::DownOut){
            results_.value = 0.0;
            results_.additionalResults["VanillaPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierInPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierOutPrice"] = 0.0;
        }
        //spot < barrier down&in vanilla
        else if(x0Quote->value() <= arguments_.barrier && arguments_.barrierType == Barrier::DownIn){
            results_.value = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["VanillaPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierInPrice"] = adaptVanDelta_? bsPriceWithSmile_ : vanillaOption;
            results_.additionalResults["BarrierOutPrice"] = 0.0;
        }
        else{

            //set up BS barrier option pricing
            //only calculate out barrier option price
            // in barrier price = vanilla - out barrier
            Barrier::Type barrierType;
            if(arguments_.barrierType == Barrier::UpOut)
                barrierType = arguments_.barrierType;
            else if(arguments_.barrierType == Barrier::UpIn)
                barrierType = Barrier::UpOut;
            else if(arguments_.barrierType == Barrier::DownOut)
                barrierType = arguments_.barrierType;
            else
                barrierType = Barrier::DownOut;

            BarrierOption barrierOption(barrierType,
                                        arguments_.barrier,
                                        arguments_.rebate,
                                        ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff),
                                        arguments_.exercise);

            barrierOption.setPricingEngine(engineBS);

            //BS price with atm vol
            Real priceBS = barrierOption.NPV();

            Real priceAtmCallBS = blackFormula(Option::Call,atmStrike,
                                              x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_), 
                                              atmVol_->value() * sqrt(T_),
                                              domesticTS_->discount(T_));
            Real price25CallBS = blackFormula(Option::Call,call25Strike,
                                              x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_), 
                                              atmVol_->value() * sqrt(T_),
                                              domesticTS_->discount(T_));
            Real price25PutBS = blackFormula(Option::Put,put25Strike,
                                              x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_),
                                              atmVol_->value() * sqrt(T_),
                                              domesticTS_->discount(T_));

            //market price
            Real priceAtmCallMkt = blackFormula(Option::Call,atmStrike,
                                              x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_), 
                                              atmVol_->value() * sqrt(T_),
                                              domesticTS_->discount(T_));

            Real price25CallMkt = blackFormula(Option::Call,call25Strike,
                                              x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_), 
                                              call25Vol * sqrt(T_),
                                              domesticTS_->discount(T_));
            Real price25PutMkt = blackFormula(Option::Put,put25Strike,
                                              x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_),
                                              put25Vol * sqrt(T_),
                                              domesticTS_->discount(T_));


            //Analytical Black Scholes formula for vanilla option
            NormalDistribution norm;
            Real d1atm = (std::log(x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_)/atmStrike) 
                           + 0.5*std::pow(atmVolQuote->value(),2.0) * T_)/(atmVolQuote->value() * sqrt(T_));
            Real vegaAtm_Analytical = x0Quote->value() * norm(d1atm) * sqrt(T_) * foreignTS_->discount(T_);
            Real vannaAtm_Analytical = vegaAtm_Analytical/x0Quote->value() *(1.0 - d1atm/(atmVolQuote->value()*sqrt(T_)));
            Real volgaAtm_Analytical = vegaAtm_Analytical * d1atm * (d1atm - atmVolQuote->value() * sqrt(T_))/atmVolQuote->value();

            Real d125call = (std::log(x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_)/call25Strike) 
                           + 0.5*std::pow(atmVolQuote->value(),2.0) * T_)/(atmVolQuote->value() * sqrt(T_));
            Real vega25Call_Analytical = x0Quote->value() * norm(d125call) * sqrt(T_) * foreignTS_->discount(T_);
            Real vanna25Call_Analytical = vega25Call_Analytical/x0Quote->value() *(1.0 - d125call/(atmVolQuote->value()*sqrt(T_)));
            Real volga25Call_Analytical = vega25Call_Analytical * d125call * (d125call - atmVolQuote->value() * sqrt(T_))/atmVolQuote->value();

            Real d125Put = (std::log(x0Quote->value()* foreignTS_->discount(T_)/ domesticTS_->discount(T_)/put25Strike) 
                           + 0.5*std::pow(atmVolQuote->value(),2.0) * T_)/(atmVolQuote->value() * sqrt(T_));
            Real vega25Put_Analytical = x0Quote->value() * norm(d125Put) * sqrt(T_) * foreignTS_->discount(T_);
            Real vanna25Put_Analytical = vega25Put_Analytical/x0Quote->value() *(1.0 - d125Put/(atmVolQuote->value()*sqrt(T_)));
            Real volga25Put_Analytical = vega25Put_Analytical * d125Put * (d125Put - atmVolQuote->value() * sqrt(T_))/atmVolQuote->value();


            //BS vega
            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() + sigmaShift_vega);
            barrierOption.recalculate();
            Real vegaBarBS = (barrierOption.NPV() - priceBS)/sigmaShift_vega;

            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() - sigmaShift_vega);//setback

            //BS volga

            //vegaBar2
            //base NPV
            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() + sigmaShift_volga);
            barrierOption.recalculate();
            Real priceBS2 = barrierOption.NPV();

            //shifted npv
            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() + sigmaShift_vega);
            barrierOption.recalculate();
            Real vegaBarBS2 = (barrierOption.NPV() - priceBS2)/sigmaShift_vega;
            Real volgaBarBS = (vegaBarBS2 - vegaBarBS)/sigmaShift_volga;

            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() 
                                                                                               - sigmaShift_volga 
                                                                                               - sigmaShift_vega);//setback

            //BS Delta
            //base delta
            ext::static_pointer_cast<SimpleQuote> (x0Quote.currentLink())->setValue(x0Quote->value() + spotShift_delta);//shift forth
            barrierOption.recalculate();
            Real priceBS_delta1 = barrierOption.NPV();

            ext::static_pointer_cast<SimpleQuote> (x0Quote.currentLink())->setValue(x0Quote->value() - 2 * spotShift_delta);//shift back
            barrierOption.recalculate();
            Real priceBS_delta2 = barrierOption.NPV();

            ext::static_pointer_cast<SimpleQuote> (x0Quote.currentLink())->setValue(x0Quote->value() +  spotShift_delta);//set back
            Real deltaBar1 = (priceBS_delta1 - priceBS_delta2)/(2.0*spotShift_delta);

            //shifted delta
            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() + sigmaShift_vanna);//shift sigma
            ext::static_pointer_cast<SimpleQuote> (x0Quote.currentLink())->setValue(x0Quote->value() + spotShift_delta);//shift forth
            barrierOption.recalculate();
            priceBS_delta1 = barrierOption.NPV();

            ext::static_pointer_cast<SimpleQuote> (x0Quote.currentLink())->setValue(x0Quote->value() - 2 * spotShift_delta);//shift back
            barrierOption.recalculate();
            priceBS_delta2 = barrierOption.NPV();

            ext::static_pointer_cast<SimpleQuote> (x0Quote.currentLink())->setValue(x0Quote->value() +  spotShift_delta);//set back
            Real deltaBar2 = (priceBS_delta1 - priceBS_delta2)/(2.0*spotShift_delta);

            Real vannaBarBS = (deltaBar2 - deltaBar1)/sigmaShift_vanna;

            ext::static_pointer_cast<SimpleQuote> (atmVolQuote.currentLink())->setValue(atmVolQuote->value() - sigmaShift_vanna);//set back

            //Matrix
            Matrix A(3,3,0.0);

            //analytical
            A[0][0] = vegaAtm_Analytical;
            A[0][1] = vega25Call_Analytical;
            A[0][2] = vega25Put_Analytical;
            A[1][0] = vannaAtm_Analytical;
            A[1][1] = vanna25Call_Analytical;
            A[1][2] = vanna25Put_Analytical;
            A[2][0] = volgaAtm_Analytical;
            A[2][1] = volga25Call_Analytical;
            A[2][2] = volga25Put_Analytical;

            Array b(3,0.0);
            b[0] = vegaBarBS;
            b[1] = vannaBarBS;
            b[2] = volgaBarBS;

            Array q = inverse(A) * b;

            //touch probability
            CumulativeNormalDistribution cnd;
            Real mu = domesticTS_->zeroRate(T_, Continuous) - foreignTS_->zeroRate(T_, Continuous) - pow(atmVol_->value(), 2.0)/2.0;
            Real h2 = (log(arguments_.barrier/x0Quote->value()) + mu*T_)/(atmVol_->value()*sqrt(T_));
            Real h2Prime = (log(x0Quote->value()/arguments_.barrier) + mu*T_)/(atmVol_->value()*sqrt(T_));
            Real probTouch = 0.0;
            if(arguments_.barrierType == Barrier::UpIn || arguments_.barrierType == Barrier::UpOut)
                probTouch = cnd(h2Prime) + pow(arguments_.barrier/x0Quote->value(), 2.0*mu/pow(atmVol_->value(), 2.0))*cnd(-h2);
            else
                probTouch = cnd(-h2Prime) + pow(arguments_.barrier/x0Quote->value(), 2.0*mu/pow(atmVol_->value(), 2.0))*cnd(h2);
            Real p_survival = 1.0 - probTouch;

            Real lambda = p_survival ;
            Real adjust = q[0]*(priceAtmCallMkt - priceAtmCallBS) 
                        + q[1]*(price25CallMkt - price25CallBS)
                        + q[2]*(price25PutMkt - price25PutBS);
            Real outPrice = priceBS + lambda*adjust;//
            Real inPrice;

            //adapt Vanilla delta
            if (adaptVanDelta_) {
                outPrice += lambda*(bsPriceWithSmile_ - vanillaOption);
                //capfloored by (0, vanilla)
                outPrice = std::max(0.0, std::min(bsPriceWithSmile_, outPrice));
                inPrice = bsPriceWithSmile_ - outPrice;
            }
            else{
                //capfloored by (0, vanilla)
                outPrice = std::max(0.0, std::min(vanillaOption, outPrice));
                inPrice = vanillaOption - outPrice;
            }

            if(arguments_.barrierType == Barrier::DownOut || arguments_.barrierType == Barrier::UpOut)
                results_.value = outPrice;
            else
                results_.value = inPrice;
            results_.additionalResults["VanillaPrice"] = vanillaOption;
            results_.additionalResults["BarrierInPrice"] = inPrice;
            results_.additionalResults["BarrierOutPrice"] = outPrice;
            results_.additionalResults["lambda"] = lambda;
         }
    }
}
]]></document_content>
  </document>
  <document index="46">
    <source>barrieroption/vannavolgabarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vannavolgabarrierengine.hpp
    \brief Vanna/Volga barrier option engine
*/

#ifndef quantlib_vanna_volga_barrier_engine_hpp
#define quantlib_vanna_volga_barrier_engine_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/instruments/dividendbarrieroption.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>

namespace QuantLib {

    //! Vanna Volga barrier option engine

    /*!
        \ingroup barrierengines
    */
    class VannaVolgaBarrierEngine
        : public GenericEngine<DividendBarrierOption::arguments,
                               DividendBarrierOption::results> {
      public:

        // Constructor
        VannaVolgaBarrierEngine(Handle<DeltaVolQuote> atmVol,
                                Handle<DeltaVolQuote> vol25Put,
                                Handle<DeltaVolQuote> vol25Call,
                                Handle<Quote> spotFX,
                                Handle<YieldTermStructure> domesticTS,
                                Handle<YieldTermStructure> foreignTS,
                                bool adaptVanDelta = false,
                                Real bsPriceWithSmile = 0.0);

        void calculate() const override;

      private:
        const Handle<DeltaVolQuote> atmVol_;
        const Handle<DeltaVolQuote> vol25Put_;
        const Handle<DeltaVolQuote> vol25Call_;
        const Time T_;
        const Handle<Quote> spotFX_;
        const Handle<YieldTermStructure> domesticTS_;
        const Handle<YieldTermStructure> foreignTS_;
        const bool adaptVanDelta_;
        const Real bsPriceWithSmile_;

    };


}

#endif /*quantlib_fd_black_scholes_barrier_engine_hpp*/
]]></document_content>
  </document>
  <document index="47">
    <source>barrieroption/vannavolgadoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vannavolgadoublebarrierengine.hpp
    \brief Vanna/Volga double-barrier option engine
*/

#ifndef quantlib_vanna_volga_double_barrier_engine_hpp
#define quantlib_vanna_volga_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/vannavolgainterpolation.hpp>
#include <ql/experimental/fx/blackdeltacalculator.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>
#include <ql/math/matrix.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    //! Vanna Volga double-barrier option engine

    /*!
        \ingroup barrierengines
    */
   template <class DoubleBarrierEngine>
      class VannaVolgaDoubleBarrierEngine
           : public GenericEngine<DoubleBarrierOption::arguments,
                                  DoubleBarrierOption::results> {
         public:
           // Constructor
           VannaVolgaDoubleBarrierEngine(Handle<DeltaVolQuote> atmVol,
                                         Handle<DeltaVolQuote> vol25Put,
                                         Handle<DeltaVolQuote> vol25Call,
                                         Handle<Quote> spotFX,
                                         Handle<YieldTermStructure> domesticTS,
                                         Handle<YieldTermStructure> foreignTS,
                                         const bool adaptVanDelta = false,
                                         const Real bsPriceWithSmile = 0.0,
                                         int series = 5)
           : GenericEngine<DoubleBarrierOption::arguments, DoubleBarrierOption::results>(),
             atmVol_(std::move(atmVol)), vol25Put_(std::move(vol25Put)),
             vol25Call_(std::move(vol25Call)), T_(atmVol_->maturity()), spotFX_(std::move(spotFX)),
             domesticTS_(std::move(domesticTS)), foreignTS_(std::move(foreignTS)),
             adaptVanDelta_(adaptVanDelta), bsPriceWithSmile_(bsPriceWithSmile), series_(series) {

               QL_REQUIRE(vol25Put_->delta() == -0.25,
                          "25 delta put is required by vanna volga method");
               QL_REQUIRE(vol25Call_->delta() == 0.25,
                          "25 delta call is required by vanna volga method");

               QL_REQUIRE(vol25Put_->maturity() == vol25Call_->maturity() &&
                              vol25Put_->maturity() == atmVol_->maturity(),
                          "Maturity of 3 vols are not the same");

               QL_REQUIRE(!domesticTS_.empty(), "domestic yield curve is not defined");
               QL_REQUIRE(!foreignTS_.empty(), "foreign yield curve is not defined");

               registerWith(atmVol_);
               registerWith(vol25Put_);
               registerWith(vol25Call_);
               registerWith(spotFX_);
               registerWith(domesticTS_);
               registerWith(foreignTS_);
           }

             void calculate() const override {

                 using std::sqrt;

                 const Real sigmaShift_vega = 0.001;
                 const Real sigmaShift_volga = 0.0001;
                 const Real spotShift_delta = 0.0001 * spotFX_->value();
                 const Real sigmaShift_vanna = 0.0001;

                 QL_REQUIRE(arguments_.barrierType == DoubleBarrier::KnockIn ||
                                arguments_.barrierType == DoubleBarrier::KnockOut,
                            "Only same type barrier supported");

                 Handle<Quote> x0Quote( // used for shift
                     ext::make_shared<SimpleQuote>(spotFX_->value()));
                 Handle<Quote> atmVolQuote( // used for shift
                     ext::make_shared<SimpleQuote>(atmVol_->value()));

                 ext::shared_ptr<BlackVolTermStructure> blackVolTS =
                     ext::make_shared<BlackConstantVol>(Settings::instance().evaluationDate(),
                                                        NullCalendar(), atmVolQuote,
                                                        Actual365Fixed());
                 ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
                     ext::make_shared<BlackScholesMertonProcess>(
                         x0Quote, foreignTS_, domesticTS_,
                         Handle<BlackVolTermStructure>(blackVolTS));

                 ext::shared_ptr<PricingEngine> engineBS =
                     ext::make_shared<DoubleBarrierEngine>(stochProcess, series_);

                 BlackDeltaCalculator blackDeltaCalculatorAtm(
                     Option::Call, atmVol_->deltaType(), x0Quote->value(),
                     domesticTS_->discount(T_), foreignTS_->discount(T_),
                     atmVol_->value() * sqrt(T_));
                 Real atmStrike = blackDeltaCalculatorAtm.atmStrike(atmVol_->atmType());

                 Real call25Vol = vol25Call_->value();
                 Real put25Vol = vol25Put_->value();
                 BlackDeltaCalculator blackDeltaCalculatorPut25(
                     Option::Put, vol25Put_->deltaType(), x0Quote->value(),
                     domesticTS_->discount(T_), foreignTS_->discount(T_), put25Vol * sqrt(T_));
                 Real put25Strike = blackDeltaCalculatorPut25.strikeFromDelta(-0.25);
                 BlackDeltaCalculator blackDeltaCalculatorCall25(
                     Option::Call, vol25Call_->deltaType(), x0Quote->value(),
                     domesticTS_->discount(T_), foreignTS_->discount(T_), call25Vol * sqrt(T_));
                 Real call25Strike = blackDeltaCalculatorCall25.strikeFromDelta(0.25);

                 // here use vanna volga interpolated smile to price vanilla
                 std::vector<Real> strikes;
                 std::vector<Real> vols;
                 strikes.push_back(put25Strike);
                 vols.push_back(put25Vol);
                 strikes.push_back(atmStrike);
                 vols.push_back(atmVol_->value());
                 strikes.push_back(call25Strike);
                 vols.push_back(call25Vol);
                 VannaVolga vannaVolga(x0Quote->value(), foreignTS_->discount(T_),
                                       foreignTS_->discount(T_), T_);
                 Interpolation interpolation =
                     vannaVolga.interpolate(strikes.begin(), strikes.end(), vols.begin());
                 interpolation.enableExtrapolation();
                 const ext::shared_ptr<StrikedTypePayoff> payoff =
                     ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
                 Real strikeVol = interpolation(payoff->strike());
                 // vanilla option price
                 Real vanillaOption = blackFormula(payoff->optionType(), payoff->strike(),
                                                   x0Quote->value() * foreignTS_->discount(T_) /
                                                       domesticTS_->discount(T_),
                                                   strikeVol * sqrt(T_), domesticTS_->discount(T_));

                 // already out
                 if ((x0Quote->value() > arguments_.barrier_hi ||
                      x0Quote->value() < arguments_.barrier_lo) &&
                     arguments_.barrierType == DoubleBarrier::KnockOut) {
                     results_.value = 0.0;
                     results_.additionalResults["VanillaPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierInPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierOutPrice"] = 0.0;
                 }
                 // already in
                 else if ((x0Quote->value() > arguments_.barrier_hi ||
                           x0Quote->value() < arguments_.barrier_lo) &&
                          arguments_.barrierType == DoubleBarrier::KnockIn) {
                     results_.value = adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["VanillaPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierInPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierOutPrice"] = 0.0;
                 } else {

                     // set up BS barrier option pricing
                     // only calculate out barrier option price
                     // in barrier price = vanilla - out barrier
                     ext::shared_ptr<StrikedTypePayoff> payoff =
                         ext::static_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
                     DoubleBarrierOption doubleBarrierOption(
                         DoubleBarrier::KnockOut, arguments_.barrier_lo, arguments_.barrier_hi,
                         arguments_.rebate, payoff, arguments_.exercise);

                     doubleBarrierOption.setPricingEngine(engineBS);

                     // BS price
                     Real priceBS = doubleBarrierOption.NPV();

                     Real priceAtmCallBS = blackFormula(
                         Option::Call, atmStrike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));
                     Real price25CallBS = blackFormula(
                         Option::Call, call25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));
                     Real price25PutBS = blackFormula(
                         Option::Put, put25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));

                     // market price
                     Real priceAtmCallMkt = blackFormula(
                         Option::Call, atmStrike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));
                     Real price25CallMkt = blackFormula(
                         Option::Call, call25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         call25Vol * sqrt(T_), domesticTS_->discount(T_));
                     Real price25PutMkt = blackFormula(
                         Option::Put, put25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         put25Vol * sqrt(T_), domesticTS_->discount(T_));

                     // Analytical Black Scholes formula
                     NormalDistribution norm;
                     Real d1atm = (std::log(x0Quote->value() * foreignTS_->discount(T_) /
                                            domesticTS_->discount(T_) / atmStrike) +
                                   0.5 * std::pow(atmVolQuote->value(), 2.0) * T_) /
                                  (atmVolQuote->value() * sqrt(T_));
                     Real vegaAtm_Analytical =
                         x0Quote->value() * norm(d1atm) * sqrt(T_) * foreignTS_->discount(T_);
                     Real vannaAtm_Analytical = vegaAtm_Analytical / x0Quote->value() *
                                                (1.0 - d1atm / (atmVolQuote->value() * sqrt(T_)));
                     Real volgaAtm_Analytical = vegaAtm_Analytical * d1atm *
                                                (d1atm - atmVolQuote->value() * sqrt(T_)) /
                                                atmVolQuote->value();

                     Real d125call = (std::log(x0Quote->value() * foreignTS_->discount(T_) /
                                               domesticTS_->discount(T_) / call25Strike) +
                                      0.5 * std::pow(atmVolQuote->value(), 2.0) * T_) /
                                     (atmVolQuote->value() * sqrt(T_));
                     Real vega25Call_Analytical =
                         x0Quote->value() * norm(d125call) * sqrt(T_) * foreignTS_->discount(T_);
                     Real vanna25Call_Analytical =
                         vega25Call_Analytical / x0Quote->value() *
                         (1.0 - d125call / (atmVolQuote->value() * sqrt(T_)));
                     Real volga25Call_Analytical = vega25Call_Analytical * d125call *
                                                   (d125call - atmVolQuote->value() * sqrt(T_)) /
                                                   atmVolQuote->value();

                     Real d125Put = (std::log(x0Quote->value() * foreignTS_->discount(T_) /
                                              domesticTS_->discount(T_) / put25Strike) +
                                     0.5 * std::pow(atmVolQuote->value(), 2.0) * T_) /
                                    (atmVolQuote->value() * sqrt(T_));
                     Real vega25Put_Analytical =
                         x0Quote->value() * norm(d125Put) * sqrt(T_) * foreignTS_->discount(T_);
                     Real vanna25Put_Analytical =
                         vega25Put_Analytical / x0Quote->value() *
                         (1.0 - d125Put / (atmVolQuote->value() * sqrt(T_)));
                     Real volga25Put_Analytical = vega25Put_Analytical * d125Put *
                                                  (d125Put - atmVolQuote->value() * sqrt(T_)) /
                                                  atmVolQuote->value();


                     // BS vega
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_vega);
                     doubleBarrierOption.recalculate();
                     Real vegaBarBS = (doubleBarrierOption.NPV() - priceBS) / sigmaShift_vega;
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() - sigmaShift_vega); // setback

                     // BS volga

                     // vegaBar2
                     // base NPV
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_volga);
                     doubleBarrierOption.recalculate();
                     Real priceBS2 = doubleBarrierOption.NPV();

                     // shifted npv
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_vega);
                     doubleBarrierOption.recalculate();
                     Real vegaBarBS2 = (doubleBarrierOption.NPV() - priceBS2) / sigmaShift_vega;
                     Real volgaBarBS = (vegaBarBS2 - vegaBarBS) / sigmaShift_volga;
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() - sigmaShift_volga -
                                    sigmaShift_vega); // setback

                     // BS Delta
                     // base delta
                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // shift forth
                     doubleBarrierOption.recalculate();
                     Real priceBS_delta1 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() - 2 * spotShift_delta); // shift back
                     doubleBarrierOption.recalculate();
                     Real priceBS_delta2 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // set back
                     Real deltaBar1 = (priceBS_delta1 - priceBS_delta2) / (2.0 * spotShift_delta);

                     // shifted vanna
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_vanna); // shift sigma
                     // shifted delta
                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // shift forth
                     doubleBarrierOption.recalculate();
                     priceBS_delta1 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() - 2 * spotShift_delta); // shift back
                     doubleBarrierOption.recalculate();
                     priceBS_delta2 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // set back
                     Real deltaBar2 = (priceBS_delta1 - priceBS_delta2) / (2.0 * spotShift_delta);

                     Real vannaBarBS = (deltaBar2 - deltaBar1) / sigmaShift_vanna;

                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() - sigmaShift_vanna); // set back

                     // Matrix
                     Matrix A(3, 3, 0.0);

                     // analytical
                     A[0][0] = vegaAtm_Analytical;
                     A[0][1] = vega25Call_Analytical;
                     A[0][2] = vega25Put_Analytical;
                     A[1][0] = vannaAtm_Analytical;
                     A[1][1] = vanna25Call_Analytical;
                     A[1][2] = vanna25Put_Analytical;
                     A[2][0] = volgaAtm_Analytical;
                     A[2][1] = volga25Call_Analytical;
                     A[2][2] = volga25Put_Analytical;

                     Array b(3, 0.0);
                     b[0] = vegaBarBS;
                     b[1] = vannaBarBS;
                     b[2] = volgaBarBS;
                     Array q = inverse(A) * b;

                     Real H = arguments_.barrier_hi;
                     Real L = arguments_.barrier_lo;
                     Real theta_tilt_minus = ((domesticTS_->zeroRate(T_, Continuous) -
                                               foreignTS_->zeroRate(T_, Continuous)) /
                                                  atmVol_->value() -
                                              atmVol_->value() / 2.0) *
                                             std::sqrt(T_);
                     Real h =
                         1.0 / atmVol_->value() * std::log(H / x0Quote->value()) / std::sqrt(T_);
                     Real l =
                         1.0 / atmVol_->value() * std::log(L / x0Quote->value()) / std::sqrt(T_);
                     CumulativeNormalDistribution cnd;

                     Real doubleNoTouch = 0.0;
                     for (int j = -series_; j < series_; j++) {
                         Real e_minus = 2 * j * (h - l) - theta_tilt_minus;
                         doubleNoTouch +=
                             std::exp(-2.0 * j * theta_tilt_minus * (h - l)) *
                                 (cnd(h + e_minus) - cnd(l + e_minus)) -
                             std::exp(-2.0 * j * theta_tilt_minus * (h - l) +
                                      2.0 * theta_tilt_minus * h) *
                                 (cnd(h - 2.0 * h + e_minus) - cnd(l - 2.0 * h + e_minus));
                     }

                     Real p_survival = doubleNoTouch;

                     Real lambda = p_survival;
                     Real adjust = q[0] * (priceAtmCallMkt - priceAtmCallBS) +
                                   q[1] * (price25CallMkt - price25CallBS) +
                                   q[2] * (price25PutMkt - price25PutBS);
                     Real outPrice = priceBS + lambda * adjust; //
                     Real inPrice;

                     // adapt Vanilla delta
                     if (adaptVanDelta_) {
                         outPrice += lambda * (bsPriceWithSmile_ - vanillaOption);
                         // capfloored by (0, vanilla)
                         outPrice = std::max(0.0, std::min(bsPriceWithSmile_, outPrice));
                         inPrice = bsPriceWithSmile_ - outPrice;
                     } else {
                         // capfloored by (0, vanilla)
                         outPrice = std::max(0.0, std::min(vanillaOption, outPrice));
                         inPrice = vanillaOption - outPrice;
                     }

                     if (arguments_.barrierType == DoubleBarrier::KnockOut)
                         results_.value = outPrice;
                     else
                         results_.value = inPrice;
                     results_.additionalResults["VanillaPrice"] = vanillaOption;
                     results_.additionalResults["BarrierInPrice"] = inPrice;
                     results_.additionalResults["BarrierOutPrice"] = outPrice;
                     results_.additionalResults["lambda"] = lambda;
                 }
             }


         private:
           const Handle<DeltaVolQuote> atmVol_;
           const Handle<DeltaVolQuote> vol25Put_;
           const Handle<DeltaVolQuote> vol25Call_;
           const Time T_;
           const Handle<Quote> spotFX_;
           const Handle<YieldTermStructure> domesticTS_;
           const Handle<YieldTermStructure> foreignTS_;
           const bool adaptVanDelta_;
           const Real bsPriceWithSmile_;
           const int series_;
       };


}

#endif
]]></document_content>
  </document>
  <document index="48">
    <source>barrieroption/vannavolgainterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vannavolgainterpolation.hpp
    \brief Vanna/Volga interpolation between discrete points
*/

#ifndef quantlib_vanna_volga_interpolation_hpp
#define quantlib_vanna_volga_interpolation_hpp

#include <ql/math/interpolation.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <vector>

namespace QuantLib {

    namespace detail {
        template<class I1, class I2> class VannaVolgaInterpolationImpl;
    }

    //! %Vanna Volga interpolation between discrete points
    class VannaVolgaInterpolation : public Interpolation {
      public:
        /*! \pre the \f$ x \f$ values must be sorted. */
        template <class I1, class I2>
        VannaVolgaInterpolation(const I1& xBegin, const I1& xEnd,
                            const I2& yBegin,
                            Real spot,
                            DiscountFactor dDiscount,
                            DiscountFactor fDiscount,
                            Time T) {
            impl_ = ext::make_shared<
                detail::VannaVolgaInterpolationImpl<I1,I2> >(
                    xBegin, xEnd, yBegin,
                    spot, dDiscount, fDiscount, T);
            impl_->update();
        }
    };

    //! %VannaVolga-interpolation factory and traits
    class VannaVolga {
      public:
        VannaVolga(Real spot,
                   DiscountFactor dDiscount,
                   DiscountFactor fDiscount,
                   Time T)
        :spot_(spot), dDiscount_(dDiscount), fDiscount_(fDiscount), T_(T)
        {}
        template <class I1, class I2>
        Interpolation interpolate(const I1& xBegin, const I1& xEnd,
                                  const I2& yBegin) const {
            return VannaVolgaInterpolation(xBegin, xEnd, yBegin, spot_, dDiscount_, fDiscount_, T_);
        }
        static const Size requiredPoints = 3;
      private:
        Real spot_;
        DiscountFactor dDiscount_;
        DiscountFactor fDiscount_;
        Time T_;
    };

    namespace detail {

        template <class I1, class I2>
        class VannaVolgaInterpolationImpl
            : public Interpolation::templateImpl<I1,I2> {
          public:
            VannaVolgaInterpolationImpl(const I1& xBegin, const I1& xEnd,
                                    const I2& yBegin,
                                    Real spot,
                                    DiscountFactor dDiscount,
                                    DiscountFactor fDiscount,
                                    Time T)
            : Interpolation::templateImpl<I1,I2>(xBegin, xEnd, yBegin,
                                                 VannaVolga::requiredPoints),
              spot_(spot), dDiscount_(dDiscount), fDiscount_(fDiscount), T_(T) {
                QL_REQUIRE(this->xEnd_-this->xBegin_ == 3,
                    "Vanna Volga Interpolator only interpolates 3 volatilities in strike space");
            }
            void update() override {
                //atmVol should be the second vol
                atmVol_ = this->yBegin_[1];
                fwd_ = spot_*fDiscount_/dDiscount_;
                for(Size i = 0; i < 3; i++){
                    premiaBS.push_back(blackFormula(Option::Call, this->xBegin_[i], fwd_, atmVol_ * std::sqrt(T_), dDiscount_));
                    premiaMKT.push_back(blackFormula(Option::Call, this->xBegin_[i], fwd_, this->yBegin_[i] * std::sqrt(T_), dDiscount_));
                    vegas.push_back(vega(this->xBegin_[i]));
                }
            }
            Real value(Real k) const override {
                Real x1 = vega(k)/vegas[0]
                    * (std::log(this->xBegin_[1]/k) * std::log(this->xBegin_[2]/k))
                    / (std::log(this->xBegin_[1]/this->xBegin_[0]) * std::log(this->xBegin_[2]/this->xBegin_[0]));
                Real x2 = vega(k)/vegas[1]
                    * (std::log(k/this->xBegin_[0]) * std::log(this->xBegin_[2]/k))
                    / (std::log(this->xBegin_[1]/this->xBegin_[0]) * std::log(this->xBegin_[2]/this->xBegin_[1]));
                Real x3 = vega(k)/vegas[2]
                    * (std::log(k/this->xBegin_[0]) * std::log(k/this->xBegin_[1]))
                    / (std::log(this->xBegin_[2]/this->xBegin_[0]) * std::log(this->xBegin_[2]/this->xBegin_[1]));

                Real cBS = blackFormula(Option::Call, k, fwd_, atmVol_ * std::sqrt(T_), dDiscount_);
                Real c = cBS + x1*(premiaMKT[0] - premiaBS[0]) + x2*(premiaMKT[1] - premiaBS[1]) + x3*(premiaMKT[2] - premiaBS[2]);
                Real std = blackFormulaImpliedStdDev(Option::Call, k, fwd_, c, dDiscount_);
                return std / sqrt(T_);
            }
            Real primitive(Real) const override {
                QL_FAIL("Vanna Volga primitive not implemented");
            }
            Real derivative(Real) const override {
                QL_FAIL("Vanna Volga derivative not implemented");
            }
            Real secondDerivative(Real) const override {
                QL_FAIL("Vanna Volga secondDerivative not implemented");
            }

          private:
            std::vector<Real> premiaBS;
            std::vector<Real> premiaMKT;
            std::vector<Real> vegas;
            Real atmVol_;
            Real spot_;
            Real fwd_;
            DiscountFactor dDiscount_;
            DiscountFactor fDiscount_;
            Time T_;

            Real vega(Real k) const {
                Real d1 = (std::log(fwd_/k) + 0.5 * std::pow(atmVol_, 2.0) * T_)/(atmVol_ * std::sqrt(T_));
                NormalDistribution norm;
                return spot_ * dDiscount_ * std::sqrt(T_) * norm(d1);
            }
        };

    }

}

#endif
]]></document_content>
  </document>
  <document index="49">
    <source>barrieroption/wulinyongdoublebarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/barrieroption/wulinyongdoublebarrierengine.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    WulinYongDoubleBarrierEngine::WulinYongDoubleBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series)
    : process_(std::move(process)), series_(series) {
        registerWith(process_);
    }

    void WulinYongDoubleBarrierEngine::calculate() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0,
                   "strike must be positive");

        Real K = payoff->strike();
        Real S = process_->x0();
        QL_REQUIRE(S >= 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(S), "barrier touched");

        DoubleBarrier::Type barrierType = arguments_.barrierType;
        QL_REQUIRE(barrierType == DoubleBarrier::KnockOut || 
                   barrierType == DoubleBarrier::KnockIn,
                   "only KnockIn and KnockOut options supported");

        Real L = arguments_.barrier_lo;
        Real H = arguments_.barrier_hi;
        Real K_up = std::min(H, K);
        Real K_down = std::max(L, K);
        Time T = residualTime();
        Real rd = riskFreeRate();
        Real dd = riskFreeDiscount();
        Real rf = dividendYield();
        Real df = dividendDiscount();
        Real vol = volatility();
        Real mu = rd - rf - vol*vol/2.0;
        Real sgn = mu > 0 ? 1.0 :(mu < 0 ? -1.0: 0.0);
        //rebate
        Real R_L = arguments_.rebate;
        Real R_H = arguments_.rebate;

        //european option
        EuropeanOption europeanOption(payoff, arguments_.exercise);
        ext::shared_ptr<PricingEngine> analyticEuropeanEngine =
            ext::make_shared<AnalyticEuropeanEngine>(process_);
        europeanOption.setPricingEngine(analyticEuropeanEngine);
        Real european = europeanOption.NPV();

        Real barrierOut = 0;
        Real rebateIn = 0;
        for(int n = -series_; n < series_; n++){
            Real d1 = D(S/H*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
            Real d2 = d1 - vol*std::sqrt(T);
            Real g1 = D(H/S*std::pow(L/H, 2.0*n - 1.0), vol*vol+mu, vol, T);
            Real g2 = g1 - vol*std::sqrt(T);
            Real h1 = D(S/H*std::pow(L/H, 2.0*n - 1.0), vol*vol+mu, vol, T);
            Real h2 = h1 - vol*std::sqrt(T);
            Real k1 = D(L/S*std::pow(L/H, 2.0*n - 1.0), vol*vol+mu, vol, T);
            Real k2 = k1 - vol*std::sqrt(T);
            Real d1_down = D(S/K_down*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
            Real d2_down = d1_down - vol*std::sqrt(T);
            Real d1_up = D(S/K_up*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
            Real d2_up = d1_up - vol*std::sqrt(T);
            Real k1_down = D((H*H)/(K_down*S)*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
            Real k2_down = k1_down - vol*std::sqrt(T);
            Real k1_up = D((H*H)/(K_up*S)*std::pow(L/H, 2.0*n), vol*vol+mu, vol, T);
            Real k2_up = k1_up - vol*std::sqrt(T);

            if( payoff->optionType() == Option::Call) {
                barrierOut += std::pow(L/H, 2.0 * n * mu/(vol*vol))*
                            (df*S*std::pow(L/H, 2.0*n)*(f_(d1_down)-f_(d1))
                            -dd*K*(f_(d2_down)-f_(d2))
                            -df*std::pow(L/H, 2.0*n)*H*H/S*std::pow(H/S, 2.0*mu/(vol*vol))*(f_(k1_down)-f_(k1))
                            +dd*K*std::pow(H/S,2.0*mu/(vol*vol))*(f_(k2_down)-f_(k2)));
            }
            else if(payoff->optionType() == Option::Put){
                barrierOut += std::pow(L/H, 2.0 * n * mu/(vol*vol))*
                            (dd*K*(f_(h2)-f_(d2_up))
                            -df*S*std::pow(L/H, 2.0*n)*(f_(h1)-f_(d1_up))
                            -dd*K*std::pow(H/S,2.0*mu/(vol*vol))*(f_(g2)-f_(k2_up))
                            +df*std::pow(L/H, 2.0*n)*H*H/S*std::pow(H/S, 2.0*mu/(vol*vol))*(f_(g1)-f_(k1_up)));
            }
            else {
                QL_FAIL("option type not recognized");
            }

            Real v1 = D(H/S*std::pow(H/L, 2.0*n), -mu, vol, T);
            Real v2 = D(H/S*std::pow(H/L, 2.0*n), mu, vol, T);
            Real v3 = D(S/L*std::pow(H/L, 2.0*n), -mu, vol, T);
            Real v4 = D(S/L*std::pow(H/L, 2.0*n), mu, vol, T);
            rebateIn +=  dd * R_H * sgn * (std::pow(L/H, 2.0*n*mu/(vol*vol)) * f_(sgn * v1) - std::pow(H/S, 2.0*mu/(vol*vol)) * f_(-sgn * v2))
                       + dd * R_L * sgn * (std::pow(L/S, 2.0*mu/(vol*vol)) * f_(-sgn * v3) - std::pow(H/L, 2.0*n*mu/(vol*vol)) * f_(sgn * v4));
        }

        //rebate paid at maturity
        if(barrierType == DoubleBarrier::KnockOut)
            results_.value = barrierOut ;
        else
            results_.value = european - barrierOut;
        results_.additionalResults["vanilla"] = european;
        results_.additionalResults["barrierOut"] = barrierOut;
        results_.additionalResults["barrierIn"] = european - barrierOut;
        results_.additionalResults["rebateIn"] = rebateIn;
    }


    Real WulinYongDoubleBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time WulinYongDoubleBarrierEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility WulinYongDoubleBarrierEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Rate WulinYongDoubleBarrierEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor WulinYongDoubleBarrierEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate WulinYongDoubleBarrierEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor WulinYongDoubleBarrierEngine::dividendDiscount() const {
        return process_->dividendYield()->discount(residualTime());
    }

    Real WulinYongDoubleBarrierEngine::D(Real X, Real lambda, Real sigma, Real T) const {
        return (std::log(X) + lambda * T)/(sigma * std::sqrt(T));
    }

}

]]></document_content>
  </document>
  <document index="50">
    <source>barrieroption/wulinyongdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file wulinyongdoublebarrierengine.hpp
    \brief Wulin Suo, Yong Wang double-barrier option engine
*/

#ifndef wulin_yong_double_barrier_engine_hpp
#define wulin_yong_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for barrier options using analytical formulae
    /*! The formulas are taken from "Barrier Option Pricing",
         Wulin Suo, Yong Wang.

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class WulinYongDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        explicit WulinYongDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series = 5);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        const int series_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real D(Real X, Real lambda, Real sigma, Real T) const;

    };

}


#endif
]]></document_content>
  </document>
  <document index="51">
    <source>basismodels/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    swaptioncfs.hpp \
    tenoroptionletvts.hpp \
    tenorswaptionvts.hpp

cpp_files = \
    swaptioncfs.cpp \
    tenoroptionletvts.cpp \
    tenorswaptionvts.cpp

if UNITY_BUILD

nodist_libBasisModels_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libBasisModels_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libBasisModels.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="52">
    <source>basismodels/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/basismodels/swaptioncfs.hpp>
#include <ql/experimental/basismodels/tenoroptionletvts.hpp>
#include <ql/experimental/basismodels/tenorswaptionvts.hpp>

]]></document_content>
  </document>
  <document index="53">
    <source>basismodels/swaptioncfs.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swaptioncfs.cpp
    \brief translate swaption into deterministic fixed and float cash flows
*/

#include <ql/experimental/basismodels/swaptioncfs.hpp>
#include <ql/cashflows/coupon.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/exercise.hpp>
#include <ql/settings.hpp>


namespace QuantLib {

    IborLegCashFlows::IborLegCashFlows(const Leg& iborLeg,
                                       const Handle<YieldTermStructure>& discountCurve,
                                       bool contTenorSpread)
    : refDate_(discountCurve->referenceDate()) {
        // we need to find the first coupon for initial payment
        Size floatIdx = 0;
        while (
            (floatIdx + 1 < iborLeg.size()) &&
            (refDate_ > (ext::dynamic_pointer_cast<Coupon>(iborLeg[floatIdx]))->accrualStartDate()))
            ++floatIdx;
        if (refDate_ <= (ext::dynamic_pointer_cast<Coupon>(iborLeg[floatIdx]))
                            ->accrualStartDate()) { // otherwise there is no floating coupon left
            ext::shared_ptr<Coupon> firstFloatCoupon =
                ext::dynamic_pointer_cast<Coupon>(iborLeg[floatIdx]);
            floatLeg_.push_back(ext::shared_ptr<CashFlow>(new SimpleCashFlow(
                firstFloatCoupon->nominal(), firstFloatCoupon->accrualStartDate())));
            // calculate spread payments
            for (Size k = floatIdx; k < iborLeg.size(); ++k) {
                ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(iborLeg[k]);
                if (!coupon)
                    QL_FAIL("FloatingLeg CashFlow is no Coupon.");
                Date startDate = coupon->accrualStartDate();
                Date endDate = coupon->accrualEndDate();
                Rate liborForwardRate = coupon->rate();
                Rate discForwardRate =
                    (discountCurve->discount(startDate) / discountCurve->discount(endDate) - 1.0) /
                    coupon->accrualPeriod();
                Rate spread;
                Date payDate;
                if (contTenorSpread) {
                    // Db = (1 + Delta L^libor) / (1 + Delta L^ois)
                    // spread (Db - 1) paid at startDate
                    spread = ((1.0 + coupon->accrualPeriod() * liborForwardRate) /
                                  (1.0 + coupon->accrualPeriod() * discForwardRate) -
                              1.0) /
                             coupon->accrualPeriod();
                    payDate = startDate;
                } else {
                    // spread L^libor - L^ois
                    spread = liborForwardRate - discForwardRate;
                    payDate = coupon->date();
                }
                floatLeg_.push_back(ext::shared_ptr<CashFlow>(new FixedRateCoupon(
                    payDate, coupon->nominal(), spread, coupon->dayCounter(), startDate, endDate)));
            } // for ...
              // finally, add the notional at the last date
            ext::shared_ptr<Coupon> lastFloatCoupon =
                ext::dynamic_pointer_cast<Coupon>(iborLeg.back());
            floatLeg_.push_back(ext::shared_ptr<CashFlow>(new SimpleCashFlow(
                -1.0 * lastFloatCoupon->nominal(), lastFloatCoupon->accrualEndDate())));
        } // if ...
        // assemble raw cash flow data...
        Actual365Fixed dc;
        // ... float times/weights
        for (auto& k : floatLeg_)
            floatTimes_.push_back(dc.yearFraction(refDate_, k->date()));
        for (auto& k : floatLeg_)
            floatWeights_.push_back(k->amount());
    }

    SwapCashFlows::SwapCashFlows(const ext::shared_ptr<VanillaSwap>& swap,
                                 const Handle<YieldTermStructure>& discountCurve,
                                 bool contTenorSpread)
    : IborLegCashFlows(swap->floatingLeg(), discountCurve, contTenorSpread) {
        // copy fixed leg coupons
        Leg fixedLeg = swap->fixedLeg();
        for (auto& k : fixedLeg) {
            if (ext::dynamic_pointer_cast<Coupon>(k)->accrualStartDate() >= refDate_)
                fixedLeg_.push_back(k);
        }
        Actual365Fixed dc;
        // ... fixed times/weights
        for (auto& k : fixedLeg_)
            fixedTimes_.push_back(dc.yearFraction(refDate_, k->date()));
        for (auto& k : fixedLeg_)
            fixedWeights_.push_back(k->amount());
        for (auto& k : fixedLeg_) {
            ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(k);
            if (coupon != nullptr)
                annuityWeights_.push_back(coupon->nominal() * coupon->accrualPeriod());
        }
    }


    // constructor to map a swaption to deterministic fixed and floating leg cash flows
    SwaptionCashFlows::SwaptionCashFlows(const ext::shared_ptr<Swaption>& swaption,
                                         const Handle<YieldTermStructure>& discountCurve,
                                         bool contTenorSpread)
    : SwapCashFlows(swaption->underlyingSwap(), discountCurve, contTenorSpread),
      swaption_(swaption) {
        // assemble raw cash flow data...
        Actual365Fixed dc;
        // ... exercise times
        for (Size k = 0; k < swaption_->exercise()->dates().size(); ++k)
            if (swaption_->exercise()->dates()[k] > refDate_) // consider only future exercise dates
                exerciseTimes_.push_back(
                    dc.yearFraction(refDate_, swaption_->exercise()->dates()[k]));
    }


}
]]></document_content>
  </document>
  <document index="54">
    <source>basismodels/swaptioncfs.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swaptioncfs.hpp
    \brief translate swaption into deterministic fixed and float cash flows
*/

#ifndef quantlib_swaptioncfs_hpp
#define quantlib_swaptioncfs_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/option.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/date.hpp>

namespace QuantLib {

    class IborLegCashFlows {
      protected:
        Date refDate_; // today, base for time calculations w.r.t. Act/365 (Fixed)
        Leg floatLeg_;
        std::vector<Real> floatTimes_;
        std::vector<Real> floatWeights_;

      public:
        inline const Leg& floatLeg() const { return floatLeg_; }
        inline const std::vector<Real>& floatTimes() const { return floatTimes_; }
        inline const std::vector<Real>& floatWeights() const { return floatWeights_; }
        IborLegCashFlows(const Leg& iborLeg,
                         const Handle<YieldTermStructure>& discountCurve,
                         bool contTenorSpread = true);
        IborLegCashFlows() = default;
        ; // allow default constructor which does nothing
    };


    class SwapCashFlows : public IborLegCashFlows {
      protected:
        // resulting cash flows as leg
        Leg fixedLeg_;
        std::vector<Real> fixedTimes_;
        std::vector<Real> fixedWeights_;
        std::vector<Real> annuityWeights_;

      public:
        SwapCashFlows(const ext::shared_ptr<VanillaSwap>& swap,
                      const Handle<YieldTermStructure>& discountCurve,
                      bool contTenorSpread = true);
        SwapCashFlows() = default;
        ; // allow default constructor which does nothing
          // inspectors
        inline const Leg& fixedLeg() const { return fixedLeg_; }
        inline const std::vector<Real>& fixedTimes() const { return fixedTimes_; }
        inline const std::vector<Real>& fixedWeights() const { return fixedWeights_; }
        inline const std::vector<Real>& annuityWeights() const { return annuityWeights_; }
    };


    class SwaptionCashFlows : public SwapCashFlows {
      protected:
        ext::shared_ptr<Swaption> swaption_;
        std::vector<Real> exerciseTimes_;

      public:
        SwaptionCashFlows(const ext::shared_ptr<Swaption>& swaption,
                          const Handle<YieldTermStructure>& discountCurve,
                          bool contTenorSpread = true);
        SwaptionCashFlows() = default;
        ; // allow default constructor which does nothing
        // inspectors
        inline ext::shared_ptr<Swaption> swaption() const { return swaption_; }
        inline const std::vector<Real>& exerciseTimes() const { return exerciseTimes_; }
    };


}

#endif
]]></document_content>
  </document>
  <document index="55">
    <source>basismodels/tenoroptionletvts.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tenoroptionletvts.cpp
    \brief caplet volatility term structure based on volatility transformation
*/

#include <ql/exercise.hpp>
#include <ql/experimental/basismodels/tenoroptionletvts.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/math/rounding.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/time/schedule.hpp>
#include <utility>


namespace QuantLib {

    TenorOptionletVTS::TenorOptionletVTS(const Handle<OptionletVolatilityStructure>& baseVTS,
                                         ext::shared_ptr<IborIndex> baseIndex,
                                         ext::shared_ptr<IborIndex> targIndex,
                                         ext::shared_ptr<CorrelationStructure> correlation)
    : OptionletVolatilityStructure(baseVTS->referenceDate(),
                                   baseVTS->calendar(),
                                   baseVTS->businessDayConvention(),
                                   baseVTS->dayCounter()),
      baseVTS_(baseVTS), baseIndex_(std::move(baseIndex)), targIndex_(std::move(targIndex)),
      correlation_(std::move(correlation)) {
        QL_REQUIRE(baseIndex_->tenor().frequency() % targIndex_->tenor().frequency() == 0,
                   "Base index frequency must be a multiple of target tenor frequency");
    }


    TenorOptionletVTS::TenorOptionletSmileSection::TenorOptionletSmileSection(
        const TenorOptionletVTS& volTS, const Time optionTime)
    : SmileSection(optionTime, volTS.baseVTS_->dayCounter(), Normal, 0.0),
      correlation_(volTS.correlation_) {
        // we assume that long (target) tenor is a multiple of short (base) tenor
        // first we need the long tenor start and end date
        Real oneDayAsYear =
            volTS.dayCounter().yearFraction(volTS.referenceDate(), volTS.referenceDate() + 1);
        Date exerciseDate =
            volTS.referenceDate() + ((BigInteger)ClosestRounding(0)(optionTime / oneDayAsYear));
        Date effectiveDate = volTS.baseIndex_->fixingCalendar().advance(
            exerciseDate, volTS.baseIndex_->fixingDays() * Days);
        Date maturityDate = volTS.baseIndex_->fixingCalendar().advance(
            effectiveDate, volTS.targIndex_->tenor(), Unadjusted, false);
        // now we can set up the short tenor schedule
        Schedule baseFloatSchedule(effectiveDate, maturityDate, volTS.baseIndex_->tenor(),
                                   volTS.baseIndex_->fixingCalendar(), ModifiedFollowing,
                                   Unadjusted, DateGeneration::Backward, false);
        // set up scalar attributes
        fraRateTarg_ = volTS.targIndex_->fixing(exerciseDate);
        Time yfTarg = volTS.targIndex_->dayCounter().yearFraction(effectiveDate, maturityDate);
        for (Size k = 0; k < baseFloatSchedule.dates().size() - 1; ++k) {
            Date startDate = baseFloatSchedule.dates()[k];
            Date fixingDate = volTS.baseIndex_->fixingCalendar().advance(
                startDate, (-1 * volTS.baseIndex_->fixingDays()) * Days);
            Time yearFrac = volTS.baseIndex_->dayCounter().yearFraction(
                baseFloatSchedule.dates()[k], baseFloatSchedule.dates()[k + 1]);
            // set up vector attributes
            baseSmileSection_.push_back(volTS.baseVTS_->smileSection(fixingDate, true));
            startTimeBase_.push_back(
                volTS.dayCounter().yearFraction(volTS.referenceDate(), startDate));
            fraRateBase_.push_back(volTS.baseIndex_->fixing(fixingDate));
            v_.push_back(yearFrac / yfTarg * (1.0 + yfTarg * fraRateTarg_) /
                         (1.0 + yearFrac * fraRateBase_[k]));
        }
    }

    Volatility TenorOptionletVTS::TenorOptionletSmileSection::volatilityImpl(Rate strike) const {
        Real sum_v = 0.0;
        for (double k : v_)
            sum_v += k;
        std::vector<Real> volBase(v_.size());
        for (Size k = 0; k < fraRateBase_.size(); ++k) {
            Real strike_k = (strike - (fraRateTarg_ - sum_v * fraRateBase_[k])) / sum_v;
            volBase[k] = baseSmileSection_[k]->volatility(strike_k, Normal, 0.0);
        }
        Real var = 0.0;
        for (Size i = 0; i < volBase.size(); ++i) {
            var += v_[i] * v_[i] * volBase[i] * volBase[i];
            for (Size j = i + 1; j < volBase.size(); ++j) {
                Real corr = (*correlation_)(startTimeBase_[i], startTimeBase_[j]);
                var += 2.0 * corr * v_[i] * v_[j] * volBase[i] * volBase[j];
            }
        }
        Real vol = sqrt(var);
        return vol;
    }


}
]]></document_content>
  </document>
  <document index="56">
    <source>basismodels/tenoroptionletvts.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tenoroptionletvts.hpp
    \brief caplet volatility term structure based on volatility transformation
*/

#ifndef quantlib_tenoroptionletvts_hpp
#define quantlib_tenoroptionletvts_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/termstructures/volatility/optionlet/optionletvolatilitystructure.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <utility>


namespace QuantLib {

    class TenorOptionletVTS : public OptionletVolatilityStructure {

      public:
        class CorrelationStructure; // declaration below

      protected:
        class TenorOptionletSmileSection : public SmileSection {
          protected:
            ext::shared_ptr<CorrelationStructure> correlation_;
            std::vector<ext::shared_ptr<SmileSection> > baseSmileSection_;
            std::vector<Time> startTimeBase_; // for correlation parametrisation
            std::vector<Real> fraRateBase_;
            Real fraRateTarg_;
            std::vector<Real> v_;
            // implement transformation formula
            Volatility volatilityImpl(Rate strike) const override;

          public:
            // constructor includes actual transformation details
            TenorOptionletSmileSection(const TenorOptionletVTS& volTS, Time optionTime);

            // further SmileSection interface methods
            Real minStrike() const override {
                return baseSmileSection_[0]->minStrike() + fraRateTarg_ - fraRateBase_[0];
            }
            Real maxStrike() const override {
                return baseSmileSection_[0]->maxStrike() + fraRateTarg_ - fraRateBase_[0];
            }
            Real atmLevel() const override { return fraRateTarg_; }
        };

        Handle<OptionletVolatilityStructure> baseVTS_;
        ext::shared_ptr<IborIndex> baseIndex_;
        ext::shared_ptr<IborIndex> targIndex_;
        ext::shared_ptr<CorrelationStructure> correlation_;

      public:
        // functor interface for parametric correlation
        class CorrelationStructure {
          public:
            // return the correlation between two FRA rates starting at start1 and start2
            virtual Real operator()(const Time& start1, const Time& start2) const = 0;
            virtual ~CorrelationStructure() = default;
            ;
        };

        // very basic choice for correlation structure
        class TwoParameterCorrelation : public CorrelationStructure {
          protected:
            ext::shared_ptr<Interpolation> rhoInf_;
            ext::shared_ptr<Interpolation> beta_;

          public:
            TwoParameterCorrelation(ext::shared_ptr<Interpolation> rhoInf,
                                    ext::shared_ptr<Interpolation> beta)
            : rhoInf_(std::move(rhoInf)), beta_(std::move(beta)) {}
            Real operator()(const Time& start1, const Time& start2) const override {
                Real rhoInf = (*rhoInf_)(start1);
                Real beta = (*beta_)(start1);
                Real rho = rhoInf + (1.0 - rhoInf) * exp(-beta * fabs(start2 - start1));
                return rho;
            }
        };

        // constructor
        TenorOptionletVTS(const Handle<OptionletVolatilityStructure>& baseVTS,
                          ext::shared_ptr<IborIndex> baseIndex,
                          ext::shared_ptr<IborIndex> targIndex,
                          ext::shared_ptr<CorrelationStructure> correlation);

        // Termstructure interface

        //! the latest date for which the curve can return values
        Date maxDate() const override { return baseVTS_->maxDate(); }

        // VolatilityTermstructure interface

        //! implements the actual smile calculation in derived classes
        ext::shared_ptr<SmileSection> smileSectionImpl(Time optionTime) const override {
            return ext::shared_ptr<SmileSection>(new TenorOptionletSmileSection(*this, optionTime));
        }
        //! implements the actual volatility calculation in derived classes
        Volatility volatilityImpl(Time optionTime, Rate strike) const override {
            return smileSection(optionTime)->volatility(strike);
        }


        //! the minimum strike for which the term structure can return vols
        Rate minStrike() const override { return baseVTS_->minStrike(); }
        //! the maximum strike for which the term structure can return vols
        Rate maxStrike() const override { return baseVTS_->maxStrike(); }

        // the methodology is designed for normal volatilities
        VolatilityType volatilityType() const override { return Normal; }
    };

    typedef TenorOptionletVTS::CorrelationStructure TenorOptionletVTSCorrelationStructure;

}

#endif
]]></document_content>
  </document>
  <document index="57">
    <source>basismodels/tenorswaptionvts.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tenorswaptionvts.cpp
    \brief swaption volatility term structure based on volatility transformation
*/


#include <ql/experimental/basismodels/tenorswaptionvts.hpp>
#include <ql/experimental/basismodels/swaptioncfs.hpp>
#include <ql/exercise.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/math/rounding.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/time/dategenerationrule.hpp>


namespace QuantLib {

    TenorSwaptionVTS::TenorSwaptionSmileSection::TenorSwaptionSmileSection(
        const TenorSwaptionVTS& volTS, Time optionTime, Time swapLength)
    : SmileSection(optionTime, volTS.baseVTS_->dayCounter(), Normal, 0.0) {
        baseSmileSection_ = volTS.baseVTS_->smileSection(optionTime, swapLength, true);
        // first we need the swap start and end date
        Real oneDayAsYear =
            volTS.dayCounter().yearFraction(volTS.referenceDate(), volTS.referenceDate() + 1);
        Date exerciseDate =
            volTS.referenceDate() + ((BigInteger)ClosestRounding(0)(optionTime / oneDayAsYear));
        Date effectiveDate = volTS.baseIndex_->fixingCalendar().advance(
            exerciseDate, volTS.baseIndex_->fixingDays() * Days);
        Date maturityDate = volTS.baseIndex_->fixingCalendar().advance(
            effectiveDate, ((BigInteger)swapLength * 12.0) * Months, Unadjusted, false);
        // now we can set up the schedules
        Schedule baseFixedSchedule(effectiveDate, maturityDate, volTS.baseFixedFreq_,
                                   volTS.baseIndex_->fixingCalendar(), ModifiedFollowing,
                                   Unadjusted, DateGeneration::Backward, false);
        Schedule finlFixedSchedule(effectiveDate, maturityDate, volTS.targFixedFreq_,
                                   volTS.targIndex_->fixingCalendar(), ModifiedFollowing,
                                   Unadjusted, DateGeneration::Backward, false);
        Schedule baseFloatSchedule(effectiveDate, maturityDate, volTS.baseIndex_->tenor(),
                                   volTS.baseIndex_->fixingCalendar(), ModifiedFollowing,
                                   Unadjusted, DateGeneration::Backward, false);
        Schedule targFloatSchedule(effectiveDate, maturityDate, volTS.targIndex_->tenor(),
                                   volTS.baseIndex_->fixingCalendar(), ModifiedFollowing,
                                   Unadjusted, DateGeneration::Backward, false);
        // and swaps
        ext::shared_ptr<VanillaSwap> baseSwap(new VanillaSwap(
            Swap::Payer, 1.0, baseFixedSchedule, 1.0, volTS.baseFixedDC_, baseFloatSchedule,
            volTS.baseIndex_, 0.0, volTS.baseIndex_->dayCounter()));
        ext::shared_ptr<VanillaSwap> targSwap(new VanillaSwap(
            Swap::Payer, 1.0, baseFixedSchedule, 1.0, volTS.baseFixedDC_, targFloatSchedule,
            volTS.targIndex_, 0.0, volTS.targIndex_->dayCounter()));
        ext::shared_ptr<VanillaSwap> finlSwap(new VanillaSwap(
            Swap::Payer, 1.0, finlFixedSchedule, 1.0, volTS.targFixedDC_, targFloatSchedule,
            volTS.targIndex_, 0.0, volTS.targIndex_->dayCounter()));
        // adding engines
        baseSwap->setPricingEngine(
            ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(volTS.discountCurve_)));
        targSwap->setPricingEngine(
            ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(volTS.discountCurve_)));
        finlSwap->setPricingEngine(
            ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(volTS.discountCurve_)));
        // swap rates
        swapRateBase_ = baseSwap->fairRate();
        swapRateTarg_ = targSwap->fairRate();
        swapRateFinl_ = finlSwap->fairRate();
        SwaptionCashFlows cfs(
            ext::shared_ptr<Swaption>(new Swaption(
                baseSwap, ext::shared_ptr<Exercise>(new EuropeanExercise(exerciseDate)))),
            volTS.discountCurve_);
        SwaptionCashFlows cf2(
            ext::shared_ptr<Swaption>(new Swaption(
                targSwap, ext::shared_ptr<Exercise>(new EuropeanExercise(exerciseDate)))),
            volTS.discountCurve_);
        // calculate affine TSR model u and v
        // Sum tau_j   (fixed leg)
        Real sumTauj = 0.0;
        for (double k : cfs.annuityWeights())
            sumTauj += k;
        // Sum tau_j (T_M - T_j)   (fixed leg)
        Real sumTaujDeltaT = 0.0;
        for (Size k = 0; k < cfs.annuityWeights().size(); ++k)
            sumTaujDeltaT +=
                cfs.annuityWeights()[k] * (cfs.fixedTimes().back() - cfs.fixedTimes()[k]);
        // Sum w_i   (float leg)
        Real sumWi = 0.0;
        for (double k : cfs.floatWeights())
            sumWi += k;
        // Sum w_i (T_N - T_i)    (float leg)
        Real sumWiDeltaT = 0.0;
        for (Size k = 0; k < cfs.floatWeights().size(); ++k)
            sumWiDeltaT += cfs.floatWeights()[k] * (cfs.floatTimes().back() - cfs.floatTimes()[k]);
        // assemble u, v and a(T_p)
        Real den = sumTaujDeltaT * sumWi - sumWiDeltaT * sumTauj;
        Real u = -sumTauj / den;
        Real v = sumTaujDeltaT / den;
        Actual365Fixed dc;
        // a(T_p) = u (T_p - T_N) + v
        Real T_N = cfs.fixedTimes().back();
        Real sumBase = 0.0;
        Real sumTarg = 0.0;
        // we skip the first and last weight as they represent the notional flows
        for (Size k = 1; k < cfs.floatWeights().size() - 1; ++k)
            sumBase += cfs.floatWeights()[k] * (u * (T_N - cfs.floatTimes()[k]) + v);
        for (Size k = 1; k < cf2.floatWeights().size() - 1; ++k)
            sumTarg += cf2.floatWeights()[k] * (u * (T_N - cf2.floatTimes()[k]) + v);
        lambda_ = sumTarg - sumBase;
        // Annuity scaling
        annuityScaling_ = targSwap->fixedLegBPS() / finlSwap->fixedLegBPS();
    }

    Volatility TenorSwaptionVTS::TenorSwaptionSmileSection::volatilityImpl(Rate strike) const {
        Real strikeBase = (strike - (swapRateTarg_ - (1.0 + lambda_) * swapRateBase_)) /
                          (1.0 + lambda_) / annuityScaling_;
        Real volBase = baseSmileSection_->volatility(strikeBase, Normal, 0.0);
        Real volTarg = annuityScaling_ * (1.0 + lambda_) * volBase;
        return volTarg;
    }


}
]]></document_content>
  </document>
  <document index="58">
    <source>basismodels/tenorswaptionvts.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tenorswaptionvts.hpp
    \brief swaption volatility term structure based on volatility transformation
*/

#ifndef quantlib_tenorswaptionvts_hpp
#define quantlib_tenorswaptionvts_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/option.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/date.hpp>
#include <utility>

namespace QuantLib {

    class TenorSwaptionVTS : public SwaptionVolatilityStructure {
      protected:
        class TenorSwaptionSmileSection : public SmileSection {
          protected:
            ext::shared_ptr<SmileSection> baseSmileSection_;
            Real swapRateBase_;
            Real swapRateTarg_;
            Real swapRateFinl_;
            Real lambda_;
            Real annuityScaling_;
            // implement transformation formula
            Volatility volatilityImpl(Rate strike) const override;

          public:
            // constructor includes actual transformation details
            TenorSwaptionSmileSection(const TenorSwaptionVTS& volTS,
                                      Time optionTime,
                                      Time swapLength);

            // further SmileSection interface methods
            Real minStrike() const override {
                return baseSmileSection_->minStrike() + swapRateTarg_ - swapRateBase_;
            }
            Real maxStrike() const override {
                return baseSmileSection_->maxStrike() + swapRateTarg_ - swapRateBase_;
            }
            Real atmLevel() const override { return swapRateFinl_; }
        };

        Handle<SwaptionVolatilityStructure> baseVTS_;
        Handle<YieldTermStructure> discountCurve_;

        ext::shared_ptr<IborIndex> baseIndex_;
        ext::shared_ptr<IborIndex> targIndex_;
        Period baseFixedFreq_;
        Period targFixedFreq_;
        DayCounter baseFixedDC_;
        DayCounter targFixedDC_;

      public:
        // constructor
        TenorSwaptionVTS(const Handle<SwaptionVolatilityStructure>& baseVTS,
                         Handle<YieldTermStructure> discountCurve,
                         ext::shared_ptr<IborIndex> baseIndex,
                         ext::shared_ptr<IborIndex> targIndex,
                         const Period& baseFixedFreq,
                         const Period& targFixedFreq,
                         DayCounter baseFixedDC,
                         DayCounter targFixedDC)
        : SwaptionVolatilityStructure(baseVTS->referenceDate(),
                                      baseVTS->calendar(),
                                      baseVTS->businessDayConvention(),
                                      baseVTS->dayCounter()),
          baseVTS_(baseVTS), discountCurve_(std::move(discountCurve)),
          baseIndex_(std::move(baseIndex)), targIndex_(std::move(targIndex)),
          baseFixedFreq_(baseFixedFreq), targFixedFreq_(targFixedFreq),
          baseFixedDC_(std::move(baseFixedDC)), targFixedDC_(std::move(targFixedDC)) {}

        // Termstructure interface

        //! the latest date for which the curve can return values
        Date maxDate() const override { return baseVTS_->maxDate(); }

        // SwaptionVolatility interface

        //! the minimum strike for which the term structure can return vols
        Rate minStrike() const override { return baseVTS_->minStrike(); }
        //! the maximum strike for which the term structure can return vols
        Rate maxStrike() const override { return baseVTS_->maxStrike(); }


        // SwaptionVolatilityStructure interface

        //! the largest length for which the term structure can return vols
        const Period& maxSwapTenor() const override { return baseVTS_->maxSwapTenor(); }

        ext::shared_ptr<SmileSection> smileSectionImpl(Time optionTime,
                                                       Time swapLength) const override {
            return ext::shared_ptr<SmileSection>(
                new TenorSwaptionSmileSection(*this, optionTime, swapLength));
        }

        Volatility volatilityImpl(Time optionTime, Time swapLength, Rate strike) const override {
            return smileSectionImpl(optionTime, swapLength)->volatility(strike, Normal, 0.0);
        }

        // the methodology is designed for normal volatilities
        VolatilityType volatilityType() const override { return Normal; }
    };

}

#endif
]]></document_content>
  </document>
  <document index="59">
    <source>callablebonds/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    blackcallablebondengine.hpp \
    callablebondconstantvol.hpp \
    callablebond.hpp \
    callablebondvolstructure.hpp \
    discretizedcallablefixedratebond.hpp \
    treecallablebondengine.hpp

cpp_files = \
    blackcallablebondengine.cpp \
    callablebondconstantvol.cpp \
    callablebond.cpp \
    callablebondvolstructure.cpp \
    discretizedcallablefixedratebond.cpp \
    treecallablebondengine.cpp

if UNITY_BUILD

nodist_libCallableBonds_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libCallableBonds_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libCallableBonds.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="60">
    <source>callablebonds/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/callablebonds/blackcallablebondengine.hpp>
#include <ql/experimental/callablebonds/callablebondconstantvol.hpp>
#include <ql/experimental/callablebonds/callablebond.hpp>
#include <ql/experimental/callablebonds/callablebondvolstructure.hpp>
#include <ql/experimental/callablebonds/discretizedcallablefixedratebond.hpp>
#include <ql/experimental/callablebonds/treecallablebondengine.hpp>

]]></document_content>
  </document>
  <document index="61">
    <source>callablebonds/blackcallablebondengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/experimental/callablebonds/blackcallablebondengine.hpp>
#include <ql/experimental/callablebonds/callablebondconstantvol.hpp>
#include <ql/experimental/callablebonds/callablebondvolstructure.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    BlackCallableFixedRateBondEngine::BlackCallableFixedRateBondEngine(
        const Handle<Quote>& fwdYieldVol, Handle<YieldTermStructure> discountCurve)
    : volatility_(ext::shared_ptr<CallableBondVolatilityStructure>(
          new CallableBondConstantVolatility(0, NullCalendar(), fwdYieldVol, Actual365Fixed()))),
      discountCurve_(std::move(discountCurve)) {
        registerWith(volatility_);
        registerWith(discountCurve_);
    }

    //! no vol structures implemented yet besides constant volatility
    BlackCallableFixedRateBondEngine::BlackCallableFixedRateBondEngine(
        Handle<CallableBondVolatilityStructure> yieldVolStructure,
        Handle<YieldTermStructure> discountCurve)
    : volatility_(std::move(yieldVolStructure)), discountCurve_(std::move(discountCurve)) {
        registerWith(volatility_);
        registerWith(discountCurve_);
    }

    Real BlackCallableFixedRateBondEngine::spotIncome() const {
        //! settle date of embedded option assumed same as that of bond
        Date settlement = arguments_.settlementDate;
        Leg cf = arguments_.cashflows;
        Date optionMaturity = arguments_.putCallSchedule[0]->date();

        /* the following assumes
           1. cashflows are in ascending order !
           2. income = coupons paid between settlementDate() and put/call date
        */
        Real income = 0.0;
        for (Size i = 0; i < cf.size() - 1; ++i) {
            if (!cf[i]->hasOccurred(settlement, false)) {
                if (cf[i]->hasOccurred(optionMaturity, false)) {
                    income += cf[i]->amount() *
                              discountCurve_->discount(cf[i]->date());
                } else {
                    break;
                }
            }
        }
        return income/discountCurve_->discount(settlement);
    }


    Volatility BlackCallableFixedRateBondEngine::forwardPriceVolatility()
                                                                       const {
        Date bondMaturity = arguments_.redemptionDate;
        Date exerciseDate = arguments_.callabilityDates[0];
        Leg fixedLeg = arguments_.cashflows;

        // value of bond cash flows at option maturity
        Real fwdNpv = CashFlows::npv(fixedLeg,
                                     **discountCurve_,
                                     false, exerciseDate);

        DayCounter dayCounter = arguments_.paymentDayCounter;
        Frequency frequency = arguments_.frequency;

        // adjust if zero coupon bond (see also bond.cpp)
        if (frequency == NoFrequency || frequency == Once)
            frequency = Annual;

        Rate fwdYtm = CashFlows::yield(fixedLeg,
                                       fwdNpv,
                                       dayCounter,
                                       Compounded,
                                       frequency,
                                       false, exerciseDate);

        InterestRate fwdRate(fwdYtm,
                             dayCounter,
                             Compounded,
                             frequency);

        Time fwdDur = CashFlows::duration(fixedLeg,
                                          fwdRate,
                                          Duration::Modified,
                                          false, exerciseDate);

        Real cashStrike = arguments_.callabilityPrices[0];
        dayCounter = volatility_->dayCounter();
        Date referenceDate = volatility_->referenceDate();
        Time exerciseTime = dayCounter.yearFraction(referenceDate,
                                                    exerciseDate);
        Time maturityTime = dayCounter.yearFraction(referenceDate,
                                                    bondMaturity);
        Volatility yieldVol = volatility_->volatility(exerciseTime,
                                                      maturityTime-exerciseTime,
                                                      cashStrike);
        Volatility fwdPriceVol = yieldVol*fwdDur*fwdYtm;
        return fwdPriceVol;
    }


    void BlackCallableFixedRateBondEngine::calculate() const {
        // validate args for Black engine
        QL_REQUIRE(arguments_.putCallSchedule.size() == 1,
                   "Must have exactly one call/put date to use Black Engine");

        Date settle = arguments_.settlementDate;
        Date exerciseDate = arguments_.callabilityDates[0];
        QL_REQUIRE(exerciseDate >= settle,
                   "must have exercise Date >= settlement Date");

        Leg fixedLeg = arguments_.cashflows;

        Real value = CashFlows::npv(fixedLeg,
                                    **discountCurve_,
                                    false, settle);

        Real npv = CashFlows::npv(fixedLeg,
                                  **discountCurve_,
                                  false, discountCurve_->referenceDate());

        Real fwdCashPrice = (value - spotIncome())/
                            discountCurve_->discount(exerciseDate);

        Real cashStrike = arguments_.callabilityPrices[0];

        Option::Type type = (arguments_.putCallSchedule[0]->type() ==
                             Callability::Call ? Option::Call : Option::Put);

        Volatility priceVol = forwardPriceVolatility();

        Time exerciseTime = volatility_->dayCounter().yearFraction(
                                                 volatility_->referenceDate(),
                                                 exerciseDate);
        Real embeddedOptionValue =
            blackFormula(type,
                         cashStrike,
                         fwdCashPrice,
                         priceVol*std::sqrt(exerciseTime));

        if (type == Option::Call) {
            results_.value = npv - embeddedOptionValue;
            results_.settlementValue = value - embeddedOptionValue;
        } else {
            results_.value = npv + embeddedOptionValue;
            results_.settlementValue = value + embeddedOptionValue;
        }
    }

}
]]></document_content>
  </document>
  <document index="62">
    <source>callablebonds/blackcallablebondengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackcallablebondengine.hpp
    \brief Black-formula callable bond engines
*/

#ifndef quantlib_black_callable_bond_engine_hpp
#define quantlib_black_callable_bond_engine_hpp

#include <ql/experimental/callablebonds/callablebond.hpp>
#include <ql/experimental/callablebonds/callablebondvolstructure.hpp>

namespace QuantLib {

    //! Black-formula callable fixed rate bond engine
    /*! Callable fixed rate bond Black engine. The embedded (European)
        option follows the Black "European bond option" treatment in
        Hull, Fourth Edition, Chapter 20.

        \todo set additionalResults (e.g. vega, fairStrike, etc.)

        \warning This class has yet to be tested

        \ingroup callablebondengines
    */
    class BlackCallableFixedRateBondEngine
        : public CallableFixedRateBond::engine {
      public:
        //! volatility is the quoted fwd yield volatility, not price vol
        BlackCallableFixedRateBondEngine(const Handle<Quote>& fwdYieldVol,
                                         Handle<YieldTermStructure> discountCurve);
        //! volatility is the quoted fwd yield volatility, not price vol
        BlackCallableFixedRateBondEngine(Handle<CallableBondVolatilityStructure> yieldVolStructure,
                                         Handle<YieldTermStructure> discountCurve);
        void calculate() const override;

      private:
        Handle<CallableBondVolatilityStructure> volatility_;
        Handle<YieldTermStructure> discountCurve_;
        // present value of all coupons paid during the life of option
        Real spotIncome() const;
        // converts the yield volatility into a forward price volatility
        Volatility forwardPriceVolatility() const;
    };


    //! Black-formula callable zero coupon bond engine
    /*! Callable zero coupon bond, where the embedded (European)
        option price is assumed to obey the Black formula. Follows
        "European bond option" treatment in Hull, Fourth Edition,
        Chapter 20.

        \warning This class has yet to be tested.

        \ingroup callablebondengines
    */
    class BlackCallableZeroCouponBondEngine :
        public BlackCallableFixedRateBondEngine {
      public:
        //! volatility is the quoted fwd yield volatility, not price vol
        BlackCallableZeroCouponBondEngine(
                              const Handle<Quote>& fwdYieldVol,
                              const Handle<YieldTermStructure>& discountCurve)
        : BlackCallableFixedRateBondEngine(fwdYieldVol, discountCurve) {}

        //! volatility is the quoted fwd yield volatility, not price vol
        BlackCallableZeroCouponBondEngine(
             const Handle<CallableBondVolatilityStructure>& yieldVolStructure,
             const Handle<YieldTermStructure>& discountCurve)
        : BlackCallableFixedRateBondEngine(yieldVolStructure, discountCurve) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="63">
    <source>callablebonds/callablebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo
 Copyright (C) 2017 BN Algorithms Ltd

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/experimental/callablebonds/blackcallablebondengine.hpp>
#include <ql/experimental/callablebonds/callablebond.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/termstructures/yield/zerospreadedtermstructure.hpp>
#include <utility>

namespace QuantLib {

    CallableBond::CallableBond(Natural settlementDays,
                               const Schedule& schedule,
                               DayCounter paymentDayCounter,
                               const Date& issueDate,
                               CallabilitySchedule putCallSchedule)
    : Bond(settlementDays, schedule.calendar(), issueDate),
      paymentDayCounter_(std::move(paymentDayCounter)),
      putCallSchedule_(std::move(putCallSchedule)) {

        maturityDate_ = schedule.dates().back();

        if (!putCallSchedule_.empty()) {
            Date finalOptionDate = Date::minDate();
            for (auto& i : putCallSchedule_) {
                finalOptionDate = std::max(finalOptionDate, i->date());
            }
            QL_REQUIRE(finalOptionDate <= maturityDate_ ,
                       "Bond cannot mature before last call/put date");
        }

        // derived classes must set cashflows_ and frequency_
    }


    void CallableBond::arguments::validate() const {

        QL_REQUIRE(Bond::arguments::settlementDate != Date(),
                   "null settlement date");

        QL_REQUIRE(redemption != Null<Real>(), "null redemption");
        QL_REQUIRE(redemption >= 0.0,
                   "positive redemption required: "
                   << redemption << " not allowed");

        QL_REQUIRE(callabilityDates.size() == callabilityPrices.size(),
                   "different number of callability dates and prices");
        QL_REQUIRE(couponDates.size() == couponAmounts.size(),
                   "different number of coupon dates and amounts");
    }


    CallableBond::ImpliedVolHelper::ImpliedVolHelper(
                              const CallableBond& bond,
                              Real targetValue)
    : targetValue_(targetValue) {

        vol_ = ext::make_shared<SimpleQuote>(0.0);
        bond.blackVolQuote_.linkTo(vol_);

        QL_REQUIRE(bond.blackEngine_,
                   "Must set blackEngine_ to use impliedVolatility");

        engine_ = bond.blackEngine_;
        bond.setupArguments(engine_->getArguments());
        results_ =
            dynamic_cast<const Instrument::results*>(engine_->getResults());
    }


    Real CallableBond::ImpliedVolHelper::operator()(Volatility x) const {
        vol_->setValue(x);
        engine_->calculate(); // get the Black NPV based on vol x
        return results_->value-targetValue_;
    }

    Volatility CallableBond::impliedVolatility(
                              Real targetValue,
                              const Handle<YieldTermStructure>& discountCurve,
                              Real accuracy,
                              Size maxEvaluations,
                              Volatility minVol,
                              Volatility maxVol) const {
        calculate();
        QL_REQUIRE(!isExpired(), "instrument expired");
        Volatility guess = 0.5*(minVol + maxVol);
        blackDiscountCurve_.linkTo(*discountCurve, false);
        ImpliedVolHelper f(*this,targetValue);
        Brent solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }

    namespace {

    template<class T>
    class RestoreVal {
        T orig_;
        T &ref_;
    public:
        explicit RestoreVal(T &ref):
            orig_(ref),
            ref_(ref)  { }
        ~RestoreVal()
        {
            ref_=orig_;
        }
    };

    class OASHelper {
    public:
        OASHelper(const ext::function<Real(Real)>& npvhelper,
                  Real targetValue):
            npvhelper_(npvhelper),
            targetValue_(targetValue)
        {
        }

        Real operator()(Spread x) const
        {
            return targetValue_ - npvhelper_(x);
        }
    private:
        const ext::function<Real(Real)>& npvhelper_;
        Real targetValue_;
    };


    /* Convert a continuous spread to a conventional spread to a
       reference yield curve
    */
    Real continuousToConv(Real oas,
                          const Bond &b,
                          const Handle<YieldTermStructure>& yts,
                          const DayCounter& dayCounter,
                          Compounding compounding,
                          Frequency frequency)
    {
        double zz=yts->zeroRate(b.maturityDate(),
                                dayCounter,
                                Continuous,
                                NoFrequency);
        InterestRate baseRate(zz,
                              dayCounter,
                              Continuous,
                              NoFrequency);
        InterestRate spreadedRate(oas+zz,
                                  dayCounter,
                                  Continuous,
                                  NoFrequency);
        double br=baseRate.equivalentRate(dayCounter,
                                          compounding,
                                          frequency,
                                          yts->referenceDate(),
                                          b.maturityDate()).rate();
        double sr=spreadedRate.equivalentRate(dayCounter,
                                              compounding,
                                              frequency,
                                              yts->referenceDate(),
                                              b.maturityDate()).rate();
        // Return the spread
        return sr-br;
    }

    /* Convert a conventional spread to a reference yield curve to a
       continuous spread
    */
    Real convToContinuous(Real oas,
                          const Bond &b,
                          const Handle<YieldTermStructure>& yts,
                          const DayCounter& dayCounter,
                          Compounding compounding,
                          Frequency frequency)
    {
        double zz=yts->zeroRate(b.maturityDate(),
                                dayCounter,
                                compounding,
                                frequency);
        InterestRate baseRate(zz,
                              dayCounter,
                              compounding,
                              frequency);

        InterestRate spreadedRate(oas+zz,
                                  dayCounter,
                                  compounding,
                                  frequency);
        double br=baseRate.equivalentRate(dayCounter,
                                          Continuous,
                                          NoFrequency,
                                          yts->referenceDate(),
                                          b.maturityDate()).rate();
        double sr=spreadedRate.equivalentRate(dayCounter,
                                              Continuous,
                                              NoFrequency,
                                              yts->referenceDate(),
                                              b.maturityDate()).rate();
        // Return the spread
        return sr-br;
    }

    }


    CallableBond::NPVSpreadHelper::NPVSpreadHelper(CallableBond& bond):
        bond_(bond),
        results_(dynamic_cast<const Instrument::results*>(bond.engine_->getResults()))
    {
        bond.setupArguments(bond.engine_->getArguments());
    }

   Real CallableBond::NPVSpreadHelper::operator()(Real x) const
   {
       auto* args = dynamic_cast<CallableBond::arguments*>(bond_.engine_->getArguments());
       // Pops the original value when function finishes
       RestoreVal<Spread> restorer(args->spread);
       args->spread=x;
       bond_.engine_->calculate();
       return results_->value;
   }

    Spread CallableBond::OAS(Real cleanPrice,
                             const Handle<YieldTermStructure>& engineTS,
                             const DayCounter& dayCounter,
                             Compounding compounding,
                             Frequency frequency,
                             Date settlement,
                             Real accuracy,
                             Size maxIterations,
                             Spread guess)
    {
        if (settlement == Date())
            settlement = settlementDate();

        Real dirtyPrice = cleanPrice + accruedAmount(settlement);

        ext::function<Real(Real)> f = NPVSpreadHelper(*this);
        OASHelper obj(f, dirtyPrice);

        Brent solver;
        solver.setMaxEvaluations(maxIterations);

        Real step = 0.001;
        Spread oas=solver.solve(obj, accuracy, guess, step);

        return continuousToConv(oas,
                                *this,
                                engineTS,
                                dayCounter,
                                compounding,
                                frequency);
    }



    Real CallableBond::cleanPriceOAS(Real oas,
                                     const Handle<YieldTermStructure>& engineTS,
                                     const DayCounter& dayCounter,
                                     Compounding compounding,
                                     Frequency frequency,
                                     Date settlement)
    {
        if (settlement == Date())
            settlement = settlementDate();

        oas=convToContinuous(oas,
                             *this,
                             engineTS,
                             dayCounter,
                             compounding,
                             frequency);

        ext::function<Real(Real)> f = NPVSpreadHelper(*this);

        Real P = f(oas) - accruedAmount(settlement);

        return P;
    }

    Real CallableBond::effectiveDuration(Real oas,
                                         const Handle<YieldTermStructure>& engineTS,
                                         const DayCounter& dayCounter,
                                         Compounding compounding,
                                         Frequency frequency,
                                         Real bump)
    {
        Real P = cleanPriceOAS(oas,
                               engineTS,
                               dayCounter,
                               compounding,
                               frequency);

        Real Ppp = cleanPriceOAS(oas+bump,
                                 engineTS,
                                 dayCounter,
                                 compounding,
                                 frequency);
        Real Pmm = cleanPriceOAS(oas-bump,
                                 engineTS,
                                 dayCounter,
                                 compounding,
                                 frequency);
            
        if ( P == 0.0 )
            return 0;
        else
            {
                return (Pmm-Ppp)/(2*P*bump);
            }
    }

    Real CallableBond::effectiveConvexity(Real oas,
                                          const Handle<YieldTermStructure>& engineTS,
                                          const DayCounter& dayCounter,
                                          Compounding compounding,
                                          Frequency frequency,
                                          Real bump)
    {
        Real P = cleanPriceOAS(oas,
                               engineTS,
                               dayCounter,
                               compounding,
                               frequency);

        Real Ppp = cleanPriceOAS(oas+bump,
                                 engineTS,
                                 dayCounter,
                                 compounding,
                                 frequency);
        Real Pmm = cleanPriceOAS(oas-bump,
                                 engineTS,
                                 dayCounter,
                                 compounding,
                                 frequency);
            
        if ( P == 0.0 )
            return 0;
        else
            {
                return (Ppp + Pmm - 2*P) / ( std::pow(bump,2) * P);
            }        

    }


    CallableFixedRateBond::CallableFixedRateBond(
                              Natural settlementDays,
                              Real faceAmount,
                              const Schedule& schedule,
                              const std::vector<Rate>& coupons,
                              const DayCounter& accrualDayCounter,
                              BusinessDayConvention paymentConvention,
                              Real redemption,
                              const Date& issueDate,
                              const CallabilitySchedule& putCallSchedule,
                              const Period& exCouponPeriod,
                              const Calendar& exCouponCalendar,
                              BusinessDayConvention exCouponConvention,
                              bool exCouponEndOfMonth)
    : CallableBond(settlementDays, schedule, accrualDayCounter,
                   issueDate, putCallSchedule) {

        frequency_ = schedule.tenor().frequency();

        bool isZeroCouponBond = (coupons.size() == 1 && close(coupons[0], 0.0));

        if (!isZeroCouponBond) {
            cashflows_ =
                FixedRateLeg(schedule)
                .withNotionals(faceAmount)
                .withCouponRates(coupons, accrualDayCounter)
                .withPaymentAdjustment(paymentConvention)
                .withExCouponPeriod(exCouponPeriod,
                                    exCouponCalendar,
                                    exCouponConvention,
                                    exCouponEndOfMonth);

            addRedemptionsToCashflows(std::vector<Real>(1, redemption));
        } else {
            Date redemptionDate = calendar_.adjust(maturityDate_,
                                                   paymentConvention);
            setSingleRedemption(faceAmount, redemption, redemptionDate);
        }

        // used for impliedVolatility() calculation
        ext::shared_ptr<SimpleQuote> dummyVolQuote(new SimpleQuote(0.));
        blackVolQuote_.linkTo(dummyVolQuote);
        blackEngine_ = ext::shared_ptr<PricingEngine>(
                   new BlackCallableFixedRateBondEngine(blackVolQuote_,
                                                        blackDiscountCurve_));
    }


    Real CallableFixedRateBond::accrued(Date settlement) const {

        if (settlement == Date()) settlement = settlementDate();

        const bool IncludeToday = false;
        for (const auto& cashflow : cashflows_) {
            // the first coupon paying after d is the one we're after
            if (!cashflow->hasOccurred(settlement, IncludeToday)) {
                ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(cashflow);
                if (coupon != nullptr)
                    // !!!
                    return coupon->accruedAmount(settlement) /
                           notional(settlement) * 100.0;
                else
                    return 0.0;
            }
        }
        return 0.0;
    }


    void CallableFixedRateBond::setupArguments(
                                       PricingEngine::arguments* args) const {

        CallableBond::setupArguments(args);

        auto* arguments = dynamic_cast<CallableBond::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "no arguments given");

        Date settlement = arguments->settlementDate;

        arguments->redemption = redemption()->amount();
        arguments->redemptionDate = redemption()->date();

        const Leg& cfs = cashflows();

        arguments->couponDates.clear();
        arguments->couponDates.reserve(cfs.size()-1);
        arguments->couponAmounts.clear();
        arguments->couponAmounts.reserve(cfs.size()-1);

        for (Size i=0; i<cfs.size()-1; i++) {
            if (!cfs[i]->hasOccurred(settlement, false)
                && !cfs[i]->tradingExCoupon(settlement)) {
                arguments->couponDates.push_back(cfs[i]->date());
                arguments->couponAmounts.push_back(cfs[i]->amount());
            }
        }

        arguments->callabilityPrices.clear();
        arguments->callabilityDates.clear();
        arguments->callabilityPrices.reserve(putCallSchedule_.size());
        arguments->callabilityDates.reserve(putCallSchedule_.size());

        arguments->paymentDayCounter = paymentDayCounter_;
        arguments->frequency = frequency_;

        arguments->putCallSchedule = putCallSchedule_;
        for (const auto& i : putCallSchedule_) {
            if (!i->hasOccurred(settlement, false)) {
                arguments->callabilityDates.push_back(i->date());
                arguments->callabilityPrices.push_back(i->price().amount());

                if (i->price().type() == Bond::Price::Clean) {
                    /* calling accrued() forces accrued interest to be zero
                       if future option date is also coupon date, so that dirty
                       price = clean price. Use here because callability is
                       always applied before coupon in the tree engine.
                    */
                    arguments->callabilityPrices.back() += this->accrued(i->date());
                }
            }
        }

        arguments->spread = 0.0;
    }


    CallableZeroCouponBond::CallableZeroCouponBond(
                              Natural settlementDays,
                              Real faceAmount,
                              const Calendar& calendar,
                              const Date& maturityDate,
                              const DayCounter& dayCounter,
                              BusinessDayConvention paymentConvention,
                              Real redemption,
                              const Date& issueDate,
                              const CallabilitySchedule& putCallSchedule)
    : CallableFixedRateBond(settlementDays,faceAmount,
                            Schedule(issueDate, maturityDate,
                                     Period(Once),
                                     calendar,
                                     paymentConvention,
                                     paymentConvention,
                                     DateGeneration::Backward,
                                     false),
                            std::vector<Rate>(1, 0.0), dayCounter,
                            paymentConvention, redemption,
                            issueDate, putCallSchedule) {}

}

]]></document_content>
  </document>
  <document index="64">
    <source>callablebonds/callablebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo
 Copyright (C) 2017 BN Algorithms Ltd

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file callablebond.hpp
    \brief callable bond classes
*/

#ifndef quantlib_callable_bond_hpp
#define quantlib_callable_bond_hpp

#include <ql/instruments/bond.hpp>
#include <ql/pricingengine.hpp>
#include <ql/instruments/callabilityschedule.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/handle.hpp>
#include <ql/quotes/simplequote.hpp>

namespace QuantLib {

    class Schedule;
    class DayCounter;

    //! Callable bond base class
    /*! Base callable bond class for fixed and zero coupon bonds.
        Defines commonalities between fixed and zero coupon callable
        bonds. At present, only European and Bermudan put/call schedules
        supported (no American optionality), as defined by the Callability
        class.

        \todo models/shortrate/calibrationHelpers
        \todo OAS/OAD
        \todo floating rate callable bonds ?

        \ingroup instruments
    */
    class CallableBond : public Bond {
      public:
        class arguments;
        class results;
        class engine;
        //! \name Inspectors
        //@{
        //! return the bond's put/call schedule
        const CallabilitySchedule& callability() const {
            return putCallSchedule_;
        }
        //@}
        //! \name Calculations
        //@{
        //! returns the Black implied forward yield volatility
        /*! the forward yield volatility, see Hull, Fourth Edition,
            Chapter 20, pg 536). Relevant only to European put/call
            schedules
        */
        Volatility impliedVolatility(
                              Real targetValue,
                              const Handle<YieldTermStructure>& discountCurve,
                              Real accuracy,
                              Size maxEvaluations,
                              Volatility minVol,
                              Volatility maxVol) const;

        //! Calculate the Option Adjusted Spread (OAS)
        /*! Calculates the spread that needs to be added to the the
            reference curve so that the theoretical model value
            matches the marketPrice.

         */
        Spread OAS(Real cleanPrice,
                   const Handle<YieldTermStructure>& engineTS,
                   const DayCounter& dayCounter,
                   Compounding compounding,
                   Frequency frequency,
                   Date settlementDate = Date(),
                   Real accuracy = 1.0e-10,
                   Size maxIterations = 100,
                   Rate guess = 0.0);

        //! Calculate the clean price based on the given
        //! option-adjust-spread (oas) over the given yield term
        //! structure (engineTS)
        Real cleanPriceOAS(Real oas,
                           const Handle<YieldTermStructure>& engineTS,
                           const DayCounter& dayCounter,
                           Compounding compounding,
                           Frequency frequency,
                           Date settlementDate = Date());

        //! Calculate the effective duration, i.e., the first
        //! differential of the dirty price w.r.t. a parallel shift of
        //! the yield term structure divided by current dirty price
        Real effectiveDuration(Real oas,
                               const Handle<YieldTermStructure>& engineTS,
                               const DayCounter& dayCounter,
                               Compounding compounding,
                               Frequency frequency,
                               Real bump=2e-4);

        //! Calculate the effective convexity, i.e., the second
        //! differential of the dirty price w.r.t. a parallel shift of
        //! the yield term structure divided by current dirty price
        Real effectiveConvexity(Real oas,
                                const Handle<YieldTermStructure>& engineTS,
                                const DayCounter& dayCounter,
                                Compounding compounding,
                                Frequency frequency,
                                Real bump=2e-4);
        //@}

      protected:
        CallableBond(Natural settlementDays,
                     const Schedule& schedule,
                     DayCounter paymentDayCounter,
                     const Date& issueDate = Date(),
                     CallabilitySchedule putCallSchedule = CallabilitySchedule());

        DayCounter paymentDayCounter_;
        Frequency frequency_;
        CallabilitySchedule putCallSchedule_;
        //! must be set by derived classes for impliedVolatility() to work
        mutable ext::shared_ptr<PricingEngine> blackEngine_;
        //! Black fwd yield volatility quote handle to internal blackEngine_
        mutable RelinkableHandle<Quote> blackVolQuote_;
        //! Black fwd yield volatility quote handle to internal blackEngine_
        mutable RelinkableHandle<YieldTermStructure> blackDiscountCurve_;
        //! helper class for Black implied volatility calculation
        class ImpliedVolHelper;
        friend class ImpliedVolHelper;
        class ImpliedVolHelper {
          public:
            ImpliedVolHelper(const CallableBond& bond,
                             Real targetValue);
            Real operator()(Volatility x) const;
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };
        //! Helper class for option adjusted spread calculations
        class NPVSpreadHelper;
        friend class NPVSpreadHelper;
        class NPVSpreadHelper {
        public:
            explicit NPVSpreadHelper(CallableBond& bond);
            Real operator()(Spread x) const;
        private:
            CallableBond& bond_;
            const Instrument::results* results_;
        };
    };

    class CallableBond::arguments : public Bond::arguments {
      public:
        arguments() = default;
        std::vector<Date> couponDates;
        std::vector<Real> couponAmounts;
        //! redemption = face amount * redemption / 100.
        Real redemption;
        Date redemptionDate;
        DayCounter paymentDayCounter;
        Frequency frequency;
        CallabilitySchedule putCallSchedule;
        //! bond full/dirty/cash prices
        std::vector<Real> callabilityPrices;
        std::vector<Date> callabilityDates;
        //! Spread to apply to the valuation. This is a continuously
        //! componded rate added to the model. Currently only applied
        //! by the TreeCallableFixedRateBondEngine
        Real spread;
        void validate() const override;
    };

    //! results for a callable bond calculation
    class CallableBond::results : public Bond::results {
      public:
        // no extra results set yet
    };

    //! base class for callable fixed rate bond engine
    class CallableBond::engine
        : public GenericEngine<CallableBond::arguments,
                               CallableBond::results> {};


    //! callable/puttable fixed rate bond
    /*! Callable fixed rate bond class.

        \ingroup instruments
    */
    class CallableFixedRateBond : public CallableBond {
      public:
        CallableFixedRateBond(Natural settlementDays,
                              Real faceAmount,
                              const Schedule& schedule,
                              const std::vector<Rate>& coupons,
                              const DayCounter& accrualDayCounter,
                              BusinessDayConvention paymentConvention
                                                                  = Following,
                              Real redemption = 100.0,
                              const Date& issueDate = Date(),
                              const CallabilitySchedule& putCallSchedule
                                                      = CallabilitySchedule(),
                              const Period& exCouponPeriod = Period(),
                              const Calendar& exCouponCalendar = Calendar(),
                              BusinessDayConvention exCouponConvention = Unadjusted,
                              bool exCouponEndOfMonth = false);

        void setupArguments(PricingEngine::arguments* args) const override;

      private:
        //! accrued interest used internally, where includeToday = false
        /*! same as Bond::accruedAmount() but with enable early
            payments true.  Forces accrued to be calculated in a
            consistent way for future put/ call dates, which can be
            problematic in lattice engines when option dates are also
            coupon dates.
        */
        Real accrued(Date settlement) const;
    };

    //! callable/puttable zero coupon bond
    /*! Callable zero coupon bond class.

        \ingroup instruments
    */
    class CallableZeroCouponBond : public CallableFixedRateBond {
      public:
        CallableZeroCouponBond(Natural settlementDays,
                               Real faceAmount,
                               const Calendar& calendar,
                               const Date& maturityDate,
                               const DayCounter& dayCounter,
                               BusinessDayConvention paymentConvention
                                                                  = Following,
                               Real redemption = 100.0,
                               const Date& issueDate = Date(),
                               const CallabilitySchedule& putCallSchedule
                                                     = CallabilitySchedule());
    };

}

#endif
]]></document_content>
  </document>
  <document index="65">
    <source>callablebonds/callablebondconstantvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/callablebonds/callablebondconstantvol.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/flatsmilesection.hpp>
#include <utility>

namespace QuantLib {

    CallableBondConstantVolatility::CallableBondConstantVolatility(const Date& referenceDate,
                                                                   Volatility volatility,
                                                                   DayCounter dayCounter)
    : CallableBondVolatilityStructure(referenceDate),
      volatility_(ext::shared_ptr<Quote>(new SimpleQuote(volatility))),
      dayCounter_(std::move(dayCounter)), maxBondTenor_(100 * Years) {}

    CallableBondConstantVolatility::CallableBondConstantVolatility(const Date& referenceDate,
                                                                   Handle<Quote> volatility,
                                                                   DayCounter dayCounter)
    : CallableBondVolatilityStructure(referenceDate), volatility_(std::move(volatility)),
      dayCounter_(std::move(dayCounter)), maxBondTenor_(100 * Years) {
        registerWith(volatility_);
    }

    CallableBondConstantVolatility::CallableBondConstantVolatility(Natural settlementDays,
                                                                   const Calendar& calendar,
                                                                   Volatility volatility,
                                                                   DayCounter dayCounter)
    : CallableBondVolatilityStructure(settlementDays, calendar),
      volatility_(ext::shared_ptr<Quote>(new SimpleQuote(volatility))),
      dayCounter_(std::move(dayCounter)), maxBondTenor_(100 * Years) {}

    CallableBondConstantVolatility::CallableBondConstantVolatility(Natural settlementDays,
                                                                   const Calendar& calendar,
                                                                   Handle<Quote> volatility,
                                                                   DayCounter dayCounter)
    : CallableBondVolatilityStructure(settlementDays, calendar), volatility_(std::move(volatility)),
      dayCounter_(std::move(dayCounter)), maxBondTenor_(100 * Years) {
        registerWith(volatility_);
    }

    Volatility CallableBondConstantVolatility::volatilityImpl(const Date&,
                                                              const Period&,
                                                              Rate) const {
        return volatility_->value();
    }

    Volatility CallableBondConstantVolatility::volatilityImpl(
                                                     Time, Time, Rate) const {
        return volatility_->value();
    }


    ext::shared_ptr<SmileSection>
    CallableBondConstantVolatility::smileSectionImpl(Time optionTime,
                                                     Time) const {
        Volatility atmVol = volatility_->value();
        return ext::shared_ptr<SmileSection>(
                                    new FlatSmileSection(optionTime,
                                                         atmVol,
                                                         dayCounter_));
    }

}

]]></document_content>
  </document>
  <document index="66">
    <source>callablebonds/callablebondconstantvol.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file callablebondconstantvol.hpp
    \brief Constant callable-bond volatility
*/

#ifndef quantlib_callable_bond_constant_volatility_hpp
#define quantlib_callable_bond_constant_volatility_hpp

#include <ql/experimental/callablebonds/callablebondvolstructure.hpp>
#include <ql/time/period.hpp>

namespace QuantLib {

    class Quote;

    //! Constant callable-bond volatility, no time-strike dependence
    class CallableBondConstantVolatility
        : public CallableBondVolatilityStructure {
      public:
        CallableBondConstantVolatility(const Date& referenceDate,
                                       Volatility volatility,
                                       DayCounter dayCounter);
        CallableBondConstantVolatility(const Date& referenceDate,
                                       Handle<Quote> volatility,
                                       DayCounter dayCounter);
        CallableBondConstantVolatility(Natural settlementDays,
                                       const Calendar&,
                                       Volatility volatility,
                                       DayCounter dayCounter);
        CallableBondConstantVolatility(Natural settlementDays,
                                       const Calendar&,
                                       Handle<Quote> volatility,
                                       DayCounter dayCounter);
        //! \name TermStructure interface
        //@{
        DayCounter dayCounter() const override { return dayCounter_; }
        Date maxDate() const override { return Date::maxDate(); }
        //@}
        //! \name CallableBondConstantVolatility interface
        //@{
        const Period& maxBondTenor() const override;
        Time maxBondLength() const override;
        Real minStrike() const override;
        Real maxStrike() const override;

      protected:
        Volatility volatilityImpl(Time, Time, Rate) const override;
        ext::shared_ptr<SmileSection> smileSectionImpl(Time optionTime,
                                                       Time bondLength) const override;
        Volatility volatilityImpl(const Date&, const Period&, Rate) const override;
        //@}
      private:
        Handle<Quote> volatility_;
        DayCounter dayCounter_;
        Period maxBondTenor_;
    };


    // inline definitions

    inline const Period& CallableBondConstantVolatility::maxBondTenor() const {
        return maxBondTenor_;
    }

    inline Time CallableBondConstantVolatility::maxBondLength() const {
        return QL_MAX_REAL;
    }

    inline Real CallableBondConstantVolatility::minStrike() const {
        return QL_MIN_REAL;
    }

    inline Real CallableBondConstantVolatility::maxStrike() const {
        return QL_MAX_REAL;
    }

}

#endif

]]></document_content>
  </document>
  <document index="67">
    <source>callablebonds/callablebondvolstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/callablebonds/callablebondvolstructure.hpp>
#include <ql/time/period.hpp>

namespace QuantLib {

    CallableBondVolatilityStructure::CallableBondVolatilityStructure(
                                                    const DayCounter& dc,
                                                    BusinessDayConvention bdc)
    : TermStructure(dc), bdc_(bdc) {}

    CallableBondVolatilityStructure::CallableBondVolatilityStructure(
                                                    const Date& referenceDate,
                                                    const Calendar& calendar,
                                                    const DayCounter& dc,
                                                    BusinessDayConvention bdc)
    : TermStructure(referenceDate, calendar, dc), bdc_(bdc) {}

    CallableBondVolatilityStructure::CallableBondVolatilityStructure(
                                                    Natural settlementDays,
                                                    const Calendar& calendar,
                                                    const DayCounter& dc,
                                                    BusinessDayConvention bdc)
    : TermStructure(settlementDays, calendar, dc), bdc_(bdc) {}

    Time CallableBondVolatilityStructure::maxBondLength() const {
        return timeFromReference(referenceDate()+maxBondTenor());
    }

    std::pair<Time,Time>
    CallableBondVolatilityStructure::convertDates(
                                              const Date& optionDate,
                                              const Period& bondTenor) const {
        Date end = optionDate + bondTenor;
        QL_REQUIRE(end>optionDate,
                   "negative bond tenor (" << bondTenor << ") given");
        Time optionTime = timeFromReference(optionDate);
        Time timeLength = dayCounter().yearFraction(optionDate, end);
        return std::make_pair(optionTime, timeLength);
    }

    void CallableBondVolatilityStructure::checkRange(const Date& optionDate,
                                                     const Period& bondTenor,
                                                     Rate k,
                                                     bool extrapolate) const {
        TermStructure::checkRange(timeFromReference(optionDate),
                                  extrapolate);
        QL_REQUIRE(bondTenor.length() > 0,
                   "negative bond tenor (" << bondTenor << ") given");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   bondTenor <= maxBondTenor(),
                   "bond tenor (" << bondTenor << ") is past max tenor ("
                   << maxBondTenor() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (k >= minStrike() && k <= maxStrike()),
                   "strike (" << k << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "]");
    }

}

]]></document_content>
  </document>
  <document index="68">
    <source>callablebonds/callablebondvolstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file callablebondvolstructure.hpp
    \brief Callable-bond volatility structure
*/

#ifndef quantlib_callable_bond_volatility_structure_hpp
#define quantlib_callable_bond_volatility_structure_hpp

#include <ql/termstructure.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>

namespace QuantLib {

    //! Callable-bond volatility structure
    /*! This class is purely abstract and defines the interface of
        concrete callable-bond volatility structures which will be
        derived from this one.
    */
    class CallableBondVolatilityStructure : public TermStructure {
      public:
        /*! \name Constructors
            See the TermStructure documentation for issues regarding
            constructors.
        */
        //@{
        //! default constructor
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        CallableBondVolatilityStructure(const DayCounter& dc = DayCounter(),
                                        BusinessDayConvention bdc = Following);
        //! initialize with a fixed reference date
        CallableBondVolatilityStructure(const Date& referenceDate,
                                        const Calendar& calendar = Calendar(),
                                        const DayCounter& dc = DayCounter(),
                                        BusinessDayConvention bdc = Following);
        //! calculate the reference date based on the global evaluation date
        CallableBondVolatilityStructure(Natural settlementDays,
                                        const Calendar&,
                                        const DayCounter& dc = DayCounter(),
                                        BusinessDayConvention bdc = Following);
        //@}
        ~CallableBondVolatilityStructure() override = default;
        //! \name Volatility, variance and smile
        //@{
        //! returns the volatility for a given option time and bondLength
        Volatility volatility(Time optionTime,
                              Time bondLength,
                              Rate strike,
                              bool extrapolate = false) const;
        //! returns the Black variance for a given option time and bondLength
        Real blackVariance(Time optionTime,
                           Time bondLength,
                           Rate strike,
                           bool extrapolate = false) const;

        //! returns the volatility for a given option date and bond tenor
        Volatility volatility(const Date& optionDate,
                              const Period& bondTenor,
                              Rate strike,
                              bool extrapolate = false) const;
        //! returns the Black variance for a given option date and bond tenor
        Real blackVariance(const Date& optionDate,
                           const Period& bondTenor,
                           Rate strike,
                           bool extrapolate = false) const;
        virtual ext::shared_ptr<SmileSection> smileSection(
                                              const Date& optionDate,
                                              const Period& bondTenor) const {
            const std::pair<Time, Time> p = convertDates(optionDate, bondTenor);
            return smileSectionImpl(p.first, p.second);
        }

        //! returns the volatility for a given option tenor and bond tenor
        Volatility volatility(const Period& optionTenor,
                              const Period& bondTenor,
                              Rate strike,
                              bool extrapolate = false) const;
        //! returns the Black variance for a given option tenor and bond tenor
        Real blackVariance(const Period& optionTenor,
                           const Period& bondTenor,
                           Rate strike,
                           bool extrapolate = false) const;
        ext::shared_ptr<SmileSection> smileSection(
                                               const Period& optionTenor,
                                               const Period& bondTenor) const;
        //@}
        //! \name Limits
        //@{
        //! the largest length for which the term structure can return vols
        virtual const Period& maxBondTenor() const = 0;
        //! the largest bondLength for which the term structure can return vols
        virtual Time maxBondLength() const;
        //! the minimum strike for which the term structure can return vols
        virtual Rate minStrike() const = 0;
        //! the maximum strike for which the term structure can return vols
        virtual Rate maxStrike() const = 0;
        //@}
        //! implements the conversion between dates and times
        virtual std::pair<Time,Time> convertDates(
                                               const Date& optionDate,
                                               const Period& bondTenor) const;
        //! the business day convention used for option date calculation
        virtual BusinessDayConvention businessDayConvention() const;
        //! implements the conversion between optionTenors and optionDates
        Date optionDateFromTenor(const Period& optionTenor) const;
    protected:

        //! return smile section
        virtual ext::shared_ptr<SmileSection> smileSectionImpl(
                                                   Time optionTime,
                                                   Time bondLength) const = 0;

        //! implements the actual volatility calculation in derived classes
        virtual Volatility volatilityImpl(Time optionTime,
                                          Time bondLength,
                                          Rate strike) const = 0;
        virtual Volatility volatilityImpl(const Date& optionDate,
                                          const Period& bondTenor,
                                          Rate strike) const {
            const std::pair<Time, Time> p = convertDates(optionDate, bondTenor);
            return volatilityImpl(p.first, p.second, strike);
        }
        void checkRange(Time, Time, Rate strike, bool extrapolate) const;
        void checkRange(const Date& optionDate,
                        const Period& bondTenor,
                        Rate strike, bool extrapolate) const;
      private:
        BusinessDayConvention bdc_;
    };


    // inline definitions

    inline BusinessDayConvention
    CallableBondVolatilityStructure::businessDayConvention() const {
        return bdc_;
    }

    inline Date CallableBondVolatilityStructure::optionDateFromTenor(
                                            const Period& optionTenor) const {
        return calendar().advance(referenceDate(),
                                  optionTenor,
                                  businessDayConvention());
    }

    inline Volatility CallableBondVolatilityStructure::volatility(
                                                     Time optionTime,
                                                     Time bondLength,
                                                     Rate strike,
                                                     bool extrapolate) const {
        checkRange(optionTime, bondLength, strike, extrapolate);
        return volatilityImpl(optionTime, bondLength, strike);
    }


    inline Real CallableBondVolatilityStructure::blackVariance(
                                                     Time optionTime,
                                                     Time bondLength,
                                                     Rate strike,
                                                     bool extrapolate) const {
        checkRange(optionTime, bondLength, strike, extrapolate);
        Volatility vol = volatilityImpl(optionTime, bondLength, strike);
        return vol*vol*optionTime;
    }


    inline Volatility CallableBondVolatilityStructure::volatility(
                                                     const Date& optionDate,
                                                     const Period& bondTenor,
                                                     Rate strike,
                                                     bool extrapolate) const {
        checkRange(optionDate, bondTenor, strike, extrapolate);
        return volatilityImpl(optionDate, bondTenor, strike);
    }

    inline Real CallableBondVolatilityStructure::blackVariance(
                                                     const Date& optionDate,
                                                     const Period& bondTenor,
                                                     Rate strike,
                                                     bool extrapolate) const {
        Volatility vol =
            volatility(optionDate, bondTenor, strike, extrapolate);
        const std::pair<Time, Time> p = convertDates(optionDate, bondTenor);
        return vol*vol*p.first;
    }

    inline Volatility CallableBondVolatilityStructure::volatility(
                                                    const Period& optionTenor,
                                                    const Period& bondTenor,
                                                    Rate strike,
                                                    bool extrapolate) const {
        Date optionDate = optionDateFromTenor(optionTenor);
        return volatility(optionDate, bondTenor, strike, extrapolate);
    }

    inline Real CallableBondVolatilityStructure::blackVariance(
                                                    const Period& optionTenor,
                                                    const Period& bondTenor,
                                                    Rate strike,
                                                    bool extrapolate) const {
        Date optionDate = optionDateFromTenor(optionTenor);
        Volatility vol =
            volatility(optionDate, bondTenor, strike, extrapolate);
        const std::pair<Time, Time> p = convertDates(optionDate, bondTenor);
        return vol*vol*p.first;
    }


    inline ext::shared_ptr<SmileSection>
    CallableBondVolatilityStructure::smileSection(
                                              const Period& optionTenor,
                                              const Period& bondTenor) const {
        Date optionDate = optionDateFromTenor(optionTenor);
        return smileSection(optionDate, bondTenor);
    }


    inline void CallableBondVolatilityStructure::checkRange(
        Time optionTime, Time bondLength, Rate k, bool extrapolate) const {
        TermStructure::checkRange(optionTime, extrapolate);
        QL_REQUIRE(bondLength >= 0.0,
                   "negative bondLength (" << bondLength << ") given");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   bondLength <= maxBondLength(),
                   "bondLength (" << bondLength << ") is past max curve bondLength ("
                   << maxBondLength() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (k >= minStrike() && k <= maxStrike()),
                   "strike (" << k << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "]");
    }

}

#endif
]]></document_content>
  </document>
  <document index="69">
    <source>callablebonds/discretizedcallablefixedratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/callablebonds/discretizedcallablefixedratebond.hpp>

namespace QuantLib {

    namespace {

        bool withinNextWeek(Time t1, Time t2) {
            static const Time dt = 1.0/52;
            return t1 <= t2 && t2 <= t1+dt;
        }

    }


    DiscretizedCallableFixedRateBond::DiscretizedCallableFixedRateBond(
                                          const CallableBond::arguments& args,
                                          const Date& referenceDate,
                                          const DayCounter& dayCounter)
    : arguments_(args) {

        redemptionTime_ = dayCounter.yearFraction(referenceDate,
                                                  args.redemptionDate);

        couponTimes_.resize(args.couponDates.size());
        for (Size i=0; i<couponTimes_.size(); ++i)
            couponTimes_[i] =
                dayCounter.yearFraction(referenceDate,
                                        args.couponDates[i]);

        callabilityTimes_.resize(args.callabilityDates.size());
        for (Size i=0; i<callabilityTimes_.size(); ++i)
            callabilityTimes_[i] =
                dayCounter.yearFraction(referenceDate,
                                        args.callabilityDates[i]);

        // To avoid mispricing, we snap exercise dates to the closest coupon date.
        for (double& exerciseTime : callabilityTimes_) {
            for (double couponTime : couponTimes_) {
                if (withinNextWeek(exerciseTime, couponTime)) {
                    exerciseTime = couponTime;
                    break;
                }
            }
        }
    }


    void DiscretizedCallableFixedRateBond::reset(Size size) {
        values_ = Array(size, arguments_.redemption);
        adjustValues();
    }


    std::vector<Time> DiscretizedCallableFixedRateBond::mandatoryTimes() const {
        std::vector<Time> times;
        Time t;
        Size i;

        t = redemptionTime_;
        if (t >= 0.0) {
            times.push_back(t);
        }

        for (i=0; i<couponTimes_.size(); i++) {
            t = couponTimes_[i];
            if (t >= 0.0) {
                times.push_back(t);
            }
        }

        for (i=0; i<callabilityTimes_.size(); i++) {
            t = callabilityTimes_[i];
            if (t >= 0.0) {
                times.push_back(t);
            }
        }

        return times;
    }


    void DiscretizedCallableFixedRateBond::preAdjustValuesImpl() { }


    void DiscretizedCallableFixedRateBond::postAdjustValuesImpl() {
        for (Size i=0; i<callabilityTimes_.size(); i++) {
            Time t = callabilityTimes_[i];
            if (t >= 0.0 && isOnTime(t)) {
                applyCallability(i);
            }
        }
        for (Size i=0; i<couponTimes_.size(); i++) {
            Time t = couponTimes_[i];
            if (t >= 0.0 && isOnTime(t)) {
                addCoupon(i);
            }
        }
    }


    void DiscretizedCallableFixedRateBond::applyCallability(Size i) {
        Size j;
        switch (arguments_.putCallSchedule[i]->type() ) {
          case Callability::Call:
            for (j=0; j<values_.size(); j++) {
                values_[j] =
                    std::min(arguments_.callabilityPrices[i],
                             values_[j]);
            }
            break;
          case Callability::Put:
            for (j=0; j<values_.size(); j++) {
                values_[j] = std::max(values_[j],
                                      arguments_.callabilityPrices[i]);
            }
            break;
          default:
            QL_FAIL("unknown callability type");
        }
    }


    void DiscretizedCallableFixedRateBond::addCoupon(Size i) {
        values_ += arguments_.couponAmounts[i];
    }

}
]]></document_content>
  </document>
  <document index="70">
    <source>callablebonds/discretizedcallablefixedratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedcallablefixedratebond.hpp
    \brief Discretized callable fixed-rate bond class
*/

#ifndef quantlib_discretized_callable_fixed_rate_bond_hpp
#define quantlib_discretized_callable_fixed_rate_bond_hpp

#include <ql/experimental/callablebonds/callablebond.hpp>
#include <ql/discretizedasset.hpp>

namespace QuantLib {

    class DiscretizedCallableFixedRateBond : public DiscretizedAsset {
      public:
        DiscretizedCallableFixedRateBond(const CallableBond::arguments&,
                                         const Date& referenceDate,
                                         const DayCounter& dayCounter);
        void reset(Size size) override;
        std::vector<Time> mandatoryTimes() const override;

      protected:
        void preAdjustValuesImpl() override;
        void postAdjustValuesImpl() override;

      private:
        CallableBond::arguments arguments_;
        Time redemptionTime_;
        std::vector<Time> couponTimes_;
        std::vector<Time> callabilityTimes_;
        void applyCallability(Size i);
        void addCoupon(Size i);
    };

}

#endif

]]></document_content>
  </document>
  <document index="71">
    <source>callablebonds/treecallablebondengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/callablebonds/discretizedcallablefixedratebond.hpp>
#include <ql/experimental/callablebonds/treecallablebondengine.hpp>
#include <ql/models/shortrate/onefactormodel.hpp>
#include <utility>

namespace QuantLib {

    TreeCallableFixedRateBondEngine::TreeCallableFixedRateBondEngine(
        const ext::shared_ptr<ShortRateModel>& model,
        const Size timeSteps,
        Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<CallableBond::arguments, CallableBond::results>(model, timeSteps),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    TreeCallableFixedRateBondEngine::TreeCallableFixedRateBondEngine(
        const ext::shared_ptr<ShortRateModel>& model,
        const TimeGrid& timeGrid,
        Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<CallableBond::arguments, CallableBond::results>(model, timeGrid),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    void TreeCallableFixedRateBondEngine::calculate() const {
        return calculateWithSpread(arguments_.spread);
    }

    void TreeCallableFixedRateBondEngine::calculateWithSpread(Spread s) const {
        QL_REQUIRE(!model_.empty(), "no model specified");

        ext::shared_ptr<TermStructureConsistentModel> tsmodel =
            ext::dynamic_pointer_cast<TermStructureConsistentModel>(*model_);
        Handle<YieldTermStructure> discountCurve =
            tsmodel != nullptr ? tsmodel->termStructure() : termStructure_;

        Date referenceDate = discountCurve->referenceDate();
        DayCounter dayCounter = discountCurve->dayCounter();

        DiscretizedCallableFixedRateBond callableBond(arguments_,
                                                      referenceDate,
                                                      dayCounter);
        ext::shared_ptr<Lattice> lattice;

        if (lattice_ != nullptr) {
            lattice = lattice_;
        } else {
            std::vector<Time> times = callableBond.mandatoryTimes();
            TimeGrid timeGrid(times.begin(), times.end(), timeSteps_);
            lattice = model_->tree(timeGrid);
        }

        if (s != 0.0) {
            auto* sr = dynamic_cast<OneFactorModel::ShortRateTree*>(&(*lattice));
            QL_REQUIRE(sr,
                       "Spread is not supported for trees other than OneFactorModel");
            sr->setSpread(s);
        }

        Time redemptionTime =
            dayCounter.yearFraction(referenceDate,
                                    arguments_.redemptionDate);
        callableBond.initialize(lattice, redemptionTime);
        callableBond.rollback(0.0);
        results_.value = callableBond.presentValue();

        DiscountFactor d = discountCurve->discount(arguments_.settlementDate);
        results_.settlementValue = results_.value / d;
    }

}

]]></document_content>
  </document>
  <document index="72">
    <source>callablebonds/treecallablebondengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file treecallablebondengine.hpp
    \brief Numerical lattice engines for callable/puttable bonds
*/

#ifndef quantlib_tree_callable_bond_engine_hpp
#define quantlib_tree_callable_bond_engine_hpp

#include <ql/experimental/callablebonds/callablebond.hpp>
#include <ql/pricingengines/latticeshortratemodelengine.hpp>

namespace QuantLib {

    //! Numerical lattice engine for callable fixed rate bonds
    /*! \ingroup callablebondengines */
    class TreeCallableFixedRateBondEngine
        : public LatticeShortRateModelEngine<CallableBond::arguments,
                                             CallableBond::results> {
      public:
        /*! \name Constructors
            \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        //@{
        TreeCallableFixedRateBondEngine(
            const ext::shared_ptr<ShortRateModel>&,
            Size timeSteps,
            Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        TreeCallableFixedRateBondEngine(
            const ext::shared_ptr<ShortRateModel>&,
            const TimeGrid& timeGrid,
            Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        //@}
        void calculate() const override;

      private:
        void calculateWithSpread(Spread s) const;
        Handle<YieldTermStructure> termStructure_;
    };

    //! Numerical lattice engine for callable zero coupon bonds
    /*! \ingroup callablebondengines */
    class TreeCallableZeroCouponBondEngine
        : public TreeCallableFixedRateBondEngine {

      public:
        TreeCallableZeroCouponBondEngine(
                           const ext::shared_ptr<ShortRateModel>& model,
                           const Size timeSteps,
                           const Handle<YieldTermStructure>& termStructure =
                                                 Handle<YieldTermStructure>())
        : TreeCallableFixedRateBondEngine(model, timeSteps, termStructure) {}

        TreeCallableZeroCouponBondEngine(
                               const ext::shared_ptr<ShortRateModel>& model,
                               const TimeGrid& timeGrid,
                           const Handle<YieldTermStructure>& termStructure =
                                                 Handle<YieldTermStructure>())
        : TreeCallableFixedRateBondEngine(model, timeGrid, termStructure) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="73">
    <source>catbonds/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    catbond.hpp \
	catrisk.hpp \
	montecarlocatbondengine.hpp \
	riskynotional.hpp

cpp_files = \
    catbond.cpp \
	catrisk.cpp \
	montecarlocatbondengine.cpp \
	riskynotional.cpp

if UNITY_BUILD

nodist_libCatBonds_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libCatBonds_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libCatBonds.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="74">
    <source>catbonds/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/catbonds/catbond.hpp>
#include <ql/experimental/catbonds/catrisk.hpp>
#include <ql/experimental/catbonds/montecarlocatbondengine.hpp>
#include <ql/experimental/catbonds/riskynotional.hpp>

]]></document_content>
  </document>
  <document index="75">
    <source>catbonds/catbond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/catbonds/catbond.hpp>
#include <ql/settings.hpp>
#include <ql/experimental/credit/loss.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/daycounters/actualactual.hpp>

using namespace std;

namespace QuantLib {

    void CatBond::arguments::validate() const {
        Bond::arguments::validate();
        QL_REQUIRE(notionalRisk, "null notionalRisk");
    }

    void CatBond::setupArguments(PricingEngine::arguments* args) const {

        auto* arguments = dynamic_cast<CatBond::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong arguments type");

        Bond::setupArguments(args);

        arguments->notionalRisk = notionalRisk_;
        arguments->startDate = issueDate();
    }
    
    void CatBond::fetchResults(const PricingEngine::results* r) const {
        Bond::fetchResults(r);

        const auto* results = dynamic_cast<const CatBond::results*>(r);
        QL_ENSURE(results != nullptr, "wrong result type");

        lossProbability_ = results->lossProbability;
        expectedLoss_ = results->expectedLoss;
        exhaustionProbability_ = results->exhaustionProbability;
    }

    FloatingCatBond::FloatingCatBond(Natural settlementDays,
                                     Real faceAmount,
                                     const Schedule& schedule,
                                     const ext::shared_ptr<IborIndex>& iborIndex,
                                     const DayCounter& paymentDayCounter,
                                     const ext::shared_ptr<NotionalRisk>& notionalRisk,
                                     BusinessDayConvention paymentConvention,
                                     Natural fixingDays,
                                     const std::vector<Real>& gearings,
                                     const std::vector<Spread>& spreads,
                                     const std::vector<Rate>& caps,
                                     const std::vector<Rate>& floors,
                                     bool inArrears,
                                     Real redemption,
                                     const Date& issueDate)
    : CatBond(settlementDays, schedule.calendar(), issueDate, notionalRisk) {

        maturityDate_ = schedule.endDate();

        cashflows_ = IborLeg(schedule, iborIndex)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(iborIndex);
    }

    FloatingCatBond::FloatingCatBond(Natural settlementDays,
                                     Real faceAmount,
                                     const Date& startDate,
                                     const Date& maturityDate,
                                     Frequency couponFrequency,
                                     const Calendar& calendar,
                                     const ext::shared_ptr<IborIndex>& iborIndex,
                                     const DayCounter& accrualDayCounter,
                                     const ext::shared_ptr<NotionalRisk>& notionalRisk,
                                     BusinessDayConvention accrualConvention,
                                     BusinessDayConvention paymentConvention,
                                     Natural fixingDays,
                                     const std::vector<Real>& gearings,
                                     const std::vector<Spread>& spreads,
                                     const std::vector<Rate>& caps,
                                     const std::vector<Rate>& floors,
                                     bool inArrears,
                                     Real redemption,
                                     const Date& issueDate,
                                     const Date& stubDate,
                                     DateGeneration::Rule rule,
                                     bool endOfMonth)
    : CatBond(settlementDays, calendar, issueDate, notionalRisk) {

        maturityDate_ = maturityDate;

        Date firstDate, nextToLastDate;
        switch (rule) {
          case DateGeneration::Backward:
            firstDate = Date();
            nextToLastDate = stubDate;
            break;
          case DateGeneration::Forward:
            firstDate = stubDate;
            nextToLastDate = Date();
            break;
          case DateGeneration::Zero:
          case DateGeneration::ThirdWednesday:
          case DateGeneration::Twentieth:
          case DateGeneration::TwentiethIMM:
            QL_FAIL("stub date (" << stubDate << ") not allowed with " <<
                    rule << " DateGeneration::Rule");
          default:
            QL_FAIL("unknown DateGeneration::Rule (" << Integer(rule) << ")");
        }

        Schedule schedule(startDate, maturityDate_, Period(couponFrequency),
                          calendar_, accrualConvention, accrualConvention,
                          rule, endOfMonth,
                          firstDate, nextToLastDate);

        cashflows_ = IborLeg(schedule, iborIndex)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(accrualDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(iborIndex);
    }

}
]]></document_content>
  </document>
  <document index="76">
    <source>catbonds/catbond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file catbond.hpp
    \brief cat bond class
*/

#ifndef quantlib_catbond_hpp
#define quantlib_catbond_hpp

#include <ql/experimental/catbonds/catrisk.hpp>
#include <ql/experimental/catbonds/riskynotional.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    class CatBond : public Bond
    {
    public:
        class arguments;
        class results;
        class engine;

        CatBond(Natural settlementDays,
                const Calendar& calendar,
                const Date& issueDate,
                ext::shared_ptr<NotionalRisk> notionalRisk)
        : Bond(settlementDays, calendar, issueDate), notionalRisk_(std::move(notionalRisk)) {}
        ~CatBond() override = default;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

        Real lossProbability() const { return lossProbability_; }
        Real expectedLoss() const { return expectedLoss_; }
        Real exhaustionProbability() const { return exhaustionProbability_; }

      protected:
        ext::shared_ptr<NotionalRisk> notionalRisk_;

        mutable Real lossProbability_;
        mutable Real exhaustionProbability_;
        mutable Real expectedLoss_;
    };

    class CatBond::arguments : public Bond::arguments {
      public:
        Date startDate;
        ext::shared_ptr<NotionalRisk> notionalRisk;
        void validate() const override;
    };

    //! results for a cat bond calculation
    class CatBond::results : public Bond::results {
      public:
        Real lossProbability;
        Real exhaustionProbability;
        Real expectedLoss;
    };

    //! base class for cat bond engine
    class CatBond::engine
        : public GenericEngine<CatBond::arguments,
                               CatBond::results> {};


    //! floating-rate cat bond (possibly capped and/or floored)
    /*! \ingroup instruments

        \test calculations are tested by checking results against
              cached values.
    */
    class FloatingCatBond : public CatBond {
      public:
        FloatingCatBond(Natural settlementDays,
                        Real faceAmount,
                        const Schedule& schedule,
                        const ext::shared_ptr<IborIndex>& iborIndex,
                        const DayCounter& accrualDayCounter,
                        const ext::shared_ptr<NotionalRisk>& notionalRisk,
                        BusinessDayConvention paymentConvention = Following,
                        Natural fixingDays = Null<Natural>(),
                        const std::vector<Real>& gearings = std::vector<Real>(1, 1.0),
                        const std::vector<Spread>& spreads = std::vector<Spread>(1, 0.0),
                        const std::vector<Rate>& caps = std::vector<Rate>(),
                        const std::vector<Rate>& floors = std::vector<Rate>(),
                        bool inArrears = false,
                        Real redemption = 100.0,
                        const Date& issueDate = Date());

        FloatingCatBond(Natural settlementDays,
                        Real faceAmount,
                        const Date& startDate,
                        const Date& maturityDate,
                        Frequency couponFrequency,
                        const Calendar& calendar,
                        const ext::shared_ptr<IborIndex>& iborIndex,
                        const DayCounter& accrualDayCounter,
                        const ext::shared_ptr<NotionalRisk>& notionalRisk,
                        BusinessDayConvention accrualConvention = Following,
                        BusinessDayConvention paymentConvention = Following,
                        Natural fixingDays = Null<Natural>(),
                        const std::vector<Real>& gearings = std::vector<Real>(1, 1.0),
                        const std::vector<Spread>& spreads = std::vector<Spread>(1, 0.0),
                        const std::vector<Rate>& caps = std::vector<Rate>(),
                        const std::vector<Rate>& floors = std::vector<Rate>(),
                        bool inArrears = false,
                        Real redemption = 100.0,
                        const Date& issueDate = Date(),
                        const Date& stubDate = Date(),
                        DateGeneration::Rule rule = DateGeneration::Backward,
                        bool endOfMonth = false);
    };

}

#endif
]]></document_content>
  </document>
  <document index="77">
    <source>catbonds/catrisk.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/catbonds/catrisk.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        Integer round(Real r) {
            return (r > 0.0) ? Integer(std::floor(r + 0.5)) : Integer(std::ceil(r - 0.5));
        }
    }

    EventSetSimulation::EventSetSimulation(
        ext::shared_ptr<std::vector<std::pair<Date, Real> > > events,
        Date eventsStart,
        Date eventsEnd,
        Date start,
        Date end)
    : CatSimulation(start, end), events_(std::move(events)), eventsStart_(eventsStart),
      eventsEnd_(eventsEnd), i_(0) {
        years_ = end_.year()-start_.year();
        if(eventsStart_.month()<start_.month() 
                            || (eventsStart_.month()==start_.month() 
                                && eventsStart_.dayOfMonth()<=start_.dayOfMonth())) {
            periodStart_ = Date(start_.dayOfMonth(), start_.month(), eventsStart_.year());
        } else {
            periodStart_ = Date(start_.dayOfMonth(), start_.month(), eventsStart_.year()+1);
        }
        periodEnd_ = Date(end_.dayOfMonth(), end_.month(), periodStart_.year()+years_);
        while(i_<events_->size() && (*events_)[i_].first<periodStart_) ++i_; //i points to the first element after the start of the relevant period.
    }

    bool EventSetSimulation::nextPath(std::vector< std::pair< Date, Real > >& path) {
        path.resize(0);
        if(periodEnd_>eventsEnd_) //Ran out of event data 
            return false;

        while(i_<events_->size() && (*events_)[i_].first<periodStart_) {
            ++i_; //skip the elements between the previous period and this period
        }
        while(i_<events_->size()  && (*events_)[i_].first<=periodEnd_){
            std::pair<Date, Real> e(events_->at(i_).first+(start_.year() - periodStart_.year())*Years, events_->at(i_).second);
            path.push_back(e);
            ++i_; //i points to the first element after the start of the relevant period.
        }
        if(start_+years_*Years<end_) {
            periodStart_+=(years_+1)*Years;
            periodEnd_+=(years_+1)*Years;
        } else {
            periodStart_+=years_*Years;
            periodEnd_+=years_*Years;
        }
        return true;
    }

    EventSet::EventSet(ext::shared_ptr<std::vector<std::pair<Date, Real> > > events,
                       Date eventsStart,
                       Date eventsEnd)
    : events_(std::move(events)), eventsStart_(eventsStart), eventsEnd_(eventsEnd) {}

    ext::shared_ptr<CatSimulation> EventSet::newSimulation(const Date& start, const Date& end) const{
        return ext::make_shared<EventSetSimulation>(events_, eventsStart_, eventsEnd_, start, end);
    }

    BetaRiskSimulation::BetaRiskSimulation(Date start, Date end, Real maxLoss, Real lambda, Real alpha, Real beta) 
              : CatSimulation(start, end), 
                maxLoss_(maxLoss), 
                exponential_(rng_, boost::exponential_distribution<>(lambda)),
                gammaAlpha_(rng_, boost::gamma_distribution<>(alpha)),
                gammaBeta_(rng_, boost::gamma_distribution<>(beta))
    {
        DayCounter dayCounter = ActualActual(ActualActual::ISDA);
        dayCount_ = dayCounter.dayCount(start, end);
        yearFraction_ = dayCounter.yearFraction(start, end);
    }

    Real BetaRiskSimulation::generateBeta()
    {
        Real X = gammaAlpha_();
        Real Y = gammaBeta_();
        return X*maxLoss_/(X+Y);
    }

    bool BetaRiskSimulation::nextPath(std::vector<std::pair<Date, Real> > &path)
    {        
        path.resize(0);
        Real eventFraction = exponential_();       
        while(eventFraction<=yearFraction_)
        {
            Integer days = round(eventFraction*dayCount_/yearFraction_);
            Date eventDate = start_ + days*Days;
            if(eventDate<=end_)
            {
                path.emplace_back(eventDate, generateBeta());
            }
            else break;
            eventFraction = exponential_();
        }
        return true;
    }

    BetaRisk::BetaRisk(Real maxLoss, 
                 Real years, 
                 Real mean, 
                 Real stdDev) 
    : maxLoss_(maxLoss), lambda_(1.0/years) {
        QL_REQUIRE(mean<maxLoss, "Mean "<<mean<<"of the loss distribution must be less than the maximum loss "<<maxLoss);
        Real normalizedMean = mean/maxLoss;
        Real normalizedVar = stdDev*stdDev/(maxLoss*maxLoss);
        QL_REQUIRE(normalizedVar<normalizedMean*(1.0-normalizedMean), "Standard deviation of "<<stdDev<<" is impossible to achieve in gamma distribution with mean "<<mean);
        Real nu = normalizedMean*(1.0-normalizedMean)/normalizedVar - 1.0;
        alpha_=normalizedMean*nu;
        beta_=(1.0-normalizedMean)*nu;
    }

    ext::shared_ptr<CatSimulation> BetaRisk::newSimulation(const Date& start, const Date& end) const {
        return ext::make_shared<BetaRiskSimulation>(start, end, maxLoss_, lambda_, alpha_, beta_);
    }
}
]]></document_content>
  </document>
  <document index="78">
    <source>catbonds/catrisk.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file catrisk.hpp
    \brief classes that encapsulate catastrophe risk
*/

#ifndef quantlib_catrisk_hpp
#define quantlib_catrisk_hpp

#include <ql/time/date.hpp>
#include <ql/errors.hpp>
#include <ql/shared_ptr.hpp>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wtautological-overlap-compare"
#endif
#include <boost/random.hpp>
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif
#include <vector>

namespace QuantLib {

    class CatSimulation {
      public:
        CatSimulation(Date start, 
                      Date end) 
        : start_(start), end_(end) 
        {}

        virtual ~CatSimulation() = default;
        virtual bool nextPath(std::vector<std::pair<Date, Real> > &path) = 0;
      protected:
        Date start_;
        Date end_;
    };

    class CatRisk {
      public:
        virtual ~CatRisk() = default;
        virtual ext::shared_ptr<CatSimulation> newSimulation(const Date& start, const Date& end) const = 0;
    };

    class EventSetSimulation : public CatSimulation {
      public:
        EventSetSimulation(ext::shared_ptr<std::vector<std::pair<Date, Real> > > events,
                           Date eventsStart,
                           Date eventsEnd,
                           Date start,
                           Date end);
        bool nextPath(std::vector<std::pair<Date, Real> >& path) override;

      private:
        ext::shared_ptr<std::vector<std::pair<Date, Real> > > events_;
        Date eventsStart_;
        Date eventsEnd_;

        Year years_;
        Date periodStart_;
        Date periodEnd_;
        unsigned int i_;
    };

    class EventSet : public CatRisk {        
      public:
        EventSet(ext::shared_ptr<std::vector<std::pair<Date, Real> > > events,
                 Date eventsStart,
                 Date eventsEnd);

        ext::shared_ptr<CatSimulation> newSimulation(const Date& start,
                                                     const Date& end) const override;

      private:
        ext::shared_ptr<std::vector<std::pair<Date, Real> > > events_; 
        Date eventsStart_;
        Date eventsEnd_;
    };

    class BetaRiskSimulation : public CatSimulation {
      public:
        BetaRiskSimulation(Date start, 
                           Date end, 
                           Real maxLoss, 
                           Real lambda, 
                           Real alpha, 
                           Real beta) ;

        bool nextPath(std::vector<std::pair<Date, Real> >& path) override;
        Real generateBeta();
    
      private:
        Real maxLoss_;
    
        Integer dayCount_;
        Real yearFraction_;
    
        boost::mt19937 rng_;
        boost::variate_generator<boost::mt19937&, boost::exponential_distribution<> > exponential_;
        boost::variate_generator<boost::mt19937&, boost::gamma_distribution<> > gammaAlpha_;
        boost::variate_generator<boost::mt19937&, boost::gamma_distribution<> > gammaBeta_;
    };

    class BetaRisk : public CatRisk {
      public:
        BetaRisk(Real maxLoss, 
                 Real years, 
                 Real mean, 
                 Real stdDev);

        ext::shared_ptr<CatSimulation> newSimulation(const Date& start,
                                                     const Date& end) const override;

      private:
        Real maxLoss_;
        Real lambda_;
        Real alpha_;
        Real beta_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="79">
    <source>catbonds/montecarlocatbondengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/experimental/catbonds/montecarlocatbondengine.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    MonteCarloCatBondEngine::MonteCarloCatBondEngine(
        ext::shared_ptr<CatRisk> catRisk,
        Handle<YieldTermStructure> discountCurve,
        const boost::optional<bool>& includeSettlementDateFlows)
    : catRisk_(std::move(catRisk)), discountCurve_(std::move(discountCurve)),
      includeSettlementDateFlows_(includeSettlementDateFlows) {
        registerWith(discountCurve_);
    }

    void MonteCarloCatBondEngine::calculate() const {
        QL_REQUIRE(!discountCurve_.empty(),
                   "discounting term structure handle is empty");

        results_.valuationDate = (*discountCurve_)->referenceDate();

        bool includeRefDateFlows = includeSettlementDateFlows_ ? // NOLINT(readability-implicit-bool-conversion)
                                       *includeSettlementDateFlows_ :
                                       Settings::instance().includeReferenceDateEvents();

        Real lossProbability;
        Real exhaustionProbability;
        Real expectedLoss;

        results_.value = npv(includeRefDateFlows,
                             results_.valuationDate,
                             results_.valuationDate,
                             lossProbability,
                             exhaustionProbability,
                             expectedLoss);

        results_.lossProbability = lossProbability;
        results_.exhaustionProbability = exhaustionProbability;
        results_.expectedLoss = expectedLoss;

        // a bond's cashflow on settlement date is never taken into
        // account, so we might have to play it safe and recalculate
        if (!includeRefDateFlows
                     && results_.valuationDate == arguments_.settlementDate) {
            // same parameters as above, we can avoid another call
            results_.settlementValue = results_.value;
        } else {
            // no such luck
            results_.settlementValue =
                npv(includeRefDateFlows, arguments_.settlementDate, arguments_.settlementDate, lossProbability, exhaustionProbability, expectedLoss);
        }
    }

    Real MonteCarloCatBondEngine::npv(bool includeSettlementDateFlows, Date settlementDate, Date npvDate, Real& lossProbability, Real &exhaustionProbability, Real& expectedLoss) const
    {
        const size_t MAX_PATHS = 10000; //TODO
        lossProbability =  0.0;
        exhaustionProbability = 0.0;
        expectedLoss = 0.0;
        if (arguments_.cashflows.empty())
            return 0.0;

        if (settlementDate == Date())
            settlementDate = Settings::instance().evaluationDate();

        if (npvDate == Date())
            npvDate = settlementDate;

        Real totalNPV = 0.0;
        Date effectiveDate = std::max(arguments_.startDate, settlementDate);
        Date maturityDate = (*arguments_.cashflows.rbegin())->date();
        ext::shared_ptr<CatSimulation> catSimulation = catRisk_->newSimulation(effectiveDate, maturityDate);
        std::vector<std::pair<Date, Real> > eventsPath;
        NotionalPath notionalPath;
        Real riskFreeNPV = pathNpv(includeSettlementDateFlows, settlementDate, notionalPath);
        size_t pathCount=0;
        while(catSimulation->nextPath(eventsPath) && pathCount<MAX_PATHS)
        {
            arguments_.notionalRisk->updatePath(eventsPath, notionalPath);
            if(notionalPath.loss()>0) { //optimization, most paths will not include any loss
                totalNPV += pathNpv(includeSettlementDateFlows, settlementDate, notionalPath);
                lossProbability+=1;
                if (notionalPath.loss()==1) 
                    exhaustionProbability+=1;
                expectedLoss+=notionalPath.loss();
            } else {
                totalNPV += riskFreeNPV;
            }
            pathCount++;
        }
        lossProbability/=pathCount;
        exhaustionProbability/=pathCount;
        expectedLoss/=pathCount;
        return totalNPV/(pathCount*discountCurve_->discount(npvDate));
    }

    Real MonteCarloCatBondEngine::pathNpv(bool includeSettlementDateFlows, 
                                          Date settlementDate, 
                                          const NotionalPath& notionalPath) const {
        Real totalNPV = 0.0;
        for (auto& cashflow : arguments_.cashflows) {
            if (!cashflow->hasOccurred(settlementDate, includeSettlementDateFlows)) {
                Real amount = cashFlowRiskyValue(cashflow, notionalPath);
                totalNPV += amount * discountCurve_->discount(cashflow->date());
            }
        }
        return totalNPV;
    }

    Real MonteCarloCatBondEngine::cashFlowRiskyValue(const ext::shared_ptr<CashFlow>& cf,
                                                     const NotionalPath& notionalPath) const {
        return cf->amount()*notionalPath.notionalRate(cf->date()); //TODO: fix for more complicated cashflows
    }

}
]]></document_content>
  </document>
  <document index="80">
    <source>catbonds/montecarlocatbondengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file montecarlocatbondengine.hpp
    \brief Monte Carlo pricing engine for cat bonds
*/

#ifndef quantlib_montecarlo_catbond_engine_hpp
#define quantlib_montecarlo_catbond_engine_hpp

#include <ql/experimental/catbonds/catbond.hpp>

namespace QuantLib {

    class MonteCarloCatBondEngine :
        public CatBond::engine
    {
    public:
      explicit MonteCarloCatBondEngine(
          ext::shared_ptr<CatRisk> catRisk,
          Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>(),
          const boost::optional<bool>& includeSettlementDateFlows = boost::none);
      void calculate() const override;
      Handle<YieldTermStructure> discountCurve() const { return discountCurve_; }
    protected:
      Real cashFlowRiskyValue(const ext::shared_ptr<CashFlow>& cf,
                              const NotionalPath& notionalPath) const;

      Real npv(bool includeSettlementDateFlows,
               Date settlementDate,
               Date npvDate,
               Real& lossProbability,
               Real& exhaustionProbability,
               Real& expectedLoss) const;

      Real pathNpv(bool includeSettlementDateFlows,
                   Date settlementDate,
                   const NotionalPath& notionalPath) const;

    private:
      ext::shared_ptr<CatRisk> catRisk_;
      Handle<YieldTermStructure> discountCurve_;
      boost::optional<bool> includeSettlementDateFlows_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="81">
    <source>catbonds/riskynotional.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/catbonds/riskynotional.hpp>

namespace QuantLib
{
    NotionalPath::NotionalPath()
    {
        Rate previous = 1.0;//full notional at the beginning
        notionalRate_.emplace_back(Date(), previous);
    }

    Rate NotionalPath::notionalRate(const Date& date) const
    {
        Size i = 0;
        for (; i<notionalRate_.size() && notionalRate_[i].first<=date; ++i)  //TODO do we take notional after reductions or before?
        {}
        return notionalRate_[i-1].second;
    }

    void NotionalPath::reset() {
        notionalRate_.resize(1);
    }

    void NotionalPath::addReduction(const Date &date, Rate newRate) {
        notionalRate_.emplace_back(date, newRate);
    }

    Real NotionalPath::loss() {
        return 1.0-notionalRate_.rbegin()->second;
    }

    void DigitalNotionalRisk::updatePath(const std::vector<std::pair<Date, Real> >  &events, 
                                         NotionalPath &path) const {
        path.reset();
        for (const auto& event : events) {
            if (event.second >= threshold_) {
                path.addReduction(paymentOffset_->paymentDate(event.first), Rate(0.0));
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="82">
    <source>catbonds/riskynotional.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file riskynotional.hpp
    \brief classes to track the notional of a cat bond
*/

#ifndef quantlib_risky_notional_hpp
#define quantlib_risky_notional_hpp

#include <ql/errors.hpp>
#include <ql/shared_ptr.hpp>
#include <ql/time/date.hpp>
#include <algorithm>
#include <utility>
#include <vector>

namespace QuantLib {

    class EventPaymentOffset {
      public:
        virtual ~EventPaymentOffset() = default;
        virtual Date paymentDate(const Date& eventDate) = 0;
    };

    class NoOffset : public EventPaymentOffset {
      public:
        Date paymentDate(const Date& eventDate) override { return eventDate; }
    };

    class NotionalPath {
      public:
        NotionalPath();

        Rate notionalRate(const Date& date) const; //The fraction of the original notional left on a given date

        void reset();

        void addReduction(const Date &date, Rate newRate);

        Real loss();

      private:
        std::vector<std::pair<Date, Real> > notionalRate_;
    };

    class NotionalRisk {
    public:
      explicit NotionalRisk(ext::shared_ptr<EventPaymentOffset> paymentOffset)
      : paymentOffset_(std::move(paymentOffset)) {}
      virtual ~NotionalRisk() = default;

      virtual void updatePath(const std::vector<std::pair<Date, Real> >& events,
                              NotionalPath& path) const = 0;

    protected:
      ext::shared_ptr<EventPaymentOffset> paymentOffset_;       
    };

    class DigitalNotionalRisk : public NotionalRisk {
      public:
        DigitalNotionalRisk(const ext::shared_ptr<EventPaymentOffset>& paymentOffset,
                            Real threshold)
        : NotionalRisk(paymentOffset), threshold_(threshold) {}

        void updatePath(const std::vector<std::pair<Date, Real> >& events,
                        NotionalPath& path) const override;

      protected:
        Real threshold_;
    };


    class ProportionalNotionalRisk : public NotionalRisk
    {
    public:
      ProportionalNotionalRisk(const ext::shared_ptr<EventPaymentOffset>& paymentOffset,
                               Real attachement,
                               Real exhaustion)
      : NotionalRisk(paymentOffset), attachement_(attachement), exhaustion_(exhaustion) {
          QL_REQUIRE(attachement < exhaustion,
                     "exhaustion level needs to be greater than attachement");
        }

        void updatePath(const std::vector<std::pair<Date, Real> >& events,
                        NotionalPath& path) const override {
            path.reset();
            Real losses = 0;
            Real previousNotional = 1;
            for (const auto& event : events) {
                losses += event.second;
                if(losses>attachement_ && previousNotional>0)
                {
                    previousNotional = std::max(0.0, (exhaustion_-losses)/(exhaustion_-attachement_));
                    path.addReduction(paymentOffset_->paymentDate(event.first), previousNotional);
                }
            }
        }

    protected:
        Real attachement_;
        Real exhaustion_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="83">
    <source>commodities/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    commodity.hpp \
    commoditycashflow.hpp \
    commoditycurve.hpp \
    commodityindex.hpp \
    commoditypricinghelpers.hpp \
    commoditysettings.hpp \
    commoditytype.hpp \
    commodityunitcost.hpp \
    dateinterval.hpp \
    energybasisswap.hpp \
    energycommodity.hpp \
    energyfuture.hpp \
    energyswap.hpp \
    energyvanillaswap.hpp \
    exchangecontract.hpp \
    paymentterm.hpp \
    petroleumunitsofmeasure.hpp \
    pricingperiod.hpp \
    quantity.hpp \
    unitofmeasure.hpp \
    unitofmeasureconversion.hpp \
    unitofmeasureconversionmanager.hpp

cpp_files = \
    commodity.cpp \
    commoditycashflow.cpp \
    commoditycurve.cpp \
    commodityindex.cpp \
    commoditypricinghelpers.cpp \
    commoditysettings.cpp \
    commoditytype.cpp \
    commodityunitcost.cpp \
    dateinterval.cpp \
    energybasisswap.cpp \
    energycommodity.cpp \
    energyfuture.cpp \
    energyswap.cpp \
    energyvanillaswap.cpp \
    paymentterm.cpp \
    quantity.cpp \
    unitofmeasure.cpp \
    unitofmeasureconversion.cpp \
    unitofmeasureconversionmanager.cpp

if UNITY_BUILD

nodist_libCommodities_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libCommodities_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libCommodities.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="84">
    <source>commodities/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/commodities/commodity.hpp>
#include <ql/experimental/commodities/commoditycashflow.hpp>
#include <ql/experimental/commodities/commoditycurve.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/experimental/commodities/commoditypricinghelpers.hpp>
#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/commodityunitcost.hpp>
#include <ql/experimental/commodities/dateinterval.hpp>
#include <ql/experimental/commodities/energybasisswap.hpp>
#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/energyfuture.hpp>
#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/experimental/commodities/energyvanillaswap.hpp>
#include <ql/experimental/commodities/exchangecontract.hpp>
#include <ql/experimental/commodities/paymentterm.hpp>
#include <ql/experimental/commodities/petroleumunitsofmeasure.hpp>
#include <ql/experimental/commodities/pricingperiod.hpp>
#include <ql/experimental/commodities/quantity.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/experimental/commodities/unitofmeasureconversion.hpp>
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>

]]></document_content>
  </document>
  <document index="85">
    <source>commodities/commodity.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commodity.hpp>
#include <iomanip>
#include <utility>

namespace QuantLib {

    Commodity::Commodity(ext::shared_ptr<SecondaryCosts> secondaryCosts)
    : secondaryCosts_(std::move(secondaryCosts)) {}

    const SecondaryCostAmounts& Commodity::secondaryCostAmounts() const {
        return secondaryCostAmounts_;
    }

    const PricingErrors& Commodity::pricingErrors() const {
        return pricingErrors_;
    }

    void Commodity::addPricingError(PricingError::Level errorLevel,
                                    const std::string& error,
                                    const std::string& detail) const {
        pricingErrors_.push_back(PricingError(errorLevel, error, detail));
    }


    std::ostream& operator<<(std::ostream& out,
                             const SecondaryCostAmounts& secondaryCostAmounts) {
        std::string currencyCode;
        Real totalAmount = 0;

        out << "secondary costs" << std::endl;
        for (const auto& secondaryCostAmount : secondaryCostAmounts) {
            Real amount = secondaryCostAmount.second.value();
            if (currencyCode.empty())
                currencyCode = secondaryCostAmount.second.currency().code();
            totalAmount += amount;
            out << std::setw(28) << std::left << secondaryCostAmount.first << std::setw(12)
                << std::right << std::fixed << std::setprecision(2) << amount << " " << currencyCode
                << std::endl;
        }
        out << std::setw(28) << std::left << "total"
            << std::setw(12) << std::right << std::fixed
            << std::setprecision(2) << totalAmount << " " << currencyCode
            << std::endl;
        return out;
    }


    std::ostream& operator<<(std::ostream& out, const PricingError& error) {
        switch (error.errorLevel) {
          case PricingError::Info:
            out << "info: ";
            break;
          case PricingError::Warning:
            out << "warning: ";
            break;
          case PricingError::Error:
            out << "*** error: ";
            break;
          case PricingError::Fatal:
            out << "*** fatal: ";
            break;
        }
        out << error.error;
        if (!error.detail.empty())
            out << ": " << error.detail;
        return out;
    }

    std::ostream& operator<<(std::ostream& out, const PricingErrors& errors) {
        if (!errors.empty()) {
            out << "*** pricing errors" << std::endl;
            for (const auto& error : errors)
                out << error << std::endl;
        }
        return out;
    }

}

]]></document_content>
  </document>
  <document index="86">
    <source>commodities/commodity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodity.hpp
    \brief Commodity base class
*/

#ifndef quantlib_commodity_hpp
#define quantlib_commodity_hpp

#include <ql/instrument.hpp>
#include <ql/money.hpp>
#include <iosfwd>
#include <utility>
#include <vector>

namespace QuantLib {

    typedef std::map<std::string, boost::any> SecondaryCosts;
    typedef std::map<std::string, Money> SecondaryCostAmounts;

    std::ostream& operator<<(std::ostream& out,
                             const SecondaryCostAmounts& secondaryCostAmounts);


    struct PricingError {
        enum Level { Info, Warning, Error, Fatal };

        Level errorLevel;
        std::string tradeId;
        std::string error;
        std::string detail;

        PricingError(Level errorLevel, std::string error, std::string detail)
        : errorLevel(errorLevel), error(std::move(error)), detail(std::move(detail)) {}
    };

    typedef std::vector<PricingError> PricingErrors;

    std::ostream& operator<<(std::ostream& out, const PricingError& error);
    std::ostream& operator<<(std::ostream& out, const PricingErrors& errors);


    //! Commodity base class
    /*! \ingroup instruments */
    class Commodity : public Instrument {
      public:
        explicit Commodity(ext::shared_ptr<SecondaryCosts> secondaryCosts);
        const ext::shared_ptr<SecondaryCosts>& secondaryCosts() const;
        const SecondaryCostAmounts& secondaryCostAmounts() const;
        const PricingErrors& pricingErrors() const;
        void addPricingError(PricingError::Level errorLevel,
                             const std::string& error,
                             const std::string& detail = "") const;
      protected:
        ext::shared_ptr<SecondaryCosts> secondaryCosts_;
        mutable PricingErrors pricingErrors_;
        mutable SecondaryCostAmounts secondaryCostAmounts_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="87">
    <source>commodities/commoditycashflow.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditycashflow.hpp>
#include <ql/patterns/visitor.hpp>
#include <iomanip>

namespace QuantLib {

    void CommodityCashFlow::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<CommodityCashFlow>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            CashFlow::accept(v);
    }

    std::ostream& operator<<(std::ostream& out,
                             const CommodityCashFlows& cashFlows) {
        if (cashFlows.empty())
            return out << "no cashflows" << std::endl;
        out << "cashflows" << std::endl;
        std::string currencyCode; //= cashFlows[0]->discountedAmount().currency().code();
        Real totalDiscounted = 0;
        Real totalUndiscounted = 0;
        for (const auto& i : cashFlows) {
            //const ext::shared_ptr<CommodityCashFlow> cashFlow = *i;
            const ext::shared_ptr<CommodityCashFlow> cashFlow = i.second;
            totalDiscounted += cashFlow->discountedAmount().value();
            totalUndiscounted += cashFlow->undiscountedAmount().value();
            //out << io::iso_date(cashFlow->date()) << " " <<
            out << io::iso_date(i.first) << " " << std::setw(16) << std::right << std::fixed
                << std::setprecision(2) << cashFlow->discountedAmount().value() << " "
                << currencyCode << std::setw(16) << std::right << std::fixed << std::setprecision(2)
                << cashFlow->undiscountedAmount().value() << " " << currencyCode << std::endl;
        }
        out << "total      "
            << std::setw(16) << std::right << std::fixed
            << std::setprecision(2) << totalDiscounted << " " << currencyCode
            << std::setw(16) << std::right << std::fixed
            << std::setprecision(2) << totalUndiscounted << " "
            << currencyCode << std::endl;
        return out;
    }

}

]]></document_content>
  </document>
  <document index="88">
    <source>commodities/commoditycashflow.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditycashflow.hpp
    \brief Commodity cash flow
*/

#ifndef quantlib_commodity_cash_flow_hpp
#define quantlib_commodity_cash_flow_hpp

#include <ql/cashflow.hpp>
#include <ql/money.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    class CommodityCashFlow : public CashFlow {
      public:
        CommodityCashFlow(const Date& date,
                          Money discountedAmount,
                          Money undiscountedAmount,
                          Money discountedPaymentAmount,
                          Money undiscountedPaymentAmount,
                          Real discountFactor,
                          Real paymentDiscountFactor,
                          bool finalized)
        : date_(date), discountedAmount_(std::move(discountedAmount)),
          undiscountedAmount_(std::move(undiscountedAmount)),
          discountedPaymentAmount_(std::move(discountedPaymentAmount)),
          undiscountedPaymentAmount_(std::move(undiscountedPaymentAmount)),
          discountFactor_(discountFactor), paymentDiscountFactor_(paymentDiscountFactor),
          finalized_(finalized) {}
        //! \name Event interface
        //@{
        Date date() const override { return date_; }
        //@}
        //! \name CashFlow interface
        //@{
        Real amount() const override { return discountedAmount_.value(); }
        //@}
        const Currency& currency() const {
            return discountedAmount_.currency();
        }

        const Money& discountedAmount() const { return discountedAmount_; }
        const Money& undiscountedAmount() const { return undiscountedAmount_; }
        const Money& discountedPaymentAmount() const {
            return discountedPaymentAmount_;
        }
        const Money& undiscountedPaymentAmount() const {
            return undiscountedPaymentAmount_;
        }
        Real discountFactor() const { return discountFactor_; }
        Real paymentDiscountFactor() const { return paymentDiscountFactor_; }
        bool finalized() const { return finalized_; }

        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      private:
        Date date_;
        Money discountedAmount_, undiscountedAmount_,
              discountedPaymentAmount_, undiscountedPaymentAmount_;
        Real discountFactor_, paymentDiscountFactor_;
        bool finalized_;
    };

    typedef std::map<Date, ext::shared_ptr<CommodityCashFlow> >
                                                           CommodityCashFlows;

    #ifndef __DOXYGEN__
    std::ostream& operator<<(std::ostream& out,
                             const CommodityCashFlows& cashFlows);
    #endif

}

#endif
]]></document_content>
  </document>
  <document index="89">
    <source>commodities/commoditycurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditycurve.hpp>
#include <ql/experimental/commodities/commoditypricinghelpers.hpp>
#include <utility>

namespace QuantLib {

    CommodityCurve::CommodityCurve(std::string name,
                                   CommodityType commodityType,
                                   Currency currency,
                                   UnitOfMeasure unitOfMeasure,
                                   const Calendar& calendar,
                                   const std::vector<Date>& dates,
                                   std::vector<Real> prices,
                                   const DayCounter& dayCounter)
    : TermStructure(dates[0], calendar, dayCounter), name_(std::move(name)),
      commodityType_(std::move(commodityType)), unitOfMeasure_(std::move(unitOfMeasure)),
      currency_(std::move(currency)), dates_(dates), data_(std::move(prices)),
      interpolator_(ForwardFlat()), basisOfCurveUomConversionFactor_(1) {

        QL_REQUIRE(dates_.size()>1, "too few dates");
        QL_REQUIRE(data_.size()==dates_.size(), "dates/prices count mismatch");

        times_.resize(dates_.size());
        times_[0]=0.0;
        for (Size i = 1; i < dates_.size(); i++) {
            QL_REQUIRE(dates_[i] > dates_[i-1],
                       "invalid date (" << dates_[i] << ", vs "
                       << dates_[i-1] << ")");
            times_[i] = dayCounter.yearFraction(dates_[0], dates_[i]);
        }

        interpolation_ =
            interpolator_.interpolate(times_.begin(), times_.end(),
                                      data_.begin());
        interpolation_.update();
    }

    CommodityCurve::CommodityCurve(std::string name,
                                   CommodityType commodityType,
                                   Currency currency,
                                   UnitOfMeasure unitOfMeasure,
                                   const Calendar& calendar,
                                   const DayCounter& dayCounter)
    : TermStructure(0, calendar, dayCounter), name_(std::move(name)),
      commodityType_(std::move(commodityType)), unitOfMeasure_(std::move(unitOfMeasure)),
      currency_(std::move(currency)), interpolator_(ForwardFlat()),
      basisOfCurveUomConversionFactor_(1) {}

    void CommodityCurve::setPrices(std::map<Date, Real>& prices) {
        QL_REQUIRE(prices.size()>1, "too few prices");

        dates_.clear();
        data_.clear();
        for (std::map<Date, Real>::const_iterator i = prices.begin(); i != prices.end(); ++i) {
            dates_.push_back(i->first);
            data_.push_back(i->second);
        }

        times_.resize(dates_.size());
        times_[0]=0.0;
        for (Size i = 1; i < dates_.size(); i++)
            times_[i] = dayCounter().yearFraction(dates_[0], dates_[i]);

        interpolation_ =
            interpolator_.interpolate(times_.begin(), times_.end(),
                                      data_.begin());
        interpolation_.update();
    }

    void CommodityCurve::setBasisOfCurve(
                      const ext::shared_ptr<CommodityCurve>& basisOfCurve) {
        basisOfCurve_ = basisOfCurve;
        basisOfCurveUomConversionFactor_ =
            CommodityPricingHelper::calculateUomConversionFactor(
                                                commodityType_,
                                                basisOfCurve_->unitOfMeasure_,
                                                unitOfMeasure_);
    }

    std::ostream& operator<<(std::ostream& out, const CommodityCurve& curve) {
        out << "[" << curve.name_ << "] (" << curve.currency_.code()
            << "/" << curve.unitOfMeasure_.code() << ")";
        if (curve.basisOfCurve_ != nullptr)
            out << "; basis to (" << (*curve.basisOfCurve_) << ")";
        return out;
    }

}
]]></document_content>
  </document>
  <document index="90">
    <source>commodities/commoditycurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditycurve.hpp
    \brief Commodity curve
*/

#ifndef quantlib_commodity_curve_hpp
#define quantlib_commodity_curve_hpp

#include <ql/termstructure.hpp>
#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/experimental/commodities/exchangecontract.hpp>
#include <ql/currency.hpp>
#include <ql/math/interpolations/forwardflatinterpolation.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

namespace QuantLib {

    //! Commodity term structure
    class CommodityCurve : public TermStructure {
        friend class CommodityIndex;
      public:
        // constructor
        CommodityCurve(std::string name,
                       CommodityType commodityType,
                       Currency currency,
                       UnitOfMeasure unitOfMeasure,
                       const Calendar& calendar,
                       const std::vector<Date>& dates,
                       std::vector<Real> prices,
                       const DayCounter& dayCounter = Actual365Fixed());

        CommodityCurve(std::string name,
                       CommodityType commodityType,
                       Currency currency,
                       UnitOfMeasure unitOfMeasure,
                       const Calendar& calendar,
                       const DayCounter& dayCounter = Actual365Fixed());

        //! \name Inspectors
        //@{
        const std::string& name() const;
        const CommodityType& commodityType() const;
        const UnitOfMeasure& unitOfMeasure() const;
        const Currency& currency() const;
        Date maxDate() const override;
        const std::vector<Time>& times() const;
        const std::vector<Date>& dates() const;
        const std::vector<Real>& prices() const;
        std::vector<std::pair<Date,Real> > nodes() const;
        bool empty() const;

        void setPrices(std::map<Date, Real>& prices);
        void setBasisOfCurve(
                       const ext::shared_ptr<CommodityCurve>& basisOfCurve);

        Real price(
               const Date& d,
               const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
               Integer nearbyOffset) const;
        Real basisOfPrice(const Date& d) const;
        Date underlyingPriceDate(
                const Date& date,
                const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
                Integer nearbyOffset) const;

        const ext::shared_ptr<CommodityCurve>& basisOfCurve() const;

        friend std::ostream& operator<<(std::ostream& out,
                                        const CommodityCurve& curve);
      protected:
        Real basisOfPriceImpl(Time t) const;

        std::string name_;
        CommodityType commodityType_;
        UnitOfMeasure unitOfMeasure_;
        Currency currency_;
        mutable std::vector<Date> dates_;
        mutable std::vector<Time> times_;
        mutable std::vector<Real> data_;
        mutable Interpolation interpolation_;
        ForwardFlat interpolator_;
        ext::shared_ptr<CommodityCurve> basisOfCurve_;
        Real basisOfCurveUomConversionFactor_;

        Real priceImpl(Time t) const;
    };


    // inline definitions

    inline bool operator==(const CommodityCurve& c1, const CommodityCurve& c2) {
        return c1.name() == c2.name();
    }

    inline const std::string& CommodityCurve::name() const {
        return name_;
    }

    inline Date CommodityCurve::maxDate() const {
        return dates_.back();
    }

    inline const std::vector<Time>& CommodityCurve::times() const {
        return times_;
    }

    inline const std::vector<Date>& CommodityCurve::dates() const {
        return dates_;
    }

    inline const std::vector<Real>& CommodityCurve::prices() const {
        return data_;
    }

    inline bool CommodityCurve::empty() const {
        return dates_.empty();
    }

    inline const ext::shared_ptr<CommodityCurve>&
    CommodityCurve::basisOfCurve() const {
        return basisOfCurve_;
    }

    inline std::vector<std::pair<Date,Real> > CommodityCurve::nodes() const {
        std::vector<std::pair<Date,Real> > results(dates_.size());
        for (Size i = 0; i < dates_.size(); ++i)
            results[i] = std::make_pair(dates_[i], data_[i]);
        return results;
    }

    inline Real CommodityCurve::basisOfPrice(const Date& d) const {
        Time t = timeFromReference(d);
        return basisOfPriceImpl(t);
    }

    // gets a price that can include an arbitrary number of basis curves
    inline Real CommodityCurve::price(
                const Date& d,
                const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
                Integer nearbyOffset) const {
        Date date = nearbyOffset > 0 ?
            underlyingPriceDate(d, exchangeContracts, nearbyOffset) : d;
        Time t = timeFromReference(date);
        Real priceValue = 0;
        try {
            priceValue = priceImpl(t);
        } catch (const std::exception& e) {
            QL_FAIL("error retrieving price for curve [" << name() << "]: "
                    << e.what());
        }
        return priceValue + basisOfPriceImpl(t);
    }

    // get the date for the underlying price, in the case of nearby
    // curves, rolls on the underlying contract expiry
    inline Date CommodityCurve::underlyingPriceDate(
                const Date& date,
                const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
                Integer nearbyOffset) const {
        QL_REQUIRE(nearbyOffset > 0, "nearby offset must be > 0");
        ExchangeContracts::const_iterator ic =
            exchangeContracts->lower_bound(date);
        if (ic != exchangeContracts->end()) {
            for (int i = 0; i < nearbyOffset-1 && ic!=exchangeContracts->end(); ++i)
                ++ic;
            QL_REQUIRE(ic != exchangeContracts->end(),
                       "not enough nearby contracts available for curve ["
                       << name() << "] for date [" << date << "].");
            return ic->second.underlyingStartDate();
        }
        return date;
    }

    inline Real CommodityCurve::basisOfPriceImpl(Time t) const {
        if (basisOfCurve_ != nullptr) {
            Real basisCurvePriceValue = 0;
            try {
                basisCurvePriceValue =
                    basisOfCurve_->priceImpl(t)
                    * basisOfCurveUomConversionFactor_;
            } catch (const std::exception& e) {
                QL_FAIL("error retrieving price for curve [" << name() <<
                        "]: " << e.what());
            }
            return basisCurvePriceValue + basisOfCurve_->basisOfPriceImpl(t);
        }
        return 0;
    }

    inline Real CommodityCurve::priceImpl(Time t) const {
        return interpolation_(t, true);
    }

}


#endif
]]></document_content>
  </document>
  <document index="91">
    <source>commodities/commodityindex.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/experimental/commodities/commoditypricinghelpers.hpp>
#include <utility>

namespace QuantLib {

    CommodityIndex::CommodityIndex(const std::string& indexName,
                                   CommodityType commodityType,
                                   Currency currency,
                                   UnitOfMeasure unitOfMeasure,
                                   Calendar calendar,
                                   Real lotQuantity,
                                   ext::shared_ptr<CommodityCurve> forwardCurve,
                                   ext::shared_ptr<ExchangeContracts> exchangeContracts,
                                   int nearbyOffset)
    : name_(indexName), commodityType_(std::move(commodityType)),
      unitOfMeasure_(std::move(unitOfMeasure)), currency_(std::move(currency)),
      calendar_(std::move(calendar)), lotQuantity_(lotQuantity),
      forwardCurve_(std::move(forwardCurve)), forwardCurveUomConversionFactor_(1),
      exchangeContracts_(std::move(exchangeContracts)), nearbyOffset_(nearbyOffset) {
        quotes_ = IndexManager::instance().getHistory(indexName);
        IndexManager::instance().setHistory(indexName, quotes_);
        registerWith(Settings::instance().evaluationDate());
        registerWith(IndexManager::instance().notifier(name()));

        if (forwardCurve_ != nullptr)
            // registerWith(forwardCurve_);
            forwardCurveUomConversionFactor_ =
                CommodityPricingHelper::calculateUomConversionFactor(
                                                commodityType_,
                                                forwardCurve_->unitOfMeasure_,
                                                unitOfMeasure_);
    }

    std::ostream& operator<<(std::ostream& out, const CommodityIndex& index) {
        out << "[" << index.name_ << "] ("
            << index.currency_.code() << "/"
            << index.unitOfMeasure_.code() << ")";
        if (index.forwardCurve_ != nullptr)
            out << "; forward (" << (*index.forwardCurve_) << ")";
        return out;
    }

}
]]></document_content>
  </document>
  <document index="92">
    <source>commodities/commodityindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodityindex.hpp
    \brief Commodity index
*/

#ifndef quantlib_commodity_index_hpp
#define quantlib_commodity_index_hpp

#include <ql/experimental/commodities/commoditycurve.hpp>
#include <ql/indexes/indexmanager.hpp>

namespace QuantLib {

    class TermStructure;

    //! base class for commodity indexes
    class CommodityIndex : public Observable,
                           public Observer {
      public:
        CommodityIndex(const std::string& name,
                       CommodityType commodityType,
                       Currency currency,
                       UnitOfMeasure unitOfMeasure,
                       Calendar calendar,
                       Real lotQuantity,
                       ext::shared_ptr<CommodityCurve> forwardCurve,
                       ext::shared_ptr<ExchangeContracts> exchangeContracts,
                       int nearbyOffset);
        //! \name Index interface
        //@{
        std::string name() const;
        //@}
        //! \name Observer interface
        //@{
        void update() override;
        //@}
        //! \name Inspectors
        //@{
        const CommodityType& commodityType() const;
        const Currency& currency() const;
        const UnitOfMeasure& unitOfMeasure() const;
        const Calendar& calendar() const;
        const ext::shared_ptr<CommodityCurve>& forwardCurve() const;
        Real lotQuantity() const;

        Real price(const Date& date);
        Real forwardPrice(const Date& date) const;
        Date lastQuoteDate() const;
        //@}
        void addQuote(const Date& quoteDate, Real quote);

        void addQuotes(const std::map<Date, Real>& quotes) {
            std::string tag = name();
            quotes_ = IndexManager::instance().getHistory(tag);
            for (auto quote : quotes) {
                quotes_[quote.first] = quote.second;
            }
            IndexManager::instance().setHistory(tag, quotes_);
        }

        void clearQuotes() const;
        //! returns TRUE if the quote date is valid
        bool isValidQuoteDate(const Date& quoteDate) const;
        bool empty() const;
        bool forwardCurveEmpty() const;
        const TimeSeries<Real>& quotes() const;

        friend std::ostream& operator<<(std::ostream&, const CommodityIndex&);
      protected:
        std::string name_;
        CommodityType commodityType_;
        UnitOfMeasure unitOfMeasure_;
        Currency currency_;
        Calendar calendar_;
        Real lotQuantity_;
        TimeSeries<Real> quotes_;
        ext::shared_ptr<CommodityCurve> forwardCurve_;
        Real forwardCurveUomConversionFactor_;
        ext::shared_ptr<ExchangeContracts> exchangeContracts_;
        Integer nearbyOffset_;
    };


    // inline definitions

    inline bool operator==(const CommodityIndex& i1, const CommodityIndex& i2) {
        return i1.name() == i2.name();
    }

    inline void CommodityIndex::update() {
        notifyObservers();
    }

    inline std::string CommodityIndex::name() const {
        return name_;
    }

    inline const CommodityType& CommodityIndex::commodityType() const {
        return commodityType_;
    }

    inline const UnitOfMeasure& CommodityIndex::unitOfMeasure() const {
        return unitOfMeasure_;
    }

    inline const Currency& CommodityIndex::currency() const {
        return currency_;
    }

    inline const Calendar& CommodityIndex::calendar() const {
        return calendar_;
    }

    inline Real CommodityIndex::lotQuantity() const {
        return lotQuantity_;
    }

    inline const ext::shared_ptr<CommodityCurve>&
    CommodityIndex::forwardCurve() const {
        return forwardCurve_;
    }

    inline const TimeSeries<Real>& CommodityIndex::quotes() const {
        return quotes_;
    }

    inline Real CommodityIndex::price(const Date& date) {
        auto hq = quotes_.find(date);
        if (hq->second == Null<Real>()) {
            ++hq;
            if (hq == quotes_.end())
                //if (hq->second == Null<Real>())
                return Null<Real>();
        }
        return hq->second;
    }

    inline Real CommodityIndex::forwardPrice(const Date& date) const {
        try {
            Real forwardPrice =
                forwardCurve_->price(date, exchangeContracts_, nearbyOffset_);
            return forwardPrice * forwardCurveUomConversionFactor_;
        } catch (const std::exception& e) {
            QL_FAIL("error fetching forward price for index " << name_
                    << ": " << e.what());
        }
    }

    inline Date CommodityIndex::lastQuoteDate() const {
        if (quotes_.empty())
            return Date::minDate();
        return quotes_.lastDate();
    }

    inline bool CommodityIndex::empty() const {
        return quotes_.empty();
    }

    inline bool CommodityIndex::forwardCurveEmpty() const {
        if (forwardCurve_ != nullptr)
            return forwardCurve_->empty();
        return false;
    }

    inline void CommodityIndex::addQuote(const Date& quoteDate, Real quote) {
        //QL_REQUIRE(isValidQuoteDate(quoteDate),
        //           "Quote date " << quoteDate.weekday() << ", " <<
        //           quoteDate << " is not valid");
        std::string tag = name();
        quotes_ = IndexManager::instance().getHistory(tag);
        quotes_[quoteDate] = quote;
        IndexManager::instance().setHistory(tag, quotes_);
    }

    inline void CommodityIndex::clearQuotes() const {
        IndexManager::instance().clearHistory(name());
    }

    inline bool CommodityIndex::isValidQuoteDate(const Date& quoteDate) const {
        return calendar().isBusinessDay(quoteDate);
    }

}

#endif
]]></document_content>
  </document>
  <document index="93">
    <source>commodities/commoditypricinghelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditypricinghelpers.hpp>

namespace QuantLib {

    void CommodityPricingHelper::createPricingPeriods(
                          Date startDate, Date endDate,
                          const Quantity& quantity,
                          EnergyCommodity::DeliverySchedule deliverySchedule,
                          EnergyCommodity::QuantityPeriodicity qtyPeriodicity,
                          const PaymentTerm& paymentTerm,
                          PricingPeriods& pricingPeriods) {
        if (deliverySchedule == EnergyCommodity::Monthly) {
            Quantity periodQuantity;
            if (qtyPeriodicity == EnergyCommodity::PerMonth) {
                periodQuantity = quantity;
            } else {
                QL_FAIL("Invalid period quantity/pricing period combination.");
            }

            for (Date periodStartDate=startDate; periodStartDate<endDate; ) {
                Date periodEndDate = (periodStartDate + (1 * Months)) - 1;
                Date paymentDate = paymentTerm.getPaymentDate(periodEndDate);
                pricingPeriods.push_back(ext::make_shared<PricingPeriod>(
                             periodStartDate, periodEndDate,
                                               paymentDate, periodQuantity));
                periodStartDate = periodEndDate + 1;
            }
        } else if (deliverySchedule == EnergyCommodity::Daily) {
            QL_REQUIRE(qtyPeriodicity == EnergyCommodity::PerDay,
                       "Invalid period quantity/pricing period combination.");

            for (Date periodStartDate=startDate; periodStartDate<endDate; ) {
                Date periodEndDate = (periodStartDate + (1 * Months)) - 1;

                Quantity periodQuantity =
                    quantity * (periodEndDate - periodStartDate);
                Date paymentDate = paymentTerm.getPaymentDate(periodEndDate);
                pricingPeriods.push_back(ext::make_shared<PricingPeriod>(
                             periodStartDate, periodEndDate,
                                               paymentDate, periodQuantity));
                periodStartDate = periodEndDate + 1;
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="94">
    <source>commodities/commoditypricinghelpers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditypricinghelpers.hpp
    \brief Commodity pricing helpers
*/

#ifndef quantlib_commodity_pricing_helpers_hpp
#define quantlib_commodity_pricing_helpers_hpp

#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/paymentterm.hpp>
#include <ql/experimental/commodities/pricingperiod.hpp>
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>
#include <ql/currencies/exchangeratemanager.hpp>

namespace QuantLib {

    //! commodity index helper
    class CommodityPricingHelper {
      public:
        CommodityPricingHelper();

        static Real calculateFxConversionFactor(const Currency& fromCurrency,
                                                const Currency& toCurrency,
                                                const Date& evaluationDate);

        static Real calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure);

        static Real calculateUnitCost(const CommodityType& commodityType,
                                      const CommodityUnitCost& unitCost,
                                      const Currency& baseCurrency,
                                      const UnitOfMeasure& baseUnitOfMeasure,
                                      const Date& evaluationDate);

        static void createPricingPeriods(
                          Date startDate, Date endDate,
                          const Quantity& quantity,
                          EnergyCommodity::DeliverySchedule deliverySchedule,
                          EnergyCommodity::QuantityPeriodicity qtyPeriodicity,
                          const PaymentTerm& paymentTerm,
                          PricingPeriods& pricingPeriods);
    };


    inline Real CommodityPricingHelper::calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure) {
        if (toUnitOfMeasure != fromUnitOfMeasure) {
            UnitOfMeasureConversion uomConv =
                UnitOfMeasureConversionManager::instance().lookup(
                           commodityType, fromUnitOfMeasure, toUnitOfMeasure);
            return uomConv.conversionFactor();
        }

        return 1;
    }

    inline Real CommodityPricingHelper::calculateFxConversionFactor(
                                                 const Currency& fromCurrency,
                                                 const Currency& toCurrency,
                                                 const Date& evaluationDate) {
        if (fromCurrency != toCurrency) {
            ExchangeRate exchRate =
                ExchangeRateManager::instance().lookup(fromCurrency,
                                                       toCurrency,
                                                       evaluationDate,
                                                       ExchangeRate::Direct);
            if (fromCurrency != exchRate.source())
                return (Real)1 / exchRate.rate();
            return exchRate.rate();
        }
        return 1;
    }

    inline Real CommodityPricingHelper::calculateUnitCost(
                                       const CommodityType& commodityType,
                                       const CommodityUnitCost& unitCost,
                                       const Currency& baseCurrency,
                                       const UnitOfMeasure& baseUnitOfMeasure,
                                       const Date& evaluationDate) {
        if (unitCost.amount().value() != 0) {
            Real unitCostUomConversionFactor =
                calculateUomConversionFactor(commodityType,
                                             unitCost.unitOfMeasure(),
                                             baseUnitOfMeasure);
            Real unitCostFxConversionFactor =
                calculateFxConversionFactor(unitCost.amount().currency(),
                                            baseCurrency, evaluationDate);
            return unitCost.amount().value() * unitCostUomConversionFactor
                 * unitCostFxConversionFactor;
        }
        return 0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="95">
    <source>commodities/commoditysettings.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/currencies/america.hpp>
#include <ql/experimental/commodities/petroleumunitsofmeasure.hpp>

namespace QuantLib {

    CommoditySettings::CommoditySettings()
    : currency_(USDCurrency()), unitOfMeasure_(BarrelUnitOfMeasure()) {}

    Currency& CommoditySettings::currency() {
        return currency_;
    }

    UnitOfMeasure& CommoditySettings::unitOfMeasure() {
        return unitOfMeasure_;
    }

}
]]></document_content>
  </document>
  <document index="96">
    <source>commodities/commoditysettings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditysettings.hpp
    \brief commodity settings
*/

#ifndef quantlib_commodity_settings_hpp
#define quantlib_commodity_settings_hpp

#include <ql/patterns/singleton.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/currency.hpp>

namespace QuantLib {

    //! global repository for run-time library settings
    class CommoditySettings : public Singleton<CommoditySettings> {
        friend class Singleton<CommoditySettings>;
      private:
        CommoditySettings();

      public:
        Currency& currency();
        UnitOfMeasure& unitOfMeasure();
      private:
        Currency currency_;
        UnitOfMeasure unitOfMeasure_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="97">
    <source>commodities/commoditytype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditytype.hpp>
#include <ostream>

namespace QuantLib {

    std::map<std::string, ext::shared_ptr<CommodityType::Data> >
    CommodityType::commodityTypes_;

    CommodityType::CommodityType(const std::string& name,
                                 const std::string& code) {
        std::map<std::string, ext::shared_ptr<CommodityType::Data> >::const_iterator i = commodityTypes_.find(code);
        if (i != commodityTypes_.end())
            data_ = i->second;
        else {
            data_ = ext::make_shared<CommodityType::Data>(
                                         name, code);
            commodityTypes_[code] = data_;
        }
    }

    std::ostream& operator<<(std::ostream& out, const CommodityType& c) {
        if (!c.empty())
            return out << c.code();
        else
            return out << "null commodity type";
    }

}

]]></document_content>
  </document>
  <document index="98">
    <source>commodities/commoditytype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodity.hpp
    \brief commodity type
*/

#ifndef quantlib_commodity_type_hpp
#define quantlib_commodity_type_hpp

#include <ql/qldefines.hpp>
#include <ql/shared_ptr.hpp>
#include <iosfwd>
#include <map>
#include <string>
#include <utility>

namespace QuantLib {

    //! commodity type
    class CommodityType {
      public:
        //! default constructor
        /*! Instances built via this constructor have undefined
          behavior. Such instances can only act as placeholders
          and must be reassigned to a valid currency before being
          used.
        */
        CommodityType() = default;
        CommodityType(const std::string& code, const std::string& name);
        //! \name Inspectors
        //@{
        //! commodity code, e.g, "HO"
        const std::string& code() const;
        //! name, e.g, "Heating Oil"
        const std::string& name() const;
        // commodity code
        //@}
        //! \name Other information
        //@{
        //! is this a usable instance?
        bool empty() const;
        //@}

      protected:
        struct Data;
        ext::shared_ptr<Data> data_;

        struct Data {
            std::string name, code;

            Data(std::string name, std::string code)
            : name(std::move(name)), code(std::move(code)) {}
        };

        static std::map<std::string, ext::shared_ptr<Data> > commodityTypes_;
    };

    /*! \relates CommodityType */
    bool operator==(const CommodityType&,
                    const CommodityType&);

    /*! \relates CommodityType */
    bool operator!=(const CommodityType&,
                    const CommodityType&);

    /*! \relates CommodityType */
    std::ostream& operator<<(std::ostream&,
                             const CommodityType&);


    class NullCommodityType : public CommodityType {
      public:
        NullCommodityType() :
        CommodityType("<NULL>", "<NULL>") {}
    };


    inline const std::string& CommodityType::code() const {
        return data_->code;
    }

    inline const std::string& CommodityType::name() const {
        return data_->name;
    }

    inline bool CommodityType::empty() const {
        return !data_;
    }

    inline bool operator==(const CommodityType& c1, const CommodityType& c2) {
        return c1.code() == c2.code();
    }

    inline bool operator!=(const CommodityType& c1, const CommodityType& c2) {
        return !(c1 == c2);
    }

}


#endif
]]></document_content>
  </document>
  <document index="99">
    <source>commodities/commodityunitcost.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commodityunitcost.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             const CommodityUnitCost& unitCost) {
        out << unitCost.amount().value() << " "
            << unitCost.amount().currency().code() << "/"
            << unitCost.unitOfMeasure().code();
        return out;
    }

}

]]></document_content>
  </document>
  <document index="100">
    <source>commodities/commodityunitcost.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodityunitcost.hpp
    \brief Commodity unit cost
*/

#ifndef quantlib_commodity_unit_cost_hpp
#define quantlib_commodity_unit_cost_hpp

#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/money.hpp>
#include <utility>

namespace QuantLib {

    class CommodityUnitCost {
      public:
        CommodityUnitCost() = default;
        CommodityUnitCost(Money amount, UnitOfMeasure unitOfMeasure)
        : amount_(std::move(amount)), unitOfMeasure_(std::move(unitOfMeasure)) {}

        const Money& amount() const { return amount_; }
        const UnitOfMeasure& unitOfMeasure() const { return unitOfMeasure_; }

      private:
        Money amount_;
        UnitOfMeasure unitOfMeasure_;
    };

    std::ostream& operator<<(std::ostream& out,
                             const CommodityUnitCost& unitCost);

}

#endif
]]></document_content>
  </document>
  <document index="101">
    <source>commodities/dateinterval.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/dateinterval.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, const DateInterval& di) {
        if (di.startDate_ == Date() || di.endDate_ == Date())
            return out << "Null<DateInterval>()";
        return out << di.startDate_ << " to " << di.endDate_;
    }

}
]]></document_content>
  </document>
  <document index="102">
    <source>commodities/dateinterval.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dateinterval.hpp
    \brief Date interval
*/

#ifndef quantlib_date_interval_hpp
#define quantlib_date_interval_hpp

#include <ql/time/date.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    //! Date interval described by a number of a given time unit
    /*! \ingroup datetime */
    class DateInterval {
        friend std::ostream& operator<<(std::ostream&, const DateInterval&);

      private:
        Date startDate_;
        Date endDate_;
      public:
        DateInterval() = default;
        DateInterval(const Date& startDate, const Date& endDate)
        : startDate_(startDate), endDate_(endDate) {
            QL_REQUIRE(endDate_ >= startDate_,
                       "end date must be >= start date");
        }
        const Date& startDate() const { return startDate_; }
        const Date& endDate() const { return endDate_; }

        bool isDateBetween(Date date,
                           bool includeFirst = true,
                           bool includeLast = true) const {
            if (includeFirst && !(date >= startDate_))
                return false;
            else if (!(date > startDate_))
                return false;
            if (includeLast && !(date <= endDate_))
                return false;
            else if (!(date < endDate_))
                return false;
            return true;
        }

        DateInterval intersection(const DateInterval& di) const {
            if ((startDate_ < di.startDate_ && endDate_ < di.startDate_) ||
                (startDate_ > di.endDate_ && endDate_ > di.endDate_))
                return {};
            return {std::max(startDate_, di.startDate_), std::min(endDate_, di.endDate_)};
        }

        bool operator==(const DateInterval& rhs) const {
            return startDate_ == rhs.startDate_ && endDate_ == rhs.endDate_;
        }

        bool operator!=(const DateInterval& rhs) const {
            return !(*this == rhs);
        }
    };

}

#endif
]]></document_content>
  </document>
  <document index="103">
    <source>commodities/energybasisswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/experimental/commodities/energybasisswap.hpp>
#include <utility>

namespace QuantLib {

    EnergyBasisSwap::EnergyBasisSwap(const Calendar& calendar,
                                     ext::shared_ptr<CommodityIndex> spreadIndex,
                                     ext::shared_ptr<CommodityIndex> payIndex,
                                     ext::shared_ptr<CommodityIndex> receiveIndex,
                                     bool spreadToPayLeg,
                                     const Currency& payCurrency,
                                     const Currency& receiveCurrency,
                                     const PricingPeriods& pricingPeriods,
                                     CommodityUnitCost basis,
                                     const CommodityType& commodityType,
                                     const ext::shared_ptr<SecondaryCosts>& secondaryCosts,
                                     Handle<YieldTermStructure> payLegTermStructure,
                                     Handle<YieldTermStructure> receiveLegTermStructure,
                                     Handle<YieldTermStructure> discountTermStructure)
    : EnergySwap(
          calendar, payCurrency, receiveCurrency, pricingPeriods, commodityType, secondaryCosts),
      spreadIndex_(std::move(spreadIndex)), payIndex_(std::move(payIndex)),
      receiveIndex_(std::move(receiveIndex)), spreadToPayLeg_(spreadToPayLeg),
      basis_(std::move(basis)), payLegTermStructure_(std::move(payLegTermStructure)),
      receiveLegTermStructure_(std::move(receiveLegTermStructure)),
      discountTermStructure_(std::move(discountTermStructure)) {
        QL_REQUIRE(!pricingPeriods_.empty(), "no payment dates");
        registerWith(spreadIndex_);
        registerWith(payIndex_);
        registerWith(receiveIndex_);
    }

    void EnergyBasisSwap::performCalculations() const {

        try {

            if (payIndex_->empty()) {
                if (payIndex_->forwardCurveEmpty()) {
                    QL_FAIL("index [" + payIndex_->name() +
                            "] does not have any quotes or forward prices");
                } else {
                    addPricingError(PricingError::Warning,
                                    "index [" + payIndex_->name() +
                                    "] does not have any quotes; "
                                    "using forward prices from [" +
                                    payIndex_->forwardCurve()->name() + "]");
                }
            }
            if (receiveIndex_->empty()) {
                if (receiveIndex_->forwardCurveEmpty()) {
                    QL_FAIL("index [" + receiveIndex_->name() +
                            "] does not have any quotes or forward prices");
                } else {
                    addPricingError(PricingError::Warning,
                                    "index [" + receiveIndex_->name() +
                                    "] does not have any quotes; "
                                    "using forward prices from [" +
                                    receiveIndex_->forwardCurve()->name() +
                                    "]");
                }
            }

            NPV_ = 0.0;
            additionalResults_.clear();
            dailyPositions_.clear();
            paymentCashFlows_.clear();

            Date evaluationDate = Settings::instance().evaluationDate();

            const Currency& baseCurrency =
                CommoditySettings::instance().currency();
            const UnitOfMeasure baseUnitOfMeasure =
                CommoditySettings::instance().unitOfMeasure();

            Real quantityUomConversionFactor =
                calculateUomConversionFactor(
                               pricingPeriods_[0]->quantity().commodityType(),
                               baseUnitOfMeasure,
                               pricingPeriods_[0]->quantity().unitOfMeasure());
            Real payIndexUomConversionFactor =
                calculateUomConversionFactor(payIndex_->commodityType(),
                                             payIndex_->unitOfMeasure(),
                                             baseUnitOfMeasure);
            Real receiveIndexUomConversionFactor =
                calculateUomConversionFactor(receiveIndex_->commodityType(),
                                             receiveIndex_->unitOfMeasure(),
                                             baseUnitOfMeasure);

            Real payIndexFxConversionFactor =
                calculateFxConversionFactor(payIndex_->currency(),
                                            baseCurrency, evaluationDate);
            Real receiveIndexFxConversionFactor =
                calculateFxConversionFactor(receiveIndex_->currency(),
                                            baseCurrency, evaluationDate);
            Real payLegFxConversionFactor =
                calculateFxConversionFactor(baseCurrency, payCurrency_,
                                            evaluationDate);
            Real receiveLegFxConversionFactor =
                calculateFxConversionFactor(baseCurrency, receiveCurrency_,
                                            evaluationDate);

            Real basisUomConversionFactor =
                calculateUomConversionFactor(
                               pricingPeriods_[0]->quantity().commodityType(),
                               basis_.unitOfMeasure(), baseUnitOfMeasure);
            Real basisFxConversionFactor =
                calculateFxConversionFactor(baseCurrency,
                                            basis_.amount().currency(),
                                            evaluationDate);

            Real basisValue = basis_.amount().value() *
                basisUomConversionFactor * basisFxConversionFactor;

            Date lastPayIndexQuoteDate = payIndex_->lastQuoteDate();
            Date lastReceiveIndexQuoteDate = receiveIndex_->lastQuoteDate();

            if (lastPayIndexQuoteDate < evaluationDate - 1) {
                std::ostringstream message;
                message << "index [" << payIndex_->name()
                        << "] has last quote date of "
                        << io::iso_date(lastPayIndexQuoteDate);
                addPricingError(PricingError::Warning, message.str());
            }
            if (lastReceiveIndexQuoteDate < evaluationDate - 1) {
                std::ostringstream message;
                message << "index [" << receiveIndex_->name()
                        << "] has last quote date of "
                        << io::iso_date(lastReceiveIndexQuoteDate);
                addPricingError(PricingError::Warning, message.str());
            }

            Date lastQuoteDate = std::min(lastPayIndexQuoteDate,
                                          lastReceiveIndexQuoteDate);

            Real totalQuantityAmount = 0;

            // price each period
            for (const auto& pricingPeriod : pricingPeriods_) {
                Integer periodDayCount = 0;

                // get the index quotes
                Date periodStartDate =
                    calendar_.adjust(pricingPeriod->startDate());
                for (Date stepDate = periodStartDate;
                     stepDate <= pricingPeriod->endDate();
                     stepDate = calendar_.advance(stepDate, 1*Days)) {

                    bool unrealized = stepDate > evaluationDate;
                    Real payQuoteValue = 0;
                    Real receiveQuoteValue = 0;

                    if (stepDate <= lastQuoteDate) {
                        payQuoteValue = payIndex_->price(stepDate);
                        receiveQuoteValue = receiveIndex_->price(stepDate);
                    } else {
                        payQuoteValue = payIndex_->forwardPrice(stepDate);
                        receiveQuoteValue =
                            receiveIndex_->forwardPrice(stepDate);
                    }

                    if (payQuoteValue == 0) {
                        std::ostringstream message;
                        message << "pay quote value for curve ["
                                << payIndex_->name() << "] is 0 for date "
                                << io::iso_date(stepDate);
                        addPricingError(PricingError::Warning, message.str());
                    }
                    if (receiveQuoteValue == 0) {
                        std::ostringstream message;
                        message << "receive quote value for curve ["
                                << receiveIndex_->name() << "] is 0 for date "
                                << io::iso_date(stepDate);
                        addPricingError(PricingError::Warning, message.str());
                    }

                    QL_REQUIRE(payQuoteValue != Null<Real>(),
                               "curve [" << payIndex_->name() <<
                               "] missing value for pricing date: "
                               << stepDate);
                    QL_REQUIRE(receiveQuoteValue != Null<Real>(),
                               "curve [" << receiveIndex_->name() <<
                               "] missing value for pricing date: "
                               << stepDate);

                    Real payLegPriceValue =
                        payQuoteValue * payIndexUomConversionFactor *
                        payIndexFxConversionFactor;
                    Real receiveLegPriceValue =
                        receiveQuoteValue * receiveIndexUomConversionFactor *
                        receiveIndexFxConversionFactor;

                    if (spreadToPayLeg_)
                        payLegPriceValue += basisValue;
                    else
                        receiveLegPriceValue += basisValue;

                    dailyPositions_[stepDate] =
                        EnergyDailyPosition(stepDate, payLegPriceValue,
                                            receiveLegPriceValue, unrealized);
                    periodDayCount++;
                }

                Real periodQuantityAmount =
                    pricingPeriod->quantity().amount() *
                    quantityUomConversionFactor;
                totalQuantityAmount += periodQuantityAmount;

                Real avgDailyQuantityAmount =
                    periodDayCount == 0 ? 0 :
                                          periodQuantityAmount / periodDayCount;

                Real payLegValue = 0;
                Real receiveLegValue = 0;
                for (auto dpi = dailyPositions_.find(periodStartDate);
                     dpi != dailyPositions_.end() && dpi->first <= pricingPeriod->endDate();
                     ++dpi) {
                    EnergyDailyPosition& dailyPosition = dpi->second;
                    dailyPosition.quantityAmount = avgDailyQuantityAmount;
                    dailyPosition.riskDelta =
                        (-dailyPosition.payLegPrice + dailyPosition.receiveLegPrice) * avgDailyQuantityAmount;
                    payLegValue += -dailyPosition.payLegPrice * avgDailyQuantityAmount;
                    receiveLegValue += dailyPosition.receiveLegPrice * avgDailyQuantityAmount;
                }

                Real discountFactor = 1;
                Real payLegDiscountFactor = 1;
                Real receiveLegDiscountFactor = 1;
                if (pricingPeriod->paymentDate() >= evaluationDate + 2 /* settlement days*/) {
                    discountFactor =
                        discountTermStructure_->discount(
                                                pricingPeriod->paymentDate());
                    payLegDiscountFactor =
                        payLegTermStructure_->discount(
                                                pricingPeriod->paymentDate());
                    receiveLegDiscountFactor =
                        receiveLegTermStructure_->discount(
                                                pricingPeriod->paymentDate());
                }

                Real uDelta = receiveLegValue + payLegValue;
                Real dDelta = (receiveLegValue * receiveLegDiscountFactor) +
                    (payLegValue * payLegDiscountFactor);
                Real pmtFxConversionFactor =
                    (dDelta > 0) ? payLegFxConversionFactor : receiveLegFxConversionFactor;
                Currency pmtCurrency =
                    (dDelta  > 0) ? receiveCurrency_ : payCurrency_;
                Real pmtDiscountFactor =
                    (dDelta  > 0) ? receiveLegDiscountFactor : payLegDiscountFactor;

                paymentCashFlows_[pricingPeriod->paymentDate()] =
                    ext::make_shared<CommodityCashFlow> (
                           pricingPeriod->paymentDate(),
                                                 Money(baseCurrency,
                                                       uDelta * discountFactor),
                                                 Money(baseCurrency, uDelta),
                                                 Money(pmtCurrency,
                                                       dDelta * pmtFxConversionFactor),
                                                 Money(pmtCurrency,
                                                       uDelta * pmtFxConversionFactor),
                                                 discountFactor,
                                                 pmtDiscountFactor,
                                                 pricingPeriod->paymentDate() <= evaluationDate);

                calculateSecondaryCostAmounts(
                               pricingPeriods_[0]->quantity().commodityType(),
                               totalQuantityAmount, evaluationDate);

                NPV_ += dDelta;
            }

            QL_REQUIRE(!paymentCashFlows_.empty(), "no cashflows");

            for (SecondaryCostAmounts::const_iterator i =
                     secondaryCostAmounts_.begin();
                 i != secondaryCostAmounts_.end(); ++i) {
                Real amount = i->second.value();
                NPV_ -= amount;
            }

            additionalResults_["dailyPositions"] = dailyPositions_;
          
        } catch (const QuantLib::Error& e) {
            addPricingError(PricingError::Error, e.what());
            throw;
        } catch (const std::exception& e) {
            addPricingError(PricingError::Error, e.what());
            throw;
        }
    }

}

]]></document_content>
  </document>
  <document index="104">
    <source>commodities/energybasisswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energybasisswap.hpp
    \brief Energy basis swap
*/

#ifndef quantlib_energy_basis_swap_hpp
#define quantlib_energy_basis_swap_hpp

#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Energy basis swap
    class EnergyBasisSwap : public EnergySwap {
      public:
        EnergyBasisSwap(const Calendar& calendar,
                        ext::shared_ptr<CommodityIndex> spreadIndex,
                        ext::shared_ptr<CommodityIndex> payIndex,
                        ext::shared_ptr<CommodityIndex> receiveIndex,
                        bool spreadToPayLeg,
                        const Currency& payCurrency,
                        const Currency& receiveCurrency,
                        const PricingPeriods& pricingPeriods,
                        CommodityUnitCost basis,
                        const CommodityType& commodityType,
                        const ext::shared_ptr<SecondaryCosts>& secondaryCosts,
                        Handle<YieldTermStructure> payLegTermStructure,
                        Handle<YieldTermStructure> receiveLegTermStructure,
                        Handle<YieldTermStructure> discountTermStructure);

        const ext::shared_ptr<CommodityIndex>& payIndex() const {
            return payIndex_;
        }
        const ext::shared_ptr<CommodityIndex>& receiveIndex() const {
            return receiveIndex_;
        }
        const CommodityUnitCost& basis() const { return basis_; }

      protected:
        void performCalculations() const override;

        ext::shared_ptr<CommodityIndex> spreadIndex_;
        ext::shared_ptr<CommodityIndex> payIndex_;
        ext::shared_ptr<CommodityIndex> receiveIndex_;
        bool spreadToPayLeg_;
        CommodityUnitCost basis_;
        Handle<YieldTermStructure> payLegTermStructure_;
        Handle<YieldTermStructure> receiveLegTermStructure_;
        Handle<YieldTermStructure> discountTermStructure_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="105">
    <source>commodities/energycommodity.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/currencies/exchangeratemanager.hpp>
#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>
#include <iomanip>
#include <utility>

namespace QuantLib {

    EnergyDailyPosition::EnergyDailyPosition(const Date& date,
                                             Real payLegPrice,
                                             Real receiveLegPrice,
                                             bool unrealized)
    : date(date), quantityAmount(0), payLegPrice(payLegPrice),
      receiveLegPrice(receiveLegPrice), unrealized(unrealized) {}

    std::ostream& operator<<(std::ostream& out,
                             const EnergyDailyPositions& dailyPositions) {
        out << std::setw(12) << std::left << "positions"
            << std::setw(12) << std::right << "pay"
            << std::setw(12) << std::right << "receive"
            << std::setw(10) << std::right << "qty"
            << std::setw(14) << std::right << "delta"
            << std::setw(10) << std::right << "open" << std::endl;

        for (const auto& i : dailyPositions) {
            const EnergyDailyPosition& dailyPosition = i.second;
            out << std::setw(4) << io::iso_date(i.first) << "  " << std::setw(12) << std::right
                << std::fixed << std::setprecision(6) << dailyPosition.payLegPrice << std::setw(12)
                << std::right << std::fixed << std::setprecision(6) << dailyPosition.receiveLegPrice
                << std::setw(10) << std::right << std::fixed << std::setprecision(2)
                << dailyPosition.quantityAmount << std::setw(14) << std::right << std::fixed
                << std::setprecision(2) << dailyPosition.riskDelta << std::setw(10) << std::right
                << std::fixed << std::setprecision(2)
                << (dailyPosition.unrealized ? dailyPosition.quantityAmount : 0) << std::endl;
        }

        return out;
    }





    void EnergyCommodity::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<EnergyCommodity::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");
        //arguments->legs = legs_;
        //arguments->payer = payer_;
    }

    void EnergyCommodity::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);
        const auto* results = dynamic_cast<const EnergyCommodity::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");
    }

    EnergyCommodity::EnergyCommodity(CommodityType commodityType,
                                     const ext::shared_ptr<SecondaryCosts>& secondaryCosts)
    : Commodity(secondaryCosts), commodityType_(std::move(commodityType)) {}

    const CommodityType& EnergyCommodity::commodityType() const {
        return commodityType_;
    }


    Real EnergyCommodity::calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure) {
        if (toUnitOfMeasure != fromUnitOfMeasure) {
            UnitOfMeasureConversion uomConv =
                UnitOfMeasureConversionManager::instance().lookup(
                           commodityType, fromUnitOfMeasure, toUnitOfMeasure);
            return uomConv.conversionFactor();
        }

        return 1;
    }

    Real EnergyCommodity::calculateFxConversionFactor(
                                                 const Currency& fromCurrency,
                                                 const Currency& toCurrency,
                                                 const Date& evaluationDate) {
        if (fromCurrency != toCurrency) {
            ExchangeRate exchRate = ExchangeRateManager::instance().lookup(
                                   fromCurrency, toCurrency,
                                   evaluationDate /*, ExchangeRate::Direct*/);
            if (fromCurrency == exchRate.target())
                return 1.0 / exchRate.rate();
            return exchRate.rate();
        }
        return 1;
    }

    Real EnergyCommodity::calculateUnitCost(const CommodityType& commodityType,
                                            const CommodityUnitCost& unitCost,
                                            const Date& evaluationDate) const {
        if (unitCost.amount().value() != 0) {
            const Currency& baseCurrency =
                CommoditySettings::instance().currency();
            const UnitOfMeasure baseUnitOfMeasure =
                CommoditySettings::instance().unitOfMeasure();
            Real unitCostUomConversionFactor =
                calculateUomConversionFactor(commodityType,
                                             unitCost.unitOfMeasure(),
                                             baseUnitOfMeasure);
            Real unitCostFxConversionFactor =
                calculateFxConversionFactor(unitCost.amount().currency(),
                                            baseCurrency, evaluationDate);
            return unitCost.amount().value() * unitCostUomConversionFactor
                 * unitCostFxConversionFactor;
        }
        return 0;
    }

    void EnergyCommodity::calculateSecondaryCostAmounts(
                                           const CommodityType& commodityType,
                                           Real totalQuantityValue,
                                           const Date& evaluationDate) const {
        secondaryCostAmounts_.clear();
        if (secondaryCosts_ != nullptr) {
            const Currency& baseCurrency =
                CommoditySettings::instance().currency();
            try {
                for (SecondaryCosts::const_iterator i = secondaryCosts_->begin();
                     i != secondaryCosts_->end(); ++i) {
                    if (boost::any_cast<CommodityUnitCost>(&i->second) != nullptr) {
                        Real value =
                            calculateUnitCost(
                                commodityType,
                                boost::any_cast<CommodityUnitCost>(i->second),
                                evaluationDate) * totalQuantityValue;
                        secondaryCostAmounts_[i->first] =
                            Money(baseCurrency, value);
                    } else if (boost::any_cast<Money>(&i->second) != nullptr) {
                        const Money& amount = boost::any_cast<Money>(i->second);
                        Real fxConversionFactor =
                            calculateFxConversionFactor(amount.currency(),
                                                        baseCurrency,
                                                        evaluationDate);
                        secondaryCostAmounts_[i->first] =
                            Money(baseCurrency,
                                  amount.value() * fxConversionFactor);
                    }
                }
            } catch (const std::exception& e) {
                QL_FAIL("error calculating secondary costs: " << e.what());
            }
        }
    }

}

]]></document_content>
  </document>
  <document index="106">
    <source>commodities/energycommodity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energycommodity.hpp
    \brief Energy commodity
*/

#ifndef quantlib_energy_commodity_hpp
#define quantlib_energy_commodity_hpp

#include <ql/experimental/commodities/commodity.hpp>
#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/commodityunitcost.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/experimental/commodities/quantity.hpp>
#include <ql/time/date.hpp>
#include <ql/money.hpp>

namespace QuantLib {

    struct EnergyDailyPosition {
        Date date;
        Real quantityAmount;
        Real payLegPrice = 0;
        Real receiveLegPrice = 0;
        Real riskDelta;
        bool unrealized = false;

        EnergyDailyPosition() = default;
        EnergyDailyPosition(const Date& date,
                            Real payLegPrice,
                            Real receiveLegPrice,
                            bool unrealized);
    };

    typedef std::map<Date, EnergyDailyPosition> EnergyDailyPositions;

    #ifndef __DOXYGEN__
    std::ostream& operator<<(std::ostream& out,
                             const EnergyDailyPositions& dailyPositions);
    #endif



    //! Energy commodity class
    /*! \ingroup instruments */
    class EnergyCommodity : public Commodity {
      public:
        class arguments;
        class results;
        class engine;

        enum DeliverySchedule { Constant,
                                Window,
                                Hourly,
                                Daily,
                                Weekly,
                                Monthly,
                                Quarterly,
                                Yearly };
        enum QuantityPeriodicity { Absolute,
                                   PerHour,
                                   PerDay,
                                   PerWeek,
                                   PerMonth,
                                   PerQuarter,
                                   PerYear };
        enum PaymentSchedule { WindowSettlement,
                               MonthlySettlement,
                               QuarterlySettlement,
                               YearlySettlement };

        EnergyCommodity(CommodityType commodityType,
                        const ext::shared_ptr<SecondaryCosts>& secondaryCosts);

        virtual Quantity quantity() const = 0;
        const CommodityType& commodityType() const;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        static Real calculateFxConversionFactor(const Currency& fromCurrency,
                                                const Currency& toCurrency,
                                                const Date& evaluationDate);
        static Real calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure);
        Real calculateUnitCost(const CommodityType& commodityType,
                               const CommodityUnitCost& unitCost,
                               const Date& evaluationDate) const;
        void calculateSecondaryCostAmounts(const CommodityType& commodityType,
                                           Real totalQuantityValue,
                                           const Date& evaluationDate) const;

        CommodityType commodityType_;
    };


    class EnergyCommodity::arguments : public virtual PricingEngine::arguments {
      public:
        Currency currency;
        UnitOfMeasure unitOfMeasure;
        void validate() const override {}
    };

    class EnergyCommodity::results : public Instrument::results {
      public:
        Real NPV;
        Currency currency;
        UnitOfMeasure unitOfMeasure;
        void reset() override { Instrument::results::reset(); }
    };

    class EnergyCommodity::engine
        : public GenericEngine<EnergyCommodity::arguments,
                               EnergyCommodity::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="107">
    <source>commodities/energyfuture.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/experimental/commodities/energyfuture.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    EnergyFuture::EnergyFuture(Integer buySell,
                               Quantity quantity,
                               CommodityUnitCost tradePrice,
                               ext::shared_ptr<CommodityIndex> index,
                               const CommodityType& commodityType,
                               const ext::shared_ptr<SecondaryCosts>& secondaryCosts)
    : EnergyCommodity(commodityType, secondaryCosts), buySell_(buySell),
      quantity_(std::move(quantity)), tradePrice_(std::move(tradePrice)), index_(std::move(index)) {
        registerWith(Settings::instance().evaluationDate());
        registerWith(index_);
    }

    bool EnergyFuture::isExpired() const {
        return false;
    }

    void EnergyFuture::performCalculations() const {

        NPV_ = 0.0;
        additionalResults_.clear();

        Date evaluationDate = Settings::instance().evaluationDate();
        const Currency& baseCurrency =
            CommoditySettings::instance().currency();
        const UnitOfMeasure baseUnitOfMeasure =
            CommoditySettings::instance().unitOfMeasure();

        Real quantityUomConversionFactor =
            calculateUomConversionFactor(
                           quantity_.commodityType(),
                           baseUnitOfMeasure,
                           quantity_.unitOfMeasure()) * index_->lotQuantity();
        Real indexUomConversionFactor =
            calculateUomConversionFactor(index_->commodityType(),
                                         index_->unitOfMeasure(),
                                         baseUnitOfMeasure);
        Real tradePriceUomConversionFactor =
            calculateUomConversionFactor(quantity_.commodityType(),
                                         tradePrice_.unitOfMeasure(),
                                         baseUnitOfMeasure);

        Real tradePriceFxConversionFactor =
            calculateFxConversionFactor(tradePrice_.amount().currency(),
                                        baseCurrency, evaluationDate);
        Real indexPriceFxConversionFactor =
            calculateFxConversionFactor(index_->currency(), baseCurrency,
                                        evaluationDate);

        Real quoteValue = 0;

        Date lastQuoteDate = index_->lastQuoteDate();
        if (lastQuoteDate >= evaluationDate - 1) {
            quoteValue = index_->price(evaluationDate);
        } else {
            quoteValue = index_->forwardPrice(evaluationDate);
            std::ostringstream message;
            message << "curve [" << index_->name()
                    << "] has last quote date of "
                    << io::iso_date(lastQuoteDate)
                    << " using forward price from ["
                    << index_->forwardCurve()->name() << "]";
            addPricingError(PricingError::Warning, message.str());
        }

        QL_REQUIRE(quoteValue != Null<Real>(),
                   "missing quote for [" << index_->name() << "]");

        Real tradePriceValue =
            tradePrice_.amount().value() * tradePriceUomConversionFactor
            * tradePriceFxConversionFactor;
        Real quotePriceValue = quoteValue * indexUomConversionFactor
            * indexPriceFxConversionFactor;

        Real quantityAmount = quantity_.amount() * quantityUomConversionFactor;

        Real delta = (((quotePriceValue - tradePriceValue) * quantityAmount)
                      * index_->lotQuantity()) * buySell_;

        NPV_ = delta;

        calculateSecondaryCostAmounts(quantity_.commodityType(),
                                      quantity_.amount(), evaluationDate);
        for (SecondaryCostAmounts::const_iterator i = secondaryCostAmounts_.begin(); i != secondaryCostAmounts_.end(); ++i) {
            Real amount = i->second.value();
            NPV_ -= amount;
        }

        // additionalResults_["brokerCommission"] =
        //     -(brokerCommissionValue * quantityAmount);
    }

}

]]></document_content>
  </document>
  <document index="108">
    <source>commodities/energyfuture.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energyfuture.hpp
    \brief Energy future
*/

#ifndef quantlib_energy_future_hpp
#define quantlib_energy_future_hpp

#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>

namespace QuantLib {

    //! Energy future
    /*! \ingroup instruments */
    class EnergyFuture : public EnergyCommodity {
      public:
        EnergyFuture(Integer buySell,
                     Quantity quantity,
                     CommodityUnitCost tradePrice,
                     ext::shared_ptr<CommodityIndex> index,
                     const CommodityType& commodityType,
                     const ext::shared_ptr<SecondaryCosts>& secondaryCosts);
        bool isExpired() const override;
        //Integer buySell{} const { return buySell_; }
        Quantity quantity() const override { return quantity_; }
        const CommodityUnitCost& tradePrice() const { return tradePrice_; }
        ext::shared_ptr<CommodityIndex> index() const { return index_; }

      protected:
        void performCalculations() const override;
        Integer buySell_;
        Quantity quantity_;
        CommodityUnitCost tradePrice_;
        ext::shared_ptr<CommodityIndex> index_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="109">
    <source>commodities/energyswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    EnergySwap::EnergySwap(Calendar calendar,
                           Currency payCurrency,
                           Currency receiveCurrency,
                           PricingPeriods pricingPeriods,
                           const CommodityType& commodityType,
                           const ext::shared_ptr<SecondaryCosts>& secondaryCosts)
    : EnergyCommodity(commodityType, secondaryCosts), calendar_(std::move(calendar)),
      payCurrency_(std::move(payCurrency)), receiveCurrency_(std::move(receiveCurrency)),
      pricingPeriods_(std::move(pricingPeriods)) {}

    const CommodityType& EnergySwap::commodityType() const {
        QL_REQUIRE(!pricingPeriods_.empty(), "no pricing periods");
        return pricingPeriods_[0]->quantity().commodityType();
    }

    Quantity EnergySwap::quantity() const {
        Real totalQuantityAmount = 0;
        for (const auto& pricingPeriod : pricingPeriods_) {
            totalQuantityAmount += pricingPeriod->quantity().amount();
        }
        return Quantity(pricingPeriods_[0]->quantity().commodityType(),
                        pricingPeriods_[0]->quantity().unitOfMeasure(),
                        totalQuantityAmount);
    }

    bool EnergySwap::isExpired() const {
        return pricingPeriods_.empty()
            || detail::simple_event(pricingPeriods_.back()->paymentDate())
               .hasOccurred();
    }

}

]]></document_content>
  </document>
  <document index="110">
    <source>commodities/energyswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energyswap.hpp
    \brief Energy swap
*/

#ifndef quantlib_energy_swap_hpp
#define quantlib_energy_swap_hpp

#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/pricingperiod.hpp>
#include <ql/experimental/commodities/commoditycashflow.hpp>
#include <ql/time/calendar.hpp>

namespace QuantLib {

    class EnergySwap : public EnergyCommodity {
      public:
        EnergySwap(Calendar calendar,
                   Currency payCurrency,
                   Currency receiveCurrency,
                   PricingPeriods pricingPeriods,
                   const CommodityType& commodityType,
                   const ext::shared_ptr<SecondaryCosts>& secondaryCosts);

        bool isExpired() const override;
        const Calendar& calendar() const { return calendar_; }
        const Currency& payCurrency() const { return payCurrency_; }
        const Currency& receiveCurrency() const { return receiveCurrency_; }
        const PricingPeriods& pricingPeriods() const { return pricingPeriods_; }
        const EnergyDailyPositions& dailyPositions() const {
            return dailyPositions_;
        }
        const CommodityCashFlows& paymentCashFlows() const {
            return paymentCashFlows_;
        }

        const CommodityType& commodityType() const;
        Quantity quantity() const override;

      protected:
        Calendar calendar_;
        Currency payCurrency_;
        Currency receiveCurrency_;
        PricingPeriods pricingPeriods_;
        mutable EnergyDailyPositions dailyPositions_;
        mutable CommodityCashFlows paymentCashFlows_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="111">
    <source>commodities/energyvanillaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/experimental/commodities/energyvanillaswap.hpp>
#include <utility>

namespace QuantLib {

    EnergyVanillaSwap::EnergyVanillaSwap(bool payer,
                                         const Calendar& calendar,
                                         Money fixedPrice,
                                         UnitOfMeasure fixedPriceUnitOfMeasure,
                                         ext::shared_ptr<CommodityIndex> index,
                                         const Currency& payCurrency,
                                         const Currency& receiveCurrency,
                                         const PricingPeriods& pricingPeriods,
                                         const CommodityType& commodityType,
                                         const ext::shared_ptr<SecondaryCosts>& secondaryCosts,
                                         Handle<YieldTermStructure> payLegTermStructure,
                                         Handle<YieldTermStructure> receiveLegTermStructure,
                                         Handle<YieldTermStructure> discountTermStructure)
    : EnergySwap(
          calendar, payCurrency, receiveCurrency, pricingPeriods, commodityType, secondaryCosts),
      payReceive_(payer ? 1 : 0), fixedPrice_(std::move(fixedPrice)),
      fixedPriceUnitOfMeasure_(std::move(fixedPriceUnitOfMeasure)), index_(std::move(index)),
      payLegTermStructure_(std::move(payLegTermStructure)),
      receiveLegTermStructure_(std::move(receiveLegTermStructure)),
      discountTermStructure_(std::move(discountTermStructure)) {

        QL_REQUIRE(!pricingPeriods_.empty(), "no pricing periods");
        registerWith(index_);
    }

    bool EnergyVanillaSwap::isExpired() const {
        return detail::simple_event(pricingPeriods_.back()->endDate())
               .hasOccurred();
    }

    void EnergyVanillaSwap::performCalculations() const {

        try {
            if (index_->empty()) {
                if (index_->forwardCurveEmpty()) {
                    QL_FAIL("index [" << index_->name()
                            << "] does not have any quotes");
                } else {
                    addPricingError(PricingError::Warning,
                                    "index [" + index_->name() +
                                    "] does not have any quotes; "
                                    "using forward prices from ["
                                    + index_->forwardCurve()->name() + "]");
                }
            }

            NPV_ = 0.0;
            additionalResults_.clear();
            dailyPositions_.clear();
            paymentCashFlows_.clear();

            Date evaluationDate = Settings::instance().evaluationDate();

            const Currency& baseCurrency =
                CommoditySettings::instance().currency();
            const UnitOfMeasure baseUnitOfMeasure =
                CommoditySettings::instance().unitOfMeasure();

            Real quantityUomConversionFactor =
                calculateUomConversionFactor(
                               pricingPeriods_[0]->quantity().commodityType(),
                               baseUnitOfMeasure,
                               pricingPeriods_[0]->quantity().unitOfMeasure());
            Real fixedPriceUomConversionFactor =
                calculateUomConversionFactor(
                               pricingPeriods_[0]->quantity().commodityType(),
                               fixedPriceUnitOfMeasure_, baseUnitOfMeasure);
            Real indexUomConversionFactor =
                calculateUomConversionFactor(index_->commodityType(),
                                             index_->unitOfMeasure(),
                                             baseUnitOfMeasure);

            Real fixedPriceFxConversionFactor =
                calculateFxConversionFactor(fixedPrice_.currency(),
                                            baseCurrency, evaluationDate);
            Real indexPriceFxConversionFactor =
                calculateFxConversionFactor(index_->currency(),
                                            baseCurrency, evaluationDate);
            Real payLegFxConversionFactor =
                calculateFxConversionFactor(
                            baseCurrency,
                            payReceive_ > 0 ? payCurrency_ : receiveCurrency_,
                            evaluationDate);
            Real receiveLegFxConversionFactor =
                calculateFxConversionFactor(
                            baseCurrency,
                            payReceive_ > 0 ? receiveCurrency_ : payCurrency_,
                            evaluationDate);

            Date lastQuoteDate = index_->lastQuoteDate();
            if (lastQuoteDate < evaluationDate - 1) {
                std::ostringstream message;
                message << "index [" << index_->name()
                        << "] has last quote date of "
                        << io::iso_date(lastQuoteDate);
                addPricingError(PricingError::Warning, message.str());
            }

            Real totalQuantityAmount = 0;

            // price each period
            for (const auto& pricingPeriod : pricingPeriods_) {
                QL_REQUIRE(pricingPeriod->quantity().amount() != 0, "quantity is zero");

                Integer periodDayCount = 0;

                // get the futures quotes or everything after
                Date periodStartDate =
                    calendar_.adjust(pricingPeriod->startDate());
                for (Date stepDate = periodStartDate;
                     stepDate <= pricingPeriod->endDate();
                     stepDate = calendar_.advance(stepDate, 1*Days)) {

                    bool unrealized = stepDate > evaluationDate;
                    Real quoteValue = 0;

                    if (stepDate <= lastQuoteDate) {
                        quoteValue = index_->price(stepDate);
                    } else {
                        quoteValue = index_->forwardPrice(stepDate);
                    }

                    if (quoteValue == 0) {
                        std::ostringstream message;
                        message << "pay quote value for curve ["
                                << index_->name() << "] is 0 for date "
                                << io::iso_date(stepDate);
                        addPricingError(PricingError::Warning, message.str());
                    }

                    QL_REQUIRE(quoteValue != Null<Real>(),
                               "curve [" << index_->name() <<
                               "] missing value for pricing date: "
                               << stepDate);

                    Real fixedLegPriceValue =
                        fixedPrice_.value() * fixedPriceUomConversionFactor *
                        fixedPriceFxConversionFactor;
                    Real floatingLegPriceValue =
                        quoteValue * indexUomConversionFactor *
                        indexPriceFxConversionFactor;
                    Real payLegPriceValue =
                        payReceive_ > 0 ? fixedLegPriceValue :
                                          floatingLegPriceValue;
                    Real receiveLegPriceValue =
                        payReceive_ > 0 ? floatingLegPriceValue :
                                          fixedLegPriceValue;

                    dailyPositions_[stepDate] =
                        EnergyDailyPosition(stepDate, payLegPriceValue,
                                            receiveLegPriceValue, unrealized);
                    periodDayCount++;
                }

                Real periodQuantityAmount =
                    pricingPeriod->quantity().amount() *
                    quantityUomConversionFactor;
                totalQuantityAmount += periodQuantityAmount;

                Real avgDailyQuantityAmount =
                    periodDayCount == 0 ? 0 :
                                          periodQuantityAmount / periodDayCount;

                Real payLegValue = 0;
                Real receiveLegValue = 0;
                for (auto dpi = dailyPositions_.find(periodStartDate);
                     dpi != dailyPositions_.end() && dpi->first <= pricingPeriod->endDate();
                     ++dpi) {
                    EnergyDailyPosition& dailyPosition = dpi->second;
                    dailyPosition.quantityAmount = avgDailyQuantityAmount;
                    dailyPosition.riskDelta =
                        (-dailyPosition.payLegPrice + dailyPosition.receiveLegPrice) * avgDailyQuantityAmount;
                    payLegValue += -dailyPosition.payLegPrice * avgDailyQuantityAmount;
                    receiveLegValue += dailyPosition.receiveLegPrice * avgDailyQuantityAmount;
                }

                Real discountFactor = 1;
                Real payLegDiscountFactor = 1;
                Real receiveLegDiscountFactor = 1;
                if (pricingPeriod->paymentDate() >= evaluationDate + 2) {
                    discountFactor =
                        discountTermStructure_->discount(
                                                pricingPeriod->paymentDate());
                    payLegDiscountFactor =
                        payLegTermStructure_->discount(
                                                pricingPeriod->paymentDate());
                    receiveLegDiscountFactor =
                        receiveLegTermStructure_->discount(
                                                pricingPeriod->paymentDate());
                }

                Real uDelta = receiveLegValue + payLegValue;
                Real dDelta = (receiveLegValue * receiveLegDiscountFactor) +
                    (payLegValue * payLegDiscountFactor);
                Real pmtFxConversionFactor =
                    ((dDelta * payReceive_) > 0) ? payLegFxConversionFactor :
                                                   receiveLegFxConversionFactor;
                Currency pmtCurrency =
                    ((dDelta * payReceive_) > 0) ? receiveCurrency_ :
                                                   payCurrency_;
                Real pmtDiscountFactor =
                    (dDelta  > 0) ? receiveLegDiscountFactor :
                                    payLegDiscountFactor;

                paymentCashFlows_[pricingPeriod->paymentDate()] =
                    ext::make_shared<CommodityCashFlow>(
                           pricingPeriod->paymentDate(),
                                                 Money(baseCurrency,
                                                       uDelta * discountFactor),
                                                 Money(baseCurrency, uDelta),
                                                 Money(pmtCurrency,
                                                       dDelta * pmtFxConversionFactor),
                                                 Money(pmtCurrency,
                                                       uDelta * pmtFxConversionFactor),
                                                 discountFactor,
                                                 pmtDiscountFactor,
                                                 pricingPeriod->paymentDate() <= evaluationDate);

                calculateSecondaryCostAmounts(
                               pricingPeriods_[0]->quantity().commodityType(),
                               totalQuantityAmount, evaluationDate);

                NPV_ += dDelta;
            }

            QL_REQUIRE(!paymentCashFlows_.empty(), "no cashflows");

            for (SecondaryCostAmounts::const_iterator i =
                     secondaryCostAmounts_.begin();
                 i != secondaryCostAmounts_.end(); ++i) {
                Real amount = i->second.value();
                NPV_ -= amount;
            }

            additionalResults_["dailyPositions"] = dailyPositions_;

        } catch (const QuantLib::Error& e) {
            addPricingError(PricingError::Error, e.what());
            throw;
        } catch (const std::exception& e) {
            addPricingError(PricingError::Error, e.what());
            throw;
        }
    }

}

]]></document_content>
  </document>
  <document index="112">
    <source>commodities/energyvanillaswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energyvanillaswap.hpp
    \brief Vanilla energy swap
*/

#ifndef quantlib_energy_vanilla_swap_hpp
#define quantlib_energy_vanilla_swap_hpp

#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Vanilla energy swap
    class EnergyVanillaSwap : public EnergySwap {
      public:
        EnergyVanillaSwap(bool payer,
                          const Calendar& calendar,
                          Money fixedPrice,
                          UnitOfMeasure fixedPriceUnitOfMeasure,
                          ext::shared_ptr<CommodityIndex> index,
                          const Currency& payCurrency,
                          const Currency& receiveCurrency,
                          const PricingPeriods& pricingPeriods,
                          const CommodityType& commodityType,
                          const ext::shared_ptr<SecondaryCosts>& secondaryCosts,
                          Handle<YieldTermStructure> payLegTermStructure,
                          Handle<YieldTermStructure> receiveLegTermStructure,
                          Handle<YieldTermStructure> discountTermStructure);

        bool isExpired() const override;
        Integer payReceive() const { return payReceive_; }
        const Money& fixedPrice() const { return fixedPrice_; }
        const UnitOfMeasure& fixedPriceUnitOfMeasure() const {
            return fixedPriceUnitOfMeasure_;
        }
        const ext::shared_ptr<CommodityIndex>& index() const {
            return index_;
        }

      protected:
        void performCalculations() const override;

        Integer payReceive_;
        Money fixedPrice_;
        UnitOfMeasure fixedPriceUnitOfMeasure_;
        ext::shared_ptr<CommodityIndex> index_;
        Handle<YieldTermStructure> payLegTermStructure_;
        Handle<YieldTermStructure> receiveLegTermStructure_;
        Handle<YieldTermStructure> discountTermStructure_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="113">
    <source>commodities/exchangecontract.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exchangecontract.hpp
    \brief Exchange contract
*/

#ifndef quantlib_exchange_contract_hpp
#define quantlib_exchange_contract_hpp

#include <ql/time/date.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    class ExchangeContract {
      public:
        ExchangeContract() = default;
        ExchangeContract(std::string code,
                         Date expirationDate,
                         Date underlyingStartDate,
                         Date underlyingEndDate);

        const std::string& code() const;
        const Date& expirationDate() const;
        const Date& underlyingStartDate() const;
        const Date& underlyingEndDate() const;
      protected:
        std::string code_;
        Date expirationDate_;
        Date underlyingStartDate_;
        Date underlyingEndDate_;
    };

    inline ExchangeContract::ExchangeContract(std::string code,
                                              Date expirationDate,
                                              Date underlyingStartDate,
                                              Date underlyingEndDate)
    : code_(std::move(code)), expirationDate_(expirationDate),
      underlyingStartDate_(underlyingStartDate), underlyingEndDate_(underlyingEndDate) {}

    inline const std::string& ExchangeContract::code() const {
        return code_;
    }

    inline const Date& ExchangeContract::expirationDate() const {
        return expirationDate_;
    }

    inline const Date& ExchangeContract::underlyingStartDate() const {
        return underlyingStartDate_;
    }

    inline const Date& ExchangeContract::underlyingEndDate() const {
        return underlyingEndDate_;
    }

    typedef std::map<Date, ExchangeContract> ExchangeContracts;

}

#endif
]]></document_content>
  </document>
  <document index="114">
    <source>commodities/paymentterm.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/paymentterm.hpp>

namespace QuantLib {

    std::map<std::string, ext::shared_ptr<PaymentTerm::Data> >
    PaymentTerm::paymentTerms_;

    PaymentTerm::PaymentTerm(const std::string& name,
                             PaymentTerm::EventType eventType,
                             Integer offsetDays,
                             const Calendar& calendar) {
        std::map<std::string, ext::shared_ptr<PaymentTerm::Data> >::const_iterator i = paymentTerms_.find(name);
        if (i != paymentTerms_.end())
            data_ = i->second;
        else {
            data_ = ext::make_shared<PaymentTerm::Data>(
                                 name, eventType,
                                                       offsetDays, calendar);
            paymentTerms_[name] = data_;
        }
    }

    std::ostream& operator<<(std::ostream& out, const PaymentTerm& c) {
        if (!c.empty())
            return out << c.name();
        else
            return out << "null payment term type";
    }

}

]]></document_content>
  </document>
  <document index="115">
    <source>commodities/paymentterm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditypricinghelpers.hpp
    \brief Commodity pricing helpers
*/

#ifndef quantlib_payment_term_hpp
#define quantlib_payment_term_hpp

#include <ql/time/calendar.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    class PaymentTerm {
      public:
        enum EventType { TradeDate, PricingDate };

        PaymentTerm() = default;
        PaymentTerm(const std::string& name,
                    EventType eventType,
                    Integer offsetDays,
                    const Calendar& calendar);
        //! \name Inspectors
        //@{
        //! name, e.g, "Pricing end + 5 days"
        const std::string& name() const;
        EventType eventType() const;
        Integer offsetDays() const;
        const Calendar& calendar() const;

        bool empty() const;
        //@}
        Date getPaymentDate(const Date& date) const;
      protected:
        struct Data;
        ext::shared_ptr<Data> data_;

        struct Data {
            std::string name;
            EventType eventType;
            Integer offsetDays;
            Calendar calendar;

            Data(std::string name, EventType eventType, Integer offsetDays, Calendar calendar);
        };

        static std::map<std::string, ext::shared_ptr<Data> > paymentTerms_;
    };

    /*! \relates PaymentTerm */
    bool operator==(const PaymentTerm&,
                    const PaymentTerm&);

    /*! \relates PaymentTerm */
    bool operator!=(const PaymentTerm&,
                    const PaymentTerm&);

    /*! \relates PaymentTerm */
    std::ostream& operator<<(std::ostream&,
                             const PaymentTerm&);


    inline PaymentTerm::Data::Data(std::string name,
                                   PaymentTerm::EventType eventType,
                                   Integer offsetDays,
                                   Calendar calendar)
    : name(std::move(name)), eventType(eventType), offsetDays(offsetDays),
      calendar(std::move(calendar)) {}

    inline const std::string& PaymentTerm::name() const {
        return data_->name;
    }

    inline PaymentTerm::EventType PaymentTerm::eventType() const {
        return data_->eventType;
    }

    inline Integer PaymentTerm::offsetDays() const {
        return data_->offsetDays;
    }
 
    inline const Calendar& PaymentTerm::calendar() const {
        return data_->calendar;
    }

    inline Date PaymentTerm::getPaymentDate(const Date& date) const {
        return data_->calendar.adjust(date + data_->offsetDays);
    }

    inline bool PaymentTerm::empty() const {
        return !data_;
    }

    inline bool operator==(const PaymentTerm& c1, const PaymentTerm& c2) {
        return c1.name() == c2.name();
    }

    inline bool operator!=(const PaymentTerm& c1, const PaymentTerm& c2) {
        return !(c1 == c2);
    }

}


#endif
]]></document_content>
  </document>
  <document index="116">
    <source>commodities/petroleumunitsofmeasure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file petroleumunitsofmeasure.hpp
    \brief Petroleum units of measure
*/

#ifndef quantlib_petroleum_units_of_measure_hpp
#define quantlib_petroleum_units_of_measure_hpp

#include <ql/experimental/commodities/unitofmeasure.hpp>

namespace QuantLib {

    class BarrelUnitOfMeasure : public UnitOfMeasure {
      public:
        BarrelUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                           new Data("Barrels", "BBL", UnitOfMeasure::Volume));
            data_ = data;
        }
    };

    class MTUnitOfMeasure : public UnitOfMeasure {
      public:
        MTUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                        new Data("Metric Tonnes", "MT", UnitOfMeasure::Mass));
            data_ = data;
        }
    };

    class MBUnitOfMeasure : public UnitOfMeasure {
      public:
        MBUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                         new Data("1000 Barrels", "MB", UnitOfMeasure::Volume,
                                  BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class GallonUnitOfMeasure : public UnitOfMeasure {
      public:
        GallonUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                          new Data("US Gallons", "GAL", UnitOfMeasure::Volume,
                                   BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class LitreUnitOfMeasure : public UnitOfMeasure {
      public:
        LitreUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                                new Data("Litres", "l", UnitOfMeasure::Volume,
                                         BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class KilolitreUnitOfMeasure : public UnitOfMeasure {
      public:
        KilolitreUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                           new Data("Kilolitres", "kl", UnitOfMeasure::Volume,
                                    BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class TokyoKilolitreUnitOfMeasure : public UnitOfMeasure {
      public:
        TokyoKilolitreUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                new Data("Tokyo Kilolitres", "KL_tk", UnitOfMeasure::Volume,
                         BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

}


#endif
]]></document_content>
  </document>
  <document index="117">
    <source>commodities/pricingperiod.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pricingperiod.hpp
    \brief Pricing period
*/

#ifndef quantlib_pricing_period_hpp
#define quantlib_pricing_period_hpp

#include <ql/experimental/commodities/dateinterval.hpp>
#include <ql/experimental/commodities/quantity.hpp>
#include <utility>
#include <vector>

namespace QuantLib {

    //! Time pricingperiod described by a number of a given time unit
    /*! \ingroup datetime */
    class PricingPeriod : public DateInterval {
      public:
        PricingPeriod(const Date& startDate,
                      const Date& endDate,
                      const Date& paymentDate,
                      Quantity quantity)
        : DateInterval(startDate, endDate), paymentDate_(paymentDate),
          quantity_(std::move(quantity)) {}
        const Date& paymentDate() const { return paymentDate_; }
        const Quantity& quantity() const { return quantity_; }
      private:
        Date paymentDate_;
        Quantity quantity_;
    };

    typedef std::vector<ext::shared_ptr<PricingPeriod> > PricingPeriods;
}

#endif
]]></document_content>
  </document>
  <document index="118">
    <source>commodities/quantity.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/quantity.hpp>
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>
#include <ql/math/comparison.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Quantity::ConversionType Quantity::conversionType = Quantity::NoConversion;

    UnitOfMeasure Quantity::baseUnitOfMeasure = UnitOfMeasure();

    namespace {

        void convertTo(Quantity& m, const UnitOfMeasure& target) {
            if (m.unitOfMeasure() != target) {
                UnitOfMeasureConversion rate =
                    UnitOfMeasureConversionManager::instance().lookup(
                                m.commodityType(), m.unitOfMeasure(), target);
                m = rate.convert(m).rounded();
            }
        }

        void convertToBase(Quantity& m) {
            QL_REQUIRE(!Quantity::baseUnitOfMeasure.empty(),
                       "no base unitOfMeasure set");
            convertTo(m, Quantity::baseUnitOfMeasure);
        }

    }

    Quantity& Quantity::operator+=(const Quantity& m) {
        if (unitOfMeasure_ == m.unitOfMeasure_) {
            amount_ += m.amount_;
        } else if (conversionType == BaseUnitOfMeasureConversion) {
            convertToBase(*this);
            Quantity tmp = m;
            convertToBase(tmp);
            *this += tmp;
        } else if (conversionType == AutomatedConversion) {
            Quantity tmp = m;
            convertTo(tmp, unitOfMeasure_);
            *this += tmp;
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
        return *this;
    }

    Quantity& Quantity::operator-=(const Quantity& m) {
        if (unitOfMeasure_ == m.unitOfMeasure_) {
            amount_ -= m.amount_;
        } else if (conversionType == BaseUnitOfMeasureConversion) {
            convertToBase(*this);
            Quantity tmp = m;
            convertToBase(tmp);
            *this -= tmp;
        } else if (conversionType == AutomatedConversion) {
            Quantity tmp = m;
            convertTo(tmp, unitOfMeasure_);
            *this -= tmp;
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
        return *this;
    }

    Real operator/(const Quantity& m1, const Quantity& m2) {
        if (m1.unitOfMeasure() == m2.unitOfMeasure()) {
            return m1.amount()/m2.amount();
        } else if (Quantity::conversionType
                   == Quantity::BaseUnitOfMeasureConversion) {
            Quantity tmp1 = m1;
            convertToBase(tmp1);
            Quantity tmp2 = m2;
            convertToBase(tmp2);
            return tmp1/tmp2;
        } else if (Quantity::conversionType == Quantity::AutomatedConversion) {
            Quantity tmp = m2;
            convertTo(tmp, m1.unitOfMeasure());
            return m1/tmp;
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
    }

    bool operator==(const Quantity& m1, const Quantity& m2) {
        if (m1.unitOfMeasure() == m2.unitOfMeasure()) {
            return m1.amount() == m2.amount();
        } else if (Quantity::conversionType
                   == Quantity::BaseUnitOfMeasureConversion) {
            Quantity tmp1 = m1;
            convertToBase(tmp1);
            Quantity tmp2 = m2;
            convertToBase(tmp2);
            return tmp1 == tmp2;
        } else if (Quantity::conversionType
                   == Quantity::AutomatedConversion) {
            Quantity tmp = m2;
            convertTo(tmp, m1.unitOfMeasure());
            return m1 == tmp;
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
    }

    bool operator<(const Quantity& m1, const Quantity& m2) {
        if (m1.unitOfMeasure() == m2.unitOfMeasure()) {
            return m1.amount() < m2.amount();
        } else if (Quantity::conversionType
                   == Quantity::BaseUnitOfMeasureConversion) {
            Quantity tmp1 = m1;
            convertToBase(tmp1);
            Quantity tmp2 = m2;
            convertToBase(tmp2);
            return tmp1 < tmp2;
        } else if (Quantity::conversionType == Quantity::AutomatedConversion) {
            Quantity tmp = m2;
            convertTo(tmp, m1.unitOfMeasure());
            return m1 < tmp;
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
    }

    bool operator<=(const Quantity& m1, const Quantity& m2) {
        if (m1.unitOfMeasure() == m2.unitOfMeasure()) {
            return m1.amount() <= m2.amount();
        } else if (Quantity::conversionType
                   == Quantity::BaseUnitOfMeasureConversion) {
            Quantity tmp1 = m1;
            convertToBase(tmp1);
            Quantity tmp2 = m2;
            convertToBase(tmp2);
            return tmp1 <= tmp2;
        } else if (Quantity::conversionType == Quantity::AutomatedConversion) {
            Quantity tmp = m2;
            convertTo(tmp, m1.unitOfMeasure());
            return m1 <= tmp;
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
    }

    bool close(const Quantity& m1, const Quantity& m2, Size n) {
        if (m1.unitOfMeasure() == m2.unitOfMeasure()) {
            return close(m1.amount(),m2.amount(),n);
        } else if (Quantity::conversionType
                   == Quantity::BaseUnitOfMeasureConversion) {
            Quantity tmp1 = m1;
            convertToBase(tmp1);
            Quantity tmp2 = m2;
            convertToBase(tmp2);
            return close(tmp1,tmp2,n);
        } else if (Quantity::conversionType == Quantity::AutomatedConversion) {
            Quantity tmp = m2;
            convertTo(tmp, m1.unitOfMeasure());
            return close(m1,tmp,n);
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
    }

    bool close_enough(const Quantity& m1, const Quantity& m2, Size n) {
        if (m1.unitOfMeasure() == m2.unitOfMeasure()) {
            return close_enough(m1.amount(),m2.amount(),n);
        } else if (Quantity::conversionType
                   == Quantity::BaseUnitOfMeasureConversion) {
            Quantity tmp1 = m1;
            convertToBase(tmp1);
            Quantity tmp2 = m2;
            convertToBase(tmp2);
            return close_enough(tmp1,tmp2,n);
        } else if (Quantity::conversionType == Quantity::AutomatedConversion) {
            Quantity tmp = m2;
            convertTo(tmp, m1.unitOfMeasure());
            return close_enough(m1,tmp,n);
        } else {
            QL_FAIL("unitOfMeasure mismatch and no conversion specified");
        }
    }


    std::ostream& operator<<(std::ostream& out, const Quantity& quantity) {
        return out << quantity.commodityType_.code() << " "
                   << quantity.amount_ << " " << quantity.unitOfMeasure_.code();
    }

}

]]></document_content>
  </document>
  <document index="119">
    <source>commodities/quantity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantity.hpp
    \brief Amount of a commodity
*/

#ifndef quantlib_quantity_hpp
#define quantlib_quantity_hpp

#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <utility>

namespace QuantLib {

    //! Amount of a commodity
    class Quantity {
      public:
        //! \name Constructors
        //@{
        Quantity() = default;
        Quantity(CommodityType commodityType, UnitOfMeasure unitOfMeasure, Real amount);
        //@}
        //! \name Inspectors
        //@{
        const CommodityType& commodityType() const;
        const UnitOfMeasure& unitOfMeasure() const;
        Real amount() const;
        Quantity rounded() const;
        //@}
        /*! \name Quantity arithmetics

            See below for non-member functions and for settings which
            determine the behavior of the operators.
        */
        //@{
        Quantity operator+() const;
        Quantity operator-() const;
        Quantity& operator+=(const Quantity&);
        Quantity& operator-=(const Quantity&);
        Quantity& operator*=(Real);
        Quantity& operator/=(Real);
        //@}
        /*! \name Conversion settings

            These parameters are used for combining quantity amounts
            in different currencies
        */
        //@{
        enum ConversionType {
            NoConversion,                /*!< do not perform conversions */
            BaseUnitOfMeasureConversion, /*!< convert both operands to
                                              the base unitOfMeasure before
                                              converting */
            AutomatedConversion          /*!< return the result in the
                                              unitOfMeasure of the first
                                              operand */
        };
        static ConversionType conversionType;
        static UnitOfMeasure baseUnitOfMeasure;
        //@}

        friend std::ostream& operator<<(std::ostream&, const Quantity&);
      private:
        CommodityType commodityType_;
        UnitOfMeasure unitOfMeasure_;
        Real amount_ = 0.0;
    };


    // More arithmetics and comparisons

    /*! \relates Quantity */
    Quantity operator+(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    Quantity operator-(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    Quantity operator*(const Quantity&, Real);
    /*! \relates Quantity */
    Quantity operator*(Real, const Quantity&);
    /*! \relates Quantity */
    Quantity operator/(const Quantity&, Real);
    /*! \relates Quantity */
    Real operator/(const Quantity&, const Quantity&);

    /*! \relates Quantity */
    bool operator==(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator!=(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator<(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator<=(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator>(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator>=(const Quantity&, const Quantity&);

    /*! \relates Quantity */
    bool close(const Quantity&, const Quantity&, Size n = 42);
    /*! \relates Quantity */
    bool close_enough(const Quantity&, const Quantity&, Size n = 42);


    // inline definitions

    inline Quantity::Quantity(CommodityType commodityType, UnitOfMeasure unitOfMeasure, Real amount)
    : commodityType_(std::move(commodityType)), unitOfMeasure_(std::move(unitOfMeasure)),
      amount_(amount) {}

    inline const CommodityType& Quantity::commodityType() const {
        return commodityType_;
    }

    inline const UnitOfMeasure& Quantity::unitOfMeasure() const {
        return unitOfMeasure_;
    }

    inline Real Quantity::amount() const {
        return amount_;
    }

    inline Quantity Quantity::rounded() const {
        return Quantity(commodityType_,
                        unitOfMeasure_,
                        unitOfMeasure_.rounding()(amount_));
    }

    inline Quantity Quantity::operator+() const {
        return *this;
    }

    inline Quantity Quantity::operator-() const {
        return Quantity(commodityType_, unitOfMeasure_, -amount_);
    }

    inline Quantity& Quantity::operator*=(Real x) {
        amount_ *= x;
        return *this;
    }

    inline Quantity& Quantity::operator/=(Real x) {
        amount_ /= x;
        return *this;
    }


    inline Quantity operator+(const Quantity& m1, const Quantity& m2) {
        Quantity tmp = m1;
        tmp += m2;
        return tmp;
    }

    inline Quantity operator-(const Quantity& m1, const Quantity& m2) {
        Quantity tmp = m1;
        tmp -= m2;
        return tmp;
    }

    inline Quantity operator*(const Quantity& m, Real x) {
        Quantity tmp = m;
        tmp *= x;
        return tmp;
    }

    inline Quantity operator*(Real x, const Quantity& m) {
        return m*x;
    }

    inline Quantity operator/(const Quantity& m, Real x) {
        Quantity tmp = m;
        tmp /= x;
        return tmp;
    }

    inline bool operator!=(const Quantity& m1, const Quantity& m2) {
        return !(m1 == m2);
    }

    inline bool operator>(const Quantity& m1, const Quantity& m2) {
        return m2 < m1;
    }

    inline bool operator>=(const Quantity& m1, const Quantity& m2) {
        return m2 <= m1;
    }

}


#endif
]]></document_content>
  </document>
  <document index="120">
    <source>commodities/unitofmeasure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ostream>
#include <utility>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, const UnitOfMeasure& c) {
        if (!c.empty())
            return out << c.code();
        else
            return out << "null unit of measure";
    }

    std::map<std::string,
             ext::shared_ptr<UnitOfMeasure::Data> >
    UnitOfMeasure::unitsOfMeasure_;

    UnitOfMeasure::UnitOfMeasure(const std::string& name,
                                 const std::string& code,
                                 UnitOfMeasure::Type unitType) {
        std::map<std::string,
            ext::shared_ptr<UnitOfMeasure::Data> >::const_iterator i =
            unitsOfMeasure_.find(name);
        if (i != unitsOfMeasure_.end()) {
            data_ = i->second;
        } else {
            data_ = ext::make_shared<UnitOfMeasure::Data>(
                               name, code, unitType);
            unitsOfMeasure_[name] = data_;
        }
    }

    UnitOfMeasure::Data::Data(std::string name,
                              std::string code,
                              UnitOfMeasure::Type unitType,
                              UnitOfMeasure triangulationUnitOfMeasure,
                              const Rounding& rounding)
    : name(std::move(name)), code(std::move(code)), unitType(unitType),
      triangulationUnitOfMeasure(std::move(triangulationUnitOfMeasure)), rounding(rounding) {}
}

]]></document_content>
  </document>
  <document index="121">
    <source>commodities/unitofmeasure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file unitofmeasure.hpp
    \brief Unit of measure
*/

#ifndef quantlib_unit_of_measure_hpp
#define quantlib_unit_of_measure_hpp

#include <ql/types.hpp>
#include <ql/math/rounding.hpp>
#include <ql/shared_ptr.hpp>
#include <string>
#include <map>
#include <iosfwd>

namespace QuantLib {

    //! %Unit of measure specification
    class UnitOfMeasure {
      public:
        enum Type { Mass, Volume, Energy, Quantity };
        //! default constructor
        /*! Instances built via this constructor have undefined
            behavior. Such instances can only act as placeholders
            and must be reassigned to a valid currency before being
            used.
        */
        UnitOfMeasure() = default;
        UnitOfMeasure(const std::string& name,
                      const std::string& code,
                      Type unitType);
        //! \name Inspectors
        //@{
        //! name, e.g, "Barrels"
        const std::string& name() const;
        //! code, e.g, "BBL", "MT"
        const std::string& code() const;
        //! unit type (mass, volume...)
        Type unitType() const;
        //@}
        //! \name Other information
        //@{
        //! is this a usable instance?
        bool empty() const;
        // rounding
        const Rounding& rounding() const;
        //! unit used for triangulation when required
        const UnitOfMeasure& triangulationUnitOfMeasure() const;
        //@}
      protected:
        struct Data;
        ext::shared_ptr<Data> data_;
      private:
        static std::map<std::string, ext::shared_ptr<UnitOfMeasure::Data> >
        unitsOfMeasure_;
    };

    struct UnitOfMeasure::Data {
        std::string name, code;
        UnitOfMeasure::Type unitType;
        UnitOfMeasure triangulationUnitOfMeasure;
        Rounding rounding;

        Data(std::string name,
             std::string code,
             UnitOfMeasure::Type unitType,
             UnitOfMeasure triangulationUnitOfMeasure = UnitOfMeasure(),
             const Rounding& rounding = Rounding(0));
    };


    /*! \relates UnitOfMeasure */
    bool operator==(const UnitOfMeasure&,
                    const UnitOfMeasure&);

    /*! \relates UnitOfMeasure */
    bool operator!=(const UnitOfMeasure&,
                    const UnitOfMeasure&);

    /*! \relates UnitOfMeasure */
    std::ostream& operator<<(std::ostream&,
                             const UnitOfMeasure&);


    // inline definitions

    inline const std::string& UnitOfMeasure::name() const {
        return data_->name;
    }

    inline const std::string& UnitOfMeasure::code() const {
        return data_->code;
    }

    inline UnitOfMeasure::Type UnitOfMeasure::unitType() const {
        return data_->unitType;
    }

    inline const Rounding& UnitOfMeasure::rounding() const {
        return data_->rounding;
    }

    inline bool UnitOfMeasure::empty() const {
        return !data_;
    }

    inline const UnitOfMeasure&
    UnitOfMeasure::triangulationUnitOfMeasure() const {
        return data_->triangulationUnitOfMeasure;
    }

    inline bool operator==(const UnitOfMeasure& c1, const UnitOfMeasure& c2) {
        return c1.code() == c2.code();
    }

    inline bool operator!=(const UnitOfMeasure& c1, const UnitOfMeasure& c2) {
        return !(c1 == c2);
    }

    class LotUnitOfMeasure : public UnitOfMeasure {
      public:
        LotUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                new Data("Lot", "Lot", UnitOfMeasure::Quantity));
            data_ = data;
        }
    };

}


#endif
]]></document_content>
  </document>
  <document index="122">
    <source>commodities/unitofmeasureconversion.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/unitofmeasureconversion.hpp>
#include <ql/errors.hpp>

using std::string;

namespace QuantLib {

    UnitOfMeasureConversion::UnitOfMeasureConversion(
                                           const CommodityType& commodityType,
                                           const UnitOfMeasure& source,
                                           const UnitOfMeasure& target,
                                           Real conversionFactor) {
        data_ = ext::make_shared<UnitOfMeasureConversion::Data>(
              commodityType, source, target,
                                                conversionFactor, Direct);
    }

    UnitOfMeasureConversion::UnitOfMeasureConversion(
                                            const UnitOfMeasureConversion& r1,
                                            const UnitOfMeasureConversion& r2) {
        data_ = ext::make_shared<UnitOfMeasureConversion::Data>(
                                   r1, r2);
    }

    UnitOfMeasureConversion::Data::Data(const CommodityType& commodityType,
                                        const UnitOfMeasure& source,
                                        const UnitOfMeasure& target,
                                        Real conversionFactor, Type type)
    : commodityType(commodityType), source(source), target(target),
      conversionFactor(conversionFactor), type(type) {
        code = commodityType.name() + source.code() + target.code();
    }

    UnitOfMeasureConversion::Data::Data(const UnitOfMeasureConversion& r1,
                                        const UnitOfMeasureConversion& r2) {
        conversionFactorChain = std::make_pair(
            ext::make_shared<UnitOfMeasureConversion>(r1),
            ext::make_shared<UnitOfMeasureConversion>(r2));
    }

    Quantity UnitOfMeasureConversion::convert(const Quantity& quantity) const {
        switch (data_->type) {
          case Direct:
            if (quantity.unitOfMeasure() == data_->source)
                return Quantity(quantity.commodityType(),
                                data_->target,
                                quantity.amount()*data_->conversionFactor);
            else if (quantity.unitOfMeasure() == data_->target)
                return Quantity(quantity.commodityType(),
                                data_->source,
                                quantity.amount()/data_->conversionFactor);
            else
                QL_FAIL("direct conversion not applicable");
          case Derived:
            if (quantity.unitOfMeasure()
                == data_->conversionFactorChain.first->source() ||
                quantity.unitOfMeasure()
                == data_->conversionFactorChain.first->target())
                return data_->conversionFactorChain.second->convert(
                       data_->conversionFactorChain.first->convert(quantity));
            else if (quantity.unitOfMeasure()
                     == data_->conversionFactorChain.second->source() ||
                     quantity.unitOfMeasure()
                     == data_->conversionFactorChain.second->target())
                return data_->conversionFactorChain.first->convert(
                      data_->conversionFactorChain.second->convert(quantity));
            else
                QL_FAIL("derived conversion factor not applicable");
          default:
            QL_FAIL("unknown conversion-factor type");
        }
    }

    UnitOfMeasureConversion UnitOfMeasureConversion::chain(
                                            const UnitOfMeasureConversion& r1,
                                            const UnitOfMeasureConversion& r2) {
        UnitOfMeasureConversion result(r1, r2);
        result.data_->type = Derived;
        if (r1.data_->source == r2.data_->source) {
            result.data_->source = r1.data_->target;
            result.data_->target = r2.data_->target;
            result.data_->conversionFactor =
                r2.data_->conversionFactor/r1.data_->conversionFactor;
        } else if (r1.data_->source == r2.data_->target) {
            result.data_->source = r1.data_->target;
            result.data_->target = r2.data_->source;
            result.data_->conversionFactor =
                1.0/(r1.data_->conversionFactor*r2.data_->conversionFactor);
        } else if (r1.data_->target == r2.data_->source) {
            result.data_->source = r1.data_->source;
            result.data_->target = r2.data_->target;
            result.data_->conversionFactor =
                r1.data_->conversionFactor*r2.data_->conversionFactor;
        } else if (r1.data_->target == r2.data_->target) {
            result.data_->source = r1.data_->source;
            result.data_->target = r2.data_->source;
            result.data_->conversionFactor =
                r1.data_->conversionFactor/r2.data_->conversionFactor;
        } else {
            QL_FAIL("conversion factors not chainable");
        }
        return result;
    }

}
]]></document_content>
  </document>
  <document index="123">
    <source>commodities/unitofmeasureconversion.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energycommodity.hpp
    \brief Energy commodity
*/

#ifndef quantlib_unit_of_measure_conversion_hpp
#define quantlib_unit_of_measure_conversion_hpp

#include <ql/experimental/commodities/quantity.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/utilities/null.hpp>
#include <utility>

namespace QuantLib {

    class UnitOfMeasureConversion {
      public:
        enum Type { Direct,  /*!< given directly by the user */
                    Derived  /*!< derived from conversion factors
                                  between other uoms */
        };
        //! \name Constructors
        //@{
        UnitOfMeasureConversion() = default;
        /*! the conversionFactor \f$ r \f$ is given with the
            convention that a unit of the source is worth \f$ r \f$
            units of the target.
        */
        UnitOfMeasureConversion(const CommodityType& commodityType,
                                const UnitOfMeasure& source,
                                const UnitOfMeasure& target,
                                Real conversionFactor);
        //@}

        //! \name Inspectors
        //@{
        //! the source UOM.
        const UnitOfMeasure& source() const;
        //! the target UOM.
        const UnitOfMeasure& target() const;
        //! the commodity type.
        const CommodityType& commodityType() const;
        //! the type
        Type type() const;
        //! the conversion factor
        Real conversionFactor() const;

        const std::string& code() const;
        //@}

        //! \name Utility methods
        //@{
        //! apply the conversion factor to a cash amount
        Quantity convert(const Quantity& quantity) const;
        //! chain two conversion factors
        static UnitOfMeasureConversion chain(const UnitOfMeasureConversion& r1,
                                             const UnitOfMeasureConversion& r2);
        //@}
      protected:
        UnitOfMeasureConversion(const UnitOfMeasureConversion& r1,
                                const UnitOfMeasureConversion& r2);

        struct Data;
        ext::shared_ptr<Data> data_;

        struct Data {
            CommodityType commodityType;
            UnitOfMeasure source, target;
            Real conversionFactor;
            Type type;
            std::string code;
            std::pair<ext::shared_ptr<UnitOfMeasureConversion>,
                      ext::shared_ptr<UnitOfMeasureConversion> >
            conversionFactorChain;

            Data(const CommodityType& commodityType,
                 const UnitOfMeasure& source,
                 const UnitOfMeasure& target,
                 Real conversionFactor,
                 Type type);

            Data(const UnitOfMeasureConversion& r1,
                 const UnitOfMeasureConversion& r2);
        };
    };

    // inline definitions

    inline const CommodityType& UnitOfMeasureConversion::commodityType() const {
        return data_->commodityType;
    }

    inline const UnitOfMeasure& UnitOfMeasureConversion::source() const {
        return data_->source;
    }

    inline const UnitOfMeasure& UnitOfMeasureConversion::target() const {
        return data_->target;
    }

    inline Real UnitOfMeasureConversion::conversionFactor() const {
        return data_->conversionFactor;
    }

    inline UnitOfMeasureConversion::Type UnitOfMeasureConversion::type() const {
        return data_->type;
    }

    inline const std::string& UnitOfMeasureConversion::code() const {
        return data_->code;
    }

}

#endif
]]></document_content>
  </document>
  <document index="124">
    <source>commodities/unitofmeasureconversionmanager.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>
#include <ql/experimental/commodities/petroleumunitsofmeasure.hpp>
#include <ql/errors.hpp>
#include <algorithm>

using namespace std;

namespace QuantLib {

    namespace {

        bool matches(const UnitOfMeasureConversion& c1,
                     const UnitOfMeasureConversion& c2) {
            return c1.commodityType() == c2.commodityType() &&
                ((c1.source() == c2.source() && c1.target() == c2.target())
                 || (c1.source() == c2.target() && c1.target() == c2.source()));
        }

        bool matches(const UnitOfMeasureConversion& c,
                     const CommodityType& commodityType,
                     const UnitOfMeasure& source,
                     const UnitOfMeasure& target) {
            return c.commodityType() == commodityType &&
                ((c.source() == source && c.target() == target)
                 || (c.source() == target && c.target() == source));
        }

        bool matches(const UnitOfMeasureConversion& c,
                     const CommodityType& commodityType,
                     const UnitOfMeasure& source) {
            return c.commodityType() == commodityType &&
                (c.source() == source || c.target() == source);
        }

    }

    UnitOfMeasureConversionManager::UnitOfMeasureConversionManager() {
        addKnownConversionFactors();
    }

    void UnitOfMeasureConversionManager::add(const UnitOfMeasureConversion& c) {
        // not fast, but hopefully we won't have a lot of entries.
        for (auto i = data_.begin(); i != data_.end(); ++i) {
            if (matches(*i, c)) {
                data_.erase(i);
                break;
            }
        }

        data_.push_back(c);
    }

    UnitOfMeasureConversion UnitOfMeasureConversionManager::lookup(
                                   const CommodityType& commodityType,
                                   const UnitOfMeasure& source,
                                   const UnitOfMeasure& target,
                                   UnitOfMeasureConversion::Type type) const {
        if (type == UnitOfMeasureConversion::Direct) {
            return directLookup(commodityType,source,target);
        } else if (!source.triangulationUnitOfMeasure().empty()) {
            const UnitOfMeasure& link = source.triangulationUnitOfMeasure();
            if (link == target)
                return directLookup(commodityType,source,link);
            else
                return UnitOfMeasureConversion::chain(
                                      directLookup(commodityType,source,link),
                                      lookup(commodityType,link,target));
        } else if (!target.triangulationUnitOfMeasure().empty()) {
            const UnitOfMeasure& link = target.triangulationUnitOfMeasure();
            if (source == link)
                return directLookup(commodityType,link,target);
            else
                return UnitOfMeasureConversion::chain(
                                     lookup(commodityType,source,link),
                                     directLookup(commodityType,link,target));
        } else {
            return smartLookup(commodityType,source,target);
        }
    }

    void UnitOfMeasureConversionManager::clear() {
        data_.clear();
        addKnownConversionFactors();
    }

    void UnitOfMeasureConversionManager::addKnownConversionFactors() {
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    MBUnitOfMeasure(),
                                    BarrelUnitOfMeasure(),
                                    1000));
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    BarrelUnitOfMeasure(),
                                    GallonUnitOfMeasure(),
                                    42));
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    GallonUnitOfMeasure(),
                                    MBUnitOfMeasure(),
                                    1000 * 42));
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    LitreUnitOfMeasure(),
                                    GallonUnitOfMeasure(),
                                    3.78541));
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    BarrelUnitOfMeasure(),
                                    LitreUnitOfMeasure(),
                                    158.987));
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    KilolitreUnitOfMeasure(),
                                    BarrelUnitOfMeasure(),
                                    6.28981));
        add(UnitOfMeasureConversion(NullCommodityType(),
                                    TokyoKilolitreUnitOfMeasure(),
                                    BarrelUnitOfMeasure(),
                                    6.28981));
    }

    UnitOfMeasureConversion UnitOfMeasureConversionManager::directLookup(
                                           const CommodityType& commodityType,
                                           const UnitOfMeasure& source,
                                           const UnitOfMeasure& target) const {

        for (const auto& i : data_) {
            if (matches(i, commodityType, source, target)) {
                return i;
            }
        }

        // Here, the code used to look for conversions with null
        // commodity type as a fall-back.  However, this would only
        // affect direct lookups and not other matches being tried in
        // the smart-lookup loop.  To implement the complete fall-back
        // strategy, we should either duplicate the loop (as we would
        // duplicate it here---smelly) or change the 'matches'
        // functions so that a null commodity type matches. However,
        // in the second case we would also have to take care that
        // conversions with a null type be at the end of the list so
        // that they don't supersede specific types. We'll have to
        // think a bit about this, so no fall-back for the time being.

        QL_FAIL("no direct conversion available from "
                << commodityType.code() << " " << source.code()
                << " to " << target.code());
    }

    UnitOfMeasureConversion UnitOfMeasureConversionManager::smartLookup(
                              const CommodityType& commodityType,
                              const UnitOfMeasure& source,
                              const UnitOfMeasure& target,
                              list<string> forbidden) const {

        try {
            return directLookup(commodityType,source,target);
        } catch (Error&) {
            ; // no direct conversion available; turn to smart lookup.
        }

        // The source unit is forbidden to subsequent lookups in order
        // to avoid cycles.
        forbidden.push_back(source.code());

        for (const auto& i : data_) {
            // we look for conversion data which involve our source unit...
            if (matches(i, commodityType, source)) {
                const UnitOfMeasure& other = source == i.source() ? i.target() : i.source();
                if (find(forbidden.begin(),forbidden.end(),
                         other.code()) == forbidden.end()) {
                    // if we can get to the target from here...
                    try {
                        UnitOfMeasureConversion tail =
                            smartLookup(commodityType,other,target);
                        // ..we're done.
                        return UnitOfMeasureConversion::chain(i, tail);
                    } catch (Error&) {
                        // otherwise, we just discard this conversion.
                        ;
                    }
                }
            }
        }

        // if the loop completed, we have no way to return the
        // requested conversion.
        QL_FAIL("no conversion available for "
                << commodityType.code() << " from "
                << source.code() << " to " << target.code());
    }

}

]]></document_content>
  </document>
  <document index="125">
    <source>commodities/unitofmeasureconversionmanager.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file unitofmeasureconversionmanager.hpp
    \brief Unit-of-measure conversion manager
*/

#ifndef quantlib_unit_of_measure_conversion_manager_hpp
#define quantlib_unit_of_measure_conversion_manager_hpp

#include <ql/experimental/commodities/unitofmeasureconversion.hpp>
#include <ql/patterns/singleton.hpp>
#include <list>

namespace QuantLib {

    //! repository of conversion factors between units of measure
    /*! \test lookup of direct unit of measure conversion is tested. */
    class UnitOfMeasureConversionManager
        : public Singleton<UnitOfMeasureConversionManager> {
        friend class Singleton<UnitOfMeasureConversionManager>;

      public:
        UnitOfMeasureConversion lookup(
            const CommodityType& commodityType,
            const UnitOfMeasure&,
            const UnitOfMeasure&,
            UnitOfMeasureConversion::Type type =
                                    UnitOfMeasureConversion::Derived) const;
        void add(const UnitOfMeasureConversion&);
        void clear();

      private:
        std::list<UnitOfMeasureConversion> data_;
        UnitOfMeasureConversionManager();
        void addKnownConversionFactors();
        UnitOfMeasureConversion directLookup(const CommodityType& commodityType,
                                             const UnitOfMeasure& source,
                                             const UnitOfMeasure& target) const;
        UnitOfMeasureConversion smartLookup(const CommodityType& commodityType,
                                            const UnitOfMeasure& source,
                                            const UnitOfMeasure& target,
                                            std::list<std::string> forbidden =
                                                std::list<std::string>()) const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="126">
    <source>convertiblebonds/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    binomialconvertibleengine.hpp \
    convertiblebond.hpp \
    discretizedconvertible.hpp \
    tflattice.hpp

cpp_files = \
    convertiblebond.cpp \
    discretizedconvertible.cpp

if UNITY_BUILD

nodist_libConvertibleBonds_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libConvertibleBonds_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libConvertibleBonds.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="127">
    <source>convertiblebonds/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/convertiblebonds/binomialconvertibleengine.hpp>
#include <ql/experimental/convertiblebonds/convertiblebond.hpp>
#include <ql/experimental/convertiblebonds/discretizedconvertible.hpp>
#include <ql/experimental/convertiblebonds/tflattice.hpp>

]]></document_content>
  </document>
  <document index="128">
    <source>convertiblebonds/binomialconvertibleengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file binomialconvertibleengine.hpp
    \brief binomial engine for convertible bonds
*/

#ifndef quantlib_binomial_convertible_engine_hpp
#define quantlib_binomial_convertible_engine_hpp

#include <ql/experimental/convertiblebonds/convertiblebond.hpp>
#include <ql/experimental/convertiblebonds/discretizedconvertible.hpp>
#include <ql/experimental/convertiblebonds/tflattice.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <utility>

namespace QuantLib {

    //! Binomial Tsiveriotis-Fernandes engine for convertible bonds
    /*  \ingroup hybridengines

        \test the correctness of the returned value is tested by
              checking it against known results in a few corner cases.
    */
    template <class T>
    class BinomialConvertibleEngine : public ConvertibleBond::option::engine {
      public:
        BinomialConvertibleEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                  Size timeSteps)
        : process_(std::move(process)), timeSteps_(timeSteps) {
            QL_REQUIRE(timeSteps>0,
                       "timeSteps must be positive, " << timeSteps <<
                       " not allowed");
            registerWith(process_);
        }
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_;
    };


    template <class T>
    void BinomialConvertibleEngine<T>::calculate() const {

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();

        Real s0 = process_->x0();
        QL_REQUIRE(s0 > 0.0, "negative or null underlying");
        Volatility v = process_->blackVolatility()->blackVol(
                                         arguments_.exercise->lastDate(), s0);
        Date maturityDate = arguments_.exercise->lastDate();
        Rate riskFreeRate = process_->riskFreeRate()->zeroRate(
                                 maturityDate, rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->zeroRate(
                                maturityDate, divdc, Continuous, NoFrequency);
        Date referenceDate = process_->riskFreeRate()->referenceDate();

        // subtract dividends
        Size i;
        for (i=0; i<arguments_.dividends.size(); i++) {
            if (arguments_.dividends[i]->date() >= referenceDate)
                s0 -= arguments_.dividends[i]->amount() *
                      process_->riskFreeRate()->discount(
                                             arguments_.dividends[i]->date());
        }
        QL_REQUIRE(s0 > 0.0,
                   "negative value after subtracting dividends");

        // binomial trees with constant coefficient
        Handle<Quote> underlying(ext::shared_ptr<Quote>(new SimpleQuote(s0)));
        Handle<YieldTermStructure> flatRiskFree(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, riskFreeRate, rfdc)));
        Handle<YieldTermStructure> flatDividends(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, q, divdc)));
        Handle<BlackVolTermStructure> flatVol(
            ext::shared_ptr<BlackVolTermStructure>(
                new BlackConstantVol(referenceDate, volcal, v, voldc)));

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Time maturity = rfdc.yearFraction(arguments_.settlementDate,
                                          maturityDate);

        ext::shared_ptr<GeneralizedBlackScholesProcess> bs(
                 new GeneralizedBlackScholesProcess(underlying, flatDividends,
                                                    flatRiskFree, flatVol));
        ext::shared_ptr<T> tree(new T(bs, maturity, timeSteps_,
                                        payoff->strike()));

        Real creditSpread = arguments_.creditSpread->value();

        ext::shared_ptr<Lattice> lattice(
              new TsiveriotisFernandesLattice<T>(tree,riskFreeRate,maturity,
                                                 timeSteps_,creditSpread,v,q));

        DiscretizedConvertible convertible(arguments_, bs,
                                           TimeGrid(maturity, timeSteps_));

        convertible.initialize(lattice, maturity);
        convertible.rollback(0.0);
        results_.value = convertible.presentValue();
        QL_ENSURE(results_.value < std::numeric_limits<Real>::max(),
                  "floating-point overflow on tree grid");
    }

}


#endif
]]></document_content>
  </document>
  <document index="129">
    <source>convertiblebonds/convertiblebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/exercise.hpp>
#include <ql/experimental/convertiblebonds/convertiblebond.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    ConvertibleBond::ConvertibleBond(const ext::shared_ptr<Exercise>&,
                                     Real conversionRatio,
                                     DividendSchedule dividends,
                                     const CallabilitySchedule& callability,
                                     const Handle<Quote>& creditSpread,
                                     const Date& issueDate,
                                     Natural settlementDays,
                                     const Schedule& schedule,
                                     Real)
    : Bond(settlementDays, schedule.calendar(), issueDate), conversionRatio_(conversionRatio),
      callability_(callability), dividends_(std::move(dividends)), creditSpread_(creditSpread) {

        maturityDate_ = schedule.endDate();

        if (!callability.empty()) {
            QL_REQUIRE(callability.back()->date() <= maturityDate_,
                       "last callability date ("
                       << callability.back()->date()
                       << ") later than maturity ("
                       << maturityDate_ << ")");
        }

        registerWith(creditSpread);
    }

    void ConvertibleBond::performCalculations() const {
        option_->setPricingEngine(engine_);
        NPV_ = settlementValue_ = option_->NPV();
        errorEstimate_ = Null<Real>();
    }


    ConvertibleZeroCouponBond::ConvertibleZeroCouponBond(
                          const ext::shared_ptr<Exercise>& exercise,
                          Real conversionRatio,
                          const DividendSchedule& dividends,
                          const CallabilitySchedule& callability,
                          const Handle<Quote>& creditSpread,
                          const Date& issueDate,
                          Natural settlementDays,
                          const DayCounter& dayCounter,
                          const Schedule& schedule,
                          Real redemption)
    : ConvertibleBond(exercise, conversionRatio, dividends, callability,
                      creditSpread, issueDate, settlementDays,
                      schedule, redemption) {

        cashflows_ = Leg();

        // !!! notional forcibly set to 100
        setSingleRedemption(100.0, redemption, maturityDate_);

        option_ = ext::shared_ptr<option>(
                           new option(this, exercise, conversionRatio,
                                      dividends, callability, creditSpread,
                                      cashflows_, dayCounter, schedule,
                                      issueDate, settlementDays, redemption));
    }


    ConvertibleFixedCouponBond::ConvertibleFixedCouponBond(
                          const ext::shared_ptr<Exercise>& exercise,
                          Real conversionRatio,
                          const DividendSchedule& dividends,
                          const CallabilitySchedule& callability,
                          const Handle<Quote>& creditSpread,
                          const Date& issueDate,
                          Natural settlementDays,
                          const std::vector<Rate>& coupons,
                          const DayCounter& dayCounter,
                          const Schedule& schedule,
                          Real redemption,
                          const Period& exCouponPeriod,
                          const Calendar& exCouponCalendar,
                          const BusinessDayConvention exCouponConvention,
                          bool exCouponEndOfMonth)
    : ConvertibleBond(exercise, conversionRatio, dividends, callability,
                      creditSpread, issueDate, settlementDays,
                      schedule, redemption) {

        // !!! notional forcibly set to 100
        cashflows_ = FixedRateLeg(schedule)
            .withNotionals(100.0)
            .withCouponRates(coupons, dayCounter)
            .withPaymentAdjustment(schedule.businessDayConvention())
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        option_ = ext::shared_ptr<option>(
                           new option(this, exercise, conversionRatio,
                                      dividends, callability, creditSpread,
                                      cashflows_, dayCounter, schedule,
                                      issueDate, settlementDays, redemption));
    }


    ConvertibleFloatingRateBond::ConvertibleFloatingRateBond(
                          const ext::shared_ptr<Exercise>& exercise,
                          Real conversionRatio,
                          const DividendSchedule& dividends,
                          const CallabilitySchedule& callability,
                          const Handle<Quote>& creditSpread,
                          const Date& issueDate,
                          Natural settlementDays,
                          const ext::shared_ptr<IborIndex>& index,
                          Natural fixingDays,
                          const std::vector<Spread>& spreads,
                          const DayCounter& dayCounter,
                          const Schedule& schedule,
                          Real redemption,
                          const Period& exCouponPeriod,
                          const Calendar& exCouponCalendar,
                          const BusinessDayConvention exCouponConvention,
                          bool exCouponEndOfMonth)
    : ConvertibleBond(exercise, conversionRatio, dividends, callability,
                      creditSpread, issueDate, settlementDays,
                      schedule, redemption) {

        // !!! notional forcibly set to 100
        cashflows_ = IborLeg(schedule, index)
            .withPaymentDayCounter(dayCounter)
            .withNotionals(100.0)
            .withPaymentAdjustment(schedule.businessDayConvention())
            .withFixingDays(fixingDays)
            .withSpreads(spreads)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        option_ = ext::shared_ptr<option>(
                           new option(this, exercise, conversionRatio,
                                      dividends, callability, creditSpread,
                                      cashflows_, dayCounter, schedule,
                                      issueDate, settlementDays, redemption));

        registerWith(index);
    }

    ConvertibleBond::option::option(const ConvertibleBond* bond,
                                    const ext::shared_ptr<Exercise>& exercise,
                                    Real conversionRatio,
                                    DividendSchedule dividends,
                                    CallabilitySchedule callability,
                                    Handle<Quote> creditSpread,
                                    Leg cashflows,
                                    DayCounter dayCounter,
                                    Schedule schedule,
                                    const Date& issueDate,
                                    Natural settlementDays,
                                    Real redemption)
    : OneAssetOption(
          ext::shared_ptr<StrikedTypePayoff>(new PlainVanillaPayoff(
              Option::Call, (bond->notionals()[0]) / 100.0 * redemption / conversionRatio)),
          exercise),
      bond_(bond), conversionRatio_(conversionRatio), callability_(std::move(callability)),
      dividends_(std::move(dividends)), creditSpread_(std::move(creditSpread)),
      cashflows_(std::move(cashflows)), dayCounter_(std::move(dayCounter)), issueDate_(issueDate),
      schedule_(std::move(schedule)), settlementDays_(settlementDays), redemption_(redemption) {
        registerWith(ext::shared_ptr<ConvertibleBond>(const_cast<ConvertibleBond*>(bond),
                                                        null_deleter()));
    }


    void ConvertibleBond::option::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ConvertibleBond::option::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");

        moreArgs->conversionRatio = conversionRatio_;

        Date settlement = bond_->settlementDate();

        Size n = callability_.size();
        moreArgs->callabilityDates.clear();
        moreArgs->callabilityTypes.clear();
        moreArgs->callabilityPrices.clear();
        moreArgs->callabilityTriggers.clear();
        moreArgs->callabilityDates.reserve(n);
        moreArgs->callabilityTypes.reserve(n);
        moreArgs->callabilityPrices.reserve(n);
        moreArgs->callabilityTriggers.reserve(n);
        for (Size i=0; i<n; i++) {
            if (!callability_[i]->hasOccurred(settlement, false)) {
                moreArgs->callabilityTypes.push_back(callability_[i]->type());
                moreArgs->callabilityDates.push_back(callability_[i]->date());
                moreArgs->callabilityPrices.push_back(
                                            callability_[i]->price().amount());
                if (callability_[i]->price().type() == Bond::Price::Clean)
                    moreArgs->callabilityPrices.back() +=
                        bond_->accruedAmount(callability_[i]->date());
                ext::shared_ptr<SoftCallability> softCall =
                    ext::dynamic_pointer_cast<SoftCallability>(
                                                             callability_[i]);
                if (softCall != nullptr)
                    moreArgs->callabilityTriggers.push_back(
                                                         softCall->trigger());
                else
                    moreArgs->callabilityTriggers.push_back(Null<Real>());
            }
        }

        const Leg& cashflows = bond_->cashflows();

        moreArgs->couponDates.clear();
        moreArgs->couponAmounts.clear();
        for (Size i=0; i<cashflows.size()-1; i++) {
            if (!cashflows[i]->hasOccurred(settlement, false)) {
                moreArgs->couponDates.push_back(cashflows[i]->date());
                moreArgs->couponAmounts.push_back(cashflows[i]->amount());
            }
        }

        moreArgs->dividends.clear();
        moreArgs->dividendDates.clear();
        for (const auto& dividend : dividends_) {
            if (!dividend->hasOccurred(settlement, false)) {
                moreArgs->dividends.push_back(dividend);
                moreArgs->dividendDates.push_back(dividend->date());
            }
        }

        moreArgs->creditSpread = creditSpread_;
        moreArgs->issueDate = issueDate_;
        moreArgs->settlementDate = settlement;
        moreArgs->settlementDays = settlementDays_;
        moreArgs->redemption = redemption_;
    }


    void ConvertibleBond::option::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(conversionRatio != Null<Real>(), "null conversion ratio");
        QL_REQUIRE(conversionRatio > 0.0,
                   "positive conversion ratio required: "
                   << conversionRatio << " not allowed");

        QL_REQUIRE(redemption != Null<Real>(), "null redemption");
        QL_REQUIRE(redemption >= 0.0,
                   "positive redemption required: "
                   << redemption << " not allowed");

        QL_REQUIRE(settlementDate != Date(), "null settlement date");

        QL_REQUIRE(settlementDays != Null<Natural>(), "null settlement days");

        QL_REQUIRE(callabilityDates.size() == callabilityTypes.size(),
                   "different number of callability dates and types");
        QL_REQUIRE(callabilityDates.size() == callabilityPrices.size(),
                   "different number of callability dates and prices");
        QL_REQUIRE(callabilityDates.size() == callabilityTriggers.size(),
                   "different number of callability dates and triggers");

        QL_REQUIRE(couponDates.size() == couponAmounts.size(),
                   "different number of coupon dates and amounts");
    }

}
]]></document_content>
  </document>
  <document index="130">
    <source>convertiblebonds/convertiblebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file convertiblebond.hpp
    \brief convertible bond class
*/

#ifndef quantlib_convertible_bond_hpp
#define quantlib_convertible_bond_hpp

#include <ql/instruments/bond.hpp>
#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/instruments/callabilityschedule.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    class IborIndex;
    class PricingEngine;

    //! %callability leaving to the holder the possibility to convert
    class SoftCallability : public Callability {
      public:
        SoftCallability(const Bond::Price& price,
                        const Date& date,
                        Real trigger)
        : Callability(price, Callability::Call, date), trigger_(trigger) {}
        Real trigger() const { return trigger_; }
      private:
        Real trigger_;
    };


    //! base class for convertible bonds
    class ConvertibleBond : public Bond {
      public:
        class option;
        Real conversionRatio() const { return conversionRatio_; }
        const DividendSchedule& dividends() const { return dividends_; }
        const CallabilitySchedule& callability() const { return callability_; }
        const Handle<Quote>& creditSpread() const { return creditSpread_; }
      protected:
        ConvertibleBond(const ext::shared_ptr<Exercise>& exercise,
                        Real conversionRatio,
                        DividendSchedule dividends,
                        const CallabilitySchedule& callability,
                        const Handle<Quote>& creditSpread,
                        const Date& issueDate,
                        Natural settlementDays,
                        const Schedule& schedule,
                        Real redemption);
        void performCalculations() const override;
        Real conversionRatio_;
        CallabilitySchedule callability_;
        DividendSchedule dividends_;
        Handle<Quote> creditSpread_;
        ext::shared_ptr<option> option_;
    };


    //! convertible zero-coupon bond
    /*! \warning Most methods inherited from Bond (such as yield or
                 the yield-based dirtyPrice and cleanPrice) refer to
                 the underlying plain-vanilla bond and do not take
                 convertibility and callability into account.
    */
    class ConvertibleZeroCouponBond : public ConvertibleBond {
      public:
        ConvertibleZeroCouponBond(
                    const ext::shared_ptr<Exercise>& exercise,
                    Real conversionRatio,
                    const DividendSchedule& dividends,
                    const CallabilitySchedule& callability,
                    const Handle<Quote>& creditSpread,
                    const Date& issueDate,
                    Natural settlementDays,
                    const DayCounter& dayCounter,
                    const Schedule& schedule,
                    Real redemption = 100);
    };


    //! convertible fixed-coupon bond
    /*! \warning Most methods inherited from Bond (such as yield or
                 the yield-based dirtyPrice and cleanPrice) refer to
                 the underlying plain-vanilla bond and do not take
                 convertibility and callability into account.
    */
    class ConvertibleFixedCouponBond : public ConvertibleBond {
      public:
        ConvertibleFixedCouponBond(const ext::shared_ptr<Exercise>& exercise,
                                   Real conversionRatio,
                                   const DividendSchedule& dividends,
                                   const CallabilitySchedule& callability,
                                   const Handle<Quote>& creditSpread,
                                   const Date& issueDate,
                                   Natural settlementDays,
                                   const std::vector<Rate>& coupons,
                                   const DayCounter& dayCounter,
                                   const Schedule& schedule,
                                   Real redemption = 100,
                                   const Period& exCouponPeriod = Period(),
                                   const Calendar& exCouponCalendar = Calendar(),
                                   BusinessDayConvention exCouponConvention = Unadjusted,
                                   bool exCouponEndOfMonth = false);
    };


    //! convertible floating-rate bond
    /*! \warning Most methods inherited from Bond (such as yield or
                 the yield-based dirtyPrice and cleanPrice) refer to
                 the underlying plain-vanilla bond and do not take
                 convertibility and callability into account.
    */
    class ConvertibleFloatingRateBond : public ConvertibleBond {
      public:
        ConvertibleFloatingRateBond(const ext::shared_ptr<Exercise>& exercise,
                                    Real conversionRatio,
                                    const DividendSchedule& dividends,
                                    const CallabilitySchedule& callability,
                                    const Handle<Quote>& creditSpread,
                                    const Date& issueDate,
                                    Natural settlementDays,
                                    const ext::shared_ptr<IborIndex>& index,
                                    Natural fixingDays,
                                    const std::vector<Spread>& spreads,
                                    const DayCounter& dayCounter,
                                    const Schedule& schedule,
                                    Real redemption = 100,
                                    const Period& exCouponPeriod = Period(),
                                    const Calendar& exCouponCalendar = Calendar(),
                                    BusinessDayConvention exCouponConvention = Unadjusted,
                                    bool exCouponEndOfMonth = false);
    };


    class ConvertibleBond::option : public OneAssetOption {
      public:
        class arguments;
        class engine;
        option(const ConvertibleBond* bond,
               const ext::shared_ptr<Exercise>& exercise,
               Real conversionRatio,
               DividendSchedule dividends,
               CallabilitySchedule callability,
               Handle<Quote> creditSpread,
               Leg cashflows,
               DayCounter dayCounter,
               Schedule schedule,
               const Date& issueDate,
               Natural settlementDays,
               Real redemption);

        void setupArguments(PricingEngine::arguments*) const override;

      private:
        const ConvertibleBond* bond_;
        Real conversionRatio_;
        CallabilitySchedule callability_;
        DividendSchedule  dividends_;
        Handle<Quote> creditSpread_;
        Leg cashflows_;
        DayCounter dayCounter_;
        Date issueDate_;
        Schedule schedule_;
        Natural settlementDays_;
        Real redemption_;
    };


    class ConvertibleBond::option::arguments
        : public OneAssetOption::arguments {
      public:
        arguments()
        : conversionRatio(Null<Real>()), settlementDays(Null<Natural>()),
          redemption(Null<Real>()) {}

        Real conversionRatio;
        Handle<Quote> creditSpread;
        DividendSchedule dividends;
        std::vector<Date> dividendDates;
        std::vector<Date> callabilityDates;
        std::vector<Callability::Type> callabilityTypes;
        std::vector<Real> callabilityPrices;
        std::vector<Real> callabilityTriggers;
        std::vector<Date> couponDates;
        std::vector<Real> couponAmounts;
        Date issueDate;
        Date settlementDate;

        Natural settlementDays;
        Real redemption;
        void validate() const override;
    };

    class ConvertibleBond::option::engine
        : public GenericEngine<ConvertibleBond::option::arguments,
                               ConvertibleBond::option::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="131">
    <source>convertiblebonds/discretizedconvertible.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/convertiblebonds/discretizedconvertible.hpp>
#include <ql/math/comparison.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    DiscretizedConvertible::DiscretizedConvertible(
        ConvertibleBond::option::arguments args,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        const TimeGrid& grid)
    : arguments_(std::move(args)), process_(std::move(process)) {

        dividendValues_ = Array(arguments_.dividends.size(), 0.0);

        Date settlementDate = process_->riskFreeRate()->referenceDate();
        for (Size i=0; i<arguments_.dividends.size(); i++) {
            if (arguments_.dividends[i]->date() >= settlementDate) {
                dividendValues_[i] =
                    arguments_.dividends[i]->amount() *
                    process_->riskFreeRate()->discount(
                                             arguments_.dividends[i]->date());
            }
        }

        DayCounter dayCounter = process_->riskFreeRate()->dayCounter();
        Date bondSettlement = arguments_.settlementDate;

        stoppingTimes_.resize(arguments_.exercise->dates().size());
        for (Size i=0; i<stoppingTimes_.size(); ++i)
            stoppingTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        arguments_.exercise->date(i));

        callabilityTimes_.resize(arguments_.callabilityDates.size());
        for (Size i=0; i<callabilityTimes_.size(); ++i)
            callabilityTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        arguments_.callabilityDates[i]);

        couponTimes_.resize(arguments_.couponDates.size());
        for (Size i=0; i<couponTimes_.size(); ++i)
            couponTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        arguments_.couponDates[i]);

        dividendTimes_.resize(arguments_.dividendDates.size());
        for (Size i=0; i<dividendTimes_.size(); ++i)
            dividendTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        arguments_.dividendDates[i]);

        if (!grid.empty()) {
            // adjust times to grid
            for (double& stoppingTime : stoppingTimes_)
                stoppingTime = grid.closestTime(stoppingTime);
            for (double& couponTime : couponTimes_)
                couponTime = grid.closestTime(couponTime);
            for (double& callabilityTime : callabilityTimes_)
                callabilityTime = grid.closestTime(callabilityTime);
            for (double& dividendTime : dividendTimes_)
                dividendTime = grid.closestTime(dividendTime);
        }
    }

    void DiscretizedConvertible::reset(Size size) {

        // Set to bond redemption values
        values_ = Array(size, arguments_.redemption);

        // coupon amounts should be added when adjusting
        // values_ = Array(size, arguments_.cashFlows.back()->amount());

        conversionProbability_ = Array(size, 0.0);
        spreadAdjustedRate_ = Array(size, 0.0);

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();

        // this takes care of convertibility and conversion probabilities
        adjustValues();

        Real creditSpread = arguments_.creditSpread->value();

        Date exercise = arguments_.exercise->lastDate();

        Rate riskFreeRate =
            process_->riskFreeRate()->zeroRate(exercise, rfdc,
                                               Continuous, NoFrequency);

        // Calculate blended discount rate to be used on roll back.
        for (Size j=0; j<values_.size(); j++) {
           spreadAdjustedRate_[j] =
               conversionProbability_[j] * riskFreeRate +
               (1-conversionProbability_[j])*(riskFreeRate + creditSpread);
        }
    }

    void DiscretizedConvertible::postAdjustValuesImpl() {

        bool convertible = false;
        switch (arguments_.exercise->type()) {
          case Exercise::American:
            if (time() <= stoppingTimes_[1] && time() >= stoppingTimes_[0])
                convertible = true;
            break;
          case Exercise::European:
            if (isOnTime(stoppingTimes_[0]))
                convertible = true;
            break;
          case Exercise::Bermudan:
              for (double stoppingTime : stoppingTimes_) {
                  if (isOnTime(stoppingTime))
                      convertible = true;
              }
            break;
          default:
            QL_FAIL("invalid option type");
        }

        for (Size i=0; i<callabilityTimes_.size(); i++) {
            if (isOnTime(callabilityTimes_[i]))
                applyCallability(i,convertible);
        }

        for (Size i=0; i<couponTimes_.size(); i++) {
            if (isOnTime(couponTimes_[i]))
                addCoupon(i);
        }

        if (convertible)
            applyConvertibility();
    }

    void DiscretizedConvertible::applyConvertibility() {
        Array grid = adjustedGrid();
        for (Size j=0; j<values_.size(); j++) {
            Real payoff = arguments_.conversionRatio*grid[j];
            if (values_[j] <= payoff) {
                values_[j] = payoff;
                conversionProbability_[j] = 1.0;
            }
        }
    }

    void DiscretizedConvertible::applyCallability(Size i, bool convertible) {
        Size j;
        Array grid = adjustedGrid();
        switch (arguments_.callabilityTypes[i]) {
          case Callability::Call:
            if (arguments_.callabilityTriggers[i] != Null<Real>()) {
                Real conversionValue =
                    arguments_.redemption/arguments_.conversionRatio;
                Real trigger =
                    conversionValue*arguments_.callabilityTriggers[i];
                for (j=0; j<values_.size(); j++) {
                    // the callability is conditioned by the trigger...
                    if (grid[j] >= trigger) {
                        // ...and might trigger conversion
                        values_[j] =
                            std::min(std::max(
                                          arguments_.callabilityPrices[i],
                                          arguments_.conversionRatio*grid[j]),
                                     values_[j]);
                    }
                }
            } else if (convertible) {
                for (j=0; j<values_.size(); j++) {
                    // exercising the callability might trigger conversion
                    values_[j] =
                        std::min(std::max(arguments_.callabilityPrices[i],
                                          arguments_.conversionRatio*grid[j]),
                                 values_[j]);
                }
            } else {
                for (j=0; j<values_.size(); j++) {
                    values_[j] = std::min(arguments_.callabilityPrices[i],
                                          values_[j]);
                }
            }
            break;
          case Callability::Put:
            for (j=0; j<values_.size(); j++) {
                values_[j] = std::max(values_[j],
                                      arguments_.callabilityPrices[i]);
            }
            break;
          default:
            QL_FAIL("unknown callability type");
        }
    }

    void DiscretizedConvertible::addCoupon(Size i) {
        values_ += arguments_.couponAmounts[i];
    }

    Disposable<Array> DiscretizedConvertible::adjustedGrid() const {
        Time t = time();
        Array grid = method()->grid(t);
        // add back all dividend amounts in the future
        for (Size i=0; i<arguments_.dividends.size(); i++) {
            Time dividendTime = dividendTimes_[i];
            if (dividendTime >= t || close(dividendTime,t)) {
                const ext::shared_ptr<Dividend>& d = arguments_.dividends[i];
                DiscountFactor dividendDiscount =
                    process_->riskFreeRate()->discount(dividendTime) /
                    process_->riskFreeRate()->discount(t);
                for (double& j : grid)
                    j += d->amount(j) * dividendDiscount;
            }
        }
        return grid;
    }

}

]]></document_content>
  </document>
  <document index="132">
    <source>convertiblebonds/discretizedconvertible.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedconvertible.hpp
    \brief discretized convertible
*/

#ifndef quantlib_discretized_convertible_hpp
#define quantlib_discretized_convertible_hpp

#include <ql/discretizedasset.hpp>
#include <ql/experimental/convertiblebonds/convertiblebond.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class DiscretizedConvertible : public DiscretizedAsset {
      public:
        DiscretizedConvertible(ConvertibleBond::option::arguments,
                               ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                               const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        const Array& conversionProbability() const {
            return conversionProbability_;
        }
        Array& conversionProbability() { return conversionProbability_; }

        const Array& spreadAdjustedRate() const { return spreadAdjustedRate_; }
        Array& spreadAdjustedRate() { return spreadAdjustedRate_; }

        const Array& dividendValues() const { return dividendValues_; }
        Array& dividendValues() { return dividendValues_; }

        std::vector<Time> mandatoryTimes() const override {
            std::vector<Time> result;
            std::copy(stoppingTimes_.begin(), stoppingTimes_.end(),
                      std::back_inserter(result));
            std::copy(callabilityTimes_.begin(), callabilityTimes_.end(),
                      std::back_inserter(result));
            std::copy(couponTimes_.begin(), couponTimes_.end(),
                      std::back_inserter(result));
            return result;
        }

      protected:
        void postAdjustValuesImpl() override;
        Array conversionProbability_, spreadAdjustedRate_, dividendValues_;

      private:
        Disposable<Array> adjustedGrid() const;
        void applyConvertibility();
        void applyCallability(Size, bool convertible);
        void addCoupon(Size);
        ConvertibleBond::option::arguments arguments_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        std::vector<Time> stoppingTimes_;
        std::vector<Time> callabilityTimes_;
        std::vector<Time> couponTimes_;
        std::vector<Time> dividendTimes_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="133">
    <source>convertiblebonds/tflattice.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tflattice.hpp
    \brief Binomial Tsiveriotis-Fernandes tree model
*/

#ifndef quantlib_lattices_tf_lattice_hpp
#define quantlib_lattices_tf_lattice_hpp

#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/experimental/convertiblebonds/discretizedconvertible.hpp>

namespace QuantLib {

    //! Binomial lattice approximating the Tsiveriotis-Fernandes model
    /*! \ingroup lattices */
    template <class T>
    class TsiveriotisFernandesLattice : public BlackScholesLattice<T> {
      public:
        TsiveriotisFernandesLattice(const ext::shared_ptr<T>& tree,
                                    Rate riskFreeRate,
                                    Time end,
                                    Size steps,
                                    Spread creditSpread,
                                    Volatility volatility,
                                    Spread divYield);

        Spread creditSpread() const { return creditSpread_; };

      protected:
        void stepback(Size i,
                      const Array& values,
                      const Array& conversionProbability,
                      const Array& spreadAdjustedRate,
                      Array& newValues,
                      Array& newConversionProbability,
                      Array& newSpreadAdjustedRate) const;
        void rollback(DiscretizedAsset&, Time to) const override;
        void partialRollback(DiscretizedAsset&, Time to) const override;

      private:
        Spread creditSpread_;
    };


    // template definitions

    template <class T>
    TsiveriotisFernandesLattice<T>::TsiveriotisFernandesLattice(
                                             const ext::shared_ptr<T>& tree,
                                             Rate riskFreeRate,
                                             Time end,
                                             Size steps,
                                             Spread creditSpread,
                                             Volatility sigma,
                                             Spread divYield)
    : BlackScholesLattice<T>(tree, riskFreeRate, end, steps),
      creditSpread_(creditSpread) {
        QL_REQUIRE(this->pu_<=1.0,
                   "probability (" << this->pu_ << ") higher than one");
        QL_REQUIRE(this->pu_>=0.0,
                   "negative (" << this->pu_ << ") probability");
    }

    template <class T>
    void TsiveriotisFernandesLattice<T>::stepback(
                                          Size i,
                                          const Array& values,
                                          const Array& conversionProbability,
                                          const Array& spreadAdjustedRate,
                                          Array& newValues,
                                          Array& newConversionProbability,
                                          Array& newSpreadAdjustedRate) const {

        for (Size j=0; j<this->size(i); j++) {

            // new conversion probability is calculated via backward
            // induction using up and down probabilities on tree on
            // previous conversion probabilities, ie weighted average
            // of previous probabilities.
            newConversionProbability[j] =
                this->pd_*conversionProbability[j] +
                this->pu_*conversionProbability[j+1];

            // Use blended discounting rate
            newSpreadAdjustedRate[j] =
                newConversionProbability[j] * this->riskFreeRate_ +
                (1-newConversionProbability[j])*(this->riskFreeRate_+creditSpread_);

            newValues[j] =
                (this->pd_*values[j]/(1+(spreadAdjustedRate[j]*this->dt_)))
              + (this->pu_*values[j+1]/(1+(spreadAdjustedRate[j+1]*this->dt_)));

        }
    }

    template <class T>
    void TsiveriotisFernandesLattice<T>::rollback(DiscretizedAsset& asset,
                                                  Time to) const {
        partialRollback(asset,to);
        asset.adjustValues();
    }


    template <class T>
    void TsiveriotisFernandesLattice<T>::partialRollback(DiscretizedAsset& asset,
                                                         Time to) const {

        Time from = asset.time();

        if (close(from,to))
            return;

        QL_REQUIRE(from > to,
                   "cannot roll the asset back to" << to
                   << " (it is already at t = " << from << ")");

        auto& convertible = dynamic_cast<DiscretizedConvertible&>(asset);

        auto iFrom = Integer(this->t_.index(from));
        auto iTo = Integer(this->t_.index(to));

        for (Integer i=iFrom-1; i>=iTo; --i) {

            Array newValues(this->size(i));
            Array newSpreadAdjustedRate(this->size(i));
            Array newConversionProbability(this->size(i));

            stepback(i, convertible.values(),
                     convertible.conversionProbability(),
                     convertible.spreadAdjustedRate(), newValues,
                     newConversionProbability,newSpreadAdjustedRate);

            convertible.time() = this->t_[i];
            convertible.values() = newValues;
            convertible.spreadAdjustedRate() = newSpreadAdjustedRate;
            convertible.conversionProbability() = newConversionProbability;

            // skip the very last adjustment
            if (i != iTo)
                convertible.adjustValues();
        }
    }

}

#endif
]]></document_content>
  </document>
  <document index="134">
    <source>coupons/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    cmsspreadcoupon.hpp \
    digitalcmsspreadcoupon.hpp \
    lognormalcmsspreadpricer.hpp \
    proxyibor.hpp \
    quantocouponpricer.hpp \
    strippedcapflooredcoupon.hpp \
    swapspreadindex.hpp

cpp_files = \
    cmsspreadcoupon.cpp \
    digitalcmsspreadcoupon.cpp \
    lognormalcmsspreadpricer.cpp \
    proxyibor.cpp \
    quantocouponpricer.cpp \
    strippedcapflooredcoupon.cpp \
    swapspreadindex.cpp

if UNITY_BUILD

nodist_libCoupons_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libCoupons_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libCoupons.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="135">
    <source>coupons/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/coupons/cmsspreadcoupon.hpp>
#include <ql/experimental/coupons/digitalcmsspreadcoupon.hpp>
#include <ql/experimental/coupons/lognormalcmsspreadpricer.hpp>
#include <ql/experimental/coupons/proxyibor.hpp>
#include <ql/experimental/coupons/quantocouponpricer.hpp>
#include <ql/experimental/coupons/strippedcapflooredcoupon.hpp>
#include <ql/experimental/coupons/swapspreadindex.hpp>

]]></document_content>
  </document>
  <document index="136">
    <source>coupons/cmsspreadcoupon.cpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details.
*/

#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/experimental/coupons/cmsspreadcoupon.hpp>
#include <utility>

namespace QuantLib {

    CmsSpreadCoupon::CmsSpreadCoupon(
        const Date &paymentDate, Real nominal, const Date &startDate,
        const Date &endDate, Natural fixingDays,
        const ext::shared_ptr<SwapSpreadIndex> &index, Real gearing,
        Spread spread, const Date &refPeriodStart,
        const Date &refPeriodEnd,
        const DayCounter &dayCounter, bool isInArrears, const Date &exCouponDate)
        : FloatingRateCoupon(paymentDate, nominal, startDate, endDate,
                             fixingDays, index, gearing, spread,
                             refPeriodStart, refPeriodEnd, dayCounter,
                             isInArrears, exCouponDate),
          index_(index) {}

    void CmsSpreadCoupon::accept(AcyclicVisitor &v) {
        auto* v1 = dynamic_cast<Visitor<CmsSpreadCoupon>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            FloatingRateCoupon::accept(v);
    }

    CmsSpreadLeg::CmsSpreadLeg(Schedule schedule, ext::shared_ptr<SwapSpreadIndex> index)
    : schedule_(std::move(schedule)), swapSpreadIndex_(std::move(index)),
      paymentAdjustment_(Following), inArrears_(false), zeroPayments_(false) {}

    CmsSpreadLeg &CmsSpreadLeg::withNotionals(Real notional) {
        notionals_ = std::vector<Real>(1, notional);
        return *this;
    }

    CmsSpreadLeg &
    CmsSpreadLeg::withNotionals(const std::vector<Real> &notionals) {
        notionals_ = notionals;
        return *this;
    }

    CmsSpreadLeg &
    CmsSpreadLeg::withPaymentDayCounter(const DayCounter &dayCounter) {
        paymentDayCounter_ = dayCounter;
        return *this;
    }

    CmsSpreadLeg &
    CmsSpreadLeg::withPaymentAdjustment(BusinessDayConvention convention) {
        paymentAdjustment_ = convention;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withFixingDays(Natural fixingDays) {
        fixingDays_ = std::vector<Natural>(1, fixingDays);
        return *this;
    }

    CmsSpreadLeg &
    CmsSpreadLeg::withFixingDays(const std::vector<Natural> &fixingDays) {
        fixingDays_ = fixingDays;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withGearings(Real gearing) {
        gearings_ = std::vector<Real>(1, gearing);
        return *this;
    }

    CmsSpreadLeg &
    CmsSpreadLeg::withGearings(const std::vector<Real> &gearings) {
        gearings_ = gearings;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withSpreads(Spread spread) {
        spreads_ = std::vector<Spread>(1, spread);
        return *this;
    }

    CmsSpreadLeg &
    CmsSpreadLeg::withSpreads(const std::vector<Spread> &spreads) {
        spreads_ = spreads;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withCaps(Rate cap) {
        caps_ = std::vector<Rate>(1, cap);
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withCaps(const std::vector<Rate> &caps) {
        caps_ = caps;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withFloors(Rate floor) {
        floors_ = std::vector<Rate>(1, floor);
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withFloors(const std::vector<Rate> &floors) {
        floors_ = floors;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::inArrears(bool flag) {
        inArrears_ = flag;
        return *this;
    }

    CmsSpreadLeg &CmsSpreadLeg::withZeroPayments(bool flag) {
        zeroPayments_ = flag;
        return *this;
    }

    CmsSpreadLeg::operator Leg() const {
        return FloatingLeg<SwapSpreadIndex, CmsSpreadCoupon,
                           CappedFlooredCmsSpreadCoupon>(
            schedule_, notionals_, swapSpreadIndex_, paymentDayCounter_,
            paymentAdjustment_, fixingDays_, gearings_, spreads_, caps_,
            floors_, inArrears_, zeroPayments_);
    }
}
]]></document_content>
  </document>
  <document index="137">
    <source>coupons/cmsspreadcoupon.hpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

/*! \file cmsspreadcoupon.hpp
    \brief CMS spread coupon
*/

#ifndef quantlib_cmsspread_coupon_hpp
#define quantlib_cmsspread_coupon_hpp

#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/experimental/coupons/swapspreadindex.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    class SwapIndex;

    //! CMS spread coupon class
    /*! \warning This class does not perform any date adjustment,
                 i.e., the start and end date passed upon construction
                 should be already rolled to a business day.
    */
    class CmsSpreadCoupon : public FloatingRateCoupon {
      public:
        CmsSpreadCoupon(const Date& paymentDate,
                  Real nominal,
                  const Date& startDate,
                  const Date& endDate,
                  Natural fixingDays,
                  const ext::shared_ptr<SwapSpreadIndex>& index,
                  Real gearing = 1.0,
                  Spread spread = 0.0,
                  const Date& refPeriodStart = Date(),
                  const Date& refPeriodEnd = Date(),
                  const DayCounter& dayCounter = DayCounter(),
                  bool isInArrears = false,
                  const Date& exCouponDate = Date());
        //! \name Inspectors
        //@{
        const ext::shared_ptr<SwapSpreadIndex>& swapSpreadIndex() const {
            return index_;
        }
        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      private:
        ext::shared_ptr<SwapSpreadIndex> index_;
    };

    class CappedFlooredCmsSpreadCoupon : public CappedFlooredCoupon {
      public:
        CappedFlooredCmsSpreadCoupon(
                  const Date& paymentDate,
                  Real nominal,
                  const Date& startDate,
                  const Date& endDate,
                  Natural fixingDays,
                  const ext::shared_ptr<SwapSpreadIndex>& index,
                  Real gearing = 1.0,
                  Spread spread= 0.0,
                  const Rate cap = Null<Rate>(),
                  const Rate floor = Null<Rate>(),
                  const Date& refPeriodStart = Date(),
                  const Date& refPeriodEnd = Date(),
                  const DayCounter& dayCounter = DayCounter(),
                  bool isInArrears = false,
                  const Date& exCouponDate = Date())
        : CappedFlooredCoupon(ext::shared_ptr<FloatingRateCoupon>(new
            CmsSpreadCoupon(paymentDate, nominal, startDate, endDate, fixingDays,
                      index, gearing, spread, refPeriodStart, refPeriodEnd,
                      dayCounter, isInArrears, exCouponDate)), cap, floor) {}

        void accept(AcyclicVisitor& v) override {
            auto* v1 = dynamic_cast<Visitor<CappedFlooredCmsSpreadCoupon>*>(&v);
            if (v1 != nullptr)
                v1->visit(*this);
            else
                CappedFlooredCoupon::accept(v);
        }
    };

    //! helper class building a sequence of capped/floored cms-spread-rate coupons
    class CmsSpreadLeg {
      public:
        CmsSpreadLeg(Schedule schedule, ext::shared_ptr<SwapSpreadIndex> swapSpreadIndex);
        CmsSpreadLeg& withNotionals(Real notional);
        CmsSpreadLeg& withNotionals(const std::vector<Real>& notionals);
        CmsSpreadLeg& withPaymentDayCounter(const DayCounter&);
        CmsSpreadLeg& withPaymentAdjustment(BusinessDayConvention);
        CmsSpreadLeg& withFixingDays(Natural fixingDays);
        CmsSpreadLeg& withFixingDays(const std::vector<Natural>& fixingDays);
        CmsSpreadLeg& withGearings(Real gearing);
        CmsSpreadLeg& withGearings(const std::vector<Real>& gearings);
        CmsSpreadLeg& withSpreads(Spread spread);
        CmsSpreadLeg& withSpreads(const std::vector<Spread>& spreads);
        CmsSpreadLeg& withCaps(Rate cap);
        CmsSpreadLeg& withCaps(const std::vector<Rate>& caps);
        CmsSpreadLeg& withFloors(Rate floor);
        CmsSpreadLeg& withFloors(const std::vector<Rate>& floors);
        CmsSpreadLeg& inArrears(bool flag = true);
        CmsSpreadLeg& withZeroPayments(bool flag = true);
        operator Leg() const;
      private:
        Schedule schedule_;
        ext::shared_ptr<SwapSpreadIndex> swapSpreadIndex_;
        std::vector<Real> notionals_;
        DayCounter paymentDayCounter_;
        BusinessDayConvention paymentAdjustment_;
        std::vector<Natural> fixingDays_;
        std::vector<Real> gearings_;
        std::vector<Spread> spreads_;
        std::vector<Rate> caps_, floors_;
        bool inArrears_, zeroPayments_;
    };


    //! base pricer for vanilla CMS spread coupons
    class CmsSpreadCouponPricer : public FloatingRateCouponPricer {
      public:
        explicit CmsSpreadCouponPricer(Handle<Quote> correlation = Handle<Quote>())
        : correlation_(std::move(correlation)) {
            registerWith(correlation_);
        }

        Handle<Quote> correlation() const{
            return correlation_;
        }

        void setCorrelation(
                         const Handle<Quote> &correlation = Handle<Quote>()) {
            unregisterWith(correlation_);
            correlation_ = correlation;
            registerWith(correlation_);
            update();
        }
      private:
        Handle<Quote> correlation_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="138">
    <source>coupons/digitalcmsspreadcoupon.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/experimental/coupons/digitalcmsspreadcoupon.hpp>
#include <utility>

namespace QuantLib {

    DigitalCmsSpreadCoupon::DigitalCmsSpreadCoupon(
                      const ext::shared_ptr<CmsSpreadCoupon>& underlying,
                      Rate callStrike,
                      Position::Type callPosition,
                      bool isCallATMIncluded,
                      Rate callDigitalPayoff,
                      Rate putStrike,
                      Position::Type putPosition,
                      bool isPutATMIncluded,
                      Rate putDigitalPayoff,
                      const ext::shared_ptr<DigitalReplication>& replication,
                      bool nakedOption)
    : DigitalCoupon(underlying, callStrike, callPosition, isCallATMIncluded,
                    callDigitalPayoff, putStrike, putPosition,
                    isPutATMIncluded, putDigitalPayoff, replication, nakedOption) {}

    void DigitalCmsSpreadCoupon::accept(AcyclicVisitor& v) {
        typedef DigitalCoupon super;
        auto* v1 = dynamic_cast<Visitor<DigitalCmsSpreadCoupon>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            super::accept(v);
    }


    DigitalCmsSpreadLeg::DigitalCmsSpreadLeg(Schedule schedule,
                                             ext::shared_ptr<SwapSpreadIndex> index)
    : schedule_(std::move(schedule)), index_(std::move(index)), paymentAdjustment_(Following),
      inArrears_(false), longCallOption_(Position::Long), callATM_(false),
      longPutOption_(Position::Long), putATM_(false) {}

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withNotionals(Real notional) {
        notionals_ = std::vector<Real>(1,notional);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withNotionals(
                                         const std::vector<Real>& notionals) {
        notionals_ = notionals;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPaymentDayCounter(
                                               const DayCounter& dayCounter) {
        paymentDayCounter_ = dayCounter;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPaymentAdjustment(
                                           BusinessDayConvention convention) {
        paymentAdjustment_ = convention;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withFixingDays(Natural fixingDays) {
        fixingDays_ = std::vector<Natural>(1,fixingDays);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withFixingDays(
                                     const std::vector<Natural>& fixingDays) {
        fixingDays_ = fixingDays;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withGearings(Real gearing) {
        gearings_ = std::vector<Real>(1,gearing);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withGearings(
                                          const std::vector<Real>& gearings) {
        gearings_ = gearings;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withSpreads(Spread spread) {
        spreads_ = std::vector<Spread>(1,spread);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withSpreads(
                                         const std::vector<Spread>& spreads) {
        spreads_ = spreads;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::inArrears(bool flag) {
        inArrears_ = flag;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withCallStrikes(Rate strike) {
        callStrikes_ = std::vector<Rate>(1,strike);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withCallStrikes(
                                           const std::vector<Rate>& strikes) {
        callStrikes_ = strikes;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withLongCallOption(Position::Type type) {
        longCallOption_ = type;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withCallATM(bool flag) {
        callATM_ = flag;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withCallPayoffs(Rate payoff) {
        callPayoffs_ = std::vector<Rate>(1,payoff);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withCallPayoffs(
                                           const std::vector<Rate>& payoffs) {
        callPayoffs_ = payoffs;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPutStrikes(Rate strike) {
        putStrikes_ = std::vector<Rate>(1,strike);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPutStrikes(
                                           const std::vector<Rate>& strikes) {
        putStrikes_ = strikes;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withLongPutOption(Position::Type type) {
        longPutOption_ = type;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPutATM(bool flag) {
        putATM_ = flag;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPutPayoffs(Rate payoff) {
        putPayoffs_ = std::vector<Rate>(1,payoff);
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withPutPayoffs(
                                           const std::vector<Rate>& payoffs) {
        putPayoffs_ = payoffs;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withReplication(
                   const ext::shared_ptr<DigitalReplication>& replication) {
        replication_ = replication;
        return *this;
    }

    DigitalCmsSpreadLeg& DigitalCmsSpreadLeg::withNakedOption(bool nakedOption) {
        nakedOption_ = nakedOption;
        return *this;
    }

    DigitalCmsSpreadLeg::operator Leg() const {
        return FloatingDigitalLeg<SwapSpreadIndex, CmsSpreadCoupon, DigitalCmsSpreadCoupon>(
                            schedule_, notionals_, index_, paymentDayCounter_,
                            paymentAdjustment_, fixingDays_,
                            gearings_, spreads_, inArrears_,
                            callStrikes_, longCallOption_,
                            callATM_, callPayoffs_,
                            putStrikes_, longPutOption_,
                            putATM_, putPayoffs_,
                            replication_, nakedOption_);
    }

}
]]></document_content>
  </document>
  <document index="139">
    <source>coupons/digitalcmsspreadcoupon.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file digitalcmsspreadcoupon.hpp
    \brief Cms-spread-rate coupon with digital call/put option
*/

#ifndef quantlib_digital_cmsspread_coupon_hpp
#define quantlib_digital_cmsspread_coupon_hpp

#include <ql/cashflows/digitalcoupon.hpp>
#include <ql/experimental/coupons/cmsspreadcoupon.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    //! Cms-spread-rate coupon with digital digital call/put option
    class DigitalCmsSpreadCoupon : public DigitalCoupon {
      public:
        explicit DigitalCmsSpreadCoupon(
            const ext::shared_ptr<CmsSpreadCoupon> &underlying,
            Rate callStrike = Null<Rate>(),
            Position::Type callPosition = Position::Long,
            bool isCallATMIncluded = false,
            Rate callDigitalPayoff = Null<Rate>(),
            Rate putStrike = Null<Rate>(),
            Position::Type putPosition = Position::Long,
            bool isPutATMIncluded = false,
            Rate putDigitalPayoff = Null<Rate>(),
            const ext::shared_ptr<DigitalReplication> &replication =
                ext::shared_ptr<DigitalReplication>(new DigitalReplication),
            bool nakedOption = false);

        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
    };


    //! helper class building a sequence of digital ibor-rate coupons
    class DigitalCmsSpreadLeg {
      public:
        DigitalCmsSpreadLeg(Schedule schedule, ext::shared_ptr<SwapSpreadIndex> index);
        DigitalCmsSpreadLeg& withNotionals(Real notional);
        DigitalCmsSpreadLeg& withNotionals(const std::vector<Real>& notionals);
        DigitalCmsSpreadLeg& withPaymentDayCounter(const DayCounter&);
        DigitalCmsSpreadLeg& withPaymentAdjustment(BusinessDayConvention);
        DigitalCmsSpreadLeg& withFixingDays(Natural fixingDays);
        DigitalCmsSpreadLeg& withFixingDays(const std::vector<Natural>& fixingDays);
        DigitalCmsSpreadLeg& withGearings(Real gearing);
        DigitalCmsSpreadLeg& withGearings(const std::vector<Real>& gearings);
        DigitalCmsSpreadLeg& withSpreads(Spread spread);
        DigitalCmsSpreadLeg& withSpreads(const std::vector<Spread>& spreads);
        DigitalCmsSpreadLeg& inArrears(bool flag = true);
        DigitalCmsSpreadLeg& withCallStrikes(Rate strike);
        DigitalCmsSpreadLeg& withCallStrikes(const std::vector<Rate>& strikes);
        DigitalCmsSpreadLeg& withLongCallOption(Position::Type);
        DigitalCmsSpreadLeg& withCallATM(bool flag = true);
        DigitalCmsSpreadLeg& withCallPayoffs(Rate payoff);
        DigitalCmsSpreadLeg& withCallPayoffs(const std::vector<Rate>& payoffs);
        DigitalCmsSpreadLeg& withPutStrikes(Rate strike);
        DigitalCmsSpreadLeg& withPutStrikes(const std::vector<Rate>& strikes);
        DigitalCmsSpreadLeg& withLongPutOption(Position::Type);
        DigitalCmsSpreadLeg& withPutATM(bool flag = true);
        DigitalCmsSpreadLeg& withPutPayoffs(Rate payoff);
        DigitalCmsSpreadLeg& withPutPayoffs(const std::vector<Rate>& payoffs);
        DigitalCmsSpreadLeg& withReplication(
            const ext::shared_ptr<DigitalReplication> &replication =
                ext::shared_ptr<DigitalReplication>(new DigitalReplication));
        DigitalCmsSpreadLeg& withNakedOption(bool nakedOption = true);

        operator Leg() const;
      private:
        Schedule schedule_;
        ext::shared_ptr<SwapSpreadIndex> index_;
        std::vector<Real> notionals_;
        DayCounter paymentDayCounter_;
        BusinessDayConvention paymentAdjustment_;
        std::vector<Natural> fixingDays_;
        std::vector<Real> gearings_;
        std::vector<Spread> spreads_;
        bool inArrears_;
        std::vector<Rate> callStrikes_, callPayoffs_;
        Position::Type longCallOption_;
        bool callATM_;
        std::vector<Rate> putStrikes_, putPayoffs_;
        Position::Type longPutOption_;
        bool putATM_;
        ext::shared_ptr<DigitalReplication> replication_;
        bool nakedOption_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="140">
    <source>coupons/lognormalcmsspreadpricer.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
  Copyright (C) 2014, 2015, 2018 Peter Caspers

  This file is part of QuantLib, a free-software/open-source library
  for financial quantitative analysts and developers - http://quantlib.org/

  QuantLib is free software: you can redistribute it and/or modify it
  under the terms of the QuantLib license.  You should have received a
  copy of the license along with this program; if not, please email
  <quantlib-dev@lists.sf.net>. The license is also available online at
  <http://quantlib.org/license.shtml>.


  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details.
*/

/*! \file lognormalcmsspreadpricer.cpp
*/

#include <ql/experimental/coupons/cmsspreadcoupon.hpp>
#include <ql/experimental/coupons/lognormalcmsspreadpricer.hpp>
#include <ql/math/integrals/kronrodintegral.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube.hpp>
#include <utility>


using std::sqrt;

namespace QuantLib {

    class LognormalCmsSpreadPricer::integrand_f {
        const LognormalCmsSpreadPricer* pricer;
      public:
        explicit integrand_f(const LognormalCmsSpreadPricer* pricer)
        : pricer(pricer) {}
        Real operator()(Real x) const {
            return pricer->integrand(x);
        }
    };

    LognormalCmsSpreadPricer::LognormalCmsSpreadPricer(
        const ext::shared_ptr<CmsCouponPricer>& cmsPricer,
        const Handle<Quote>& correlation,
        Handle<YieldTermStructure> couponDiscountCurve,
        const Size integrationPoints,
        const boost::optional<VolatilityType>& volatilityType,
        const Real shift1,
        const Real shift2)
    : CmsSpreadCouponPricer(correlation), cmsPricer_(cmsPricer),
      couponDiscountCurve_(std::move(couponDiscountCurve)) {

        registerWith(correlation);
        if (!couponDiscountCurve_.empty())
            registerWith(couponDiscountCurve_);
        registerWith(cmsPricer_);

        QL_REQUIRE(integrationPoints >= 4,
                   "at least 4 integration points should be used ("
                       << integrationPoints << ")");
        integrator_ =
            ext::make_shared<GaussHermiteIntegration>(integrationPoints);

        cnd_ = ext::make_shared<CumulativeNormalDistribution>(0.0, 1.0);

        if(volatilityType == boost::none) {
            QL_REQUIRE(shift1 == Null<Real>() && shift2 == Null<Real>(),
                       "if volatility type is inherited, no shifts should be "
                       "specified");
            inheritedVolatilityType_ = true;
            volType_ = cmsPricer->swaptionVolatility()->volatilityType();
        } else {
            shift1_ = shift1 == Null<Real>() ? 0.0 : shift1;
            shift2_ = shift2 == Null<Real>() ? 0.0 : shift2;
            inheritedVolatilityType_ = false;
            volType_ = *volatilityType;
        }
    }

    Real LognormalCmsSpreadPricer::integrand(const Real x) const {

        // this is Brigo, 13.16.2 with x = v / sqrt(2)

        Real v = M_SQRT2 * x;
        Real h =
            k_ - b_ * s2_ * std::exp((m2_ - 0.5 * v2_ * v2_) * fixingTime_ +
                                     v2_ * std::sqrt(fixingTime_) * v);
        Real phi1, phi2;
        phi1 = (*cnd_)(
            phi_ * (std::log(a_ * s1_ / h) +
                    (m1_ + (0.5 - rho_ * rho_) * v1_ * v1_) * fixingTime_ +
                    rho_ * v1_ * std::sqrt(fixingTime_) * v) /
            (v1_ * std::sqrt(fixingTime_ * (1.0 - rho_ * rho_))));
        phi2 = (*cnd_)(
            phi_ * (std::log(a_ * s1_ / h) +
                    (m1_ - 0.5 * v1_ * v1_) * fixingTime_ +
                    rho_ * v1_ * std::sqrt(fixingTime_) * v) /
            (v1_ * std::sqrt(fixingTime_ * (1.0 - rho_ * rho_))));
        Real f = a_ * phi_ * s1_ *
                     std::exp(m1_ * fixingTime_ -
                              0.5 * rho_ * rho_ * v1_ * v1_ * fixingTime_ +
                              rho_ * v1_ * std::sqrt(fixingTime_) * v) *
                     phi1 -
                 phi_ * h * phi2;
        return std::exp(-x * x) * f;
    }

    Real LognormalCmsSpreadPricer::integrand_normal(const Real x) const {

        // this is http://ssrn.com/abstract=2686998, 3.20 with x = s / sqrt(2)

        Real s = M_SQRT2 * x;

        Real beta =
            phi_ *
            (gearing1_ * adjustedRate1_ + gearing2_ * adjustedRate2_ - k_ +
             std::sqrt(fixingTime_) *
                 (rho_ * gearing1_ * vol1_ + gearing2_ * vol2_) * s);
        Real f =
            close_enough(alpha_, 0.0)
                ? std::max(beta, 0.0)
                : psi_ * alpha_ / (M_SQRTPI * M_SQRT2) *
                          std::exp(-beta * beta / (2.0 * alpha_ * alpha_)) +
                      beta * (1.0 - (*cnd_)(-psi_ * beta / alpha_));
        return std::exp(-x * x) * f;
    }

    void
    LognormalCmsSpreadPricer::initialize(const FloatingRateCoupon &coupon) {

        coupon_ = dynamic_cast<const CmsSpreadCoupon *>(&coupon);
        QL_REQUIRE(coupon_, "CMS spread coupon needed");
        index_ = coupon_->swapSpreadIndex();
        gearing_ = coupon_->gearing();
        spread_ = coupon_->spread();

        fixingDate_ = coupon_->fixingDate();
        paymentDate_ = coupon_->date();

        // if no coupon discount curve is given just use the discounting curve
        // from the _first_ swap index.
        // for rate calculation this curve cancels out in the computation, so
        // e.g. the discounting
        // swap engine will produce correct results, even if the
        // couponDiscountCurve is not set here.
        // only the price member function in this class will be dependent on the
        // coupon discount curve.

        today_ = QuantLib::Settings::instance().evaluationDate();

        if (couponDiscountCurve_.empty())
            couponDiscountCurve_ =
                index_->swapIndex1()->exogenousDiscount()
                    ? index_->swapIndex1()->discountingTermStructure()
                    : index_->swapIndex1()->forwardingTermStructure();

        discount_ = paymentDate_ > couponDiscountCurve_->referenceDate()
                        ? couponDiscountCurve_->discount(paymentDate_)
                        : 1.0;

        spreadLegValue_ = spread_ * coupon_->accrualPeriod() * discount_;

        gearing1_ = index_->gearing1();
        gearing2_ = index_->gearing2();

        QL_REQUIRE(gearing1_ > 0.0 && gearing2_ < 0.0,
                   "gearing1 (" << gearing1_
                                << ") should be positive while gearing2 ("
                                << gearing2_ << ") should be negative");

        c1_ = ext::shared_ptr<CmsCoupon>(new CmsCoupon(
            coupon_->date(), coupon_->nominal(), coupon_->accrualStartDate(),
            coupon_->accrualEndDate(), coupon_->fixingDays(),
            index_->swapIndex1(), 1.0, 0.0, coupon_->referencePeriodStart(),
            coupon_->referencePeriodEnd(), coupon_->dayCounter(),
            coupon_->isInArrears()));

        c2_ = ext::shared_ptr<CmsCoupon>(new CmsCoupon(
            coupon_->date(), coupon_->nominal(), coupon_->accrualStartDate(),
            coupon_->accrualEndDate(), coupon_->fixingDays(),
            index_->swapIndex2(), 1.0, 0.0, coupon_->referencePeriodStart(),
            coupon_->referencePeriodEnd(), coupon_->dayCounter(),
            coupon_->isInArrears()));

        c1_->setPricer(cmsPricer_);
        c2_->setPricer(cmsPricer_);

        if (fixingDate_ > today_) {

            fixingTime_ = cmsPricer_->swaptionVolatility()->timeFromReference(
                fixingDate_);

            swapRate1_ = c1_->indexFixing();
            swapRate2_ = c2_->indexFixing();

            adjustedRate1_ = c1_->adjustedFixing();
            adjustedRate2_ = c2_->adjustedFixing();

            ext::shared_ptr<SwaptionVolatilityStructure> swvol =
                *cmsPricer_->swaptionVolatility();
            ext::shared_ptr<SwaptionVolatilityCube> swcub =
                ext::dynamic_pointer_cast<SwaptionVolatilityCube>(swvol);

            if(inheritedVolatilityType_ && volType_ == ShiftedLognormal) {
                shift1_ =
                    swvol->shift(fixingDate_, index_->swapIndex1()->tenor());
                shift2_ =
                    swvol->shift(fixingDate_, index_->swapIndex2()->tenor());
            }

            if (swcub == nullptr) {
                // not a cube, just an atm surface given, so we can
                // not easily convert volatilities and just forbid it
                QL_REQUIRE(inheritedVolatilityType_,
                           "if only an atm surface is given, the volatility "
                           "type must be inherited");
                vol1_ = swvol->volatility(
                    fixingDate_, index_->swapIndex1()->tenor(), swapRate1_);
                vol2_ = swvol->volatility(
                    fixingDate_, index_->swapIndex2()->tenor(), swapRate2_);
            } else {
                vol1_ = swcub->smileSection(fixingDate_,
                                            index_->swapIndex1()->tenor())
                            ->volatility(swapRate1_, volType_, shift1_);
                vol2_ = swcub->smileSection(fixingDate_,
                                            index_->swapIndex2()->tenor())
                            ->volatility(swapRate2_, volType_, shift2_);
            }

            if(volType_ == ShiftedLognormal) {
                mu1_ = 1.0 / fixingTime_ * std::log((adjustedRate1_ + shift1_) /
                                                    (swapRate1_ + shift1_));
                mu2_ = 1.0 / fixingTime_ * std::log((adjustedRate2_ + shift2_) /
                                                    (swapRate2_ + shift2_));
            }
            // for the normal volatility case we do not need the drifts
            // but rather use adjusted rates directly in the integrand

            rho_ = std::max(std::min(correlation()->value(), 0.9999),
                            -0.9999); // avoid division by zero in integrand
        } else {
            // fixing is in the past or today
            adjustedRate1_ = c1_->indexFixing();
            adjustedRate2_ = c2_->indexFixing();
        }
    }

    Real LognormalCmsSpreadPricer::optionletPrice(Option::Type optionType,
                                                  Real strike) const {
        // this method is only called for future fixings
        optionType_ = optionType;
        phi_ = optionType == Option::Call ? 1.0 : -1.0;
        Real res = 0.0;
        if (volType_ == ShiftedLognormal) {
            // (shifted) lognormal volatility
            if (strike >= 0.0) {
                a_ = gearing1_;
                b_ = gearing2_;
                s1_ = swapRate1_ + shift1_;
                s2_ = swapRate2_ + shift2_;
                m1_ = mu1_;
                m2_ = mu2_;
                v1_ = vol1_;
                v2_ = vol2_;
                k_ = strike + gearing1_ * shift1_ + gearing2_ * shift2_;
            } else {
                a_ = -gearing2_;
                b_ = -gearing1_;
                s1_ = swapRate2_ + shift1_;
                s2_ = swapRate1_ + shift2_;
                m1_ = mu2_;
                m2_ = mu1_;
                v1_ = vol2_;
                v2_ = vol1_;
                k_ = -strike - gearing1_ * shift1_ - gearing2_ * shift2_;
                res += phi_ * (gearing1_ * adjustedRate1_ +
                               gearing2_ * adjustedRate2_ - strike);
            }
            res +=
                1.0 / M_SQRTPI * (*integrator_)(integrand_f(this));
        } else {
            // normal volatility
            Real forward = gearing1_ * adjustedRate1_ +
                gearing2_ * adjustedRate2_;
            Real stddev =
                std::sqrt(fixingTime_ *
                          (gearing1_ * gearing1_ * vol1_ * vol1_ +
                           gearing2_ * gearing2_ * vol2_ * vol2_ +
                           2.0 * gearing1_ * gearing2_ * rho_ * vol1_ * vol2_));
            res =
                bachelierBlackFormula(optionType_, strike, forward, stddev, 1.0);
        }
        return res * discount_ * coupon_->accrualPeriod();
    }

    Rate LognormalCmsSpreadPricer::swapletRate() const {
        return swapletPrice() / (coupon_->accrualPeriod() * discount_);
    }

    Real LognormalCmsSpreadPricer::capletPrice(Rate effectiveCap) const {
        // caplet is equivalent to call option on fixing
        if (fixingDate_ <= today_) {
            // the fixing is determined
            const Rate Rs = std::max(
                coupon_->index()->fixing(fixingDate_) - effectiveCap, 0.);
            Rate price = gearing_ * Rs * coupon_->accrualPeriod() * discount_;
            return price;
        } else {
            Real capletPrice = optionletPrice(Option::Call, effectiveCap);
            return gearing_ * capletPrice;
        }
    }

    Rate LognormalCmsSpreadPricer::capletRate(Rate effectiveCap) const {
        return capletPrice(effectiveCap) /
               (coupon_->accrualPeriod() * discount_);
    }

    Real LognormalCmsSpreadPricer::floorletPrice(Rate effectiveFloor) const {
        // floorlet is equivalent to put option on fixing
        if (fixingDate_ <= today_) {
            // the fixing is determined
            const Rate Rs = std::max(
                effectiveFloor - coupon_->index()->fixing(fixingDate_), 0.);
            Rate price = gearing_ * Rs * coupon_->accrualPeriod() * discount_;
            return price;
        } else {
            Real floorletPrice = optionletPrice(Option::Put, effectiveFloor);
            return gearing_ * floorletPrice;
        }
    }

    Rate LognormalCmsSpreadPricer::floorletRate(Rate effectiveFloor) const {
        return floorletPrice(effectiveFloor) /
               (coupon_->accrualPeriod() * discount_);
    }

    Real LognormalCmsSpreadPricer::swapletPrice() const {
        return gearing_ * coupon_->accrualPeriod() * discount_ *
                   (gearing1_ * adjustedRate1_ + gearing2_ * adjustedRate2_) +
               spreadLegValue_;
    }
}
]]></document_content>
  </document>
  <document index="141">
    <source>coupons/lognormalcmsspreadpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2014, 2015, 2018 Peter Caspers

  This file is part of QuantLib, a free-software/open-source library
  for financial quantitative analysts and developers - http://quantlib.org/

  QuantLib is free software: you can redistribute it and/or modify it
  under the terms of the QuantLib license.  You should have received a
  copy of the license along with this program; if not, please email
  <quantlib-dev@lists.sf.net>. The license is also available online at
  <http://quantlib.org/license.shtml>.


  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

/*! \file lognormalcmsspreadpricer.hpp
    \brief cms spread coupon pricer as in Brigo, Mercurio, 13.6.2, with
           extensions for shifted lognormal and normal dynamics as
           described in http://ssrn.com/abstract=2686998
*/

#ifndef quantlib_lognormal_cmsspread_pricer_hpp
#define quantlib_lognormal_cmsspread_pricer_hpp

#include <ql/cashflows/cmscoupon.hpp>
#include <ql/experimental/coupons/cmsspreadcoupon.hpp>
#include <ql/experimental/coupons/swapspreadindex.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    class CmsSpreadCoupon;
    class YieldTermStructure;

    //! CMS spread - coupon pricer
    /*! The swap rate adjustments are computed using the given
        volatility structures for the underlyings in every case
        (w.r.t. volatility type and shift).

        For the bivariate spread model, the volatility type and
        the shifts can be inherited (default), or explicitly
        specified. In the latter case the type, and (if lognormal)
        the shifts must be given (or are defaulted to zero, if not
        given).

        References:

        Brigo, Mercurio: Interst Rate Models - Theory and Practice,
        2nd Edition, Springer, 2006, chapter 13.6.2

        http://ssrn.com/abstract=2686998
    */

    class LognormalCmsSpreadPricer : public CmsSpreadCouponPricer {

      public:
        LognormalCmsSpreadPricer(
            const ext::shared_ptr<CmsCouponPricer>& cmsPricer,
            const Handle<Quote>& correlation,
            Handle<YieldTermStructure> couponDiscountCurve = Handle<YieldTermStructure>(),
            Size IntegrationPoints = 16,
            const boost::optional<VolatilityType>& volatilityType = boost::none,
            Real shift1 = Null<Real>(),
            Real shift2 = Null<Real>());

        /* */
        Real swapletPrice() const override;
        Rate swapletRate() const override;
        Real capletPrice(Rate effectiveCap) const override;
        Rate capletRate(Rate effectiveCap) const override;
        Real floorletPrice(Rate effectiveFloor) const override;
        Rate floorletRate(Rate effectiveFloor) const override;

      private:
        void initialize(const FloatingRateCoupon& coupon) override;
        Real optionletPrice(Option::Type optionType, Real strike) const;

        Real integrand(Real) const;
        Real integrand_normal(Real) const;

        class integrand_f;
        friend class integrand_f;

        ext::shared_ptr<CmsCouponPricer> cmsPricer_;

        Handle<YieldTermStructure> couponDiscountCurve_;

        const CmsSpreadCoupon *coupon_;

        Date today_, fixingDate_, paymentDate_;

        Real fixingTime_;

        Real gearing_, spread_;
        Real spreadLegValue_;
        Real discount_;

        ext::shared_ptr<SwapSpreadIndex> index_;

        ext::shared_ptr<CumulativeNormalDistribution> cnd_;
        ext::shared_ptr<GaussianQuadrature> integrator_;

        Real swapRate1_, swapRate2_, gearing1_, gearing2_;
        Real adjustedRate1_, adjustedRate2_;
        Real vol1_, vol2_;
        Real mu1_, mu2_;
        Real rho_;

        bool inheritedVolatilityType_;
        VolatilityType volType_;
        Real shift1_, shift2_;

        mutable Real phi_, a_, b_, s1_, s2_, m1_, m2_, v1_, v2_, k_;
        mutable Real alpha_, psi_;
        mutable Option::Type optionType_;

        ext::shared_ptr<CmsCoupon> c1_, c2_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="142">
    <source>coupons/proxyibor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/coupons/proxyibor.hpp>
#include <utility>

namespace QuantLib {

    ProxyIbor::ProxyIbor(const std::string& familyName,
                         const Period& tenor,
                         Natural settlementDays,
                         const Currency& currency,
                         const Calendar& fixingCalendar,
                         BusinessDayConvention convention,
                         bool endOfMonth,
                         const DayCounter& dayCounter,
                         Handle<Quote> gearing,
                         ext::shared_ptr<IborIndex> iborIndex,
                         Handle<Quote> spread)
    : IborIndex(familyName,
                tenor,
                settlementDays,
                currency,
                fixingCalendar,
                convention,
                endOfMonth,
                dayCounter),
      gearing_(std::move(gearing)), iborIndex_(std::move(iborIndex)), spread_(std::move(spread)) {
        registerWith(iborIndex_);
    }
}
]]></document_content>
  </document>
  <document index="143">
    <source>coupons/proxyibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file proxyibor.hpp
    \brief IborIndex calculated as proxy of some other IborIndex
*/

#ifndef quantlib_proxyibor_hpp
#define quantlib_proxyibor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! IborIndex calculated as proxy of some other IborIndex
    class ProxyIbor : public IborIndex {
      public:
        ProxyIbor(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  BusinessDayConvention convention,
                  bool endOfMonth,
                  const DayCounter& dayCounter,
                  Handle<Quote> gearing,
                  ext::shared_ptr<IborIndex> iborIndex,
                  Handle<Quote> spread);

      private:
        // overload
        Rate forecastFixing(const Date& fixingDate) const override;

        Handle<Quote> gearing_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Handle<Quote> spread_;
    };

    inline Rate ProxyIbor::forecastFixing(const Date& fixingDate) const {
        Rate proxy = iborIndex_->fixing(fixingDate);
        return gearing_->value() * proxy * spread_->value();
    }

}

#endif
]]></document_content>
  </document>
  <document index="144">
    <source>coupons/quantocouponpricer.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Toyin Akin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/coupons/quantocouponpricer.hpp>
#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/digitalcoupon.hpp>
#include <ql/cashflows/digitalcmscoupon.hpp>
#include <ql/cashflows/digitaliborcoupon.hpp>
#include <ql/cashflows/rangeaccrual.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/indexes/interestrateindex.hpp>

namespace QuantLib {

    Rate BlackIborQuantoCouponPricer::adjustedFixing(Real fixing) const {

        if (fixing == Null<Rate>())
            fixing = coupon_->indexFixing();

        // Here we apply the quanto adjustment first, then delegate to
        // the parent class
        Date d1 = coupon_->fixingDate(),
             referenceDate = capletVolatility()->referenceDate();

        if (d1 > referenceDate) {
            Time t1 =
                capletVolatility()->timeFromReference(d1);
            Volatility fxsigma =
                fxRateBlackVolatility_->blackVol(d1, fixing, true);
            Volatility sigma = capletVolatility()->volatility(d1, fixing);
            Real rho = underlyingFxCorrelation_->value();

            // Apply Quanto Adjustment.
            // Hull 6th Edition, page 642, generalised to
            // shifted lognormal and normal volatilities
            if(capletVolatility()->volatilityType() == ShiftedLognormal) {
                Real dQuantoAdj = std::exp(sigma*fxsigma*rho*t1);
                Real shift = capletVolatility()->displacement();
                fixing = (fixing+shift)*dQuantoAdj-shift;
            }
            else {
                Real dQuantoAdj = sigma*fxsigma*rho*t1;
                fixing += dQuantoAdj;
            }
        }

        return BlackIborCouponPricer::adjustedFixing(fixing);
    }

}

]]></document_content>
  </document>
  <document index="145">
    <source>coupons/quantocouponpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Toyin Akin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantocouponpricer.hpp
    \brief quanto-adjusted coupon
*/

#ifndef quantlib_coupon_quanto_pricer_hpp
#define quantlib_coupon_quanto_pricer_hpp

#include <ql/cashflows/couponpricer.hpp>
#include <ql/quote.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <utility>

namespace QuantLib {

    class BlackIborQuantoCouponPricer : public BlackIborCouponPricer {
      public:
        BlackIborQuantoCouponPricer(Handle<BlackVolTermStructure> fxRateBlackVolatility,
                                    Handle<Quote> underlyingFxCorrelation,
                                    const Handle<OptionletVolatilityStructure>& capletVolatility)
        : BlackIborCouponPricer(capletVolatility),
          fxRateBlackVolatility_(std::move(fxRateBlackVolatility)),
          underlyingFxCorrelation_(std::move(underlyingFxCorrelation)) {
            registerWith(fxRateBlackVolatility_);
            registerWith(underlyingFxCorrelation_);
        }

      protected:
        Rate adjustedFixing(Rate fixing = Null<Rate>()) const override;

      private:
        Handle<BlackVolTermStructure> fxRateBlackVolatility_;
        Handle<Quote> underlyingFxCorrelation_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="146">
    <source>coupons/strippedcapflooredcoupon.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/couponpricer.hpp>
#include <ql/experimental/coupons/strippedcapflooredcoupon.hpp>
#include <utility>

namespace QuantLib {

    StrippedCappedFlooredCoupon::StrippedCappedFlooredCoupon(
        const ext::shared_ptr<CappedFlooredCoupon> &underlying)
        : FloatingRateCoupon(
              underlying->date(), underlying->nominal(),
              underlying->accrualStartDate(), underlying->accrualEndDate(),
              underlying->fixingDays(), underlying->index(),
              underlying->gearing(), underlying->spread(),
              underlying->referencePeriodStart(),
              underlying->referencePeriodEnd(), underlying->dayCounter(),
              underlying->isInArrears()),
          underlying_(underlying) {
        registerWith(underlying);
    }

    Rate StrippedCappedFlooredCoupon::rate() const {

        QL_REQUIRE(underlying_->underlying()->pricer() != nullptr, "pricer not set");
        underlying_->underlying()->pricer()->initialize(*underlying_->underlying());
        Rate floorletRate = 0.0;
        if (underlying_->isFloored())
            floorletRate = underlying_->underlying()->pricer()->floorletRate(
                underlying_->effectiveFloor());
        Rate capletRate = 0.0;
        if (underlying_->isCapped())
            capletRate =
                underlying_->underlying()->pricer()->capletRate(underlying_->effectiveCap());

        // if the underlying is collared we return the value of the embedded
        // collar, otherwise the value of a long floor or a long cap respectively

        return (underlying_->isFloored() && underlying_->isCapped())
                   ? floorletRate - capletRate
                   : floorletRate + capletRate;
    }

    Rate StrippedCappedFlooredCoupon::convexityAdjustment() const {
        return underlying_->convexityAdjustment();
    }

    Rate StrippedCappedFlooredCoupon::cap() const { return underlying_->cap(); }

    Rate StrippedCappedFlooredCoupon::floor() const {
        return underlying_->floor();
    }

    Rate StrippedCappedFlooredCoupon::effectiveCap() const {
        return underlying_->effectiveCap();
    }

    Rate StrippedCappedFlooredCoupon::effectiveFloor() const {
        return underlying_->effectiveFloor();
    }

    void StrippedCappedFlooredCoupon::update() { notifyObservers(); }

    void StrippedCappedFlooredCoupon::accept(AcyclicVisitor &v) {
        underlying_->accept(v);
        auto* v1 = dynamic_cast<Visitor<StrippedCappedFlooredCoupon>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            FloatingRateCoupon::accept(v);
    }

    bool StrippedCappedFlooredCoupon::isCap() const {
        return underlying_->isCapped();
    }

    bool StrippedCappedFlooredCoupon::isFloor() const {
        return underlying_->isFloored();
    }

    bool StrippedCappedFlooredCoupon::isCollar() const {
        return isCap() && isFloor();
    }

    void StrippedCappedFlooredCoupon::setPricer(
        const ext::shared_ptr<FloatingRateCouponPricer> &pricer) {
        FloatingRateCoupon::setPricer(pricer);
        underlying_->setPricer(pricer);
    }

    StrippedCappedFlooredCouponLeg::StrippedCappedFlooredCouponLeg(Leg underlyingLeg)
    : underlyingLeg_(std::move(underlyingLeg)) {}

    StrippedCappedFlooredCouponLeg::operator Leg() const {
        Leg resultLeg;
        resultLeg.reserve(underlyingLeg_.size());
        ext::shared_ptr<CappedFlooredCoupon> c;
        for (const auto& i : underlyingLeg_) {
            if ((c = ext::dynamic_pointer_cast<CappedFlooredCoupon>(i)) != nullptr) {
                resultLeg.push_back(
                    ext::make_shared<StrippedCappedFlooredCoupon>(c));
            } else {
                resultLeg.push_back(i);
            }
        }
        return resultLeg;
    }
}
]]></document_content>
  </document>
  <document index="147">
    <source>coupons/strippedcapflooredcoupon.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file strippedcapflooredcoupon.hpp
    \brief strips the embedded option from cap floored coupons
*/

#ifndef quantlib_stripped_capfloored_coupon_hpp
#define quantlib_stripped_capfloored_coupon_hpp

#include <ql/cashflows/capflooredcoupon.hpp>

namespace QuantLib {

    class StrippedCappedFlooredCoupon : public FloatingRateCoupon {

    public:

        explicit StrippedCappedFlooredCoupon(const ext::shared_ptr<CappedFlooredCoupon> &underlying);

        //! Coupon interface
        Rate rate() const override;
        Rate convexityAdjustment() const override;
        //! cap
        Rate cap() const;
        //! floor
        Rate floor() const;
        //! effective cap
        Rate effectiveCap() const;
        //! effective floor
        Rate effectiveFloor() const;

        //! Observer interface
        void update() override;

        //! Visitability
        void accept(AcyclicVisitor&) override;

        bool isCap() const;
        bool isFloor() const;
        bool isCollar() const;

        void setPricer(const ext::shared_ptr<FloatingRateCouponPricer>& pricer) override;

        ext::shared_ptr<CappedFlooredCoupon> underlying() { return underlying_; }

      protected:
        ext::shared_ptr<CappedFlooredCoupon> underlying_;

    };

    class StrippedCappedFlooredCouponLeg {
      public:
        explicit StrippedCappedFlooredCouponLeg(Leg underlyingLeg);
        operator Leg() const;
      private:
        Leg underlyingLeg_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="148">
    <source>coupons/swapspreadindex.cpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

#include <ql/experimental/coupons/swapspreadindex.hpp>
#include <iomanip>
#include <sstream>
#include <utility>

namespace QuantLib {

    SwapSpreadIndex::SwapSpreadIndex(const std::string& familyName,
                                     const ext::shared_ptr<SwapIndex>& swapIndex1,
                                     ext::shared_ptr<SwapIndex> swapIndex2,
                                     const Real gearing1,
                                     const Real gearing2)
    : InterestRateIndex(familyName,
                        swapIndex1->tenor(), // does not make sense, but we have to provide one
                        swapIndex1->fixingDays(),
                        swapIndex1->currency(),
                        swapIndex1->fixingCalendar(),
                        swapIndex1->dayCounter()),
      swapIndex1_(swapIndex1), swapIndex2_(std::move(swapIndex2)), gearing1_(gearing1),
      gearing2_(gearing2) {

        registerWith(swapIndex1_);
        registerWith(swapIndex2_);

        std::ostringstream name;
        name << std::setprecision(4) << std::fixed << swapIndex1_->name() << "("
             << gearing1 << ") + " << swapIndex2_->name() << "(" << gearing2
             << ")";
        name_ = name.str();

        QL_REQUIRE(swapIndex1_->fixingDays() == swapIndex2_->fixingDays(),
                   "index1 fixing days ("
                       << swapIndex1_->fixingDays() << ")"
                       << "must be equal to index2 fixing days ("
                       << swapIndex2_->fixingDays() << ")");

        QL_REQUIRE(swapIndex1_->fixingCalendar() ==
                       swapIndex2_->fixingCalendar(),
                   "index1 fixingCalendar ("
                       << swapIndex1_->fixingCalendar() << ")"
                       << "must be equal to index2 fixingCalendar ("
                       << swapIndex2_->fixingCalendar() << ")");

        QL_REQUIRE(swapIndex1_->currency() == swapIndex2_->currency(),
                   "index1 currency (" << swapIndex1_->currency() << ")"
                                       << "must be equal to index2 currency ("
                                       << swapIndex2_->currency() << ")");

        QL_REQUIRE(swapIndex1_->dayCounter() == swapIndex2_->dayCounter(),
                   "index1 dayCounter ("
                       << swapIndex1_->dayCounter() << ")"
                       << "must be equal to index2 dayCounter ("
                       << swapIndex2_->dayCounter() << ")");

        QL_REQUIRE(swapIndex1_->fixedLegTenor() == swapIndex2_->fixedLegTenor(),
                   "index1 fixedLegTenor ("
                       << swapIndex1_->fixedLegTenor() << ")"
                       << "must be equal to index2 fixedLegTenor ("
                       << swapIndex2_->fixedLegTenor());

        QL_REQUIRE(swapIndex1_->fixedLegConvention() ==
                       swapIndex2_->fixedLegConvention(),
                   "index1 fixedLegConvention ("
                       << swapIndex1_->fixedLegConvention() << ")"
                       << "must be equal to index2 fixedLegConvention ("
                       << swapIndex2_->fixedLegConvention());
    }
}
]]></document_content>
  </document>
  <document index="149">
    <source>coupons/swapspreadindex.hpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

/*! \file swapspreadindex.hpp
    \brief swap-rate spread indexes
*/

#ifndef quantlib_swapspreadindex_hpp
#define quantlib_swapspreadindex_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! class for swap-rate spread indexes
    class SwapSpreadIndex : public InterestRateIndex {
      public:
        SwapSpreadIndex(const std::string& familyName,
                        const ext::shared_ptr<SwapIndex>& swapIndex1,
                        ext::shared_ptr<SwapIndex> swapIndex2,
                        Real gearing1 = 1.0,
                        Real gearing2 = -1.0);

        //! \name InterestRateIndex interface
        //@{
        Date maturityDate(const Date& valueDate) const override {
            QL_FAIL("SwapSpreadIndex does not provide a single maturity date");
        }
        Rate forecastFixing(const Date& fixingDate) const override;
        Rate pastFixing(const Date& fixingDate) const override;
        bool allowsNativeFixings() override { return false; }
        //@}

        //! \name Inspectors
        //@{
        ext::shared_ptr<SwapIndex> swapIndex1() { return swapIndex1_; }
        ext::shared_ptr<SwapIndex> swapIndex2() { return swapIndex2_; }
        Real gearing1() const { return gearing1_; }
        Real gearing2() const { return gearing2_; }
        //@}


    private:
        ext::shared_ptr<SwapIndex> swapIndex1_, swapIndex2_;
        Real gearing1_, gearing2_;
    };


    inline Rate SwapSpreadIndex::forecastFixing(const Date& fixingDate) const {
        // this also handles the case when one of indices has
        // a historic fixing on the evaluation date
        return gearing1_ * swapIndex1_->fixing(fixingDate,false) +
            gearing2_ * swapIndex2_->fixing(fixingDate,false);

    }

    inline Rate SwapSpreadIndex::pastFixing(const Date& fixingDate) const {

        Real f1 = swapIndex1_->pastFixing(fixingDate);
        Real f2 = swapIndex2_->pastFixing(fixingDate);
        // if one of the fixings is missing we return null, indicating
        // a missing fixing for the spread index
        if(f1 == Null<Real>() || f2 == Null<Real>())
            return Null<Real>();
        else
            return gearing1_ * f1 + gearing2_ * f2;
    }

}

#endif
]]></document_content>
  </document>
  <document index="150">
    <source>credit/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    basecorrelationlossmodel.hpp \
    basecorrelationstructure.hpp \
    basket.hpp \
    binomiallossmodel.hpp \
    blackcdsoptionengine.hpp \
    cdo.hpp \
    cdsoption.hpp \
    constantlosslatentmodel.hpp \
    correlationstructure.hpp \
    defaultevent.hpp \
    defaultlossmodel.hpp \
    defaultprobabilitykey.hpp \
    defaultprobabilitylatentmodel.hpp \
    defaulttype.hpp \
    distribution.hpp \
    factorspreadedhazardratecurve.hpp \
    gaussianlhplossmodel.hpp \
    homogeneouspooldef.hpp \
    inhomogeneouspooldef.hpp \
    integralcdoengine.hpp \
    integralntdengine.hpp \
    interpolatedaffinehazardratecurve.hpp \
    issuer.hpp \
    loss.hpp \
    lossdistribution.hpp \
    midpointcdoengine.hpp \
    nthtodefault.hpp \
    onefactoraffinesurvival.hpp \
    onefactorcopula.hpp \
    onefactorgaussiancopula.hpp \
    onefactorstudentcopula.hpp \
    pool.hpp \
    randomdefaultlatentmodel.hpp \
    randomdefaultmodel.hpp \
    randomlosslatentmodel.hpp \
    recoveryratemodel.hpp \
    recoveryratequote.hpp \
    recursivelossmodel.hpp \
    riskyassetswap.hpp \
    riskyassetswapoption.hpp \
    riskybond.hpp \
    saddlepointlossmodel.hpp \
    spotlosslatentmodel.hpp \
    spreadedhazardratecurve.hpp \
    syntheticcdo.hpp

cpp_files = \
    basecorrelationstructure.cpp \
    basket.cpp \
    blackcdsoptionengine.cpp \
    cdo.cpp \
    cdsoption.cpp \
    correlationstructure.cpp \
    defaultevent.cpp \
    defaultprobabilitykey.cpp \
    defaulttype.cpp \
    distribution.cpp \
    gaussianlhplossmodel.cpp \
    integralcdoengine.cpp \
    integralntdengine.cpp \
    issuer.cpp \
    lossdistribution.cpp \
    midpointcdoengine.cpp \
    nthtodefault.cpp \
    onefactorcopula.cpp \
    onefactorgaussiancopula.cpp \
    onefactorstudentcopula.cpp \
    pool.cpp \
    randomdefaultmodel.cpp \
    recoveryratemodel.cpp \
    recoveryratequote.cpp \
    riskyassetswap.cpp \
    riskyassetswapoption.cpp \
    riskybond.cpp \
    syntheticcdo.cpp

if UNITY_BUILD

nodist_libCredit_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libCredit_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libCredit.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="151">
    <source>credit/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/credit/basecorrelationlossmodel.hpp>
#include <ql/experimental/credit/basecorrelationstructure.hpp>
#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/binomiallossmodel.hpp>
#include <ql/experimental/credit/blackcdsoptionengine.hpp>
#include <ql/experimental/credit/cdo.hpp>
#include <ql/experimental/credit/cdsoption.hpp>
#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/correlationstructure.hpp>
#include <ql/experimental/credit/defaultevent.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#include <ql/experimental/credit/defaultprobabilitylatentmodel.hpp>
#include <ql/experimental/credit/defaulttype.hpp>
#include <ql/experimental/credit/distribution.hpp>
#include <ql/experimental/credit/factorspreadedhazardratecurve.hpp>
#include <ql/experimental/credit/gaussianlhplossmodel.hpp>
#include <ql/experimental/credit/homogeneouspooldef.hpp>
#include <ql/experimental/credit/inhomogeneouspooldef.hpp>
#include <ql/experimental/credit/integralcdoengine.hpp>
#include <ql/experimental/credit/integralntdengine.hpp>
#include <ql/experimental/credit/interpolatedaffinehazardratecurve.hpp>
#include <ql/experimental/credit/issuer.hpp>
#include <ql/experimental/credit/loss.hpp>
#include <ql/experimental/credit/lossdistribution.hpp>
#include <ql/experimental/credit/midpointcdoengine.hpp>
#include <ql/experimental/credit/nthtodefault.hpp>
#include <ql/experimental/credit/onefactoraffinesurvival.hpp>
#include <ql/experimental/credit/onefactorcopula.hpp>
#include <ql/experimental/credit/onefactorgaussiancopula.hpp>
#include <ql/experimental/credit/onefactorstudentcopula.hpp>
#include <ql/experimental/credit/pool.hpp>
#include <ql/experimental/credit/randomdefaultlatentmodel.hpp>
#include <ql/experimental/credit/randomdefaultmodel.hpp>
#include <ql/experimental/credit/randomlosslatentmodel.hpp>
#include <ql/experimental/credit/recoveryratemodel.hpp>
#include <ql/experimental/credit/recoveryratequote.hpp>
#include <ql/experimental/credit/recursivelossmodel.hpp>
#include <ql/experimental/credit/riskyassetswap.hpp>
#include <ql/experimental/credit/riskyassetswapoption.hpp>
#include <ql/experimental/credit/riskybond.hpp>
#include <ql/experimental/credit/saddlepointlossmodel.hpp>
#include <ql/experimental/credit/spotlosslatentmodel.hpp>
#include <ql/experimental/credit/spreadedhazardratecurve.hpp>
#include <ql/experimental/credit/syntheticcdo.hpp>

]]></document_content>
  </document>
  <document index="152">
    <source>credit/basecorrelationlossmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_base_correl_lossmodel_hpp
#define quantlib_base_correl_lossmodel_hpp


#include <ql/quote.hpp>
#include <ql/quotes/simplequote.hpp>

#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/experimental/credit/basecorrelationstructure.hpp>

// move these to the CPP (and the template spezs)
#include <ql/experimental/credit/binomiallossmodel.hpp>
#include <ql/experimental/credit/gaussianlhplossmodel.hpp>
#include <ql/experimental/credit/inhomogeneouspooldef.hpp>
#include <utility>

namespace QuantLib {

    /*! Base Correlation loss model; interpolation is performed by portfolio 
    (live) amount percentage.\par
    Though the literature on this model is inmense, see for a more than 
    introductory level (precrisis) chapters 19, 20 and 21 of <b>Modelling single
    name and multi-name credit derivatives.</b> Dominic O'Kane, Wiley Finance, 
    2008\par
    For freely available documentation see:\par
    Credit Correlation: A Guide; JP Morgan Credit Derivatives Strategy; 
        12 March 2004 \par
    Introducing Base Correlations; JP Morgan Credit Derivatives Strategy; 
        22 March 2004 \par
    A Relative Value Framework for Credit Correlation; JP Morgan Credit 
        Derivatives Strategy; 27 April 2004 \par
    Valuing and Hedging Synthetic CDO Tranches Using Base Correlations; Bear 
        Stearns; May 17, 2004 \par
    Correlation Primer; Nomura Fixed Income Research, August 6, 2004 \par
    Base Correlation Explained; Lehman Brothers Fixed Income Quantitative 
        Credit Research; 15 November 2004 \par
    'Pricing CDOs with a smile' in Societe Generale Credit Research; 
        February 2005 \par
    For bespoke base correlation see: \par
    Base Correlation Mapping in Lehman Brothers' Quantitative Credit Research 
        Quarterly; Volume 2007-Q1 \par
    You can explore typical postcrisis data by perusing some of the JPMorgan 
    Global Correlation Daily Analytics \par
    Here the crisis model problems of ability to price stressed portfolios 
    or tranches over the maximum loss are the responsibility of the base models.
    Users should select their models according to this; choosing the copula or
    a random loss given default base model (or more exotic ones). \par
    Notice this is different to a bespoke base correlation loss (bespoke here 
    refering to basket composition, not just attachment levels) ; where 
    loss interpolation is on the expected loss value to match the two baskets. 
    Therefore the correlation surface should refer to the same basket intended
    to be priced. But this is left to the user and is not implemented in the 
    correlation surface (yet...)

    \todo Bespoke portfolios BC models are yet to be implemented.

    BaseModel_T must have a constructor with a single quote value
    */
    /* Criticism:
    This model is not as generic as it could be. In principle a default loss 
    model dependent on a single factor correlation parameter is the only 
    restriction on the base loss model(s) type. This class however is tied to a 
    LatentModel single factor. But there is no need for the 
    underlying model to be of a latent type. This link is due to the copula 
    initialization traits which have to be present for non trivial copula 
    policies initialization (e.g. Student-T base correl models)

    Maybe a possibility is to pass copiable instances of the model and relinking
    to the correlation in two internal copies.
    */
    template <class BaseModel_T, class Corr2DInt_T>
    class BaseCorrelationLossModel : public DefaultLossModel, 
        public virtual Observer {
    private:
        typedef typename BaseModel_T::copulaType::initTraits initTraits;
    public:
      BaseCorrelationLossModel(const Handle<BaseCorrelationTermStructure<Corr2DInt_T> >& correlTS,
                               std::vector<Real> recoveries,
                               const initTraits& traits = initTraits())
      : localCorrelationAttach_(ext::make_shared<SimpleQuote>(0.)),
        localCorrelationDetach_(ext::make_shared<SimpleQuote>(0.)),
        recoveries_(std::move(recoveries)), correlTS_(correlTS), copulaTraits_(traits) {
          registerWith(correlTS);
          registerWith(Settings::instance().evaluationDate());
      }

    private:
        // react to base correl surface notifications (quotes or reference date)
      void update() override {
          setupModels();
          // tell basket to notify instruments, etc, we are invalid
          if (!basket_.empty())
              basket_->notifyObservers();
      }

        /* Update model caches after basket assignement. */
      void resetModel() override {
          remainingNotional_ = basket_->remainingNotional();
          attachRatio_ = basket_->remainingAttachmentAmount() / remainingNotional_;
          detachRatio_ = basket_->remainingDetachmentAmount() / remainingNotional_;

          basketAttach_ = ext::make_shared<Basket>(basket_->refDate(), basket_->remainingNames(),
                                                   basket_->remainingNotionals(), basket_->pool(),
                                                   0.0, attachRatio_, basket_->claim());
          basketDetach_ = ext::make_shared<Basket>(basket_->refDate(), basket_->remainingNames(),
                                                   basket_->remainingNotionals(), basket_->pool(),
                                                   0.0, detachRatio_, basket_->claim());
          setupModels();
      }
        /* Most of the statistics are not implemented, not impossible but
        the model is intended for pricing rather than ptfolio risk management.
        */
      Real expectedTrancheLoss(const Date& d) const override;

    protected:
        /*! Sets up attach/detach models. Gets called on basket update. 
        To be specialized on the spacific model type.
        */
        void setupModels() const;
    private:
        mutable Real attachRatio_, detachRatio_;
        mutable Real remainingNotional_;

        //! Correlation buffer to pick up values from the surface and 
        //  trigger calculation.
        ext::shared_ptr<SimpleQuote> localCorrelationAttach_, 
            localCorrelationDetach_;
        mutable ext::shared_ptr<Basket> basketAttach_,
            basketDetach_;
        // just cached for the update method
        mutable std::vector<Real> recoveries_;
        Handle<BaseCorrelationTermStructure<Corr2DInt_T> > correlTS_;
        // Initialization parameters for models copula
        mutable typename BaseModel_T::copulaType::initTraits copulaTraits_;
        // Models of equity baskets.
        mutable ext::shared_ptr<BaseModel_T> scalarCorrelModelAttach_;
        mutable ext::shared_ptr<BaseModel_T> scalarCorrelModelDetach_;
    };


    // Remember ETL returns the EL on the live part of the basket. 
    template<class LM, class I>
    Real BaseCorrelationLossModel<LM, I>::expectedTrancheLoss(
        const Date& d) const 
    {
        Real correlK1 = correlTS_->correlation(d, attachRatio_);
        Real correlK2 = correlTS_->correlation(d, detachRatio_);

        /* reset correl and call base models which have the different baskets 
        associated.*/
        localCorrelationAttach_->setValue(correlK1);
        Real expLossK1 = 
            basketAttach_->expectedTrancheLoss(d);
        localCorrelationDetach_->setValue(correlK2);
        Real expLossK2 = 
            basketDetach_->expectedTrancheLoss(d);
        return expLossK2 - expLossK1;
    }


    // ----------------------------------------------------------------------


    /* Concrete specializations submodels construction. With the dummy template 
    parameter trick partial specializations leaving the interpolation open 
    would be possible.
    */

    #ifndef QL_PATCH_SOLARIS

    template<>
    inline void BaseCorrelationLossModel<GaussianLHPLossModel, 
        BilinearInterpolation>::setupModels() const 
    {
        // on this assignment any previous registration with the attach and 
        //   detach baskets should be removed
        scalarCorrelModelAttach_ = ext::make_shared<GaussianLHPLossModel>(
            Handle<Quote>(localCorrelationAttach_), recoveries_);
        scalarCorrelModelDetach_ = ext::make_shared<GaussianLHPLossModel>(
            Handle<Quote>(localCorrelationDetach_), recoveries_);

        basketAttach_->setLossModel(scalarCorrelModelAttach_);
        basketDetach_->setLossModel(scalarCorrelModelDetach_);
    }

    template<>
    inline void BaseCorrelationLossModel<GaussianBinomialLossModel, 
        BilinearInterpolation>::setupModels() const 
    {
        ext::shared_ptr<GaussianConstantLossLM> lmA = 
            ext::make_shared<GaussianConstantLossLM>(
                Handle<Quote>(localCorrelationAttach_), recoveries_, 
                LatentModelIntegrationType::GaussianQuadrature, 
                recoveries_.size(), copulaTraits_);
        ext::shared_ptr<GaussianConstantLossLM> lmD = 
            ext::make_shared<GaussianConstantLossLM>(
                Handle<Quote>(localCorrelationDetach_), recoveries_, 
                LatentModelIntegrationType::GaussianQuadrature, 
                recoveries_.size(), copulaTraits_);
        scalarCorrelModelAttach_ = 
            ext::make_shared<GaussianBinomialLossModel>(lmA);
        scalarCorrelModelDetach_ = 
            ext::make_shared<GaussianBinomialLossModel>(lmD);
            
        basketAttach_->setLossModel(scalarCorrelModelAttach_);
        basketDetach_->setLossModel(scalarCorrelModelDetach_);

    }

    template<>
    inline void BaseCorrelationLossModel<TBinomialLossModel, 
        BilinearInterpolation>::setupModels() const 
    {
        ext::shared_ptr<TConstantLossLM> lmA = 
            ext::make_shared<TConstantLossLM>(
                Handle<Quote>(localCorrelationAttach_), recoveries_, 
                LatentModelIntegrationType::GaussianQuadrature, 
                recoveries_.size(), copulaTraits_);
        ext::shared_ptr<TConstantLossLM> lmD = 
            ext::make_shared<TConstantLossLM>(
                Handle<Quote>(localCorrelationDetach_), recoveries_, 
                LatentModelIntegrationType::GaussianQuadrature, 
                recoveries_.size(), copulaTraits_);

        scalarCorrelModelAttach_ = 
            ext::make_shared<TBinomialLossModel>(lmA);
        scalarCorrelModelDetach_ = 
            ext::make_shared<TBinomialLossModel>(lmD);
            
        basketAttach_->setLossModel(scalarCorrelModelAttach_);
        basketDetach_->setLossModel(scalarCorrelModelDetach_);
    }

    /* \todo Fix this model, is failing for equity tranches at least, the
    base model works all right, its the link here.
    */
    template<>
    inline void BaseCorrelationLossModel<IHGaussPoolLossModel, 
        BilinearInterpolation>::setupModels() const 
    {
        ext::shared_ptr<GaussianConstantLossLM> lmA = 
            ext::make_shared<GaussianConstantLossLM>(
                Handle<Quote>(localCorrelationAttach_), recoveries_, 
                LatentModelIntegrationType::GaussianQuadrature, 
                recoveries_.size(), copulaTraits_);
        ext::shared_ptr<GaussianConstantLossLM> lmD = 
            ext::make_shared<GaussianConstantLossLM>(
                Handle<Quote>(localCorrelationDetach_), recoveries_, 
                LatentModelIntegrationType::GaussianQuadrature, 
                recoveries_.size(), copulaTraits_);

        // \todo Allow the sending specific model params, as the number of 
        //   buckets here.
        scalarCorrelModelAttach_ = 
            ext::make_shared<IHGaussPoolLossModel>(lmA, 500);
        scalarCorrelModelDetach_ = 
            ext::make_shared<IHGaussPoolLossModel>(lmD, 500);
            
        basketAttach_->setLossModel(scalarCorrelModelAttach_);
        basketDetach_->setLossModel(scalarCorrelModelDetach_);
    }

    #endif


    // Vanilla BC model
    #ifndef QL_PATCH_SOLARIS
    typedef BaseCorrelationLossModel<GaussianLHPLossModel, 
                BilinearInterpolation> GaussianLHPFlatBCLM;
    #endif

}

#endif
]]></document_content>
  </document>
  <document index="153">
    <source>credit/basecorrelationstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/basecorrelationstructure.hpp>


namespace QuantLib {

    /* Default Factories for some specific two dimensional interpolations 
    through template specialization. The signature of the 2D interpolator 
        constructor is not guaranteed.*/
    template<>
    void 
    BaseCorrelationTermStructure<BilinearInterpolation>::setupInterpolation() {
         interpolation_ =  
             BilinearInterpolation(trancheTimes_.begin(), 
            trancheTimes_.end(), lossLevel_.begin(), lossLevel_.end(), 
            correlations_);
     }

     /* Notice See that some interpolators might take you out of the [-1,1]
     correlation domain.
    */
    template<>
    void 
    BaseCorrelationTermStructure<BicubicSpline>::setupInterpolation() {
         interpolation_ =  
             BicubicSpline(trancheTimes_.begin(), 
            trancheTimes_.end(), lossLevel_.begin(), lossLevel_.end(), 
            correlations_);
    }

}
]]></document_content>
  </document>
  <document index="154">
    <source>credit/basecorrelationstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_base_correl_structure_hpp
#define quantlib_base_correl_structure_hpp

#include <ql/quote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>

#include <ql/experimental/credit/correlationstructure.hpp>

namespace QuantLib {


    /*! Matrix based Base Correlation Term Structure\par
    Loss level versus time interpolated scalar copula type parametric 
    correlation term structure. Represents the correlation for the credit loss 
    level of a given portfolio at a given loss level and time.

    \todo The relation to a given basket is to be made explicit for bespoke 
    models to be implemented.
    \todo Consider moving to a matrix data structure. A matrix might make some
    computations heavy, template specialization on the dimension might be an
    alternative to having two classes, one for scalars and another for matrices.
    \todo Rethink all the data structure with a basket where current losses are 
    not zero.
    \todo In principle the 2D interpolator is left optional since there are 
    arbitrage issues on the interpolator type to be used. However one has to be
    careful when using non local interpolators like CubicSplines which have an
    effect on the past (calibrated) coupons of previous tenors.
    */
    template<class Interpolator2D_T>
    class BaseCorrelationTermStructure : public CorrelationTermStructure {
    public:
        /*
        @param correls Corresponds to: correls[iYear][iLoss]

        The Settlement date should in an ideal world coincide with the 
        (implicit) basket inception date and its default term structures 
        settlement dates.
        */
        BaseCorrelationTermStructure(
            Natural settlementDays,
            const Calendar& cal,
            BusinessDayConvention bdc,
            const std::vector<Period>& tenors,// sorted
            const std::vector<Real>& lossLevel,//sorted
            const std::vector<std::vector<Handle<Quote> > >& correls,
            const DayCounter& dc = DayCounter()
            )
        : CorrelationTermStructure(settlementDays, cal, bdc, dc),
          correlHandles_(correls),
          correlations_(correls.size(), correls.front().size()),
          nTrancheTenors_(tenors.size()),
          nLosses_(lossLevel.size()),
          tenors_(tenors),
          lossLevel_(lossLevel),
          trancheTimes_(tenors.size(), 0.) {
              checkTrancheTenors();

              for (auto& tenor : tenors_)
                  trancheDates_.push_back(
                      calendar().advance(referenceDate(), tenor, businessDayConvention()));

              initializeTrancheTimes();
              checkInputs(correlations_.rows(), correlations_.columns());
                updateMatrix();
              registerWithMarketData();
              // call factory
              setupInterpolation();
        }
    private:
        virtual void setupInterpolation() ;
    public:
      Size correlationSize() const override { return 1; }
      //! Implicit correlation for the given loss interval.
      Real ImplicitCorrelation(Real, Real);

      void checkTrancheTenors() const;
      void checkLosses() const;
      void initializeTrancheTimes() const;
      void checkInputs(Size volRows, Size volsColumns) const;
      void registerWithMarketData();

      void update() override;
      void updateMatrix() const;

      // TermStructure interface
      Date maxDate() const override { return trancheDates_.back(); }
      Real correlation(const Date& d, Real lossLevel, bool extrapolate = false) const {
          return correlation(timeFromReference(d), lossLevel, extrapolate);
        }
        Real correlation(Time t, Real lossLevel, 
            bool extrapolate = false) const 
        {
            return interpolation_(t, lossLevel, true);
        }
    private:
        std::vector<std::vector<Handle<Quote> > > correlHandles_;
        mutable Matrix correlations_;
        Interpolation2D interpolation_;
        Size nTrancheTenors_,
            nLosses_;
        std::vector<Period> tenors_;
        mutable std::vector<Real> lossLevel_;
        mutable std::vector<Date> trancheDates_;
        mutable std::vector<Time> trancheTimes_;
    };

    // ----------------------------------------------------------------------

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::checkTrancheTenors() const {
        QL_REQUIRE(tenors_[0]>0*Days,
                   "first tranche tenor is negative (" <<
                   tenors_[0] << ")");
        for (Size i=1; i<nTrancheTenors_; ++i)
            QL_REQUIRE(tenors_[i]>tenors_[i-1],
                       "non increasing tranche tenor: " << io::ordinal(i) <<
                       " is " << tenors_[i-1] << ", " << io::ordinal(i+1) <<
                       " is " << tenors_[i]);
    }

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::checkLosses() const {
        QL_REQUIRE(lossLevel_[0]>0.,
                   "first loss level is negative (" <<
                   lossLevel_[0] << ")");
        QL_REQUIRE(lossLevel_[0] <= 1.,
            "First loss level larger than 100% (" << lossLevel_[0] <<")");
        for (Size i=1; i<nLosses_; ++i) {
            QL_REQUIRE(lossLevel_[i]>lossLevel_[i-1],
                       "non increasing losses: " << io::ordinal(i) <<
                       " is " << lossLevel_[i-1] << ", " << io::ordinal(i+1) <<
                       " is " << lossLevel_[i]);
        QL_REQUIRE(lossLevel_[i] <= 1.,
            "Loss level " << i << " larger than 100% (" << lossLevel_[i] <<")");
        }
    }

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::initializeTrancheTimes() const {
        for (Size i=0; i<nTrancheTenors_; ++i)
            trancheTimes_[i] = timeFromReference(trancheDates_[i]);
    }

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::checkInputs(Size volRows,
                                               Size volsColumns) const {
        QL_REQUIRE(nLosses_==volRows,
                   "mismatch between number of loss levels (" <<
                   nLosses_ << ") and number of rows (" << volRows <<
                   ") in the correl matrix");
        QL_REQUIRE(nTrancheTenors_==volsColumns,
                   "mismatch between number of tranche tenors (" <<
                   nTrancheTenors_ << ") and number of columns (" << 
                   volsColumns << ") in the correl matrix");
    }

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::registerWithMarketData()
    {
        for (Size i=0; i<correlHandles_.size(); ++i)
            for (Size j=0; j<correlHandles_.front().size(); ++j)
                registerWith(correlHandles_[i][j]);
    }

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::update() {
        updateMatrix();
        TermStructure::update();
    }

    template <class I2D_T>
    void BaseCorrelationTermStructure<I2D_T>::updateMatrix() const {
        for (Size i=0; i<correlHandles_.size(); ++i)
            for (Size j=0; j<correlHandles_.front().size(); ++j)
                correlations_[i][j] = correlHandles_[i][j]->value();

    }

}

#endif
]]></document_content>
  </document>
  <document index="155">
    <source>credit/basket.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/experimental/credit/loss.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <numeric>
#include <utility>

using namespace std;

namespace QuantLib {

    Basket::Basket(const Date& refDate,
                   const vector<string>& names,
                   vector<Real> notionals,
                   ext::shared_ptr<Pool> pool,
                   Real attachment,
                   Real detachment,
                   ext::shared_ptr<Claim> claim)
    : notionals_(std::move(notionals)), pool_(std::move(pool)), claim_(std::move(claim)),
      attachmentRatio_(attachment), detachmentRatio_(detachment), basketNotional_(0.0),
      attachmentAmount_(0.0), detachmentAmount_(0.0), trancheNotional_(0.0), refDate_(refDate) {
        QL_REQUIRE(!notionals_.empty(), "notionals empty");
        QL_REQUIRE (attachmentRatio_ >= 0 &&
                    attachmentRatio_ <= detachmentRatio_ &&
                    detachmentRatio_ <= 1,
                    "invalid attachment/detachment ratio");
        QL_REQUIRE(pool_, "Empty pool pointer.");
        QL_REQUIRE(notionals_.size() == pool_->size(), 
                   "unmatched data entry sizes in basket");

        // registrations relevant to the loss status, not to the expected 
        // loss values; those are through models.
        registerWith(Settings::instance().evaluationDate());
        registerWith(claim_);

        computeBasket();

        // At this point Issuers in the pool might or might not have
        //   probability term structures for the defultKeys(eventType+
        //   currency+seniority) entering in this basket. This is not
        //   necessarily a problem.
        for (double notional : notionals_) {
            basketNotional_ += notional;
            attachmentAmount_ += notional * attachmentRatio_;
            detachmentAmount_ += notional * detachmentRatio_;
        }
        trancheNotional_ = detachmentAmount_ - attachmentAmount_;
    }

    /*\todo Alternatively send a relinkable handle so it can be changed from 
    the outside. In that case reconsider the observability chain.
    */
    void Basket::setLossModel(
        const ext::shared_ptr<DefaultLossModel>& lossModel) {

        if (lossModel_ != nullptr)
            unregisterWith(lossModel_);
        lossModel_ = lossModel;
        if (lossModel_ != nullptr) {
            //recovery quotes, defaults(once Issuer is observable)etc might 
            //  trigger us:
            registerWith(lossModel_);
        }
        LazyObject::update(); //<- just set calc=false
    }

    void Basket::performCalculations() const {
        // Calculations for status
        computeBasket();// or we might be called from an statistic member 
                        // without being initialized yet (first called)
        QL_REQUIRE(lossModel_, "Basket has no default loss model assigned.");

        /* The model must notify us if the another basket calls it for 
        reasignment. The basket works as an argument to the deafult loss models 
        so, even if the models dont cache anything, they will be using the wrong
        default TS. \todo: This has a possible optimization: the basket 
        incorporates trancheability and many models do their compuations 
        independently of that (some do but do it inefficiently when asked for 
        two tranches on the same basket; e,g, recursive model) so it might be 
        more efficient sending the pool only; however the modtionals and other 
        basket info are still used.*/
        lossModel_->setBasket(const_cast<Basket*>(this));
    }

    Real Basket::notional() const {
        return std::accumulate(notionals_.begin(), notionals_.end(), 0.0);
    }

    Disposable<vector<Real> > Basket::probabilities(const Date& d) const {
        vector<Real> prob(size());
        vector<DefaultProbKey> defKeys = defaultKeys();
        for (Size j = 0; j < size(); j++)
            prob[j] = pool_->get(pool_->names()[j]).defaultProbability(
                defKeys[j])->defaultProbability(d);
        return prob;
    }

    Real Basket::cumulatedLoss(const Date& endDate) const {
        QL_REQUIRE(endDate >= refDate_, 
            "Target date lies before basket inception");
        Real loss = 0.0;
        for (Size i = 0; i < size(); i++) {
            ext::shared_ptr<DefaultEvent> credEvent =
                pool_->get(pool_->names()[i]).defaultedBetween(refDate_,
                    endDate, pool_->defaultKeys()[i]);
            if (credEvent != nullptr) {
                /* \todo If the event has not settled one would need to 
                introduce some model recovery rate (independently of a loss 
                model) This remains to be done.
                */  
                if(credEvent->hasSettled())
                    loss += claim_->amount(credEvent->date(),
                            // notionals_[i],
                            exposure(pool_->names()[i], credEvent->date()),
                            credEvent->settlement().recoveryRate(
                                pool_->defaultKeys()[i].seniority()));
            }
        }
        return loss;
    }

    Real Basket::settledLoss(const Date& endDate) const {
        QL_REQUIRE(endDate >= refDate_, 
            "Target date lies before basket inception");
        
        Real loss = 0.0;
        for (Size i = 0; i < size(); i++) {
            ext::shared_ptr<DefaultEvent> credEvent =
                pool_->get(pool_->names()[i]).defaultedBetween(refDate_,
                    endDate, pool_->defaultKeys()[i]);
            if (credEvent != nullptr) {
                if(credEvent->hasSettled()) {
                    loss += claim_->amount(credEvent->date(),
                            //notionals_[i],
                            exposure(pool_->names()[i], credEvent->date()),
                            //NOtice I am requesting an exposure in the past...
                            /* also the seniority does not belong to the 
                            counterparty anymore but to the position.....*/
                            credEvent->settlement().recoveryRate(
                                pool_->defaultKeys()[i].seniority()));
                }
            }
        }
        return loss;
    }

    Real Basket::remainingNotional() const {
        return evalDateRemainingNot_;
    }

    Disposable<std::vector<Size> > 
        Basket::liveList(const Date& endDate) const {
        std::vector<Size> calcBufferLiveList;
        for (Size i = 0; i < size(); i++)
            if (!pool_->get(pool_->names()[i]).defaultedBetween(
                    refDate_,
                    endDate,
                    pool_->defaultKeys()[i]))
                calcBufferLiveList.push_back(i);

        return calcBufferLiveList;
    }

    Real Basket::remainingNotional(const Date& endDate) const {
        Real notional = 0;
        vector<DefaultProbKey> defKeys = defaultKeys();
        for (Size i = 0; i < size(); i++) {
            if (!pool_->get(pool_->names()[i]).defaultedBetween(refDate_,
                                                        endDate,
                                                        defKeys[i]))
                notional += notionals_[i];
        }
        return notional;
    }

    Disposable<vector<Real> > 
        Basket::remainingNotionals(const Date& endDate) const 
    {
        QL_REQUIRE(endDate >= refDate_, 
            "Target date lies before basket inception");

        std::vector<Real> calcBufferNotionals;
        const std::vector<Size>& alive = liveList(endDate);
        for(Size i=0; i<alive.size(); i++)
            calcBufferNotionals.push_back(
                exposure(pool_->names()[i], endDate)
                );// some better way to trim it? 
        return calcBufferNotionals;
    }

    Disposable<std::vector<Probability> > 
        Basket::remainingProbabilities(const Date& d) const 
    {
        QL_REQUIRE(d >= refDate_, "Target date lies before basket inception");
        vector<Real> prob;
        const std::vector<Size>& alive = liveList();

        for(Size i=0; i<alive.size(); i++)
            prob.push_back(pool_->get(pool_->names()[i]).defaultProbability(
                pool_->defaultKeys()[i])->defaultProbability(d, true));
        return prob;
    }

    /* It is supossed to return the addition of ALL notionals from the 
    requested ctpty......*/
    Real Basket::exposure(const std::string& name, const Date& d) const {
        //'this->names_' contains duplicates, contrary to 'pool->names'
        auto match = std::find(pool_->names().begin(), pool_->names().end(), name);
        QL_REQUIRE(match != pool_->names().end(), "Name not in basket.");
        Real totalNotional = 0.;
        do{
            totalNotional += 
             // NOT IMPLEMENTED YET:
    //positions_[std::distance(names_.begin(), match)]->expectedExposure(d);
                notionals_[std::distance(pool_->names().begin(), match)];
            ++match;
            match = std::find(match, pool_->names().end(), name);
        }while(match != pool_->names().end());

        return totalNotional;
        //Size position = std::distance(poolNames.begin(), 
        //    std::find(poolNames.begin(), poolNames.end(), name));
        //QL_REQUIRE(position < pool_->size(), "Name not in pool list");

        //return positions_[position]->expectedExposure(d);
    }

    Disposable<std::vector<std::string> >
        Basket::remainingNames(const Date& endDate) const 
    {
        // maybe return zero directly instead?:
        QL_REQUIRE(endDate >= refDate_, 
            "Target date lies before basket inception");

        const std::vector<Size>& alive = liveList(endDate);
        std::vector<std::string> calcBufferNames;
        calcBufferNames.reserve(alive.size());
        for (unsigned long i : alive)
            calcBufferNames.push_back(pool_->names()[i]);
        return calcBufferNames;
    }

    Disposable<vector<DefaultProbKey> >
        Basket::remainingDefaultKeys(const Date& endDate) const 
    {
        QL_REQUIRE(endDate >= refDate_,
            "Target date lies before basket inception");

        const std::vector<Size>& alive = liveList(endDate);
        vector<DefaultProbKey> defKeys;
        defKeys.reserve(alive.size());
        for (unsigned long i : alive)
            defKeys.push_back(pool_->defaultKeys()[i]);
        return defKeys;
    }

    Size Basket::remainingSize() const {
        return evalDateLiveList_.size();
    }

    Size Basket::remainingSize(const Date& d) const {
        return remainingDefaultKeys(d).size();
    }

    /* computed on the inception values, notice the positions might have 
    amortized or changed in value and the total outstanding notional might 
    differ from the inception one.*/
    Real Basket::remainingDetachmentAmount(const Date& endDate) const {
        return detachmentAmount_;
    }

    Real Basket::remainingAttachmentAmount(const Date& endDate) const {
        // maybe return zero directly instead?:
        QL_REQUIRE(endDate >= refDate_, 
            "Target date lies before basket inception");
        Real loss = settledLoss(endDate);
        return std::min(detachmentAmount_, attachmentAmount_ + 
            std::max(0.0, loss - attachmentAmount_));
    }

    Probability Basket::probOverLoss(const Date& d, Real lossFraction) const {
        // convert initial basket fraction to remaining basket fraction
        calculate();
        // if eaten up all the tranche the prob of losing any amount is 1 
        //  (we have already lost it)
        if(evalDateRemainingNot_ == 0.) return 1.;

        // Turn to live (remaining) tranche units to feed into the model request
        Real xPtfl = attachmentAmount_ + 
            (detachmentAmount_-attachmentAmount_)*lossFraction;
        Real xPrim = (xPtfl- evalDateAttachAmount_)/
            (detachmentAmount_-evalDateAttachAmount_);
        // in live tranche fractional units
        // if the level falls within realized losses the prob is 1.
        if(xPtfl < 0.) return 1.;

        return lossModel_->probOverLoss(d, xPrim);
    }

    Real Basket::percentile(const Date& d, Probability prob) const {
        calculate();
        return lossModel_->percentile(d, prob);
    }

    Real Basket::expectedTrancheLoss(const Date& d) const {
        calculate();
        return cumulatedLoss() + lossModel_->expectedTrancheLoss(d);
    }

    Disposable<std::vector<Real> > 
        Basket::splitVaRLevel(const Date& date, Real loss) const {
        calculate();
        return lossModel_->splitVaRLevel(date, loss);
    }

    Real Basket::expectedShortfall(const Date& d, Probability prob) const {
        calculate();
        return lossModel_->expectedShortfall(d, prob);
    }

    Disposable<std::map<Real, Probability> > 
        Basket::lossDistribution(const Date& d) const {
        calculate();
        return lossModel_->lossDistribution(d);
    }

    std::vector<Probability> 
        Basket::probsBeingNthEvent(Size n, const Date& d) const {

        Size alreadyDefaulted = pool_->size() - remainingNames().size();
        if(alreadyDefaulted >=n) 
            return std::vector<Probability>(remainingNames().size(), 0.);

        calculate();
        return lossModel_->probsBeingNthEvent(n-alreadyDefaulted, d);
    }

    Real Basket::defaultCorrelation(const Date& d, Size iName, Size jName) const{
        calculate();
        return lossModel_->defaultCorrelation(d, iName, jName);

    }

    /*! Returns the probaility of having a given or larger number of 
    defaults in the basket portfolio at a given time.
    */
    Probability Basket::probAtLeastNEvents(Size n, const Date& d) const{
        calculate();
        return lossModel_->probAtLeastNEvents(n, d);

    }

    Real Basket::recoveryRate(const Date& d, Size iName) const {
        calculate();
        return 
            lossModel_->expectedRecovery(d, iName, pool_->defaultKeys()[iName]);
    }

}
]]></document_content>
  </document>
  <document index="156">
    <source>credit/basket.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file basket.hpp
    \brief basket of issuers and related notionals
*/

#ifndef quantlib_basket_hpp
#define quantlib_basket_hpp

#include <ql/instruments/claim.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#include <ql/experimental/credit/issuer.hpp>
#include <ql/experimental/credit/recoveryratemodel.hpp>
#include <ql/experimental/credit/pool.hpp>
#include <ql/experimental/credit/loss.hpp>
#include <ql/utilities/disposable.hpp>

namespace QuantLib {

    class DefaultLossModel;

    /*! Credit Basket.\par
        A basket is a collection of credit names, represented by a
        unique identifier (a text string), associated notional
        amounts, a pool and tranche information. The pool is a map of
        "names" to issuers.  The Basket structure is motivated by CDO
        squared instruments containing various underlying inner CDOs
        which can be represented by respective baskets including their
        tranche structure.  The role of the Pool is providing a unique
        list of relevant issuers while names may appear multiple times
        across different baskets (overlap).
     */
    class Basket : public LazyObject {
      public:
        Basket() = default;
        /*! Constructs a basket of simple collection of constant notional 
          positions subject to default risk only.
          
          The refDate parameter is the basket inception date, that is,
          the date at which defaultable events are relevant. (There
          are no constraints on forward baskets but models assigned
          should be consistent.)
        */
        Basket(const Date& refDate,
               const std::vector<std::string>& names,
               std::vector<Real> notionals,
               ext::shared_ptr<Pool> pool,
               Real attachmentRatio = 0.0,
               Real detachmentRatio = 1.0,
               ext::shared_ptr<Claim> claim = ext::shared_ptr<Claim>(new FaceValueClaim()));
        void update() override {
            computeBasket();
            LazyObject::update();
        }
        void computeBasket() const {
            Date today = Settings::instance().evaluationDate();
            /* update cache values at the calculation date (work as arguments 
              to the Loss Models)
            \to do: IMPORTANT: notice that defaults added to Issuers dont get
            notify as the codes stnds today. Issuers need to be observables.
            */
            //this one must remain on top since there are dependencies
            evalDateLiveKeys_      = remainingDefaultKeys(today);
            evalDateSettledLoss_   = settledLoss(today);
            evalDateRemainingNot_  = remainingNotional(today);
            evalDateLiveNotionals_ = remainingNotionals(today);
            evalDateLiveNames_     = remainingNames(today);
            evalDateAttachAmount_  = remainingAttachmentAmount(today);
            evalDateDetachAmmount_ = 
                remainingDetachmentAmount(today);
            evalDateLiveList_ = liveList(today);
        }
        //! Basket inception number of counterparties.
        Size size() const;
        //! Basket counterparties names at inception.
        const std::vector<std::string>& names() const {return pool_->names();}
        //! Basket counterparties notionals at inception.
        const std::vector<Real>& notionals() const;
        //! Basket total notional at inception.
        Real notional() const;
        //! Returns the total expected exposures for that name.
        Real exposure(const std::string& name, const Date& = Date()) const;
        //! Underlying pool
        const ext::shared_ptr<Pool>& pool() const;
        //! The keys each counterparty enters the basket with (sensitive to)
        Disposable<std::vector<DefaultProbKey> > defaultKeys() const;
        /*! Loss Given Default for all issuers/notionals based on
            expected recovery rates for the respective issuers.
        */
        //! Basket inception date.
        const Date& refDate() const {return refDate_;}
        /*! Attachment point expressed as a fraction of the total inception 
          notional.
        */
        Real attachmentRatio() const {return attachmentRatio_;}
        //! Detachment point expressed as a fraction of the total pool notional
        Real detachmentRatio() const {return detachmentRatio_;}
        //! Original basket notional ignoring any losses.
        Real basketNotional() const {return basketNotional_;}
        //! Original tranche notional ignoring any realized losses.
        Real trancheNotional() const {return trancheNotional_;}
        //! Attachment amount = attachmentRatio() * basketNotional()
        Real attachmentAmount() const {return attachmentAmount_;}
        //! Detachment amount = detachmentRatio() * basketNotional()
        Real detachmentAmount() const {return detachmentAmount_;}
        //! default claim, same for all positions and counterparties
        ext::shared_ptr<Claim> claim() const {return claim_;}
        /*! Vector of cumulative default probability to date d for all
            issuers in the basket.
        */
        Disposable<std::vector<Probability> > 
            probabilities(const Date& d) const;
        /*! Realized basket losses between the reference date and the 
            calculation date, taking the actual recovery rates of loss events 
            into account. 
            Only default events that have settled (have a realized RR) are 
            accounted for. For contingent losses after a default you need
            to compute the losses through a DefaultLossModel

            Optionally one can pass a date in the future and that will collect 
            events stored in the issuers list. This shows the effect of 
            'programmed' (after today's) events on top of past ones. The 
            intention is to be used in risk analysis (jump to default, etc).
        */
        Real settledLoss() const;
        Real settledLoss(const Date&) const;
        /*! Actual basket losses between the reference date and the calculation
            date, taking the actual recovery rates of loss events into account.
            If the event has not settled yet a model driven recovery is used.

            Returns the realized losses in this portfolio since the portfolio
            default reference date.
            This method relies on an implementation of the loss given default 
            since the events have not necessarily settled.
        */
        Real cumulatedLoss() const;
        Real cumulatedLoss(const Date&) const;
        /*! Remaining full basket (untranched) notional after settled losses 
          between the reference date and the given date.  The full notional 
          for defaulted names is subracted, recovery ignored.
        */
        Real remainingNotional() const;
        Real remainingNotional(const Date&) const;
        /*! Vector of surviving notionals after settled losses between the 
          reference date and the given date, recovery ignored.
        */
        const std::vector<Real>& remainingNotionals() const;
        Disposable<std::vector<Real> > remainingNotionals(const Date&) const;
        /*! Vector of surviving issuers after defaults between the reference 
          basket date and the given (or evaluation) date.
        */
        const std::vector<std::string>& remainingNames() const;
        Disposable<std::vector<std::string> > 
            remainingNames(const Date&) const;
        /*! Default keys of non defaulted counterparties
        */
        const std::vector<DefaultProbKey>& remainingDefaultKeys() const;
        Disposable<std::vector<DefaultProbKey> > remainingDefaultKeys(
            const Date&) const;
        //! Number of counterparties alive on the requested date.
        Size remainingSize() const;
        Size remainingSize(const Date&) const;
        /*! Vector of cumulative default probability to date d for all
            issuers still (at the evaluation date) alive in the basket.
        */
        Disposable<std::vector<Probability> > 
            remainingProbabilities(const Date& d) const;
        /*!
          Attachment amount of the equivalent (after defaults) remaining basket
          The remaining attachment amount is
          RAA = max (0, attachmentAmount - cumulatedLoss())

          The remaining attachment ratio is then
          RAR = RAA / remainingNotional()
        */
        Real remainingAttachmentAmount() const;
        Real remainingAttachmentAmount(const Date& endDate) const;

        /*!
          Detachment amount of the equivalent remaining basket.
          The remaining detachment amount is
          RDA = max (0, detachmentAmount - cumulatedLoss())

          The remaining detachment ratio is then
          RDR = RDA / remainingNotional()
        */
        Real remainingDetachmentAmount() const;
        Real remainingDetachmentAmount(const Date& endDate) const;

        //! Remaining basket tranched notional on calculation date
        Real remainingTrancheNotional() const {
            calculate();
            return evalDateDetachAmmount_ - evalDateAttachAmount_;
        }
        /*! Expected basket tranched notional on the requested date
            according to the basket model. Model should have been assigned.
        */
        Real remainingTrancheNotional(const Date& endDate) const {
            calculate();
            return remainingDetachmentAmount(endDate) - 
                remainingAttachmentAmount(endDate);
        }
        //!Indexes of remaining names. Notice these are names and not positions.
        const std::vector<Size>& liveList() const;
        Disposable<std::vector<Size> > liveList(const Date&) const;//?? keep?
        //! Assigns the default loss model to this basket. Resets calculations.
        void setLossModel(
            const ext::shared_ptr<DefaultLossModel>& lossModel);
        /*! \name Basket Loss Statistics
            Methods providing statistical metrics on the loss or value 
            distribution of the basket. Most calculations rely on the pressence
            of a model assigned to the basket.
        */
        //@{
        Real expectedTrancheLoss(const Date& d) const;
        /*! The lossFraction is the fraction of losses expressed in 
            inception (no losses) tranche units (e.g. 'attach level'=0%, 
            'detach level'=100%)
        */
        Probability probOverLoss(const Date& d, Real lossFraction) const;
        /*! 
        */
        Real percentile(const Date& d, Probability prob) const;
        /*! ESF 
        */
        Real expectedShortfall(const Date& d, Probability prob) const;
        /* Split a portfolio loss along counterparties. Typically loss 
        corresponds to some percentile.*/
        Disposable<std::vector<Real> > 
            splitVaRLevel(const Date& date, Real loss) const;
        /*! Full loss distribution
        */
        Disposable<std::map<Real, Probability> > lossDistribution(
            const Date&) const;
        Real densityTrancheLoss(const Date& d, Real lossFraction) const;
        Real defaultCorrelation(const Date& d, Size iName, Size jName) const;
        /*! Probability vector that each of the remaining live names (at eval
          date) is the n-th default by date d.

          The n parameter is the internal index to the name; it should
          be alive at the evaluation date.

        ---------TO DO: Implement with a string passed----------------------
        ---------TO DO: Perform check the name is alive---------------------
        */
        std::vector<Probability> probsBeingNthEvent(
            Size n, const Date& d) const;
        /*! Returns the probaility of having a given or larger number of 
        defaults in the basket portfolio at a given time.
        */
        Probability probAtLeastNEvents(Size n, const Date& d) const;
        /*! Expected recovery rate of the underlying position as a fraction of 
          its exposure value at date d _given_ it has defaulted _on_ that date.
          NOTICE THE ARG IS THE CTPTY....SHOULDNT IT BE THE POSITION/INSTRUMENT?????<<<<<<<<<<<<<<<<<<<<<<<
        */
        Real recoveryRate(const Date& d, Size iName) const;
        //@}
      private:
        // LazyObject interface
        void performCalculations() const override;

        std::vector<Real> notionals_;
        ext::shared_ptr<Pool> pool_;
        //! The claim is the same for all names
        const ext::shared_ptr<Claim> claim_;

        Real attachmentRatio_;
        Real detachmentRatio_;
        Real basketNotional_;
        //! basket tranched inception attachment amount:
        mutable Real attachmentAmount_;
        //! basket tranched inception detachment amount:
        mutable Real detachmentAmount_;
        //! basket tranched notional amount:
        mutable Real trancheNotional_;
        /* Caches. Most of the times one wants statistics on the distribution of
        futures losses at arbitrary dates but some problems (e.g. derivatives 
        pricing) work with todays (evalDate) magnitudes which do not require a 
        loss model and would be too expensive to recompute on every call.
        */
        mutable Real evalDateSettledLoss_,
            evalDateRemainingNot_,
            evalDateAttachAmount_,
            evalDateDetachAmmount_;
        mutable std::vector<Size> evalDateLiveList_;
        mutable std::vector<Real> evalDateLiveNotionals_;
        mutable std::vector<std::string> evalDateLiveNames_;
        mutable std::vector<DefaultProbKey> evalDateLiveKeys_;
        //! Basket inception date.
        const Date refDate_;
        /* It is the basket responsibility to ensure that the model assigned it 
          is properly initialized to the basket current data. 
          This might not be the case for various reasons: the basket data might
          have been updated, the evaluation date has changed or the model has 
          received another request from another basket pointing to it. For
          this last reason we can never be sure between calls that this is the 
          case (and that is true in a single thread environment only).
        */
        ext::shared_ptr<DefaultLossModel> lossModel_;
    };

    // ------------ Inlines -------------------------------------------------

    inline Size Basket::size() const {
        return pool_->size();
    }

    inline const std::vector<Real>& Basket::notionals() const {
        return notionals_;
    }

    inline Disposable<std::vector<DefaultProbKey> > 
        Basket::defaultKeys() const {
        return pool_->defaultKeys();
    }

    inline const ext::shared_ptr<Pool>& Basket::pool() const {
        return pool_;
    }

    inline const std::vector<Size>& Basket::liveList() const {
        return evalDateLiveList_;
    }

    inline Real Basket::remainingDetachmentAmount() const {
        return evalDateDetachAmmount_;
    }

    inline Real Basket::remainingAttachmentAmount() const {
        return evalDateAttachAmount_;
    }

    inline const std::vector<std::string>& Basket::remainingNames() const {
        return evalDateLiveNames_;
    }

    inline const std::vector<Real>& Basket::remainingNotionals() const {
        return evalDateLiveNotionals_;
    }

    inline Real Basket::cumulatedLoss() const {
        return this->evalDateSettledLoss_;
    }
    
    inline Real Basket::settledLoss() const {
        return evalDateSettledLoss_;
    }

    inline const std::vector<DefaultProbKey>& 
        Basket::remainingDefaultKeys() const 
    {
        return evalDateLiveKeys_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="157">
    <source>credit/binomiallossmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_binomial_loss_model_hpp
#define quantlib_binomial_loss_model_hpp

#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/functional.hpp>
#include <ql/handle.hpp>
#include <algorithm>
#include <numeric>
#include <utility>

namespace QuantLib {

    /*! Binomial Defaultable Basket Loss Model\par
    Models the portfolio loss distribution by approximatting it to an adjusted 
    binomial. Fits the two moments of the loss distribution through an adapted 
    binomial approximation. This simple model allows for portfolio inhomogeneity
    with no excesive cost over the LHP.\par
    See:\par
    <b>Approximating Independent Loss Distributions with an Adjusted Binomial 
    Distribution</b> , Dominic O'Kane, 2007 EDHEC RISK AND ASSET MANAGEMENT 
    RESEARCH CENTRE \par
    <b>Modelling single name and multi-name credit derivatives</b> Chapter 
    18.5.2, Dominic O'Kane, Wiley Finance, 2008 \par
    The version presented here is adaptated to the multifactorial case
    by computing a conditional binomial approximation; notice that the Binomial
    is stable. This way the model can be used also in risk management models
    rather than only in pricing. The copula is also left 
    undefined/arbitrary. \par
    LLM: Loss Latent Model template parameter able to model default and 
    loss.\par
    The model is allowed and arbitrary copula, although initially designed for
    a Gaussian setup. If these exotic versions were not allowed the template 
    parameter can then be dropped but the use of random recoveries should be
    added in some other way.

    \todo untested/wip for the random recovery models.
    \todo integrate with the previously computed probability inversions of
    the cumulative functions.
    */
    template<class LLM>
    class BinomialLossModel : public DefaultLossModel {
    public:
        typedef typename LLM::copulaType copulaType;
        explicit BinomialLossModel(ext::shared_ptr<LLM> copula) : copula_(std::move(copula)) {}

      private:
        void resetModel() override {
            /* say there are defaults and these havent settled... and this is
            the engine to compute them.... is this the wrong place?:*/
            attachAmount_ = basket_->remainingAttachmentAmount();
            detachAmount_ = basket_->remainingDetachmentAmount();

            copula_->resetBasket(basket_.currentLink()); // forces interface
      }

    protected:
        /*! Returns the probability of the default loss values given by the 
            method lossPoints.
        */
        Disposable<std::vector<Real> > 
            expectedDistribution(const Date& date) const {
            // precal date conditional magnitudes:
            std::vector<Real> notionals = basket_->remainingNotionals(date);
            std::vector<Probability> invProbs = 
                basket_->remainingProbabilities(date);
            for(Size iName=0; iName<invProbs.size(); iName++)
                invProbs[iName] = 
                    copula_->inverseCumulativeY(invProbs[iName], iName);

            return copula_->integratedExpectedValueV(
                [&](const std::vector<Real>& v1) {
                    return lossProbability(date, notionals, invProbs, v1);
                });
        }
        //! attainable loss points this model provides
        Disposable<std::vector<Real> > lossPoints(const Date&) const;
        //! Returns the cumulative full loss distribution
        Disposable<std::map<Real, Probability> > lossDistribution(const Date& d) const override;
        //! Loss level for this percentile
        Real percentile(const Date& d, Real percentile) const override;
        Real expectedShortfall(const Date& d, Real percentile) const override;
        Real expectedTrancheLoss(const Date& d) const override;

        // Model internal workings ----------------
        //! Average loss per credit.
        Real averageLoss(const Date&, const std::vector<Real>& reminingNots, 
            const std::vector<Real>&) const;
        Real condTrancheLoss(const Date&, const std::vector<Real>& lossVals, 
            const std::vector<Real>& bsktNots,
            const std::vector<Probability>& uncondDefProbs, 
            const std::vector<Real>&) const;
        // expected as in time-value, not average, see literature
        Disposable<std::vector<Real> >
            expConditionalLgd(const Date& d,
                               const std::vector<Real>& mktFactors) const
        {
            std::vector<Real> condLgds;
            const std::vector<Size>& evalDateLives = basket_->liveList();
            condLgds.reserve(evalDateLives.size());
            for (unsigned long evalDateLive : evalDateLives)
                condLgds.push_back(1. - copula_->conditionalRecovery(d, evalDateLive, mktFactors));
            return condLgds;
        }

        //! Loss probability density conditional on the market factor value.
        // Heres where the burden of the algorithm setup lies.
        Disposable<std::vector<Real> > 
            lossProbability(      
                const Date& date,
                // expected exposures at the passed date, no wrong way means
                //  no dependence of the exposure with the mkt factor 
                const std::vector<Real>& bsktNots,
                const std::vector<Real>& uncondDefProbInv, 
                            const std::vector<Real>&  mktFactor) const;

        const ext::shared_ptr<LLM> copula_;

        // cached arguments:
        // remaining basket magnitudes:
        mutable Real attachAmount_, detachAmount_;
    };

    //-------------------------------------------------------------------------

    /* The algorithm to compute the prob. of n defaults in the basket is 
        recursive. For this reason theres no sense in returning the prob 
        distribution of a given number of defaults.
    */
    template< class LLM>
    Disposable<std::vector<Real> > BinomialLossModel<LLM>::lossProbability(
        const Date& date, 
        const std::vector<Real>& bsktNots,
        const std::vector<Real>& uncondDefProbInv, 
        const std::vector<Real>& mktFactors) const 
    {   // the model as it is does not model the exposures conditional to the 
        //   mkt factr, otherwise this needs revision
        /// model does not take the unconditional rr
        Size bsktSize = basket_->remainingSize();
        /* The conditional loss per unit notional of each name at time 'date'
            The spot recovery model is returning for all i's:
            \frac{\int_0^t  [1-rr_i(\tau; \xi)] P_{def-i}(0, \tau; \xi) d\tau}
                 {P_{def-i}(0,t;\xi)}
            and the constant recovery model is simply returning: 
            1-RR_i
        */
        // conditional fractional LGD expected as given by the recovery model 
        //   for the ramaining(live) names at the current eval date.
        std::vector<Real> fractionalEL = expConditionalLgd(date, mktFactors);
        std::vector<Real> lgdsLeft;
        std::transform(fractionalEL.begin(), fractionalEL.end(), 
            bsktNots.begin(), std::back_inserter(lgdsLeft), 
            std::multiplies<Real>());
        Real avgLgd = 
            std::accumulate(lgdsLeft.begin(), lgdsLeft.end(), Real(0.)) /
                bsktSize;

        std::vector<Probability> condDefProb(bsktSize, 0.);
        for(Size j=0; j<bsktSize; j++)//transform
            condDefProb[j] = 
                copula_->conditionalDefaultProbabilityInvP(uncondDefProbInv[j],
                    j, mktFactors);
        // of full portfolio:
        Real avgProb = avgLgd <= QL_EPSILON ? 0. : // only if all are 0
                std::inner_product(condDefProb.begin(), 
                    condDefProb.end(), lgdsLeft.begin(), 0.)
                / (avgLgd * bsktSize);
        // model parameters:
        Real m = avgProb * bsktSize;
        Real floorAveProb = std::min(Real(bsktSize-1), std::floor(Real(m)));
        Real ceilAveProb = floorAveProb + 1.;
        // nu_A
        Real varianceBinom = avgProb * (1. - avgProb)/bsktSize;
        // nu_E
        std::vector<Probability> oneMinusDefProb;//: 1.-condDefProb[j]
        std::transform(condDefProb.begin(), condDefProb.end(), 
                       std::back_inserter(oneMinusDefProb), 
                       subtract_from<Real>(1.0));

        //breaks condDefProb and lgdsLeft to spare memory
        std::transform(condDefProb.begin(), condDefProb.end(), 
            oneMinusDefProb.begin(), condDefProb.begin(), 
            std::multiplies<Real>());
        std::transform(lgdsLeft.begin(), lgdsLeft.end(), 
            lgdsLeft.begin(), lgdsLeft.begin(), std::multiplies<Real>());
        Real variance = std::inner_product(condDefProb.begin(), 
            condDefProb.end(), lgdsLeft.begin(), 0.);

        variance = avgLgd <= QL_EPSILON ? 0. : 
            variance / (bsktSize * bsktSize * avgLgd * avgLgd );
        Real sumAves = -std::pow(ceilAveProb-m, 2) 
            - (std::pow(floorAveProb-m, 2) - std::pow(ceilAveProb,2.)) 
                * (ceilAveProb-m);
        Real alpha = (variance * bsktSize + sumAves) 
            / (varianceBinom * bsktSize + sumAves);
        // Full distribution: 
        // ....DO SOMETHING CHEAPER at least go up to the loss tranche limit.
        std::vector<Probability> lossProbDensity(bsktSize+1, 0.); 
        if(avgProb >= 1.-QL_EPSILON) {
           lossProbDensity[bsktSize] = 1.;
        }else if(avgProb <= QL_EPSILON) {
           lossProbDensity[0] = 1.;
        }else{
            /* FIX ME: With high default probabilities one only gets tiny values
            at the end and the sum of probabilities in the 
            conditional distribution does not add up to one. It might be due to 
            the fact that recursion should be done in the other direction as 
            pointed out in the book. This is numerical.
            */
            Probability probsRatio = avgProb/(1.-avgProb);
            lossProbDensity[0] = std::pow(1.-avgProb, 
                static_cast<Real>(bsktSize));
            for(Size i=1; i<bsktSize+1; i++) // recursive to avoid factorial
                lossProbDensity[i] = lossProbDensity[i-1] * probsRatio 
                    * (bsktSize-i+1.)/i;
            // redistribute probability:
            for(Size i=0; i<bsktSize+1; i++)
                lossProbDensity[i] *= alpha;
            // adjust average
            Real epsilon = (1.-alpha)*(ceilAveProb-m);
            Real epsilonPlus = 1.-alpha-epsilon;
            lossProbDensity[static_cast<Size>(floorAveProb)] += epsilon;
            lossProbDensity[static_cast<Size>(ceilAveProb)]  += epsilonPlus;
        }
        return lossProbDensity;
    }

    //-------------------------------------------------------------------------

    template< class LLM>
    Real BinomialLossModel<LLM>::averageLoss(
        const Date& d, 
        const std::vector<Real>& reminingNots,
        const std::vector<Real>& mktFctrs) const 
    {
        Size bsktSize = basket_->remainingSize();
        /* The conditional loss per unit notional of each name at time 'date'
            The spot recovery model is returning for all i's:
            \frac{\int_0^t  [1-rr_i(\tau; \xi)] P_{def-i}(0, \tau; \xi) d\tau}
                 {P_{def-i}(0,t;\xi)}
            and the constant recovery model is simply returning: 
            1-RR_i
        */
        std::vector<Real> fractionalEL = expConditionalLgd(d, mktFctrs);
        Real notBskt = std::accumulate(reminingNots.begin(), 
                                       reminingNots.end(), Real(0.));
        std::vector<Real> lgdsLeft;
        std::transform(fractionalEL.begin(), fractionalEL.end(), 
                       reminingNots.begin(), std::back_inserter(lgdsLeft),
                       std::multiplies<Real>());
        return std::accumulate(lgdsLeft.begin(), lgdsLeft.end(), Real(0.)) 
            / (bsktSize*notBskt);
    }

    template< class LLM>
    Disposable<std::vector<Real> >
        BinomialLossModel<LLM>::lossPoints(const Date& d) const 
    {
        std::vector<Real> notionals = basket_->remainingNotionals(d);

        Real aveLossFrct = copula_->integratedExpectedValue(
            [&](const std::vector<Real>& v1) {
                return averageLoss(d, notionals, v1);
            });

        std::vector<Real> data;
        Size dataSize = basket_->remainingSize() + 1;
        data.reserve(dataSize);
        // use std::algorithm
        Real outsNot = basket_->remainingNotional(d);
        for(Size i=0; i<dataSize; i++)
            data.push_back(i * aveLossFrct * outsNot);
        return data;
    }

    template< class LLM>
    Real BinomialLossModel<LLM>::condTrancheLoss(
        const Date& d, 
        const std::vector<Real>& lossVals, 
        const std::vector<Real>& bsktNots,
        const std::vector<Real>& uncondDefProbsInv,
        const std::vector<Real>& mkf) const {

        std::vector<Real> condLProb = 
            lossProbability(d, bsktNots, uncondDefProbsInv, mkf);
        // \to do: move to a do-while over attach to detach
        Real suma = 0.;
        for(Size i=0; i<lossVals.size(); i++) { 
            suma += condLProb[i] * 
                std::min(std::max(lossVals[i]
                 - attachAmount_, 0.), detachAmount_ - attachAmount_);
        }
        return suma;
    }

    template< class LLM>
    Real BinomialLossModel<LLM>::expectedTrancheLoss(const Date& d) const {
        std::vector<Real> lossVals  = lossPoints(d);
        std::vector<Real> notionals = basket_->remainingNotionals(d);
        std::vector<Probability> invProbs = 
            basket_->remainingProbabilities(d);
        for(Size iName=0; iName<invProbs.size(); iName++)
            invProbs[iName] = 
                copula_->inverseCumulativeY(invProbs[iName], iName);
            
        return copula_->integratedExpectedValue(
            [&](const std::vector<Real>& v1) {
                return condTrancheLoss(d, lossVals, notionals, invProbs, v1);
            });
    }


    template< class LLM>
    Disposable<std::map<Real, Probability> > 
        BinomialLossModel<LLM>::lossDistribution(const Date& d) const 
    {
        std::map<Real, Probability> distrib;
        std::vector<Real> lossPts = lossPoints(d);
        std::vector<Real> values  = expectedDistribution(d);
        Real sum = 0.;
        for(Size i=0; i<lossPts.size(); i++) {
            distrib.insert(std::make_pair(lossPts[i], 
                //capped, some situations giving a very small probability over 1
                std::min(sum+values[i],1.)
                ));
            sum+= values[i];
        }
        return distrib;
    }

    template< class LLM>
    Real BinomialLossModel<LLM>::percentile(const Date& d, Real perc) const {
        std::map<Real, Probability> dist = lossDistribution(d);
        // \todo: Use some of the library interpolators instead
        if(// included in test below-> (dist.begin()->second >=1.) ||
            (dist.begin()->second >= perc))return dist.begin()->first;

        // deterministic case (e.g. date requested is todays date)
        if(dist.size() == 1) return dist.begin()->first;

        if(perc == 1.) return dist.rbegin()->first;
        if(perc == 0.) return dist.begin()->first;
        std::map<Real, Probability>::const_iterator itdist = dist.begin();
        while (itdist->second <= perc) ++itdist;
        Real valPlus = itdist->second;
        Real xPlus   = itdist->first;
        --itdist; //we're never 1st or last, because of tests above
        Real valMin  = itdist->second;
        Real xMin    = itdist->first;

        Real portfLoss = xPlus-(xPlus-xMin)*(valPlus-perc)/(valPlus-valMin);

        return 
            std::min(std::max(portfLoss - attachAmount_, 0.), 
                detachAmount_ - attachAmount_);
    }

    template< class LLM>
    Real BinomialLossModel<LLM>::expectedShortfall(const Date&d, 
        Real perctl) const 
    {
        //taken from recursive since we have the distribution in both cases.
        if(d == Settings::instance().evaluationDate()) return 0.;
            std::map<Real, Probability> distrib = lossDistribution(d);

            std::map<Real, Probability>::iterator 
                itNxt, itDist = distrib.begin();
            for(; itDist != distrib.end(); ++itDist)
                if(itDist->second >= perctl) break;
            itNxt = itDist;
            --itDist;

            // \todo: I could linearly triangulate the exact point and get 
            //    extra precission on the first(broken) period.
            if(itNxt != distrib.end()) { 
                Real lossNxt = std::min(std::max(itNxt->first - attachAmount_, 
                    0.), detachAmount_ - attachAmount_);
                Real lossHere = std::min(std::max(itDist->first - attachAmount_,
                    0.), detachAmount_ - attachAmount_);

                Real val =  lossNxt - (itNxt->second - perctl) * 
                    (lossNxt - lossHere) / (itNxt->second - itDist->second); 
                Real suma = (itNxt->second - perctl) * (lossNxt + val) * .5;
                ++itDist; ++itNxt;
                do{
                    lossNxt = std::min(std::max(itNxt->first - attachAmount_, 
                        0.), detachAmount_ - attachAmount_);
                    lossHere = std::min(std::max(itDist->first - attachAmount_, 
                        0.), detachAmount_ - attachAmount_);
                    suma += .5 * (lossHere + lossNxt) 
                        * (itNxt->second - itDist->second);
                    ++itDist; ++itNxt;
                }while(itNxt != distrib.end());
                return suma / (1.-perctl);
            }
            QL_FAIL("Binomial model fails to calculate ESF.");
    }

    // The standard use:
    typedef BinomialLossModel<GaussianConstantLossLM> GaussianBinomialLossModel;
    typedef BinomialLossModel<TConstantLossLM> TBinomialLossModel;

}

#endif
]]></document_content>
  </document>
  <document index="158">
    <source>credit/blackcdsoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Stamm
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/credit/blackcdsoptionengine.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/quote.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    BlackCdsOptionEngine::BlackCdsOptionEngine(Handle<DefaultProbabilityTermStructure> probability,
                                               Real recoveryRate,
                                               Handle<YieldTermStructure> termStructure,
                                               Handle<Quote> volatility)
    : probability_(std::move(probability)), recoveryRate_(recoveryRate),
      termStructure_(std::move(termStructure)), volatility_(std::move(volatility)) {

        registerWith(probability_);
        registerWith(termStructure_);
        registerWith(volatility_);
    }

    void BlackCdsOptionEngine::calculate() const {

        Date maturityDate = arguments_.swap->coupons().front()->date();
        Date exerciseDate = arguments_.exercise->date(0);
        QL_REQUIRE(maturityDate > exerciseDate,
                   "Underlying CDS should start after option maturity");
        Date settlement   = termStructure_->referenceDate();

        Rate spotFwdSpread = arguments_.swap->fairSpread();
        Rate swapSpread    = arguments_.swap->runningSpread();

        DayCounter tSDc = termStructure_->dayCounter();

        // The sense of the underlying/option has to be sent this way
        // to the Black formula, no sign.
        Real riskyAnnuity =
            std::fabs(arguments_.swap->couponLegNPV() / swapSpread);
        results_.riskyAnnuity = riskyAnnuity;

        Time T = tSDc.yearFraction(settlement, exerciseDate);

        Real stdDev = volatility_->value()  * std::sqrt(T);
        Option::Type callPut = (arguments_.side == Protection::Buyer) ?
                                                   Option::Call : Option::Put;

        results_.value =
            blackFormula(callPut, swapSpread, spotFwdSpread,
                         stdDev, riskyAnnuity);

        // if a non knock-out payer option, add front end protection value
        if (arguments_.side == Protection::Buyer && !arguments_.knocksOut) {
            Real frontEndProtection =
                callPut * arguments_.swap->notional()
                * (1.-recoveryRate_)
                * probability_->defaultProbability(exerciseDate)
                * termStructure_->discount(exerciseDate);
            results_.value += frontEndProtection;
        }
    }

    Handle<YieldTermStructure> BlackCdsOptionEngine::termStructure() {
        return termStructure_;
    }

    Handle<Quote> BlackCdsOptionEngine::volatility() {
        return volatility_;
    }

}
]]></document_content>
  </document>
  <document index="159">
    <source>credit/blackcdsoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Stamm
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackcdsoptionengine.hpp
    \brief Black credit default swap option engine
*/

#ifndef quantlib_black_cds_option_engine_hpp
#define quantlib_black_cds_option_engine_hpp

#include <ql/experimental/credit/cdsoption.hpp>

namespace QuantLib {

    //! Black-formula CDS-option engine
    /*! \warning The engine assumes that the exercise date equals the
                 start date of the passed CDS.
    */
    class BlackCdsOptionEngine : public CdsOption::engine {
      public:
        BlackCdsOptionEngine(Handle<DefaultProbabilityTermStructure>,
                             Real recoveryRate,
                             Handle<YieldTermStructure> termStructure,
                             Handle<Quote> vol);
        void calculate() const override;
        Handle<YieldTermStructure> termStructure();
        Handle<Quote> volatility();
      private:
        Handle<DefaultProbabilityTermStructure> probability_;
        Real recoveryRate_;
        Handle<YieldTermStructure> termStructure_;
        Handle<Quote> volatility_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="160">
    <source>credit/cdo.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/experimental/credit/cdo.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    CDO::CDO(Real attachment,
             Real detachment,
             vector<Real> nominals,
             const vector<Handle<DefaultProbabilityTermStructure> >& basket,
             Handle<OneFactorCopula> copula,
             bool protectionSeller,
             Schedule premiumSchedule,
             Rate premiumRate,
             DayCounter dayCounter,
             Rate recoveryRate,
             Rate upfrontPremiumRate,
             Handle<YieldTermStructure> yieldTS,
             Size nBuckets,
             const Period& integrationStep)
    : attachment_(attachment), detachment_(detachment), nominals_(std::move(nominals)),
      basket_(basket), copula_(std::move(copula)), protectionSeller_(protectionSeller),
      premiumSchedule_(std::move(premiumSchedule)), premiumRate_(premiumRate),
      dayCounter_(std::move(dayCounter)), recoveryRate_(recoveryRate),
      upfrontPremiumRate_(upfrontPremiumRate), yieldTS_(std::move(yieldTS)), nBuckets_(nBuckets),
      integrationStep_(integrationStep) {

        QL_REQUIRE (!basket.empty(), "basket is empty");
        QL_REQUIRE (attachment_ >= 0 && attachment_ < detachment_
                    && detachment_ <= 1,
                    "illegal attachment/detachment point");

        registerWith (yieldTS_);
        registerWith (copula_);
        for (auto& i : basket_)
            registerWith(i);

        QL_REQUIRE (nominals_.size() <= basket_.size(),
                    "nominal vector size too large");

        if (nominals_.size() < basket_.size()) {
            Size n = basket_.size() - nominals_.size();
            Real back = nominals_.back();
            for (Size i = 0; i < n; i++)
                nominals_.push_back(back);
        }

        QL_REQUIRE (nominals_.size() == basket_.size(),
                    "nominal size " << nominals_.size()
                    << " != basket size " << basket_.size());

        nominal_ = 0;
        for (Size i = 0; i < nominals_.size(); i++) {
            lgds_.push_back (nominals_[i] * (1.0 - recoveryRate_));
            nominal_ += nominals_[i];
            lgd_ += lgds_[i];
        }
        xMax_ = detachment_ * nominal_;
        xMin_ = attachment_ * nominal_;
    }


    bool CDO::isExpired () const {
        return detail::simple_event(premiumSchedule_.dates().back())
               .hasOccurred(yieldTS_->referenceDate());
    }


    void CDO::setupExpired() const {
        Instrument::setupExpired();
    }


    Real CDO::expectedTrancheLoss (Date d) const {
        if (d <= basket_.front()->referenceDate())
            return 0;

        vector<Real> defProb (basket_.size());
        for (Size j = 0; j < basket_.size(); j++)
            defProb[j] = basket_[j]->defaultProbability (d);

        LossDistBucketing op (nBuckets_, xMax_);
        Distribution dist = copula_->integral (op, lgds_, defProb);

        return dist.trancheExpectedValue (xMin_, xMax_);

        // The following causes two errors in test against literature values.
        // FIXME: Investigate accuracy.
        // return dist.cumulativeExcessProbability (xMin_, xMax_);

        //   TranchePayoff func (xMin_, xMax_);
        //   return (dist.expectedValue (func)
        //    + (xMax_ - xMin_) * (1.0 - dist.cumulatedProbability (xMax_)));
    }


    void CDO::performCalculations() const {

        QL_REQUIRE(!yieldTS_.empty(), "no yield term structure set");

        errorEstimate_ = Null<Real>();

        NPV_ = 0.0;
        premiumValue_ = 0;
        protectionValue_ = 0;
        error_ = 0;

        /* Expectations e1 and e2 are portfolio loss given default,
           i.e.  with recovery already "bult in". Multiplication by
           (1-r) is therefore not necessary, neither in premium nor
           protection value calculation.
        */

        Real e1 = 0;
        Date today = yieldTS_->referenceDate();
        if (premiumSchedule_[0] > today)
            e1 = expectedTrancheLoss (premiumSchedule_[0]);

        for (Size i = 1; i < premiumSchedule_.size(); i++) {
            Date d2 = premiumSchedule_[i];
            if (d2 < today)
                continue;

            Date d1 = premiumSchedule_[i-1];

            Date d, d0 = d1;
            do {
                d = NullCalendar().advance (d0 > today ? d0 : today,
                                            integrationStep_);
                if (d > d2)
                    d = d2;

                Real e2 = expectedTrancheLoss (d);

                premiumValue_ += (xMax_ - xMin_ - e2)
                    * premiumRate_ * dayCounter_.yearFraction (d0, d)
                    * yieldTS_->discount (d);

                if (e2 < e1) {
                    error_ ++;
                }

                protectionValue_ -= (e2 - e1) * yieldTS_->discount (d);

                d0 = d;
                e1 = e2;
            }
            while (d < d2);
        }

        if (premiumSchedule_[0] >= today)
            upfrontPremiumValue_ = (xMax_ - xMin_) * upfrontPremiumRate_ *
                yieldTS_->discount(premiumSchedule_[0]);
        else
            upfrontPremiumValue_ = 0.0;

        if (!protectionSeller_) {
            premiumValue_ *= -1;
            upfrontPremiumValue_ *= -1;
            protectionValue_ *= -1;
        }

        NPV_ = premiumValue_ + protectionValue_ + upfrontPremiumValue_;
    }


    Rate CDO::premiumValue () const {
        calculate();
        return premiumValue_;
    }

    Rate CDO::protectionValue () const {
        calculate();
        return protectionValue_;
    }

    Size CDO::error () const {
        calculate();
        return error_;
    }

    Rate CDO::fairPremium () const {
        calculate();
        return - premiumRate_ * protectionValue_ / premiumValue_;
    }

}
]]></document_content>
  </document>
  <document index="161">
    <source>credit/cdo.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cdo.hpp
    \brief collateralized debt obligation
*/

#ifndef quantlib_cdo_hpp
#define quantlib_cdo_hpp

#include <ql/instrument.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/experimental/credit/lossdistribution.hpp>
#include <ql/experimental/credit/onefactorcopula.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    //! collateralized debt obligation
    /*! The instrument prices a mezzanine CDO tranche with loss given
        default between attachment point \f$ D_1\f$ and detachment
        point \f$ D_2 > D_1 \f$.

        For purchased protection, the instrument value is given by the
        difference of the protection value \f$ V_1 \f$ and premium
        value \f$ V_2 \f$,

        \f[ V = V_1 - V_2. \f]

        The protection leg is priced as follows:

        - Build the probability distribution for volume of defaults
          \f$ L \f$ (before recovery) or Loss Given Default \f$ LGD =
          (1-r)\,L \f$ at times/dates \f$ t_i, i=1, ..., N\f$ (premium
          schedule times with intermediate steps)
        - Determine the expected value
          \f$ E_i = E_{t_i}\,\left[Pay(LGD)\right] \f$
          of the protection payoff \f$ Pay(LGD) \f$ at each time
          \f$ t_i\f$ where
         \f[
         Pay(L) = min (D_1, LGD) - min (D_2, LGD) = \left\{
         \begin{array}{lcl}
         \displaystyle 0 &;& LGD < D_1 \\
         \displaystyle LGD - D_1 &;& D_1 \leq LGD \leq D_2 \\
         \displaystyle D_2 - D_1 &;& LGD > D_2
         \end{array}
         \right.
         \f]
        - The protection value is then calculated as
          \f[ V_1 \:=\: \sum_{i=1}^N (E_i - E_{i-1}) \cdot  d_i \f]
          where \f$ d_i\f$ is the discount factor at time/date \f$ t_i \f$

        The premium is paid on the protected notional amount,
        initially \f$ D_2 - D_1. \f$ This notional amount is reduced
        by the expected protection payments \f$ E_i \f$ at times
        \f$ t_i, \f$ so that the premium value is calculated as

        \f[
        V_2 = m \, \cdot \sum_{i=1}^N \,(D_2 - D_1 - E_i)
                   \cdot \Delta_{i-1,i}\,d_i
        \f]

        where \f$ m \f$ is the premium rate, \f$ \Delta_{i-1, i}\f$ is
        the day count fraction between date/time \f$ t_{i-1}\f$ and
        \f$ t_i.\f$

        The construction of the portfolio loss distribution \f$ E_i
        \f$ is based on the probability bucketing algorithm described
        in

        <strong>
        John Hull and Alan White, "Valuation of a CDO and nth to default CDS
        without Monte Carlo simulation", Journal of Derivatives 12, 2, 2004
        </strong>

        The pricing algorithm allows for varying notional amounts and
        default termstructures of the underlyings.

        \todo Investigate and fix cases \f$ E_{i+1} < E_i. \f$
    */
    class CDO : public Instrument {
      public:
        /*! \param attachment  fraction of the LGD where protection starts
            \param detachment  fraction of the LGD where protection ends
            \param nominals    vector of basket nominal amounts
            \param basket      default basket represented by a vector of
                               default term structures that allow
                               computing single name default
                               probabilities depending on time
            \param copula      one-factor copula
            \param protectionSeller   sold protection if set to true, purchased
                                      otherwise
            \param premiumSchedule    schedule for premium payments
            \param premiumRate        annual premium rate, e.g. 0.05 for 5% p.a.
            \param dayCounter         day count convention for the premium rate
            \param recoveryRate       recovery rate as a fraction
            \param upfrontPremiumRate premium as a tranche notional fraction
            \param yieldTS            yield term structure handle
            \param nBuckets           number of distribution buckets
            \param integrationStep    time step for integrating over one
                                      premium period; if larger than premium
                                      period length, a single step is taken
        */
        CDO(Real attachment,
            Real detachment,
            std::vector<Real> nominals,
            const std::vector<Handle<DefaultProbabilityTermStructure> >& basket,
            Handle<OneFactorCopula> copula,
            bool protectionSeller,
            Schedule premiumSchedule,
            Rate premiumRate,
            DayCounter dayCounter,
            Rate recoveryRate,
            Rate upfrontPremiumRate,
            Handle<YieldTermStructure> yieldTS,
            Size nBuckets,
            const Period& integrationStep = Period(10, Years));

        Real nominal() const { return nominal_; }
        Real lgd() const { return lgd_; }
        Real attachment() const { return attachment_; }
        Real detachment() const { return detachment_; }
        std::vector<Real> nominals() { return nominals_; }
        Size size() { return basket_.size(); }

        bool isExpired() const override;
        Rate fairPremium() const;
        Rate premiumValue () const;
        Rate protectionValue () const;
        Size error () const;

      private:
        void setupExpired() const override;
        void performCalculations() const override;
        Real expectedTrancheLoss (Date d) const;

        Real attachment_;
        Real detachment_;
        std::vector<Real> nominals_;
        std::vector<Handle<DefaultProbabilityTermStructure> > basket_;
        Handle<OneFactorCopula> copula_;
        bool protectionSeller_;

        Schedule premiumSchedule_;
        Rate premiumRate_;
        DayCounter dayCounter_;
        Rate recoveryRate_;
        Rate upfrontPremiumRate_;
        Handle<YieldTermStructure> yieldTS_;
        Size nBuckets_; // number of buckets up to detachment point
        Period integrationStep_;

        std::vector<Real> lgds_;

        Real nominal_;  // total basket volume (sum of nominals_)
        Real lgd_;      // maximum loss given default (sum of lgds_)
        Real xMax_;     // tranche detachment point (tranche_ * nominal_)
        Real xMin_;     // tranche attachment point (tranche_ * nominal_)

        mutable Size error_;

        mutable Real premiumValue_;
        mutable Real protectionValue_;
        mutable Real upfrontPremiumValue_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="162">
    <source>credit/cdsoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Stamm
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/cdsoption.hpp>
#include <ql/experimental/credit/blackcdsoptionengine.hpp>
#include <ql/exercise.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/solvers1d/brent.hpp>

namespace QuantLib {

    namespace {

        class ImpliedVolHelper {
          public:
            ImpliedVolHelper(
                   const CdsOption& cdsoption,
                   const Handle<DefaultProbabilityTermStructure>& probability,
                   Real recoveryRate,
                   const Handle<YieldTermStructure>& termStructure,
                   Real targetValue)
            : targetValue_(targetValue), vol_(ext::make_shared<SimpleQuote>(0.0)) {

                Handle<Quote> h(vol_);
                engine_ = ext::shared_ptr<PricingEngine>(
                           new BlackCdsOptionEngine(probability, recoveryRate,
                                                    termStructure, h));
                cdsoption.setupArguments(engine_->getArguments());

                results_ =
                    dynamic_cast<const Instrument::results*>(
                                                       engine_->getResults());
            }
            Real operator()(Volatility x) const {
                vol_->setValue(x);
                engine_->calculate();
                return results_->value-targetValue_;
            }
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };

    }


    CdsOption::CdsOption(const ext::shared_ptr<CreditDefaultSwap>& swap,
                         const ext::shared_ptr<Exercise>& exercise,
                         bool knocksOut)
    : Option(ext::shared_ptr<Payoff>(new NullPayoff), exercise),
      swap_(swap), knocksOut_(knocksOut) {
        QL_REQUIRE(swap->side() == Protection::Buyer || knocksOut_,
                   "receiver CDS options must knock out");
        QL_REQUIRE(!swap->upfront(), "underlying must be running-spread only");
        registerWith(swap_);
    }

    bool CdsOption::isExpired () const {
        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void CdsOption::setupExpired() const {
        Instrument::setupExpired();
        riskyAnnuity_ = 0.0;
    }

    void CdsOption::setupArguments(PricingEngine::arguments* args) const {
        swap_->setupArguments(args);
        Option::setupArguments(args);

        auto* arguments = dynamic_cast<CdsOption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->swap      = swap_;
        arguments->knocksOut = knocksOut_;
    }

    void CdsOption::fetchResults(const PricingEngine::results* r) const {
        Option::fetchResults(r);
        const auto* results = dynamic_cast<const CdsOption::results*>(r);
        QL_ENSURE(results != nullptr, "wrong results type");
        riskyAnnuity_ = results->riskyAnnuity;
    }



    Rate CdsOption::atmRate() const{
        return swap_->fairSpread();
    }

    Real CdsOption::riskyAnnuity() const {
        calculate();
        QL_REQUIRE(riskyAnnuity_ != Null<Real>(), "risky annuity not provided");
        return riskyAnnuity_;
    }

    Volatility CdsOption::impliedVolatility(
                   Real targetValue,
                   const Handle<YieldTermStructure>& termStructure,
                   const Handle<DefaultProbabilityTermStructure>& probability,
                   Real recoveryRate,
                   Real accuracy,
                   Size maxEvaluations,
                   Volatility minVol,
                   Volatility maxVol) const {
        calculate();
        QL_REQUIRE(!isExpired(), "instrument expired");

        Volatility guess = 0.10;

        ImpliedVolHelper f(*this, probability, recoveryRate,
                           termStructure, targetValue);
        Brent solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }



    void CdsOption::arguments::validate() const {
        CreditDefaultSwap::arguments::validate();
        Option::arguments::validate();
        QL_REQUIRE(swap, "CDS not set");
        QL_REQUIRE(exercise, "exercise not set");
    }

    void CdsOption::results::reset() {
        Option::results::reset();
        riskyAnnuity = Null<Real>();
    }

}

]]></document_content>
  </document>
  <document index="163">
    <source>credit/cdsoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Stamm
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cdsoption.hpp
    \brief CDS option
*/

#ifndef quantlib_cds_option_hpp
#define quantlib_cds_option_hpp

#include <ql/option.hpp>
#include <ql/instruments/creditdefaultswap.hpp>

namespace QuantLib {

    class Quote;
    class YieldTermStructure;

    //! CDS option
    /*! The side of the swaption is set by choosing the side of the CDS.
        A receiver CDS option is a right to buy an underlying CDS
        selling protection and receiving a coupon. A payer CDS option
        is a right to buy an underlying CDS buying protection and
        paying coupon.
    */
    class CdsOption : public Option {
      public:
        class arguments;
        class results;
        class engine;
        CdsOption(const ext::shared_ptr<CreditDefaultSwap>& swap,
                  const ext::shared_ptr<Exercise>& exercise,
                  bool knocksOut = true);

        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        const ext::shared_ptr<CreditDefaultSwap>& underlyingSwap() const {
            return swap_;
        }
        //@}
        //! \name Calculations
        //@{
        Rate atmRate() const;
        Real riskyAnnuity() const;
        Volatility impliedVolatility(
                              Real price,
                              const Handle<YieldTermStructure>& termStructure,
                              const Handle<DefaultProbabilityTermStructure>&,
                              Real recoveryRate,
                              Real accuracy = 1.e-4,
                              Size maxEvaluations = 100,
                              Volatility minVol = 1.0e-7,
                              Volatility maxVol = 4.0) const;
        //@}

    private:
        ext::shared_ptr<CreditDefaultSwap> swap_;
        bool knocksOut_;

        mutable Real riskyAnnuity_;
        void setupExpired() const override;
        void fetchResults(const PricingEngine::results*) const override;
    };


    //! %Arguments for CDS-option calculation
    class CdsOption::arguments : public CreditDefaultSwap::arguments,
                                 public Option::arguments {
      public:
        arguments() = default;

        ext::shared_ptr<CreditDefaultSwap> swap;
        bool knocksOut;
        void validate() const override;
    };

    //! %Results from CDS-option calculation
    class CdsOption::results : public Option::results {
      public:
        Real riskyAnnuity;
        void reset() override;
    };

    //! base class for swaption engines
    class CdsOption::engine
        : public GenericEngine<CdsOption::arguments, CdsOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="164">
    <source>credit/constantlosslatentmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_constantloss_latentmodel_hpp
#define quantlib_constantloss_latentmodel_hpp

#include <ql/experimental/credit/defaultprobabilitylatentmodel.hpp>
// take the loss model to a different file and avoid this inclusion
#include <ql/experimental/credit/defaultlossmodel.hpp>

namespace QuantLib {

    /*! Constant deterministic loss amount default latent model. Integrable 
        implementation.
    */
    /* \todo: 
        Several options: Refer to a set of individual RR models, have quotes to
        RRs (registered)
    */
    template <class copulaPolicy>
    class ConstantLossLatentmodel : public DefaultLatentModel<copulaPolicy> {
    private:
        const std::vector<Real> recoveries_;
        typedef typename copulaPolicy::initTraits initTraits;
    public:
        ConstantLossLatentmodel(
            const std::vector<std::vector<Real> >& factorWeights,
            const std::vector<Real>& recoveries,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            const initTraits& ini = initTraits()            
            ) 
        : DefaultLatentModel<copulaPolicy>(factorWeights, integralType, ini),
          recoveries_(recoveries) {

              QL_REQUIRE(recoveries.size() == factorWeights.size(), 
                "Incompatible factors and recovery sizes.");
        }

        ConstantLossLatentmodel(
            const Handle<Quote>& mktCorrel,
            const std::vector<Real>& recoveries,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            Size nVariables,
            const initTraits& ini = initTraits()            
            ) 
        : DefaultLatentModel<copulaPolicy>(mktCorrel, nVariables,
                                           integralType, ini),
          recoveries_(recoveries) {
            // actually one could define the other and get rid of the variable 
            // here and in other similar models
            QL_REQUIRE(recoveries.size() == nVariables, 
                "Incompatible model and recovery sizes.");
        }

        Real conditionalRecovery(const Date& d, Size iName, 
                                 const std::vector<Real>& mktFactors) const {
            return recoveries_[iName];
        }

        Real conditionalRecovery(Probability uncondDefP, Size iName, 
                                 const std::vector<Real>& mktFactors) const {
            return recoveries_[iName];
        }

        Real conditionalRecoveryInvP(Real invUncondDefP, Size iName, 
                                 const std::vector<Real>& mktFactors) const {
            return recoveries_[iName];
        }

        Real conditionalRecovery(Real latentVarSample, 
            Size iName, const Date& d) const {
            return recoveries_[iName];
        }

        const std::vector<Real>& recoveries() const {
            return recoveries_;
        }

        // this is really an interface to rr models even if not imposed. Default
        // loss models do have an interface for this one. Enforced only through
        // duck typing.
        Real expectedRecovery(const Date& d, Size iName, 
            const DefaultProbKey& defKeys) const {
            return recoveries_[iName];
        }
    };

    typedef ConstantLossLatentmodel<GaussianCopulaPolicy> 
        GaussianConstantLossLM;
    typedef ConstantLossLatentmodel<TCopulaPolicy> TConstantLossLM;


    /*! ConstantLossLatentModel interface for loss models. 
    While it does not provide distribution type losses (e.g. expected tranche 
    losses) because it lacks an integration algorithm it serves to allow 
    pricing of digital type products like NTDs.

    Alternatively fuse with the aboves class.
    */
    template <class copulaPolicy>
    class ConstantLossModel : 
        public virtual ConstantLossLatentmodel<copulaPolicy>, 
        public virtual DefaultLossModel 
    {
    public:
        ConstantLossModel(
            const std::vector<std::vector<Real> >& factorWeights,
            const std::vector<Real>& recoveries,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            const typename copulaPolicy::initTraits& ini = 
                copulaPolicy::initTraits()) 
        : ConstantLossLatentmodel<copulaPolicy>(factorWeights, recoveries, 
            integralType, ini) {}

        ConstantLossModel(
            const Handle<Quote>& mktCorrel,
            const std::vector<Real>& recoveries,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            Size nVariables,
            const typename copulaPolicy::initTraits& ini = 
                copulaPolicy::initTraits()) 
        : ConstantLossLatentmodel<copulaPolicy>(mktCorrel, recoveries, 
            integralType, nVariables,ini) {}

    protected:
        //Disposable<std::vector<Probability> > probsBeingNthEvent(
        //    Size n, const Date& d) const {
        //    return 
        //      ConstantLossLatentmodel<copulaPolicy>::probsBeingNthEvent(n, d);
        //}
      Real defaultCorrelation(const Date& d, Size iName, Size jName) const override {
          return ConstantLossLatentmodel<copulaPolicy>::defaultCorrelation(d, iName, jName);
      }
      Probability probAtLeastNEvents(Size n, const Date& d) const override {
          return ConstantLossLatentmodel<copulaPolicy>::probAtLeastNEvents(n, d);
      }
      Real expectedRecovery(const Date& d, Size iName, const DefaultProbKey& k) const override {
          return ConstantLossLatentmodel<copulaPolicy>::expectedRecovery(d, iName, k);
      }

    private:
      void resetModel() override {
          // update the default latent model we derive from
          DefaultLatentModel<copulaPolicy>::resetBasket(
              DefaultLossModel::basket_.currentLink()); // forces interface
      }
    };

}

#endif
]]></document_content>
  </document>
  <document index="165">
    <source>credit/correlationstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/correlationstructure.hpp>

namespace QuantLib {

    CorrelationTermStructure::CorrelationTermStructure(
        const Calendar& cal,
        BusinessDayConvention bdc,
        const DayCounter& dc)
    : TermStructure(dc), bdc_(bdc){
        calendar_ = cal;
    }

    CorrelationTermStructure::CorrelationTermStructure(
        Natural settlementDays,
        const Calendar& cal,
        BusinessDayConvention bdc,
        const DayCounter& dc)
    : TermStructure(settlementDays, cal, dc), bdc_(bdc){ }

}
]]></document_content>
  </document>
  <document index="166">
    <source>credit/correlationstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_correl_term_structure_hpp
#define quantlib_correl_term_structure_hpp

#include <ql/termstructure.hpp>

namespace QuantLib {

    // pretty much like the volatility TS, here the correlation range is 
    // obviously known in advance and theres no reference to a strike.

    /*! Abstract interface, derived correlations TS might have elements with 
    arbitrary dimensions.\par
    In principle there might be several extrapolation dimensions, at this 
    level we do not know how many or the nature of those dimensions (time, 
    strike...) 
    Equally we ignore at this level if the correlation is a number, 
    matrix. Rather than including an arbitrary size matrix this data
    structure is deferred in the hierarchy to enable potential optimizations
    on the data nature.
    */
    class CorrelationTermStructure : public TermStructure {
    public:
        /*! \name Constructors
            See the TermStructure documentation for issues regarding
            constructors.
        */
        //@{
        //! default constructor
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        CorrelationTermStructure(const Calendar& cal,
                                 BusinessDayConvention bdc,
                                 const DayCounter& dc = DayCounter());
        //! initialize with a fixed reference date
        CorrelationTermStructure(const Date& referenceDate,
                                 const Calendar& cal,
                                 BusinessDayConvention bdc,
                                 const DayCounter& dc = DayCounter());
        //! calculate the reference date based on the global evaluation date
        CorrelationTermStructure(Natural settlementDays,
                                 const Calendar& cal,
                                 BusinessDayConvention bdc,
                                 const DayCounter& dc = DayCounter());
        //@}
        BusinessDayConvention businessDayConvention() const;
        //! period/date conversion
        Date dateFromTenor(const Period&) const;
        //! The size of the squared correlation.
        virtual Size correlationSize() const = 0;
    private:
        BusinessDayConvention bdc_;
    };

    // inline definitions
    inline BusinessDayConvention
    CorrelationTermStructure::businessDayConvention() const {
        return bdc_;
    }

    inline Date
    CorrelationTermStructure::dateFromTenor(const Period& p) const {
        // swaption style, still holds here.
        return calendar().advance(referenceDate(),
                                  p,
                                  businessDayConvention());
    }
}

#endif
]]></document_content>
  </document>
  <document index="167">
    <source>credit/defaultevent.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/defaultevent.hpp>
#include <ql/experimental/credit/recoveryratequote.hpp>
#include <ql/patterns/visitor.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    Date DefaultEvent::date() const {
        return defaultDate_;
    }

    void DefaultEvent::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<DefaultEvent>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Event::accept(v);
    }

    // They will be sorted by settlement date
    Date DefaultEvent::DefaultSettlement::date() const {
        return settlementDate_;
    }

    void DefaultEvent::DefaultSettlement::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<DefaultEvent::DefaultSettlement>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Event::accept(v);
    }

    DefaultEvent::DefaultSettlement::DefaultSettlement(
        const Date& date,
        const std::map<Seniority, Real>& recoveryRates )
    : settlementDate_(date), recoveryRates_(recoveryRates) {
        QL_REQUIRE(recoveryRates.find(NoSeniority) ==
            recoveryRates.end(),
            "NoSeniority is not a valid realized seniority.");
    }

    DefaultEvent::DefaultSettlement::DefaultSettlement(
        const Date& date,
        Seniority seniority,
        const Real recoveryRate)
    : settlementDate_(date), recoveryRates_(makeIsdaConvMap()) {
        if (seniority == NoSeniority) {
            for (auto& i : recoveryRates_) {
                i.second = recoveryRate;
            }
        } else {
            recoveryRates_[seniority] = recoveryRate;
        }
    }

    Real DefaultEvent::DefaultSettlement::recoveryRate(
        Seniority sen) const {
        // expensive require cause called often...... fix me
        QL_REQUIRE(sen != NoSeniority,
            "NoSeniority is not valid for recovery rate request.");
        auto itmatch = recoveryRates_.find(sen);
        if(itmatch != recoveryRates_.end()) {
            return itmatch->second;
        }else{
            return Null<Real>();
        }
    }

    DefaultEvent::DefaultEvent(const Date& creditEventDate,
                               const DefaultType& atomicEvType,
                               Currency curr,
                               Seniority bondsSen,
                               // Settlement information:
                               const Date& settleDate,
                               const std::map<Seniority, Real>& recoveryRates)
    : bondsCurrency_(std::move(curr)), defaultDate_(creditEventDate), eventType_(atomicEvType),
      bondsSeniority_(bondsSen),
      defSettlement_(settleDate, recoveryRates.empty() ? makeIsdaConvMap() : recoveryRates) {
        if(settleDate != Null<Date>()) {// has settled
            QL_REQUIRE(settleDate >= creditEventDate,
              "Settlement date should be after default date.");
            QL_REQUIRE(recoveryRates.find(bondsSen) != recoveryRates.end(),
              "Settled events must contain the seniority of the default");
        }
    }

    DefaultEvent::DefaultEvent(const Date& creditEventDate,
                               const DefaultType& atomicEvType,
                               Currency curr,
                               Seniority bondsSen,
                               // Settlement information:
                               const Date& settleDate,
                               Real recoveryRate)
    : bondsCurrency_(std::move(curr)), defaultDate_(creditEventDate), eventType_(atomicEvType),
      bondsSeniority_(bondsSen), defSettlement_(settleDate, bondsSen, recoveryRate) {
        if(settleDate != Null<Date>()) {
            QL_REQUIRE(settleDate >= creditEventDate,
            "Settlement date should be after default date.");
        }
    }

    bool DefaultEvent::matchesDefaultKey(
        const DefaultProbKey& contractKey) const {
        if(bondsCurrency_ != contractKey.currency()) return false;
        // a contract with NoSeniority matches all events
        if((bondsSeniority_ != contractKey.seniority())
            && (contractKey.seniority() != NoSeniority))
            return false;
        // loop on all event types in the contract and chek if we match any,
        //   calls derived types
        for(Size i=0; i<contractKey.size(); i++) {
            if(this->matchesEventType(contractKey.eventTypes()[i])) return true;
        }
        return false;
    }



    bool operator==(const DefaultEvent& lhs, const DefaultEvent& rhs) {
        return (lhs.currency() == rhs.currency()) &&
            (lhs.defaultType() == rhs.defaultType()) &&
            (lhs.date() == rhs.date()) &&
            (lhs.eventSeniority() == rhs.eventSeniority());
    }


    bool FailureToPayEvent::matchesEventType(
        const ext::shared_ptr<DefaultType>& contractEvType) const {
        ext::shared_ptr<FailureToPay> eveType =
            ext::dynamic_pointer_cast<FailureToPay>(contractEvType);
        // this chekcs the atomic types, no need to call parents method
        if(!eveType) return false;
        if(defaultedAmount_ < eveType->amountRequired()) return false;
        Date today = Settings::instance().evaluationDate();
        return this->hasOccurred(today - eveType->gracePeriod(), true);
    }



    FailureToPayEvent::FailureToPayEvent(const Date& creditEventDate,
                                         const Currency& curr,
                                         Seniority bondsSen,
                                         Real defaultedAmount,
                                         // Settlement information:
                                         const Date& settleDate,
                                         const std::map<Seniority, Real>&
                                            recoveryRates)
    : DefaultEvent(creditEventDate,
                   DefaultType(AtomicDefault::FailureToPay,
                               Restructuring::XR),
                   curr,
                   bondsSen,
                   settleDate,
                   recoveryRates),
      defaultedAmount_(defaultedAmount) { }

    FailureToPayEvent::FailureToPayEvent(const Date& creditEventDate,
                                         const Currency& curr,
                                         Seniority bondsSen,
                                         Real defaultedAmount,
                                         // Settlement information:
                                         const Date& settleDate,
                                         Real recoveryRates)
    : DefaultEvent(creditEventDate,
                   DefaultType(AtomicDefault::FailureToPay,
                               Restructuring::XR),
                   curr,
                   bondsSen,
                   settleDate,
                   recoveryRates),
      defaultedAmount_(defaultedAmount) { }



    BankruptcyEvent::BankruptcyEvent(const Date& creditEventDate,
                                     const Currency& curr,
                                     Seniority bondsSen,
                                     // Settlement information:
                                     const Date& settleDate,
                                     const std::map<Seniority, Real>&
                                        recoveryRates)
    : DefaultEvent(creditEventDate,
                   DefaultType(AtomicDefault::Bankruptcy,
                               Restructuring::XR),
                   curr,
                   bondsSen,
                   settleDate,
                   recoveryRates) {
        if(hasSettled()) {
            QL_REQUIRE(recoveryRates.size() == makeIsdaConvMap().size(),
              "Bankruptcy event should have settled for all seniorities.");
        }
    }

    BankruptcyEvent::BankruptcyEvent(const Date& creditEventDate,
                                     const Currency& curr,
                                     Seniority bondsSen,
                                     // Settlement information:
                                     const Date& settleDate,
                                     // means same for all
                                     Real recoveryRates)
    : DefaultEvent(creditEventDate,
                   DefaultType(AtomicDefault::Bankruptcy,
                               Restructuring::XR),
                   curr,
                   bondsSen,
                   settleDate,
                   recoveryRates) { }

}
]]></document_content>
  </document>
  <document index="168">
    <source>credit/defaultevent.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file defaultevent.hpp
    \brief Classes for default-event description.
*/

#ifndef quantlib_default_event_hpp
#define quantlib_default_event_hpp

#include <ql/event.hpp>
#include <ql/currency.hpp>
#include <ql/math/comparison.hpp>
#include <ql/experimental/credit/defaulttype.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#include <map>

namespace QuantLib {

    /**
    @class DefaultEvent
    @brief Credit event on a bond of a certain seniority(ies)/currency

      Represents a credit event affecting all bonds with a given \
      seniority and currency. It assumes that all such bonds suffer \
      the event simultaneously.
      Some events affect all seniorities and this has to be encoded
      through a different set of events of the same event type.
      The event is an actual realization, not a contractual reference,
      as such it contains only an atomic type.
    */
    class DefaultEvent : public Event {
      public:
        class DefaultSettlement : public Event {
          public:
            friend class DefaultEvent;
          protected:
            /*! Default settlement events encode the settlement date
                and the recovery rates for the affected
                seniorities. Specific events might require different
                sets of recoveries to be present. The way these
                objects are constructed is a prerogative of the
                particular event class.
            */
            DefaultSettlement(const Date& date,
                              const std::map<Seniority, Real>& recoveryRates);
            /*! When NoSeniority is passed all seniorities are assumed
                to have settled to the recovery passed.
            */
            DefaultSettlement(const Date& date = Date(),
                              Seniority seniority = NoSeniority,
                              Real recoveryRate = 0.4);
          public:
            Date date() const override;
            /*! Returns the recovery rate of a default event which has already
                settled.
            */
            Real recoveryRate(Seniority sen) const;
            void accept(AcyclicVisitor&) override;

          private:
            Date settlementDate_;
            //! Realized recovery rates
            std::map<Seniority, Real> recoveryRates_;
        };
      private:
        // for some reason, gcc chokes on the default parameter below
        // unless we use the typedef
        typedef std::map<Seniority, Real> rate_map;
      public:
        /*! Credit event with optional settlement
            information. Represents a credit event that has taken
            place. Realized events are of an atomic type.  If the
            settlement information is given seniorities present are
            the seniorities/bonds affected by the event.
        */
        DefaultEvent(const Date& creditEventDate,
                     const DefaultType& atomicEvType,
                     Currency curr,
                     Seniority bondsSen,
                     // Settlement information:
                     const Date& settleDate = Null<Date>(),
                     const std::map<Seniority, Real>& recoveryRates = rate_map());
        /*! Use NoSeniority to settle to all seniorities with that
            recovery. In that case the event is assumed to have
            affected all seniorities.
        */
        DefaultEvent(const Date& creditEventDate,
                     const DefaultType& atomicEvType,
                     Currency curr,
                     Seniority bondsSen,
                     // Settlement information:
                     const Date& settleDate = Null<Date>(),
                     Real recoveryRate = 0.4);

        Date date() const override;
        bool isRestructuring() const { return eventType_.isRestructuring(); }
        bool isDefault() const { return !isRestructuring();}
        bool hasSettled() const {
            return defSettlement_.date() != Null<Date>();
        }
        const DefaultSettlement& settlement() const {
            return defSettlement_;
        }
        const DefaultType& defaultType() const {
            return eventType_;
        }
        //! returns the currency of the bond this event refers to.
        const Currency& currency() const {
            return bondsCurrency_;
        }
        //! returns the seniority of the bond that triggered the event.
        Seniority eventSeniority() const {
            return bondsSeniority_;
        }
        /*! returns a value if the event lead to a settlement for the
            requested seniority.  Specializations on the default
            atomics and recoveries could change the default policy.
        */
        virtual Real recoveryRate(Seniority seniority) const {
            if(hasSettled()) {
                return defSettlement_.recoveryRate(seniority);
            }
            return Null<Real>();
        }

        /*! matches the event if this event would trigger a contract
            related to the requested event type.  Notice the
            contractual event types are not neccesarily atomic.
            Notice it does not check seniority or currency only event
            type.  typically used from Issuer
        */
        virtual bool matchesEventType(
                 const ext::shared_ptr<DefaultType>& contractEvType) const {
            // remember we are made of an atomic type.
            // behaviour by default...
            return
                contractEvType->containsRestructuringType(
                    eventType_.restructuringType()) &&
                contractEvType->containsDefaultType(
                    eventType_.defaultType());
        }
        /*! Returns true if this event would trigger a contract with
            the arguments characteristics.
        */
        virtual bool matchesDefaultKey(const DefaultProbKey& contractKey) const;

        void accept(AcyclicVisitor&) override;

      protected:
        Currency bondsCurrency_;
        Date defaultDate_;
        DefaultType eventType_;
        Seniority bondsSeniority_;
        DefaultSettlement defSettlement_;
    };

    /*! Two credit events are the same independently of their
        settlement member data. This has the side effect of
        overwritting different settlements from the same credit event
        when, say, inserting in a map. But on the other hand one given
        event can only have one settlement. This means we can not have
        two restructuring events on a bond on the same date.
    */
    bool operator==(const DefaultEvent& lhs, const DefaultEvent& rhs);

    inline bool operator!=(const DefaultEvent& lhs, const DefaultEvent& rhs) {
        return !(lhs == rhs);
    }

    template<>
    struct earlier_than<DefaultEvent> {
        bool operator()(const DefaultEvent& e1,
                        const DefaultEvent& e2) const {
            return e1.date() < e2.date();
        }
    };


    // ------------------------------------------------------------------------

    class FailureToPayEvent : public DefaultEvent {
      public:
        FailureToPayEvent(const Date& creditEventDate,
                          const Currency& curr,
                          Seniority bondsSen,
                          Real defaultedAmount,
                          // Settlement information:
                          const Date& settleDate,
                          const std::map<Seniority, Real>& recoveryRates);
        FailureToPayEvent(const Date& creditEventDate,
                          const Currency& curr,
                          Seniority bondsSen,
                          Real defaultedAmount,
                          // Settlement information:
                          const Date& settleDate,
                          Real recoveryRates);
        Real amountDefaulted() const {return defaultedAmount_;}
        bool matchesEventType(const ext::shared_ptr<DefaultType>& contractEvType) const override;

      private:
        Real defaultedAmount_;
    };


    // ------------------------------------------------------------------------

    class BankruptcyEvent : public DefaultEvent {
      public:
        BankruptcyEvent(const Date& creditEventDate,
                        const Currency& curr,
                        Seniority bondsSen,
                        // Settlement information:
                        const Date& settleDate,
                        const std::map<Seniority, Real>& recoveryRates);
        BankruptcyEvent(const Date& creditEventDate,
                        const Currency& curr,
                        Seniority bondsSen,
                        // Settlement information:
                        const Date& settleDate,
                        // means same for all
                        Real recoveryRates);
        //! This is a stronger than all event and will trigger all of them.
        bool matchesEventType(const ext::shared_ptr<DefaultType>&) const override { return true; }
    };

}

#endif
]]></document_content>
  </document>
  <document index="169">
    <source>credit/defaultlossmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_defaultlossmodel_hpp
#define quantlib_defaultlossmodel_hpp

#include <ql/instruments/claim.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#include <ql/utilities/disposable.hpp>
#include <ql/experimental/credit/basket.hpp>

#include <ql/utilities/null_deleter.hpp>

/* Intended to replace LossDistribution in 
    ql/experimental/credit/lossdistribution, not sure its covering all the 
    functionality (see mthod below)
*/

namespace QuantLib {

    /*! Default loss model interface definition.
    Allows communication between the basket and specific algorithms. Intended to
    hold any kind of portfolio joint loss, latent models, top-down,....

    An inconvenience of this design as opposed to the full arguments/results
    is that when pricing several derivatives instruments on the same basket
    not all the pricing engines would point to the same loss model; thus when
    pricing a set of such instruments there might be some switching on the 
    basket loss models, which might require recalculations (of the basket) or 
    not depending on the pricing order.
    */
    class DefaultLossModel : public Observable {// joint-? basket?-defaultLoss
     /* Protection together with frienship to avoid the need of checking the 
     basket-argument pointer integrity. It is the responsibility of the basket 
     now; our only caller.
     */
        friend class Basket;
    protected:
        // argument basket:
        mutable RelinkableHandle<Basket> basket_;

        DefaultLossModel() = default;
        //! \name Statistics
        //@{
        /* Non mandatory implementations, fails if client is not providing what 
        requested. */

        /* Default implementation using the expectedLoss(Date) method. 
          Typically this method is called repeatedly with the same 
          date parameter which makes it innefficient. */
        virtual Real expectedTrancheLoss(const Date& d) const {
            QL_FAIL("expectedTrancheLoss Not implemented for this model.");
        }
        /*! Probability of the tranche losing the same or more than the 
            fractional amount given.

            The passed lossFraction is a fraction of losses over the
            tranche notional (not the portfolio).
        */
        virtual Probability probOverLoss(
            const Date& d, Real lossFraction) const {
            QL_FAIL("probOverLoss Not implemented for this model.");   
        }
        //! Value at Risk given a default loss percentile.
        virtual Real percentile(const Date& d, Real percentile) const {
            QL_FAIL("percentile Not implemented for this model.");   
        }
        //! Expected shortfall given a default loss percentile.
        virtual Real expectedShortfall(const Date& d, Real percentile) const {
            QL_FAIL("eSF Not implemented for this model.");   
        }
        //! Associated VaR fraction to each counterparty.
        virtual Disposable<std::vector<Real> >
            splitVaRLevel(const Date& d, Real loss) const {
            QL_FAIL("splitVaRLevel Not implemented for this model.");   
        }
        //! Associated ESF fraction to each counterparty.
        virtual Disposable<std::vector<Real> >
            splitESFLevel(const Date& d, Real loss) const {
            QL_FAIL("splitESFLevel Not implemented for this model.");   
        }

        // \todo Add splits by instrument position.

        //! Full loss distribution.
        virtual Disposable<std::map<Real, Probability> > 
            lossDistribution(const Date&) const {
            QL_FAIL("lossDistribution Not implemented for this model.");   
        }
        //! Probability density of a given loss fraction of the basket notional.
        virtual Real densityTrancheLoss(
            const Date& d, Real lossFraction) const {
            QL_FAIL("densityTrancheLoss Not implemented for this model.");
        }
        /*! Probabilities for each of the (remaining) basket elements in the 
        pool to have defaulted by time d and at the same time be the Nth 
        defaulting name to default in the basket. This method is oriented to 
        default order dependent portfolio pricing (e.g. NTDs)
            The the probabilities ordering in the vector coincides with the 
            pool order.
        */
        virtual Disposable<std::vector<Probability> > probsBeingNthEvent(
            Size n, const Date& d) const {
            QL_FAIL("probsBeingNthEvent Not implemented for this model.");
        }
        //! Pearsons' default probability correlation. 
        virtual Real defaultCorrelation(const Date& d, Size iName, 
            Size jName) const {
            QL_FAIL("defaultCorrelation Not implemented for this model.");
        }
        /*! Returns the probaility of having a given or larger number of 
        defaults in the basket portfolio at a given time.
        */
        virtual Probability probAtLeastNEvents(Size n, const Date& d) const {
            QL_FAIL("probAtLeastNEvents Not implemented for this model.");
        }
        /*! Expected RR for name conditinal to default by that date.
        */
        virtual Real expectedRecovery(const Date&, Size iName, 
            const DefaultProbKey&) const {
            QL_FAIL("expected recovery Not implemented for this model.");
        }
        //@}

        /*! Send a reference to the basket to allow the model to read the 
        problem arguments (contained in the basket)
        */
    private: //can only be called from Basket
        void setBasket(Basket* bskt) {
            /* After this; if the model modifies its internal status/caches (if 
            any) it should notify the  prior basket to recognise that basket is 
            not in a calculated=true state. Since we dont know at this level if 
            the model keeps caches it is the children responsibility. Typically 
            this is done at the first call to calculate to the loss model, there
            it notifies the basket. The old basket is still registered with us 
            until the basket takes in a new model....
            ..alternatively both old basket and model could be forced reset here
            */
            basket_.linkTo(ext::shared_ptr<Basket>(bskt, null_deleter()),
                           false);
            resetModel();// or rename to setBasketImpl(...)
        }
        // the call order matters, which is the reason for the parent to be the 
        //   sole caller.
        //! Concrete models do now any updates/inits they need on basket reset
        virtual void resetModel() = 0;
    };

}

#endif
]]></document_content>
  </document>
  <document index="170">
    <source>credit/defaultprobabilitykey.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#if defined(QL_PATCH_MSVC)
#pragma warning(push)
#pragma warning(disable:4181)
#endif
#include <algorithm>
#include <set>
#include <utility>

namespace QuantLib {

    namespace {

        struct points_to {
            explicit points_to(const DefaultType& t) : t(t) {}
            bool operator()(const ext::shared_ptr<DefaultType>& p) const {
                return *p == t;
            }
            const DefaultType& t;
        };
        
    }
    
    bool operator==(const DefaultProbKey& lhs, const DefaultProbKey& rhs) {
        if(lhs.seniority() != rhs.seniority()) return false;
        if(lhs.currency() != rhs.currency()) return false;

        Size mySize = rhs.eventTypes().size();
        if(mySize != lhs.eventTypes().size()) return false;
        // the all types must be equal in the weak sense.
        for(Size i=0; i<mySize; i++) {
            if(std::find_if(lhs.eventTypes().begin(), lhs.eventTypes().end(),
                            points_to(*rhs.eventTypes()[i])) == lhs.eventTypes().end())
                return false;
        }// naah, I bet this can be done with a double lambda
        return true;
    }

    DefaultProbKey::DefaultProbKey() : obligationCurrency_(Currency()) {}

    DefaultProbKey::DefaultProbKey(std::vector<ext::shared_ptr<DefaultType> > eventTypes,
                                   Currency cur,
                                   Seniority sen)
    : eventTypes_(std::move(eventTypes)), obligationCurrency_(std::move(cur)), seniority_(sen) {
        std::set<AtomicDefault::Type> buffer;
        Size numEvents = eventTypes_.size();
        for(Size i=0; i< numEvents; i++)
            buffer.insert(eventTypes_[i]->defaultType());
        QL_REQUIRE(buffer.size() == numEvents,
            "Duplicated event type in contract definition");
    }

    NorthAmericaCorpDefaultKey::NorthAmericaCorpDefaultKey(
        const Currency& currency,
        Seniority sen,
        Period graceFailureToPay,
        Real amountFailure,
        Restructuring::Type resType)
    : DefaultProbKey(std::vector<ext::shared_ptr<DefaultType> >(),
                     currency, sen) {
        eventTypes_.push_back( ext::shared_ptr<DefaultType>(
            new FailureToPay(graceFailureToPay,
            amountFailure)));
        // no specifics for Bankruptcy
        eventTypes_.push_back( ext::make_shared<DefaultType>(
            AtomicDefault::Bankruptcy,
                            Restructuring::XR));
        if(resType != Restructuring::NoRestructuring)
            eventTypes_.push_back( ext::make_shared<DefaultType>(
                AtomicDefault::Restructuring, resType));
    }

}
]]></document_content>
  </document>
  <document index="171">
    <source>credit/defaultprobabilitykey.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file defaultprobabilitykey.hpp
    \brief Classes for default-event description.
*/

#ifndef quantlib_default_probability_key_hpp
#define quantlib_default_probability_key_hpp

#include <ql/experimental/credit/defaulttype.hpp>
#include <ql/currency.hpp>
#include <vector>

namespace QuantLib {

    /*! Used to index market implied credit curve probabilities. It is
        a proxy to the defaultable bond or class of bonds which
        determines the credit contract conditions.  It aggregates the
        atomic default types in a group defining the contract
        conditions and which serves to index the probability curves
        calibrated to the market.
    */
    class DefaultProbKey {
      protected:
        //! aggregation of event types for which the contract is sensitive.
        std::vector<ext::shared_ptr<DefaultType> > eventTypes_;
        //! Currency of the bond and protection leg payment.
        Currency obligationCurrency_;
        //! Reference bonds seniority.
        Seniority seniority_ = NoSeniority;

      public:
        DefaultProbKey();

        DefaultProbKey(std::vector<ext::shared_ptr<DefaultType> > eventTypes,
                       Currency cur,
                       Seniority sen);

        const Currency& currency() const {return obligationCurrency_;}
        Seniority seniority() const {return seniority_;}
        const std::vector<ext::shared_ptr<DefaultType> >&
            eventTypes() const {
                return eventTypes_;
        }
        Size size() const {return eventTypes_.size();}
    };

    bool operator==(const DefaultProbKey& lhs, const DefaultProbKey& rhs);


    //! ISDA standard default contractual key for corporate US debt.
    //    Restructuring here can be set to NoRestructuring.
    class NorthAmericaCorpDefaultKey : public DefaultProbKey {
      public:
        // with only one restructuring type
        NorthAmericaCorpDefaultKey(const Currency& currency,
                                   Seniority sen,
                                   Period graceFailureToPay =
                                       Period(30, Days),
                                   Real amountFailure = 1.e6,
                                   Restructuring::Type resType =
                                                           Restructuring::CR);
    };

}

#endif
]]></document_content>
  </document>
  <document index="172">
    <source>credit/defaultprobabilitylatentmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_default_latent_model_hpp
#define quantlib_default_latent_model_hpp

#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/math/latentmodel.hpp>
#include <ql/experimental/math/gaussiancopulapolicy.hpp>
#include <boost/dynamic_bitset.hpp>

namespace QuantLib {

    /*! \brief Default event Latent Model.

     This is a model for joint default events based on a generic Latent 
      Model. It models solely the default events in a portfolio, not making any 
      reference to severities, exposures, etc...
     An implicit correspondence is stablished between the variables modelled and
     the names in the basket given by the basket and model variable access 
     indices.
     The class is parametric on the Latent Model copula.

     \todo Consider QL_REQUIRE(basket_, "No portfolio basket set.") test in 
     debug model only for performance reasons.
    */
    template<class copulaPolicy>
    class DefaultLatentModel : public LatentModel<copulaPolicy> {
        // import template members
    protected:
        using LatentModel<copulaPolicy>::factorWeights_;
        using LatentModel<copulaPolicy>::idiosyncFctrs_;
        using LatentModel<copulaPolicy>::copula_;
    public:
        using LatentModel<copulaPolicy>::inverseCumulativeY;
        using LatentModel<copulaPolicy>::cumulativeZ;
        using LatentModel<copulaPolicy>::integratedExpectedValue;// which one?
    protected:
        // not a handle, the model doesnt keep any cached magnitudes, no need 
        //  for notifications, still...
        mutable ext::shared_ptr<Basket> basket_;
        ext::shared_ptr<LMIntegration> integration_;
    private:
        typedef typename copulaPolicy::initTraits initTraits;
    public:
        /*!
        @param factorWeights Latent model independent factors weights for each 
            variable.
        @param integralType Integration type.
        @param ini Copula initialization if any.

        \warning Baskets with realized defaults not tested/WIP.
        */
        DefaultLatentModel(
            const std::vector<std::vector<Real> >& factorWeights,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            const initTraits& ini = initTraits()
            ) 
        : LatentModel<copulaPolicy>(factorWeights, ini),
          integration_(LatentModel<copulaPolicy>::IntegrationFactory::
            createLMIntegration(factorWeights[0].size(), integralType))
        { }
        DefaultLatentModel(
            const Handle<Quote>& mktCorrel,
            Size nVariables,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            const initTraits& ini = initTraits()
            )
        : LatentModel<copulaPolicy>(mktCorrel, nVariables, ini),
          integration_(LatentModel<copulaPolicy>::IntegrationFactory::
            createLMIntegration(1, integralType))
        { }
        /* \todo
            Add other constructors as in LatentModel for ease of use. (less 
            dimensions, factors, etcc...)
        */

        /* To interface with loss models. It is possible to change the basket 
        since there are no cached magnitudes.
        */
        void resetBasket(const ext::shared_ptr<Basket>& basket) const {
            basket_ = basket;
            // in the future change 'size' to 'liveSize'
            QL_REQUIRE(basket_->size() == factorWeights_.size(), 
                "Incompatible new basket and model sizes.");
        }

        /*! Returns the probability of default of a given name conditional on
        the realization of a given set of values of the model independent
        factors. The date at which the probability is given is implicit in the
        probability since theres not other time dependence in this model.
        @param prob Unconditional probability of default.
        @param iName desired name.
        @param mktFactors Value of LM independent factors.
        \warning Most often it is preferred to use the method below avoiding the
        cumulative inversion.
        */
        Probability conditionalDefaultProbability(Probability prob, Size iName,
            const std::vector<Real>& mktFactors) const 
        {
            // we can be called from the outside (from an integrable loss model)
            //   but we are called often at integration points. This or
            //   consider a list of friends.
        #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(basket_, "No portfolio basket set.");
        #endif
            /*Avoid redundant call to minimum value inversion (might be \infty),
            and this independently of the copula function.
            */
            if (prob < 1.e-10) return 0.;// use library macro...
            return conditionalDefaultProbabilityInvP(
                inverseCumulativeY(prob, iName), iName, mktFactors);
        }
    protected:
      void update() override {
          if (basket_ != nullptr)
              basket_->notifyObservers();
          LatentModel<copulaPolicy>::update();
      }

    public:// open since users access it for performance on joint integrations.

        /*! Returns the probability of default of a given name conditional on
        the realization of a given set of values of the model independent
        factors. The date at which the probability is given is implicit in the
        probability since theres not other time dependent in this model.
        Same intention as above but provides a performance opportunity, if the
        integration is along the market factors (as usually is) avoids computing
        the inverse of the probability on each call.
        @param invCumYProb Inverse cumul of the unconditional probability of 
          default, has to follow the same copula law for results to be coherent
        @param iName desired name.
        @param m Value of LM independent factors.
        */
        Probability conditionalDefaultProbabilityInvP(Real invCumYProb, 
            Size iName, 
            const std::vector<Real>& m) const {
            Real sumMs = 
                std::inner_product(factorWeights_[iName].begin(), 
                    factorWeights_[iName].end(), m.begin(), 0.);
            Real res = cumulativeZ((invCumYProb - sumMs) / 
                    idiosyncFctrs_[iName] );
            #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE (res >= 0. && res <= 1.,
                        "conditional probability " << res << "out of range");
            #endif
        
            return res;
        }
    protected:
        /*! Returns the probability of default of a given name conditional on
        the realization of a given set of values of the model independent
        factors.
        @param date The date for the probability of default.
        @param iName desired name.
        @param mktFactors Value of LM independent factors.

        Same intention as the above methods. Usage of this one is typically more
        expensive because most often the date we call this method with
        repeats itself and with this one the probability can not be cached
        outside the call.
        */
        Probability conditionalDefaultProbability(const Date& date, Size iName,
            const std::vector<Real>& mktFactors) const 
        {
            const ext::shared_ptr<Pool>& pool = basket_->pool();
            Probability pDefUncond =
                pool->get(pool->names()[iName]).
                defaultProbability(basket_->defaultKeys()[iName])
                  ->defaultProbability(date);
            return conditionalDefaultProbability(pDefUncond, iName, mktFactors);
        }
        /*! Conditional default probability product, intermediate step in the 
            correlation calculation.*/
        Probability condProbProduct(Real invCumYProb1, Real invCumYProb2, 
            Size iName1, Size iName2, 
            const std::vector<Real>& mktFactors) const {
            return 
                conditionalDefaultProbabilityInvP(invCumYProb1, iName1, 
                    mktFactors) *
                conditionalDefaultProbabilityInvP(invCumYProb2, iName2, 
                    mktFactors);
        }
        //! Conditional probability of n default events or more.
        // \todo: check the issuer has not defaulted.
        Real conditionalProbAtLeastNEvents(Size n, const Date& date,
            const std::vector<Real>& mktFactors) const;
        //! access to integration:
        const ext::shared_ptr<LMIntegration>& integration() const override { return integration_; }

      public:
        /*! Computes the unconditional probability of default of a given name. 
        Trivial method for testing
        */
        Probability probOfDefault(Size iName, const Date& d) const {
            QL_REQUIRE(basket_, "No portfolio basket set.");
            const ext::shared_ptr<Pool>& pool = basket_->pool();
            // avoid repeating this in the integration:
            Probability pUncond = pool->get(pool->names()[iName]).
                defaultProbability(basket_->defaultKeys()[iName])
                ->defaultProbability(d);
            if (pUncond < 1.e-10) return 0.;

            return integratedExpectedValue(
                [&](const std::vector<Real>& v1) {
                    return conditionalDefaultProbabilityInvP(
                        inverseCumulativeY(pUncond, iName), iName, v1);
                });
        }
        /*! Pearsons' default probability correlation. 
            Users should consider specialization on the copula type for specific
            distributions since that might simplify the integrations, most 
            importantly if this is to be used in calibration of observations for
            factor coefficients as it is expensive to integrate directly.
        */
        Real defaultCorrelation(const Date& d, Size iNamei, Size iNamej) const;

        /*! Returns the probaility of having a given or larger number of 
        defaults in the basket portfolio at a given time.
        */
        Probability probAtLeastNEvents(Size n, const Date& date) const {
            return integratedExpectedValue(
                [&](const std::vector<Real>& v1) {
                    return conditionalProbAtLeastNEvents(n, date, v1);
                });
        }
    };


    //---- Defines -----------------------------------------------------------

    template<class CP>
    Real DefaultLatentModel<CP>::defaultCorrelation(const Date& d, 
        Size iNamei, Size iNamej) const 
    {
        QL_REQUIRE(basket_, "No portfolio basket set.");

        const ext::shared_ptr<Pool>& pool = basket_->pool();
        // unconditionals:
        Probability pi = pool->get(pool->names()[iNamei]).
            defaultProbability(basket_->defaultKeys()[iNamei])
            ->defaultProbability(d);
        Probability pj = pool->get(pool->names()[iNamej]).
            defaultProbability(basket_->defaultKeys()[iNamej])
            ->defaultProbability(d);
        Real pipj = pi * pj;
        Real invPi = inverseCumulativeY(pi, iNamei);
        Real invPj = inverseCumulativeY(pj, iNamej);
        // avoid repetitive calls when i=j?
        Real E1i1j; // joint default covariance term
        if(iNamei !=iNamej) {
            E1i1j = integratedExpectedValue(
                [&](const std::vector<Real>& v1) {
                    return condProbProduct(invPi, invPj, iNamei, iNamej, v1); });
        }else{
            E1i1j = pi;
        }
        return (E1i1j - pipj )/std::sqrt(pipj*(1.-pi)*(1.-pj));
    }


    template<class CP>
    Real DefaultLatentModel<CP>::conditionalProbAtLeastNEvents(Size n, 
        const Date& date,
        const std::vector<Real>& mktFactors) const {
            QL_REQUIRE(basket_, "No portfolio basket set.");

            /* \todo 
            This algorithm traverses all permutations starting form the
            lowest one. This is inneficient, there shouldnt be any need to 
            go through the invalid ones. Use combinations of n elements.

            See integration in O'Kane for homogeneous ntds.
            */
            // first position with as many defaults as desired:
            Size poolSize = basket_->size();//move to 'livesize'
            const ext::shared_ptr<Pool>& pool = basket_->pool();

            auto limit = static_cast<BigNatural>(std::pow(2., (int)(poolSize)));

            // Precalc conditional probabilities
            std::vector<Probability> pDefCond;
            for(Size i=0; i<poolSize; i++)
                pDefCond.push_back(conditionalDefaultProbability(
                    pool->get(pool->names()[i]).
                    defaultProbability(basket_->defaultKeys()[i])->
                    defaultProbability(date), i, mktFactors));

            Probability probNEventsOrMore = 0.;
            for (auto mask = static_cast<BigNatural>(std::pow(2., (int)(n)) - 1); mask < limit;
                 mask++) {
                // cheap permutations
                boost::dynamic_bitset<> bsetMask(poolSize, mask);
                if(bsetMask.count() >= n) {
                    Probability pConfig = 1;
                    for(Size i=0; i<bsetMask.size(); i++)
                        pConfig *= 
                          (bsetMask[i] ? pDefCond[i] : (1.- pDefCond[i]));
                    probNEventsOrMore += pConfig;
                }
            }
            return probNEventsOrMore;
        }


    // often used:
    typedef DefaultLatentModel<GaussianCopulaPolicy> GaussianDefProbLM;
    typedef DefaultLatentModel<TCopulaPolicy> TDefProbLM;
}

#endif
]]></document_content>
  </document>
  <document index="173">
    <source>credit/defaulttype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/defaulttype.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    DefaultType::DefaultType(AtomicDefault::Type defType,
                             Restructuring::Type restType)
    : defTypes_(defType), restrType_(restType) {
        // checks restruct and norestruct are never together.
        QL_REQUIRE((defType == AtomicDefault::Restructuring) != // xor
                   (restrType_ == Restructuring::NoRestructuring),
                   "Incoherent credit event type definition.");
    }

    bool operator==(const DefaultType& lhs, const DefaultType& rhs) {
        return (lhs.defaultType() == rhs.defaultType()) &&
            (lhs.restructuringType() == rhs.restructuringType());
    }

}

]]></document_content>
  </document>
  <document index="174">
    <source>credit/defaulttype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file defaulttype.hpp
    \brief Classes for default-event description.
*/


#ifndef quantlib_default_type_hpp
#define quantlib_default_type_hpp

#include <ql/time/period.hpp>

namespace QuantLib {

    //! Seniority of a bond.
    /*! They are also ISDA tier/seniorities used for CDS conventional
        spreads.
    */
    enum Seniority {
        SecDom = 0,
        SnrFor,
        SubLT2,
        JrSubT2,
        PrefT1,
        // Unassigned value, allows for default RR quote
        NoSeniority,
        // markit parlance
        SeniorSec     = SecDom,
        SeniorUnSec   = SnrFor,
        SubTier1      = PrefT1,
        SubUpperTier2 = JrSubT2,
        SubLoweTier2  = SubLT2
    };


    //! Atomic (single contractual event) default events.
    /*! Default types defined as enum to allow easy aggregation of
        types. Theres an event algebra logic by default provided by
        DefaultType. If your new type requires more sofisticated test
        you need to derive from it as in FailureToPay
    */
    struct AtomicDefault {
        enum Type {
            // Includes one of the restructuring cases
            Restructuring = 0,
            Bankruptcy,
            FailureToPay,
            RepudiationMoratorium,
            Acceleration,
            Default,
            // synonyms
            ObligationAcceleration = Acceleration,
            ObligationDefault = Default,
            CrossDefault = Default,
            // Other non-isda
            Downgrade,   // Non-ISDA, not in FpML
            MergerEvent  // Non-ISDA, not in FpML
        };
    };


    // these could be merged with the ones above if not because
    //   restructuring types can not be combined together.

    //! Restructuring type
    struct Restructuring {
        enum Type {
            NoRestructuring = 0,
            ModifiedRestructuring,
            ModifiedModifiedRestructuring,
            FullRestructuring,
            AnyRestructuring,
            // Markit notation:
            XR = NoRestructuring,
            MR = ModifiedRestructuring,
            MM = ModifiedModifiedRestructuring,
            CR = FullRestructuring
        };
    };


    //! Atomic credit-event type.
    /*! This class encapsulates the ISDA default contractual types and
        their combinations. Non-atomicity works only at the atomic
        type level, obviating the specific event characteristics which
        it is accounted for only in derived classes.
    */
    class DefaultType {
      public:
        explicit DefaultType(AtomicDefault::Type defType =
                                                    AtomicDefault::Bankruptcy,
                             Restructuring::Type restType = Restructuring::XR);

        virtual ~DefaultType() = default;

        AtomicDefault::Type defaultType() const {
            return defTypes_;
        }
        Restructuring::Type restructuringType() const {return restrType_;}
        bool isRestructuring() const {
            return restrType_ != Restructuring::NoRestructuring;
        }

        // bool isAtomic() const { return defTypes_.size() == 1;}

        /*! Returns true if one or a set of event types is within this
            one and as such will be recognised as a trigger. Not the
            same as equality.

            Notice that these methods do not include any event logical
            hierarchy. The match is in a strict sense. If event B is
            contained in (implied by) event A this would not send a
            match. This policies should be implemented at the
            CreditEvent class, which is polymorphic.
        */
        bool containsDefaultType(AtomicDefault::Type defType) const {
            return defTypes_ ==  defType;
        }

        bool containsRestructuringType(Restructuring::Type resType) const {
            return (restrType_ == resType) ||
                (Restructuring::AnyRestructuring == resType);
        }
    protected:
        //std::set<AtomicDefault::Type> defTypes_;
        AtomicDefault::Type defTypes_;
        Restructuring::Type restrType_;
    };


    /*! Equality is the criteria for indexing the curves. This depends
        only on the atomic types and not on idiosincracies of derived
        type as mentioned in the functional documentation (specific
        event characteristics are relevant to credit event matching
        but not to the probability meaning).  operator== is also used
        to remove duplicates in some containers. This ensures we do
        not have two equal events (despite having different
        characteristics) in those containers. This makes sense, theres
        no logic in having two FailureToPay in a contract even if they
        have different characteristics.
    */
    bool operator==(const DefaultType& lhs, const DefaultType& rhs);



    //! Failure to Pay atomic event type.
    class FailureToPay : public DefaultType {
      public:
        // Only atomic construction.
        // Amount contract by default is in dollars as per ISDA doc and not
        //   the contract curr. Theres an issue here...... FIX ME
        explicit FailureToPay(const Period& grace,
                              Real amount = 1.e+6)
        : DefaultType(AtomicDefault::FailureToPay, Restructuring::XR),
          gracePeriod_(grace), amountRequired_(amount) {}

        Real amountRequired() const {return amountRequired_;}
        const Period& gracePeriod() const {return gracePeriod_;}
      private:
        // Grace period to consider the event. If payment occurs during
        // the period the event should be removed from its container.
        Period gracePeriod_;
        // Minimum default amount triggering the event
        Real amountRequired_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="175">
    <source>credit/distribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file distribution.cpp
    \brief Discretized probability density and cumulative probability
 */

#include <ql/experimental/credit/distribution.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/functional.hpp>
#include <ql/errors.hpp>
#include <algorithm>
#include <functional>

namespace QuantLib {

    //-------------------------------------------------------------------------
    Distribution::Distribution (int nBuckets, Real xmin, Real xmax)
    //-------------------------------------------------------------------------
        : size_(nBuckets),
          xmin_(xmin), xmax_(xmax), count_(nBuckets),
          x_(nBuckets,0), dx_(nBuckets,0),
          density_(nBuckets,0),
          cumulativeDensity_(nBuckets,0),
          excessProbability_(nBuckets,0),
          cumulativeExcessProbability_(nBuckets,0),
          average_(nBuckets,0),
          overFlow_(0), underFlow_(0),
          isNormalized_(false) {
        for (int i = 0; i < nBuckets; i++) {
            dx_[i] = (xmax - xmin) / nBuckets;
            x_[i] = (i == 0 ? xmin : x_[i-1] + dx_[i-1]);
        }
        // ensure we match exactly the domain, otherwise we might fail the
        //   locate test because of precission mismatches
        dx_.back() = xmax - x_.back();
    }

    //-------------------------------------------------------------------------
    int Distribution::locate (Real x) {
    //-------------------------------------------------------------------------
        QL_REQUIRE ((x >= x_.front() || close(x, x_.front())) &&
                    (x <= x_.back() + dx_.back()
                     || close(x, x_.back() + dx_.back())),
                    "coordinate " << x
                    << " out of range [" << x_.front() << "; "
                    << x_.back() + dx_.back() << "]");
        for (Size i = 0; i < x_.size(); i++) {
            if (x_[i] > x)
                return i - 1;
        }
        return x_.size() - 1;
    }

    //-------------------------------------------------------------------------
    Real Distribution::dx (Real x) {
    //-------------------------------------------------------------------------
        int i = locate (x);
        return dx_[i];
    }

    //-------------------------------------------------------------------------
    void Distribution::add (Real value) {
    //-------------------------------------------------------------------------
        isNormalized_ = false;
        if (value < x_.front()) underFlow_++;
        else {
            for (Size i = 0; i < count_.size(); i++) {
                if (x_[i] + dx_[i] > value) {
                    count_[i]++;
                    average_[i] += value;
                    return;
                }
            }
            overFlow_++;
        }
    }

    //-------------------------------------------------------------------------
    void Distribution::addDensity (int bucket, Real value) {
    //-------------------------------------------------------------------------
        QL_REQUIRE (bucket >= 0 && bucket < size_, "bucket out of range");
        isNormalized_ = false;
        density_[bucket] += value;
    }

    //-------------------------------------------------------------------------
    void Distribution::addAverage (int bucket, Real value) {
    //-------------------------------------------------------------------------
        QL_REQUIRE (bucket >= 0 && bucket < size_, "bucket out of range");
        isNormalized_ = false;
        average_[bucket] += value;
    }

    //-------------------------------------------------------------------------
    void Distribution::normalize () {
    //-------------------------------------------------------------------------
        if (isNormalized_)
            return;

        int count = underFlow_ + overFlow_;
        for (int i = 0; i < size_; i++)
            count += count_[i];

        excessProbability_[0] = 1.0;
        cumulativeExcessProbability_[0] = 0.0;
        for (int i = 0; i < size_; i++) {
            if (count > 0) {
                density_[i] = 1.0 / dx_[i] * count_[i] / count;
                if (count_[i] > 0)
                    average_[i] /= count_[i];
            }
            if (density_[i] == 0.0)
                average_[i] = x_[i] + dx_[i]/2;

            cumulativeDensity_[i] = density_[i] * dx_[i];
            if (i > 0) {
                cumulativeDensity_[i] += cumulativeDensity_[i-1];
                excessProbability_[i] = 1.0 - cumulativeDensity_[i-1];
//                     excessProbability_[i] = excessProbability_[i-1]
//                         - density_[i-1] * dx_[i-1];
//                     cumulativeExcessProbability_[i]
//                         = (excessProbability_[i-1] +
//                            excessProbability_[i]) / 2 * dx_[i-1]
//                         + cumulativeExcessProbability_[i-1];
                cumulativeExcessProbability_[i]
                    = excessProbability_[i-1] * dx_[i-1]
                    + cumulativeExcessProbability_[i-1];
            }
        }

        isNormalized_ = true;
    }

    //-------------------------------------------------------------------------
    Real Distribution::confidenceLevel (Real quantil) {
    //-------------------------------------------------------------------------
        normalize();
        for (int i = 0; i < size_; i++) {
            if (cumulativeDensity_[i] > quantil)
                return x_[i] + dx_[i];
        }
        return x_.back() + dx_.back();
    }

    //-------------------------------------------------------------------------
    Real Distribution::expectedValue () {
    //-------------------------------------------------------------------------
        normalize();
        Real expected = 0;
        for (int i = 0; i < size_; i++) {
            Real x = x_[i] + dx_[i]/2;
            expected += x * dx_[i] * density_[i];
        }
        return expected;
    }

    //-------------------------------------------------------------------------
    Real Distribution::trancheExpectedValue (Real a, Real d) {
    //-------------------------------------------------------------------------
        normalize();
        Real expected = 0;
        for (int i = 0; i < size_; i++) {
            Real x = x_[i] + dx_[i]/2;
            if (x < a)
                continue;
            if (x > d)
                break;
            expected += (x - a) * dx_[i] * density_[i];
        }

        expected += (d - a) * (1.0 - cumulativeDensity (d));

        return expected;
    }

//     Real Distribution::cumulativeExcessProbability (Real a, Real b) {
//         //normalize();
//         Real integral = 0.0;
//         for (int i = 0; i < size_; i++) {
//             if (x_[i] >= b) break;
//             if (x_[i] >= a)
//                 integral += dx_[i] * excessProbability_[i];
//         }
//         return integral;
//     }

    //-------------------------------------------------------------------------
    Real Distribution::cumulativeExcessProbability (Real a, Real b) {
    //-------------------------------------------------------------------------
        normalize();
        QL_REQUIRE (b <= xmax_,
                 "end of interval " << b << " out of range ["
                 << xmin_ << ", " << xmax_ << "]");
        QL_REQUIRE (a >= xmin_,
                 "start of interval " << a << " out of range ["
                 << xmin_ << ", " << xmax_ << "]");

        int i = locate (a);
        int j = locate (b);
        return cumulativeExcessProbability_[j]-cumulativeExcessProbability_[i];
    }

    //-------------------------------------------------------------------------
    Real Distribution::cumulativeDensity (Real x) {
    //-------------------------------------------------------------------------
        Real tiny = dx_.back() * 1e-3;
        QL_REQUIRE (x > 0, "x must be positive");
        normalize();
        for (int i = 0; i < size_; i++) {
            if (x_[i] + dx_[i] + tiny >= x)
                return ((x - x_[i]) * cumulativeDensity_[i]
                     + (x_[i] + dx_[i] - x) * cumulativeDensity_[i-1]) / dx_[i];
        }
        QL_FAIL ("x = " << x << " beyond distribution cutoff "
                 << x_.back() + dx_.back());
    }

    //-------------------------------------------------------------------------
    // Dangerous to perform calls to members after this; transform and clone?
    void Distribution::tranche (Real attachmentPoint, Real detachmentPoint) {
    //-------------------------------------------------------------------------
        QL_REQUIRE (attachmentPoint < detachmentPoint,
                 "attachment >= detachment point");
        QL_REQUIRE (x_.back() > attachmentPoint && 
                    x_.back()+dx_.back() >= detachmentPoint,
                 "attachment or detachment too large");

        normalize();

        // shift
        while (x_[0] < attachmentPoint) {
            x_.erase(x_.begin());
            dx_.erase(dx_.begin());
            count_.erase(count_.begin());
            density_.erase(density_.begin());
            cumulativeDensity_.erase(cumulativeDensity_.begin());
            excessProbability_.erase(excessProbability_.begin());
        }

        // remove losses over detachment point:
        auto detachPosit = std::find_if(x_.begin(), x_.end(), greater_than<Real>(detachmentPoint));
        if(detachPosit != x_.end())
            x_.erase(detachPosit + 1, x_.end());

        size_ = x_.size();
        cumulativeDensity_.erase(cumulativeDensity_.begin() + size_, 
            cumulativeDensity_.end());
        cumulativeDensity_.back() = 1.; 
        count_.erase(count_.begin() + size_, count_.end());
        dx_.erase(dx_.begin() + size_, dx_.end());

        // truncate
        for (double& i : x_) {
            i = std::min(std::max(i - attachmentPoint, 0.), detachmentPoint - attachmentPoint);
        }

        density_.clear(); 
        excessProbability_.clear();
        cumulativeExcessProbability_.clear(); //? reuse?
        density_.push_back((cumulativeDensity_[0]-0.)/dx_[0]);
        excessProbability_.push_back(1.);
        for(Integer i=1; i<size_-1; i++) {
            excessProbability_.push_back(1.-cumulativeDensity_[i-1]);
            density_.push_back((cumulativeDensity_[i]-
                cumulativeDensity_[i-1])/dx_[i]);
        }
        excessProbability_.push_back(1.-cumulativeDensity_.back());
        density_.push_back((1.-cumulativeDensity_.back())/dx_.back());
    }

    //-------------------------------------------------------------------------
    Distribution ManipulateDistribution::convolve (const Distribution& d1,
                                                   const Distribution& d2) {
    //-------------------------------------------------------------------------
        // force equal constant bucket sizes
        QL_REQUIRE (d1.dx_[0] == d2.dx_[0], "bucket sizes differ in d1 and d2");
        for (Size i = 1; i < d1.size(); i++)
            QL_REQUIRE (d1.dx_[i] == d1.dx_[i-1], "bucket size varies in d1");
        for (Size i = 1; i < d2.size(); i++)
            QL_REQUIRE (d2.dx_[i] == d2.dx_[i-1], "bucket size varies in d2");

        // force offset 0
        QL_REQUIRE (d1.xmin_ == 0.0 && d2.xmin_ == 0.0,
                 "distributions offset larger than 0");

        Distribution dist(d1.size() + d2.size() - 1,
                          0.0, // assuming both distributions have xmin = 0
                          d1.xmax_ + d2.xmax_);

        for (Size i1 = 0; i1 < d1.size(); i1++) {
            Real dx = d1.dx_[i1];
            for (Size i2 = 0; i2 < d2.size(); i2++)
                dist.density_[i1+i2] = d1.density_[i1] * d2.density_[i2] * dx;
        }

        // update cumulated and excess
        dist.excessProbability_[0] = 1.0;
        for (Size i = 0; i < dist.size(); i++) {
            dist.cumulativeDensity_[i] = dist.density_[i] * dist.dx_[i];
            if (i > 0) {
                dist.cumulativeDensity_[i] += dist.cumulativeDensity_[i-1];
                dist.excessProbability_[i] = dist.excessProbability_[i-1]
                    - dist.density_[i-1] * dist.dx_[i-1];
            }
        }

        return dist;
    }


    //-------------------------------------------------------------------------
    Real Distribution::expectedShortfall (Real percValue) {
    //-------------------------------------------------------------------------
        QL_REQUIRE(percValue >= 0. && percValue <= 1., 
            "Incorrect percentile");
        normalize();
        Real expected = 0;
        Integer iVal = locate(confidenceLevel(percValue));

        if(iVal == size_-1) return x_.back();

        for (int i = iVal; i < size_; i++)
            expected += x_[i] * 
                (cumulativeDensity_[i] - cumulativeDensity_[i-1]);
        return expected/(1.-cumulativeDensity_.at(iVal));
    }

}
]]></document_content>
  </document>
  <document index="176">
    <source>credit/distribution.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file distribution.hpp
    \brief Discretized probability density and cumulative probability
*/

#ifndef quantlib_probability_distribution_hpp
#define quantlib_probability_distribution_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    //! Discretized probability density and cumulative probability
    /*! Discretized probability density and cumulative probability
      \ingroup probability
    */
    class ManipulateDistribution;
    class Distribution {
    public:
        friend class ManipulateDistribution;
        Distribution (int nBuckets, Real xmin, Real xmax);
        Distribution() = default;
        ;

        void add (Real value);
        void addDensity (int bucket, Real value);
        void addAverage (int bucket, Real value);
        void normalize ();

        Size size () const { return size_; }
        Real x (Size k) { return x_.at(k); }
        std::vector<Real>& x () { return x_; }
        Real dx (Size k) { return dx_.at(k); }
        std::vector<Real>& dx () { return dx_; }
        Real dx (Real x);

        Real density (Size k) {
            normalize();
            return density_.at(k);
        }
        Real cumulative (Size k) {
            normalize();
            return cumulativeDensity_.at(k);
        }
        Real excess (Size k) {
            normalize();
            return excessProbability_.at(k);
        }
        Real cumulativeExcess (Size k) {
            normalize();
            return cumulativeExcessProbability_.at(k);
        }
        Real average (Size k) { return average_.at(k); }

        Real confidenceLevel (Real quantil);
        Real cumulativeDensity (Real x);
        Real cumulativeExcessProbability (Real a, Real b);
        Real expectedValue ();
        Real trancheExpectedValue (Real a, Real d);

        template <class F>
        Real expectedValue (F& f) {
            normalize();
            Real expected = 0;
            for (int i = 0; i < size_; i++) {
                Real x = x_[i] + dx_[i]/2;
                expected += f (x) * dx_[i] * density_[i];
            }
            return expected;
        }

        /*!
          Transform the loss distribution into the tranche loss distribution
          for losses L_T = min(L,D) - min(L,A).
          The effects are:
          1) shift the distribution to the left by A, then
          2) cut off at D-A, Pr(L_T > D-A) = 0
          3) ensure Pr(L_T >= 0) = 1, i.e. a density spike at L_T = 0
         */
        void tranche (Real attachmentPoint, Real detachmentPoint);

        /*
          index of the grid point to the left of x
        */
        int locate (Real x);

        /* Returns the average value conditional on values above
        the passed percentile probability */
        Real expectedShortfall (Real percValue);
    private:
        int size_;
        Real xmin_, xmax_;
        std::vector<int> count_;
        // x: coordinate of left hand cell bundary
        // dx: cell width
        std::vector<Real> x_, dx_;
        // density: probability density, densitx*dx = prob. of loss in cell i
        // cumulatedDensity: cumulated (integrated) from x = 0
        // excessProbability: cumulated from x_i to infinity
        // cumulativeExcessProbability: integrated excessProbability from x = 0
        std::vector<Real> density_, cumulativeDensity_;
        std::vector<Real> excessProbability_, cumulativeExcessProbability_;
        // average loss in cell i
        std::vector<Real> average_;

        int overFlow_, underFlow_;
        bool isNormalized_;
    };

    class ManipulateDistribution {
    public:
        static Distribution convolve (const Distribution& d1,
                                      const Distribution& d2);
    };

}

#endif
]]></document_content>
  </document>
  <document index="177">
    <source>credit/factorspreadedhazardratecurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file factorspreadedhazardratecurve.hpp
    \brief Default-probability structure with a multiplicative spread on hazard rates
*/

#ifndef quantlib_factor_spreaded_hazard_rate_curve_hpp
#define quantlib_factor_spreaded_hazard_rate_curve_hpp

#include <ql/quote.hpp>
#include <ql/termstructures/credit/hazardratestructure.hpp>
#include <utility>

namespace QuantLib {

    //! Default-probability structure with a multiplicative spread on hazard rates
    /*! \note This term structure will remain linked to the original
              structure, i.e., any changes in the latter will be
              reflected in this structure as well.

        \ingroup termstructures
    */
    class FactorSpreadedHazardRateCurve : public HazardRateStructure {
      public:
        FactorSpreadedHazardRateCurve(Handle<DefaultProbabilityTermStructure> originalCurve,
                                      Handle<Quote> spread);
        //! \name DefaultTermStructure interface
        //@{
        DayCounter dayCounter() const override;
        Calendar calendar() const override;
        const Date& referenceDate() const override;
        Date maxDate() const override;
        Time maxTime() const override;
        //@}
      protected:
        Real hazardRateImpl(Time t) const override;

      private:
        Handle<DefaultProbabilityTermStructure> originalCurve_;
        Handle<Quote> spread_;
    };


    // inline definitions

    inline FactorSpreadedHazardRateCurve::FactorSpreadedHazardRateCurve(
        Handle<DefaultProbabilityTermStructure> h, Handle<Quote> spread)
    : originalCurve_(std::move(h)), spread_(std::move(spread)) {
        registerWith(originalCurve_);
        registerWith(spread_);
    }

    inline DayCounter FactorSpreadedHazardRateCurve::dayCounter() const {
        return originalCurve_->dayCounter();
    }

    inline Calendar FactorSpreadedHazardRateCurve::calendar() const {
        return originalCurve_->calendar();
    }

    inline const Date& FactorSpreadedHazardRateCurve::referenceDate() const {
        return originalCurve_->referenceDate();
    }

    inline Date FactorSpreadedHazardRateCurve::maxDate() const {
        return originalCurve_->maxDate();
    }

    inline Time FactorSpreadedHazardRateCurve::maxTime() const {
        return originalCurve_->maxTime();
    }

    inline Real FactorSpreadedHazardRateCurve::hazardRateImpl(Time t) const {
        return originalCurve_->hazardRate(t, true) * (1.0 + spread_->value());
    }

}

#endif
]]></document_content>
  </document>
  <document index="178">
    <source>credit/gaussianlhplossmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/gaussianlhplossmodel.hpp>

#ifndef QL_PATCH_SOLARIS


using std::sqrt;

namespace QuantLib {

    CumulativeNormalDistribution const GaussianLHPLossModel::phi_ = 
        CumulativeNormalDistribution();

    GaussianLHPLossModel::GaussianLHPLossModel(
            const Handle<Quote>& correlQuote,
            const std::vector<Handle<RecoveryRateQuote> >& quotes)
        : LatentModel<GaussianCopulaPolicy>(sqrt(correlQuote->value()),
            quotes.size(),
            //g++ complains default value not seen as typename
            GaussianCopulaPolicy::initTraits()),
          sqrt1minuscorrel_(std::sqrt(1.-correlQuote->value())),
          correl_(correlQuote),
          rrQuotes_(quotes), 
          beta_(sqrt(correlQuote->value())),
          biphi_(-sqrt(correlQuote->value()))
        {
            registerWith(correl_);
            for (const auto& quote : quotes)
                registerWith(quote);
    }

    GaussianLHPLossModel::GaussianLHPLossModel(
            Real correlation,
            const std::vector<Real>& recoveries)
        : LatentModel<GaussianCopulaPolicy>(sqrt(correlation),
            recoveries.size(),
            //g++ complains default value not seen as typename
            GaussianCopulaPolicy::initTraits()),
          sqrt1minuscorrel_(std::sqrt(1.-correlation)),
          correl_(Handle<Quote>(ext::make_shared<SimpleQuote>(correlation))),
          beta_(sqrt(correlation)),
          biphi_(-sqrt(correlation))
        {
        for (double recoverie : recoveries)
            rrQuotes_.emplace_back(ext::make_shared<RecoveryRateQuote>(recoverie));
        }

        GaussianLHPLossModel::GaussianLHPLossModel(
            const Handle<Quote>& correlQuote,
            const std::vector<Real>& recoveries)
        : LatentModel<GaussianCopulaPolicy>(sqrt(correlQuote->value()),
            recoveries.size(),
            //g++ complains default value not seen as typename
            GaussianCopulaPolicy::initTraits()),
          sqrt1minuscorrel_(std::sqrt(1.-correlQuote->value())),
          correl_(correlQuote),
          beta_(sqrt(correlQuote->value())),
          biphi_(-sqrt(correlQuote->value()))
        {
            registerWith(correl_);
            for (double recoverie : recoveries)
                rrQuotes_.emplace_back(ext::make_shared<RecoveryRateQuote>(recoverie));
        }


        Real GaussianLHPLossModel::expectedTrancheLossImpl(
            Real remainingNot, // << at the given date 'd'
            Real prob, // << at the given date 'd'
            Real averageRR, // << at the given date 'd'
            // these are percentual values:
            Real attachLimit, Real detachLimit) const 
        {

            if (attachLimit >= detachLimit) return 0.;// or is it an error?
            // expected remaining notional:
            if (remainingNot == 0.) return 0.;

            const Real one = 1.0 - 1.0e-12;  // FIXME DUE TO THE INV CUMUL AT 1
            const Real k1 = std::min(one, attachLimit /(1.0 - averageRR)
                ) + QL_EPSILON;
            const Real k2 = std::min(one, detachLimit /(1.0 - averageRR)
                ) + QL_EPSILON;

            if (prob > 0) {
                const Real ip = InverseCumulativeNormal::standard_value(prob);
                const Real invFlightK1 = 
                    (ip-sqrt1minuscorrel_ * 
                        InverseCumulativeNormal::standard_value(k1))/beta_;
                const Real invFlightK2 = (ip-sqrt1minuscorrel_*
                    InverseCumulativeNormal::standard_value(k2))/beta_;

                return remainingNot * (detachLimit * phi_(invFlightK2) 
                    - attachLimit * phi_(invFlightK1) + (1.-averageRR) * 
                    (biphi_(ip, -invFlightK2) - biphi_(ip, -invFlightK1)) );
            }
            else return 0.0;
        }

        Real GaussianLHPLossModel::probOverLoss(const Date& d,
            Real remainingLossFraction) const {
            // these test goes into basket<<<<<<<<<<<<<<<<<<<<<<<<<
            QL_REQUIRE(remainingLossFraction >=0., "Incorrect loss fraction.");
            QL_REQUIRE(remainingLossFraction <=1., "Incorrect loss fraction.");

            Real remainingAttachAmount = basket_->remainingAttachmentAmount();
            Real remainingDetachAmount = basket_->remainingDetachmentAmount();
            // live unerlying portfolio loss fraction (remaining portf fraction)

            const Real remainingBasktNot = basket_->remainingNotional(d);
            const Real attach = 
                std::min(remainingAttachAmount / remainingBasktNot, 1.);
            const Real detach = 
                std::min(remainingDetachAmount / remainingBasktNot, 1.);

            Real portfFract = 
                attach + remainingLossFraction * (detach - attach);

            Real averageRR = averageRecovery(d);
            Real maxAttLossFract = (1.-averageRR);
            if(portfFract > maxAttLossFract) return 0.;

            // for non-equity losses add the probability jump at zero tranche 
            //   losses (since this method returns prob of losing more or 
            //   equal to)
            if(portfFract <= QL_EPSILON) return 1.;

            Probability prob = averageProb(d);

            Real ip = InverseCumulativeNormal::standard_value(prob);
            Real invFlightK = (ip-sqrt1minuscorrel_*
                InverseCumulativeNormal::standard_value(portfFract
                    /(1.-averageRR)))/beta_;

            return  phi_(invFlightK);//probOver
        }

        Real GaussianLHPLossModel::expectedShortfall(const Date& d, 
            Probability perctl) const 
        {
            // loss as a fraction of the live portfolio
            Real ptflLossPerc = percentilePortfolioLossFraction(d, perctl);
            Real remainingAttachAmount = basket_->remainingAttachmentAmount();
            Real remainingDetachAmount = basket_->remainingDetachmentAmount();

            const Real remainingNot = basket_->remainingNotional(d);
            const Real attach = 
                std::min(remainingAttachAmount / remainingNot, 1.);
            const Real detach = 
                std::min(remainingDetachAmount / remainingNot, 1.);

            if(ptflLossPerc >= detach-QL_EPSILON) 
                return remainingNot * (detach-attach);//equivalent

            Real maxLossLevel = std::max(attach, ptflLossPerc);
            Probability prob = averageProb(d);
            Real averageRR = averageRecovery(d);

            Real valA = expectedTrancheLossImpl(remainingNot, prob, 
                averageRR, maxLossLevel, detach);
            Real valB = // probOverLoss(d, maxLossLevel);//in live tranche units
            // from fraction of basket notional to fraction of tranche notional
                probOverLoss(d, std::min(std::max((maxLossLevel - attach)
                /(detach - attach), 0.), 1.));
            return ( valA + (maxLossLevel - attach) * remainingNot * valB )
                / (1.-perctl);
        }

        Real GaussianLHPLossModel::percentilePortfolioLossFraction(
            const Date& d, Real perctl) const 
        {
            // this test goes into basket<<<<<<<<<<<<<<<<<<<<<<<<<
            QL_REQUIRE(perctl >= 0. && perctl <=1., 
                "Percentile argument out of bounds.");

            if(perctl==0.) return 0.;// portfl == attach
            if(perctl==1.) perctl = 1. - QL_EPSILON; // portfl == detach

            return (1.-averageRecovery(d)) * 
                phi_( ( InverseCumulativeNormal::standard_value(averageProb(d))
                    + beta_ * InverseCumulativeNormal::standard_value(perctl) )
                        /sqrt1minuscorrel_);
        }

}

#endif
]]></document_content>
  </document>
  <document index="179">
    <source>credit/gaussianlhplossmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_gaussian_lhp_lossmodel_hpp
#define quantlib_gaussian_lhp_lossmodel_hpp

#include <ql/qldefines.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/experimental/credit/recoveryratequote.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/math/latentmodel.hpp>
#include <ql/functional.hpp>
#include <numeric>

/* Intended to replace GaussianLHPCDOEngine in 
    ql/experimental/credit/syntheticcdoengines.hpp
   Moved from an engine to a loss model, CDO engines might refer to it.
*/

namespace QuantLib {

    /*!
      Portfolio loss model with analytical expected tranche loss for a large 
      homogeneous pool with Gaussian one-factor copula. See for example
      "The Normal Inverse Gaussian Distribution for Synthetic CDO pricing.",
      Anna Kalemanova, Bernd Schmid, Ralf Werner,
      Journal of Derivatives, Vol. 14, No. 3, (Spring 2007), pp. 80-93.
      http://www.defaultrisk.com/pp_crdrv_91.htm

      It can be used to price a credit derivative or to provide risk metrics of 
      a portfolio.

      \todo It should be checking that basket exposures are deterministic (fixed
      or programmed amortizing) otherwise the model is not fit for the basket.

      \todo Bugging on tranched baskets with upper limit over maximum 
        attainable loss?
     */
    class GaussianLHPLossModel : public DefaultLossModel, 
        public LatentModel<GaussianCopulaPolicy> {
    public:
        typedef GaussianCopulaPolicy copulaType;

        GaussianLHPLossModel(
            const Handle<Quote>& correlQuote,
            const std::vector<Handle<RecoveryRateQuote> >& quotes);

        GaussianLHPLossModel(
            Real correlation,
            const std::vector<Real>& recoveries);

        GaussianLHPLossModel(
            const Handle<Quote>& correlQuote,
            const std::vector<Real>& recoveries);

        void update() override {
            sqrt1minuscorrel_ = std::sqrt(1.-correl_->value());
            beta_ = std::sqrt(correl_->value());
            biphi_ = BivariateCumulativeNormalDistribution(
                -beta_);
            // tell basket to notify instruments, etc, we are invalid
            if(!basket_.empty()) basket_->notifyObservers();
        }

    private:
      void resetModel() override {}
      /*! @param attachLimit as a fraction of the underlying live portfolio
      notional
      */
      Real expectedTrancheLossImpl(Real remainingNot, // << at the given date 'd'
                                   Real prob,         // << at the given date 'd'
                                   Real averageRR,    // << at the given date 'd'
                                   Real attachLimit,
                                   Real detachLimit) const;
    public:
      Real expectedTrancheLoss(const Date& d) const override {
          // can calls to Basket::remainingNotional(d) be cached?<<<<<<<<<<<<<
          const Real remainingfullNot = basket_->remainingNotional(d);
          Real averageRR = averageRecovery(d);
          Probability prob = averageProb(d);
          Real remainingAttachAmount = basket_->remainingAttachmentAmount();
          Real remainingDetachAmount = basket_->remainingDetachmentAmount();


          // const Real attach = std::min(remainingAttachAmount
          //    / remainingfullNot, 1.);
          // const Real detach = std::min(remainingDetachAmount
          //    / remainingfullNot, 1.);
          const Real attach = remainingAttachAmount / remainingfullNot;
          const Real detach = remainingDetachAmount / remainingfullNot;

          return expectedTrancheLossImpl(remainingfullNot, prob, averageRR, attach, detach);
      }

        /*! The passed remainingLossFraction is in live tranche units,
            not portfolio as a fraction of the remaining(live) tranche
            (i.e. a_remaining=0% and det_remaining=100%)
        */
      Real probOverLoss(const Date& d, Real remainingLossFraction) const override;

      //! Returns the ESF as an absolute amount (rather than a fraction)
      /* The way it is implemented here is a transformation from ETL to ESF
      is a generic algorithm, not specific to this model so it should be moved
      to the Basket/DefaultLossModel class.
      TO DO: Implement the inverse transformation
      */
      Real expectedShortfall(const Date& d, Probability perctl) const override;

    protected:
        // This is wrong, it is not accounting for the current defaults ....
        // returns the loss value in actual loss units, returns the loss value 
        // for the underlying portfolio, untranched
        Real percentilePortfolioLossFraction(const Date& d, Real perctl) const;
        Real expectedRecovery(const Date& d, Size iName, const DefaultProbKey& ik) const override {
            return rrQuotes_[iName].currentLink()->value();
        }

    public:
        // same as percentilePortfolio but tranched
      Real percentile(const Date& d, Real perctl) const override {
          const Real remainingNot = basket_->remainingNotional(d);
          Real remainingAttachAmount = basket_->remainingAttachmentAmount();
          Real remainingDetachAmount = basket_->remainingDetachmentAmount();
          const Real attach = std::min(remainingAttachAmount / remainingNot, 1.);
          const Real detach = std::min(remainingDetachAmount / remainingNot, 1.);
          return remainingNot *
                 std::min(std::max(percentilePortfolioLossFraction(d, perctl) - attach, 0.),
                          detach - attach);
      }

        Probability averageProb(const Date& d) const {// not an overload of Deflossmodel ???<<<<<???
            // weighted average by programmed exposure.
            const std::vector<Probability> probs = 
                basket_->remainingProbabilities(d);//use remaining basket
            const std::vector<Real> remainingNots = 
                basket_->remainingNotionals(d);
            return std::inner_product(probs.begin(), probs.end(), 
                remainingNots.begin(), 0.) / basket_->remainingNotional(d);
        }

        /* One could define the average recovery without the probability
        factor, weighting only by notional instead, but that way the expected 
        loss of the average/aggregated and the original portfolio would not 
        coincide. This introduces however a time dependence in the recovery 
        value.
        Weighting by notional implies time dependent weighting since the basket 
        might amortize.
        */
        Real averageRecovery(
            const Date& d) const //no explicit time dependence in this model
        {
            const std::vector<Probability> probs = 
                basket_->remainingProbabilities(d);
            std::vector<Real> recoveries;
            for(Size i=0; i<basket_->remainingSize(); i++)
                recoveries.push_back(rrQuotes_[i]->value());
            std::vector<Real> notionals = basket_->remainingNotionals(d);
            Real denominator = std::inner_product(notionals.begin(), 
                notionals.end(), probs.begin(), 0.);
            if(denominator == 0.) return 0.;

            std::transform(notionals.begin(), notionals.end(), probs.begin(),
                notionals.begin(), std::multiplies<Real>());

            return std::inner_product(recoveries.begin(), recoveries.end(), 
                notionals.begin(), 0.) / denominator;
        }

    private:
        // cached
        mutable Real sqrt1minuscorrel_;

        Handle<Quote> correl_;
        std::vector<Handle<RecoveryRateQuote> > rrQuotes_;
        // calculation buffers

        /* The problem with defining a fixed average recovery on a portfolio 
        with uneven exposures is that it does not preserve portfolio
        moments like the expected loss. To achieve it one should define the 
        averarage recovery with a time dependence: 
        $\hat{R}(t) = \frac{\sum_i R_i N_i P_i(t)}{\sum_i N_i P_i(t)}$
        But the date dependence increases significantly the calculations cost.
        Notice that this problem dissapears if the recoveries are all equal.
        */
        
        Real beta_;
        BivariateCumulativeNormalDistribution biphi_;
        static CumulativeNormalDistribution const phi_;
    };

}

#endif

#endif
]]></document_content>
  </document>
  <document index="180">
    <source>credit/homogeneouspooldef.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_homogenous_pool_default_model_hpp
#define quantlib_homogenous_pool_default_model_hpp

#include <ql/experimental/credit/lossdistribution.hpp>
#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/math/functional.hpp>

// Intended to replace HomogeneousPoolCDOEngine in syntheticcdoengines.hpp

namespace QuantLib {

    //-------------------------------------------------------------------------
    //! Default loss distribution convolution for finite homogeneous pool
    /* A note on the number of buckets: As it is now the code goes splitting
    losses into buckets from loses equal to zero to losses up to the value of
    the underlying basket. This is in view of a stochastic loss given default
    but in a constant LGD situation this is a waste and it is more efficient to
    go up to the attainable losses.
    \todo Extend to the multifactor case for a generic LM
    */
    template<class copulaPolicy>
    class HomogeneousPoolLossModel : public DefaultLossModel {
    private:
      void resetModel() override;

    public:
        HomogeneousPoolLossModel(
            const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> >& 
                copula,
            Size nBuckets,
            Real max = 5.,
            Real min = -5.,
            Real nSteps = 50)
        : copula_(copula), 
          nBuckets_(nBuckets), 
          max_(max), min_(min), nSteps_(nSteps), delta_((max - min)/nSteps)
        { 
            QL_REQUIRE(copula->numFactors() == 1, 
                "Inhomogeneous model not implemented for multifactor");
        }
    protected:
        Distribution lossDistrib(const Date& d) const;
    public:
      Real expectedTrancheLoss(const Date& d) const override {
          return lossDistrib(d).cumulativeExcessProbability(attachAmount_, detachAmount_);
          // This one if the distribution is over the whole loss structure:
          // but it becomes very expensive
          /*
          return lossDistrib(d).trancheExpectedValue(attach_ * notional_,
              detach_ * notional_);
          */
      }
      Real percentile(const Date& d, Real percentile) const override {
          Real portfLoss = lossDistrib(d).confidenceLevel(percentile);
          return std::min(std::max(portfLoss - attachAmount_, 0.), detachAmount_ - attachAmount_);
      }
      Real expectedShortfall(const Date& d, Probability percentile) const override {
          Distribution dist = lossDistrib(d);
          dist.tranche(attachAmount_, detachAmount_);
          return dist.expectedShortfall(percentile);
      }

    protected:
        const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> > copula_;
        Size nBuckets_;
        mutable Real attach_, detach_, notional_, attachAmount_, detachAmount_;
        mutable std::vector<Real> notionals_;
    private:
        // integration:
        //  \todo move integration to latent model types when moving to a 
        //  multifactor version
        const Real max_;// redundant?
        const Real min_;
        const Real nSteps_;
        const Real delta_; 
    };
    // \todo Add other loss distribution statistics
    typedef HomogeneousPoolLossModel<GaussianCopulaPolicy> 
        HomogGaussPoolLossModel;
    typedef HomogeneousPoolLossModel<TCopulaPolicy> HomogTPoolLossModel;

    //-----------------------------------------------------------------------

    template<class CP>
    void HomogeneousPoolLossModel<CP>::resetModel()
    {
        // need to be capped now since the limit amounts might be over the 
        //  remaining notional (think amortizing)
        attach_ = std::min(basket_->remainingAttachmentAmount() / 
            basket_->remainingNotional(), 1.);
        detach_ = std::min(basket_->remainingDetachmentAmount() / 
            basket_->remainingNotional(), 1.);
        notional_ = basket_->remainingNotional();
        notionals_ = basket_->remainingNotionals();
        attachAmount_ = basket_->remainingAttachmentAmount();
        detachAmount_ = basket_->remainingDetachmentAmount();

        copula_->resetBasket(basket_.currentLink());
    }

    template<class CP>
    Distribution HomogeneousPoolLossModel<CP>::lossDistrib(
        const Date& d) const 
    {
        LossDistHomogeneous bucktLDistBuff(nBuckets_, detachAmount_);

        std::vector<Real> lgd;// switch to a mutable cache member
        std::vector<Real> recoveries = copula_->recoveries();
        std::transform(recoveries.begin(), recoveries.end(), 
                       std::back_inserter(lgd),
                       subtract_from<Real>(1.0));
        std::transform(lgd.begin(), lgd.end(), notionals_.begin(), 
            lgd.begin(), std::multiplies<Real>());
        std::vector<Real> prob = basket_->remainingProbabilities(d);
        for(Size iName=0; iName<prob.size(); iName++)
            prob[iName] = copula_->inverseCumulativeY(prob[iName], iName);

        // integrate locally (1 factor). 
        // use explicitly a 1D latent model object? 
        Distribution dist(nBuckets_, 0.0, 
            detachAmount_);
            //notional_);
        std::vector<Real> mkft(1, min_ + delta_ /2.);
        for (Size i = 0; i < nSteps_; i++) {
            std::vector<Real> conditionalProbs;
            for(Size iName=0; iName<notionals_.size(); iName++)
                conditionalProbs.push_back(
                copula_->conditionalDefaultProbabilityInvP(prob[iName], iName, 
                    mkft));
            Distribution bld = bucktLDistBuff(lgd, conditionalProbs);
            Real densitydm = delta_ * copula_->density(mkft);
            // also, instead of calling the static method it could be wrapped 
            // through an inlined call in the latent model
            for (Size j = 0; j < nBuckets_; j++)
                dist.addDensity(j, bld.density(j) * densitydm);
            mkft[0] += delta_;
        }
        return dist;
    }


}

#endif
]]></document_content>
  </document>
  <document index="181">
    <source>credit/inhomogeneouspooldef.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_inhomogenous_pool_default_model_hpp
#define quantlib_inhomogenous_pool_default_model_hpp

#include <ql/experimental/credit/lossdistribution.hpp>
#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/math/functional.hpp>

// Intended to replace InhomogeneousPoolCDOEngine in syntheticcdoengines.hpp

namespace QuantLib {

    //-------------------------------------------------------------------------
    //! Default loss distribution convolution for finite non homogeneous pool
    /* A note on the number of buckets: As it is now the code goes splitting
    losses into buckets from loses equal to zero to losses up to the value of
    the underlying basket. This is in view of a stochastic loss given default
    but in a constant LGD situation this is a waste and it is more efficient to
    go up to the attainable losses.
    \todo Extend to the multifactor case for a generic LM
    \todo Many common code with the homogeneous version, both classes perform
    the same work on different loss distribution types, merge and send the 
    distribution object?
    */
    template<class copulaPolicy>
    class InhomogeneousPoolLossModel : public DefaultLossModel {
    private:
      void resetModel() override;

    public:
        // allow base correlations:
        typedef copulaPolicy copulaType;

        InhomogeneousPoolLossModel(
        // restricted to non random recoveries, but it could be possible.
            const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> >& 
                copula,
            Size nBuckets,
            Real max = 5.,
            Real min = -5.,
            Real nSteps = 50)
        : copula_(copula), 
          nBuckets_(nBuckets), 
          max_(max), min_(min), nSteps_(nSteps), delta_((max - min)/nSteps)
        { 
            QL_REQUIRE(copula->numFactors() == 1, 
                "Inhomogeneous model not implemented for multifactor");
        }
    // Write another constructor sending the LM factors and recoveries.
    protected:
        Distribution lossDistrib(const Date& d) const;
    public:
      Real expectedTrancheLoss(const Date& d) const override {
          return lossDistrib(d).cumulativeExcessProbability(attachAmount_, detachAmount_);
          // This one if the distribution is over the whole loss structure:
          // but it becomes very expensive
          /*
          return lossDistrib(d).trancheExpectedValue(
              attachAmount_, detachAmount_);
          */
      }
      Real percentile(const Date& d, Real percentile) const override {
          Real portfLoss = lossDistrib(d).confidenceLevel(percentile);
          return std::min(std::max(portfLoss - attachAmount_, 0.), detachAmount_ - attachAmount_);
      }
      Real expectedShortfall(const Date& d, Probability percentile) const override {
          Distribution dist = lossDistrib(d);
          dist.tranche(attachAmount_, detachAmount_);
          return dist.expectedShortfall(percentile);
      }

    protected:
        const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> > copula_;
        Size nBuckets_;
        mutable Real attach_, detach_, notional_, attachAmount_, detachAmount_;
        mutable std::vector<Real> notionals_;
    private:
        // integration:
        //  \todo move integration to latent model types when moving to a 
        //  multifactor version
        const Real max_;// redundant?
        const Real min_;
        const Real nSteps_;
        const Real delta_; 
    };
    // \todo Add other loss distribution statistics
    typedef InhomogeneousPoolLossModel<GaussianCopulaPolicy> 
        IHGaussPoolLossModel;
    typedef InhomogeneousPoolLossModel<TCopulaPolicy> IHStudentPoolLossModel;

    //-----------------------------------------------------------------------

    template<class CP>
    void InhomogeneousPoolLossModel<CP>::resetModel()
    {
        // need to be capped now since the limit amounts might be over the 
        //  remaining notional (think amortizing)
        attach_ = std::min(basket_->remainingAttachmentAmount() / 
            basket_->remainingNotional(), 1.);
        detach_ = std::min(basket_->remainingDetachmentAmount() / 
            basket_->remainingNotional(), 1.);
        notional_ = basket_->remainingNotional();
        notionals_ = basket_->remainingNotionals();
        attachAmount_ = basket_->remainingAttachmentAmount();
        detachAmount_ = basket_->remainingDetachmentAmount();

        copula_->resetBasket(basket_.currentLink());
    }

    template<class CP>
    Distribution InhomogeneousPoolLossModel<CP>::lossDistrib(
        const Date& d) const 
    {
        LossDistBucketing bucktLDistBuff(nBuckets_, detachAmount_);

        std::vector<Real> lgd;// switch to a mutable cache member
        std::vector<Real> recoveries = copula_->recoveries();
        std::transform(recoveries.begin(), recoveries.end(), 
                       std::back_inserter(lgd),
                       subtract_from<Real>(1.0));
        std::transform(lgd.begin(), lgd.end(), notionals_.begin(), 
                       lgd.begin(), std::multiplies<Real>());
        std::vector<Real> prob = basket_->remainingProbabilities(d);
        for(Size iName=0; iName<prob.size(); iName++)
            prob[iName] = copula_->inverseCumulativeY(prob[iName], iName);

        // integrate locally (1 factor). 
        // use explicitly a 1D latent model object? 
        // \todo Use a library integrator here and in the homogeneous case.
        Distribution dist(nBuckets_, 0.0, 
            detachAmount_);
            //notional_);
        std::vector<Real> mkft(1, min_ + delta_ /2.);
        for (Size i = 0; i < nSteps_; i++) {
            std::vector<Real> conditionalProbs;
            for(Size iName=0; iName<notionals_.size(); iName++)
                conditionalProbs.push_back(
                copula_->conditionalDefaultProbabilityInvP(prob[iName], iName, 
                    mkft));
            Distribution bld = bucktLDistBuff(lgd, conditionalProbs);
            Real densitydm = delta_ * copula_->density(mkft);
            // also, instead of calling the static method it could be wrapped 
            // through an inlined call in the latent model
            for (Size j = 0; j < nBuckets_; j++)
                dist.addDensity(j, bld.density(j) * densitydm);
            mkft[0] += delta_;
        }
        return dist;
    }


}

#endif
]]></document_content>
  </document>
  <document index="182">
    <source>credit/integralcdoengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/integralcdoengine.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    void IntegralCDOEngine::calculate() const {
        Date today = Settings::instance().evaluationDate();

        results_.protectionValue = 0.0;
        results_.premiumValue = 0.0;
        results_.upfrontPremiumValue = 0.0;
        results_.error = 0;
        results_.expectedTrancheLoss.clear();
        // todo Should be remaining when considering realized loses
        results_.xMin = arguments_.basket->attachmentAmount();
        results_.xMax = arguments_.basket->detachmentAmount();
        results_.remainingNotional = results_.xMax - results_.xMin;
        const Real inceptionTrancheNotional = 
            arguments_.basket->trancheNotional();

        // compute expected loss at the beginning of first relevant period
        Real e1 = 0;
        // todo add includeSettlement date flows variable to engine.
        if (!arguments_.normalizedLeg[0]->hasOccurred(today)) 
             // cast to fixed rate coupon?
            e1 = arguments_.basket->expectedTrancheLoss(
                ext::dynamic_pointer_cast<Coupon>(
                    arguments_.normalizedLeg[0])->accrualStartDate()); 
        results_.expectedTrancheLoss.push_back(e1);// zero or realized losses?

        for (auto& i : arguments_.normalizedLeg) {
            if (i->hasOccurred(today)) {
                // add includeSettlement date flows variable to engine.
                results_.expectedTrancheLoss.push_back(0.);
                continue;
            }

            const ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(i);

            Date d1 = coupon->accrualStartDate();
            Date d2 = coupon->date();

            Date d, d0 = d1;
            Real e2;
            do {
                d = NullCalendar().advance(d0 > today ? d0 : today,
                                           stepSize_);
                if (d > d2) d = d2;

                e2 = arguments_.basket->expectedTrancheLoss(d);

                results_.premiumValue
                    // ..check for e2 including past/realized losses
                    += (inceptionTrancheNotional - e2)
                    * arguments_.runningRate
                    * arguments_.dayCounter.yearFraction(d0, d)
                    * discountCurve_->discount(d);

                // TO DO: Addd default coupon accrual value here-----

                if (e2 < e1) results_.error ++;

                results_.protectionValue
                    += (e2 - e1) * discountCurve_->discount(d);

                d0 = d;
                e1 = e2;
            }
            while (d < d2);
            results_.expectedTrancheLoss.push_back(e2);
        }

        // add includeSettlement date flows variable to engine.
        if (!arguments_.normalizedLeg[0]->hasOccurred(today))
            results_.upfrontPremiumValue
                = inceptionTrancheNotional * arguments_.upfrontRate
                    * discountCurve_->discount(
                        ext::dynamic_pointer_cast<Coupon>(
                            arguments_.normalizedLeg[0])->accrualStartDate());

        if (arguments_.side == Protection::Buyer) {
            results_.protectionValue *= -1;
            results_.premiumValue *= -1;
            results_.upfrontPremiumValue *= -1;
        }

        results_.value = results_.premiumValue - results_.protectionValue
            + results_.upfrontPremiumValue;
        results_.errorEstimate = Null<Real>();
        // Fair spread GIVEN the upfront
        Real fairSpread = 0.;
        if (results_.premiumValue != 0.0) {
            fairSpread =
                -(results_.protectionValue + results_.upfrontPremiumValue)
                  *arguments_.runningRate/results_.premiumValue;
        }

        results_.additionalResults["fairPremium"] = fairSpread;
        results_.additionalResults["premiumLegNPV"] = 
            results_.premiumValue + results_.upfrontPremiumValue;
        results_.additionalResults["protectionLegNPV"] = 
            results_.protectionValue;
    }

}

#endif
]]></document_content>
  </document>
  <document index="183">
    <source>credit/integralcdoengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_integral_cdo_engine_hpp
#define quantlib_integral_cdo_engine_hpp

#include <ql/qldefines.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/experimental/credit/syntheticcdo.hpp>
#    include <utility>

namespace QuantLib {

    class YieldTermStructure;

    class IntegralCDOEngine : public SyntheticCDO::engine {
    public:
      explicit IntegralCDOEngine(Handle<YieldTermStructure> discountCurve,
                                 Period stepSize = 3 * Months)
      : stepSize_(stepSize), discountCurve_(std::move(discountCurve)) {}
      void calculate() const override;

    protected:
      Period stepSize_;
      Handle<YieldTermStructure> discountCurve_;
    };

}

#endif

#endif
]]></document_content>
  </document>
  <document index="184">
    <source>credit/integralntdengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/integralntdengine.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/experimental/credit/basket.hpp>
#include <numeric>

namespace QuantLib {

    void IntegralNtdEngine::calculate() const {
        Date today = Settings::instance().evaluationDate();

        results_.errorEstimate = Null<Real>();
        results_.value = 0.0;
        results_.premiumValue = 0.0;
        results_.upfrontPremiumValue = 0.;
        Real accrualValue = 0.0;
        Real claimValue = 0.0;
        Date d, d0;
        /* Given the expense of probsBeingNthEvent both in integrable and 
        monte carlo algorithms this engine tests who to call.
        Warning: This is not entirely a basket property but of the model too.
        The basket has to have all notionals equal but it is the model which
        determines the recovery; having all the market recoveries equal is not
        enough since we might be using a loss model which is stochastic in the
        recovery rates.
        */
        bool basketIsHomogeneous = true;// hardcoded by now

        for (auto& i : arguments_.premiumLeg) {
            ext::shared_ptr<FixedRateCoupon> coupon = ext::dynamic_pointer_cast<FixedRateCoupon>(i);
            Date d = i->date();
            if (d > discountCurve_->referenceDate()) {
                /*
                std::vector<Probability> probsTriggering =
                    arguments_.basket->probsBeingNthEvent(arguments_.ntdOrder, 
                        d);
                Probability defaultProb = 
                    std::accumulate(probsTriggering.begin(), 
                    probsTriggering.end(), Real(0.));
                // OVERKILL???? 1-probAtLeastNEvents is enough

*/
                // prob of contract not having been triggered by date of payment
                Probability probNonTriggered = 
                    1. - arguments_.basket->probAtLeastNEvents(
                        arguments_.ntdOrder, d);

                results_.premiumValue +=
                    i->amount() * discountCurve_->discount(d) * probNonTriggered;
                ////   * (1.0 - defaultProb);

                if (coupon->accrualStartDate() >= 
                    discountCurve_->referenceDate())
                    d = coupon->accrualStartDate();
                else
                    d = discountCurve_->referenceDate();

                // do steps of specified size
                d0 = d;
                Period stepSize = integrationStepSize_;
/*
                probsTriggering =
                    arguments_.basket->probsBeingNthEvent(arguments_.ntdOrder, 
                    ///////REDUNDANT?
                        d0);
                Probability defProb0 = std::accumulate(probsTriggering.begin(), 
                ///OVERKILL????
                    probsTriggering.end(), Real(0.));
*/
                Probability defProb0 = arguments_.basket->probAtLeastNEvents(
                        arguments_.ntdOrder, d0);
                std::vector<Probability> probsTriggering, probsTriggering1;
                do {
                    DiscountFactor disc = discountCurve_->discount(d);

                    Probability defProb1;
                    if(basketIsHomogeneous) {//take test out of the while loop
                        defProb1 = arguments_.basket->probAtLeastNEvents(
                            arguments_.ntdOrder, d);
                        claimValue -= (defProb1-defProb0)
                            * arguments_.basket->claim()->amount(d, 
                                arguments_.notional, 
                                arguments_.basket->recoveryRate(d, 0))
                            * disc;

                    }else{
                        probsTriggering1 =
                            arguments_.basket->probsBeingNthEvent(
                                arguments_.ntdOrder, d);
                        defProb1 = std::accumulate(probsTriggering1.begin(), 
                            probsTriggering1.end(), Real(0.));
                        /*Recoveries might differ along names, depending on 
                        which name is triggering the contract the loss will be 
                        different  
                        There is an issue here; MC engines can still be used 
                        since the prob of triggering the contract can be 
                        extracted from the simulation from the 
                        probsBeingNthEvent statistic. Yet, when the RR is 
                        stochastic the realized value of the RR is the expected 
                        one subject/conditional to the contract being triggered;
                        not simply the expected value. For this reason the MC 
                        can not be used through the statistic but has to consume
                        the simulations directly.
                        */
                        for(Size iName=0; 
                            iName<arguments_.basket->remainingSize(); 
                            iName++) 
                        {
                            claimValue -= (probsTriggering1[iName]-
                                probsTriggering[iName])
                                * arguments_.basket->claim()->amount(d, 
                                    arguments_.notional,// [iName]! 
                                    arguments_.basket->recoveryRate(d, iName))
                                * disc;
                        }
                        probsTriggering = probsTriggering1;
                    }

                    Probability dcfdd = defProb1 - defProb0;
                    defProb0 = defProb1;

                    if (arguments_.settlePremiumAccrual)
                        accrualValue += coupon->accruedAmount(d)*disc*dcfdd;

                    d0 = d;
                    d = d0 + stepSize;
                    // reduce step size ?
                    if (stepSize != 1*Days && d > coupon->accrualEndDate()) {
                        stepSize = 1*Days;
                        d = d0 + stepSize;
                    }
                }
                while (d <= coupon->accrualEndDate());
            }
        }

        // The upfront might be due before the curve ref date...
        if (!arguments_.premiumLeg[0]->hasOccurred(today))
            results_.upfrontPremiumValue =
                arguments_.basket->remainingNotional() 
                    * arguments_.upfrontRate
                    * discountCurve_->discount(
                        ext::dynamic_pointer_cast<FixedRateCoupon>(
                            arguments_.premiumLeg[0])->accrualStartDate());
        if (arguments_.side == Protection::Buyer) {
            results_.premiumValue *= -1;
            accrualValue *= -1;
            claimValue *= -1;
            results_.upfrontPremiumValue *= -1;
        }

        results_.value = results_.premiumValue + accrualValue + claimValue + 
            results_.upfrontPremiumValue;

        results_.fairPremium = -arguments_.premiumRate * claimValue 
            / (results_.premiumValue + accrualValue);
        // alternatively use results buffers and omit locals.
        results_.protectionValue = claimValue;

        results_.additionalResults["fairPremium"] = results_.fairPremium;
        results_.additionalResults["premiumLegNPV"] = 
            results_.premiumValue + results_.upfrontPremiumValue;
        results_.additionalResults["protectionLegNPV"] = 
            results_.protectionValue;
    }

}
]]></document_content>
  </document>
  <document index="185">
    <source>credit/integralntdengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_integral_ntd_engine_hpp
#define quantlib_integral_ntd_engine_hpp

#include <ql/experimental/credit/nthtodefault.hpp>
#include <utility>

namespace QuantLib {

    class YieldTermStructure;

    // Varying recoveries allowed, allow now for heterogeneous notionals
    class IntegralNtdEngine : public NthToDefault::engine {
    public:
      IntegralNtdEngine(const Period& integrationStep, Handle<YieldTermStructure> discountCurve)
      : discountCurve_(std::move(discountCurve)), integrationStepSize_(integrationStep) {}
      void calculate() const override;

    protected:
      Handle<YieldTermStructure> discountCurve_;
      Period integrationStepSize_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="186">
    <source>credit/interpolatedaffinehazardratecurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_interpolated_affine_hazard_rate_curve_hpp
#define quantlib_interpolated_affine_hazard_rate_curve_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/experimental/credit/onefactoraffinesurvival.hpp>
#include <ql/termstructures/credit/probabilitytraits.hpp>
#include <ql/termstructures/interpolatedcurve.hpp>
#include <ql/termstructures/bootstraphelper.hpp>
#include <utility>

namespace QuantLib {

    /*! DefaultProbabilityTermStructure based on interpolation of a 
    deterministic hazard rate component plus a stochastic one factor 
    rate.
    */
    /*
    The hazard rate structure here refers to the deterministic term 
    structure added on top of the affine model intensity. It is typically
    employed to match the current market implied probabilities. The total
    probabilities keep their meaning and are those of the affine model. An
    example of this is the CIR++ model as employed in credit.

    (Although this is not usually the preferred way one can instead match the
    model to price the market.)

    Notice that here, hazardRateImpl(Time) returns the deterministic part of
    the hazard rate and not E[\lambda] This is what the bootstrapping
    requires but it might be confusing.

    \todo Redesign?:
    The Affine model type is meant to model short rates; most methods
    if not all still have sense here, though discounts mean probabilities.
    This is not satisfactory, the affine models might need more structure
    or reusing these classes should be reconsidered.
    \todo Implement forward default methods.
    \todo Implement statistics methods (expected values etc)

    */
    /*! \ingroup defaultprobabilitytermstructures */
    template <class Interpolator>
    class InterpolatedAffineHazardRateCurve
        : public OneFactorAffineSurvivalStructure,
          protected InterpolatedCurve<Interpolator> {
      public:
        InterpolatedAffineHazardRateCurve(
            const std::vector<Date>& dates,
            const std::vector<Rate>& hazardRates,
            const DayCounter& dayCounter,
            const ext::shared_ptr<OneFactorAffineModel>& model,
            const Calendar& cal = Calendar(),
            const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
            const std::vector<Date>& jumpDates = std::vector<Date>(),
            const Interpolator& interpolator = Interpolator());
        InterpolatedAffineHazardRateCurve(const std::vector<Date>& dates,
                                          const std::vector<Rate>& hazardRates,
                                          const DayCounter& dayCounter,
                                          const ext::shared_ptr<OneFactorAffineModel>& model,
                                          const Calendar& calendar,
                                          const Interpolator& interpolator);
        InterpolatedAffineHazardRateCurve(const std::vector<Date>& dates,
                                          const std::vector<Rate>& hazardRates,
                                          const DayCounter& dayCounter,
                                          const ext::shared_ptr<OneFactorAffineModel>& model,
                                          const Interpolator& interpolator);
        //! \name TermStructure interface
        //@{
        Date maxDate() const override;
        //@}
        //! \name other inspectors
        //@{
        const std::vector<Time>& times() const;
        const std::vector<Date>& dates() const;
        const std::vector<Real>& data() const;
        const std::vector<Rate>& hazardRates() const;
        std::vector<std::pair<Date, Real> > nodes() const;
        //@}
      protected:
        InterpolatedAffineHazardRateCurve(
            const DayCounter&,
            const ext::shared_ptr<OneFactorAffineModel>& model,
            const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
            const std::vector<Date>& jumpDates = std::vector<Date>(),
            const Interpolator& interpolator = Interpolator());
        InterpolatedAffineHazardRateCurve(
            const Date& referenceDate,
            const DayCounter&,
            const ext::shared_ptr<OneFactorAffineModel>& model,
            const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
            const std::vector<Date>& jumpDates = std::vector<Date>(),
            const Interpolator& interpolator = Interpolator());
        InterpolatedAffineHazardRateCurve(
            Natural settlementDays,
            const Calendar&,
            const DayCounter&,
            const ext::shared_ptr<OneFactorAffineModel>& model,
            const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
            const std::vector<Date>& jumpDates = std::vector<Date>(),
            const Interpolator& interpolator = Interpolator());
        //! \name DefaultProbabilityTermStructure implementation
        //@{
        //! Returns the deterministic hazard rate component.
        Real hazardRateImpl(Time) const override;
        Probability survivalProbabilityImpl(Time) const override;

      public:
        using DefaultProbabilityTermStructure::hazardRate;
    protected:
        /*! Probability of default conditional to the realization of a given
        value of the stochastic part of the hazard rate at a prior time (and
        thus to survival at that time).
        \f$ P_{surv}(\tau>tTarget|F_{tFwd}) \f$
        */
      Probability
      conditionalSurvivalProbabilityImpl(Time tFwd, Time tTarget, Real yVal) const override;
      //@}

      mutable std::vector<Date> dates_;

    private:
      void initialize();
    };


    namespace detail {
        // hazard rate compensation TS for affine models
        const Real minHazardRateComp = -1.0;
    }

    /*! Piecewise (deterministic) plus affine (stochastic) terms composed
        hazard rate
    */
    struct AffineHazardRate {
        // interpolated curve type
        template <class Interpolator>
        struct curve {
            typedef InterpolatedAffineHazardRateCurve<Interpolator> type;
        };
        // helper class
        typedef BootstrapHelper<DefaultProbabilityTermStructure> helper;

        // start of curve data
        static Date initialDate(const DefaultProbabilityTermStructure* c) {
            return c->referenceDate();
        }
        // dummy value at reference date
        static Real initialValue(const DefaultProbabilityTermStructure*) {
            return detail::avgHazardRate;
        }

        // guesses
        template <class C>
        static Real guess(Size i,
                          const C* c,
                          bool validData,
                          Size) // firstAliveHelper
        {
            if (validData) // previous iteration value
                return c->data()[i];

            if (i==1) // first pillar
                return 0.0001;
               // return detail::avgHazardRate;

            // extrapolate
            Date d = c->dates()[i];
            /* Uneasy about the naming: Here we are bootstrapping only the
             deterministic part of the intensity it might be a better idea to
             have a different naming when having these two components.
             What is meant here is the deterministic part of a ++model type
            */
            return c->hazardRate(d, true);
        }

        // constraints
        template <class C>
        static Real minValueAfter(Size i,
                                  const C* c,
                                  bool validData,
                                  Size) // firstAliveHelper
        {
            if (validData) {
                Real r = *(std::min_element(c->data().begin(),
                                            c->data().end()));
                return r/2.0;
            }
            return detail::minHazardRateComp;
            ///return QL_EPSILON;
        }
        template <class C>
        static Real maxValueAfter(Size i,
                                  const C* c,
                                  bool validData,
                                  Size) // firstAliveHelper
        {
            if (validData) {
                Real r = *(std::max_element(c->data().begin(),
                                            c->data().end()));
                return r*2.0;
            }
            // no constraints.
            // We choose as max a value very unlikely to be exceeded.
            return detail::maxHazardRate;
        }
        // update with new guess
        static void updateGuess(std::vector<Real>& data,
                                Real rate,
                                Size i) {
            data[i] = rate;
            if (i==1)
                data[0] = rate; // first point is updated as well
        }
        // upper bound for convergence loop
        static Size maxIterations() { return 30; }
    };


    // inline definitions

    template <class T>
    inline Date InterpolatedAffineHazardRateCurve<T>::maxDate() const {
        return dates_.back();
    }

    template <class T>
    inline const std::vector<Time>&
    InterpolatedAffineHazardRateCurve<T>::times() const {
        return this->times_;
    }

    template <class T>
    inline const std::vector<Date>&
    InterpolatedAffineHazardRateCurve<T>::dates() const {
        return dates_;
    }

    template <class T>
    inline const std::vector<Real>&
    InterpolatedAffineHazardRateCurve<T>::data() const {
        return this->data_;
    }

    template <class T>
    inline const std::vector<Rate>&
    InterpolatedAffineHazardRateCurve<T>::hazardRates() const {
        return this->data_;
    }

    template <class T>
    inline std::vector<std::pair<Date, Real> >
    InterpolatedAffineHazardRateCurve<T>::nodes() const {
        std::vector<std::pair<Date, Real> > results(dates_.size());
        for (Size i=0; i<dates_.size(); ++i)
            results[i] = std::make_pair(dates_[i], this->data_[i]);
        return results;
    }

    #ifndef __DOXYGEN__

    // template definitions

    template <class T>
    Real InterpolatedAffineHazardRateCurve<T>::hazardRateImpl(Time t) const {
        if (t <= this->times_.back())
            return this->interpolation_(t, true);

        // deterministic flat hazard rate extrapolation
        return this->data_.back();
    }

    // notice it is rewritten and no call is made to hazardRateImpl
    template <class T>
    Probability
    InterpolatedAffineHazardRateCurve<T>::survivalProbabilityImpl(
        Time t) const 
    {
        // the way x0 is defined:
        Real initValHR = std::pow(model_->dynamics()->process()->x0(), 2);

        if (t == 0.0)
            return model_->discountBond(0., t, initValHR);

        Real integral;
        if (t <= this->times_.back()) {
            integral = this->interpolation_.primitive(t, true);
        } else {
            // flat hazard rate extrapolation
            integral = 
                this->interpolation_.primitive(this->times_.back(), true)
                     + this->data_.back()*(t - this->times_.back());
        }
        return std::exp(-integral) * model_->discountBond(0., t, initValHR);
    }

    template <class T>
    Probability
    InterpolatedAffineHazardRateCurve<T>::conditionalSurvivalProbabilityImpl(
        Time tFwd, Time tTarget, Real yVal) const 
    {
        QL_REQUIRE(tFwd <= tTarget, "Probability time in the past.");
        // Still leaves the possibility of sending tFwd=0 and an yVal different
        //   to the initial conditions. In an abstract sense thats all right as
        //   long as it is seen as a zero probability scenario.
        #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(tFwd > 0. || yVal == 
                model_->dynamics()->process()->x0(), 
                "Initial value different to process'.");
        #endif
        if (tFwd == 0.) return survivalProbabilityImpl(tTarget);
        if (tFwd - tTarget == 0.0)
            return 1.;

        Real integralTFwd, integralTP;
        if (tFwd <= this->times_.back()) {
            integralTFwd = this->interpolation_.primitive(tFwd, true);
        } else {
            // flat hazard rate extrapolation
            integralTFwd = 
                this->interpolation_.primitive(this->times_.back(), true)
                     + this->data_.back()*(tFwd - this->times_.back());
        }
        if (tTarget <= this->times_.back()) {
            integralTP = this->interpolation_.primitive(tTarget, true);
        } else {
            // flat hazard rate extrapolation
            integralTP = 
                this->interpolation_.primitive(this->times_.back(), true)
                     + this->data_.back()*(tTarget - this->times_.back());
        }

        return std::exp(-(integralTP-integralTFwd)) * 
            model_->discountBond(tFwd, tTarget, yVal );
    }

    template <class T>
    InterpolatedAffineHazardRateCurve<T>::InterpolatedAffineHazardRateCurve(
        const DayCounter& dayCounter,
        const ext::shared_ptr<OneFactorAffineModel>& model,
        const std::vector<Handle<Quote> >& jumps,
        const std::vector<Date>& jumpDates,
        const T& interpolator)
    : OneFactorAffineSurvivalStructure(model, dayCounter, jumps, jumpDates), InterpolatedCurve<T>(
                                                                                 interpolator) {}

    template <class T>
    InterpolatedAffineHazardRateCurve<T>::InterpolatedAffineHazardRateCurve(
        const Date& referenceDate,
        const DayCounter& dayCounter,
        const ext::shared_ptr<OneFactorAffineModel>& model,
        const std::vector<Handle<Quote> >& jumps,
        const std::vector<Date>& jumpDates,
        const T& interpolator)
    : OneFactorAffineSurvivalStructure(
          model, referenceDate, Calendar(), dayCounter, jumps, jumpDates),
      InterpolatedCurve<T>(interpolator) {}

    template <class T>
    InterpolatedAffineHazardRateCurve<T>::InterpolatedAffineHazardRateCurve(
        Natural settlementDays,
        const Calendar& calendar,
        const DayCounter& dayCounter,
        const ext::shared_ptr<OneFactorAffineModel>& model,
        const std::vector<Handle<Quote> >& jumps,
        const std::vector<Date>& jumpDates,
        const T& interpolator)
    : OneFactorAffineSurvivalStructure(
          model, settlementDays, calendar, dayCounter, jumps, jumpDates),
      InterpolatedCurve<T>(interpolator) {}

    template <class T>
    InterpolatedAffineHazardRateCurve<T>::InterpolatedAffineHazardRateCurve(
        const std::vector<Date>& dates,
        const std::vector<Rate>& hazardRates,
        const DayCounter& dayCounter,
        const ext::shared_ptr<OneFactorAffineModel>& model,
        const Calendar& calendar,
        const std::vector<Handle<Quote> >& jumps,
        const std::vector<Date>& jumpDates,
        const T& interpolator)
    : OneFactorAffineSurvivalStructure(model, dates.at(0), calendar, dayCounter, jumps, jumpDates),
      InterpolatedCurve<T>(std::vector<Time>(), hazardRates, interpolator), dates_(dates) {
        initialize();
    }

    template <class T>
    InterpolatedAffineHazardRateCurve<T>::InterpolatedAffineHazardRateCurve(
        const std::vector<Date>& dates,
        const std::vector<Rate>& hazardRates,
        const DayCounter& dayCounter,
        const ext::shared_ptr<OneFactorAffineModel>& model,
        const Calendar& calendar,
        const T& interpolator)
    : OneFactorAffineSurvivalStructure(model, dates.at(0), calendar, dayCounter),
      InterpolatedCurve<T>(std::vector<Time>(), hazardRates, interpolator), dates_(dates) {
        initialize();
    }

    template <class T>
    InterpolatedAffineHazardRateCurve<T>::InterpolatedAffineHazardRateCurve(
        const std::vector<Date>& dates,
        const std::vector<Rate>& hazardRates,
        const DayCounter& dayCounter,
        const ext::shared_ptr<OneFactorAffineModel>& model,
        const T& interpolator)
    : OneFactorAffineSurvivalStructure(model, dates.at(0), Calendar(), dayCounter),
      InterpolatedCurve<T>(std::vector<Time>(), hazardRates, interpolator), dates_(dates) {
        initialize();
    }

    template <class T>
    void InterpolatedAffineHazardRateCurve<T>::initialize()
    {
        QL_REQUIRE(dates_.size() >= T::requiredPoints,
                   "not enough input dates given");
        QL_REQUIRE(this->data_.size() == dates_.size(),
                   "dates/data count mismatch");

        this->times_.resize(dates_.size());
        this->times_[0] = 0.0;
        for (Size i=1; i<dates_.size(); ++i) {
            QL_REQUIRE(dates_[i] > dates_[i-1],
                       "invalid date (" << dates_[i] << ", vs "
                       << dates_[i-1] << ")");
            this->times_[i] = dayCounter().yearFraction(dates_[0], dates_[i]);
            QL_REQUIRE(!close(this->times_[i], this->times_[i-1]),
                       "two dates correspond to the same time "
                       "under this curve's day count convention");
        }

        this->interpolation_ =
            this->interpolator_.interpolate(this->times_.begin(),
                                            this->times_.end(),
                                            this->data_.begin());
        this->interpolation_.update();
    }

    #endif

}

#endif
]]></document_content>
  </document>
  <document index="187">
    <source>credit/issuer.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/issuer.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        bool between(const ext::shared_ptr<DefaultEvent>& e,
                     const Date& start,
                     const Date& end,
                     bool includeRefDate = false) {
            return !e->hasOccurred(start, includeRefDate) &&
                e->hasOccurred(end, includeRefDate);
        }
    }

    Issuer::Issuer(std::vector<std::pair<DefaultProbKey, Handle<DefaultProbabilityTermStructure> > >
                       probabilities,
                   DefaultEventSet events)
    : probabilities_(std::move(probabilities)), events_(std::move(events)) {}

    Issuer::Issuer(const std::vector<std::vector<ext::shared_ptr<DefaultType> > >& eventTypes,
                   const std::vector<Currency>& currencies,
                   const std::vector<Seniority>& seniorities,
                   const std::vector<Handle<DefaultProbabilityTermStructure> >& curves,
                   DefaultEventSet events)
    : events_(std::move(events)) {
        QL_REQUIRE((eventTypes.size() == curves.size()) &&
            (curves.size()== currencies.size()) &&
            (currencies.size() == seniorities.size()),
            "Incompatible size of Issuer parameters.");

        for(Size i=0; i <eventTypes.size(); i++) {
            DefaultProbKey keytmp(eventTypes[i], currencies[i],
                seniorities[i]);
            probabilities_.emplace_back(keytmp, curves[i]);
        }
    }

    const Handle<DefaultProbabilityTermStructure>&
        Issuer::defaultProbability(const DefaultProbKey& key) const {
        for (const auto& probabilitie : probabilities_)
            if (key == probabilitie.first)
                return probabilitie.second;
        QL_FAIL("Probability curve not available.");
    }

    ext::shared_ptr<DefaultEvent>
    Issuer::defaultedBetween(const Date& start,
                             const Date& end,
                             const DefaultProbKey& contractKey,
                             bool includeRefDate
                             ) const
    {
        // to do: the set is ordered, see how to use it to speed this up
        for (const auto& event : events_) {
            if (event->matchesDefaultKey(contractKey) && between(event, start, end, includeRefDate))
                return event;
        }
        return ext::shared_ptr<DefaultEvent>();
    }


    std::vector<ext::shared_ptr<DefaultEvent> >
    Issuer::defaultsBetween(const Date& start,
                            const Date& end,
                            const DefaultProbKey& contractKey,
                            bool includeRefDate
                            ) const
    {
        std::vector<ext::shared_ptr<DefaultEvent> > defaults;
        // to do: the set is ordered, see how to use it to speed this up
        for (const auto& event : events_) {
            if (event->matchesDefaultKey(contractKey) && between(event, start, end, includeRefDate))
                defaults.push_back(event);
        }
        return defaults;
    }

}
]]></document_content>
  </document>
  <document index="188">
    <source>credit/issuer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file issuer.hpp
    \brief Classes for credit-name handling.
*/

#ifndef quantlib_issuer_hpp
#define quantlib_issuer_hpp

#include <ql/experimental/credit/defaultevent.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <set>
#include <vector>

namespace QuantLib {

    typedef std::set<ext::shared_ptr<DefaultEvent>,
                earlier_than<ext::shared_ptr<DefaultEvent> > >
            DefaultEventSet;

    class Issuer {
      public:
        typedef std::pair<DefaultProbKey,
                          Handle<DefaultProbabilityTermStructure> >
                                                               key_curve_pair;
        /*! The first argument represents the probability of an issuer
            of having any of its bonds with the given seniority,
            currency incurring in that particular event.  The second
            argument represents the history of past events.  Theres no
            check on whether the event list makes sense, events can
            occur several times and several of them can take place on
            the same date.

            To do: add settlement event access
        */
        Issuer(std::vector<key_curve_pair> probabilities = std::vector<key_curve_pair>(),
               DefaultEventSet events = DefaultEventSet());

        Issuer(const std::vector<std::vector<ext::shared_ptr<DefaultType> > >& eventTypes,
               const std::vector<Currency>& currencies,
               const std::vector<Seniority>& seniorities,
               const std::vector<Handle<DefaultProbabilityTermStructure> >& curves,
               DefaultEventSet events = DefaultEventSet());

        //! \name Inspectors
        //@{
        const Handle<DefaultProbabilityTermStructure>&
            defaultProbability(const DefaultProbKey& key) const;

        //@}

        //! \name Utilities
        //@{
        //! If a default event with the required seniority and
        //    restructuring type is found, it is returned for
        //    inspection; otherwise, the method returns an empty pointer.
        ext::shared_ptr<DefaultEvent>
        defaultedBetween(const Date& start,
                         const Date& end,
                         const DefaultProbKey& key,
                         bool includeRefDate = false
                         ) const;

        //@}
        std::vector<ext::shared_ptr<DefaultEvent> >
        defaultsBetween(const Date& start,
                        const Date& end,
                        const DefaultProbKey& contractKey,
                        bool includeRefDate
                        ) const ;
      private:
        //! probabilities of events for each bond collection
        // vector of pairs preferred over maps for performance
        std::vector<std::pair<DefaultProbKey,
            Handle<DefaultProbabilityTermStructure> > > probabilities_;
        //! History of past events affecting this issuer. Notice it is possible
        //    for the same event to occur on the same bond several times along
        //    time.
        DefaultEventSet events_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="189">
    <source>credit/loss.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file loss.hpp
  \brief Pair of loss time and amount, sortable by loss time
*/

#ifndef quantlib_loss_hpp
#define quantlib_loss_hpp

#include <ql/types.hpp>

namespace QuantLib {

class Loss {
    public:
        Loss(Real t = 0.0, Real a = 0.0) : time(t), amount(a) {};
        Real time, amount;
    };

    inline bool operator<(const Loss& l1, const Loss& l2) {
        return (l1.time < l2.time);
    }
    inline bool operator>(const Loss& l1, const Loss& l2) {
        return (l1.time > l2.time);
    }
    inline bool operator==(const Loss& l1, const Loss& l2) {
        return (l1.time == l2.time);
    }
    inline bool operator!=(const Loss& l1, const Loss& l2) {
        return (l1.time != l2.time);
    }

}

#endif
]]></document_content>
  </document>
  <document index="190">
    <source>credit/lossdistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/lossdistribution.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>

using namespace std;

namespace QuantLib {

    //--------------------------------------------------------------------------
    Real LossDist::binomialProbabilityOfNEvents(int n, vector<Real>& p) {
    //--------------------------------------------------------------------------
        BinomialDistribution binomial (p[0], p.size());
        return binomial(n);
    }

    //--------------------------------------------------------------------------
    Real LossDist::binomialProbabilityOfAtLeastNEvents(int n, vector<Real>& p) {
    //--------------------------------------------------------------------------
        CumulativeBinomialDistribution binomial(p[0], p.size());
        return 1.0 - binomial(n-1);
        /*
        Real defp = 0;
        for (Size i = n; i <= p.size(); i++)
            defp += binomialProbabilityOfNEvents (i, p);

        return defp;
        */
    }

    //--------------------------------------------------------------------------
    vector<Real> LossDist::probabilityOfNEvents(vector<Real>& p) {
    //--------------------------------------------------------------------------
        Size n = p.size();
        vector<Real> probability(n+1, 0.0);
        vector<Real> prev;
        probability[0] = 1.0;
        for (Size j = 0; j < n; j++) {
            prev = probability;
            probability[0] = prev[0] * (1.0 - p[j]);
            for (Size i = 1; i <= j; i++)
                probability[i] = prev[i-1] * p[j] + prev[i] * (1.0 - p[j]);
            probability[j+1] = prev[j] * p[j];
        }

        return probability;
    }

    //--------------------------------------------------------------------------
    Real LossDist::probabilityOfNEvents(int k, vector<Real>& p) {
    //--------------------------------------------------------------------------
        return probabilityOfNEvents(p)[k];

//      vector<Real> w (p.size(), 0);
//      vector<Real> u (k+1, 0);
//      vector<Real> v (k+1, 0);

//      Real pZero = 1.0;
//      for (Size i = 0; i < w.size(); i++) {
//          pZero *= (1.0 - p[i]);
//          w[i] = p[i] / (1.0 - p[i]);
//      }

//      if (k == 0) return pZero;

//      int kk = k;
//      Real prodw = 1.0;

//      Cumulated probability of up to n events:
//      Cut off when the cumulated probability reaches 1,
//      i.e. set all following probabilities of exactly n events to zero.
//      Real sum = 1.0;

//      u[0] = 1.0;
//      for (int i = 1; i <= kk; i++) {
//          v[i] = 0;
//          for (Size j = 0; j < w.size(); j++)
//              v[i] += pow (w[j], i);
//          u[i] = 0;
//          for (int j = 1; j <= i; j++)
//              u[i] +=  pow (-1.0, j+1) * v[j] * u[i-j];
//          u[i] /= i;

//          cut off
//          if (sum * pZero >= 1.0 || u[i] < 0 || u[i] * pZero >= 1.0)
//              u[i] = 0;

//          sum += u[i];
//      }

//      return pZero * prodw * u[kk];
    }

    //--------------------------------------------------------------------------
    Real LossDist::probabilityOfAtLeastNEvents (int k, vector<Real>& p) {
    //--------------------------------------------------------------------------
        vector<Real> probability = probabilityOfNEvents(p);
        Real sum = 1.0;
        for (int j = 0; j < k; j++)
            sum -= probability[j];
        return sum;
        /*
        Real sum = 0;
        for (Size i = k; i <= p.size(); i++)
            sum += probabilityOfNEvents (i, p);
        return sum;
        */
    }

    //--------------------------------------------------------------------------
    Real ProbabilityOfNEvents::operator()(vector<Real> p) const {
    //--------------------------------------------------------------------------
        return LossDist::probabilityOfNEvents (n_, p);
    }

    //--------------------------------------------------------------------------
    Real ProbabilityOfAtLeastNEvents::operator()(vector<Real> p) const {
    //--------------------------------------------------------------------------
        return LossDist::probabilityOfAtLeastNEvents (n_, p);
    }

    //--------------------------------------------------------------------------
    Real BinomialProbabilityOfAtLeastNEvents::operator()(vector<Real> p) const {
        //--------------------------------------------------------------------------
        return LossDist::binomialProbabilityOfAtLeastNEvents(n_, p);
    }

    //--------------------------------------------------------------------------
    Distribution LossDistBinomial::operator()(Size n, Real volume,
                                              Real probability) const {
    //--------------------------------------------------------------------------
        n_ = n;
        probability_.clear();
        probability_.resize(n_+1, 0.0);
        Distribution dist (nBuckets_, 0.0, maximum_);
        BinomialDistribution binomial (probability, n);
        for (Size i = 0; i <= n; i++) {
            if (volume_ * i <= maximum_) {
                probability_[i] = binomial(i);
                Size bucket = dist.locate(volume * i);
                dist.addDensity (bucket, probability_[i] / dist.dx(bucket));
                dist.addAverage (bucket, volume * i);
            }
        }

        excessProbability_.clear();
        excessProbability_.resize(n_+1, 0.0);
        excessProbability_[n_] = probability_[n_];
        for (int k = n_-1; k >= 0; k--)
            excessProbability_[k] = excessProbability_[k+1] + probability_[k];

        dist.normalize();

        return dist;
    }

    //--------------------------------------------------------------------------
    Distribution LossDistBinomial::operator()(const vector<Real>& nominals,
                                    const vector<Real>& probabilities) const {
    //--------------------------------------------------------------------------
        return operator()(nominals.size(), nominals[0], probabilities[0]);
    }

    //--------------------------------------------------------------------------
    Distribution LossDistHomogeneous::operator()(Real volume,
                                                 const vector<Real>& p) const {
    //--------------------------------------------------------------------------
        volume_ = volume;
        n_ = p.size();
        probability_.clear();
        probability_.resize(n_+1, 0.0);
        vector<Real> prev;
        probability_[0] = 1.0;
        for (Size k = 0; k < n_; k++) {
            prev = probability_;
            probability_[0] = prev[0] * (1.0 - p[k]);
            for (Size i = 1; i <= k; i++)
                probability_[i] = prev[i-1] * p[k] + prev[i] * (1.0 - p[k]);
            probability_[k+1] = prev[k] * p[k];
        }

        excessProbability_.clear();
        excessProbability_.resize(n_+1, 0.0);
        excessProbability_[n_] = probability_[n_];
        for (int k = n_ - 1; k >= 0; k--)
            excessProbability_[k] = excessProbability_[k+1] + probability_[k];

        Distribution dist (nBuckets_, 0.0, maximum_);
        for (Size i = 0; i <= n_; i++) {
            if (volume * i <= maximum_) {
                Size bucket = dist.locate(volume * i);
                dist.addDensity (bucket, probability_[i] / dist.dx(bucket));
                dist.addAverage (bucket, volume*i);
            }
        }

        dist.normalize();

        return dist;
    }

    //--------------------------------------------------------------------------
    Distribution LossDistHomogeneous::operator()(const vector<Real>& nominals,
                                    const vector<Real>& probabilities) const {
    //--------------------------------------------------------------------------
        return operator()(nominals[0], probabilities);
    }

    //--------------------------------------------------------------------------
    Distribution LossDistBucketing::operator()(const vector<Real>& nominals,
                                    const vector<Real>& probabilities) const {
    //--------------------------------------------------------------------------
        QL_REQUIRE (nominals.size() == probabilities.size(), "sizes differ: "
                    << nominals.size() << " vs " << probabilities.size());

        vector<Real> p (nBuckets_, 0.0);
        vector<Real> a (nBuckets_, 0.0);
        vector<Real> ap (nBuckets_, 0.0);

        p[0] = 1.0;
        a[0] = 0.0;
        Real dx = maximum_ / nBuckets_;
        for (Size k = 1; k < nBuckets_; k++)
            a[k] = dx * k + dx/2;

        for (Size i = 0; i < nominals.size(); i++) {
            Real L = nominals[i];
            Real P = probabilities[i];
            for (int k = a.size()-1; k >= 0; k--) {
                if (p[k] > 0) {
                    int u = locateTargetBucket (a[k] + L, k);
                    QL_REQUIRE (u >= 0, "u=" << u << " at i=" << i << " k=" << k);
                    QL_REQUIRE (u >= k, "u=" << u << "<k=" << k << " at i=" << i);

                    Real dp = p[k] * P;
                    if (u == k)
                        a[k] += P * L;
                    else {
                        // no update of a[u] and p[u] if u is beyond grid end
                        if (u < int(nBuckets_)) {
                            // a[u] remains unchanged, if dp = 0
                            if (dp > 0.0) {
                                // on Windows, p[u]/dp could cause a NaN for
                                // some very small values of p[k].
                                // Writing the above as (p[u]/p[k])/P prevents
                                // the NaN. What can I say?
                                Real f = 1.0 / (1.0 + (p[u]/p[k]) / P);
                                a[u] = (1.0 - f) * a[u] + f * (a[k] + L);
                            }
                            /* formulation of Hull-White:
                               if (p[u] + dp > 0)
                                  a[u] = (p[u] * a[u] + dp * (a[k] + L))
                                         / (p[u] + dp);
                            */
                            p[u] += dp;
                        }
                        p[k] -= dp;
                    }
                }
                QL_REQUIRE(a[k] + epsilon_ >= dx * k && a[k] < dx * (k+1),
                           "a out of range at k=" << k << ", contract " << i);
            }
        }

        Distribution dist (nBuckets_, 0.0, maximum_);
        for (Size i = 0; i < nBuckets_; i++) {
            dist.addDensity (i, p[i] / dx);
            dist.addAverage (i, a[i]);
        }

        return dist;
    }

    //--------------------------------------------------------------------------
    int LossDistBucketing::locateTargetBucket (Real loss, Size i0) const {
    //--------------------------------------------------------------------------
        QL_REQUIRE (loss >= 0, "loss " << loss << " must be >= 0");
        Real dx = maximum_ / nBuckets_;
        for (Size i = i0; i < nBuckets_; i++)
            if (dx * i > loss + epsilon_) return i - 1;
        return nBuckets_;
    }

    //--------------------------------------------------------------------------
    Distribution LossDistMonteCarlo::operator()(const vector<Real>& nominals,
                                   const vector<Real>& probabilities) const {
    //--------------------------------------------------------------------------
        Distribution dist (nBuckets_, 0.0, maximum_);
        // KnuthUniformRng rng(seed_);
        // LecuyerUniformRng rng(seed_);
        MersenneTwisterUniformRng rng(seed_);
        for (Size i = 0; i < simulations_; i++) {
            Real e = 0;
            for (Size j = 0; j < nominals.size(); j++) {
                Real r = rng.next().value;
                if (r <= probabilities[j])
                    e += nominals[j];
            }
            dist.add (e + epsilon_);
        }

        dist.normalize();

        return dist;
    }

}
]]></document_content>
  </document>
  <document index="191">
    <source>credit/lossdistribution.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file lossdistribution.hpp
    \brief Loss distributions and probability of n defaults
*/

#ifndef quantlib_loss_distribution_hpp
#define quantlib_loss_distribution_hpp

#include <ql/math/distributions/binomialdistribution.hpp>
#include <ql/experimental/credit/distribution.hpp>
#include <ql/experimental/credit/onefactorcopula.hpp>

namespace QuantLib {

    //! Probability formulas and algorithms
    /*!
      \ingroup probability
    */ 
    class LossDist {
    public:
      LossDist() = default;
      virtual ~LossDist() = default;

      virtual Distribution operator()(const std::vector<Real>& volumes,
                                      const std::vector<Real>& probabilities) const = 0;
      virtual Size buckets() const = 0;
      virtual Real maximum() const = 0;

      /*! Binomial probability of n defaults using prob[0]
       */
      static Real binomialProbabilityOfNEvents(int n, std::vector<Real>& p);

      /*! Binomial probability of at least n defaults using prob[0]
       */
      static Real binomialProbabilityOfAtLeastNEvents(int n, std::vector<Real>& p);
      /*! Probability of exactly n default events
        Xiaofong Ma, "Numerical Methods for the Valuation of Synthetic
        Collateralized Debt Obligations", PhD Thesis,
        Graduate Department of Computer Science, University of Toronto, 2007
        http://www.cs.toronto.edu/pub/reports/na/ma-07-phd.pdf (formula 2.1)
      */
      static std::vector<Real> probabilityOfNEvents(std::vector<Real>& p);

      static Real probabilityOfNEvents(int n, std::vector<Real>& p);

      /*! Probability of at least n defaults
       */
      static Real probabilityOfAtLeastNEvents(int n, std::vector<Real>& p);
    }; 

    //! Probability of N events 
    class ProbabilityOfNEvents {
    public:
        explicit ProbabilityOfNEvents (int n) : n_(n) {}
        Real operator()(std::vector<Real> p) const;
    private:
        Size n_;
    };

    //! Probability of at least N events 
    class ProbabilityOfAtLeastNEvents {
    public:
        explicit ProbabilityOfAtLeastNEvents (int n) : n_(n) {}
        Real operator()(std::vector<Real> p) const;
    private:
        Size n_;
    };

    //! Probability of at least N events 
    class BinomialProbabilityOfAtLeastNEvents {
    public:
        explicit BinomialProbabilityOfAtLeastNEvents(int n) : n_(n) {}
        Real operator()(std::vector<Real> p) const;

      private:
        int n_;
    };

    //! Binomial loss distribution
    /*! Binomial loss distribution
      \ingroup probability
    */
    class LossDistBinomial : public LossDist {
    public:
        LossDistBinomial (Size nBuckets, Real maximum)
            : nBuckets_(nBuckets), maximum_(maximum) {}
        Distribution operator()(Size n, Real volume, Real probability) const;
        Distribution operator()(const std::vector<Real>& volumes,
                                const std::vector<Real>& probabilities) const override;
        Size buckets() const override { return nBuckets_; }
        Real maximum() const override { return maximum_; }
        Real volume() const { return volume_; }
        Size size () const { return n_; }
        std::vector<Real> probability() const { return probability_; }
        std::vector<Real> excessProbability() const { return excessProbability_; }
    private:
        Size nBuckets_;
        Real maximum_;
        mutable Real volume_;
        mutable Size n_;
        mutable std::vector<Real> probability_;
        mutable std::vector<Real> excessProbability_;
    };

    //! Loss Distribution for Homogeneous Pool
    /*! Loss Distribution for Homogeneous Pool

      Loss distribution for equal volumes but varying probabilities of 
      default.

      The method builds the exact loss distribution for a homogeneous pool
      of underlyings iteratively by computing the convolution of the given
      loss distribution with the "loss distribution" of an additional credit
      following 
      
      Xiaofong Ma, "Numerical Methods for the Valuation of Synthetic
      Collateralized Debt Obligations", PhD Thesis, 
      Graduate Department of Computer Science, University of Toronto, 2007  
      http://www.cs.toronto.edu/pub/reports/na/ma-07-phd.pdf (formula 2.1)

      avoiding numerical instability of the algorithm by

      John Hull and Alan White, "Valuation of a CDO and nth to default CDS 
      without Monte Carlo simulation", Journal of Derivatives 12, 2, 2004 

      \ingroup probability
     */
    class LossDistHomogeneous : public LossDist {
    public:
        LossDistHomogeneous (Size nBuckets, Real maximum)
            : nBuckets_(nBuckets), maximum_(maximum),
              n_(0), volume_(0.0) {}
        Distribution operator()(Real volume, 
                                const std::vector<Real>& probabilities) const;
        Distribution operator()(const std::vector<Real>& volumes,
                                const std::vector<Real>& probabilities) const override;
        Size buckets() const override { return nBuckets_; }
        Real maximum() const override { return maximum_; }
        Size size () const { return n_; }
        Real volume() const { return volume_; }
        std::vector<Real> probability() const { return probability_; }
        std::vector<Real> excessProbability() const { return excessProbability_; }
    private:
        Size nBuckets_;
        Real maximum_;
        mutable Size n_;
        mutable Real volume_;
        mutable std::vector<Real> probability_;
        mutable std::vector<Real> excessProbability_;
    };

    //! Loss distribution with Hull-White bucketing 
    /*! Loss distribution with Hull-White bucketing 

      Loss distribution for varying volumes and probabilities of default, 
      independence assumed.

      The implementation of the loss distribution follows 

      John Hull and Alan White, "Valuation of a CDO and nth to default CDS 
      without Monte Carlo simulation", Journal of Derivatives 12, 2, 2004. 

      \ingroup probability
    */
    class LossDistBucketing : public LossDist {
    public:
        LossDistBucketing (Size nBuckets, Real maximum, 
                           Real epsilon = 1e-6)
            : nBuckets_(nBuckets), maximum_(maximum), epsilon_(epsilon) {}
        Distribution operator()(const std::vector<Real>& volumes,
                                const std::vector<Real>& probabilities) const override;
        Size buckets() const override { return nBuckets_; }
        Real maximum() const override { return maximum_; }

      private:
        int locateTargetBucket (Real loss, Size i0 = 0) const;

        Size nBuckets_;
        Real maximum_;
        Real epsilon_;
    };

    //! Loss distribution with Monte Carlo simulation
    /*!
      Loss distribution for varying volumes and probabilities of default
      via Monte Carlo simulation of independent default events.

      \ingroup probability
    */
    class LossDistMonteCarlo : public LossDist {
    public:
        LossDistMonteCarlo (Size nBuckets, Real maximum, Size simulations,
                            long seed = 42, Real epsilon = 1e-6)
            : nBuckets_(nBuckets), maximum_(maximum), 
              simulations_(simulations), seed_(seed), epsilon_(epsilon) {}
        Distribution operator()(const std::vector<Real>& volumes,
                                const std::vector<Real>& probabilities) const override;
        Size buckets() const override { return nBuckets_; }
        Real maximum() const override { return maximum_; }

      private:
        Size nBuckets_;
        Real maximum_;
        Size simulations_;
        long seed_;
        Real epsilon_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="192">
    <source>credit/midpointcdoengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/midpointcdoengine.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    void MidPointCDOEngine::calculate() const {
        Date today = Settings::instance().evaluationDate();

        results_.premiumValue = 0.0;
        results_.protectionValue = 0.0;
        results_.upfrontPremiumValue = 0.0;
        results_.error = 0;
        results_.expectedTrancheLoss.clear();
        // todo Should be remaining when considering realized loses
        results_.xMin = arguments_.basket->attachmentAmount();
        results_.xMax = arguments_.basket->detachmentAmount();
        results_.remainingNotional = results_.xMax - results_.xMin;
        const Real inceptionTrancheNotional = 
            arguments_.basket->trancheNotional();

        // compute expected loss at the beginning of first relevant period
        Real e1 = 0;
        // todo add includeSettlement date flows variable to engine.
        if (!arguments_.normalizedLeg[0]->hasOccurred(today))
            // Notice that since there might be a gap between the end of 
            // acrrual and payment dates and today be in between
            // the tranche loss on that date might not be contingent but 
            // realized:
            e1 = arguments_.basket->expectedTrancheLoss(
                ext::dynamic_pointer_cast<Coupon>(
                    arguments_.normalizedLeg[0])->accrualStartDate());
        results_.expectedTrancheLoss.push_back(e1);
        //'e1'  should contain the existing loses.....? use remaining amounts?
        for (auto& i : arguments_.normalizedLeg) {
            if (i->hasOccurred(today)) {
                results_.expectedTrancheLoss.push_back(0.);
                continue;
            }
            ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(i);
            Date paymentDate = coupon->date();
            Date startDate = std::max(coupon->accrualStartDate(),
                                      discountCurve_->referenceDate());
            Date endDate = coupon->accrualEndDate();
            // we assume the loss within the period took place on this date:
            Date defaultDate = startDate + (endDate-startDate)/2;

            Real e2 = arguments_.basket->expectedTrancheLoss(endDate);
            results_.expectedTrancheLoss.push_back(e2);
            results_.premiumValue += 
                ((inceptionTrancheNotional - e2) / inceptionTrancheNotional)
                * coupon->amount()
                * discountCurve_->discount(paymentDate);
            // default flows:
            const Real discount = discountCurve_->discount(defaultDate);

            /* Accrual removed till the argument flag is implemented
            // pays accrued on defaults' date
            results_.premiumValue += coupon->accruedAmount(defaultDate)
                * discount * (e2 - e1) / inceptionTrancheNotional;
            */
            results_.protectionValue += discount * (e2 - e1);
            /* use it in a future version for coherence with the integral engine
            * arguments_.leverageFactor;
            */
            e1 = e2;
        }

        //\todo treat upfron tnow as in the new CDS (see March 2014)
        // add includeSettlement date flows variable to engine ?
        if (!arguments_.normalizedLeg[0]->hasOccurred(today))
            results_.upfrontPremiumValue 
                = inceptionTrancheNotional * arguments_.upfrontRate 
                    * discountCurve_->discount(
                        ext::dynamic_pointer_cast<Coupon>(
                            arguments_.normalizedLeg[0])->accrualStartDate());
            /* use it in a future version for coherence with the integral engine
                arguments_.leverageFactor * ;
            */
        if (arguments_.side == Protection::Buyer) {
            results_.protectionValue *= -1;
            results_.premiumValue *= -1;
            results_.upfrontPremiumValue *= -1;
        }
        results_.value = results_.premiumValue - results_.protectionValue
            + results_.upfrontPremiumValue;
        results_.errorEstimate = Null<Real>();
        // Fair spread GIVEN the upfront
        Real fairSpread = 0.;
        if (results_.premiumValue != 0.0) {
            fairSpread =
                -(results_.protectionValue + results_.upfrontPremiumValue)
                  *arguments_.runningRate/results_.premiumValue;
        }

        results_.additionalResults["fairPremium"] = fairSpread;
        results_.additionalResults["premiumLegNPV"] = 
            results_.premiumValue + results_.upfrontPremiumValue;
        results_.additionalResults["protectionLegNPV"] = 
            results_.protectionValue;
    }

}

#endif
]]></document_content>
  </document>
  <document index="193">
    <source>credit/midpointcdoengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_midpoint_cdo_engine_hpp
#define quantlib_midpoint_cdo_engine_hpp

#include <ql/qldefines.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/experimental/credit/syntheticcdo.hpp>
#    include <utility>

namespace QuantLib {

    class YieldTermStructure;

    //! CDO base engine taking schedule steps

    /* The engine obtains the cdo reference basket from its arguments and it 
    is expecting it to have a default model assigned. 
    */
    /* FIX ME: ASSUMES basket->expectedTrancheLoss(endDate) includes past 
    realized losses (between cdo inception and calculation time) .... what if 
    basket inception is not the same as CDO's ?????

    \todo non tested under realized defaults. JTD metrics might be invalid
    */
    class MidPointCDOEngine : public SyntheticCDO::engine {
    public:
      explicit MidPointCDOEngine(Handle<YieldTermStructure> discountCurve)
      : discountCurve_(std::move(discountCurve)) {}
      void calculate() const override;

    protected:
      Handle<YieldTermStructure> discountCurve_;
    };

}

#endif

#endif
]]></document_content>
  </document>
  <document index="194">
    <source>credit/nthtodefault.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/nthtodefault.hpp>
#include <ql/experimental/credit/lossdistribution.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/event.hpp>
#include <ql/experimental/credit/basket.hpp>

namespace QuantLib {


    NthToDefault::NthToDefault(
        const ext::shared_ptr<Basket>& basket,
        Size n,
        Protection::Side side,
        const Schedule& premiumSchedule,
        Rate upfrontRate,
        Rate premiumRate,
        const DayCounter& dayCounter,
        Real nominal,
        bool settlePremiumAccrual
        )
    : basket_(basket), n_(n),
      side_(side), nominal_(nominal),
      premiumSchedule_(premiumSchedule), premiumRate_(premiumRate), 
      upfrontRate_(upfrontRate), 
      dayCounter_(dayCounter), settlePremiumAccrual_(settlePremiumAccrual)
    {
        QL_REQUIRE(n_ <= basket_->size(), 
                   "NTD order provided is larger than the basket size.");

        // Basket inception must lie before contract protection start.
        QL_REQUIRE(basket->refDate() <= premiumSchedule.startDate(),
            //using the start date of the schedule might be wrong, think of the CDS rule
            "Basket did not exist before contract start.");

        premiumLeg_ = FixedRateLeg(premiumSchedule)
            .withNotionals(nominal)
            .withCouponRates(premiumRate, dayCounter)
            .withPaymentAdjustment(Unadjusted);

        registerWith(basket_);
    }


// SOME OF THESE ARE INLINES---------------------------------
    Size NthToDefault::basketSize() const { return basket_->size(); }

    bool NthToDefault::isExpired() const {
        return detail::simple_event(premiumLeg_.back()->date()).hasOccurred();
    }

    Rate NthToDefault::fairPremium() const {
        calculate();
        QL_REQUIRE(fairPremium_ != Null<Rate>(),
                   "fair premium not available");
        return fairPremium_;
    }

    Real NthToDefault::premiumLegNPV() const {
        calculate();
        QL_REQUIRE(premiumValue_ != Null<Rate>(),
                   "premium leg not available");
        QL_REQUIRE(upfrontPremiumValue_ != Null<Rate>(),
                   "upfront value not available");
        return premiumValue_ + upfrontPremiumValue_;
    }

    Real NthToDefault::protectionLegNPV() const {
        calculate();
        QL_REQUIRE(protectionValue_ != Null<Rate>(),
                   "protection leg not available");
        return protectionValue_;
    }

    Real NthToDefault::errorEstimate() const {
        calculate();
        QL_REQUIRE(errorEstimate_ != Null<Rate>(),
                   "error estimate not available");
        return errorEstimate_;

    }

    void NthToDefault::setupExpired() const {
        Instrument::setupExpired();

        premiumValue_ = 0.0;
        protectionValue_ = 0.0;
        upfrontPremiumValue_ = 0.0;
        fairPremium_ = 0.0;
        errorEstimate_ = 0.0;
    }

    void NthToDefault::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<NthToDefault::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");
        arguments->basket = basket_;
        arguments->side = side_;
        arguments->premiumLeg = premiumLeg_;
        arguments->ntdOrder = n_;
        arguments->settlePremiumAccrual = settlePremiumAccrual_;
        arguments->notional = nominal_;
        arguments->premiumRate = premiumRate_;
        arguments->upfrontRate = upfrontRate_;
    }

    void NthToDefault::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const NthToDefault::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");

        premiumValue_ = results->premiumValue;
        protectionValue_ = results->protectionValue;
        upfrontPremiumValue_ = results->upfrontPremiumValue;
        fairPremium_ = results->fairPremium;
        errorEstimate_ = results->errorEstimate;
    }

    void NthToDefault::results::reset() {
        Instrument::results::reset();
        premiumValue = Null<Real>();
        protectionValue = Null<Real>();
        upfrontPremiumValue = Null<Real>();
        fairPremium = Null<Real>();
        errorEstimate = Null<Real>();
        additionalResults.clear();
    }

    void NthToDefault::arguments::validate() const {
        QL_REQUIRE(basket && !basket->names().empty(), "no basket given");
        QL_REQUIRE(side != Protection::Side(-1), "side not set");
        QL_REQUIRE(premiumRate != Null<Real>(), "no premium rate given");
        QL_REQUIRE(upfrontRate != Null<Real>(), "no upfront rate given");
        QL_REQUIRE(notional != Null<Real>(), "no notional given");
        QL_REQUIRE(ntdOrder != Null<Size>(), "no NTD order given");
    }

}

]]></document_content>
  </document>
  <document index="195">
    <source>credit/nthtodefault.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nthtodefault.hpp
    \brief N-th to default swap
*/

#ifndef quantlib_nth_to_default_hpp
#define quantlib_nth_to_default_hpp

#include <ql/instrument.hpp>
#include <ql/cashflow.hpp>
#include <ql/default.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/experimental/credit/onefactorcopula.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class Claim;
    class Basket;

    //--------------------------------------------------------------------------
    //! N-th to default swap
    /*! A NTD instrument exchanges protection against the nth default
        in a basket of underlying credits for premium payments based
        on the protected notional amount.

        The pricing is analogous to the pricing of a CDS instrument
        which represents protection against default of a single
        underlying credit.  The only difference is the calculation of
        the probability of default.  In the CDS case, it is the
        probabilty of single name default; in the NTD case the
        probability of at least N defaults in the portfolio of
        underlying credits.

        This probability is computed using the algorithm in
        John Hull and Alan White, "Valuation of a CDO and nth to
        default CDS without Monte Carlo simulation", Journal of
        Derivatives 12, 2, 2004.

        The algorithm allows for varying probability of default across
        the basket. Otherwise, for identical probabilities of default,
        the probability of n defaults is given by the binomial
        distribution.

        Default correlation is modeled using a one-factor Gaussian copula
        approach.

        The class is tested against data in Hull-White (see reference
        above.)
    */
    class NthToDefault : public Instrument {
      public:
        class arguments;
        class results;
        class engine;

        //! This product is 'digital'; the basket might be tranched but this is 
        //  not relevant to it.
        NthToDefault(const ext::shared_ptr<Basket>& basket,
                Size n,
                Protection::Side side,
                const Schedule& premiumSchedule,
                Rate upfrontRate,
                Rate premiumRate,
                const DayCounter& dayCounter,
                Real nominal,
                bool settlePremiumAccrual);

        bool isExpired() const override;

        // inspectors
        Rate premium() const { return premiumRate_; }
        Real nominal() const { return nominal_; }
        DayCounter dayCounter() const { return dayCounter_; }
        Protection::Side side() const { return side_; }
        Size rank() const { return n_; }
        Size basketSize() const;

        const Date& maturity() const {return premiumSchedule_.endDate();}//???

        const ext::shared_ptr<Basket>& basket() const {return basket_;}

        // results
        Rate fairPremium() const;
        Real premiumLegNPV() const;
        Real protectionLegNPV() const;
        Real errorEstimate() const;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;

        ext::shared_ptr<Basket> basket_;
        Size n_;
        Protection::Side side_;
        Real nominal_;
        Schedule premiumSchedule_;
        Rate premiumRate_;
        Rate upfrontRate_;
        DayCounter dayCounter_;
        bool settlePremiumAccrual_;

        Leg premiumLeg_;/////////////////// LEG AND SCHEDULE BOTH MEMBERS..... REVISE THIS!

        // results
        mutable Rate premiumValue_;
        mutable Real protectionValue_;
        mutable Real upfrontPremiumValue_;
        mutable Real fairPremium_;
        mutable Real errorEstimate_;
    };



    class NthToDefault::arguments : public virtual PricingEngine::arguments {
    public:
        arguments() : side(Protection::Side(-1)),
                      premiumRate(Null<Real>()),
                      upfrontRate(Null<Real>()) {}
        void validate() const override;

        ext::shared_ptr<Basket> basket;
        Protection::Side side;
        Leg premiumLeg;

        Size ntdOrder;
        bool settlePremiumAccrual;
        Real notional;// ALL NAMES WITH THE SAME WEIGHT, NOTIONAL IS NOT MAPPED TO THE BASKET HERE, this does not have to be that way, its perfectly possible to have irreg notionals...
        Real premiumRate;
        Rate upfrontRate;
    };

    class NthToDefault::results : public Instrument::results {
    public:
      void reset() override;
      Real premiumValue;
      Real protectionValue;
      Real upfrontPremiumValue;
      Real fairPremium;
      Real errorEstimate;
    };

    //! NTD base engine
    class NthToDefault::engine : 
        public GenericEngine<NthToDefault::arguments, 
                             NthToDefault::results> { };

}

#endif
]]></document_content>
  </document>
  <document index="196">
    <source>credit/onefactoraffinesurvival.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef onefactor_affine_survival_hpp
#define onefactor_affine_survival_hpp

#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/termstructures/credit/hazardratestructure.hpp>
#include <utility>

namespace QuantLib {
    
    /*! Survival probability term structure based on a one factor stochastic
    model of the default intensity.
    */
    /*
    While deriving from the hazard rate class the HRTS refers only to the
    deterministic part of the model. The probabilities depend on this 
    component and the stochastic part and are rewritten here.
    Derived classes need to specify the deterministic part 
    of the hazard rate if any (the one returned by 'hazardRateImpl'). It
    is needed for the conditional/forward probabilities.
     */
    class OneFactorAffineSurvivalStructure 
        : public HazardRateStructure {
    public:
        // implement remaining constructors.....
      explicit OneFactorAffineSurvivalStructure(
          ext::shared_ptr<OneFactorAffineModel> model,
          const DayCounter& dayCounter = DayCounter(),
          const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
          const std::vector<Date>& jumpDates = std::vector<Date>())
      : HazardRateStructure(dayCounter, jumps, jumpDates), model_(std::move(model)) {}

      OneFactorAffineSurvivalStructure(
          ext::shared_ptr<OneFactorAffineModel> model,
          const Date& referenceDate,
          const Calendar& cal = Calendar(),
          const DayCounter& dayCounter = DayCounter(),
          const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
          const std::vector<Date>& jumpDates = std::vector<Date>())
      : HazardRateStructure(referenceDate, Calendar(), dayCounter, jumps, jumpDates),
        model_(std::move(model)) {}

      OneFactorAffineSurvivalStructure(
          ext::shared_ptr<OneFactorAffineModel> model,
          Natural settlementDays,
          const Calendar& calendar,
          const DayCounter& dayCounter = DayCounter(),
          const std::vector<Handle<Quote> >& jumps = std::vector<Handle<Quote> >(),
          const std::vector<Date>& jumpDates = std::vector<Date>())
      : HazardRateStructure(settlementDays, calendar, dayCounter, jumps, jumpDates),
        model_(std::move(model)) {}

      //! \name TermStructure interface
      //@{
      // overwrite on mkt models (e.g. bootstraps)
      Date maxDate() const override { return Date::maxDate(); }

      /* Notice this is not calling hazard rate methods, these are
         stochastic now.
      */
      /*!
        Returns the probability at a future time dTgt, conditional to
        survival at a prior time dFwd and to the realization of a particular
        hazard rate value at dFwd.
        \param dFwd Time of the forward survival calculation and HR
                    realization.
        \param dTgt Target time of survival probability.
        \param yVal Realized value of the HR at time dFwd.
        \param extrapolate Allow curve extrapolation.
        \return Survival probability.

        \todo turn into a protected method to be called by
              defaults and survivals
      */
      /*
        Note: curve extrapolation has a different meaning on different curve
          types; for matched to market structures the credit market curves
          would be requested for extrapolation; for affine models on top of
          a static term structure it is this one that will be required for
          extrapolation.
       */
      Probability conditionalSurvivalProbability(const Date& dFwd,
                                                 const Date& dTgt,
                                                 Real yVal,
                                                 bool extrapolate = false) const {
          return conditionalSurvivalProbability(timeFromReference(dFwd), timeFromReference(dTgt),
                                                yVal, extrapolate); 
        }
        Probability conditionalSurvivalProbability(
                Time tFwd, Time tgt, Real yVal,
                bool extrapolate = false) const
        {
            #if defined(QL_EXTRA_SAFETY_CHECKS)
                QL_REQUIRE(tgt >= tFwd, "Incorrect dates ordering.");
            #endif
            checkRange(tFwd, extrapolate);
            checkRange(tgt, extrapolate);
            
            // \todo ADD JUMPS TREATMENT

            return conditionalSurvivalProbabilityImpl(tFwd, tgt, yVal);
        }
        //@}
        // DefaultTermStructure interface
        using DefaultProbabilityTermStructure::hazardRate;
        Rate hazardRate(Time t, bool extrapolate = false) const {
            checkRange(t, extrapolate);
            return hazardRateImpl(t);
        }
    protected:
        //! \name DefaultProbabilityTermStructure implementation
        //@{
      Probability survivalProbabilityImpl(Time) const override;
      Real defaultDensityImpl(Time) const override;
      //@}
      // avoid call super
      // \todo addd date overload
      virtual Probability conditionalSurvivalProbabilityImpl(Time tFwd, Time tgt, Real yVal) const;

      // HazardRateStructure interface
      Real hazardRateImpl(Time) const override {
          // no deterministic component
          return 0.;
      }

        ext::shared_ptr<OneFactorAffineModel> model_;        
    };
    
    inline Probability
        OneFactorAffineSurvivalStructure::survivalProbabilityImpl(
        Time t) const
    {
        Real initValHR =
            model_->dynamics()->shortRate(0., 
                model_->dynamics()->process()->x0());

        return model_->discountBond(0., t, initValHR);
    }

    inline Probability
        OneFactorAffineSurvivalStructure::conditionalSurvivalProbabilityImpl(
            Time tFwd, Time tgt, Real yVal) const {
        return model_->discountBond(tFwd, tgt, yVal);
    }

    inline Real 
        OneFactorAffineSurvivalStructure::defaultDensityImpl(Time t) const {
        Real initValHR = 
            model_->dynamics()->shortRate(0., 
                model_->dynamics()->process()->x0());;

        return hazardRateImpl(t)*survivalProbabilityImpl(t) /
            model_->discountBond(0., t, initValHR);
    }
}

#endif
]]></document_content>
  </document>
  <document index="197">
    <source>credit/onefactorcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/onefactorcopula.hpp>

using namespace std;

namespace QuantLib {

    //-------------------------------------------------------------------------
    Real OneFactorCopula::conditionalProbability(Real p, Real m) const {
    //-------------------------------------------------------------------------
        calculate ();
        // FIXME
        if (p < 1e-10) return 0;

        Real c = correlation_->value();

        Real res = cumulativeZ ((inverseCumulativeY (p) - sqrt(c) * m)
                                / sqrt (1. - c));

        QL_REQUIRE (res >= 0 && res <= 1,
                    "conditional probability " << res << "out of range");

        return res;
    }

    //-------------------------------------------------------------------------
    vector<Real> OneFactorCopula::conditionalProbability(
                                                     const vector<Real>& prob,
                                                     Real m) const {
    //-------------------------------------------------------------------------
        calculate ();
        vector<Real> p (prob.size(), 0);
        for (Size i = 0; i < p.size(); i++)
            p[i] = conditionalProbability (prob[i], m);
        return p;
    }

    //-------------------------------------------------------------------------
    Real OneFactorCopula::cumulativeY (Real y) const {
    //-------------------------------------------------------------------------
        calculate ();

        QL_REQUIRE(!y_.empty(), "cumulative Y not tabulated yet");

        // linear interpolation on the tabulated cumulative distribution of Y
        if (y < y_.front())
            return cumulativeY_.front();

        for (Size i = 0; i < y_.size(); i++) {
            if (y_[i] > y)
                return (   (y_[i] - y)   * cumulativeY_[i-1]
                           + (y - y_[i-1]) * cumulativeY_[i]   )
                    / (y_[i] - y_[i-1]);
        }

        return cumulativeY_.back();
    }

    //-------------------------------------------------------------------------
    Real OneFactorCopula::inverseCumulativeY (Real x) const {
    //-------------------------------------------------------------------------
        calculate ();

        QL_REQUIRE(!y_.empty(), "cumulative Y not tabulated yet");

        // linear interpolation on the tabulated cumulative distribution of Y
        if (x < cumulativeY_.front())
            return y_.front();

        for (Size i = 0; i < cumulativeY_.size(); i++) {
            if (cumulativeY_[i] > x)
                return (   (cumulativeY_[i] - x)   * y_[i-1]
                           + (x - cumulativeY_[i-1]) * y_[i]   )
                    / (cumulativeY_[i] - cumulativeY_[i-1]);
        }

        return y_.back();
    }

    //-------------------------------------------------------------------------
    int OneFactorCopula::checkMoments (Real tolerance) const {
    //-------------------------------------------------------------------------
        calculate ();

        Real norm = 0, mean = 0, var = 0;
        for (Size i = 0; i < steps(); i++) {
            norm += densitydm (i);
            mean += m(i) * densitydm (i);
            var += pow (m(i), 2) * densitydm (i);
        }

        QL_REQUIRE (fabs (norm - 1.0) < tolerance, "norm out of tolerance range");
        QL_REQUIRE (fabs (mean) < tolerance, "mean out of tolerance range");
        QL_REQUIRE (fabs (var - 1.0) < tolerance, "variance out of tolerance range");

        // FIXME: define range for Y via cutoff quantil?
        Real zMin = -10;
        Real zMax = +10;
        Size zSteps = 200;
        norm = 0;
        mean = 0;
        var = 0;
        for (Size i = 1; i < zSteps; i++) {
            Real z1 = zMin + (zMax - zMin) / zSteps * (i - 1);
            Real z2 = zMin + (zMax - zMin) / zSteps * i;
            Real z  = (z1 + z2) / 2;
            Real densitydz = cumulativeZ (z2) - cumulativeZ (z1);
            norm += densitydz;
            mean += z * densitydz;
            var += pow (z, 2) * densitydz;
        }

        QL_REQUIRE (fabs (norm - 1.0) < tolerance, "norm out of tolerance range");
        QL_REQUIRE (fabs (mean) < tolerance, "mean out of tolerance range");
        QL_REQUIRE (fabs (var - 1.0) < tolerance, "variance out of tolerance range");

        // FIXME: define range for Y via cutoff quantil?
        Real yMin = -10;
        Real yMax = +10;
        Size ySteps = 200;
        norm = 0;
        mean = 0;
        var = 0;
        for (Size i = 1; i < ySteps; i++) {
            Real y1 = yMin + (yMax - yMin) / ySteps * (i - 1);
            Real y2 = yMin + (yMax - yMin) / ySteps * i;
            Real y  = (y1 + y2) / 2;
            Real densitydy = cumulativeY (y2) - cumulativeY (y1);
            norm += densitydy;
            mean += y * densitydy;
            var += y * y * densitydy;
        }

        QL_REQUIRE (fabs (norm - 1.0) < tolerance, "norm out of tolerance range");
        QL_REQUIRE (fabs (mean) < tolerance, "mean out of tolerance range");
        QL_REQUIRE (fabs (var - 1.0) < tolerance, "variance out of tolerance range");

        return 0;
    }

}

]]></document_content>
  </document>
  <document index="198">
    <source>credit/onefactorcopula.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file onefactorcopula.hpp
    \brief One-factor copula base class
*/

#ifndef quantlib_one_factor_copula_hpp
#define quantlib_one_factor_copula_hpp

#include <ql/experimental/credit/distribution.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/quote.hpp>
#include <utility>

namespace QuantLib {

    //! Abstract base class for one-factor copula models
    /*! Reference: John Hull and Alan White, The Perfect Copula, June 2006

        Let \f$Q_i(t)\f$ be the cumulative probability of default of
        counterparty i before time t.

        In a one-factor model, consider random variables
        \f[ Y_i = a_i\,M+\sqrt{1-a_i^2}\:Z_i \f]
        where \f$M\f$ and \f$Z_i\f$ have independent zero-mean
        unit-variance distributions and \f$-1\leq a_i \leq 1\f$.  The
        correlation between \f$Y_i\f$ and \f$Y_j\f$ is then
        \f$a_i a_j\f$.

        Let \f$F_Y(y)\f$ be the cumulative distribution function of \f$Y_i\f$.
        \f$y\f$ is mapped to \f$t\f$ such that percentiles match, i.e.
        \f$F_Y(y)=Q_i(t)\f$ or \f$y=F_Y^{-1}(Q_i(t))\f$.

        Now let \f$F_Z(z)\f$ be the cumulated distribution function of
        \f$Z_i\f$.  For given realization of \f$M\f$, this determines
        the distribution of \f$y\f$:
        \f[
        Prob \,(Y_i < y|M) = F_Z \left( \frac{y-a_i\,M}{\sqrt{1-a_i^2}}\right)
        \qquad
        \mbox{or}
        \qquad
        Prob \,(t_i < t|M) = F_Z \left( \frac{F_Y^{-1}(Q_i(t))-a_i\,M}
        {\sqrt{1-a_i^2}}
        \right)
        \f]

        The distribution functions of \f$ M, Z_i \f$ are specified in
        derived classes. The distribution function of \f$ Y \f$ is
        then given by the convolution
        \f[
        F_Y(y) = Prob\,(Y<y) = \int_{-\infty}^\infty\,\int_{-\infty}^{\infty}\:
        D_Z(z)\,D_M(m) \quad
        \Theta \left(y - a\,m - \sqrt{1-a^2}\,z\right)\,dm\,dz,
        \qquad
        \Theta (x) = \left\{
        \begin{array}{ll}
        1 & x \geq 0 \\
        0 & x < 0
        \end{array}\right.
        \f]
        where \f$ D_Z(z) \f$ and \f$ D_M(m) \f$ are the probability
        densities of \f$ Z\f$ and \f$ M, \f$ respectively.

        This convolution can also be written
        \f[
        F(y) = Prob \,(Y < y) =
        \int_{-\infty}^\infty D_M(m)\,dm\:
        \int_{-\infty}^{g(y,a,m)} D_Z(z)\,dz, \qquad
        g(y,a,m) = \frac{y - a\cdot m}{\sqrt{1-a^2}}, \qquad a < 1
        \f]

        or

        \f[
        F(y) = Prob \,(Y < y) =
        \int_{-\infty}^\infty D_Z(z)\,dz\:
        \int_{-\infty}^{h(y,a,z)} D_M(m)\,dm, \qquad
        h(y,a,z) = \frac{y - \sqrt{1 - a^2}\cdot z}{a}, \qquad a > 0.
        \f]

        In general, \f$ F_Y(y) \f$ needs to be computed numerically.

        \todo Improve on simple Euler integration
    */
    class OneFactorCopula : public LazyObject {
      public:
        OneFactorCopula(Handle<Quote> correlation,
                        Real maximum = 5.0,
                        Size integrationSteps = 50,
                        Real minimum = -5.0)
        : correlation_(std::move(correlation)), max_(maximum), steps_(integrationSteps),
          min_(minimum) {
            QL_REQUIRE(correlation_->value() >= -1
                       && correlation_->value() <= 1,
                       "correlation out of range [-1, +1]");
            registerWith(correlation_);
        }

        //! Density function of M.
        /*! Derived classes must override this method and ensure zero
            mean and unit variance.
        */
        virtual Real density(Real m) const = 0;
        //! Cumulative distribution of Z.
        /*! Derived classes must override this method and ensure zero
            mean and unit variance.
        */
        virtual Real cumulativeZ(Real z) const = 0;
        //! Cumulative distribution of Y.
        /*! This is the default implementation based on tabulated
            data. The table needs to be filled by derived classes. If
            analytic calculation is feasible, this method can also be
            overridden.
        */
        virtual Real cumulativeY(Real y) const;
        //! Inverse cumulative distribution of Y.
        /*! This is the default implementation based on tabulated
            data. The table needs to be filled by derived classes. If
            analytic calculation is feasible, this method can also be
            overridden.
        */
        virtual Real inverseCumulativeY(Real p) const;

        //! Single correlation parameter
        Real correlation() const;

        //! Conditional probability
        /*! \f[
            \hat p(m) = F_Z \left( \frac{F_Y^{-1}(p)-a\,m}{\sqrt{1-a^2}}\right)
            \f]
        */
        Real conditionalProbability(Real prob,
                                    Real m) const;

        //! Vector of conditional probabilities
        /*! \f[
            \hat p_i(m) = F_Z \left( \frac{F_Y^{-1}(p_i)-a\,m}{\sqrt{1-a^2}}
            \right)
            \f]
        */
        std::vector<Real> conditionalProbability(const std::vector<Real>& prob,
                                                 Real m) const;

        /*! Integral over the density \f$ \rho(m) \f$ of M and the conditional
            probability related to p:

            \f[
            \int_{-\infty}^\infty\,dm\,\rho(m)\,
            F_Z \left( \frac{F_Y^{-1}(p)-a\,m}{\sqrt{1-a^2}}\right)
            \f]
        */
        Real integral(Real p) const {
            QL_REQUIRE(p >= 0 && p <= 1, "probability p=" << p
                       << " out of range [0,1]");
            calculate();

            Real avg = 0;
            for (Size k = 0; k < steps(); k++) {
                Real pp = conditionalProbability(p, m(k));
                avg += pp * densitydm(k);
            }
            return avg;
        }

        /*! Integral over the density \f$ \rho(m) \f$ of M and a
            one-dimensional function \f$ f \f$ of conditional
            probabilities related to the input vector of probabilities p:

            \f[
            \int_{-\infty}^\infty\,dm\,\rho(m)\, f (\hat p_1, \hat p_2, \dots,
            \hat p_N), \qquad
            \hat p_i (m) = F_Z \left( \frac{F_Y^{-1}(p_i)-a\,m}{\sqrt{1-a^2}}
            \right)
            \f]
        */
        template <class F>
        Real integral(const F& f, std::vector<Real>& probabilities) const {
            calculate();

            Real avg = 0.0;
            for (Size i = 0; i < steps_; i++) {
                std::vector<Real> conditional
                    = conditionalProbability(probabilities, m(i));
                Real prob = f(conditional);
                avg += prob * densitydm(i);
            }
            return avg;
        }

        /*! Integral over the density \f$ \rho(m) \f$ of M and a
            multi-dimensional function \f$ f \f$ of conditional
            probabilities related to the input vector of probabilities p:

            \f[
            \int_{-\infty}^\infty\,dm\,\rho(m)\, f (\hat p_1, \hat p_2, \dots,
            \hat p_N), \qquad
            \hat p_i = F_Z \left( \frac{F_Y^{-1}(p_i)-a\,m}{\sqrt{1-a^2}}\right)
            \f]
        */
        template <class F>
        Distribution integral(const F& f,
                              const std::vector<Real>& nominals,
                              const std::vector<Real>& probabilities) const {
            calculate();

            Distribution dist(f.buckets(), 0.0, f.maximum());
            for (Size i = 0; i < steps(); i++) {
                std::vector<Real> conditional
                    = conditionalProbability(probabilities, m(i));
                Distribution d = f(nominals, conditional);
                for (Size j = 0; j < dist.size(); j++)
                    dist.addDensity(j, d.density(j) * densitydm(i));
            }
            return dist;
        }

        /*! Check moments (unit norm, zero mean and unit variance) of
            the distributions of M, Z, and Y by numerically
            integrating the respective density.  Parameter tolerance
            is the maximum tolerable absolute error.
        */
        int checkMoments(Real tolerance) const;

      protected:
        Handle<Quote> correlation_;
        mutable Real max_;
        mutable Size steps_;
        mutable Real min_;

        // Tabulated numerical solution of the cumulated distribution of Y
        mutable std::vector<Real> y_;
        mutable std::vector<Real> cumulativeY_;

        //private:
        // utilities for simple Euler integrations over the density of M
        Size steps() const;

        // i not used yet, might allow varying grid size
        // for the copula integration in the future
        Real dm(Size i) const;

        Real m(Size i) const;
        Real densitydm(Size i) const;
    };

    inline Real OneFactorCopula::correlation() const {
        calculate();
        return correlation_->value();
    }

    inline Size OneFactorCopula::steps() const {
        return steps_;
    }

    inline Real OneFactorCopula::dm(Size) const {
        return (max_ - min_)/ steps_;
    }

    inline Real OneFactorCopula::m(Size i) const {
        QL_REQUIRE(i < steps_, "index out of range");
        return min_ + dm(i) * i + dm(i) / 2;
    }

    inline Real OneFactorCopula::densitydm(Size i) const {
        QL_REQUIRE(i < steps_, "index out of range");
        return density(m(i)) * dm(i);
    }

}

#endif
]]></document_content>
  </document>
  <document index="199">
    <source>credit/onefactorgaussiancopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/onefactorgaussiancopula.hpp>

namespace QuantLib {

    //-----------------------------------------------------------------------
    Real OneFactorGaussianCopula::testCumulativeY (Real y) const {
    //-----------------------------------------------------------------------
        Real c = correlation_->value();

        if (c == 0)
            return CumulativeNormalDistribution()(y);

        if (c == 1)
            return CumulativeNormalDistribution()(y);

        NormalDistribution dz;
        NormalDistribution dm;

        Real minimum = -10;
        Real maximum = +10;
        int steps = 200;

        Real delta = (maximum - minimum) / steps;
        Real cumulated = 0;
        if (c < 0.5) {
            // outer integral -> 1 for c -> 0
            // inner integral -> CumulativeNormal()(y) for c-> 0
            for (Real m = minimum; m < maximum; m += delta)
                for (Real z = minimum; z < (y - std::sqrt(c) * m) / std::sqrt (1. - c);
                     z += delta)
                    cumulated += dm (m) * dz (z);
        }
        else {
            // outer integral -> 1 for c -> 1
            // inner integral -> CumulativeNormal()(y) for c-> 1
            for (Real z = minimum; z < maximum; z += delta)
                for (Real m = minimum; m < (y - std::sqrt(1.0 - c) * z) / std::sqrt(c);
                     m += delta)
                    cumulated += dm (m) * dz (z);
        }
        cumulated *= (delta * delta);

        return cumulated;
    }

}

]]></document_content>
  </document>
  <document index="200">
    <source>credit/onefactorgaussiancopula.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file onefactorgaussiancopula.hpp
    \brief One-factor Gaussian copula
*/

#ifndef quantlib_one_factor_gaussian_copula_hpp
#define quantlib_one_factor_gaussian_copula_hpp

#include <ql/experimental/credit/onefactorcopula.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! One-factor Gaussian Copula
    /*! The copula model
        \f[ Y_i = a_i\,M+\sqrt{1-a_i^2}\:Z_i \f]
        is specified here by setting the desnity function for all
        variables, \f$ M, Z,\f$ and also \f$ Y \f$ to the standard
        normal distribution
        \f$ \phi(x) = \exp(-x^2/2) / \sqrt{2\pi}. \f$
    */
    class OneFactorGaussianCopula : public OneFactorCopula {
      public:
        explicit OneFactorGaussianCopula(const Handle<Quote>& correlation,
                                         Real maximum = 5, Size integrationSteps = 50)
        : OneFactorCopula (correlation, maximum, integrationSteps) {
            registerWith(correlation_);
        }
        Real density(Real m) const override;
        Real cumulativeZ(Real z) const override;
        /*! overrides the base class implementation based on table data */
        Real cumulativeY(Real y) const override;
        Real testCumulativeY (Real y) const;
        /*! overrides the base class implementation based on table data */
        Real inverseCumulativeY(Real p) const override;

      private:
        // nothing to be done when correlation changes
        void performCalculations() const override {}

        NormalDistribution density_;
        CumulativeNormalDistribution cumulative_;
        InverseCumulativeNormal inverseCumulative_;
    };

    inline Real OneFactorGaussianCopula::density (Real m) const {
        return density_(m);
    }

    inline Real OneFactorGaussianCopula::cumulativeZ (Real z) const {
        return cumulative_(z);
    }

    inline Real OneFactorGaussianCopula::cumulativeY (Real y) const {
        return cumulative_(y);
    }

    inline Real OneFactorGaussianCopula::inverseCumulativeY (Real p) const {
        return inverseCumulative_(p);
    }

}

#endif
]]></document_content>
  </document>
  <document index="201">
    <source>credit/onefactorstudentcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/onefactorstudentcopula.hpp>

namespace QuantLib {

    //-------------------------------------------------------------------------
    OneFactorStudentCopula::OneFactorStudentCopula (
                                             const Handle<Quote>& correlation,
                                             int nz, int nm,
                                             Real maximum,
                                             Size integrationSteps)
    : OneFactorCopula (correlation, maximum, integrationSteps),
      density_ (nm), cumulative_ (nz), nz_(nz), nm_(nm) {
    //-------------------------------------------------------------------------

        QL_REQUIRE (nz > 2 && nm > 2, "degrees of freedom must be > 2");

        scaleM_ = std::sqrt (Real (nm_ - 2) / nm_);
        scaleZ_ = std::sqrt (Real (nz_ - 2) / nz_);

        calculate ();
    }

    //-------------------------------------------------------------------------
    void OneFactorStudentCopula::performCalculations () const {
    //-------------------------------------------------------------------------
        y_.clear();
        cumulativeY_.clear();

        // FIXME:
        // compute F(ymin) and F(ymax) for the fattest case nm = nz = 2
        // set a desired confidence and work out ymin, ymax
        Real ymin = -10;
        Real ymax = +10;
        Size steps = 200;
        for (Size i = 0; i <= steps; i++) {
            Real y = ymin + (ymax - ymin) * i / steps;
            Real c = cumulativeYintegral (y);
            y_.push_back (y);
            cumulativeY_.push_back (c);
        }
    }

    //-------------------------------------------------------------------------
    Real OneFactorStudentCopula::cumulativeYintegral (Real y) const {
    //-------------------------------------------------------------------------
        Real c = correlation_->value();

        if (c == 0)
            return CumulativeStudentDistribution(nz_)(y / scaleZ_);

        if (c == 1)
            return CumulativeStudentDistribution(nm_)(y / scaleM_);

        StudentDistribution dz (nz_);
        StudentDistribution dm (nm_);

        // FIXME:
        // Find a sensitive way of setting these parameters,
        // e.g. depending on nm and nz, and the desired table range
        Real minimum = -10; // -15
        Real maximum = +10; // +15
        int steps = 400;

        Real delta = (maximum - minimum) / steps;
        Real cumulated = 0;

        if (c < 0.5) {
            // outer integral -> 1 for c -> 0
            // inner integral -> cumulativeStudent(nz)(y) for c-> 0
            for (Real m = minimum + delta/2; m < maximum; m += delta)
                for (Real z = minimum + delta/2;
                     z < (y - std::sqrt(c) * m) / std::sqrt (1. - c); z += delta)
                    cumulated += dm (m / scaleM_) / scaleM_
                        * dz (z / scaleZ_) / scaleZ_;
        }
        else {
            // outer integral -> 1 for c -> 1
            // inner integral -> cumulativeStudent(nm)(y) for c-> 1
            for (Real z = minimum + delta/2; z < maximum; z += delta)
                for (Real m = minimum + delta/2;
                     m < (y - std::sqrt(1.0 - c) * z) / std::sqrt(c); m += delta)
                    cumulated += dm (m / scaleM_) / scaleM_
                        * dz (z / scaleZ_) / scaleZ_;
        }

        return cumulated * delta * delta;
    }

    //-------------------------------------------------------------------------
    OneFactorGaussianStudentCopula::OneFactorGaussianStudentCopula (
                                             const Handle<Quote>& correlation,
                                             int nz, Real maximum,
                                             Size integrationSteps)
    : OneFactorCopula (correlation, maximum, integrationSteps),
      cumulative_(nz), nz_(nz) {
    //-------------------------------------------------------------------------

        QL_REQUIRE (nz > 2, "degrees of freedom must be > 2");

        scaleZ_ = std::sqrt (Real (nz_ - 2) / nz_);

        calculate ();
    }

    //-------------------------------------------------------------------------
    void OneFactorGaussianStudentCopula::performCalculations () const {
    //-------------------------------------------------------------------------
        y_.clear();
        cumulativeY_.clear();

        // FIXME:
        // compute F(ymin) and F(ymax) for the fattest case nm = nz = 2
        // set a desired confidence and work out ymin, ymax
        Real ymin = -10;
        Real ymax = +10;
        Size steps = 200;
        for (Size i = 0; i <= steps; i++) {
            Real y = ymin + (ymax - ymin) * i / steps;
            Real c = cumulativeYintegral (y);
            y_.push_back (y);
            cumulativeY_.push_back (c);
        }
    }

    //-------------------------------------------------------------------------
    Real OneFactorGaussianStudentCopula::cumulativeYintegral (Real y) const {
    //-------------------------------------------------------------------------
        Real c = correlation_->value();

        if (c == 0)
            return CumulativeStudentDistribution(nz_)(y / scaleZ_);

        if (c == 1)
            return CumulativeNormalDistribution()(y);

        StudentDistribution dz (nz_);
        NormalDistribution dm;

        // FIXME:
        // Find a sensitive way of setting these parameters,
        // e.g. depending on nm and nz, and the desired table range
        Real minimum = -10;
        Real maximum = +10;
        int steps = 400;

        Real delta = (maximum - minimum) / steps;
        Real cumulated = 0;

        if (c < 0.5) {
            // outer integral -> 1 for c -> 0
            // inner integral -> cumulativeStudent(nz)(y) for c-> 0
            for (Real m = minimum + delta/2; m < maximum; m += delta)
                for (Real z = minimum + delta/2;
                     z < (y - std::sqrt(c) * m) / std::sqrt (1. - c);
                     z += delta)
                    cumulated += dm (m) * dz (z / scaleZ_) / scaleZ_;
        }
        else {
            // outer integral -> 1 for c -> 1
            // inner integral -> cumulativeNormal(y) for c-> 1
            for (Real z = minimum + delta/2; z < maximum; z += delta)
                for (Real m = minimum + delta/2;
                     m < (y - std::sqrt(1.0 - c) * z) / std::sqrt(c);
                     m += delta)
                    cumulated += dm (m) * dz (z / scaleZ_) / scaleZ_;
        }

        return cumulated * delta * delta;
    }

    //-------------------------------------------------------------------------
    OneFactorStudentGaussianCopula::OneFactorStudentGaussianCopula (
                                             const Handle<Quote>& correlation,
                                             int nm, Real maximum,
                                             Size integrationSteps)
    : OneFactorCopula (correlation, maximum, integrationSteps),
      density_ (nm), nm_(nm) {
    //-------------------------------------------------------------------------

        QL_REQUIRE (nm > 2, "degrees of freedom must be > 2");

        scaleM_ = std::sqrt (Real (nm_ - 2) / nm_);

        calculate ();
    }

    //-------------------------------------------------------------------------
    void OneFactorStudentGaussianCopula::performCalculations () const {
    //-------------------------------------------------------------------------
        y_.clear();
        cumulativeY_.clear();

        // FIXME:
        // compute F(ymin) and F(ymax) for the fattest case nm = nz = 2
        // set a desired confidence and work out ymin, ymax
        Real ymin = -10;
        Real ymax = +10;
        Size steps = 200;
        for (Size i = 0; i <= steps; i++) {
            Real y = ymin + (ymax - ymin) * i / steps;
            Real c = cumulativeYintegral (y);
            y_.push_back (y);
            cumulativeY_.push_back (c);
        }
    }

    //-------------------------------------------------------------------------
    Real OneFactorStudentGaussianCopula::cumulativeYintegral (Real y) const {
    //-------------------------------------------------------------------------
        Real c = correlation_->value();

        if (c == 0)
            return CumulativeNormalDistribution()(y);

        if (c == 1)
            return CumulativeStudentDistribution(nm_)(y / scaleM_);


        StudentDistribution dm (nm_);
        NormalDistribution dz;

        // FIXME:
        // Find a sensitive way of setting these parameters,
        // e.g. depending on nm and nz, and the desired table range
        Real minimum = -10;
        Real maximum = +10;
        int steps = 400;

        Real delta = (maximum - minimum) / steps;
        Real cumulated = 0;

        if (c < 0.5) {
            // outer integral -> 1 for c -> 0
            // inner integral -> cumulativeNormal(y) for c-> 0
            for (Real m = minimum + delta/2; m < maximum; m += delta)
                for (Real z = minimum + delta/2;
                     z < (y - std::sqrt(c) * m) / std::sqrt (1. - c);
                     z += delta)
                    cumulated += dm (m / scaleM_) / scaleM_ * dz (z);
        }
        else {
            // outer integral -> 1 for c -> 1
            // inner integral -> cumulativeStudent(nm)(y) for c-> 1
            for (Real z = minimum + delta/2; z < maximum; z += delta)
                for (Real m = minimum + delta/2;
                     m < (y - std::sqrt(1.0 - c) * z) / std::sqrt(c);
                     m += delta)
                    cumulated += dm (m / scaleM_) / scaleM_ * dz (z);
        }

        return cumulated * delta * delta;
    }

}
]]></document_content>
  </document>
  <document index="202">
    <source>credit/onefactorstudentcopula.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file onefactorstudentcopula.hpp
    \brief One-factor Student-t copula
*/

#ifndef quantlib_one_factor_student_copula_hpp
#define quantlib_one_factor_student_copula_hpp

#include <ql/experimental/credit/onefactorcopula.hpp>
#include <ql/math/distributions/studenttdistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! One-factor Double Student t-Copula
    /*! The copula model
        \f[ Y_i = a_i\,M+\sqrt{1-a_i^2}\:Z_i \f]

        is specified here by setting the probability density functions
        for \f$ Z_i \f$ (\f$ D_Z \f$) and \f$ M \f$ (\f$ D_M \f$) to
        Student t-distributions with \f$ N_z \f$ and \f$ N_m \f$
        degrees of freedom, respectively.

        The variance of the Student t-distribution with \f$ \nu \f$
        degrees of freedom is \f$ \nu / (\nu - 2) \f$. Since the
        copula approach requires zero mean and unit variance
        distributions, variables \f$ Z \f$ and \f$ M \f$ are scaled by
        \f$ \sqrt{(N_z - 2) / N_z} \f$ and \f$ \sqrt{(N_m - 2) / N_m}, \f$
        respectively.

        \todo Improve performance/accuracy of the calculation of
              inverse cumulative Y. Tabulate and store it for selected
              correlations?
    */
    class OneFactorStudentCopula : public OneFactorCopula {
      public:
        OneFactorStudentCopula (const Handle<Quote>& correlation,
                                int nz, int nm,
                                Real maximum = 10, Size integrationSteps = 200);

        Real density(Real m) const override;
        Real cumulativeZ(Real z) const override;

      private:
        //! Observer interface
        void performCalculations() const override;

        StudentDistribution density_;              // density of M
        CumulativeStudentDistribution cumulative_; // cumulated density of Z
        int nz_;                                   // degrees of freedom of Z
        int nm_;                                   // degrees of freedom of M

        Real scaleM_; // scaling for m to ensure unit variance
        Real scaleZ_; // scaling for z to ensure unit variance

        // This function is used to update the table of the cumulative
        // distribution of Y. It is invoked by performCalculations() when the
        // correlation handle is amended.
        Real cumulativeYintegral (Real y) const;
    };

    inline Real OneFactorStudentCopula::density (Real m) const {
        return density_(m / scaleM_) / scaleM_;
    }

    inline Real OneFactorStudentCopula::cumulativeZ (Real z) const {
        return cumulative_(z / scaleZ_);
    }


    //! One-factor Gaussian-Student t-Copula
    /*! The copula model
        \f[ Y_i = a_i\,M+\sqrt{1-a_i^2}\:Z_i \f]

        is specified here by setting the probability density functions
        for \f$ Z_i \f$ (\f$ D_Z \f$) to a Student t-distributions
        with \f$ N_z \f$ degrees of freedom, and for \f$ M \f$
        (\f$ D_M \f$) to a Gaussian.

        The variance of the Student t-distribution with \f$ \nu \f$
        degrees of freedom is \f$ \nu / (\nu - 2) \f$. Since the
        copula approach requires zero mean and unit variance
        distributions, \f$ Z \f$ is scaled by \f$ \sqrt{(N_z - 2) /
        N_z}.\f$

        \todo Improve performance/accuracy of the calculation of
              inverse cumulative Y. Tabulate and store it for selected
              correlations?
    */
    class OneFactorGaussianStudentCopula : public OneFactorCopula {
      public:
        OneFactorGaussianStudentCopula (const Handle<Quote>& correlation,
                                        int nz,
                                        Real maximum = 10,
                                        Size integrationSteps = 200);

        Real density(Real m) const override;
        Real cumulativeZ(Real z) const override;

      private:
        //! Observer interface
        void performCalculations() const override;

        NormalDistribution density_;               // density of M
        CumulativeStudentDistribution cumulative_; // cumulated density of Z
        int nz_;                                   // degrees of freedom of Z

        Real scaleZ_; // scaling for z to ensure unit variance

        // This function is used to update the table of the cumulative
        // distribution of Y. It is invoked by performCalculations() when the
        // correlation handle is amended.
        Real cumulativeYintegral (Real y) const;
    };

    inline Real OneFactorGaussianStudentCopula::density (Real m) const {
        return density_(m);
    }

    inline Real OneFactorGaussianStudentCopula::cumulativeZ (Real z) const {
        return cumulative_(z / scaleZ_);
    }


    //! One-factor Student t - Gaussian Copula
    /*! The copula model
        \f[ Y_i = a_i\,M+\sqrt{1-a_i^2}\:Z_i \f]
        is specified here by setting the probability density functions
        for \f$ Z_i \f$ (\f$ D_Z \f$) to a Gaussian and for \f$ M \f$
        (\f$ D_M \f$) to a Student t-distribution with \f$ N_m \f$
        degrees of freedom.

        The variance of the Student t-distribution with \f$ \nu \f$
        degrees of freedom is \f$ \nu / (\nu - 2) \f$. Since the
        copula approach requires zero mean and unit variance
        distributions, \f$ M \f$ is scaled by \f$ \sqrt{(N_m - 2) /
        N_m}. \f$

        \todo Improve performance/accuracy of the calculation of
              inverse cumulative Y. Tabulate and store it for selected
              correlations?
    */
    class OneFactorStudentGaussianCopula : public OneFactorCopula {
      public:
        OneFactorStudentGaussianCopula (const Handle<Quote>& correlation,
                                        int nm,
                                        Real maximum = 10,
                                        Size integrationSteps = 200);

        Real density(Real m) const override;
        Real cumulativeZ(Real z) const override;

      private:
        //! Observer interface
        void performCalculations() const override;

        StudentDistribution density_;              // density of M
        CumulativeNormalDistribution cumulative_;  // cumulated density of Z
        int nm_;                                   // degrees of freedom of M

        Real scaleM_; // scaling for m to ensure unit variance

        // This function is used to update the table of the cumulative
        // distribution of Y. It is invoked by performCalculations() when the
        // correlation handle is amended.
        Real cumulativeYintegral (Real y) const;
    };

    inline Real OneFactorStudentGaussianCopula::density (Real m) const {
        return density_(m / scaleM_) / scaleM_;
    }

    inline Real OneFactorStudentGaussianCopula::cumulativeZ (Real z) const {
        return cumulative_(z);
    }

}


#endif
]]></document_content>
  </document>
  <document index="203">
    <source>credit/pool.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/pool.hpp>
#include <ql/functional.hpp>
#include <iterator>

namespace QuantLib {

    Pool::Pool() {
        clear();
    }

    Size Pool::size() const {
        return names_.size();
    }

    void Pool::clear() {
        data_.clear();
        time_.clear();
        names_.clear();
    }

    bool Pool::has(const std::string& name) const {
        return data_.find(name) != data_.end();
    }

    void Pool::add (const std::string& name, const Issuer& issuer, 
        const DefaultProbKey& contractTrigger) {
        if (!has(name)) {
            data_[name] = issuer;
            time_[name] = 0.0;
            names_.push_back(name);
            defaultKeys_[name] = contractTrigger;
        }
    }

    const Issuer& Pool::get (const std::string& name) const {
        QL_REQUIRE(has(name), name + " not found");
        return data_.find(name)->second;
    }

    const DefaultProbKey& Pool::defaultKey (const std::string& name) const {
        QL_REQUIRE(has(name), name + " not found");
        return defaultKeys_.find(name)->second;
    }

    Real Pool::getTime (const std::string& name) const {
        QL_REQUIRE(has(name), name + " not found");
        return time_.find(name)->second;
    }

    void Pool::setTime(const std::string& name, Real time) {
        time_[name] = time;
    }

    const std::vector<std::string>& Pool::names() const {
        return names_;
    }

    Disposable<std::vector<DefaultProbKey> > Pool::defaultKeys() const {
        std::vector<DefaultProbKey> defaultKeys;
        defaultKeys.reserve(defaultKeys_.size());
        for (const auto & i : defaultKeys_)
            defaultKeys.push_back(i.second);
        return defaultKeys;
    }

}


]]></document_content>
  </document>
  <document index="204">
    <source>credit/pool.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pool.hpp
    \brief pool of issuers
*/

#ifndef quantlib_pool_hpp
#define quantlib_pool_hpp

#include <ql/utilities/disposable.hpp>
#include <ql/experimental/credit/issuer.hpp>
#include <map>

namespace QuantLib {

    class Pool {
      public:
        Pool();
        Size size() const;
        void clear();
        bool has (const std::string& name) const;
        void add (const std::string& name, const Issuer& issuer, 
            const DefaultProbKey& contractTrigger = NorthAmericaCorpDefaultKey(
                Currency(), SeniorSec, Period(), 1.));
        const Issuer& get (const std::string& name) const;
        const DefaultProbKey& defaultKey(const std::string& name) const;
        void setTime(const std::string& name, Real time);
        Real getTime (const std::string& name) const;
        const std::vector<std::string>& names() const;
        Disposable<std::vector<DefaultProbKey> > defaultKeys() const;
    private:
        // \todo: needs to cehck all defaul TS have the same ref date? here or
        //   where used? e.g. simulations.
        std::map<std::string,Issuer> data_;
        std::map<std::string,Real> time_;
        std::vector<std::string> names_;
        /*! default events seniority and currency this name enters the basket 
        with. Determines to which event/probability this pool referes to. */
        std::map<std::string, DefaultProbKey> defaultKeys_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="205">
    <source>credit/randomdefaultlatentmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_randomdefault_latent_model_hpp
#define quantlib_randomdefault_latent_model_hpp

#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <ql/experimental/math/gaussiancopulapolicy.hpp>
#include <ql/experimental/math/latentmodel.hpp>
#include <ql/experimental/math/tcopulapolicy.hpp>
#include <ql/math/beta.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/statistics/histogram.hpp>
#include <ql/math/statistics/riskstatistics.hpp>
#include <ql/tuple.hpp>
#include <utility>

/* Intended to replace
    ql\experimental\credit\randomdefaultmodel.Xpp
*/

namespace QuantLib {

    /*! Simulation event trait class template forward declaration.
    Each latent model will be modelling different entities according to the
    meaning of the model function which depends on the random \$ Y_i\$
    variables. Still the generation of the factors and variables it is common to
    any model. Only within a given transformation function the model and event
    generated becomes concrete.

    However here these simulations are already made specific to a default event.
    Yet other variables contingent to default can be modelled (recovery,
    market...) So we are placed in a less generic stage where default is
    modelled possibly jointly with other unespecified magnitudes.

    Another role of this trait class is to compact in memory the simulation
    data. The statistic post processing needs to have the results stored in
    memory and simulations can not be consumed at generation time, typically
    because some statistics are conditional on others (e.g. ESF) or/and
    parametric (percentile, etc...)

    Simulation events do not derive from each other, and they are specialized
    for each type; duck typing applies for variable names (see the statistic
    methods)
    */
    // replaces class Loss
    template <class simEventOwner> struct simEvent;


    /*! Base class for latent model monte carlo simulation. Independent of the
    copula type and the generator.
    Generates the factors and variable samples and determines event threshold
    but it is not responsible for actual event specification; thats the derived
    classes responsibility according to what they model.
    Derived classes need mainly to implement nextSample (Worker::nextSample in
    the multithreaded version) to compute the simulation event generated, if
    any, from the latent variables sample. They also have the accompanying
    event trait to specify.
    */
    /* CRTP used for performance to avoid virtual table resolution in the Monte
    Carlo. Not only in sample generation but access; quite an amount of time can
    go into statistics computation, for a portfolio of tens of thousands
    positions that part of the problem will be starting to overtake the
    simulation costs.

    \todo: someone with sound experience on cache misses look into this, the
    statistics will be getting memory in and out of the cpu heavily and it
    might be possible to get performance out of that.
    \todo: parallelize the statistics computation, things like Var/ESF splits
    are very expensive.
    \todo: consider another design, taking the statistics outside the models.
    */
    template<template <class, class> class derivedRandomLM, class copulaPolicy,
        class USNG = SobolRsg>
    class RandomLM : public virtual LazyObject,
                     public virtual DefaultLossModel {
    private:
        // Takes the parents type, all children have the same type, the
        // random generation is performed in this class only.
        typedef typename LatentModel<copulaPolicy>::template FactorSampler<USNG>
            copulaRNG_type;
    protected:
      RandomLM(Size numFactors, Size numLMVars, copulaPolicy copula, Size nSims, BigNatural seed)
      : seed_(seed), numFactors_(numFactors), numLMVars_(numLMVars), nSims_(nSims),
        copula_(std::move(copula)) {}

      void update() override {
          simsBuffer_.clear();
          // tell basket to notify instruments, etc, we are invalid
          if (!basket_.empty())
              basket_->notifyObservers();
          LazyObject::update();
        }

        void performCalculations() const override {
            static_cast<const derivedRandomLM<copulaPolicy, USNG>* >(
                this)->initDates();//in update?
            copulasRng_ = ext::make_shared<copulaRNG_type>(copula_, seed_);
            performSimulations();
        }

        void performSimulations() const {
            // Next sequence should determine the event and push it into buffer
            for (Size i = nSims_; i != 0U; i--) {
                const std::vector<Real>& sample =
                    copulasRng_->nextSequence().value;
                static_cast<const derivedRandomLM<copulaPolicy, USNG>* >(
                    this)->nextSample(sample);
            // alternatively make call an explicit local method...
            }
        }

        /* Method to access simulation results and avoiding a copy of
        each thread results buffer. PerformCalculations should have been called.
        Here in the monothread version this method is redundant/trivial but
        serves to detach the statistics access to the way the simulations are
        stored.
        */
        const std::vector<simEvent<derivedRandomLM<copulaPolicy, USNG> > >&
            getSim(const Size iSim) const { return simsBuffer_[iSim]; }

        /* Allows statistics to be written generically for fixed and random
        recovery rates. */
        Real getEventRecovery(
            const simEvent<derivedRandomLM<copulaPolicy, USNG> >& evt) const
        {
            return static_cast<const derivedRandomLM<copulaPolicy, USNG>* >(
                this)->getEventRecovery(evt);
        }

        //! \name Statistics, DefaultLossModel interface.
        // These are virtual and allow for children-specific optimization and
        //   variance reduction. The virtual table is ok, they are not part
        //   of the simulation.
        //@{
        /*! Returns the probaility of having a given or larger number of
        defaults in the basket portfolio at a given time.
        */
        Probability probAtLeastNEvents(Size n, const Date& d) const override;
        /*! Order of results refers to the simulated (super)pool not the
        basket's pool.
        Notice that this statistic suffers from heavy dispersion. To see
        techniques to improve it (not implemented here) see:
        Joshi, M., D. Kainth. 2004. Rapid and accurate development of prices
        and Greeks for nth to default credit swaps in the Li model. Quantitative
        Finance, Vol. 4. Institute of Physics Publishing, London, UK, 266-275
        and:
        Chen, Z., Glasserman, P. 'Fast pricing of basket default swaps' in
        Operations Research Vol. 56, No. 2, March/April 2008, pp. 286-303
        */
        Disposable<std::vector<Probability> > probsBeingNthEvent(Size n,
                                                                 const Date& d) const override;
        //! Pearsons' default probability correlation.
        Real defaultCorrelation(const Date& d, Size iName, Size jName) const override;
        Real expectedTrancheLoss(const Date& d) const override;
        virtual std::pair<Real, Real> expectedTrancheLossInterval(const Date& d,
            Probability confidencePerc) const;
        Disposable<std::map<Real, Probability> > lossDistribution(const Date& d) const override;
        virtual Histogram computeHistogram(const Date& d) const;
        Real expectedShortfall(const Date& d, Real percent) const override;
        Real percentile(const Date& d, Real percentile) const override;
        /*! Returns the VaR value for a given percentile and the 95 confidence
        interval of that value. */
        virtual ext::tuple<Real, Real, Real> percentileAndInterval(
            const Date& d, Real percentile) const;
        /*! Distributes the total VaR amount along the portfolio counterparties.
            The passed loss amount is in loss units.
        */
        Disposable<std::vector<Real> > splitVaRLevel(const Date& date, Real loss) const override;
        /*! Distributes the total VaR amount along the portfolio
            counterparties.

            Provides confidence interval for split so that portfolio
            optimization can be performed outside those limits.

            The passed loss amount is in loss units.
        */
        virtual Disposable<std::vector<std::vector<Real> > > splitVaRAndError(
            const Date& date, Real loss, Probability confInterval) const;
        //@}
    public:
      ~RandomLM() override = default;

    private:
        BigNatural seed_;
    protected:
        const Size numFactors_;
        const Size numLMVars_;

        const Size nSims_;

        mutable std::vector<std::vector<simEvent<derivedRandomLM<copulaPolicy,
            USNG > > > > simsBuffer_;

        mutable copulaPolicy copula_;
        mutable ext::shared_ptr<copulaRNG_type> copulasRng_;

        // Maximum time inversion horizon
        static const Size maxHorizon_ = 4050; // over 11 years
        // Inversion probability limits are computed by children in initdates()
    };


    /* ---- Statistics ---------------------------------------------------  */

    template<template <class, class> class D, class C, class URNG>
    Probability RandomLM<D, C, URNG>::probAtLeastNEvents(Size n,
        const Date& d) const
    {
        calculate();
        Date today = Settings::instance().evaluationDate();

        QL_REQUIRE(d>today, "Date for statistic must be in the future.");
        // casted to natural to avoid warning, we have just checked the sign
        Natural val = d.serialNumber() - today.serialNumber();

        if(n==0) return 1.;

        Real counts = 0.;
        for(Size iSim=0; iSim < nSims_; iSim++) {
            Size simCount = 0;
            const std::vector<simEvent<D<C, URNG> > >& events =
                getSim(iSim);
            for(Size iEvt=0; iEvt < events.size(); iEvt++)
                // duck type on the members:
                if(val > events[iEvt].dayFromRef) simCount++;
            if(simCount >= n) counts++;
        }
        return counts/nSims_;
        // \todo Provide confidence interval
    }

    template<template <class, class> class D, class C, class URNG>
    Disposable<std::vector<Probability> >
        RandomLM<D, C, URNG>::probsBeingNthEvent(Size n,
            const Date& d) const
    {
        calculate();
        Size basketSize = basket_->size();

        QL_REQUIRE(n>0 && n<=basketSize, "Impossible number of defaults.");
        Date today = Settings::instance().evaluationDate();

        QL_REQUIRE(d>today, "Date for statistic must be in the future.");
        // casted to natural to avoid warning, we have just checked the sign
        Natural val = d.serialNumber() - today.serialNumber();

        std::vector<Probability> hitsByDate(basketSize, 0.);
        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);
            std::map<unsigned short, unsigned short> namesDefaulting;
            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                // if event is within time horizon...
                if(val > events[iEvt].dayFromRef)
                    //...count it. notice insertion sorts by date.
                    namesDefaulting.insert(std::make_pair<unsigned short,
                      unsigned short>(events[iEvt].dayFromRef,
                        events[iEvt].nameIdx));
            }
            if(namesDefaulting.size() >= n) {
                std::map<unsigned short, unsigned short>::const_iterator
                    itdefs = namesDefaulting.begin();
                // locate nth default in time:
                std::advance(itdefs, n-1);
                // update statistic:
                hitsByDate[itdefs->second]++;
            }
        }
        std::transform(hitsByDate.begin(), hitsByDate.end(),
                       hitsByDate.begin(),
                       divide_by<Real>(Real(nSims_)));
        return hitsByDate;
        // \todo Provide confidence interval
    }


    template<template <class, class> class D, class C, class URNG>
    Real RandomLM<D, C, URNG>::defaultCorrelation(const Date& d,
        Size iName, Size jName) const
    {
        // a control variate with the probabilities is possible
        calculate();
        Date today = Settings::instance().evaluationDate();

        QL_REQUIRE(d>today, "Date for statistic must be in the future.");
        // casted to natural to avoid warning, we have just checked the sign
        Natural val = d.serialNumber() - today.serialNumber();

        Real expectedDefiDefj = 0.;// E[1_i 1_j]
        // the rest of magnitudes have known values (probabilities) but that
        //   would distort the simulation results.
        Real expectedDefi = 0.;
        Real expectedDefj = 0.;
        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);
            Real imatch = 0., jmatch = 0.;
            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                if((val > events[iEvt].dayFromRef) &&
                   (events[iEvt].nameIdx == iName)) imatch = 1.;
                if((val > events[iEvt].dayFromRef) &&
                   (events[iEvt].nameIdx == jName)) jmatch = 1.;
            }
            expectedDefiDefj += imatch * jmatch;
            expectedDefi += imatch;
            expectedDefj += jmatch;
        }
        expectedDefiDefj = expectedDefiDefj / (nSims_-1);// unbiased
        expectedDefi = expectedDefi / nSims_;
        expectedDefj = expectedDefj / nSims_;

        return (expectedDefiDefj - expectedDefi*expectedDefj) /
            std::sqrt((expectedDefi*expectedDefj*(1.-expectedDefi)
                *(1.-expectedDefj)));
        // \todo Provide confidence interval
    }


    template<template <class, class> class D, class C, class URNG>
    Real RandomLM<D, C, URNG>::expectedTrancheLoss(
        const Date& d) const {
            return expectedTrancheLossInterval(d, 0.95).first;
    }


    template<template <class, class> class D, class C, class URNG>
    std::pair<Real, Real> RandomLM<D, C, URNG>::expectedTrancheLossInterval(
        const Date& d, Probability confidencePerc) const
    {
        calculate();
        Date today = Settings::instance().evaluationDate();
        Date::serial_type val = d.serialNumber() - today.serialNumber();

        Real attachAmount = basket_->attachmentAmount();
        Real detachAmount = basket_->detachmentAmount();

        // Real trancheLoss= 0.;
        GeneralStatistics lossStats;
        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);

            Real portfSimLoss=0.;
            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                // if event is within time horizon...
                if(val > static_cast<Date::serial_type>(
					   events[iEvt].dayFromRef)) {
                    Size iName = events[iEvt].nameIdx;
                    // ...and is contained in the basket.
                        portfSimLoss +=
                            basket_->exposure(basket_->names()[iName],
                                Date(events[iEvt].dayFromRef +
                                    today.serialNumber())) *
                                        (1.-getEventRecovery(events[iEvt]));
               }
            }
            lossStats.add(// d  ates? current losses? realized defaults, not yet
                std::min(std::max(portfSimLoss - attachAmount, 0.),
                    detachAmount - attachAmount) );
        }
        return std::make_pair(lossStats.mean(), lossStats.errorEstimate() *
            InverseCumulativeNormal::standard_value(0.5*(1.+confidencePerc)));
    }


    template<template <class, class> class D, class C, class URNG>
    Disposable<std::map<Real, Probability> >
        RandomLM<D, C, URNG>::lossDistribution(const Date& d) const {

        Histogram hist = computeHistogram(d);
        std::map<Real, Probability> distrib;

        // prob of losses less or equal to
        Real suma = hist.frequency(0);
        distrib.insert(std::make_pair(0., suma));
        for(Size i=1; i<hist.bins(); i++) {
            suma += hist.frequency(i);
            distrib.insert(std::make_pair( hist.breaks()[i-1], suma ));
        }
        return distrib;
    }


    template<template <class, class> class D, class C, class URNG>
    Histogram RandomLM<D, C, URNG>::computeHistogram(const Date& d) const {
        std::vector<Real> data;
        std::set<Real> keys;// attainable loss values
        keys.insert(0.);
        Date today = Settings::instance().evaluationDate();
        Date::serial_type val = d.serialNumber() - today.serialNumber();
        // redundant test? should have been tested by the basket caller?
        QL_REQUIRE(d >= today,
            "Requested percentile date must lie after computation date.");
        calculate();

        Real attachAmount = basket_->attachmentAmount();
        Real detachAmount = basket_->detachmentAmount();

        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);

            Real portfSimLoss=0.;
            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                if(val > static_cast<Date::serial_type>(
					 events[iEvt].dayFromRef)) {
                    Size iName = events[iEvt].nameIdx;
          // test needed (here and the others) to reuse simulations:
          //          if(basket_->pool()->has(copula_->pool()->names()[iName]))
                        portfSimLoss +=
                            basket_->exposure(basket_->names()[iName],
                                Date(events[iEvt].dayFromRef +
                                    today.serialNumber())) *
                                        (1.-getEventRecovery(events[iEvt]));
                }
            }
            data.push_back(std::min(std::max(portfSimLoss - attachAmount, 0.),
                detachAmount - attachAmount));
            keys.insert(data.back());
        }
        // avoid using as many points as in the simulation.
        Size nPts = std::min<Size>(data.size(), 150);// fix
        return Histogram(data.begin(), data.end(), nPts);
    }


    template<template <class, class> class D, class C, class URNG>
    Real RandomLM<D, C, URNG>::expectedShortfall(const Date& d,
        Real percent) const {

        const Date today = Settings::instance().evaluationDate();
        QL_REQUIRE(d >= today,
            "Requested percentile date must lie after computation date.");
        calculate();

        Real attachAmount = basket_->attachmentAmount();
        Real detachAmount = basket_->detachmentAmount();

        Date::serial_type val = d.serialNumber() - today.serialNumber();
        if(val <= 0) return 0.;// plus basket realized losses

        //GenericRiskStatistics<GeneralStatistics> statsX;
        std::vector<Real> losses;
        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);
            Real portfSimLoss=0.;
            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                if(val > static_cast<Date::serial_type>(
					  events[iEvt].dayFromRef)) {
                    Size iName = events[iEvt].nameIdx;
                    // ...and is contained in the basket.
                    //if(basket_->pool()->has(copula_->pool()->names()[iName]))
                        portfSimLoss +=
                            basket_->exposure(basket_->names()[iName],
                                Date(events[iEvt].dayFromRef +
                                    today.serialNumber())) *
                                        (1.-getEventRecovery(events[iEvt]));
                }
            }
            portfSimLoss = std::min(std::max(portfSimLoss - attachAmount, 0.),
                detachAmount - attachAmount);
            losses.push_back(portfSimLoss);
        }

        std::sort(losses.begin(), losses.end());
        Real posit = std::ceil(percent * nSims_);
        posit = posit >= 0. ? posit : 0.;
        Size position = static_cast<Size>(posit);
        Real perctlInf = losses[position];//q_{\alpha}

        // the prob of values strictly larger than the quantile value.
        Probability probOverQ =
            static_cast<Real>(std::distance(losses.begin() + position,
                losses.end())) / static_cast<Real>(nSims_);

        return ( perctlInf * (1.-percent-probOverQ) +//<-correction term
            std::accumulate(losses.begin() + position, losses.end(), 
			    Real(0.))/nSims_
                )/(1.-percent);

        /* Alternative ESF definition; find the first loss larger than the
        one of the percentile. Notice the choice here, the expected shortfall
        is understood in the sense that we are looking for the average given
        than losses are above a certain value rather than above a certain
        probability:
        (Unlikely to be the algorithm of choice)*/
        /*
        std::vector<Real>::iterator itPastPerc =
            std::find_if(losses.begin() + position, losses.end(),
                         greater_or_equal_to<Real>(perctlInf));
        // notice if the sample is flat at the end this might be zero
        Size pointsOverVal = nSims_ - std::distance(itPastPerc, losses.end());
        return pointsOverVal == 0 ? 0. :
            std::accumulate(itPastPerc, losses.end(), 0.) / pointsOverVal;
        */

        /* For the definition of ESF see for instance: 'Quantitative Risk
        Management' by A.J. McNeil, R.Frey and P.Embrechts, princeton series in
        finance, 2005; equations on page 39 sect 2.12:
        $q_{\alpha}(F) = inf{x \in R : F(x) \le \alpha}$
        and equation 2.25 on p. 45:
        $ESF_{\alpha} = \frac{1}{1-\alpha} [E(L; L \ge q_{\alpha} ) +
            q_{\alpha} (1-\alpha-P(L \ge q_{\alpha})) ]$
        The second term accounts for non continuous distributions.
        */
    }


    template<template <class, class> class D, class C, class URNG>
    Real RandomLM<D, C, URNG>::percentile(const Date& d, Real perc) const {
        // need to specify return type in tuples' get is parametric
        return ext::get<0>(percentileAndInterval(d, perc));
    }


    /* See Appendix-A of "Evaluating value-at-risk methodologies: Accuracy
        versus computational time.", M. Pritsker, Wharton FIC, November 1996
    Strictly speaking this gives the interval with a 95% probability of
    the true value being within the interval; which is different to the error
    of the stimator just computed. See the reference for a discussion.
    */
    template<template <class, class> class D, class C, class URNG>
    ext::tuple<Real, Real, Real> // disposable?
        RandomLM<D, C, URNG>::percentileAndInterval(const Date& d,
            Real percentile) const {

        QL_REQUIRE(percentile >= 0. && percentile <= 1.,
            "Incorrect percentile");
        calculate();

        Real attachAmount = basket_->attachmentAmount();
        Real detachAmount = basket_->detachmentAmount();

        std::vector<Real> rankLosses;
        Date today = Settings::instance().evaluationDate();
        Date::serial_type val = d.serialNumber() - today.serialNumber();
        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);
            Real portfSimLoss=0.;
            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                if(val > static_cast<Date::serial_type>(
					 events[iEvt].dayFromRef)) {
                    Size iName = events[iEvt].nameIdx;
                 //   if(basket_->pool()->has(copula_->pool()->names()[iName]))
                        portfSimLoss +=
                            basket_->exposure(basket_->names()[iName],
                                Date(events[iEvt].dayFromRef +
                                    today.serialNumber())) *
                                        (1.-getEventRecovery(events[iEvt]));
                }
            }
            portfSimLoss = std::min(std::max(portfSimLoss - attachAmount, 0.),
                detachAmount - attachAmount);
            // update dataset for rank stat:
            rankLosses.push_back(portfSimLoss);
        }

        std::sort(rankLosses.begin(), rankLosses.end());
        Size quantilePosition = static_cast<Size>(floor(nSims_*percentile));
        Real quantileValue = rankLosses[quantilePosition];

        // compute confidence interval:
        const Probability confInterval = 0.95;// as an argument?
        Real lowerPercentile, upperPercentile;
        Size r = quantilePosition - 1;
        Size s = quantilePosition + 1;
        bool rLocked = false,
            sLocked = false;
        // Size rfinal = 0,
        //      sfinal = 0;
        for(Size delta=1; delta < quantilePosition; delta++) {
            Real cached =
                incompleteBetaFunction(Real(s), Real(nSims_+1-s),
                                       percentile, 1.e-8, 500);
            Real pMinus =
            /* There was a fix in the repository on the gammadistribution. It
            might impact these, it might be neccesary to multiply these values
            by '-1'*/
                incompleteBetaFunction(Real(r+1), Real(nSims_-r),
                                       percentile, 1.e-8, 500)
                - cached;
            Real pPlus  =
                incompleteBetaFunction(Real(r), Real(nSims_-r+1),
                                       percentile, 1.e-8, 500)
                - cached;
            if((pMinus > confInterval) && !rLocked ) {
                // rfinal = r + 1;
               rLocked = true;
            }
            if((pPlus >= confInterval) && !sLocked) {
                // sfinal = s;
                sLocked = true;
            }
            if(rLocked && sLocked) break;
            r--;
            s++;
            s = std::min(nSims_-1, s);
        }
        lowerPercentile = rankLosses[r];
        upperPercentile = rankLosses[s];

        return {quantileValue, lowerPercentile, upperPercentile};
    }


    template<template <class, class> class D, class C, class URNG>
    Disposable<std::vector<Real> > RandomLM<D, C, URNG>::splitVaRLevel(
        const Date& date, Real loss) const
    {
        std::vector<Real> varLevels = splitVaRAndError(date, loss, 0.95)[0];
        // turn relative units into absolute:
        std::transform(varLevels.begin(), varLevels.end(), varLevels.begin(),
                       multiply_by<Real>(loss));
        return varLevels;
    }


    // parallelize this one(if possible), it is really expensive
    template<template <class, class> class D, class C, class URNG>
    /* FIX ME: some trouble on limit cases, like zero loss or no losses over the
    requested level.*/
    Disposable<std::vector<std::vector<Real> > >
        RandomLM<D, C, URNG>::splitVaRAndError(const Date& date, Real loss,
            Probability confInterval) const
    {
        /* Check 'loss' value integrity: i.e. is within tranche limits? (should
            have been done basket...)*/
        calculate();

        Real attachAmount = basket_->attachmentAmount();
        Real detachAmount = basket_->detachmentAmount();
        Size numLiveNames = basket_->remainingSize();

        std::vector<Real> split(numLiveNames, 0.);
        std::vector<GeneralStatistics> splitStats(numLiveNames,
            GeneralStatistics());
        Date today = Settings::instance().evaluationDate();
        Date::serial_type val = date.serialNumber() - today.serialNumber();

        for(Size iSim=0; iSim < nSims_; iSim++) {
            const std::vector<simEvent<D<C, URNG> > >& events = getSim(iSim);
            Real portfSimLoss=0.;
            //std::vector<Real> splitBuffer(numLiveNames_, 0.);
            std::vector<simEvent<D<C, URNG> > > splitEventsBuffer;

            for(Size iEvt=0; iEvt < events.size(); iEvt++) {
                if(val > static_cast<Date::serial_type>(
					 events[iEvt].dayFromRef)) {
                    Size iName = events[iEvt].nameIdx;
                // if(basket_->pool()->has(copula_->pool()->names()[iName])) {
                        portfSimLoss +=
                            basket_->exposure(basket_->names()[iName],
                                Date(events[iEvt].dayFromRef +
                                    today.serialNumber())) *
                                        (1.-getEventRecovery(events[iEvt]));
                        //and will sort later if buffer applies:
                        splitEventsBuffer.push_back(events[iEvt]);
                }
            }
            portfSimLoss = std::min(std::max(portfSimLoss - attachAmount, 0.),
                detachAmount - attachAmount);

            /* second pass; split is conditional to total losses within target
            losses/percentile:  */
            Real ptflCumulLoss = 0.;
            if(portfSimLoss > loss) {
                std::sort(splitEventsBuffer.begin(), splitEventsBuffer.end());
                //NOW THIS:
                split.assign(numLiveNames, 0.);
                /*  if the name triggered a loss in the portf limits assign
                this loss to that name..  */
                for(Size i=0; i<splitEventsBuffer.size(); i++) {
                    Size iName = splitEventsBuffer[i].nameIdx;
                    Real lossName =
            // allows amortizing (others should be like this)
            // basket_->remainingNotionals(Date(simsBuffer_[i].dayFromRef +
            //      today.serialNumber()))[iName] *
                        basket_->exposure(basket_->names()[iName],
                            Date(splitEventsBuffer[i].dayFromRef +
                                today.serialNumber())) *
                                (1.-getEventRecovery(splitEventsBuffer[i]));

                    Real tranchedLossBefore =
                        std::min(std::max(ptflCumulLoss - attachAmount, 0.),
                        detachAmount - attachAmount);
                    ptflCumulLoss += lossName;
                    Real tranchedLossAfter =
                        std::min(std::max(ptflCumulLoss - attachAmount, 0.),
                        detachAmount - attachAmount);
                    // assign new losses:
                    split[iName] += tranchedLossAfter - tranchedLossBefore;
                }
                for(Size iName=0; iName<numLiveNames; iName++) {
                    splitStats[iName].add(split[iName] /
                        std::min(std::max(ptflCumulLoss - attachAmount, 0.),
                            detachAmount - attachAmount) );
                }
            }
        }

        // Compute error in VaR split
        std::vector<Real> means, rangeUp, rangeDown;
        Real confidFactor = InverseCumulativeNormal()(0.5+confInterval/2.);
        for(Size iName=0; iName<numLiveNames; iName++) {
            means.push_back(splitStats[iName].mean());
            Real error = confidFactor * splitStats[iName].errorEstimate() ;
            rangeDown.push_back(means.back() - error);
            rangeUp.push_back(means.back() + error);
        }

        std::vector<std::vector<Real> > results;
        results.push_back(means);
        results.push_back(rangeDown);
        results.push_back(rangeUp);

        return results;
    }




    // --------- Time inversion solver target function: -----------------------

    /* It could be argued that this concept is part of the copula (more generic)
    In general when the modelled magnitude is parametric one can solve for
    inversion to get the parameter value for a given magnitude value (provided
    the modelled variable dependence in invertible). In this particular problem
    the parameter is Time and it is solved here where we are alredy in the
    context of default
    See default transition models for another instance of this inversion.
    Alternatively use the faster trick (flat HR) mentioned in the code or make
    the algorithm parametric on the type of interpolation in the default TS.
    */
    namespace detail {// not template dependent .....move it
        //! Utility for the numerical time solver
        class Root {
          public:
            /* See a faster algorithm (neeeds to locate the points) in
            D.O'KANE p.249 sect 13.5 */
            Root(const Handle<DefaultProbabilityTermStructure>& dts, Real pd)
            : dts_(dts), pd_(pd), curveRef_(dts->referenceDate()) {}
            /* The cast I am forcing here comes from the requirement of 1D
            solvers to take in a target (cost) function of Real domain. It could
            be possible to change the template arg F in the 1D solvers to a
            boost function and then use the (template arg) domain argument type
            of the function for use with the 'guess' and operator() ?
             */
            Real operator()(Real t) const {
                QL_REQUIRE (t >= 0.0, "t < 0");
                /* As long as this doesnt involve modifying a mutable member
                it should be thread safe (they are const methods and access is
                read only)
                */
                return dts_->defaultProbability(curveRef_ +
                    Period(static_cast<Integer>(t), Days), true) - pd_;
            }
          private:
            const Handle<DefaultProbabilityTermStructure> dts_;
            Real pd_;
            const Date curveRef_;
        };
    }

    /*
    ---------------------------------------------------------------------------
    ---------------------------------------------------------------------------
    */

    // move this one to a separte file?
    /*! Random default with deterministic recovery event type.\par
    Stores sims results in a bitfield buffer for lean memory storage.
    Although strictly speaking this is not guaranteed by the compiler it
    amounts to reducing the memory storage by half.
    Some computations, like conditional statistics, precise that all sims
    results be available.
    */
    template<class , class > class RandomDefaultLM;
    template<class copulaPolicy, class USNG>
    struct simEvent<RandomDefaultLM<copulaPolicy, USNG> > {
        simEvent(unsigned int n, unsigned int d)
        : nameIdx(n), dayFromRef(d){}
        unsigned int nameIdx : 16; // can index up to 65535 names
        unsigned int dayFromRef : 16; //indexes up to 65535 days ~179 years
        bool operator<(const simEvent& evt) const {
            return dayFromRef < evt.dayFromRef;
        }
    };

    /*! Default only latent model simulation with trivially fixed recovery
        amounts.
    */
    template<class copulaPolicy, class USNG = SobolRsg>
    class RandomDefaultLM : public RandomLM<RandomDefaultLM, copulaPolicy, USNG>
    {
    private:
        typedef simEvent<RandomDefaultLM> defaultSimEvent;

        // \todo Consider this to be only a ConstantLossLM instead
        const ext::shared_ptr<DefaultLatentModel<copulaPolicy> > model_;
        const std::vector<Real> recoveries_;
        // for time inversion:
        Real accuracy_;
    public:
        // \todo: Allow a constructor building its own default latent model.
      explicit RandomDefaultLM(const ext::shared_ptr<DefaultLatentModel<copulaPolicy> >& model,
                               const std::vector<Real>& recoveries = std::vector<Real>(),
                               Size nSims = 0, // stats will crash on div by zero, FIX ME.
                               Real accuracy = 1.e-6,
                               BigNatural seed = 2863311530UL)
      : RandomLM< ::QuantLib::RandomDefaultLM, copulaPolicy, USNG>(
            model->numFactors(), model->size(), model->copula(), nSims, seed),
        model_(model),
        recoveries_(recoveries.empty() ? std::vector<Real>(model->size(), 0.) : recoveries),
        accuracy_(accuracy) {
          // redundant through basket?
          this->registerWith(Settings::instance().evaluationDate());
          this->registerWith(model_);
        }
        explicit RandomDefaultLM(
            const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> >& model,
            Size nSims = 0,// stats will crash on div by zero, FIX ME.
            Real accuracy = 1.e-6,
            BigNatural seed = 2863311530UL)
        : RandomLM< ::QuantLib::RandomDefaultLM, copulaPolicy, USNG>
            (model->numFactors(), model->size(), model->copula(),
                nSims, seed ),
          model_(model),
          recoveries_(model->recoveries()),
          accuracy_(accuracy)
        {
            // redundant through basket?
            this->registerWith(Settings::instance().evaluationDate());
            this->registerWith(model_);
        }

        // grant access to static polymorphism:
        /* While this works on g++, VC9 refuses to compile it.
        Not completely sure whos right; individually making friends of the
        calling members or writting explicitly the derived class T parameters
        throws the same errors.
        The access is then open to the member fucntions.
        Another solution is to use this http://accu.org/index.php/journals/296

        It might well be that gcc is allowing some c11 features silently, which
        wont pass on a lower gcc version.
        */
        friend class RandomLM< ::QuantLib::RandomDefaultLM, copulaPolicy, USNG>;
    protected:
        void nextSample(const std::vector<Real>& values) const;
        void initDates() const {
            /* Precalculate horizon time default probabilities (used to
              determine if the default took place and subsequently compute its
              event time)
            */
            Date today = Settings::instance().evaluationDate();
            Date maxHorizonDate = today  + Period(this->maxHorizon_, Days);

            const ext::shared_ptr<Pool>& pool = this->basket_->pool();
            for(Size iName=0; iName < this->basket_->size(); ++iName)//use'live'
                horizonDefaultPs_.push_back(pool->get(pool->names()[iName]).
                    defaultProbability(this->basket_->defaultKeys()[iName])
                        ->defaultProbability(maxHorizonDate, true));
        }
        Real getEventRecovery(const defaultSimEvent& evt) const {
            return recoveries_[evt.nameIdx];
        }
        Real expectedRecovery(const Date&, Size iName, const DefaultProbKey&) const override {
            // deterministic
            return recoveries_[iName];
        }

        Real latentVarValue(const std::vector<Real>& factorsSample,
            Size iVar) const {
            return model_->latentVarValue(factorsSample, iVar);
        }
        //allows statistics to know the portfolio size (could be moved to parent
        //invoking duck typing on the variable name or a handle to the basket)
        Size basketSize() const { return model_->size(); }
    private:
      void resetModel() override /*const*/ {
          /* Explore: might save recalculation if the basket is the same
          (some situations, like BC or control variates) in that case do not
          update, only reset the model's basket.
          */
          model_->resetBasket(this->basket_.currentLink());

          QL_REQUIRE(this->basket_->size() == model_->size(),
                     "Incompatible basket and model sizes.");
          QL_REQUIRE(recoveries_.size() == this->basket_->size(),
                     "Incompatible basket and recovery sizes.");
          // invalidate current calculations if any and notify observers
          // NOLINTNEXTLINE(bugprone-parent-virtual-call)
          LazyObject::update();
      }
        // This one and the buffer might be moved to the parent, only some
        //   dates might be specific to a particular model.
        // Default probabilities for each name at the time of the maximun
        //   horizon date. Cached for perf.
        mutable std::vector<Probability> horizonDefaultPs_;
    };





    template<class C, class URNG>
    void RandomDefaultLM<C, URNG>::nextSample(
        const std::vector<Real>& values) const
    {
        const ext::shared_ptr<Pool>& pool = this->basket_->pool();
        // starts with no events
        this->simsBuffer_.push_back(std::vector<defaultSimEvent> ());

        for(Size iName=0; iName<model_->size(); iName++) {
            Real latentVarSample =
                model_->latentVarValue(values, iName);
            Probability simDefaultProb =
               model_->cumulativeY(latentVarSample, iName);
            // If the default simulated lies before the max date:
            if (horizonDefaultPs_[iName] >= simDefaultProb) {
                const Handle<DefaultProbabilityTermStructure>& dfts =
                    pool->get(pool->names()[iName]).// use 'live' names
                    defaultProbability(this->basket_->defaultKeys()[iName]);
                // compute and store default time with respect to the
                //  curve ref date:
                Size dateSTride =
                    static_cast<Size>(Brent().solve(// casted from Real:
                        detail::Root(dfts, simDefaultProb),
                            accuracy_,0.,1.));
                   /*
                   // value if one approximates to a flat HR;
                   //   faster (>x2) but it introduces an error:..
                   // \todo: see how to include this 'polymorphically'.
                   // While not the case in pricing in risk metrics/real
                   //   probabilities the curves are often flat
                    static_cast<Size>(ceil(maxHorizon_ *
                                        std::log(1.-simDefaultProb)
                    /std::log(1.-data_.horizonDefaultPs_[iName])));
                   */
                this->simsBuffer_.back().push_back(defaultSimEvent(iName,
                    dateSTride));
               //emplace_back
            }
        /* Used to remove sims with no events. Uses less memory, faster
        post-statistics. But only if all names in the portfolio have low
        default probability, otherwise is more expensive and sim access has
        to be modified. However low probability is also an indicator that
        variance reduction is needed. */
        }
    }




    // Common usage typedefs (notice they vary in the multithread version)
    // ---------- Gaussian default generators options ------------------------
    /* Uses copula direct normal inversion and MT generator
    typedef RandomDefaultLM<GaussianCopulaPolicy,
        RandomSequenceGenerator<MersenneTwisterUniformRng> >
            GaussianRandomDefaultLM;
    */
    /* Uses BoxMuller for gaussian generation, bypassing copula inversions
    typedef RandomDefaultLM<GaussianCopulaPolicy, RandomSequenceGenerator<
        BoxMullerGaussianRng<MersenneTwisterUniformRng> > >
            GaussianRandomDefaultLM;
    */
    /* Default case, uses the copula inversion directly and sobol sequence */
    typedef RandomDefaultLM<GaussianCopulaPolicy> GaussianRandomDefaultLM;

    // ---------- T default generators options ----------------------------
    /* Uses copula inversion and MT base generation
    typedef RandomDefaultLM<TCopulaPolicy,
      RandomSequenceGenerator<MersenneTwisterUniformRng> > TRandomDefaultLM;
    */
    /* Uses MT and polar direct strudent-T generation
    typedef RandomDefaultLM<TCopulaPolicy,
        RandomSequenceGenerator<PolarStudentTRng<MersenneTwisterUniformRng> > >
            TRandomDefaultLM;
    */
    /* Default case, uses sobol sequence and copula inversion */
    typedef RandomDefaultLM<TCopulaPolicy> TRandomDefaultLM;

}

#endif
]]></document_content>
  </document>
  <document index="206">
    <source>credit/randomdefaultmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/randomdefaultmodel.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    namespace {

        // Utility for the numerical solver
        class Root {
          public:
            Root(Handle<DefaultProbabilityTermStructure> dts, Real pd)
            : dts_(std::move(dts)), pd_(pd) {}
            Real operator()(Real t) const {
                QL_REQUIRE (t >= 0.0, "t < 0");
                return dts_->defaultProbability(t, true) - pd_;
            }
          private:
            const Handle<DefaultProbabilityTermStructure> dts_;
            Real pd_;
        };

    }

    GaussianRandomDefaultModel::GaussianRandomDefaultModel(
        const ext::shared_ptr<Pool>& pool,
        const std::vector<DefaultProbKey>& defaultKeys,
        const Handle<OneFactorCopula>& copula,
        Real accuracy,
        long seed)
    : RandomDefaultModel(pool, defaultKeys), copula_(copula), accuracy_(accuracy), seed_(seed),
      rsg_(PseudoRandom::make_sequence_generator(pool->size() + 1, seed)) {
        registerWith(copula);
    }

    void GaussianRandomDefaultModel::reset() {
        Size dim = pool_->size() + 1;
        rsg_ = PseudoRandom::make_sequence_generator(dim, seed_);
    }

    void GaussianRandomDefaultModel::nextSequence(Real tmax) {
        const std::vector<Real>& values = rsg_.nextSequence().value;
        Real a = sqrt(copula_->correlation());
        for (Size j = 0; j < pool_->size(); j++) {
            const string name = pool_->names()[j];
            const Handle<DefaultProbabilityTermStructure>&
                dts = pool_->get(name).defaultProbability(defaultKeys_[j]);

            Real y = a * values[0] + sqrt(1-a*a) * values[j+1];
            Real p = CumulativeNormalDistribution()(y);

            if (dts->defaultProbability(tmax) < p)
                pool_->setTime(name, tmax+1);
            else
                pool_->setTime(name, Brent().solve(Root(dts,p),accuracy_,0,1));
        }
    }

}

]]></document_content>
  </document>
  <document index="207">
    <source>credit/randomdefaultmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file randomdefaultmodel.hpp
    \brief Random default-time scenarios for a pool of credit names
*/

#ifndef quantlib_random_default_model_hpp
#define quantlib_random_default_model_hpp

#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/experimental/credit/pool.hpp>
#include <ql/experimental/credit/onefactorcopula.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>

namespace QuantLib {

    //! Base class for random default models
    /*! Provides sequences of random default times for each name in the pool. */
    class RandomDefaultModel : public Observer, public Observable {
    public:
      RandomDefaultModel(const ext::shared_ptr<Pool>& pool,
                         const std::vector<DefaultProbKey>& defaultKeys)
      : pool_(pool), defaultKeys_(defaultKeys) {
          // assuming none defaulted this is true.
          QL_REQUIRE(defaultKeys.size() == pool->size(), "Incompatible pool and keys sizes.");
        }
        ~RandomDefaultModel() override = default;
        void update() override { notifyObservers(); }
        /*!
          Generate a sequence of random default times, one for each name in the
          pool, and store the result in the Pool using method setTime(name).
          tmax denotes the maximum relevant time- default times > tmax are not
          computed but set to tmax + 1 instead to save coputation time.
         */
        virtual void nextSequence(Real tmax = QL_MAX_REAL) = 0;
        virtual void reset() = 0;
    protected:
        ext::shared_ptr<Pool> pool_;
        std::vector<DefaultProbKey> defaultKeys_;
    };

    /*!
      Random default times using a one-factor Gaussian copula.
    */
    class GaussianRandomDefaultModel : public RandomDefaultModel {
    public:
      GaussianRandomDefaultModel(const ext::shared_ptr<Pool>& pool,
                                 const std::vector<DefaultProbKey>& defaultKeys,
                                 const Handle<OneFactorCopula>& copula,
                                 Real accuracy,
                                 long seed);
      void nextSequence(Real tmax = QL_MAX_REAL) override;
      void reset() override;

    private:
        Handle<OneFactorCopula> copula_;
        Real accuracy_;
        long seed_;
        PseudoRandom::rsg_type rsg_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="208">
    <source>credit/randomlosslatentmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
#ifndef quantlib_randomloss_latent_model_hpp
#define quantlib_randomloss_latent_model_hpp

#include <ql/experimental/credit/basket.hpp>
#include <ql/experimental/credit/randomdefaultlatentmodel.hpp>
#include <ql/experimental/credit/spotlosslatentmodel.hpp> 
#include <ql/experimental/math/gaussiancopulapolicy.hpp>
#include <ql/experimental/math/latentmodel.hpp>
#include <ql/experimental/math/tcopulapolicy.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <cmath>

namespace QuantLib {


    template<class , class > class RandomLossLM;
    template<class copulaPolicy, class USNG>
        struct simEvent<RandomLossLM<copulaPolicy, USNG> > {
            simEvent(unsigned int n, unsigned int d, Real r) 
            : nameIdx(n), dayFromRef(d), 
                // truncates the value:
              compactRR(std::lround(r/rrGranular)) {}
            unsigned int nameIdx : 12; // can index up to 4095 names
            unsigned int dayFromRef : 12; // can index up to 4095 days = 11 yrs
        private:
            unsigned int compactRR : 8;
        public:
            // ..............still one bit left
            bool operator<(const simEvent& evt) const {
                return dayFromRef < evt.dayFromRef; 
            }
            Real recovery() const {
                /* we pay the price of this product (plus the division at 
                construction) for the memory we save. Precission is lost though,
                e.g. figures from 0.0 to 0.00390625/2. are stored as 0.0
                */
                return rrGranular * compactRR;
            }
            static const Real rrGranular;// = 1./256.;// 2^8
    };

#ifndef __DOXYGEN__

    template <class C, class G> const Real 
        simEvent<RandomLossLM<C, G> >::rrGranular = 1./256.;// 2^8

#endif

    /*! Random spot recovery rate loss model simulation for an arbitrary copula.
    */
    template<class copulaPolicy, class USNG = SobolRsg>
    class RandomLossLM : public RandomLM<RandomLossLM, copulaPolicy, USNG>
    {
    private:
        typedef simEvent<RandomLossLM> defaultSimEvent;

        const ext::shared_ptr<SpotRecoveryLatentModel<copulaPolicy> > copula_;
        // for time inversion:
        Real accuracy_;
    public:
        explicit RandomLossLM(
            const ext::shared_ptr<SpotRecoveryLatentModel<copulaPolicy> >& 
                copula,
            Size nSims = 0,
            Real accuracy = 1.e-6, 
            BigNatural seed = 2863311530UL)
        : RandomLM< ::QuantLib::RandomLossLM, copulaPolicy, USNG>
            (copula->numFactors(), copula->size(), copula->copula(), 
                nSims, seed),
          copula_(copula), accuracy_(accuracy)
    {
        // redundant through basket?
        this->registerWith(Settings::instance().evaluationDate());
    }

        // grant access to static polymorphism:
        /* While this works on g++, VC9 refuses to compile it.
        Not completely sure whos right; individually making friends of the 
        calling members or writting explicitly the derived class T parameters 
        throws the same errors.
        The access is then open to the member fucntions.
        */
        friend class RandomLM< ::QuantLib::RandomLossLM, copulaPolicy, USNG>;
    protected:
        void nextSample(const std::vector<Real>& values) const;

        // see note on randomdefaultlatentmodel
        void initDates() const {
            /* Precalculate horizon time default probabilities (used to 
              determine if the default took place and subsequently compute its 
              event time)
            */
            Date today = Settings::instance().evaluationDate();
            Date maxHorizonDate = today  + Period(this->maxHorizon_, Days);

            const ext::shared_ptr<Pool>& pool = this->basket_->pool();
            for(Size iName=0; iName < this->basket_->size(); ++iName)//use'live'
                horizonDefaultPs_.push_back(pool->get(pool->names()[iName]).
                    defaultProbability(this->basket_->defaultKeys()[iName])
                        ->defaultProbability(maxHorizonDate, true));
        }
       Real getEventRecovery(const defaultSimEvent& evt) const {
            return evt.recovery();
        }

        Real latentVarValue(const std::vector<Real>& factorsSample, 
            Size iVar) const {
                return copula_->latentVarValue(factorsSample, iVar);
        }
        Size basketSize() const { return this->basket_->size(); }
        // conditional to default, defined as spot-recovery.
        Real conditionalRecovery(Real latentVarSample, Size iName, 
            const Date& d) const;
    private:
      void resetModel() override {
          /* Explore: might save recalculation if the basket is the same
          (some situations, like BC or control variates) in that case do not
          update, only reset the copula's basket.
          */
          copula_->resetBasket(this->basket_.currentLink());

          QL_REQUIRE(2 * this->basket_->size() == copula_->size(),
                     "Incompatible basket and model sizes.");
          // invalidate current calculations if any and notify observers
          // NOLINTNEXTLINE(bugprone-parent-virtual-call)
          LazyObject::update();
      }
        // Default probabilities for each name at the time of the maximun 
        //   horizon date. Cached for perf.
        mutable std::vector<Probability> horizonDefaultPs_;
    };


    // --------------------------------------------------------------


    template<class C, class URNG>
    void RandomLossLM<C, URNG>::nextSample(
        const std::vector<Real>& values) const 
    {
        const ext::shared_ptr<Pool>& pool = this->basket_->pool();
        this->simsBuffer_.push_back(std::vector<defaultSimEvent> ());

        // half the model is defaults, the other half are RRs...
        for(Size iName=0; iName<copula_->size()/2; iName++) {
            // ...but samples must be full
            /* This is really a trick, we are passing a longer than
            expected set of values in the sample but the last idiosyncratic
            values corresponding to the RR are not used. They are used below
            only if we are in default. This works due to the way the SpotLossLM
            is split in two almost disjoint latent models and that theres no
            check on the vector size in the LM base class.
            */
            Real latentVarSample = 
                copula_->latentVarValue(values, iName);
            Probability simDefaultProb = 
                copula_->cumulativeY(latentVarSample, iName);
            // If the default simulated lies before the max date:
            if (horizonDefaultPs_[iName] >= simDefaultProb) {
                const Handle<DefaultProbabilityTermStructure>& dfts = 
                    pool->get(pool->names()[iName]).  // use 'live' names
                    defaultProbability(this->basket_->defaultKeys()[iName]);
                // compute and store default time with respect to the 
                //  curve ref date:
                Size dateSTride =
                    static_cast<Size>(Brent().solve(// casted from Real:
                    detail::Root(dfts, simDefaultProb), accuracy_, 0., 1.));
                /*
                // value if one approximates to a flat HR; 
                //   faster (>x2) but it introduces an error:..
                // \todo: see how to include this 'polymorphically'. While
                //   not the case in pricing in risk metrics/real  
                //   probabilities the curves are often flat
                static_cast<Size>(ceil(maxHorizon_ * 
                                    std::log(1.-simDefaultProb)
                /std::log(1.-data_.horizonDefaultPs_[iName])));
                */
                // Determine the realized recovery rate:
                /* For this; 'conditionalRecovery' needs to compute the pdef on 
                the realized def event date from the simulation. Yet, this might
                have fallen between todays date and the default TS reference 
                date(usually a two day gap) To avoid requesting a negative time
                probability the date is moved to the TS date 
                Unless the gap is ridiculous this has no practical effect for 
                the RR value*/
                Date today = Settings::instance().evaluationDate();
                Date eventDate = today+Period(static_cast<Integer>(dateSTride), 
                    Days);
                if(eventDate<dfts->referenceDate()) 
                    eventDate = dfts->referenceDate();
                Real latentRRVarSample = 
                    copula_->latentRRVarValue(values, iName);
                Real recovery = 
                    copula_->conditionalRecovery(latentRRVarSample,
                        iName, eventDate);
                this->simsBuffer_.back().push_back(
                  defaultSimEvent(iName, dateSTride, recovery));
                //emplace_back
            }
        /* Used to remove sims with no events. Uses less memory, faster 
        post-statistics. But only if all names in the portfolio have low 
        default probability, otherwise is more expensive and sim access has 
        to be modified. However low probability is also an indicator that 
        variance reduction is needed. */
        //if(simsBuffer.back().empty()) {
        //    emptySims_++;// Size; intilzd to zero
        //    simsBuffer.pop_back();
        //}
        }
    }


    // Common uses: Not valid in multithread version.
    // ---------- Gaussian default generators options ------------------------
    /* Uses copula direct normal inversion and MT generator 
    typedef RandomLossLM<GaussianCopulaPolicy,
        RandomSequenceGenerator<MersenneTwisterUniformRng> >
            GaussianRandomLossLM;
    */
    /* Uses BoxMuller for gaussian generation, bypassing copula inversions
    typedef RandomLossLM<GaussianCopulaPolicy, RandomSequenceGenerator<
        BoxMullerGaussianRng<MersenneTwisterUniformRng> > >
            GaussianRandomLossLM;
    */
    /* Default case, uses the copula inversion directly and sobol sequence */
    typedef RandomLossLM<GaussianCopulaPolicy> GaussianRandomLossLM;

    // ---------- T default generators options ----------------------------
    /*
    typedef RandomLossLM<TCopulaPolicy, 
      RandomSequenceGenerator<MersenneTwisterUniformRng> > TRandomLossLM;
    */
    /*
    typedef RandomLossLM<TCopulaPolicy, 
        RandomSequenceGenerator<PolarStudentTRng<MersenneTwisterUniformRng> > >
            TRandomLossLM;
    */
    typedef RandomLossLM<TCopulaPolicy> TRandomLossLM;

}

#endif
]]></document_content>
  </document>
  <document index="209">
    <source>credit/recoveryratemodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/recoveryratemodel.hpp>

namespace QuantLib {

    ConstantRecoveryModel::ConstantRecoveryModel(
                                       const Handle<RecoveryRateQuote>& quote)
    : quote_(quote) {
        registerWith(quote);
    }

    ConstantRecoveryModel::ConstantRecoveryModel(Real recovery,
                                                 Seniority sen)
    : quote_(Handle<RecoveryRateQuote>(ext::make_shared<RecoveryRateQuote>(
                                    recovery, sen))) {}

}
]]></document_content>
  </document>
  <document index="210">
    <source>credit/recoveryratemodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_recovery_rate_model_hpp
#define quantlib_recovery_rate_model_hpp

#include <ql/settings.hpp>
#include <ql/handle.hpp>
#include <ql/experimental/credit/defaultprobabilitykey.hpp>
#include <ql/experimental/credit/recoveryratequote.hpp>

namespace QuantLib {

    /*! Models of the recovery rate provide future values of a recovery
        rate in the event of a default.
    */
    class RecoveryRateModel : public virtual Observable {
      public:
        /*! returns the expected recovery rate at a future time conditional
            on some default event type and seniority.
        */
        virtual Real recoveryValue(const Date& defaultDate,
            const DefaultProbKey& defaultKey = DefaultProbKey()) const {
            // no check on dates...
            return recoveryValueImpl(defaultDate, defaultKey);
        }
        /*! Returns true if the model will return recovery rates for
            the requested seniority.
        */
        virtual bool appliesToSeniority(Seniority) const = 0;
        ~RecoveryRateModel() override = default;

      protected:
        /*! Returns Null<Real> if unable to produce a recovery for
            the requested seniority.
        */
        virtual Real recoveryValueImpl(const Date&,
                                       const DefaultProbKey& defaultKey
                                       ) const = 0;
    };


    /*! Simple Recovery Rate model returning the constant value of the quote
        independently of the date and the seniority.
    */
    class ConstantRecoveryModel : public RecoveryRateModel,
                                  public Observer {
      public:
        explicit ConstantRecoveryModel(const Handle<RecoveryRateQuote>& quote);
        explicit ConstantRecoveryModel(Real recovery,
                                       Seniority sen = NoSeniority);
        void update() override { notifyObservers(); }
        bool appliesToSeniority(Seniority) const override { return true; }

      protected:
        /*! Notice the quote's value is returned without a
            check on a match of the seniorties of the
            quote and the request.
        */
        Real recoveryValueImpl(const Date&, const DefaultProbKey&) const override {
            // no match on requested seniority, all pass
            return quote_->value();
        }

      private:
        Handle<RecoveryRateQuote> quote_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="211">
    <source>credit/recoveryratequote.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/recoveryratequote.hpp>

namespace QuantLib {

    const Real RecoveryRateQuote::IsdaConvRecoveries[] =  {
        0.65,// SECDOM
        0.4, // SNRFOR
        0.2, // SUBLT2
        0.2, // JRSUBUT2
        0.15 // PREFT1
    };

    std::map<Seniority, Real> makeIsdaConvMap() {
        return RecoveryRateQuote::makeIsdaMap(
            RecoveryRateQuote::IsdaConvRecoveries);
    }

    RecoveryRateQuote::RecoveryRateQuote(Real value,
                                         Seniority seniority)
        : seniority_(seniority), recoveryRate_(value) {
            QL_REQUIRE(value == Null<Real>() ||
                (value >= 0. && value <= 1.),
                "Recovery value must be a fractional unit.");
    }

    Real RecoveryRateQuote::setValue(Real value) {
        Real diff = value-recoveryRate_;
        if (diff != 0.0) {
            recoveryRate_ = value;
            notifyObservers();
        }
        return diff;
    }

    void RecoveryRateQuote::reset() {
        setValue(Null<Real>());
        seniority_ = NoSeniority;
    }

}
]]></document_content>
  </document>
  <document index="212">
    <source>credit/recoveryratequote.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_recoveryrate_quote_hpp
#define quantlib_recoveryrate_quote_hpp

#include <ql/quote.hpp>
#include <ql/experimental/credit/defaulttype.hpp>
#include <map>

namespace QuantLib {

    //! Stores a recovery rate market quote and the associated seniority.
    class RecoveryRateQuote : public Quote {
        friend std::map<Seniority, Real> makeIsdaConvMap();
    public:
        /*! Returns a map with the ISDA conventional (values by
            default) of the recovery rate per each ISDA seniority.
        */
        static Real conventionalRecovery(Seniority sen) {
            return IsdaConvRecoveries[sen];
        }
        RecoveryRateQuote(Real value = Null<Real>(),
                          Seniority seniority = NoSeniority);
        //! \name Quote interface
        //@{
        Real value() const override;
        Seniority seniority() const;
        bool isValid() const override;
        //@}
        //! \name Modifiers
        //@{
        //! returns the difference between the new value and the old value
        Real setValue(Real value = Null<Real>());
        void reset();
        //@}

        /*! Turn a set of recoveries into a seniority-recovery map
            (intended to be used in an event construction)
        */
        // member? move to friend?
        template <Size N>
        static std::map<Seniority, Real> makeIsdaMap(const Real (&(arrayIsdaRR))[N]);

      private:
        // Conventional recoveries for ISDA seniorities
        static const Real IsdaConvRecoveries[];
        // The seniority this recovery is quoted for.
        Seniority seniority_;
        // The recovery value. In fractional units.
        Real recoveryRate_;
    };

    inline Seniority RecoveryRateQuote::seniority() const {
        return seniority_;
    }

    inline Real RecoveryRateQuote::value() const {
        QL_ENSURE(isValid(), "invalid Recovery Quote");
        return recoveryRate_;
    }

    inline bool RecoveryRateQuote::isValid() const {
        // not to be consufed with proper initialization [0-1]
        return recoveryRate_!=Null<Real>();/* &&
            seniority_ != NoSeniority;*/
    }

    //! Helper function for conventional recoveries. Returns the ISDA
    //    conventional recovery rates for the ISDA seniorities.
    std::map<Seniority, Real> makeIsdaConvMap();


    // template definitions

    // helpers allow further automatic inclusion of seniorities
    template <Size N>
    std::map<Seniority, Real> RecoveryRateQuote::makeIsdaMap(const Real (&(arrayIsdaRR))[N]) {
        // TO DO: include check on sizes... not to go beyond enum sizes.
        // TO DO: check Reals are valid, i.e. non Null and within [0-1] range
        std::map<Seniority, Real> isdaMap;
        for(Size i=0; i<N; i++) {
            auto isdaType = Seniority(i); // compiler dependent?
            isdaMap[isdaType] = arrayIsdaRR[i];
        }
        return isdaMap;
    }
}

#endif
]]></document_content>
  </document>
  <document index="213">
    <source>credit/recursivelossmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_recursive_loss_model_hpp
#define quantlib_recursive_loss_model_hpp

#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/defaultlossmodel.hpp>
#include <map>
#include <algorithm>

namespace QuantLib {

    /*! Recursive STCDO default loss model for a heterogeneous pool of names. 
    The pool names are heterogeneous in their default probabilities, notionals
    and recovery rates. Correlations are given by the latent model.
    The recursive pricing algorithm used here is described in Andersen, Sidenius
    and Basu; "All your hedges in one basket", Risk, November 2003, pages 67-72

        Notice that using copulas other than Gaussian it is only an
        approximation (see remark on p.68).

        \todo Make the loss unit equal to some small fraction depending on the
        portfolio loss weights (notionals and recoveries). As it is now this
        is ok for pricing but not for risk metrics. See the discussion in O'Kane
        18.3.2
        \todo Intengrands should all use the inverted probabilities for 
        performance instead of calling the copula inversion with the same vals.
    */
    template<class copulaPolicy> 
    class RecursiveLossModel : public DefaultLossModel {
    public:
      explicit RecursiveLossModel(
          const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> >& m,
          // nope! use max common divisor. See O'Kane. Or give both options at least.
          Size nbuckets = 1)
      : copula_(m), nBuckets_(nbuckets) {}

    private:
      /*!
      @param pDefDate Vector of unconditional default probabilities for each
      live name (at the current evaluation date). This is passed instead of
      the date for performance reasons (if in the future other magnitudes
      -e.g. lgd- are contingent on the date they shouldd be passed too).
      */
      Disposable<std::map<Real, Probability> >
      conditionalLossDistrib(const std::vector<Probability>& pDefDate,
                             const std::vector<Real>& mktFactor) const;
      Real expectedConditionalLoss(const std::vector<Probability>& pDefDate, //<< never used!!
                                   const std::vector<Real>& mktFactor) const;
      Disposable<std::vector<Real> > conditionalLossProb(const std::vector<Probability>& pDefDate,
                                                         // const Date& date,
                                                         const std::vector<Real>& mktFactor) const;
      // versions using the P-inverse, deprecate the former
      Disposable<std::map<Real, Probability> >
      conditionalLossDistribInvP(const std::vector<Real>& pDefDate,
                                 // const Date& date,
                                 const std::vector<Real>& mktFactor) const;
      Real expectedConditionalLossInvP(const std::vector<Real>& pDefDate,
                                       // const Date& date,
                                       const std::vector<Real>& mktFactor) const;
    protected:
      void resetModel() override;

    public:
        /*  Expected tranche Loss calculation.
            This is computed from the first equation on page 70 (not numbered)
            Notice that while we want to compute:
            \f[
            EL(t) = \sum_{l_k}l_k P(l;t) =
              \sum_{l_k}l_k \int P(l_k;t|\omega) d\omega q(\omega)
            \f]
            One can invert the sumation and the integral order to:
            \f[
            EL(t) = \int\,q(\omega)\,d\omega\,\sum_{l_k}\,l_k\,P(l_k;t|\omega) =
              \int\,q(\omega)\,d\omega\,EL(t|\omega)
            \f]
            and this is the way it is integrated here. The recursion formula 
            makes it easier this way.
        */
      Real expectedTrancheLoss(const Date& date) const override;
      Disposable<std::vector<Real> > lossProbability(const Date& date) const;
      // REMEBER THIS HAS TO BE MOVED TO A DISTRIBUTION OBJECT.............
      Disposable<std::map<Real, Probability> > lossDistribution(const Date& d) const override;
      // INTEGRATE THEN SEARCH RATHER THAN SEARCH AND THEN INTEGRATE:
      // Here I am not using a search because the point might not be attainable
      //  (loss distrib is not continuous)
      Real percentile(const Date& d, Real percentile) const override;
      Real expectedShortfall(const Date& d, Real perctl) const override;

    protected:
        const ext::shared_ptr<ConstantLossLatentmodel<copulaPolicy> > copula_;
    private:
        // loss model descriptor members
        const Size nBuckets_;
        mutable std::vector<Real> wk_;
        mutable Real lossUnit_;
        //! name to name factor. In the single factor copula:
        //    correl = beta * beta
        // When constructing through a single correlation number the factor is
        //   taken to be the positive swuare root of this number in the copula.
        ////////in the latent model now: mutable std::vector<Real> oneFactorCorrels_;
        // cached remaining basket magnitudes:
        mutable Real attachAmount_, 
            detachAmount_,
            notional_;
        mutable Size remainingBsktSize_;
        mutable std::vector<Real> notionals_;
    };


    typedef RecursiveLossModel<GaussianCopulaPolicy> RecursiveGaussLossModel;

    // Inlines ------------------------------------------------

    template<class CP>
    inline Real RecursiveLossModel<CP>::expectedTrancheLoss(
        const Date& date) const 
    {
/*
        std::map<Real, Probability> dist = lossDistribution(date);

        Real expLoss = 0.;
        std::map<Real, Probability>::iterator distIt = dist.begin();

        while(distIt != dist.end()) {
            Real loss = distIt->first * lossUnit_;
            loss = std::max(std::min(loss, detachAmount_)-attachAmount_, 0.);
            // MIN MAX BUGS ....??
            expLoss += loss * distIt->second;
            distIt++;
        }
        return expLoss ;




    ///////////////////////////////////////////////////////////////////////

        // calculate inverted unconditional Ps first so we save the inversion:
        // TO DO : turn to STL algorithm code
        std::vector<Probability> uncDefProb = 
            basket_->remainingProbabilities(date);

        return copula_->integratedExpectedValue(
            [&](const std::vector<Real>& v1) {
                return expectedConditionalLoss(uncDefProb, v1);
            });
            */

        std::vector<Probability> uncDefProb = 
            basket_->remainingProbabilities(date);
        std::vector<Real> invProb;
        for(Size i=0; i<uncDefProb.size(); ++i)
           invProb.push_back(copula_->inverseCumulativeY(uncDefProb[i], i));
           ///  invProb.push_back(CP::inverseCumulativeY(uncDefProb[i], i));//<-static call
        return copula_->integratedExpectedValue(
            [&](const std::vector<Real>& v1) {
                return expectedConditionalLossInvP(invProb, v1);
            });
    }

    template<class CP>
    inline Disposable<std::vector<Real> > 
    RecursiveLossModel<CP>::lossProbability(const Date& date) const {

        std::vector<Probability> uncDefProb = 
            basket_->remainingProbabilities(date);
        return copula_->integratedExpectedValueV(
            [&](const std::vector<Real>& v1) {
                return conditionalLossProb(uncDefProb, v1);
            });
    }

    // -------------------------------------------------------------------

    template<class CP>
    void RecursiveLossModel<CP>::resetModel() {
        // basket update:
        notionals_ = basket_->remainingNotionals();
        notional_  = basket_->remainingNotional();
        attachAmount_ = basket_->remainingAttachmentAmount();
        detachAmount_ = basket_->remainingDetachmentAmount();
        // model parameters:
        remainingBsktSize_ = notionals_.size();

        copula_->resetBasket(basket_.currentLink());

        std::vector<Real> lgdsTmp, lgds;
        for(Size i=0; i<remainingBsktSize_; ++i)
            lgds.push_back(notionals_[i]*(1.-copula_->recoveries()[i]));
        lgdsTmp = lgds;
        ///////////////std::remove(lgds.begin(), lgds.end(), 0.);
        lgds.erase(std::remove(lgds.begin(), lgds.end(), 0.), lgds.end());
        lossUnit_ = *(std::min_element(lgds.begin(), lgds.end()))
            / nBuckets_;
        for(Size i=0; i<remainingBsktSize_; ++i)
            wk_.push_back(std::floor(lgdsTmp[i]/lossUnit_ + .5));
    }

    // make it return a distribution object?
    template<class CP>
    Disposable<std::map<Real, Probability> > 
        RecursiveLossModel<CP>::lossDistribution(const Date& d) const 
    {
        std::map<Real, Probability> distrib;
        std::vector<Real> values  = lossProbability(d);
        Real sum = 0.;
        for(Size i=0; i<values.size(); ++i) {
            distrib.insert(std::make_pair<Real, Probability>(i * lossUnit_, 
                sum + values[i]));
            sum += values[i];
        }
        return distrib;
    }

    // Integrate then search rather than search and then integrate?
    // Here I am not using a search because the point might be not attainable 
    //   (loss distrib is not continuous) 
    template<class CP>
    Real RecursiveLossModel<CP>::percentile(const Date& d, 
        Real percentile) const 
    {
        std::map<Real, Probability> dist = lossDistribution(d);

        if(dist.begin()->second >=1.) return dist.begin()->first;

        // deterministic case (e.g. date requested is todays date)
        if(dist.size() == 1) return dist.begin()->first;

        if(percentile == 1.) return dist.rbegin()->second;
        if(percentile == 0.) return dist.begin()->second;
        std::map<Real, Probability>::const_iterator itdist = dist.begin();
        while (itdist->second <= percentile) ++itdist;
        Real valPlus = itdist->second;
        Real xPlus   = itdist->first;
        --itdist;  //we're never 1st or last, because of tests above
        Real valMin  = itdist->second;
        Real xMin    = itdist->first;

        // return xPlus-(xPlus-xMin)*(valPlus-percentile)/(valPlus-valMin);
        Real portfLoss =  xPlus-(xPlus-xMin)*(valPlus-percentile)
            /(valPlus-valMin);
        return //remainingNotional_ * 
            std::min(std::max(portfLoss - attachAmount_, 0.), 
                detachAmount_ - attachAmount_);/////(detach_ - attach_);
    }

    template<class CP>
    Real RecursiveLossModel<CP>::expectedShortfall(const Date& d, 
        Real perctl) const 
    {
        if(d == Settings::instance().evaluationDate()) return 0.;
        std::map<Real, Probability> distrib = lossDistribution(d);

        std::map<Real, Probability>::iterator itNxt, itDist = 
            distrib.begin();
        for(; itDist != distrib.end(); ++itDist)
            if(itDist->second >= perctl) break;
        itNxt = itDist;
        --itDist; // what if we are on the first one?!!!

        // One could linearly triangulate the exact point and get extra 
        // precission on the first(broken) period.
        if(itNxt != distrib.end()) { 
            Real lossNxt = std::min(std::max(itNxt->first - attachAmount_, 
                0.), detachAmount_ - attachAmount_);
            Real lossHere = std::min(std::max(itDist->first - attachAmount_,
                0.), detachAmount_ - attachAmount_);

            Real val =  lossNxt - (itNxt->second - perctl) * 
                (lossNxt - lossHere) / (itNxt->second - itDist->second); 
            Real suma = (itNxt->second - perctl) * (lossNxt + val) * .5;
            ++itDist; ++itNxt;
            do{
                lossNxt = std::min(std::max(itNxt->first - attachAmount_, 
                    0.), detachAmount_ - attachAmount_);
                lossHere = std::min(std::max(itDist->first - attachAmount_, 
                    0.), detachAmount_ - attachAmount_);
                suma += .5 * (lossHere + lossNxt) * (itNxt->second - 
                    itDist->second);
                ++itDist; ++itNxt;
            }while(itNxt != distrib.end());
            return suma / (1.-perctl);
        }
        return 0.;// well, we are in error....  fix: FAIL
    }

    template<class CP>
    Disposable<std::map<Real, Probability> >
        RecursiveLossModel<CP>::conditionalLossDistrib(
            const std::vector<Probability>& pDefDate, 
            //const Date& date,
            const std::vector<Real>& mktFactor) const 
    {
        //eq. 10 p.68
        //attainable losses distribution, recursive algorithm
        const std::vector<Probability>& uncDefProb = pDefDate;// alias, remove

        std::map<Real, Probability> pIndepDistrib;
        ////////  K=0
        pIndepDistrib.insert(std::make_pair(0., 1.));
        for(Size iName=0; iName<remainingBsktSize_; ++iName) {
            Probability pDef =
                copula_->conditionalDefaultProbability(uncDefProb[iName], iName,
                                                mktFactor);
            ////// iterate on all possible losses in the distribution:
            std::map<Real, Probability> pDistTemp;
            auto distIt = pIndepDistrib.begin();
            while(distIt != pIndepDistrib.end()) {
              ///   update prob if this name does not default
              auto matchIt = pDistTemp.find(distIt->first);
              if (matchIt != pDistTemp.end()) {
                  matchIt->second += distIt->second * (1. - pDef);
                }else{
                    pDistTemp.insert(std::make_pair(distIt->first,
                        distIt->second * (1.-pDef)));
                }
              ////   and if it does
                matchIt = pDistTemp.find(distIt->first + wk_[iName]);
                if(matchIt != pDistTemp.end()) {
                    matchIt->second += distIt->second * pDef;
                }else{
                    pDistTemp.insert(std::make_pair(
                        distIt->first+wk_[iName], distIt->second * pDef));
                }
                ++distIt;
            }
           /////  copy back
            pIndepDistrib = pDistTemp;
        }
        /* Apply tranche limits now .... mind you this could be done outside*/
        ////  to be done....
        return pIndepDistrib;
    }

    template<class CP>
    Disposable<std::map<Real, Probability> >
        // twice?! rewrite one in terms of the other, this is a duplicate!
        RecursiveLossModel<CP>::conditionalLossDistribInvP(
            const std::vector<Real>& invpDefDate, 
            //const Date& date,
            const std::vector<Real>& mktFactor) const 
    {
        // eq. 10 p.68
        // attainable losses distribution, recursive algorithm

        std::map<Real, Probability> pIndepDistrib;
        // K=0
        pIndepDistrib.insert(std::make_pair(0., 1.));
        for(Size iName=0; iName<remainingBsktSize_; ++iName) {
            Probability pDef =
                copula_->conditionalDefaultProbabilityInvP(invpDefDate[iName], 
                    iName, mktFactor);

            // iterate on all possible losses in the distribution:
            std::map<Real, Probability> pDistTemp;
            auto distIt = pIndepDistrib.begin();
            while(distIt != pIndepDistrib.end()) {
                // update prob if this name does not default
                auto matchIt = pDistTemp.find(distIt->first);
                if(matchIt != pDistTemp.end()) {
                    matchIt->second += distIt->second * (1.-pDef);
                }else{
                    pDistTemp.insert(std::make_pair(distIt->first,
                        distIt->second * (1.-pDef)));
                }
                // and if it does
                matchIt = pDistTemp.find(distIt->first + wk_[iName]);
                if(matchIt != pDistTemp.end()) {
                    matchIt->second += distIt->second * pDef;
                }else{
                    pDistTemp.insert(std::make_pair(
                        distIt->first+wk_[iName], distIt->second * pDef));
                }
                ++distIt;
            }
            // copy back
            pIndepDistrib = pDistTemp;
        }
        /* Apply tranche limits now .... mind you this could be done outside*/
        return pIndepDistrib;
    }




    /*
    Bugs here???. The max min on the tranche looks 
    wrong. It is better to have a tranche function since that way we can avoid 
    adding up losses over all the posible losses rather than just over the 
    tranche limits.
    */
    //! Portfolio loss conditional to the market factor value
    template<class CP>
    Real RecursiveLossModel<CP>::expectedConditionalLoss(
        const std::vector<Probability>& pDefDate, 
        //const Date& date,
        const std::vector<Real>& mktFactor) const 
    {
        std::map<Real, Probability> pIndepDistrib =
            conditionalLossDistrib(pDefDate, mktFactor);

        // get the expected value subject to the value of the market
        //   factor.
        Real expLoss = 0.;
        //---------------------------------------------------------------
        /* This is the original (easy to read) loop which I have partially
             unroll below to take profit of the fact that once we go over
             the tranche top the loss amount is fixed:
        */
        auto distIt = pIndepDistrib.begin();

        while(distIt != pIndepDistrib.end()) {
            Real loss = distIt->first * lossUnit_;
     //       loss = std::max(std::min(loss, detachAmount_)-attachAmount_, 0.);
            loss = std::min(std::max(loss - attachAmount_, 0.), 
                detachAmount_ - attachAmount_);
            // MIN MAX BUGS ....??
            expLoss += loss * distIt->second;
            ++distIt;
        }
        return expLoss ;
    }

    template<class CP>
    // again, I am duplicating code.
    Real RecursiveLossModel<CP>::expectedConditionalLossInvP(
                                 const std::vector<Real>& invPDefDate, 
                                 //const Date& date,
                                 const std::vector<Real>& mktFactor) const 
    {
        std::map<Real, Probability> pIndepDistrib =
            conditionalLossDistribInvP(invPDefDate, mktFactor);

        // get the expected value subject to the value of the market
        //   factor.
        Real expLoss = 0.;
        //---------------------------------------------------------------
        /* This is the original (easy to read) loop which I have partially
             unroll below to take profit of the fact that once we go over
             the tranche top the loss amount is fixed:
        */
        auto distIt = pIndepDistrib.begin();

        while(distIt != pIndepDistrib.end()) {
            Real loss = distIt->first * lossUnit_;
   //         loss = std::max(std::min(loss, detachAmount_)-attachAmount_, 0.);
            loss = std::min(std::max(loss - attachAmount_, 0.), 
                detachAmount_ - attachAmount_);
            // MIN MAX BUGS ....???
            expLoss += loss * distIt->second;
            ++distIt;
        }
        return expLoss ;
    }

    template<class CP>
    Disposable<std::vector<Real> > RecursiveLossModel<CP>::conditionalLossProb(
        const std::vector<Probability>& pDefDate, 
        //const Date& date,
        const std::vector<Real>& mktFactor) const 
    {
        std::map<Real, Probability> pIndepDistrib =
            conditionalLossDistrib(pDefDate, mktFactor);

        std::vector<Real> results;
        auto distIt = pIndepDistrib.begin();
        while(distIt != pIndepDistrib.end()) {
            //Real loss = distIt->first * loss_unit_
            //                    ;
            //loss = std::max(std::min(loss,
            //    results_.xMax)-results_.xMin, 0.);
            //expLoss += loss * distIt->second;

            results.push_back(distIt->second);
             ++distIt;
        }
        return results;
    }

}

#endif
]]></document_content>
  </document>
  <document index="214">
    <source>credit/riskyassetswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/experimental/credit/riskyassetswap.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    RiskyAssetSwap::RiskyAssetSwap(bool fixedPayer,
                                   Real nominal,
                                   Schedule fixedSchedule,
                                   Schedule floatSchedule,
                                   DayCounter fixedDayCounter,
                                   DayCounter floatDayCounter,
                                   Rate spread,
                                   Rate recoveryRate,
                                   Handle<YieldTermStructure> yieldTS,
                                   Handle<DefaultProbabilityTermStructure> defaultTS,
                                   Rate coupon)
    : fixedPayer_(fixedPayer), nominal_(nominal), fixedSchedule_(std::move(fixedSchedule)),
      floatSchedule_(std::move(floatSchedule)), fixedDayCounter_(std::move(fixedDayCounter)),
      floatDayCounter_(std::move(floatDayCounter)), spread_(spread), recoveryRate_(recoveryRate),
      yieldTS_(std::move(yieldTS)), defaultTS_(std::move(defaultTS)), coupon_(coupon) {

        registerWith (yieldTS_);
        registerWith (defaultTS_);
    }

    bool RiskyAssetSwap::isExpired () const {
        return detail::simple_event(fixedSchedule_.dates().back())
               .hasOccurred(yieldTS_->referenceDate());
    }


    void RiskyAssetSwap::setupExpired() const {
        Instrument::setupExpired();
    }


    void RiskyAssetSwap::performCalculations() const {
        // order of calls is essential
        floatAnnuity_   = floatAnnuity();
        fixedAnnuity_   = fixedAnnuity();
        parCoupon_      = parCoupon();

        if (coupon_ == Null<Rate>())  coupon_ = parCoupon_;

        recoveryValue_  = recoveryValue();
        riskyBondPrice_ = riskyBondPrice();

        NPV_ = riskyBondPrice_
            - coupon_ * fixedAnnuity_
            + yieldTS_->discount (fixedSchedule_.dates().front())
            - yieldTS_->discount (fixedSchedule_.dates().back())
            + spread_ * floatAnnuity_;

        NPV_ *= nominal_;

        if (!fixedPayer_)
            NPV_ *= -1;
    }


    Real RiskyAssetSwap::floatAnnuity () const {
        Real annuity = 0;
        for (Size i = 1; i < floatSchedule_.size(); i++) {
            Time dcf = floatDayCounter_.yearFraction (floatSchedule_[i-1],
                                                      floatSchedule_[i]);
            annuity += dcf * yieldTS_->discount (floatSchedule_[i]);
        }
        return annuity;
    }


    Real RiskyAssetSwap::fixedAnnuity () const {
        Real annuity = 0;
        for (Size i = 1; i < floatSchedule_.size(); i++) {
            Time dcf = fixedDayCounter_.yearFraction (floatSchedule_[i-1],
                                                      floatSchedule_[i]);
            annuity += dcf * yieldTS_->discount (floatSchedule_[i]);
        }
        return annuity;
    }


    Real RiskyAssetSwap::parCoupon () const {
        return (yieldTS_->discount(fixedSchedule_.dates().front())
                -yieldTS_->discount(fixedSchedule_.dates().back()))
            / fixedAnnuity_;
    }


    Real RiskyAssetSwap::recoveryValue() const {
        Real recoveryValue = 0;
        // simple Euler integral to evaluate the recovery value
        for (Size i = 1; i < fixedSchedule_.size(); i++) {
            TimeUnit stepSize = Days;
            Date d;
            if (fixedSchedule_[i-1] >= defaultTS_->referenceDate())
                d = fixedSchedule_[i-1];
            else
                d = defaultTS_->referenceDate();
            Date d0 = d;
            do {
                Real disc = yieldTS_->discount (d);
                Real dd   = defaultTS_->defaultDensity (d, true);
                Real dcf  = defaultTS_->dayCounter().yearFraction (d0, d);

                recoveryValue  += disc * dd * dcf;

                d0 = d;

                d = NullCalendar().advance (d0, 1, stepSize, Unadjusted);
            }
            while (d < fixedSchedule_[i]);
        }
        recoveryValue *= recoveryRate_;

        return recoveryValue;
    }


    Real RiskyAssetSwap::riskyBondPrice () const {
        Real value = 0;
        for (Size i = 1; i < fixedSchedule_.size(); i++) {
            Time dcf = fixedDayCounter_.yearFraction (fixedSchedule_[i-1],
                                                      fixedSchedule_[i]);
            value += dcf * yieldTS_->discount (fixedSchedule_[i])
                * defaultTS_->survivalProbability (fixedSchedule_[i], true);
        }
        value *= coupon_;

        value += yieldTS_->discount (fixedSchedule_.dates().back())
            * defaultTS_->survivalProbability (fixedSchedule_.dates().back(),
                                               true);

        return value + recoveryValue_;
    }


    Real RiskyAssetSwap::fairSpread () {
        calculate();

        Real value = 0;
        for (Size i = 1; i < fixedSchedule_.size(); i++) {
            Time dcf = fixedDayCounter_.yearFraction (fixedSchedule_[i-1],
                                                      fixedSchedule_[i]);
            value += dcf * yieldTS_->discount (fixedSchedule_[i])
                * defaultTS_->defaultProbability (fixedSchedule_[i], true);
        }
        value *= coupon_;

        value += yieldTS_->discount (fixedSchedule_.dates().back())
            * defaultTS_->defaultProbability (fixedSchedule_.dates().back(),
                                              true);

        Real initialDiscount = yieldTS_->discount(fixedSchedule_[0]);

        return (1.0 - initialDiscount + value - recoveryValue_) / fixedAnnuity_;
    }


    AssetSwapHelper::AssetSwapHelper(const Handle<Quote>& spread,
                                     const Period& tenor,
                                     Natural settlementDays,
                                     Calendar calendar,
                                     const Period& fixedPeriod,
                                     BusinessDayConvention fixedConvention,
                                     DayCounter fixedDayCount,
                                     const Period& floatPeriod,
                                     BusinessDayConvention floatConvention,
                                     DayCounter floatDayCount,
                                     Real recoveryRate,
                                     const RelinkableHandle<YieldTermStructure>& yieldTS,
                                     const Period& integrationStepSize)
    : DefaultProbabilityHelper(spread), tenor_(tenor), settlementDays_(settlementDays),
      calendar_(std::move(calendar)), fixedConvention_(fixedConvention), fixedPeriod_(fixedPeriod),
      fixedDayCount_(std::move(fixedDayCount)), floatConvention_(floatConvention),
      floatPeriod_(floatPeriod), floatDayCount_(std::move(floatDayCount)),
      recoveryRate_(recoveryRate), yieldTS_(yieldTS), integrationStepSize_(integrationStepSize) {

        initializeDates();

        registerWith(Settings::instance().evaluationDate());
        registerWith(yieldTS);
    }

    Real AssetSwapHelper::impliedQuote() const {
        QL_REQUIRE(!probability_.empty(),
                   "default term structure not set");
        // we didn't register as observers - force calculation
        asw_->recalculate();
        return asw_->fairSpread();
    }

    void AssetSwapHelper::setTermStructure(
                                        DefaultProbabilityTermStructure* ts) {
        DefaultProbabilityHelper::setTermStructure(ts);

        probability_.linkTo(
            ext::shared_ptr<DefaultProbabilityTermStructure>(ts, null_deleter()),
            false);

        initializeDates();
    }

    void AssetSwapHelper::update() {
        if (evaluationDate_ != Settings::instance().evaluationDate())
            initializeDates();

        DefaultProbabilityHelper::update();
    }

    void AssetSwapHelper::initializeDates() {
        evaluationDate_ = Settings::instance().evaluationDate();

        earliestDate_ = calendar_.advance (evaluationDate_,
                                           settlementDays_, Days);

        Date maturity = earliestDate_ + tenor_;

        latestDate_ = calendar_.adjust (maturity, fixedConvention_);

        Schedule fixedSchedule(earliestDate_, maturity,
                               fixedPeriod_, calendar_,
                               fixedConvention_, fixedConvention_,
                               DateGeneration::Forward, false);
        Schedule floatSchedule(earliestDate_, maturity,
                               floatPeriod_, calendar_,
                               floatConvention_, floatConvention_,
                               DateGeneration::Forward, false);

        asw_ = ext::shared_ptr<RiskyAssetSwap>(
                                      new RiskyAssetSwap(true,
                                                         100.0,
                                                         fixedSchedule,
                                                         floatSchedule,
                                                         fixedDayCount_,
                                                         floatDayCount_,
                                                         0.01,
                                                         recoveryRate_,
                                                         yieldTS_,
                                                         probability_));
    }

}
]]></document_content>
  </document>
  <document index="215">
    <source>credit/riskyassetswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file riskyassetswap.hpp
    \brief Risky asset-swap instrument
*/

#ifndef quantlib_risky_asset_swap_hpp
#define quantlib_risky_asset_swap_hpp

#include <ql/instrument.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/credit/defaultprobabilityhelpers.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    //! Risky asset-swap instrument
    class RiskyAssetSwap : public Instrument {
      public:
        RiskyAssetSwap(bool fixedPayer,
                       Real nominal,
                       Schedule fixedSchedule,
                       Schedule floatSchedule,
                       DayCounter fixedDayCounter,
                       DayCounter floatDayCounter,
                       Rate spread,
                       Rate recoveryRate_,
                       Handle<YieldTermStructure> yieldTS,
                       Handle<DefaultProbabilityTermStructure> defaultTS,
                       Rate coupon = Null<Rate>());

        Real fairSpread ();

        Real floatAnnuity() const;

        Real nominal() const { return nominal_; }
        Rate spread() const { return spread_; }
        bool fixedPayer() const { return fixedPayer_; }

      private:
        void setupExpired() const override;
        bool isExpired() const override;
        void performCalculations() const override;

        Real fixedAnnuity() const;
        Real parCoupon() const;
        Real recoveryValue() const;
        Real riskyBondPrice() const;

        // calculated values
        mutable Real fixedAnnuity_;
        mutable Real floatAnnuity_;
        mutable Real parCoupon_;
        mutable Real recoveryValue_;
        mutable Real riskyBondPrice_;

        // input
        bool fixedPayer_;
        Real nominal_;
        Schedule fixedSchedule_, floatSchedule_;
        DayCounter fixedDayCounter_, floatDayCounter_;
        Rate spread_;
        Rate recoveryRate_;
        Handle<YieldTermStructure> yieldTS_;
        Handle<DefaultProbabilityTermStructure> defaultTS_;
        mutable Real coupon_;
    };


    // risky-asset-swap helper for probability-curve bootstrap
    class AssetSwapHelper : public DefaultProbabilityHelper {
      public:
        AssetSwapHelper(const Handle<Quote>& spread,
                        const Period& tenor,
                        Natural settlementDays,
                        Calendar calendar,
                        const Period& fixedPeriod,
                        BusinessDayConvention fixedConvention,
                        DayCounter fixedDayCount,
                        const Period& floatPeriod,
                        BusinessDayConvention floatConvention,
                        DayCounter floatDayCount,
                        Real recoveryRate,
                        const RelinkableHandle<YieldTermStructure>& yieldTS,
                        const Period& integrationStepSize = Period());
        Real impliedQuote() const override;
        void setTermStructure(DefaultProbabilityTermStructure*) override;

      private:
        void update() override;
        void initializeDates();

        Period tenor_;
        Natural settlementDays_;
        Calendar calendar_;
        BusinessDayConvention fixedConvention_;
        Period fixedPeriod_;
        DayCounter fixedDayCount_;
        BusinessDayConvention floatConvention_;
        Period floatPeriod_;
        DayCounter floatDayCount_;
        Real recoveryRate_;
        RelinkableHandle<YieldTermStructure> yieldTS_;
        Period integrationStepSize_;

        Date evaluationDate_;
        ext::shared_ptr<RiskyAssetSwap> asw_;
        RelinkableHandle<DefaultProbabilityTermStructure> probability_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="216">
    <source>credit/riskyassetswapoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/experimental/credit/riskyassetswapoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    RiskyAssetSwapOption::RiskyAssetSwapOption(ext::shared_ptr<RiskyAssetSwap> asw,
                                               const Date& expiry,
                                               Rate marketSpread,
                                               Volatility spreadVolatility)
    : asw_(std::move(asw)), expiry_(expiry), marketSpread_(marketSpread),
      spreadVolatility_(spreadVolatility) {}

    bool RiskyAssetSwapOption::isExpired() const {
        return detail::simple_event(expiry_).hasOccurred();
    }


    void RiskyAssetSwapOption::performCalculations() const {
        Real w;
        if (asw_->fixedPayer()) // strike receiver = asw call = spread put
            w = -1.0;
        else
            w = 1.0;

        Date today = Settings::instance().evaluationDate();
        Time expiryTime = Actual365Fixed().yearFraction(today, expiry_);
        Real stdDev = spreadVolatility_ * std::sqrt(expiryTime);
        Real d = (asw_->spread() - marketSpread_) / stdDev;
        Real A0 = asw_->nominal() * asw_->floatAnnuity();

        NPV_ = A0 * stdDev * (w*d * CumulativeNormalDistribution()(w*d)
                              + NormalDistribution()(d));
    }

}
]]></document_content>
  </document>
  <document index="217">
    <source>credit/riskyassetswapoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file riskyassetswapoption.hpp
    \brief option on risky asset swap
*/

#ifndef quantlib_risky_asset_swap_option_hpp
#define quantlib_risky_asset_swap_option_hpp

#include <ql/experimental/credit/riskyassetswap.hpp>

namespace QuantLib {

    //! %Option on risky asset swap
    /*! \ingroup credit */
    class RiskyAssetSwapOption : public Instrument {
      public:
        RiskyAssetSwapOption(ext::shared_ptr<RiskyAssetSwap> asw,
                             const Date& expiry,
                             Rate marketSpread,
                             Volatility spreadVolatility);

      private:
        bool isExpired() const override;
        void performCalculations() const override;

        ext::shared_ptr<RiskyAssetSwap> asw_;
        Date expiry_;
        Rate marketSpread_;
        Volatility spreadVolatility_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="218">
    <source>credit/riskybond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/experimental/credit/loss.hpp>
#include <ql/experimental/credit/riskybond.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    RiskyBond::RiskyBond(std::string name,
                         Currency ccy,
                         Real recoveryRate,
                         Handle<DefaultProbabilityTermStructure> defaultTS,
                         Handle<YieldTermStructure> yieldTS,
                         Natural settlementDays,
                         Calendar calendar)
    : name_(std::move(name)), ccy_(std::move(ccy)), recoveryRate_(recoveryRate),
      defaultTS_(std::move(defaultTS)), yieldTS_(std::move(yieldTS)),
      settlementDays_(settlementDays), calendar_(std::move(calendar)) {
        registerWith (yieldTS_);
        registerWith (defaultTS_);
        //the two above might not be registered with evalDate
        registerWith(Settings::instance().evaluationDate());
    }

    bool RiskyBond::isExpired() const {
        return detail::simple_event(maturityDate()).hasOccurred();
    }

    void RiskyBond::setupExpired() const {
        Instrument::setupExpired();
    }

    void RiskyBond::performCalculations() const {
        NPV_ = 0;
        Date today = Settings::instance().evaluationDate();
        Date npvDate = calendar_.advance(today, settlementDays_, Days);
        std::vector<ext::shared_ptr<CashFlow> > cf = cashflows();
        Date d1 = effectiveDate();
        for (auto& i : cf) {
            Date d2 = i->date();
            if (d2 > npvDate) {
                d1 = max(npvDate , d1);
                Date defaultDate = d1 + (d2-d1)/2;

                Real coupon = i->amount() * defaultTS_->survivalProbability(d2);
                Real recovery = notional(defaultDate) * recoveryRate_
                    * (defaultTS_->survivalProbability(d1)
                       -defaultTS_->survivalProbability(d2));
                NPV_ += coupon * yieldTS()->discount(d2);
                NPV_ += recovery * yieldTS()->discount(defaultDate);
            }
            d1 = d2;
        }
        valuationDate_ = npvDate;
    }

    Real RiskyBond::riskfreeNPV() const {
        Date today = Settings::instance().evaluationDate();
        Date npvDate = calendar_.advance(today, settlementDays_, Days);
        Real npv = 0;
        std::vector<ext::shared_ptr<CashFlow> > cf = cashflows();
        for (auto& i : cf) {
            Date d2 = i->date();
            if (d2 > npvDate)
                npv += i->amount() * yieldTS()->discount(d2);
        }
        return npv;
    }

    Real RiskyBond::totalFutureFlows() const {
        Date today = Settings::instance().evaluationDate();
        Date npvDate = calendar_.advance(today, settlementDays_, Days);
        Real flow = 0;
        std::vector<ext::shared_ptr<CashFlow> > cf = cashflows();
        for (auto& i : cf) {
            if (i->date() > npvDate)
                flow += i->amount();
        }
        return flow;
    }

    std::vector<ext::shared_ptr<CashFlow> > RiskyBond::expectedCashflows() {
        std::vector<ext::shared_ptr<CashFlow> > expected;
        std::vector<ext::shared_ptr<CashFlow> > cf = cashflows();
        Date today = Settings::instance().evaluationDate();
        Date npvDate = calendar_.advance(today, settlementDays_, Days);
        Date d1 = effectiveDate();
        for (auto& i : cf) {
            Date d2 = i->date();
            if (d2 > npvDate) {
                d1 = max(npvDate, d1);
                Date defaultDate = d1 + (d2-d1)/2;

                Real coupon = i->amount() * defaultTS_->survivalProbability(d2);
                Real recovery = notional(defaultDate) * recoveryRate_
                    * (defaultTS_->survivalProbability(d1)
                       -defaultTS_->survivalProbability(d2));
                ext::shared_ptr<CashFlow>
                    flow1(new SimpleCashFlow(coupon, d2));
                expected.push_back(flow1);

                ext::shared_ptr<CashFlow>
                    flow2(new SimpleCashFlow(recovery, defaultDate));
                expected.push_back(flow2);
            }
            d1 = d2;
        }
        return expected;
    }

    //------------------------------------------------------------------------
    RiskyFixedBond::RiskyFixedBond(const std::string& name,
                                   const Currency& ccy,
                                   Real recoveryRate,
                                   const Handle<DefaultProbabilityTermStructure>& defaultTS,
                                   const Schedule& schedule,
                                   Real rate,
                                   DayCounter dayCounter,
                                   BusinessDayConvention paymentConvention,
                                   std::vector<Real> notionals,
                                   const Handle<YieldTermStructure>& yieldTS,
                                   Natural settlementDays)
    : RiskyBond(name, ccy, recoveryRate, defaultTS, yieldTS, settlementDays, schedule.calendar()),
      schedule_(schedule), rate_(rate), dayCounter_(std::move(dayCounter)),
      // paymentConvention_(paymentConvention),
      notionals_(std::move(notionals)) {
        // FIXME: Take paymentConvention into account
        std::vector<Date> dates = schedule_.dates();
        Real previousNotional = notionals_.front();
        for (Size i = 1; i < dates.size(); i++) {
            Real currentNotional = (i < notionals_.size() ?
                             notionals_[i] :
                             notionals_.back());
            ext::shared_ptr<CashFlow> interest (new
                   FixedRateCoupon(dates[i], previousNotional,
                                   rate_, dayCounter_, dates[i-1], dates[i]));
            ext::shared_ptr<CashFlow> amortization(new
                 AmortizingPayment(previousNotional - currentNotional, dates[i]));
            previousNotional = currentNotional;

            leg_.push_back(interest);
            interestLeg_.push_back(interest);
            if (amortization->amount() != 0){
                leg_.push_back(amortization);
                redemptionLeg_.push_back(amortization);
            }
        }

        ext::shared_ptr<CashFlow> redemption(new
                 Redemption(previousNotional, schedule_.dates().back()));
        leg_.push_back(redemption);
        redemptionLeg_.push_back(redemption);
    }

    std::vector<ext::shared_ptr<CashFlow> > RiskyFixedBond::cashflows() const{
        return leg_;
    }
    std::vector<ext::shared_ptr<CashFlow> > RiskyFixedBond::interestFlows() const{
        return interestLeg_;
    }
    std::vector<ext::shared_ptr<CashFlow> > RiskyFixedBond::notionalFlows() const{
        return redemptionLeg_;
    }

    Real RiskyFixedBond::notional(Date date) const {
        if (date > maturityDate())
            return 0.0;
        Real ntl = notionals_.front();
        for (Size i = 0; i < schedule_.size(); i++) {
            if (i < notionals_.size() && schedule_[i] <= date)
                ntl = notionals_[i];
            else
                break;
        }
        return ntl;
    }

    Date RiskyFixedBond::effectiveDate() const {
        return schedule_.dates().front();
    }

    Date RiskyFixedBond::maturityDate() const {
        return schedule_.dates().back();
    }

    //------------------------------------------------------------------------
    RiskyFloatingBond::RiskyFloatingBond(const std::string& name,
                                         const Currency& ccy,
                                         Real recoveryRate,
                                         const Handle<DefaultProbabilityTermStructure>& defaultTS,
                                         const Schedule& schedule,
                                         ext::shared_ptr<IborIndex> index,
                                         Integer fixingDays,
                                         Real spread,
                                         std::vector<Real> notionals,
                                         const Handle<YieldTermStructure>& yieldTS,
                                         Natural settlementDays)
    : RiskyBond(name, ccy, recoveryRate, defaultTS, yieldTS, settlementDays, schedule.calendar()),
      schedule_(schedule), index_(std::move(index)), fixingDays_(fixingDays), spread_(spread),
      notionals_(std::move(notionals)) {

        // FIXME: Take paymentConvention into account
        std::vector<Date> dates = schedule_.dates();
        Real previousNotional = notionals_.front();
        for (Size i = 1; i < dates.size(); i++) {
            Real currentNotional = (i < notionals_.size() ?
                             notionals_[i] :
                             notionals_.back());
            ext::shared_ptr<CashFlow> interest (new
                   IborCoupon(dates[i], previousNotional, dates[i-1], dates[i],
                              fixingDays_, index_, 1.0, spread_));
            ext::shared_ptr<CashFlow> amortization(new
                 AmortizingPayment(previousNotional - currentNotional, dates[i]));
            previousNotional = currentNotional;

            leg_.push_back(interest);
            interestLeg_.push_back(interest);
            if (amortization->amount() != 0){
                leg_.push_back(amortization);
                redemptionLeg_.push_back(amortization);
            }
        }

        ext::shared_ptr<CashFlow> redemption(new
                 Redemption(previousNotional, schedule_.dates().back()));
        leg_.push_back(redemption);
        redemptionLeg_.push_back(redemption);

        ext::shared_ptr<IborCouponPricer>
            fictitiousPricer(new
                BlackIborCouponPricer(Handle<OptionletVolatilityStructure>()));
        setCouponPricer(leg_,fictitiousPricer);
    }

    std::vector<ext::shared_ptr<CashFlow> > RiskyFloatingBond::cashflows()
        const {
        return leg_;
    }

    std::vector<ext::shared_ptr<CashFlow> > RiskyFloatingBond::interestFlows()
    const {
        return interestLeg_;
    }

    std::vector<ext::shared_ptr<CashFlow> > RiskyFloatingBond::notionalFlows()
    const {
        return redemptionLeg_;
    }

    Real RiskyFloatingBond::notional(Date date) const {
        if (date > maturityDate())
            return 0.0;
        Real ntl = notionals_.front();
        for (Size i = 0; i < schedule_.size(); i++) {
            if (i < notionals_.size() && schedule_[i] <= date)
                ntl = notionals_[i];
            else
                break;
        }
        return ntl;
    }

    Date RiskyFloatingBond::effectiveDate() const {
        return schedule_.dates().front();
    }

    Date RiskyFloatingBond::maturityDate() const {
        return schedule_.dates().back();
    }

}

]]></document_content>
  </document>
  <document index="219">
    <source>credit/riskybond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file riskybond.hpp
    \brief Defaultable bonds
*/

#ifndef quantlib_riskybond_hpp
#define quantlib_riskybond_hpp

#include <ql/instrument.hpp>
#include <ql/experimental/credit/issuer.hpp>
#include <ql/default.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/cashflow.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/experimental/credit/pool.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/currency.hpp>

namespace QuantLib {

    /*! Base class for default risky bonds
      \ingroup credit
    */
    class RiskyBond : public Instrument {
    public:
        /*! The value is contingent to survival, i.e., the knockout
            probability is considered.  To compute the npv given that
            the issuer has survived, use the riskfreeNPV().

            In each of the \f$n\f$ coupon periods, we can calculate the value
            in the case of survival and default, assuming that the issuer
            can only default in the middle of a coupon period. We denote this time
            \f$T_{i}^{mid}=\frac{T_{i-1}+T_{i}}{2}\f$.

            Given survival we receive the full cash flow (both coupons and notional).
            The time \f$t\f$ value of these payments are given by
            \f[
                \sum_{i=1}^{n}CF_{i}P(t,T_{i})Q(T_{i}<\tau)
            \f]
            where \f$P(t,T)\f$ is the time \f$T\f$ discount bond
            and \f$Q(T<\tau)\f$ is the time \f$T\f$ survival probability.
            \f$n\f$ is the number of coupon periods. This takes care of the payments
            in the case of survival.

            Given default we receive only a fraction of the notional at default.
            \f[
                \sum_{i=1}^{n}Rec N(T_{i}^{mid}) P(t,T_{i}^{mid})Q(T_{i-1}<\tau\leq T_{i})
            \f]
            where \f$Rec\f$ is the recovery rate and \f$N(T)\f$ is the time T notional. The default probability can be
            rewritten as
            \f[
                Q(T_{i-1}<\tau\leq T_{i})=Q(T_{i}<\tau)-Q(T_{i-1}<\tau)=(1-Q(T_{i}\geq\tau))-(1-Q(T_{i-1}\geq\tau))=Q(T_{i-1}\geq\tau)-Q(T_{i}\geq\tau)
            \f]
        */
      RiskyBond(std::string name,
                Currency ccy,
                Real recoveryRate,
                Handle<DefaultProbabilityTermStructure> defaultTS,
                Handle<YieldTermStructure> yieldTS,
                Natural settlementDays = 0,
                Calendar calendar = Calendar());
      ~RiskyBond() override = default;
      virtual std::vector<ext::shared_ptr<CashFlow> > cashflows() const = 0;
      std::vector<ext::shared_ptr<CashFlow> > expectedCashflows();
      virtual Real notional(Date date = Date::minDate()) const = 0;
      virtual Date effectiveDate() const = 0;
      virtual Date maturityDate() const = 0;
      virtual std::vector<ext::shared_ptr<CashFlow> > interestFlows() const = 0;
      virtual std::vector<ext::shared_ptr<CashFlow> > notionalFlows() const = 0;
      Real riskfreeNPV() const;
      Real totalFutureFlows() const;
      std::string name() const;
      Currency ccy() const;
      Handle<YieldTermStructure> yieldTS() const;
      Handle<DefaultProbabilityTermStructure> defaultTS() const;
      Real recoveryRate() const;
      //! \name Instrument interface
      //@{
      bool isExpired() const override;
      //@}
    protected:
      void setupExpired() const override;
      void performCalculations() const override;

    private:
        std::string name_;
        Currency ccy_;
        Real recoveryRate_;
        Handle<DefaultProbabilityTermStructure> defaultTS_;
        Handle<YieldTermStructure> yieldTS_;
    protected:
        // engines data
        Natural settlementDays_;
        Calendar calendar_;
    };

    inline std::string RiskyBond::name() const {
        return name_;
    }

    inline Currency RiskyBond::ccy() const {
        return ccy_;
    }

    inline Handle<YieldTermStructure> RiskyBond::yieldTS() const {
        return yieldTS_;
    }

    inline Handle<DefaultProbabilityTermStructure>
    RiskyBond::defaultTS() const {
        return defaultTS_;
    }

    inline Real RiskyBond::recoveryRate() const {
        return recoveryRate_;
    }

    /*! Default risky fixed bond
      \ingroup credit
    */
    class RiskyFixedBond : public RiskyBond {
    public:
      RiskyFixedBond(const std::string& name,
                     const Currency& ccy,
                     Real recoveryRate,
                     const Handle<DefaultProbabilityTermStructure>& defaultTS,
                     const Schedule& schedule,
                     Real rate,
                     DayCounter dayCounter,
                     BusinessDayConvention paymentConvention,
                     std::vector<Real> notionals,
                     const Handle<YieldTermStructure>& yieldTS,
                     Natural settlementDays = 0);
      std::vector<ext::shared_ptr<CashFlow> > cashflows() const override;
      Real notional(Date date = Date::minDate()) const override;
      Date effectiveDate() const override;
      Date maturityDate() const override;
      std::vector<ext::shared_ptr<CashFlow> > interestFlows() const override;
      std::vector<ext::shared_ptr<CashFlow> > notionalFlows() const override;

    private:
      Schedule schedule_;
      Real rate_;
      DayCounter dayCounter_;
      // BusinessDayConvention paymentConvention_;
      std::vector<Real> notionals_;
      std::vector<ext::shared_ptr<CashFlow> > leg_;
      std::vector<ext::shared_ptr<CashFlow> > interestLeg_;
      std::vector<ext::shared_ptr<CashFlow> > redemptionLeg_;
    };


    /*! Default risky floating bonds
      \ingroup credit
    */
    class RiskyFloatingBond : public RiskyBond {
    public:
      RiskyFloatingBond(const std::string& name,
                        const Currency& ccy,
                        Real recoveryRate,
                        const Handle<DefaultProbabilityTermStructure>& defaultTS,
                        const Schedule& schedule,
                        ext::shared_ptr<IborIndex> index,
                        Integer fixingDays,
                        Real spread,
                        std::vector<Real> notionals,
                        const Handle<YieldTermStructure>& yieldTS,
                        Natural settlementDays = 0);
      std::vector<ext::shared_ptr<CashFlow> > cashflows() const override;
      Real notional(Date date = Date::minDate()) const override;
      Date effectiveDate() const override;
      Date maturityDate() const override;
      std::vector<ext::shared_ptr<CashFlow> > interestFlows() const override;
      std::vector<ext::shared_ptr<CashFlow> > notionalFlows() const override;

    private:
        Schedule schedule_;
        ext::shared_ptr<IborIndex> index_;
        DayCounter dayCounter_;
        Integer fixingDays_;
        Real spread_;
        // BusinessDayConvention paymentConvention_;
        std::vector<Real> notionals_;
        std::vector<ext::shared_ptr<CashFlow> > leg_;
        std::vector<ext::shared_ptr<CashFlow> > interestLeg_;
        std::vector<ext::shared_ptr<CashFlow> > redemptionLeg_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="220">
    <source>credit/spotlosslatentmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_spotlosslatentmodel_hpp
#define quantlib_spotlosslatentmodel_hpp

#include <ql/experimental/credit/defaultprobabilitylatentmodel.hpp>

namespace QuantLib {

    /*! \brief Random spot recovery rate latent variable portfolio model.\par
    See: \par
    <b>A Spot Stochastic Recovery Extension of the Gaussian Copula</b> N.Bennani
         and J.Maetz, MPRA July 2009 \par
    <b>Extension of Spot Recovery model for Gaussian Copula</b> H.Li, October
        2009,  MPRA \par
    The model is adpated here for a multifactor set up and a generic copula so 
    it can be used for pricing in single factor mode or for risk metrics in its
    multifactor version.\par
    \todo Rewrite this model: the distribution of the spot recovery given
    default could be given as a functional of rr_i with the market factors and
    the rest of methods depend on this. That would offer a family of models.
    \todo Implement eq. 45 to have the EL(t) and be able to integrate the model
    */
    template <class copulaPolicy>
    class SpotRecoveryLatentModel : public LatentModel<copulaPolicy> {
    public:
        // resolve LM interface:
        using LatentModel<copulaPolicy>::factorWeights;
        using LatentModel<copulaPolicy>::inverseCumulativeY;
        using LatentModel<copulaPolicy>::cumulativeY;
        using LatentModel<copulaPolicy>::latentVarValue;
        using LatentModel<copulaPolicy>::integratedExpectedValue;
    private:
        const std::vector<Real> recoveries_;
        const Real modelA_;
        // products of default and recoveries factors, see refs ('covariances')
        std::vector<Real> crossIdiosyncFctrs_;
        mutable Size numNames_;
        mutable ext::shared_ptr<Basket> basket_;
        ext::shared_ptr<LMIntegration> integration_;
    protected:
        //! access to integration:
      const ext::shared_ptr<LMIntegration>& integration() const override { return integration_; }

    private:
        typedef typename copulaPolicy::initTraits initTraits;
    public:
        SpotRecoveryLatentModel(
            const std::vector<std::vector<Real> >& factorWeights,
            const std::vector<Real>& recoveries,
            Real modelA,
            LatentModelIntegrationType::LatentModelIntegrationType integralType,
            const initTraits& ini = initTraits()
            );

        void resetBasket(const ext::shared_ptr<Basket>& basket) const;
        Probability conditionalDefaultProbability(const Date& date, Size iName,
            const std::vector<Real>& mktFactors) const;
        Probability conditionalDefaultProbability(Probability prob, Size iName,
            const std::vector<Real>& mktFactors) const;
        Probability conditionalDefaultProbabilityInvP(Real invCumYProb, 
            Size iName, 
            const std::vector<Real>& m) const;
        /*! Expected conditional spot recovery rate. Conditional on a set of 
        systemic factors and default returns the integrated attainable recovery 
        values. \par
        Corresponds to a multifactor generalization of the model in eq. 44 
        on p.15 of <b>Extension of Spot Recovery Model for Gaussian Copula</b> 
        Hui Li. 2009  Only remember that \f$\rho_l Z \f$ there is here 
        (multiple betas): 
        \f$ \sum_k \beta_{ik}^l Z_k \f$ and that \f$ \rho_d \rho_l \f$ there is
        here: 
        \f$ \sum_k \beta_{ik}^d \beta_{ik}^l \f$ \par
        (d,l corresponds to first and last set of betas) 
        */
        Real expCondRecovery/*conditionalRecovery*/(const Date& d, Size iName, 
                                 const std::vector<Real>& mktFactors) const;
        Real expCondRecoveryP(Real uncondDefP, Size iName, 
                                 const std::vector<Real>& mktFactors) const;
        Real expCondRecoveryInvPinvRR(Real invUncondDefP, Real invUncondRR,
            Size iName, const std::vector<Real>& mktFactors) const;
        /*! Implements equation 42 on p.14 (second).
            Remember that for this call to make sense the sample used must be 
            one leading to a default. Theres no check on this. This member
            typically to be used within a simulation.
        */
        Real conditionalRecovery(Real latentVarSample, Size iName, 
            const Date& d) const;
        /*! Due to the way the latent model is splitted in two parts, we call 
        the base class for the default sample and the LM owned here for the RR 
        model sample. This sample only makes sense if it led to a default.
        @param allFactors All sampled factors, default and RR valiables.
        @param iName The index of the name for which we want the RR sample

        \todo Write vector version for all names' RRs 
        */
        Real latentRRVarValue(const std::vector<Real>& allFactors, 
            Size iName) const;
        Real conditionalExpLossRR(const Date& d, Size iName, 
            const std::vector<Real>& mktFactors) const;
        Real conditionalExpLossRRInv(Real invP, Real invRR, Size iName, 
            const std::vector<Real>& mktFactors) const;
        /*! Single name expected loss.\par 
        The main reason of this method is for the testing of this model. The 
        model is coherent in that it preserves the single name expected loss
        and thus is coherent with the single name CDS market when used in the
        pricing context. i.e. it should match: \f$pdef_i(d) \times RR_i \f$
        */
        Real expectedLoss(const Date& d, Size iName) const;
    };


    typedef SpotRecoveryLatentModel<GaussianCopulaPolicy> GaussianSpotLossLM;
    typedef SpotRecoveryLatentModel<TCopulaPolicy> TSpotLossLM;


    // ------------------------------------------------------------------------

    template <class CP>
    inline void
    SpotRecoveryLatentModel<CP>::resetBasket(const ext::shared_ptr<Basket>& basket) const {
        basket_ = basket;
        // in the future change 'size' to 'liveSize'
        QL_REQUIRE(basket_->size() == numNames_, 
            "Incompatible new basket and model sizes.");
    }

    template<class CP>
    inline Probability 
        SpotRecoveryLatentModel<CP>::conditionalDefaultProbability(
        const Date& date, 
        Size iName, const std::vector<Real>& mktFactors) const 
    {
        const ext::shared_ptr<Pool>& pool = basket_->pool();
        Probability pDefUncond =
            pool->get(pool->names()[iName]).
            defaultProbability(basket_->defaultKeys()[iName])
              ->defaultProbability(date);
        return conditionalDefaultProbability(pDefUncond, iName, mktFactors);
    }

    template<class CP>
    inline Probability 
        SpotRecoveryLatentModel<CP>::conditionalDefaultProbability(
        Probability prob, 
        Size iName, const std::vector<Real>& mktFactors) const 
    {
        // we can be called from the outside (from an integrable loss model)
        //   but we are called often at integration points. This or
        //   consider a list of friends.
    #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(basket_, "No portfolio basket set.");
    #endif
        /*Avoid redundant call to minimum value inversion (might be \infty),
        and this independently of the copula function.
        */
        if (prob < 1.e-10) return 0.;// use library macro...
        return conditionalDefaultProbabilityInvP(
            inverseCumulativeY(prob, iName), iName, mktFactors);
    }

    template<class CP>
    inline Probability 
        SpotRecoveryLatentModel<CP>::conditionalDefaultProbabilityInvP(
        Real invCumYProb, 
        Size iName, 
        const std::vector<Real>& m) const 
    {
        Real sumMs = 
            std::inner_product(this->factorWeights_[iName].begin(), 
                               this->factorWeights_[iName].end(), m.begin(), 0.);
        Real res = this->cumulativeZ((invCumYProb - sumMs) / 
                this->idiosyncFctrs_[iName] );
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE (res >= 0. && res <= 1.,
                    "conditional probability " << res << "out of range");
        #endif
    
        return res;
    }

    template<class CP>
    inline Real 
        SpotRecoveryLatentModel<CP>::expCondRecovery(const Date& d, 
        Size iName,
        const std::vector<Real>& mktFactors) const 
    {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(mktFactors.size() == this->numFactors(), 
        "Realization of market factors and latent model size do not match");
    #endif
        const ext::shared_ptr<Pool>& pool = basket_->pool();
        Probability pDefUncond =
            pool->get(pool->names()[iName]).
            defaultProbability(basket_->defaultKeys()[iName])
              ->defaultProbability(d);

        return expCondRecoveryP(pDefUncond, iName, mktFactors);
    }

    template<class CP>
    inline Real SpotRecoveryLatentModel<CP>::expCondRecoveryP(
        Real uncondDefP, Size iName, const std::vector<Real>& mktFactors) const 
    {
        return expCondRecoveryInvPinvRR(
            inverseCumulativeY(uncondDefP, iName), 
            inverseCumulativeY(recoveries_[iName], iName + numNames_),
            iName, mktFactors);
    }

    template<class CP>
    Real SpotRecoveryLatentModel<CP>::expCondRecoveryInvPinvRR(
        Real invUncondDefP, 
        Real invUncondRR, 
        Size iName, 
        const std::vector<Real>& mktFactors) const 
    {
        const std::vector<std::vector<Real> >& fctrs_ = factorWeights();
        //Size iRR = iName + basket_->size();// should be live pool
        const Real sumMs =
          std::inner_product(fctrs_[iName].begin(), fctrs_[iName].end(), 
              mktFactors.begin(), 0.);
        const Real sumBetaLoss = 
          std::inner_product(fctrs_[iName + numNames_].begin(),
              fctrs_[iName + numNames_].end(),
              fctrs_[iName + numNames_].begin(), 
              0.);
        return this->cumulativeZ((sumMs + std::sqrt(1.-crossIdiosyncFctrs_[iName])
                 * std::sqrt(1.+modelA_*modelA_) * 
                   invUncondRR
            - std::sqrt(crossIdiosyncFctrs_[iName]) * 
                invUncondDefP
                )
            / std::sqrt(1.- sumBetaLoss + modelA_*modelA_ * 
                (1.-crossIdiosyncFctrs_[iName])) );
    }

    template<class CP>
    Real SpotRecoveryLatentModel<CP>::conditionalRecovery(Real latentVarSample,
        Size iName, const Date& d) const 
    {
        const ext::shared_ptr<Pool>& pool = basket_->pool();

        // retrieve the default probability for this name
        const Handle<DefaultProbabilityTermStructure>& dfts = 
            pool->get(basket_->names()[iName]).defaultProbability(
                basket_->defaultKeys()[iName]);
        const Probability pdef = dfts->defaultProbability(d, true);
        // before asking for -\infty
        if (pdef < 1.e-10) return 0.;

        Size iRecovery = iName + numNames_;// should be live pool
        return cumulativeY(
            (latentVarSample - std::sqrt(crossIdiosyncFctrs_[iName]) 
                * inverseCumulativeY(pdef, iName)) / 
                (modelA_ * std::sqrt(1.-crossIdiosyncFctrs_[iName]))
            // cache the sqrts
            // cache this factor.
            +std::sqrt(1.+ 1./(modelA_*modelA_)) * 
                inverseCumulativeY(recoveries_[iName], iRecovery) 
            , iRecovery);
    }

    template<class CP>
    inline Real SpotRecoveryLatentModel<CP>::latentRRVarValue(
        const std::vector<Real>& allFactors, 
        Size iName) const 
    {
        Size iRecovery = iName + numNames_;// should be live pool
        return latentVarValue(allFactors, iRecovery);
    }

    template<class CP>
    inline Real SpotRecoveryLatentModel<CP>::conditionalExpLossRR(const Date& d,
        Size iName, 
        const std::vector<Real>& mktFactors) const 
    {
        const ext::shared_ptr<Pool>& pool = basket_->pool();
        Probability pDefUncond =
            pool->get(pool->names()[iName]).
            defaultProbability(basket_->defaultKeys()[iName])
              ->defaultProbability(d);

        Real invP = inverseCumulativeY(pDefUncond, iName);
        Real invRR = inverseCumulativeY(recoveries_[iName], iName + numNames_);

        return conditionalExpLossRRInv(invP, invRR, iName, mktFactors);
    }

    template<class CP>
    inline Real SpotRecoveryLatentModel<CP>::conditionalExpLossRRInv(
        Real invP, 
        Real invRR,
        Size iName, 
        const std::vector<Real>& mktFactors) const 
    {
        return conditionalDefaultProbabilityInvP(invP, iName, mktFactors)
            * (1.-this->conditionalRecoveryInvPinvRR(invP, invRR, iName, mktFactors));
    }

    template<class CP>
    inline Real SpotRecoveryLatentModel<CP>::expectedLoss(const Date& d, 
        Size iName) const 
    {
        const ext::shared_ptr<Pool>& pool = basket_->pool();
        Probability pDefUncond =
            pool->get(pool->names()[iName]).
            defaultProbability(basket_->defaultKeys()[iName])
              ->defaultProbability(d);

        Real invP = inverseCumulativeY(pDefUncond, iName);
        Real invRR = inverseCumulativeY(recoveries_[iName], iName + numNames_);

        return integratedExpectedValue(
            [&](const std::vector<Real>& v){
                return conditionalExpLossRRInv(invP, invRR, iName, v);
            });
    }

    template<class CP>
    SpotRecoveryLatentModel<CP>::SpotRecoveryLatentModel(
        const std::vector<std::vector<Real> >& factorWeights,
        const std::vector<Real>& recoveries,
        Real modelA,
        LatentModelIntegrationType::LatentModelIntegrationType integralType,
        const typename CP::initTraits& ini
        ) 
    : LatentModel<CP>(factorWeights, ini),
      recoveries_(recoveries), 
      modelA_(modelA),
      numNames_(factorWeights.size()/2),
      integration_(LatentModel<CP>::IntegrationFactory::
        createLMIntegration(factorWeights[0].size(), integralType))
    {
        QL_REQUIRE(factorWeights.size() % 2 == 0, 
         "Number of RR variables must be equal to number of default variables");
        QL_REQUIRE(recoveries.size() == numNames_ , 
         "Number of recoveries does not match number of defaultable entities.");

        // reminder: first betas are default, last ones are recovery 
        for(Size iName=0; iName<numNames_; iName++) /// USE STL
            /* Corresponds to: (k denotes factor, i denotes modelled 
                variable -default and recoveries))
                \sum_k a^2_{i,k} a^2_{N+i,k}
            */
        {
            Real cumul = 0.;
            for(Size iB=0; iB<factorWeights[iName].size(); iB++)
                // actually this size is unique
                cumul += factorWeights[iName][iB] * 
                    factorWeights[iName][iB] * 
                    factorWeights[iName + numNames_][iB] * 
                    factorWeights[iName + numNames_][iB];
            crossIdiosyncFctrs_.push_back(cumul);
        }

    }


}

#endif
]]></document_content>
  </document>
  <document index="221">
    <source>credit/spreadedhazardratecurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file spreadedhazardratecurve.hpp
    \brief Default-probability structure with an additive spread on hazard rates
*/

#ifndef quantlib_spreaded_hazard_rate_curve_hpp
#define quantlib_spreaded_hazard_rate_curve_hpp

#include <ql/quote.hpp>
#include <ql/termstructures/credit/hazardratestructure.hpp>
#include <utility>

namespace QuantLib {

    //! Default-probability structure with an additive spread on hazard rates
    /*! \note This term structure will remain linked to the original
              structure, i.e., any changes in the latter will be
              reflected in this structure as well.

        \ingroup termstructures
    */
    class SpreadedHazardRateCurve : public HazardRateStructure {
      public:
        SpreadedHazardRateCurve(Handle<DefaultProbabilityTermStructure> originalCurve,
                                Handle<Quote> spread);
        //! \name DefaultProbabilityTermStructure interface
        //@{
        DayCounter dayCounter() const override;
        Calendar calendar() const override;
        const Date& referenceDate() const override;
        Date maxDate() const override;
        Time maxTime() const override;
        //@}
      protected:
        //! \name DefaultProbabilityTermStructure interface
        //@{
        Real hazardRateImpl(Time t) const override;
        //@}
      private:
        Handle<DefaultProbabilityTermStructure> originalCurve_;
        Handle<Quote> spread_;
    };


    // inline definitions

    inline SpreadedHazardRateCurve::SpreadedHazardRateCurve(
        Handle<DefaultProbabilityTermStructure> h, Handle<Quote> spread)
    : originalCurve_(std::move(h)), spread_(std::move(spread)) {
        registerWith(originalCurve_);
        registerWith(spread_);
    }

    inline DayCounter SpreadedHazardRateCurve::dayCounter() const {
        return originalCurve_->dayCounter();
    }

    inline Calendar SpreadedHazardRateCurve::calendar() const {
        return originalCurve_->calendar();
    }

    inline const Date& SpreadedHazardRateCurve::referenceDate() const {
        return originalCurve_->referenceDate();
    }

    inline Date SpreadedHazardRateCurve::maxDate() const {
        return originalCurve_->maxDate();
    }

    inline Time SpreadedHazardRateCurve::maxTime() const {
        return originalCurve_->maxTime();
    }

    inline Real SpreadedHazardRateCurve::hazardRateImpl(Time t) const {
        return originalCurve_->hazardRate(t, true) + spread_->value();
    }

}

#endif
]]></document_content>
  </document>
  <document index="222">
    <source>credit/syntheticcdo.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/credit/syntheticcdo.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/event.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/experimental/credit/gaussianlhplossmodel.hpp>
#include <ql/experimental/credit/midpointcdoengine.hpp>

using namespace std;

namespace QuantLib {

    SyntheticCDO::SyntheticCDO(const ext::shared_ptr<Basket>& basket,
                               Protection::Side side,
                               const Schedule& schedule,
                               Rate upfrontRate,
                               Rate runningRate,
                               const DayCounter& dayCounter,
                               BusinessDayConvention paymentConvention,
                               boost::optional<Real> notional)
    : basket_(basket), side_(side), upfrontRate_(upfrontRate), runningRate_(runningRate),
      leverageFactor_(notional ? notional.get() / basket->trancheNotional() : 1.), // NOLINT(readability-implicit-bool-conversion)
      dayCounter_(dayCounter), paymentConvention_(paymentConvention) {
        QL_REQUIRE(!basket->names().empty(), "basket is empty");
        // Basket inception must lie before contract protection start.
        QL_REQUIRE(basket->refDate() <= schedule.startDate(),
        //using the start date of the schedule might be wrong, think of the 
        //  CDS rule
            "Basket did not exist before contract start.");

        // Notice the notional is that of the basket at basket inception, some 
        //   names might have defaulted in between
        normalizedLeg_ = FixedRateLeg(schedule)
            .withNotionals(basket_->trancheNotional() * leverageFactor_)
            .withCouponRates(runningRate, dayCounter)
            .withPaymentAdjustment(paymentConvention);

        // Date today = Settings::instance().evaluationDate();
        
        // register with probabilities if the corresponding issuer is, baskets
        //   are not registered with the DTS
        for (Size i = 0; i < basket->names().size(); i++) {
            /* This turns out to be a problem: depends on today but I am not 
            modifying the registrations, if we go back in time in the 
            calculations this would left me unregistered to some. Not impossible
            to de-register and register when updating but i am dropping it.

            if(!basket->pool()->get(basket->names()[i]).
                defaultedBetween(schedule.dates()[0], today,
                                     basket->pool()->defaultKeys()[i]))
            */
            // registers with the associated curve (issuer and event type)
            // \todo make it possible to access them by name instead of index
            registerWith(basket->pool()->get(basket->names()[i]).
                defaultProbability(basket->pool()->defaultKeys()[i]));
            /* \todo Issuers should be observables/obsrvr and they would in turn
            regiter with the DTS; only we might get updates from curves we do
            not use.
            */
        }
        registerWith(basket_);
    }

    Rate SyntheticCDO::premiumValue () const {
        calculate();
        return premiumValue_;
    }

    Rate SyntheticCDO::protectionValue () const {
        calculate();
        return protectionValue_;
    }

    Real SyntheticCDO::premiumLegNPV() const {
        calculate();
        if(side_ == Protection::Buyer) return premiumValue_;
        return -premiumValue_;
    }

    Real SyntheticCDO::protectionLegNPV() const {
        calculate();
        if(side_ == Protection::Buyer) return -protectionValue_;
        return protectionValue_;
    }

    Rate SyntheticCDO::fairPremium () const {
        calculate();
        QL_REQUIRE(premiumValue_ != 0, "Attempted divide by zero while calculating syntheticCDO premium.");
        return runningRate_
            * (protectionValue_ - upfrontPremiumValue_) / premiumValue_;
    }

    Rate SyntheticCDO::fairUpfrontPremium () const {
        calculate();
        return (protectionValue_ - premiumValue_) / remainingNotional_;
    }

    Disposable<vector<Real> > SyntheticCDO::expectedTrancheLoss() const {
        calculate();
        return expectedTrancheLoss_;
    }

    Size SyntheticCDO::error () const {
        calculate();
        return error_;
    }

    bool SyntheticCDO::isExpired () const {
        // FIXME: it could have also expired (knocked out) because theres
        //   no remaining tranche notional.
        return detail::simple_event(normalizedLeg_.back()->date())
               .hasOccurred();
    }

    Real SyntheticCDO::remainingNotional() const {
        calculate();
        return remainingNotional_;
    }

    void SyntheticCDO::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<SyntheticCDO::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");
        arguments->basket = basket_;
        arguments->side = side_;
        arguments->normalizedLeg = normalizedLeg_;

        arguments->upfrontRate = upfrontRate_;
        arguments->runningRate = runningRate_;
        arguments->dayCounter = dayCounter_;
        arguments->paymentConvention = paymentConvention_;
        arguments->leverageFactor = leverageFactor_;
    }

    void SyntheticCDO::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const SyntheticCDO::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");

        premiumValue_ = results->premiumValue;
        protectionValue_ = results->protectionValue;
        upfrontPremiumValue_ = results->upfrontPremiumValue;
        remainingNotional_ = results->remainingNotional;
        error_ = results->error;
        expectedTrancheLoss_ = results->expectedTrancheLoss;
    }

    void SyntheticCDO::setupExpired() const {
        Instrument::setupExpired();
        premiumValue_ = 0.0;
        protectionValue_ = 0.0;
        upfrontPremiumValue_ = 0.0;
        remainingNotional_ = 1.0;
        expectedTrancheLoss_.clear();
    }

    void SyntheticCDO::arguments::validate() const {
        QL_REQUIRE(side != Protection::Side(-1), "side not set");
        QL_REQUIRE(basket && !basket->names().empty(), "no basket given");
        QL_REQUIRE(runningRate != Null<Real>(), "no premium rate given");
        QL_REQUIRE(upfrontRate != Null<Real>(), "no upfront rate given");
        QL_REQUIRE(!dayCounter.empty(), "no day counter given");
    }

    void SyntheticCDO::results::reset() {
        Instrument::results::reset();
        premiumValue = Null<Real>();
        protectionValue = Null<Real>();
        upfrontPremiumValue = Null<Real>();
        remainingNotional = Null<Real>();
        error = 0;
        expectedTrancheLoss.clear();
    }





    namespace {

        class ObjectiveFunction {
          public:
            ObjectiveFunction(Real target,
                              SimpleQuote& quote,
                              PricingEngine& engine,
                              const SyntheticCDO::results* results)
            : target_(target), quote_(quote),
              engine_(engine), results_(results) {}

            Real operator()(Real guess) const {
                quote_.setValue(guess);
                engine_.calculate();
                return results_->value - target_;
            }
          private:
            Real target_;
            SimpleQuote& quote_;
            PricingEngine& engine_;
            const SyntheticCDO::results* results_;
        };

    }

    // untested, not sure this is not messing up, once it comes out of this
    //   the basket model is different.....
    Real SyntheticCDO::implicitCorrelation(const std::vector<Real>& recoveries, 
        const Handle<YieldTermStructure>& discountCurve, 
        Real targetNPV,
        Real accuracy) const 
    {
        ext::shared_ptr<SimpleQuote> correl(new SimpleQuote(0.0));

        ext::shared_ptr<GaussianLHPLossModel> lhp(new 
            GaussianLHPLossModel(Handle<Quote>(correl), recoveries));

        // lock
        basket_->setLossModel(lhp);

        MidPointCDOEngine engineIC(discountCurve);
        setupArguments(engineIC.getArguments());
        const auto* results = dynamic_cast<const SyntheticCDO::results*>(engineIC.getResults());

        // aviod recal of the basket on engine updates through the quote
        basket_->recalculate();
        basket_->freeze();

        ObjectiveFunction f(targetNPV, *correl, engineIC, results);
        Rate guess = 0.001;
        //  Rate step = guess*0.1;

        // wrap/catch to be able to unfreeze the basket:
        Real solution = Brent().solve(f, accuracy, guess, QL_EPSILON, 1.-QL_EPSILON);
        basket_->unfreeze();
        return solution;
    }

}

#endif
]]></document_content>
  </document>
  <document index="223">
    <source>credit/syntheticcdo.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file syntheticcdo.hpp
    \brief Synthetic Collateralized Debt Obligation and pricing engines
*/

#ifndef quantlib_synthetic_cdo_hpp
#define quantlib_synthetic_cdo_hpp

#include <ql/qldefines.hpp>

#ifndef QL_PATCH_SOLARIS

#include <ql/instrument.hpp>
#include <ql/default.hpp>
#include <ql/time/schedule.hpp>

#include <ql/experimental/credit/basket.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>

namespace QuantLib {

    class YieldTermStructure;

    //! Synthetic Collateralized Debt Obligation
    /*!
      The instrument prices a mezzanine CDO tranche with loss given default 
      between attachment point \f$ D_1\f$ and detachment point 
      \f$ D_2 > D_1 \f$.

      For purchased protection, the instrument value is given by the difference
      of the protection value \f$ V_1 \f$ and premium value \f$ V_2 \f$,

      \f[ V = V_1 - V_2. \f]

      The protection leg is priced as follows:

      - Build the probability distribution for volume of defaults \f$ L \f$ 
      (before recovery) or Loss Given Default \f$ LGD = (1-r)\,L \f$ at 
      times/dates \f$ t_i, i=1, ..., N\f$ (premium schedule times with
      intermediate steps)

      - Determine the expected value 
      \f$ E_i = E_{t_i}\,\left[Pay(LGD)\right] \f$
      of the protection payoff \f$ Pay(LGD) \f$  at each time \f$ t_i\f$ where
      \f[
      Pay(L) = min (D_1, LGD) - min (D_2, LGD) = \left\{
      \begin{array}{lcl}
      \displaystyle 0 &;& LGD < D_1 \\
      \displaystyle LGD - D_1 &;& D_1 \leq LGD \leq D_2 \\
      \displaystyle D_2 - D_1 &;& LGD > D_2
      \end{array}
      \right.
      \f]

      - The protection value is then calculated as
      \f[ V_1 \:=\: \sum_{i=1}^N (E_i - E_{i-1}) \cdot  d_i \f]
      where \f$ d_i\f$ is the discount factor at time/date \f$ t_i \f$

      The premium is paid on the protected notional amount, initially
      \f$ D_2 - D_1. \f$ This notional amount is reduced by the expected 
      protection
      payments \f$ E_i \f$ at times \f$ t_i, \f$ so that the premium value is
      calculated as

      \f[
      V_2 =m \, \cdot \sum_{i=1}^N \,(D_2 - D_1 - E_i) \cdot \Delta_{i-1,i}\,d_i
      \f]

      where \f$ m \f$ is the premium rate, \f$ \Delta_{i-1, i}\f$ is the day
      count fraction between date/time \f$ t_{i-1}\f$ and \f$ t_i.\f$

      The construction of the portfolio loss distribution \f$ E_i \f$ is
      based on the probability bucketing algorithm described in

      <strong>
      John Hull and Alan White, "Valuation of a CDO and nth to default CDS
      without Monte Carlo simulation", Journal of Derivatives 12, 2, 2004
      </strong>

      The pricing algorithm allows for varying notional amounts and
      default termstructures of the underlyings.

      \ingroup credit

      \todo Investigate and fix cases \f$ E_{i+1} < E_i. \f$
    */
    class SyntheticCDO : public Instrument {
    public:
        class arguments;
        class results;
        class engine;

        // Review: No accrual settlement flag. No separate upfront payment date.
        // Review: Forward start case.
        /*! If the notional exceeds the basket inception tranche
            notional, the cdo is leveraged by that factor.

            \todo: allow for extra payment flags, arbitrary upfront
                   payment date...
        */
        SyntheticCDO (const ext::shared_ptr<Basket>& basket,
                      Protection::Side side,
                      const Schedule& schedule,
                      Rate upfrontRate,
                      Rate runningRate,
                      const DayCounter& dayCounter,
                      BusinessDayConvention paymentConvention,
                      boost::optional<Real> notional = boost::none);

        const ext::shared_ptr<Basket>& basket() const { return basket_; }

        bool isExpired() const override;
        Rate fairPremium() const;
        Rate fairUpfrontPremium() const;
        Rate premiumValue () const;
        Rate protectionValue () const;
        Real premiumLegNPV() const;
        Real protectionLegNPV() const;
        /*!
          Total outstanding tranche notional, not wiped out
        */
        Real remainingNotional() const;
        /*! The number of times the contract contains the portfolio tranched 
                notional.
        */
        Real leverageFactor() const {
            return leverageFactor_;
        }
        //! Last protection date.
        const Date& maturity() const {
            return ext::dynamic_pointer_cast<FixedRateCoupon>(
                normalizedLeg_.back())->accrualEndDate();
        }
        /*! The Gaussian Copula LHP implied correlation that makes the 
            contract zero value. This is for a flat correlation along
            time and portfolio loss level.
        */
        Real implicitCorrelation(const std::vector<Real>& recoveries,
            const Handle<YieldTermStructure>& discountCurve, 
            Real targetNPV = 0.,
            Real accuracy = 1.0e-3) const;

        /*!
          Expected tranche loss for all payment dates
         */
        Disposable<std::vector<Real> > expectedTrancheLoss() const;
        Size error () const;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;

        ext::shared_ptr<Basket> basket_;
        Protection::Side side_;
        Leg normalizedLeg_;

        Rate upfrontRate_;
        Rate runningRate_;
        const Real leverageFactor_;
        DayCounter dayCounter_;
        BusinessDayConvention paymentConvention_;

        mutable Real premiumValue_;
        mutable Real protectionValue_;
        mutable Real upfrontPremiumValue_;
        mutable Real remainingNotional_;
        mutable Size error_;
        mutable std::vector<Real> expectedTrancheLoss_;
    };

    class SyntheticCDO::arguments : public virtual PricingEngine::arguments {
    public:
        arguments() : side(Protection::Side(-1)),
                      upfrontRate(Null<Real>()),
                      runningRate(Null<Real>()) {}
        void validate() const override;

        ext::shared_ptr<Basket> basket;
        Protection::Side side;
        Leg normalizedLeg;

        Rate upfrontRate;
        Rate runningRate;
        Real leverageFactor;
        DayCounter dayCounter;
        BusinessDayConvention paymentConvention;
    };

    class SyntheticCDO::results : public Instrument::results {
    public:
      void reset() override;
      Real premiumValue;
      Real protectionValue;
      Real upfrontPremiumValue;
      Real remainingNotional;
      Real xMin, xMax;
      Size error;
      /* Expected tranche losses affecting this tranche coupons. Notice this
      number might be below the actual basket losses, since the cdo protection
      might start after basket inception (forward start CDO)*/
      std::vector<Real> expectedTrancheLoss;
    };


    //! CDO base engine
    class SyntheticCDO::engine : 
        public GenericEngine<SyntheticCDO::arguments, 
                             SyntheticCDO::results> { };

}

#endif

#endif
]]></document_content>
  </document>
  <document index="224">
    <source>exoticoptions/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    analyticamericanmargrabeengine.hpp \
    analyticcomplexchooserengine.hpp \
    analyticcompoundoptionengine.hpp \
    analyticeuropeanmargrabeengine.hpp \
    analyticholderextensibleoptionengine.hpp \
    analyticpartialtimebarrieroptionengine.hpp \
    analyticpdfhestonengine.hpp \
    analyticsimplechooserengine.hpp \
    analytictwoassetbarrierengine.hpp \
    analytictwoassetcorrelationengine.hpp \
    analyticwriterextensibleoptionengine.hpp \
    complexchooseroption.hpp \
    compoundoption.hpp \
    continuousarithmeticasianlevyengine.hpp \
    continuousarithmeticasianvecerengine.hpp \
    everestoption.hpp \
    himalayaoption.hpp \
    holderextensibleoption.hpp \
    kirkspreadoptionengine.hpp \
    margrabeoption.hpp \
    mceverestengine.hpp \
    mchimalayaengine.hpp \
    mcpagodaengine.hpp \
    pagodaoption.hpp \
    partialtimebarrieroption.hpp \
    simplechooseroption.hpp \
    spreadoption.hpp \
    twoassetbarrieroption.hpp \
    twoassetcorrelationoption.hpp \
    writerextensibleoption.hpp

cpp_files = \
    analyticamericanmargrabeengine.cpp \
    analyticcomplexchooserengine.cpp \
    analyticcompoundoptionengine.cpp \
    analyticeuropeanmargrabeengine.cpp \
    analyticholderextensibleoptionengine.cpp \
    analyticpartialtimebarrieroptionengine.cpp \
    analyticpdfhestonengine.cpp \
    analyticsimplechooserengine.cpp \
    analytictwoassetbarrierengine.cpp \
    analytictwoassetcorrelationengine.cpp \
    analyticwriterextensibleoptionengine.cpp \
    complexchooseroption.cpp \
    compoundoption.cpp \
    continuousarithmeticasianlevyengine.cpp \
    continuousarithmeticasianvecerengine.cpp \
    everestoption.cpp \
    himalayaoption.cpp \
    holderextensibleoption.cpp \
    kirkspreadoptionengine.cpp \
    margrabeoption.cpp \
    mceverestengine.cpp \
    mchimalayaengine.cpp \
    mcpagodaengine.cpp \
    pagodaoption.cpp \
    partialtimebarrieroption.cpp \
    simplechooseroption.cpp \
    twoassetbarrieroption.cpp \
    twoassetcorrelationoption.cpp \
    writerextensibleoption.cpp

if UNITY_BUILD

nodist_libExoticOptions_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libExoticOptions_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libExoticOptions.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="225">
    <source>exoticoptions/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/exoticoptions/analyticamericanmargrabeengine.hpp>
#include <ql/experimental/exoticoptions/analyticcomplexchooserengine.hpp>
#include <ql/experimental/exoticoptions/analyticcompoundoptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticeuropeanmargrabeengine.hpp>
#include <ql/experimental/exoticoptions/analyticholderextensibleoptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticpartialtimebarrieroptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticpdfhestonengine.hpp>
#include <ql/experimental/exoticoptions/analyticsimplechooserengine.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetbarrierengine.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetcorrelationengine.hpp>
#include <ql/experimental/exoticoptions/analyticwriterextensibleoptionengine.hpp>
#include <ql/experimental/exoticoptions/complexchooseroption.hpp>
#include <ql/experimental/exoticoptions/compoundoption.hpp>
#include <ql/experimental/exoticoptions/continuousarithmeticasianlevyengine.hpp>
#include <ql/experimental/exoticoptions/continuousarithmeticasianvecerengine.hpp>
#include <ql/experimental/exoticoptions/everestoption.hpp>
#include <ql/experimental/exoticoptions/himalayaoption.hpp>
#include <ql/experimental/exoticoptions/holderextensibleoption.hpp>
#include <ql/experimental/exoticoptions/kirkspreadoptionengine.hpp>
#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/experimental/exoticoptions/mceverestengine.hpp>
#include <ql/experimental/exoticoptions/mchimalayaengine.hpp>
#include <ql/experimental/exoticoptions/mcpagodaengine.hpp>
#include <ql/experimental/exoticoptions/pagodaoption.hpp>
#include <ql/experimental/exoticoptions/partialtimebarrieroption.hpp>
#include <ql/experimental/exoticoptions/simplechooseroption.hpp>
#include <ql/experimental/exoticoptions/spreadoption.hpp>
#include <ql/experimental/exoticoptions/twoassetbarrieroption.hpp>
#include <ql/experimental/exoticoptions/twoassetcorrelationoption.hpp>
#include <ql/experimental/exoticoptions/writerextensibleoption.hpp>

]]></document_content>
  </document>
  <document index="226">
    <source>exoticoptions/analyticamericanmargrabeengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analyticamericanmargrabeengine.hpp>
#include <ql/pricingengines/vanilla/bjerksundstenslandengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    AnalyticAmericanMargrabeEngine::AnalyticAmericanMargrabeEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(correlation) {
        registerWith(process1_);
        registerWith(process2_);
    }

    void AnalyticAmericanMargrabeEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::American,
                   "not an American option");

        ext::shared_ptr<AmericanExercise> exercise =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an American option");

        ext::shared_ptr<NullPayoff> payoff0 =
            ext::dynamic_pointer_cast<NullPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff0, "not a null payoff");

        // The option can be priced as an American single-asset option
        // with an adjusted process and payoff.

        Date today = Settings::instance().evaluationDate();

        DayCounter rfdc  = process1_->riskFreeRate()->dayCounter();
        Time t = rfdc.yearFraction(process1_->riskFreeRate()->referenceDate(),
                                   arguments_.exercise->lastDate());

        Real s1 = process1_->stateVariable()->value();
        Real s2 = process2_->stateVariable()->value();

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(arguments_.Q1*s1));

        ext::shared_ptr<StrikedTypePayoff> payoff(
                      new PlainVanillaPayoff(Option::Call, arguments_.Q2*s2));

        DiscountFactor dividendDiscount1 =
            process1_->dividendYield()->discount(exercise->lastDate());
        Rate q1 = -std::log(dividendDiscount1)/t;

        DiscountFactor dividendDiscount2 =
            process2_->dividendYield()->discount(exercise->lastDate());
        Rate q2 = -std::log(dividendDiscount2)/t;

        ext::shared_ptr<YieldTermStructure> qTS(
                                            new FlatForward(today, q1, rfdc));

        ext::shared_ptr<YieldTermStructure> rTS(
                                            new FlatForward(today, q2, rfdc));

        Real variance1 = process1_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s1);
        Real variance2 = process2_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s2);
        Real variance = variance1 + variance2
                      - 2*rho_*std::sqrt(variance1)*std::sqrt(variance2);
        Volatility volatility = std::sqrt(variance/t);

        ext::shared_ptr<BlackVolTermStructure> volTS(
               new BlackConstantVol(today, NullCalendar(), volatility, rfdc));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                     new BjerksundStenslandApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        results_.value = option.NPV();
    }

}
]]></document_content>
  </document>
  <document index="227">
    <source>exoticoptions/analyticamericanmargrabeengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticamericanmargrabeengine.hpp
    \brief Analytic engine for American Margrabe option
*/

#ifndef quantlib_analytic_american_margrabe_engine_hpp
#define quantlib_analytic_american_margrabe_engine_hpp

#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for American Margrabe option
    /*! This class implements formulae from
        "The Value of an American Option to Exchange One Asset for Another",
        W. Margrabe,
        Journal of Finance, 33, 177-86.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticAmericanMargrabeEngine : public MargrabeOption::engine {
      public:
        AnalyticAmericanMargrabeEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                       ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                       Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="228">
    <source>exoticoptions/analyticcomplexchooserengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analyticcomplexchooserengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <utility>

using std::pow;
using std::log;
using std::exp;
using std::sqrt;

namespace QuantLib {

    AnalyticComplexChooserEngine::AnalyticComplexChooserEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticComplexChooserEngine::calculate() const {
        results_.value = ComplexChooser();
    }

    Real AnalyticComplexChooserEngine::ComplexChooser() const{
        Real S = process_->x0();
        Real b;
        Real v;
        Real Xc = arguments_.strikeCall;
        Real Xp = arguments_.strikePut;
        Time T = choosingTime();
        Time Tc = callMaturity()-choosingTime();
        Time Tp = putMaturity()-choosingTime();

        Real i = CriticalValueChooser();

        b = riskFreeRate(choosingTime()) - dividendYield(choosingTime());
        v = volatility(T);
        Real d1 = (log(S / i) + (b + pow(v, 2) / 2)*T) / (v*sqrt(T));
        Real d2 = d1 - v*sqrt(T);

        b = riskFreeRate(callMaturity()) - dividendYield(callMaturity());
        v = volatility(Tc);
        Real y1 = (log(S / Xc) + (b + pow(v, 2) / 2)*Tc) / (v*sqrt(Tc));

        b = riskFreeRate(putMaturity()) - dividendYield(putMaturity());
        v = volatility(Tp);
        Real y2 = (log(S / Xp) + (b + pow(v, 2) / 2)*Tp) / (v*sqrt(Tp));

        Real rho1 = sqrt(T / Tc);
        Real rho2 = sqrt(T / Tp);
        b = riskFreeRate(callMaturity()) - dividendYield(callMaturity());
        Real r = riskFreeRate(callMaturity());
        Real ComplexChooser = S * exp((b - r)*Tc) *  BivariateCumulativeNormalDistributionDr78(rho1)(d1, y1)
            - Xc * exp(-r*Tc)*BivariateCumulativeNormalDistributionDr78(rho1)(d2, y1 - v * sqrt(Tc)) ;
        b = riskFreeRate(putMaturity()) - dividendYield(putMaturity());
        r = riskFreeRate(putMaturity());
        ComplexChooser-= S * exp((b - r)*Tp) * BivariateCumulativeNormalDistributionDr78(rho2)(-d1, -y2);
        ComplexChooser+= Xp * exp(-r*Tp) * BivariateCumulativeNormalDistributionDr78(rho2)(-d2, -y2 + v * sqrt(Tp));
        return ComplexChooser;
    }

    BlackScholesCalculator AnalyticComplexChooserEngine::bsCalculator(
                                   Real spot, Option::Type optionType) const {
        Real vol;
        DiscountFactor growth;
        DiscountFactor discount;

        //payoff
        ext::shared_ptr<PlainVanillaPayoff > vanillaPayoff;
        if (optionType == Option::Call){
            //TC-T
            Time t=callMaturity()-choosingTime()-choosingTime();
            vanillaPayoff = ext::make_shared<PlainVanillaPayoff>(
                                          Option::Call, strike(Option::Call));
            //QuantLib requires sigma * sqrt(T) rather than just sigma/volatility
            vol = volatility(t) * std::sqrt(t);
            growth = dividendDiscount(t);
            discount = riskFreeDiscount(t);
        } else{
            Time t=putMaturity()-choosingTime()-choosingTime();
            vanillaPayoff = ext::make_shared<PlainVanillaPayoff>(
                                            Option::Put, strike(Option::Put));
            vol = volatility(t) * std::sqrt(t);
            growth = dividendDiscount(t);
            discount = riskFreeDiscount(t);
        }

        BlackScholesCalculator bs(vanillaPayoff, spot, growth, vol, discount);
        return bs;
    }

    Real AnalyticComplexChooserEngine::CriticalValueChooser() const{
        Real Sv = process_->x0();

        BlackScholesCalculator bs=bsCalculator(Sv,Option::Call);
        Real ci = bs.value();
        Real dc = bs.delta();

        bs=bsCalculator(Sv,Option::Put);
        Real Pi = bs.value();
        Real dp = bs.delta();

        Real yi = ci - Pi;
        Real di = dc - dp;
        Real epsilon = 0.001;

        //Newton-Raphson process
        while (std::fabs(yi) > epsilon){
            Sv = Sv - yi / di;

            bs=bsCalculator(Sv,Option::Call);
            ci = bs.value();
            dc = bs.delta();

            bs=bsCalculator(Sv,Option::Put);
            Pi = bs.value();
            dp = bs.delta();

            yi = ci - Pi;
            di = dc - dp;
        }
        return Sv;
    }


    Real AnalyticComplexChooserEngine::strike(Option::Type optionType) const {
        if (optionType == Option::Call)
            return arguments_.strikeCall;
        else
            return arguments_.strikePut;
    }

    Time AnalyticComplexChooserEngine::choosingTime() const {
        return process_->time(arguments_.choosingDate);
    }

    Time AnalyticComplexChooserEngine::putMaturity() const {
        return process_->time(arguments_.exercisePut->lastDate());
    }

    Time AnalyticComplexChooserEngine::callMaturity() const {
        return process_->time(arguments_.exerciseCall->lastDate());
    }

    Volatility AnalyticComplexChooserEngine::volatility(Time t) const {
        return process_->blackVolatility()->blackVol(t, arguments_.strikeCall);
    }

    Rate AnalyticComplexChooserEngine::dividendYield(Time t) const {
        return process_->dividendYield()->zeroRate(t, Continuous, NoFrequency);
    }

    DiscountFactor AnalyticComplexChooserEngine::dividendDiscount(Time t) const {
        return process_->dividendYield()->discount(t);
    }

    Rate AnalyticComplexChooserEngine::riskFreeRate(Time t) const {
        return process_->riskFreeRate()->zeroRate(t, Continuous, NoFrequency);
    }

    DiscountFactor AnalyticComplexChooserEngine::riskFreeDiscount(Time t) const {
        return process_->riskFreeRate()->discount(t);
    }

}
]]></document_content>
  </document>
  <document index="229">
    <source>exoticoptions/analyticcomplexchooserengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcomplexchooserengine.hpp
    \brief Analytic engine for complex chooser option
*/

#ifndef quantlib_analytic_complex_chooser_engine_hpp
#define quantlib_analytic_complex_chooser_engine_hpp

#include <ql/experimental/exoticoptions/complexchooseroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    class AnalyticComplexChooserEngine : public ComplexChooserOption::engine {
      public:
        explicit AnalyticComplexChooserEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real strike(Option::Type optionType) const;
        Time choosingTime() const;
        Time putMaturity() const;
        Time callMaturity() const;
        Volatility volatility(Time t) const;

        Rate dividendYield(Time t) const;
        DiscountFactor dividendDiscount(Time t) const;

        Rate riskFreeRate(Time t) const;
        DiscountFactor riskFreeDiscount(Time t) const;

        BlackScholesCalculator bsCalculator(Real spot,
                                            Option::Type optionType) const;
        Real CriticalValueChooser() const;
        Real ComplexChooser() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="230">
    <source>exoticoptions/analyticcompoundoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/analyticcompoundoptionengine.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        // Helper Class needed to solve an implicit problem of finding a
        // spot to a corresponding option price.
        class ImpliedSpotHelper {
          public:
            ImpliedSpotHelper(DiscountFactor dividendDiscount,
                              DiscountFactor riskFreeDiscount,
                              Real standardDeviation,
                              ext::shared_ptr<PlainVanillaPayoff> payoff,
                              Real strike)
            : dividendDiscount_(dividendDiscount), riskFreeDiscount_(riskFreeDiscount),
              standardDeviation_(standardDeviation), strike_(strike), payoff_(std::move(payoff)) {}
            Real operator()(Real spot) const {
                Real forwardPrice = spot*dividendDiscount_/riskFreeDiscount_;
                Real value = blackFormula(payoff_, forwardPrice,
                                          standardDeviation_,riskFreeDiscount_);
                return value - strike_;
            }
          private:
            DiscountFactor dividendDiscount_;
            DiscountFactor riskFreeDiscount_;
            Real standardDeviation_;
            Real strike_;
            ext::shared_ptr<PlainVanillaPayoff> payoff_;
        };

    }

    AnalyticCompoundOptionEngine::AnalyticCompoundOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticCompoundOptionEngine::calculate() const {

        QL_REQUIRE(strikeDaughter()>0.0,
                   "Daughter strike must be positive");

        QL_REQUIRE(strikeMother()>0.0,
                   "Mother strike must be positive");

        QL_REQUIRE(spot() >= 0.0, "negative or null underlying given");

        /* Solver Setup ***************************************************/
        Date helpDate(process_->riskFreeRate()->referenceDate());
        Date helpMaturity=helpDate+(maturityDaughter()-maturityMother())*Days;
        Real vol =process_->blackVolatility()->blackVol(helpMaturity,
                                                        strikeDaughter());

        Time helpTimeToMat=process_->time(helpMaturity);
        vol=vol*std::sqrt(helpTimeToMat);

        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(helpMaturity);

        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(helpMaturity);


        ext::shared_ptr<ImpliedSpotHelper> f(
                new ImpliedSpotHelper(dividendDiscount, riskFreeDiscount,
                                      vol, payoffDaughter(), strikeMother()));

        Brent solver;
        solver.setMaxEvaluations(1000);
        Real accuracy = 1.0e-6;

        Real sSolved=solver.solve(*f, accuracy, strikeDaughter(), 1.0e-6, strikeDaughter()*1000.0);
        Real X=transformX(sSolved); // transform stock to return as in Wystup's book
        /* Solver Setup Finished*****************************************/

        Real phi=typeDaughter(); // -1 or 1
        Real w=typeMother(); // -1 or 1

        Real rho=std::sqrt(residualTimeMother()/residualTimeDaughter());
        BivariateCumulativeNormalDistributionDr78 N2(w*rho) ;

        DiscountFactor ddD=dividendDiscountDaughter();
        DiscountFactor rdD=riskFreeDiscountDaughter();
        //DiscountFactor ddM=dividendDiscountMother();
        DiscountFactor rdM=riskFreeDiscountMother();

        Real XmSM=X-stdDeviationMother();
        Real S=spot();
        Real dP=dPlus();
        Real dPT12=dPlusTau12(sSolved);
        Real vD=volatilityDaughter();

        Real dM=dMinus();
        Real strD=strikeDaughter();
        Real strM=strikeMother();
        Real rTM=residualTimeMother();
        Real rTD=residualTimeDaughter();

        Real rD=riskFreeRateDaughter();
        Real dD=dividendRateDaughter();

        Real N2XmSM=N2(-phi*w*XmSM,phi*dP);
        Real N2X=N2(-phi*w*X,phi*dM);
        Real NeX=N_(-phi*w*e(X));
        Real NX=N_(-phi*w*X);
        Real NT12=N_(phi*dPT12);
        Real ndP=n_(dP);
        Real nXm=n_(XmSM);
        Real invMTime=1/std::sqrt(rTM);
        Real invDTime=1/std::sqrt(rTD);

        Real tempRes=phi*w*S*ddD*N2XmSM-phi*w*strD*rdD*N2X-w*strM*rdM*NX;
        Real tempDelta=phi*w*ddD*N2XmSM;
        Real tempGamma=(ddD/(vD*S))*(invMTime*nXm*NT12+w*invDTime*ndP*NeX);
        Real tempVega=ddD*S*((1/invMTime)*nXm*NT12+w*(1/invDTime)*ndP*NeX);
        Real tempTheta=phi*w*dD*S*ddD*N2XmSM-phi*w*rD*strD*rdD*N2X-w*rD*strM*rdM*NX;
        tempTheta-=0.5*vD*S*ddD*(invMTime*nXm*NT12+w*invDTime*ndP*NeX);

        results_.value=tempRes;
        results_.delta=tempDelta;
        results_.gamma=tempGamma;
        results_.vega=tempVega;
        results_.theta=tempTheta;
    }

    Real AnalyticCompoundOptionEngine::typeDaughter() const {
        // returns -1 or 1 according to put or call
        return (Real) payoffDaughter()->optionType();
    }

    Real AnalyticCompoundOptionEngine::typeMother() const {
        return (Real) payoffMother()->optionType();
    }

    Date AnalyticCompoundOptionEngine::maturityDaughter() const {
        return arguments_.daughterExercise->lastDate();
    }

    Date AnalyticCompoundOptionEngine::maturityMother() const {
        return arguments_.exercise->lastDate();
    }

    Time AnalyticCompoundOptionEngine::residualTimeDaughter() const {
        return process_->time(maturityDaughter());
    }

    Time AnalyticCompoundOptionEngine::residualTimeMother() const {
        return process_->time(maturityMother());
    }

    Time AnalyticCompoundOptionEngine::residualTimeMotherDaughter() const {
        return residualTimeDaughter()-residualTimeMother();
    }


    Real AnalyticCompoundOptionEngine::volatilityDaughter() const {
        return process_->blackVolatility()->blackVol(maturityDaughter(),
                                                     strikeDaughter());
    }


    Real AnalyticCompoundOptionEngine::volatilityMother() const {
        return process_->blackVolatility()->blackVol(maturityMother(),
                                                     strikeMother());
    }

    Real AnalyticCompoundOptionEngine::stdDeviationDaughter() const {
        return volatilityDaughter()*std::sqrt(residualTimeDaughter());
    }

    Real AnalyticCompoundOptionEngine::stdDeviationMother() const {
        return volatilityMother()*std::sqrt(residualTimeMother());
    }


    ext::shared_ptr<PlainVanillaPayoff>
    AnalyticCompoundOptionEngine::payoffDaughter() const {
        ext::shared_ptr<PlainVanillaPayoff> dPayoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                   arguments_.daughterPayoff);
        QL_REQUIRE(dPayoff, "non-plain payoff given");
        return dPayoff;
    }

    ext::shared_ptr<PlainVanillaPayoff>
    AnalyticCompoundOptionEngine::payoffMother() const {
        ext::shared_ptr<PlainVanillaPayoff> mPayoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(mPayoff, "non-plain payoff given");
        return mPayoff;
    }

    Real AnalyticCompoundOptionEngine::strikeMother() const {
        return payoffMother()->strike();
    }

    Real AnalyticCompoundOptionEngine::strikeDaughter() const {
        return payoffDaughter()->strike();
    }

    DiscountFactor AnalyticCompoundOptionEngine::riskFreeDiscountDaughter() const {
        return process_->riskFreeRate()->discount(residualTimeDaughter());
    }

    DiscountFactor AnalyticCompoundOptionEngine::riskFreeDiscountMother() const {
        return process_->riskFreeRate()->discount(residualTimeMother());
    }

    DiscountFactor AnalyticCompoundOptionEngine::riskFreeDiscountMotherDaughter() const {
        return process_->riskFreeRate()->discount(residualTimeMotherDaughter());
    }

    DiscountFactor AnalyticCompoundOptionEngine::dividendDiscountDaughter() const {
        return process_->dividendYield()->discount(residualTimeDaughter());
    }

    DiscountFactor AnalyticCompoundOptionEngine::dividendDiscountMother() const {
        return process_->dividendYield()->discount(residualTimeMother());
    }

    DiscountFactor AnalyticCompoundOptionEngine::dividendDiscountMotherDaughter() const {
        return process_->dividendYield()->discount(residualTimeMotherDaughter());
    }

    Real AnalyticCompoundOptionEngine::dPlus() const {
        Real forward = spot() * dividendDiscountDaughter() / riskFreeDiscountDaughter();
        Real sd=stdDeviationDaughter();
        return std::log(forward/strikeDaughter())/sd+0.5*sd;
    }

    Real AnalyticCompoundOptionEngine::dMinus() const {
        return dPlus()-stdDeviationDaughter();
    }

    Real AnalyticCompoundOptionEngine::dPlusTau12(Real S) const {
        Real forward = S * dividendDiscountMotherDaughter() / riskFreeDiscountMotherDaughter();
        Real sd=volatilityDaughter()*std::sqrt(residualTimeMotherDaughter());
        return std::log(forward/strikeDaughter())/sd+0.5*sd;
    }

    Real AnalyticCompoundOptionEngine::spot() const {
        return process_->x0();
    }

    Real AnalyticCompoundOptionEngine::riskFreeRateDaughter() const {
        return process_->riskFreeRate()->zeroRate(residualTimeDaughter(),
                                                  Continuous,
                                                  NoFrequency);
    }

    Real AnalyticCompoundOptionEngine::dividendRateDaughter() const {
        return process_->dividendYield()->zeroRate(residualTimeDaughter(),
                                                   Continuous,
                                                   NoFrequency);
    }

    Real AnalyticCompoundOptionEngine::transformX(Real X) const {

        Real sd=stdDeviationMother();
        Real resX=riskFreeDiscountMother()*X/(spot()*dividendDiscountMother());
        resX=resX*std::exp(0.5*sd*sd);
        resX=std::log(resX);

        return resX/sd;
    }

    Real AnalyticCompoundOptionEngine::e(Real X) const {
        Real rtM=residualTimeMother();
        Real rtD=residualTimeDaughter();

        return (X*std::sqrt(rtD)+std::sqrt(rtM)*dMinus())/std::sqrt(rtD-rtM);
    }

}
]]></document_content>
  </document>
  <document index="231">
    <source>exoticoptions/analyticcompoundoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcompoundoptionengine.hpp
    \brief Analytic compound option engines
*/

#ifndef quantlib_analytic_compound_option_engine_hpp
#define quantlib_analytic_compound_option_engine_hpp

#include <ql/experimental/exoticoptions/compoundoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for compound options using analytical formulae
    /*! The formulas are taken from "Foreign Exchange Risk",
        Uwe Wystup, Risk 2002, where closed form Greeks are available.
        (not available in Haug 2007).
        Value: Page 84, Greeks: Pages 94-95.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticCompoundOptionEngine : public CompoundOption::engine {
      public:
        explicit AnalyticCompoundOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        CumulativeNormalDistribution N_;
        NormalDistribution n_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;

        // helper methods
        Time residualTimeMother() const;
        Time residualTimeDaughter() const;
        Time residualTimeMotherDaughter() const;

        Date maturityMother() const;
        Date maturityDaughter() const;

        Real dPlus() const;
        Real dMinus() const;

        Real dPlusTau12(Real S) const;
        Real dMinusTau12() const;

        Real strikeDaughter() const;
        Real strikeMother() const;

        Real spot() const;

        Real volatilityDaughter() const;
        Real volatilityMother() const;

        Real riskFreeRateDaughter() const;
        Real dividendRateDaughter() const;

        Real stdDeviationDaughter() const;
        Real stdDeviationMother() const;

        Real typeDaughter() const;
        Real typeMother() const;

        Real transformX(Real X) const;
        Real e(Real X) const;

        DiscountFactor riskFreeDiscountDaughter() const;
        DiscountFactor riskFreeDiscountMother() const;
        DiscountFactor riskFreeDiscountMotherDaughter() const;

        DiscountFactor dividendDiscountDaughter() const;
        DiscountFactor dividendDiscountMother() const;
        DiscountFactor dividendDiscountMotherDaughter() const;

        ext::shared_ptr<PlainVanillaPayoff> payoffMother() const;
        ext::shared_ptr<PlainVanillaPayoff> payoffDaughter() const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="232">
    <source>exoticoptions/analyticeuropeanmargrabeengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analyticeuropeanmargrabeengine.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    AnalyticEuropeanMargrabeEngine::AnalyticEuropeanMargrabeEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(correlation) {
        registerWith(process1_);
        registerWith(process2_);
    }

    void AnalyticEuropeanMargrabeEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European Option");

        ext::shared_ptr<NullPayoff> payoff =
            ext::dynamic_pointer_cast<NullPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non a Null Payoff type");

        Integer quantity1 = arguments_.Q1;
        Integer quantity2 = arguments_.Q2;

        Real s1  = process1_->stateVariable()->value();
        Real s2  = process2_->stateVariable()->value();

        Real variance1 = process1_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s1);
        Real variance2 = process2_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s2);

        DiscountFactor riskFreeDiscount =
            process1_->riskFreeRate()->discount(exercise->lastDate());

        DiscountFactor dividendDiscount1 =
            process1_->dividendYield()->discount(exercise->lastDate());
        DiscountFactor dividendDiscount2 =
            process2_->dividendYield()->discount(exercise->lastDate());

        Real forward1 = process1_->stateVariable()->value() *
            dividendDiscount1 / riskFreeDiscount;
        Real forward2 = process2_->stateVariable()->value() *
            dividendDiscount2 / riskFreeDiscount;

        Real stdDev1 = std::sqrt(variance1);
        Real stdDev2 = std::sqrt(variance2);
        Real variance = variance1 + variance2 - 2*rho_*stdDev1*stdDev2;
        Real stdDev = std::sqrt(variance);
        Real d1 = (std::log((quantity1*forward1)/(quantity2*forward2))
                   + 0.5*variance) / stdDev;
        Real d2 = d1 - stdDev;
        Real Nd1, Nd2, nd1, nd2;
        CumulativeNormalDistribution cum;
        NormalDistribution norm;
        Nd1 = cum(d1);
        Nd2 = cum(d2);
        nd1 = norm(d1);
        nd2 = norm(d2);
        DayCounter rfdc  = process1_->riskFreeRate()->dayCounter();
        Time t = rfdc.yearFraction(process1_->riskFreeRate()->referenceDate(),
                                  arguments_.exercise->lastDate());
        Real sqt = std::sqrt(t);
        Real q1  = -std::log(dividendDiscount1)/(sqt*sqt);
        Real q2  = -std::log(dividendDiscount2)/(sqt*sqt);

        results_.value =
            riskFreeDiscount * (quantity1*forward1*Nd1 - quantity2*forward2*Nd2);

        // Greeks
        results_.delta1 = riskFreeDiscount*(quantity1*forward1*Nd1)/s1;
        results_.delta2 = -riskFreeDiscount*(quantity2*forward2*Nd2)/s2;
        results_.gamma1 = (riskFreeDiscount*(quantity1*forward1*nd1)/s1)/(quantity1*s1*stdDev);
        results_.gamma2 = (-riskFreeDiscount*(quantity2*forward2*nd2)/s2)/(-quantity2*s2*stdDev);
        Real vega       = riskFreeDiscount*(quantity1*forward1*nd1)*sqt;
        results_.theta  = -((stdDev*vega/sqt)/(2*t)-(q1*quantity1*s1*results_.delta1)-(q2*quantity2*s2*results_.delta2));
        results_.rho    = 0.0;
    }

}
]]></document_content>
  </document>
  <document index="233">
    <source>exoticoptions/analyticeuropeanmargrabeengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticeuropeanmargrabeengine.hpp
    \brief Analytic engine for European Margrabe option
*/

#ifndef quantlib_analytic_european_margrabe_engine_hpp
#define quantlib_analytic_european_margrabe_engine_hpp

#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for European Margrabe option
    /*! This class implements formulae from
        "The Value of an Option to Exchange One Asset for Another",
        W. Margrabe,
        Journal of Finance, 33 (March 1978), 177-186.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticEuropeanMargrabeEngine : public MargrabeOption::engine {
      public:
        AnalyticEuropeanMargrabeEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                       ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                       Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="234">
    <source>exoticoptions/analyticholderextensibleoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analyticholderextensibleoptionengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <utility>

using std::pow;
using std::log;
using std::exp;
using std::sqrt;

namespace QuantLib {

    AnalyticHolderExtensibleOptionEngine::AnalyticHolderExtensibleOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticHolderExtensibleOptionEngine::calculate() const {
        //Spot
        Real S = process_->x0();
        Real r = riskFreeRate();
        Real b = r - dividendYield();
        Real X1 = strike();
        Real X2 = arguments_.secondStrike;
        Time T2 = secondExpiryTime();
        Time t1 = firstExpiryTime();
        Real A = arguments_.premium;


        Real z1 = this->z1();

        Real z2 = this->z2();

        Real rho = sqrt(t1 / T2);


        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);

        //QuantLib requires sigma * sqrt(T) rather than just sigma/volatility
        Real vol = volatility();

        //calculate dividend discount factor assuming continuous compounding (e^-rt)
        DiscountFactor growth = dividendDiscount(t1);
        //calculate payoff discount factor assuming continuous compounding
        DiscountFactor discount = riskFreeDiscount(t1);
        Real result = 0;
        Real minusInf=-std::numeric_limits<Real>::infinity();

        Real y1 = this->y1(payoff->optionType()),
             y2 = this->y2(payoff->optionType());
        if (payoff->optionType() == Option::Call) {
            //instantiate payoff function for a call
            ext::shared_ptr<PlainVanillaPayoff> vanillaCallPayoff =
                ext::make_shared<PlainVanillaPayoff>(Option::Call, X1);
            Real BSM = BlackScholesCalculator(vanillaCallPayoff, S, growth, vol*sqrt(t1), discount).value();
            result = BSM
                + S*exp((b - r)*T2)*M2(y1, y2, minusInf, z1, rho)
                - X2*exp(-r*T2)*M2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1), minusInf, z1 - vol*sqrt(T2), rho)
                - S*exp((b - r)*t1)*N2(y1, z2) + X1*exp(-r*t1)*N2(y1 - vol*sqrt(t1), z2 - vol*sqrt(t1))
                - A*exp(-r*t1)*N2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1));
        } else {
            //instantiate payoff function for a call
            ext::shared_ptr<PlainVanillaPayoff> vanillaPutPayoff =
                ext::make_shared<PlainVanillaPayoff>(Option::Put, X1);
            result = BlackScholesCalculator(vanillaPutPayoff, S, growth, vol*sqrt(t1), discount).value()
                - S*exp((b - r)*T2)*M2(y1, y2, minusInf, -z1, rho)
                + X2*exp(-r*T2)*M2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1), minusInf, -z1 + vol*sqrt(T2), rho)
                + S*exp((b - r)*t1)*N2(z2, y2) - X1*exp(-r*t1)*N2(z2 - vol*sqrt(t1), y2 - vol*sqrt(t1))
                - A*exp(-r*t1)*N2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1));
        }
        this->results_.value = result;
    }

    Real AnalyticHolderExtensibleOptionEngine::I1Call() const {
        Real Sv = process_->x0();
        Real A = arguments_.premium;

        if(A==0)
        {
            return 0;
        }
        else
        {
            BlackScholesCalculator bs = bsCalculator(Sv, Option::Call);
            Real ci = bs.value();
            Real dc = bs.delta();

            Real yi = ci - A;
            //da/ds = 0
            Real di = dc - 0;
            Real epsilon = 0.001;

            //Newton-Raphson process
            while (std::fabs(yi) > epsilon){
                Sv = Sv - yi / di;

                bs = bsCalculator(Sv, Option::Call);
                ci = bs.value();
                dc = bs.delta();

                yi = ci - A;
                di = dc - 0;
            }
            return Sv;
        }
    }

    Real AnalyticHolderExtensibleOptionEngine::I2Call() const {
        Real Sv = process_->x0();
        Real X1 = strike();
        Real X2 = arguments_.secondStrike;
        Real A = arguments_.premium;
        Time T2 = secondExpiryTime();
        Time t1 = firstExpiryTime();
        Real r=riskFreeRate();

        Real val=X1-X2*std::exp(-r*(T2-t1));
        if(A< val){
            return std::numeric_limits<Real>::infinity();
        } else {
            BlackScholesCalculator bs = bsCalculator(Sv, Option::Call);
            Real ci = bs.value();
            Real dc = bs.delta();

            Real yi = ci - A - Sv + X1;
            //da/ds = 1
            Real di = dc - 1;
            Real epsilon = 0.001;

            //Newton-Raphson process
            while (std::fabs(yi) > epsilon){
                Sv = Sv - yi / di;

                bs = bsCalculator(Sv, Option::Call);
                ci = bs.value();
                dc = bs.delta();

                yi = ci - A - Sv + X1;
                di = dc - 1;
            }
            return Sv;
        }
    }

    Real AnalyticHolderExtensibleOptionEngine::I1Put() const {
        Real Sv = process_->x0();
        //Srtike
        Real X1 = strike();
        //Premium
        Real A = arguments_.premium;

        BlackScholesCalculator bs = bsCalculator(Sv, Option::Put);
        Real pi = bs.value();
        Real dc = bs.delta();

        Real yi = pi - A + Sv - X1;
        //da/ds = 1
        Real di = dc - 1;
        Real epsilon = 0.001;

        //Newton-Raphson prosess
        while (std::fabs(yi) > epsilon){
            Sv = Sv - yi / di;

            bs = bsCalculator(Sv, Option::Put);
            pi = bs.value();
            dc = bs.delta();

            yi = pi - A + Sv - X1;
            di = dc - 1;
        }
        return Sv;
    }

    Real AnalyticHolderExtensibleOptionEngine::I2Put() const {
        Real Sv = process_->x0();
        Real A = arguments_.premium;
        if(A==0){
            return std::numeric_limits<Real>::infinity();
        }
        else{
            BlackScholesCalculator bs = bsCalculator(Sv, Option::Put);
            Real pi = bs.value();
            Real dc = bs.delta();

            Real yi = pi - A;
            //da/ds = 0
            Real di = dc - 0;
            Real epsilon = 0.001;

            //Newton-Raphson prosess
            while (std::fabs(yi) > epsilon){
                Sv = Sv - yi / di;

                bs = bsCalculator(Sv, Option::Put);
                pi = bs.value();
                dc = bs.delta();

                yi = pi - A;
                di = dc - 0;
            }
            return Sv;
        }
    }


    BlackScholesCalculator AnalyticHolderExtensibleOptionEngine::bsCalculator(
                                    Real spot, Option::Type optionType) const {
        //Real spot = process_->x0();
        Real vol;
        DiscountFactor growth;
        DiscountFactor discount;
        Real X2 = arguments_.secondStrike;
        Time T2 = secondExpiryTime();
        Time t1 = firstExpiryTime();
        Time t = T2 - t1;

        //payoff
        ext::shared_ptr<PlainVanillaPayoff > vanillaPayoff =
            ext::make_shared<PlainVanillaPayoff>(optionType, X2);

        //QuantLib requires sigma * sqrt(T) rather than just sigma/volatility
        vol = volatility() * std::sqrt(t);
        //calculate dividend discount factor assuming continuous compounding (e^-rt)
        growth = dividendDiscount(t);
        //calculate payoff discount factor assuming continuous compounding
        discount = riskFreeDiscount(t);

        BlackScholesCalculator bs(vanillaPayoff, spot, growth, vol, discount);
        return bs;
    }

    Real AnalyticHolderExtensibleOptionEngine::M2(Real a, Real b, Real c, Real d, Real rho) const {
        BivariateCumulativeNormalDistributionDr78 CmlNormDist(rho);
        return CmlNormDist(b, d) - CmlNormDist(a, d) - CmlNormDist(b, c) + CmlNormDist(a,c);
    }

    Real AnalyticHolderExtensibleOptionEngine::N2(Real a, Real b) const {
        CumulativeNormalDistribution  NormDist;
        return NormDist(b) - NormDist(a);
    }

    Real AnalyticHolderExtensibleOptionEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticHolderExtensibleOptionEngine::firstExpiryTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Time AnalyticHolderExtensibleOptionEngine::secondExpiryTime() const {
        return process_->time(arguments_.secondExpiryDate);
    }

    Volatility AnalyticHolderExtensibleOptionEngine::volatility() const {
        return process_->blackVolatility()->blackVol(firstExpiryTime(), strike());
    }
    Rate AnalyticHolderExtensibleOptionEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(firstExpiryTime(), Continuous,
            NoFrequency);
    }
    Rate AnalyticHolderExtensibleOptionEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(firstExpiryTime(),
            Continuous, NoFrequency);
    }

    DiscountFactor AnalyticHolderExtensibleOptionEngine::dividendDiscount(Time t) const {
        return process_->dividendYield()->discount(t);
    }

    DiscountFactor AnalyticHolderExtensibleOptionEngine::riskFreeDiscount(Time t) const {
        return process_->riskFreeRate()->discount(t);
    }

    Real AnalyticHolderExtensibleOptionEngine::y1(Option::Type type) const {
        Real S = process_->x0();
        Real I2 = (type == Option::Call) ? I2Call() : I2Put();

        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time t1 = firstExpiryTime();

        return (log(S / I2) + (b + pow(vol, 2) / 2)*t1) / (vol*sqrt(t1));
    }

    Real AnalyticHolderExtensibleOptionEngine::y2(Option::Type type) const {
        Real S = process_->x0();
        Real I1 = (type == Option::Call) ? I1Call() : I1Put();

        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time t1 = firstExpiryTime();

        return (log(S / I1) + (b + pow(vol, 2) / 2)*t1) / (vol*sqrt(t1));
    }

    Real AnalyticHolderExtensibleOptionEngine::z1() const {
        Real S = process_->x0();
        Real X2 = arguments_.secondStrike;
        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time T2 = secondExpiryTime();

        return (log(S / X2) + (b + pow(vol, 2) / 2)*T2) / (vol*sqrt(T2));
    }

    Real AnalyticHolderExtensibleOptionEngine::z2() const {
        Real S = process_->x0();
        Real X1 = strike();

        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time t1 = firstExpiryTime();

        return (log(S / X1) + (b + pow(vol, 2) / 2)*t1) / (vol*sqrt(t1));
    }

}
]]></document_content>
  </document>
  <document index="235">
    <source>exoticoptions/analyticholderextensibleoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticholderextensibleoptionengine.hpp
    \brief Analytic engine for holder-extensible options
*/

#ifndef quantlib_analytic_holder_extensible_option_engine_hpp
#define quantlib_analytic_holder_extensible_option_engine_hpp

#include <ql/experimental/exoticoptions/holderextensibleoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    class AnalyticHolderExtensibleOptionEngine
        : public HolderExtensibleOption::engine {
      public:
        explicit AnalyticHolderExtensibleOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real strike() const;
        Time firstExpiryTime() const;
        Time secondExpiryTime() const;
        Volatility volatility() const;
        Rate riskFreeRate() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount(Time t) const;
        DiscountFactor riskFreeDiscount(Time t) const;
        Real I1Call() const;
        Real I2Call() const;
        Real I1Put() const;
        Real I2Put() const;
        BlackScholesCalculator bsCalculator(Real spot, Option::Type optionType) const;
        Real M2(Real a, Real b, Real c, Real d, Real rho) const;
        Real N2(Real a, Real b) const;
        Real y1(Option::Type) const;
        Real y2(Option::Type) const;
        Real z1() const;
        Real z2() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="236">
    <source>exoticoptions/analyticpartialtimebarrieroptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analyticpartialtimebarrieroptionengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticPartialTimeBarrierOptionEngine::AnalyticPartialTimeBarrierOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticPartialTimeBarrierOptionEngine::calculate() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0,
                   "strike must be positive");

        Real spot = process_->x0();
        QL_REQUIRE(spot >= 0.0, "negative or null underlying given");

        PartialBarrier::Type barrierType = arguments_.barrierType;
        PartialBarrier::Range barrierRange = arguments_.barrierRange;

        switch (payoff->optionType()) {
          //Call Option
          case Option::Call:
            switch (barrierType) {
              case PartialBarrier::DownOut:
                switch (barrierRange) {
                  case PartialBarrier::Start:
                    results_.value = CA(1);
                    break;
                  case PartialBarrier::EndB1:
                    results_.value = CoB1();
                    break;
                  case PartialBarrier::EndB2:
                    results_.value = CoB2(PartialBarrier::DownOut);
                    break;
                  default:
                    QL_FAIL("invalid barrier range");
                }
                break;

              case PartialBarrier::DownIn:
                switch (barrierRange) {
                  case PartialBarrier::Start:
                    results_.value = CIA(1);
                    break;
                  case PartialBarrier::End:
                    QL_FAIL("Down-and-in partial-time end barrier is not implemented");
                  default:
                    QL_FAIL("invalid barrier range");
                }
                break;

              case PartialBarrier::UpOut:
                switch (barrierRange) {
                  case PartialBarrier::Start:
                    results_.value = CA(-1);
                    break;
                  case PartialBarrier::EndB1:
                    results_.value = CoB1();
                    break;
                  case PartialBarrier::EndB2:
                    results_.value = CoB2(PartialBarrier::UpOut);
                    break;
                  default:
                    QL_FAIL("invalid barrier range");
                }
                break;

              case PartialBarrier::UpIn:
                switch (barrierRange) {
                  case PartialBarrier::Start:
                    results_.value = CIA(-1);
                    break;
                  case PartialBarrier::End:
                    QL_FAIL("Up-and-in partial-time end barrier is not implemented");
                  default:
                    QL_FAIL("invalid barrier range");
                }
                break;
              default:
                QL_FAIL("unknown barrier type");
            }
            break;

          case Option::Put:
            QL_FAIL("Partial-time barrier Put option is not implemented");

          default:
            QL_FAIL("unknown option type");
        }
    }

    Real AnalyticPartialTimeBarrierOptionEngine::CoB2(
                                      PartialBarrier::Type barrierType) const {
        Real result = 0.0;
        Real b = riskFreeRate()-dividendYield();
        if (strike()<barrier()){
            switch (barrierType) {
              case PartialBarrier::DownOut:
                result = underlying()*std::exp((b-riskFreeRate())*residualTime());
                result *= (M(g1(),e1(),rho())-HS(underlying(),barrier(),2*(mu()+1))*M(g3(),-e3(),-rho()));
                result -= strike()*std::exp(-riskFreeRate()*residualTime())*(M(g2(),e2(),rho())-HS(underlying(),barrier(),2*mu())*M(g4(),-e4(),-rho()));
                return result;

              case PartialBarrier::UpOut:
                result = underlying()*std::exp((b-riskFreeRate())*residualTime());
                result *= (M(-g1(),-e1(),rho())-HS(underlying(),barrier(),2*(mu()+1))*M(-g3(),e3(),-rho()));
                result -= strike()*std::exp(-riskFreeRate()*residualTime())*(M(-g2(),-e2(),rho())-HS(underlying(),barrier(),2*mu())*M(-g4(),e4(),-rho()));
                result -= underlying()*std::exp((b-riskFreeRate())*residualTime())*(M(-d1(),-e1(),rho())-HS(underlying(),barrier(),2*(mu()+1))*M(e3(),-f1(),-rho()));
                result += strike()*std::exp(-riskFreeRate()*residualTime())*(M(-d2(),-e2(),rho())-HS(underlying(),barrier(),2*mu())*M(e4(),-f2(),-rho()));
                return result;

              default:
                QL_FAIL("invalid barrier type");
            }
        } else {
            QL_FAIL("case of strike>barrier is not implemented for OutEnd B2 type");
        }
    }

    Real AnalyticPartialTimeBarrierOptionEngine::CoB1() const {
        Real result = 0.0;
        Real b = riskFreeRate()-dividendYield();
        if (strike()>barrier()) {
            result = underlying()*std::exp((b-riskFreeRate())*residualTime());
            result *= (M(d1(),e1(),rho())-HS(underlying(),barrier(),2*(mu()+1))*M(f1(),-e3(),-rho()));
            result -= (strike()*std::exp(-riskFreeRate()*residualTime()))*(M(d2(),e2(),rho())-HS(underlying(),barrier(),2*mu())*M(f2(),-e4(),-rho()));
            return result;
        } else {
            Real S1 = underlying()*std::exp((b-riskFreeRate())*residualTime());
            Real X1 = (strike()*std::exp(-riskFreeRate()*residualTime()));
            Real HS1 = HS(underlying(),barrier(),2*(mu()+1));
            Real HS2 = HS(underlying(), barrier(), 2 * mu());
            result = S1;
            result *= (M(-g1(),-e1(),rho())-HS1*M(-g3(),e3(),-rho()));
            result -= X1*(M(-g2(), -e2(), rho()) - HS2*M(-g4(), e4(), -rho()));
            result -= S1*(M(-d1(), -e1(), rho()) - HS1*M(-f1(), e3(), -rho()));
            result += X1*(M(-d2(), -e2(), rho()) - HS2*M(-f2(), e4(), -rho()));
            result += S1*(M(g1(), e1(), rho()) - HS1*M(g3(), -e3(), -rho()));
            result -= X1*(M(g2(), e2(), rho()) - HS2*M(g4(), -e4(), -rho()));
            return result;
        }
    }

    // eta = -1: Up-and-In Call
    // eta =  1: Down-and-In Call
    Real AnalyticPartialTimeBarrierOptionEngine::CIA(Integer eta) const {
        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);

        VanillaOption europeanOption(payoff, exercise);

        europeanOption.setPricingEngine(
                        ext::make_shared<AnalyticEuropeanEngine>(process_));

        return europeanOption.NPV() - CA(eta);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::CA(Integer eta) const {
        //Partial-Time-Start- OUT  Call Option calculation
        Real b = riskFreeRate()-dividendYield();
        Real result;
        result = underlying()*std::exp((b-riskFreeRate())*residualTime());
        result *= (M(d1(),eta*e1(),eta*rho())-HS(underlying(),barrier(),2*(mu()+1))*M(f1(),eta*e3(),eta*rho()));
        result -= (strike()*std::exp(-riskFreeRate()*residualTime())*(M(d2(),eta*e2(),eta*rho())-HS(underlying(),barrier(),2*mu())*M(f2(),eta*e4(),eta*rho())));
        return result;
    }

    Real AnalyticPartialTimeBarrierOptionEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticPartialTimeBarrierOptionEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticPartialTimeBarrierOptionEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Time AnalyticPartialTimeBarrierOptionEngine::coverEventTime() const {
        return process_->time(arguments_.coverEventDate);
    }

    Volatility AnalyticPartialTimeBarrierOptionEngine::volatility(Time t) const {
        return process_->blackVolatility()->blackVol(t, strike());
    }

    Real AnalyticPartialTimeBarrierOptionEngine::stdDeviation() const {
        Time T = residualTime();
        return volatility(T) * std::sqrt(T);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::barrier() const {
        return arguments_.barrier;
    }

    Real AnalyticPartialTimeBarrierOptionEngine::rebate() const {
        return arguments_.rebate;
    }

    Rate AnalyticPartialTimeBarrierOptionEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticPartialTimeBarrierOptionEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticPartialTimeBarrierOptionEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(), Continuous,
                                                   NoFrequency);
    }

    DiscountFactor AnalyticPartialTimeBarrierOptionEngine::dividendDiscount() const {
        return process_->dividendYield()->discount(residualTime());
    }


    Real AnalyticPartialTimeBarrierOptionEngine::f1() const {
        Real S = underlying();
        Real T = residualTime();
        Real sigma = volatility(T);
        return (std::log(S / strike()) + 2 * std::log(barrier() / S) + ((riskFreeRate()-dividendYield()) + (std::pow(sigma, 2) / 2))*T) / (sigma*std::sqrt(T));
    }

    Real AnalyticPartialTimeBarrierOptionEngine::f2() const {
        Time T = residualTime();
        return f1() - volatility(T)*std::sqrt(T);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::M(Real a,Real b,Real rho) const {
        BivariateCumulativeNormalDistributionDr78 CmlNormDist(rho);
        return CmlNormDist(a,b);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::rho() const {
        return std::sqrt(coverEventTime()/residualTime());
    }

    Rate AnalyticPartialTimeBarrierOptionEngine::mu() const {
        Volatility vol = volatility(coverEventTime());
        return ((riskFreeRate() - dividendYield()) - (vol * vol) / 2) / (vol * vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::d1() const {
        Real b = riskFreeRate()-dividendYield();
        Time T2 = residualTime();
        Volatility vol = volatility(T2);
        return (std::log(underlying()/strike())+(b+vol*vol/2)*T2)/(std::sqrt(T2)*vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::d2() const {
        Time T2 = residualTime();
        Volatility vol = volatility(T2);
        return d1() - vol*std::sqrt(T2);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e1() const {
        Real b = riskFreeRate()-dividendYield();
        Time T1 = coverEventTime();
        Volatility vol = volatility(T1);
        return (std::log(underlying()/barrier())+(b+vol*vol/2)*T1)/(std::sqrt(T1)*vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e2() const {
        Time T1 = coverEventTime();
        Volatility vol = volatility(T1);
        return e1() - vol*std::sqrt(T1);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e3() const {
        Time T1 = coverEventTime();
        Real vol = volatility(T1);
        return e1()+(2*std::log(barrier()/underlying()) /(vol*std::sqrt(T1)));
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e4() const {
        Time t = coverEventTime();
        return e3()-volatility(t)*std::sqrt(t);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g1() const {
        Real b = riskFreeRate()-dividendYield();
        Time T2 = residualTime();
        Volatility vol = volatility(T2);
        return (std::log(underlying()/barrier())+(b+vol*vol/2)*T2)/(std::sqrt(T2)*vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g2() const {
        Time T2 = residualTime();
        Volatility vol = volatility(T2);
        return g1() - vol*std::sqrt(T2);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g3() const {
        Time T2 = residualTime();
        Real vol = volatility(T2);
        return g1()+(2*std::log(barrier()/underlying()) /(vol*std::sqrt(T2)));
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g4() const {
        Time T2 = residualTime();
        Real vol = volatility(T2);
        return g3()-vol*std::sqrt(T2);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::HS(Real S, Real H, Real power) const {
        return std::pow((H/S),power);
    }

}

]]></document_content>
  </document>
  <document index="237">
    <source>exoticoptions/analyticpartialtimebarrieroptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpartialtimebarrieroptionengine.hpp
    \brief Analytic engine for partial-time barrier options
*/

#ifndef quantlib_analytic_partial_time_barrier_option_engine_hpp
#define quantlib_analytic_partial_time_barrier_option_engine_hpp

#include <ql/experimental/exoticoptions/partialtimebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class AnalyticPartialTimeBarrierOptionEngine
        : public PartialTimeBarrierOption::engine {
      public:
        explicit AnalyticPartialTimeBarrierOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Time coverEventTime() const;
        Volatility volatility(Time t) const;
        Real barrier() const;
        Real rebate() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real M(Real a,Real b,Real rho) const;
        Real d1()const;
        Real d2()const;
        Real e1() const;
        Real e2() const;
        Real e3() const;
        Real e4() const;
        Real f1() const;
        Real f2() const;
        Real rho() const;
        Rate mu() const;
        Real CoB2(PartialBarrier::Type barrierType) const;
        Real CoB1() const;
        Real CA(Integer n) const;
        Real CIA(Integer n) const;
        Real g1()const;
        Real g2()const;
        Real g3()const;
        Real g4()const;
        Real HS(Real S, Real H, Real power)const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="238">
    <source>exoticoptions/analyticpdfhestonengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014, 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpdfhestonengine.cpp
    \brief Analytic engine for arbitrary European payoffs under the Heston model
*/

#include <ql/experimental/exoticoptions/analyticpdfhestonengine.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <utility>

namespace QuantLib {

    AnalyticPDFHestonEngine::AnalyticPDFHestonEngine(ext::shared_ptr<HestonModel> model,
                                                     Real integrationEps_,
                                                     Size maxIntegrationIterations)
    : maxIntegrationIterations_(maxIntegrationIterations), integrationEps_(integrationEps_),
      model_(std::move(model)) {}

    void AnalyticPDFHestonEngine::calculate() const {
        // this is an European option pricer
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        const ext::shared_ptr<HestonProcess>& process = model_->process();

        const Time t = process->time(arguments_.exercise->lastDate());

        const Real xMax = 8.0 * std::sqrt(process->theta()*t
            + (process->v0() - process->theta())
                *(1-std::exp(-process->kappa()*t))/process->kappa());

        const Real x0 = std::log(process->s0()->value());
        const Real rD = process->riskFreeRate()->discount(t);
        const Real qD = process->dividendYield()->discount(t);

        const Real drift = x0 + std::log(rD/qD);

        results_.value = GaussLobattoIntegral(maxIntegrationIterations_, integrationEps_)(
            [&](Real _x){ return weightedPayoff(_x, t); },
            -xMax+drift, xMax+drift);
    }

    Real AnalyticPDFHestonEngine::Pv(Real x_t, Time t) const {
        return HestonRNDCalculator(
            model_->process(), integrationEps_, maxIntegrationIterations_)
                .pdf(x_t, t);
    }

    Real AnalyticPDFHestonEngine::cdf(Real s, Time t) const {
        const Real x_t = std::log(s);
        return HestonRNDCalculator(
            model_->process(), integrationEps_, maxIntegrationIterations_)
                .cdf(x_t, t);
    }

    Real AnalyticPDFHestonEngine::weightedPayoff(Real x_t, Time t) const {
        const DiscountFactor rD
            = model_->process()->riskFreeRate()->discount(t);

        const Real s_t = std::exp(x_t);
        const Real payoff = (*arguments_.payoff)(s_t);

        return (payoff != 0.0) ? payoff*Pv(x_t, t)*rD : 0.0;
    }
}

]]></document_content>
  </document>
  <document index="239">
    <source>exoticoptions/analyticpdfhestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpdfhestonengine.hpp
    \brief Analytic engine for arbitrary European payoffs under the Heston model
*/

#ifndef quantlib_analytic_pdf_heston_engine_hpp
#define quantlib_analytic_pdf_heston_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>

namespace QuantLib {

    //! Analytic engine for arbitrary European payoffs under the Heston model

    /*! References:

        The formulas are taken from A. Dragulescu, V. Yakovenko, 2002.
        Probability distribution of returns in the Heston model
        with stochastic volatility.
        http://arxiv.org/pdf/cond-mat/0203046.pdf

        \test the correctness of the returned value is tested by
              reproducing digital prices using call spreads and the
              AnalyticHestonEngine.

    */
    class AnalyticPDFHestonEngine
       : public GenericModelEngine<HestonModel,
                                   VanillaOption::arguments,
                                   VanillaOption::results> {
      public:
        explicit AnalyticPDFHestonEngine(ext::shared_ptr<HestonModel> model,
                                         Real gaussLobattoEps = 1e-6,
                                         Size gaussLobattoIntegrationOrder = 10000UL);
        void calculate() const override;


        // probability in x_t = ln(s_t)
        Real Pv(Real x_t, Time t) const;

        // cumulative distribution function Pr(x < X)
        Real cdf(Real X, Time t) const;

      private:
        Real weightedPayoff(Real x_t, Time t) const;

        const Size maxIntegrationIterations_;
        const Real integrationEps_;

        const ext::shared_ptr<HestonModel> model_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="240">
    <source>exoticoptions/analyticsimplechooserengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analyticsimplechooserengine.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    AnalyticSimpleChooserEngine::AnalyticSimpleChooserEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticSimpleChooserEngine::calculate() const {
        Date today = Settings::instance().evaluationDate();
        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        QL_REQUIRE(rfdc==divdc,
                   "Risk-free rate and dividend yield must"
                   "have the same day counter");
        QL_REQUIRE(rfdc==voldc,
                   "Risk-free rate and volatility must"
                   "have the same day counter");
        Real spot = process_->stateVariable()->value();
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        Real strike = payoff->strike();
        Volatility volatility = process_->blackVolatility()->blackVol(
                                                arguments_.exercise->lastDate(),
                                                strike);
        Date maturity = arguments_.exercise->lastDate();
        Real timeToMaturity = rfdc.yearFraction(today,maturity);
        Real timeToChoosing = rfdc.yearFraction(today,arguments_.choosingDate);
        Rate dividendRate =
            process_->dividendYield()->zeroRate(maturity, divdc,
                                                Continuous, NoFrequency);
        Rate riskFreeRate =
            process_->riskFreeRate()->zeroRate(maturity, rfdc,
                                               Continuous, NoFrequency);

        QL_REQUIRE(spot > 0.0, "negative or null spot value");
        QL_REQUIRE(strike > 0.0, "negative or null strike value");
        QL_REQUIRE(volatility > 0.0,
                   "negative or null volatility");
        QL_REQUIRE(timeToChoosing > 0.0,
                   "choosing date earlier than or equal to evaluation date");

        Real d = (std::log(spot/strike)
            + ((riskFreeRate-dividendRate) + volatility*volatility*0.5)*timeToMaturity)
            /(volatility*std::sqrt(timeToMaturity));

        Real y = (std::log(spot/strike) + (riskFreeRate-dividendRate)*timeToMaturity
            + (volatility*volatility*timeToChoosing/2))
            /(volatility*std::sqrt(timeToChoosing));

        CumulativeNormalDistribution f;

        results_.value = spot*std::exp(-dividendRate*timeToMaturity)*f(d)
            - strike*std::exp(-riskFreeRate*timeToMaturity)
            *f(d-volatility*std::sqrt(timeToMaturity))
            -spot*std::exp(-dividendRate*timeToMaturity)*f(-y)
            +strike*std::exp(-riskFreeRate*timeToMaturity)
            *f(-y+volatility*std::sqrt(timeToChoosing));
     }

}
]]></document_content>
  </document>
  <document index="241">
    <source>exoticoptions/analyticsimplechooserengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticsimplechooserengine.hpp
    \brief Analytic engine for simple chooser option
*/

#ifndef quantlib_analytic_simple_chooser_engine_hpp
#define quantlib_analytic_simple_chooser_engine_hpp

#include <ql/experimental/exoticoptions/simplechooseroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European Simple Chooser option
    /*! This class implements a Simple Chooser Option
        option, with European exercise.
    */
    class AnalyticSimpleChooserEngine : public SimpleChooserOption::engine {
      public:
        explicit AnalyticSimpleChooserEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="242">
    <source>exoticoptions/analytictwoassetbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetbarrierengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    AnalyticTwoAssetBarrierEngine::AnalyticTwoAssetBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Handle<Quote> rho)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(std::move(rho)) {
        registerWith(process1_);
        registerWith(process2_);
        registerWith(rho_);
    }

    void AnalyticTwoAssetBarrierEngine::calculate() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0,"strike must be positive");

        Real spot2 = process2_->x0();
        // option is triggered by S2
        QL_REQUIRE(spot2 >= 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(spot2), "barrier touched");

        Barrier::Type barrierType = arguments_.barrierType;

        switch (payoff->optionType()) {
          case Option::Call:
            switch (barrierType) {
              case Barrier::DownOut:
                results_.value = A(1,-1) +B(1,-1) ;
                break;
              case Barrier::UpOut:
                results_.value = A(1,1) + B(1,1) ;
                break;
              case Barrier::DownIn:
                results_.value = call()-(A(1,-1) +B(1,-1) );
                break;
              case Barrier::UpIn:
                results_.value = call()-(A(1,1) +B(1,1));
                break;
            }
            break;
          case Option::Put:
            switch (barrierType) {
              case Barrier::DownOut:
                results_.value = A(-1,-1)+B(-1,-1) ;
                break;
              case Barrier::UpOut:
                results_.value = A(-1,1)+B(-1,1) ;
                break;
              case Barrier::DownIn:
                results_.value = put()-(A(-1,-1) +B(-1,-1) );
                break;
              case Barrier::UpIn:
                results_.value = put()-(A(-1,1) +B(-1,1) );
                break;
            }
            break;
          default:
            QL_FAIL("unknown type");
        }
    }

    Real AnalyticTwoAssetBarrierEngine::underlying1() const {
        return process1_->x0();
    }

    Real AnalyticTwoAssetBarrierEngine::underlying2() const {
        return process2_->x0();
    }

    Real AnalyticTwoAssetBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticTwoAssetBarrierEngine::residualTime() const {
        return process1_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticTwoAssetBarrierEngine::volatility1() const {
        return process1_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Volatility AnalyticTwoAssetBarrierEngine::volatility2() const {
        return process2_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticTwoAssetBarrierEngine::barrier() const {
        return arguments_.barrier;
    }

    Real AnalyticTwoAssetBarrierEngine::rho() const {
        return rho_->value();
    }

    Rate AnalyticTwoAssetBarrierEngine::riskFreeRate() const {
        return process1_->riskFreeRate()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }


    Rate AnalyticTwoAssetBarrierEngine::dividendYield1() const {
        return process1_->dividendYield()->zeroRate(residualTime(),
                                                    Continuous, NoFrequency);
    }

    Rate AnalyticTwoAssetBarrierEngine::dividendYield2() const {
        return process2_->dividendYield()->zeroRate(residualTime(),
                                                    Continuous, NoFrequency);
    }

    Rate AnalyticTwoAssetBarrierEngine::costOfCarry1() const {
        return riskFreeRate() - dividendYield1();
    }

    Rate AnalyticTwoAssetBarrierEngine::costOfCarry2() const {
        return riskFreeRate() - dividendYield2();
    }

    Real AnalyticTwoAssetBarrierEngine::d1() const {
        return (std::log(underlying1()/strike())+(mu(costOfCarry1(),volatility1())+volatility1()*volatility1())*residualTime())/
            (volatility1()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::d2() const {
        return d1() - volatility1()*std::sqrt(residualTime());
    }

    Real AnalyticTwoAssetBarrierEngine::d3() const {
        return d1()+ (2*rho()*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::d4() const {
        return d2()+ (2*rho()*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::e1() const {
        return (std::log(barrier()/underlying2())-(mu(costOfCarry2(),volatility2())+rho()*volatility1()*volatility2())*residualTime())/
        (volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::e2() const {
         return e1()+rho()*volatility1()*std::sqrt(residualTime());
    }

    Real AnalyticTwoAssetBarrierEngine::e3() const {
            return e1()-(2*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::e4() const {
        return e2()-(2*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::mu(Real b, Real vol) const {
        return b-(vol*vol)/2;
    }

    Real AnalyticTwoAssetBarrierEngine::call() const {
        CumulativeNormalDistribution nd;
        return underlying1()*nd(d1())-strike()*std::exp(-riskFreeRate()*residualTime())*nd(d2());
    }

    Real AnalyticTwoAssetBarrierEngine::put() const {
        CumulativeNormalDistribution nd;
        return strike()*std::exp(-riskFreeRate()*residualTime())*nd(-d2())-underlying1()*nd(-d1());
    }

    Real AnalyticTwoAssetBarrierEngine::A(Real eta, Real phi) const {
        Real S1 = underlying1(), S2 = underlying2();
        Rate b1 = costOfCarry1(), b2 = costOfCarry2();
        Rate r = riskFreeRate();
        Time T = residualTime();
        Real H = barrier(), X = strike();
        Volatility sigma1 = volatility1(), sigma2 = volatility2();
        Real rho = rho_->value();

        Rate mu1 = b1 - sigma1*sigma1/2.0;
        Rate mu2 = b2 - sigma2*sigma2/2.0;

        Real d1 = (std::log(S1/X)+(mu1+sigma1*sigma1)*T)/
            (sigma1*std::sqrt(T));
        Real d2 = d1 - sigma1*std::sqrt(T);
        Real d3 = d1 + (2*rho*std::log(H/S2))/(sigma2*std::sqrt(T));
        Real d4 = d2 + (2*rho*std::log(H/S2))/(sigma2*std::sqrt(T));

        Real e1 = (std::log(H/S2)-(mu2+rho*sigma1*sigma2)*T)/
            (sigma2*std::sqrt(T));
        Real e2 = e1 + rho*sigma1*std::sqrt(T);
        Real e3 = e1 - (2*std::log(H/S2))/(sigma2*std::sqrt(T));
        Real e4 = e2 - (2*std::log(H/S2))/(sigma2*std::sqrt(T));

        Real w =
            eta*S1*std::exp((b1-r)*T) *
            (M(eta*d1, phi*e1,-eta*phi*rho)
             -std::exp((2*(mu2+rho*sigma1*sigma2)*std::log(H/S2))/(sigma2*sigma2))
             *M(eta*d3, phi*e3, -eta*phi*rho))

            - eta*X*std::exp(-r*T) *
            (M(eta*d2, phi*e2, -eta*phi*rho)
             -std::exp((2*mu2*std::log(H/S2))/(sigma2*sigma2))*
             M(eta*d4, phi*e4, -eta*phi*rho) ) ;

        return w;
    }

    Real AnalyticTwoAssetBarrierEngine::B(Real, Real) const {
        return 0.0;
    }

    Real AnalyticTwoAssetBarrierEngine::M(Real m_a, Real m_b, Real rho) const {
        BivariateCumulativeNormalDistributionDr78 f(rho);
        return f(m_a, m_b);
    }

}

]]></document_content>
  </document>
  <document index="243">
    <source>exoticoptions/analytictwoassetbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytictwoassetbarrierengine.hpp
    \brief Analytic engine for barrier option on two assets
*/

#ifndef quantlib_analytic_two_asset_barrier_engine_hpp
#define quantlib_analytic_two_asset_barrier_engine_hpp

#include <ql/experimental/exoticoptions/twoassetbarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for barrier option on two assets
    /*! The formulas are taken from "Option pricing formulas",
        E.G. Haug, McGraw-Hill,

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
     */
    class AnalyticTwoAssetBarrierEngine
        : public TwoAssetBarrierOption::engine {
      public:
        AnalyticTwoAssetBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                      ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                      Handle<Quote> rho);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Handle<Quote> rho_;

        // helper methods
        Real underlying1() const;
        Real underlying2() const;

        Real strike() const;
        Time residualTime() const;

        Volatility volatility1() const;
        Volatility volatility2() const;

        Real barrier() const;
        Real rho() const;

        Rate riskFreeRate() const;

        Rate dividendYield1() const;
        Rate dividendYield2() const;

        Rate costOfCarry1() const;
        Rate costOfCarry2() const;

        Real mu(Real b, Real vol) const;

        Real d1() const;
        Real d2() const;
        Real d3() const;
        Real d4() const;

        Real e1() const;
        Real e2() const;
        Real e3() const;
        Real e4() const;

        Real call() const;
        Real put() const;

        Real A(Real eta, Real phi) const;
        Real B(Real eta, Real phi) const;

        Real M(Real m_a, Real m_b,Real rho) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="244">
    <source>exoticoptions/analytictwoassetcorrelationengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetcorrelationengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <utility>

using std::log;

namespace QuantLib {

    AnalyticTwoAssetCorrelationEngine::AnalyticTwoAssetCorrelationEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> p1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> p2,
        Handle<Quote> correlation)
    : p1_(std::move(p1)), p2_(std::move(p2)), correlation_(std::move(correlation)) {
        registerWith(p1_);
        registerWith(p2_);
        registerWith(correlation_);
    }

    void AnalyticTwoAssetCorrelationEngine::calculate() const {
        BivariateCumulativeNormalDistributionDr78 M(correlation_->value());

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0, "strike must be positive");
        ext::shared_ptr<Exercise> exercise = arguments_.exercise;
        Real strike = payoff->strike();//X1
        Real spot = p1_->x0();
        QL_REQUIRE(spot >= 0.0, "negative or null underlying given");

        Volatility sigma1 =
            p1_->blackVolatility()->blackVol(p1_->time(exercise->lastDate()),
                                             payoff->strike());
        Volatility sigma2 =
            p2_->blackVolatility()->blackVol(p2_->time(exercise->lastDate()),
                                             payoff->strike());

        Time T = p2_->time(arguments_.exercise->lastDate());

        Real s1=p1_->x0();
        Real s2=p2_->x0();
        Rate q1= p1_->dividendYield()->zeroRate(T, Continuous, NoFrequency);
        Rate q2= p2_->dividendYield()->zeroRate(T, Continuous, NoFrequency);
        Rate r=p1_->riskFreeRate()->zeroRate(T, Continuous, NoFrequency);
        Rate b1=r-q1;
        Rate b2=r-q2;
        Real rho = correlation_->value();

        Real y1=(log(s1/strike)+(b1-(sigma1*sigma1)/2)*T)/(sigma1*std::sqrt(T));
        Real y2=(log(s2/arguments_.X2)+(b2-(sigma2*sigma2)/2)*T)/(sigma2*std::sqrt(T));

        switch (payoff->optionType()) {
          case Option::Call:
            results_.value=s2*std::exp((b2-r)*T)*M(y2+sigma2*std::sqrt(T),y1+rho*sigma2*std::sqrt(T))-arguments_.X2*std::exp(-r*T)*M(y2,y1);
            break;
          case Option::Put:
            results_.value=arguments_.X2*std::exp(-r*T)*M(-y2,-y1)-s2*std::exp((b2-r)*T)*M(-y2-sigma2*std::sqrt(T),-y1-rho*sigma2*std::sqrt(T));
            break;
          default:
            QL_FAIL("unknown option type");
        }
    }

}
]]></document_content>
  </document>
  <document index="245">
    <source>exoticoptions/analytictwoassetcorrelationengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytictwoassetcorrelationengine.hpp
    \brief Analytic engine for two-asset correlation options
*/

#ifndef quantlib_analytic_two_asset_correlation_option_engine_hpp
#define quantlib_analytic_two_asset_correlation_option_engine_hpp

#include <ql/experimental/exoticoptions/twoassetcorrelationoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic two-asset correlation option engine
    class AnalyticTwoAssetCorrelationEngine
        : public TwoAssetCorrelationOption::engine {
      public:
        AnalyticTwoAssetCorrelationEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> p1,
                                          ext::shared_ptr<GeneralizedBlackScholesProcess> p2,
                                          Handle<Quote> correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> p1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> p2_;
        Handle<Quote> correlation_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="246">
    <source>exoticoptions/analyticwriterextensibleoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/analyticwriterextensibleoptionengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    AnalyticWriterExtensibleOptionEngine::AnalyticWriterExtensibleOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticWriterExtensibleOptionEngine::calculate() const {
        // We take all the arguments:

        ext::shared_ptr<PlainVanillaPayoff> payoff1 =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff1, "not a plain vanilla payoff");

        ext::shared_ptr<PlainVanillaPayoff> payoff2 =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff2);
        QL_REQUIRE(payoff2, "not a plain vanilla payoff");

        ext::shared_ptr<Exercise> exercise1 = arguments_.exercise;

        ext::shared_ptr<Exercise> exercise2 = arguments_.exercise2;


        // We create and apply the calculate process:

        Option::Type type = payoff1->optionType();

        // STEP 1:

        // S = spot
        Real spot = process_->stateVariable()->value();

        // For the B&S formulae:
        DayCounter dividendDC = process_->dividendYield()->dayCounter();
        Rate dividend = process_->dividendYield()->zeroRate(
                  exercise1->lastDate(), dividendDC, Continuous, NoFrequency);

        DayCounter riskFreeDC = process_->riskFreeRate()->dayCounter();
        Rate riskFree = process_->riskFreeRate()->zeroRate(
                  exercise1->lastDate(), riskFreeDC, Continuous, NoFrequency);

        // The time to maturity:
        Time t1 = riskFreeDC.yearFraction(
                                    process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise->lastDate());
        Time t2 = riskFreeDC.yearFraction(
                                    process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise2->lastDate());

        // b = r-q:
        Real b = riskFree - dividend;

        Real forwardPrice = spot * std::exp(b*t1);

        Volatility volatility = process_->blackVolatility()->blackVol(
                                    exercise1->lastDate(), payoff1->strike());

        Real stdDev = volatility*std::sqrt(t1);

        Real discount = std::exp(-riskFree*t1);

        // Call the B&S method:
        Real black = blackFormula(type, payoff1->strike(),
                                  forwardPrice, stdDev, discount);

        // STEP 2:

        // Standard bivariate normal distribution:
        Real ro = std::sqrt(t1/t2);
        Real z1 = (std::log(spot/payoff2->strike()) +
                   (b+std::pow(volatility, 2)/2)*t2)/(volatility*std::sqrt(t2));
        Real z2 = (std::log(spot/payoff1->strike()) +
                   (b+std::pow(volatility, 2)/2)*t1)/(volatility*std::sqrt(t1));

        // Call the bivariate method:
        BivariateCumulativeNormalDistributionWe04DP biv(-ro);


        // STEP 3:

        Real bivariate1, bivariate2, result;

        // Final computing:
        if (type == Option::Call) {
            // Call case:
            bivariate1 = biv(z1, -z2);
            bivariate2 = biv(z1-volatility*std::sqrt(t2),
                             -z2+volatility*std::sqrt(t1));
            result = black + spot*std::exp((b-riskFree)*t2)*bivariate1
                - payoff2->strike()*std::exp((-riskFree)*t2)*bivariate2;
        } else {
            // Put case:
            bivariate1 = biv(-z1, z2);
            bivariate2 = biv(-z1+volatility*std::sqrt(t2),
                             z2-volatility*std::sqrt(t1));
            result = black - spot*std::exp((b-riskFree)*t2)*bivariate1
                + payoff2->strike()*std::exp((-riskFree)*t2)*bivariate2;
        }

        // Save the result:
        results_.value = result;
    }

}
]]></document_content>
  </document>
  <document index="247">
    <source>exoticoptions/analyticwriterextensibleoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticwriterextensibleoptionengine.hpp
    \brief Analytic engine for writer-extensible options
*/

#ifndef quantlib_analytic_writer_extensible_option_engine_hpp
#define quantlib_analytic_writer_extensible_option_engine_hpp

#include <ql/experimental/exoticoptions/writerextensibleoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for writer-extensible options
    class AnalyticWriterExtensibleOptionEngine
        : public WriterExtensibleOption::engine {
      public:
        explicit AnalyticWriterExtensibleOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="248">
    <source>exoticoptions/complexchooseroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/complexchooseroption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    ComplexChooserOption::ComplexChooserOption(
        Date choosingDate,
        Real strikeCall,
        Real strikePut,
        const ext::shared_ptr<Exercise>& exerciseCall,
        const ext::shared_ptr<Exercise>& exercisePut)
    : OneAssetOption(ext::make_shared<PlainVanillaPayoff>(Option::Call,
                                                            strikeCall),
                     exerciseCall),
      choosingDate_(choosingDate),
      strikeCall_(strikeCall),
      strikePut_(strikePut),
      exerciseCall_(exerciseCall),
      exercisePut_(exercisePut) {}

    void ComplexChooserOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<ComplexChooserOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->choosingDate=choosingDate_;
        moreArgs->strikeCall=strikeCall_;
        moreArgs->strikePut=strikePut_;
        moreArgs->exerciseCall = exerciseCall_;
        moreArgs->exercisePut = exercisePut_;
    }

    void ComplexChooserOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(choosingDate != Date() , " no choosing date given");
        QL_REQUIRE(choosingDate < exerciseCall->lastDate(),
                   "choosing date later than or equal to Call maturity date");
        QL_REQUIRE(choosingDate < exercisePut->lastDate(),
                   "choosing date later than or equal to Put maturity date");
    }

}
]]></document_content>
  </document>
  <document index="249">
    <source>exoticoptions/complexchooseroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file complexchooseroption.hpp
    \brief Complex chooser option
*/

#ifndef quantlib_complex_chooser_option_hpp
#define quantlib_complex_chooser_option_hpp

#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib{

    class GeneralizedBlackScholesProcess;

    class ComplexChooserOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        ComplexChooserOption(Date choosingDate,
                             Real strikeCall,
                             Real strikePut,
                             const ext::shared_ptr<Exercise>& exerciseCall,
                             const ext::shared_ptr<Exercise>& exercisePut);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Date choosingDate_;
        Real strikeCall_;
        Real strikePut_;
        const ext::shared_ptr<Exercise>& exerciseCall_;
        const ext::shared_ptr<Exercise>& exercisePut_;
    };

    class ComplexChooserOption::arguments : public OneAssetOption::arguments {
      public:
        void validate() const override;
        Date choosingDate;
        Real strikeCall;
        Real strikePut;
        ext::shared_ptr<Exercise> exerciseCall;
        ext::shared_ptr<Exercise> exercisePut;
    };

    class ComplexChooserOption::engine
        : public GenericEngine<ComplexChooserOption::arguments,
                               ComplexChooserOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="250">
    <source>exoticoptions/compoundoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/compoundoption.hpp>
#include <utility>

namespace QuantLib {

    CompoundOption::CompoundOption(const ext::shared_ptr<StrikedTypePayoff>& motherPayoff,
                                   const ext::shared_ptr<Exercise>& motherExercise,
                                   ext::shared_ptr<StrikedTypePayoff> daughterPayoff,
                                   ext::shared_ptr<Exercise> daughterExercise)
    : OneAssetOption(motherPayoff, motherExercise), daughterPayoff_(std::move(daughterPayoff)),
      daughterExercise_(std::move(daughterExercise)) {}

    void CompoundOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<CompoundOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->daughterPayoff = daughterPayoff_;
        moreArgs->daughterExercise = daughterExercise_;
    }

    void CompoundOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(daughterPayoff,
                   "no payoff given for underlying option");
        QL_REQUIRE(daughterExercise,
                   "no exercise given for underlying option");
        QL_REQUIRE(exercise->lastDate() <= daughterExercise->lastDate(),
                   "maturity of compound option exceeds "
                   "maturity of underlying option");
    }

}
]]></document_content>
  </document>
  <document index="251">
    <source>exoticoptions/compoundoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file compoundoption.hpp
    \brief Compound option on a single asset
*/

#ifndef quantlib_compound_option_hpp
#define quantlib_compound_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! %Compound option on a single asset.
    /*! \ingroup instruments */
    class CompoundOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        // Mother is the compound Option.
        // Daughter is the option which plays the role of the underlying.
        CompoundOption(const ext::shared_ptr<StrikedTypePayoff>& motherPayoff,
                       const ext::shared_ptr<Exercise>& motherExercise,
                       ext::shared_ptr<StrikedTypePayoff> daughterPayoff,
                       ext::shared_ptr<Exercise> daughterExercise);
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        ext::shared_ptr<StrikedTypePayoff> daughterPayoff_;
        ext::shared_ptr<Exercise> daughterExercise_;
    };

    class CompoundOption::arguments : public OneAssetOption::arguments {
      public:
        ext::shared_ptr<StrikedTypePayoff> daughterPayoff;
        ext::shared_ptr<Exercise> daughterExercise;
        void validate() const override;
    };

    //! %Compound-option %engine base class
    class CompoundOption::engine
        : public GenericEngine<CompoundOption::arguments,
                               CompoundOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="252">
    <source>exoticoptions/continuousarithmeticasianlevyengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/continuousarithmeticasianlevyengine.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    ContinuousArithmeticAsianLevyEngine::ContinuousArithmeticAsianLevyEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Handle<Quote> currentAverage,
        Date startDate)
    : process_(std::move(process)), currentAverage_(std::move(currentAverage)),
      startDate_(startDate) {
        registerWith(process_);
        registerWith(currentAverage_);
    }

    void ContinuousArithmeticAsianLevyEngine::calculate() const {
        QL_REQUIRE(arguments_.averageType == Average::Arithmetic,
                   "not an Arithmetic average option");
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");
        QL_REQUIRE(startDate_ <= process_->riskFreeRate()->referenceDate(),
                   "startDate must be earlier than or equal to reference date");

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Real spot = process_->stateVariable()->value();

        // payoff
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        // original time to maturity
        Date maturity = arguments_.exercise->lastDate();
        Time T = rfdc.yearFraction(startDate_,
                                   arguments_.exercise->lastDate());
        // remaining time to maturity
        Time T2 = rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise->lastDate());

        Real strike = payoff->strike();

        Volatility volatility =
            process_->blackVolatility()->blackVol(maturity, strike);

        CumulativeNormalDistribution N;

        Rate riskFreeRate = process_->riskFreeRate()->
            zeroRate(maturity, rfdc, Continuous, NoFrequency);
        Rate dividendYield = process_->dividendYield()->
            zeroRate(maturity, divdc, Continuous, NoFrequency);
        Real b = riskFreeRate - dividendYield;

        Real Se = (std::fabs(b) > 1000*QL_EPSILON) 
            ? (spot/(T*b))*(exp((b-riskFreeRate)*T2)-exp(-riskFreeRate*T2))
            : spot*T2/T * std::exp(-riskFreeRate*T2);

        Real X;
        if (T2 < T) {
            QL_REQUIRE(!currentAverage_.empty() && currentAverage_->isValid(),
                       "current average required");
            X = strike - ((T-T2)/T)*currentAverage_->value();
        } else {
            X = strike;
        }

        Real m = (std::fabs(b) > 1000*QL_EPSILON) ? ((exp(b*T2)-1)/b) : T2;

        Real M = (2*spot*spot/(b+volatility*volatility)) *
            (((exp((2*b+volatility*volatility)*T2)-1)
              / (2*b+volatility*volatility))-m);

        Real D = M/(T*T);

        Real V = log(D)-2*(riskFreeRate*T2+log(Se));

        Real d1 = (1/sqrt(V))*((log(D)/2)-log(X));
        Real d2 = d1-sqrt(V);

        if(payoff->optionType()==Option::Call)
            results_.value = Se*N(d1) - X*exp(-riskFreeRate*T2)*N(d2);
        else
            results_.value = Se*N(d1) - X*exp(-riskFreeRate*T2)*N(d2)
                             - Se + X*exp(-riskFreeRate*T2);
    }

}
]]></document_content>
  </document>
  <document index="253">
    <source>exoticoptions/continuousarithmeticasianlevyengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file continuousarithmeticasianlevyengine.hpp
    \brief Levy engine for continuous arithmetic Asian options
*/

#ifndef quantlib_continuous_arithmetic_asian_levy_engine_hpp
#define quantlib_continuous_arithmetic_asian_levy_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class ContinuousArithmeticAsianLevyEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        ContinuousArithmeticAsianLevyEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                            Handle<Quote> currentAverage,
                                            Date startDate);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<Quote> currentAverage_ ;
        Date startDate_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="254">
    <source>exoticoptions/continuousarithmeticasianvecerengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2014 Bernd Lewerenz

  This file is part of QuantLib, a free-software/open-source library
  for financial quantitative analysts and developers - http://quantlib.org/

  QuantLib is free software: you can redistribute it and/or modify it
  under the terms of the QuantLib license.  You should have received a
  copy of the license along with this program; if not, please email
  <quantlib-dev@lists.sf.net>. The license is also available online at
  <http://quantlib.org/license.shtml>.

  This program is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/continuousarithmeticasianvecerengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/rounding.hpp>
#include <ql/methods/finitedifferences/dminus.hpp>
#include <ql/methods/finitedifferences/dplus.hpp>
#include <ql/methods/finitedifferences/dplusdminus.hpp>
#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    ContinuousArithmeticAsianVecerEngine::ContinuousArithmeticAsianVecerEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Handle<Quote> currentAverage,
        Date startDate,
        Size timeSteps,
        Size assetSteps,
        Real z_min,
        Real z_max)
    : process_(std::move(process)), currentAverage_(std::move(currentAverage)),
      startDate_(startDate), z_min_(z_min), z_max_(z_max), timeSteps_(timeSteps),
      assetSteps_(assetSteps) {
        registerWith(process_);
        registerWith(currentAverage_);
    }

    void ContinuousArithmeticAsianVecerEngine::calculate() const {
        Real expectedAverage;

        QL_REQUIRE(arguments_.averageType == Average::Arithmetic,
                   "not an Arithmetic average option");
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Real S_0 = process_->stateVariable()->value();

        // payoff
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        // original time to maturity
        Date maturity = arguments_.exercise->lastDate();

        Real X = payoff->strike();
        QL_REQUIRE(z_min_<=0 && z_max_>=0,
                   "strike (0 for vecer fixed strike asian)  not on Grid");

        Volatility sigma =
            process_->blackVolatility()->blackVol(maturity, X);

        Rate r = process_->riskFreeRate()->
            zeroRate(maturity, rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->
            zeroRate(maturity, divdc, Continuous, NoFrequency);

        Date today(Settings::instance().evaluationDate());

        QL_REQUIRE(startDate_>=today,
                   "Seasoned Asian not yet implemented");

        // Expiry in Years
        Time T = rfdc.yearFraction(today,
                                   arguments_.exercise->lastDate());
        Time T1 = rfdc.yearFraction(today,
                                    startDate_ );            // Average Begin
        Time T2 = T;            // Average End (In this version only Maturity...)

        if ((T2 - T1) < 0.001) {
            // its a vanilla option. Use vanilla engine
            VanillaOption europeanOption(payoff, arguments_.exercise);
            europeanOption.setPricingEngine(
                        ext::make_shared<AnalyticEuropeanEngine>(process_));
            results_.value = europeanOption.NPV();

        } else {
            Real Theta = 0.5;        // Mixed Scheme: 0.5 = Crank Nicolson
            Real Z_0 = cont_strategy(0,T1,T2,q,r) - std::exp(-r*T) * X /S_0;

            QL_REQUIRE(Z_0>=z_min_ && Z_0<=z_max_,
                       "spot not on grid");

            Real h = (z_max_ - z_min_) / assetSteps_; // Space step size
            Real k = T / timeSteps_;         // Time Step size

            Real sigma2 = sigma * sigma, vecerTerm;

            Array SVec(assetSteps_+1),u_initial(assetSteps_+1),
                  u(assetSteps_+1),rhs(assetSteps_+1);

            for (Natural i= 0; i<= SVec.size()-1;i++) {
                SVec[i] = z_min_ + i * h;     // Value of Underlying on the grid
            }

            // Begin gamma construction
            TridiagonalOperator gammaOp = DPlusDMinus(assetSteps_+1,h);

            Array upperD = gammaOp.upperDiagonal();
            Array lowerD = gammaOp.lowerDiagonal();
            Array Dia    = gammaOp.diagonal();

            // Construct Vecer operator
            TridiagonalOperator explicit_part(gammaOp.size());
            TridiagonalOperator implicit_part(gammaOp.size());

            for (Natural i= 0; i<= SVec.size()-1;i++) {
                u_initial[i] = std::max<Real>(SVec[i] , 0.0); // Call Payoff
            }

            u = u_initial;

            // Start Time Loop

            for (Natural j = 1; j<=timeSteps_;j++) {
                if (Theta != 1.0) { // Explicit Part
                    for (Natural i = 1; i<= SVec.size()-2;i++) {
                        vecerTerm = SVec[i] - std::exp(-q * (T-(j-1)*k))
                                  * cont_strategy(T-(j-1)*k,T1,T2,q,r);
                        gammaOp.setMidRow(i,
                            0.5 * sigma2 * vecerTerm * vecerTerm  * lowerD[i-1],
                            0.5 * sigma2 * vecerTerm * vecerTerm  * Dia[i],
                            0.5 * sigma2 *  vecerTerm * vecerTerm * upperD[i]);
                    }
                    explicit_part = TridiagonalOperator::identity(gammaOp.size()) +
                                    (1 - Theta) * k * gammaOp;
                    explicit_part.setFirstRow(1.0,0.0); // Apply before applying
                    explicit_part.setLastRow(-1.0,1.0); // Neumann BC

                    u = explicit_part.applyTo(u);

                    // Apply after applying (Neumann BC)
                    u[assetSteps_] = u[assetSteps_-1] + h;
                    u[0] = 0;
                } // End Explicit Part

                if (Theta != 0.0) {  // Implicit Part
                    for (Natural i = 1; i<= SVec.size()-2;i++) {
                        vecerTerm = SVec[i] - std::exp(-q * (T-j*k)) *
                                    cont_strategy(T-j*k,T1,T2,q,r);
                        gammaOp.setMidRow(i,
                            0.5 * sigma2 * vecerTerm * vecerTerm * lowerD[i-1],
                            0.5 * sigma2 * vecerTerm * vecerTerm  * Dia[i],
                            0.5 * sigma2 * vecerTerm * vecerTerm * upperD[i]);
                    }

                    implicit_part = TridiagonalOperator::identity(gammaOp.size()) -
                                    Theta * k * gammaOp;

                    // Apply before solving
                    implicit_part.setFirstRow(1.0,0.0);
                    implicit_part.setLastRow(-1.0,1.0);
                    rhs = u;
                    rhs[0] = 0; // Lower BC
                    rhs[assetSteps_] = h; // Upper BC (Neumann) Delta=1
                    u = implicit_part.solveFor(rhs);
                } // End implicit Part
            } // End Time Loop

            DownRounding Rounding(0);
            auto lowerI = Integer(Rounding((Z_0 - z_min_) / h));
            // Interpolate solution
            Real pv;

            pv = u[lowerI] + (u[lowerI+1] - u[lowerI]) * (Z_0 - SVec[lowerI])/h;
            results_.value = S_0 * pv;

            if (payoff->optionType()==Option::Put) {
                // Apply Call Put Parity for Asians
                if (r == q) {
                    expectedAverage = S_0;
                } else {
                    expectedAverage =
                        S_0 * (std::exp( (r-q) * T2) -
                               std::exp( (r-q) * T1)) / ((r-q) * (T2-T1));
                }

                Real asianForward = std::exp(-r * T2) * (expectedAverage -  X);
                results_.value = results_.value - asianForward;
            }
        }
    }

    // Replication of Average by holding this amount in Assets
    Real ContinuousArithmeticAsianVecerEngine::cont_strategy(Time t,
                                                             Time T1,
                                                             Time T2,
                                                             Real v,
                                                             Real r) const {
        Real const eps= 0.00001;

        QL_REQUIRE(T1 <= T2, "Average Start must be before Average End");
        if (std::fabs(t-T2) < eps) {
            return 0.0;
        } else {
            if (t<T1) {
                if (std::fabs(r-v) >= eps) {
                    return (std::exp(v * (t-T2)) *
                           (1 - std::exp((v-r) * (T2-T1) ))  /
                           (( r - v) * (T2 - T1) ));
                } else {
                    return std::exp(v*(t-T2));
                } // end else v-r ==0
            } else { // t<T1
                if (std::fabs(r-v) >= eps) {
                    return std::exp(v * (t-T2)) *
                           (1 - std::exp( (v - r) * (T2-t) )) /
                           (( r - v) * (T2 - T1)  );
                } else {
                    return std::exp(v * (t-T2)) * (T2 - t) / (T2 - T1);
                }
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="255">
    <source>exoticoptions/continuousarithmeticasianvecerengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Bernd Lewerenz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file continuousarithmeticasianvecerengine.hpp
    \brief Vecer engine for continuous arithmetic Asian options
*/

#ifndef quantlib_continuous_arithmetic_asian_vecer_engine_hpp
#define quantlib_continuous_arithmetic_asian_vecer_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Vecer engine for continuous-avaeraging Asian options
    /*! See <http://www.stat.columbia.edu/~vecer/asian-vecer.pdf> */
    class ContinuousArithmeticAsianVecerEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        ContinuousArithmeticAsianVecerEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            Handle<Quote> currentAverage,
            Date startDate,
            Size timeSteps = 100,
            Size assetSteps = 100,
            Real z_min = -1.0,
            Real z_max = 1.0);
        void calculate() const override;

      protected:
        // Replication of average by holding this amount in assets
        Real cont_strategy(Time t, Time T1,Time T2,Real v, Real r) const; 
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<Quote> currentAverage_ ;
        Date startDate_;
        Real z_min_;
        Real z_max_;
        Size timeSteps_;
        Size assetSteps_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="256">
    <source>exoticoptions/everestoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/everestoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    EverestOption::EverestOption(Real notional,
                                 Rate guarantee,
                                 const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(ext::shared_ptr<Payoff>(new NullPayoff), exercise),
      notional_(notional), guarantee_(guarantee) {}

    Rate EverestOption::yield() const {
        calculate();
        QL_REQUIRE(yield_ != Null<Rate>(), "yield not provided");
        return yield_;
    }

    void EverestOption::setupArguments(PricingEngine::arguments* args) const {
        MultiAssetOption::setupArguments(args);

        auto* arguments = dynamic_cast<EverestOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->notional = notional_;
        arguments->guarantee= guarantee_;
    }

    void EverestOption::fetchResults(const PricingEngine::results* r) const {
        MultiAssetOption::fetchResults(r);
        const auto* results = dynamic_cast<const EverestOption::results*>(r);
        QL_ENSURE(results != nullptr, "no results returned from pricing engine");
        yield_ = results->yield;
    }


    EverestOption::arguments::arguments()
    : notional(Null<Real>()), guarantee(Null<Rate>()) {}

    void EverestOption::arguments::validate() const {
        MultiAssetOption::arguments::validate();
        QL_REQUIRE(notional != Null<Rate>(), "no notional given");
        QL_REQUIRE(notional != 0.0, "null notional given");
        QL_REQUIRE(guarantee != Null<Rate>(), "no guarantee given");
    }


    void EverestOption::results::reset() {
        MultiAssetOption::results::reset();
        yield = Null<Rate>();
    }

}

]]></document_content>
  </document>
  <document index="257">
    <source>exoticoptions/everestoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file everestoption.hpp
    \brief Everest option on a number of assets
*/

#ifndef quantlib_everest_option_hpp
#define quantlib_everest_option_hpp

#include <ql/instruments/multiassetoption.hpp>

namespace QuantLib {

    class EverestOption : public MultiAssetOption {
      public:
        class engine;
        class arguments;
        class results;
        EverestOption(Real notional,
                      Rate guarantee,
                      const ext::shared_ptr<Exercise>&);
        Rate yield() const;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private :
        Real notional_;
        Rate guarantee_;
        mutable Rate yield_;
    };

    class EverestOption::arguments : public MultiAssetOption::arguments {
      public:
        arguments();
        void validate() const override;

        Real notional;
        Rate guarantee;
    };

    class EverestOption::results : public MultiAssetOption::results {
      public:
        void reset() override;

        Rate yield;
    };

    class EverestOption::engine
        : public GenericEngine<EverestOption::arguments,
                               EverestOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="258">
    <source>exoticoptions/himalayaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/himalayaoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    HimalayaOption::HimalayaOption(const std::vector<Date>& fixingDates,
                                   Real strike)
    : MultiAssetOption(ext::shared_ptr<Payoff>(
                                new PlainVanillaPayoff(Option::Call, strike)),
                       ext::shared_ptr<Exercise>(
                                   new EuropeanExercise(fixingDates.back()))),
      fixingDates_(fixingDates) {}

    void HimalayaOption::setupArguments(PricingEngine::arguments* args) const {
        MultiAssetOption::setupArguments(args);

        auto* arguments = dynamic_cast<HimalayaOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->fixingDates = fixingDates_;
    }

    void HimalayaOption::arguments::validate() const {
        MultiAssetOption::arguments::validate();
        QL_REQUIRE(!fixingDates.empty(), "no fixing dates given");
    }

}

]]></document_content>
  </document>
  <document index="259">
    <source>exoticoptions/himalayaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file himalayaoption.hpp
    \brief Himalaya option on a number of assets
*/

#ifndef quantlib_himalaya_option_hpp
#define quantlib_himalaya_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    //! Himalaya option
    /*! The payoff of a Himalaya option is computed in the following
        way: Given a basket of N assets, and N time periods, at the
        end of each period the option who performed the best is added
        to the average and then discarded from the basket. At the end
        of the N, periods the option pays the max between the strike
        and the average of the best performers.

        \warning This implementation still does not manage seasoned
                 options.
    */
    class HimalayaOption : public MultiAssetOption {
      public:
        class engine;
        class arguments;
        class results;
        HimalayaOption(const std::vector<Date>& fixingDates,
                       Real strike);

        void setupArguments(PricingEngine::arguments*) const override;

      private:
        std::vector<Date> fixingDates_;
    };

    class HimalayaOption::arguments : public MultiAssetOption::arguments {
      public:
        void validate() const override;
        std::vector<Date> fixingDates;
    };

    class HimalayaOption::results : public MultiAssetOption::results {};

    class HimalayaOption::engine
        : public GenericEngine<HimalayaOption::arguments,
                               HimalayaOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="260">
    <source>exoticoptions/holderextensibleoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/holderextensibleoption.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    HolderExtensibleOption::HolderExtensibleOption(
                           Option::Type type,
                           Real premium,
                           Date secondExpiryDate,
                           Real secondStrike,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff,exercise),
      premium_(premium),
      secondExpiryDate_(secondExpiryDate),
      secondStrike_(secondStrike) {}

    void HolderExtensibleOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<HolderExtensibleOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->premium = premium_;
        moreArgs->secondExpiryDate = secondExpiryDate_;
        moreArgs->secondStrike = secondStrike_;
    }

    void HolderExtensibleOption:: arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(premium > 0,"negative premium not allowed");
        QL_REQUIRE(secondExpiryDate != Date() , "no extending date given");
        QL_REQUIRE(secondExpiryDate >= exercise->lastDate(),
                   "extended date is earlier than or equal to first maturity date");
    }

}
]]></document_content>
  </document>
  <document index="261">
    <source>exoticoptions/holderextensibleoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file holderextensibleoption.hpp
    \brief Holder-extensible option
*/

#ifndef quantlib_holder_extensible_option_hpp
#define quantlib_holder_extensible_option_hpp

#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    class HolderExtensibleOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        HolderExtensibleOption(
                       Option::Type type,
                       Real premium,
                       Date secondExpiryDate,
                       Real secondStrike,
                       const ext::shared_ptr<StrikedTypePayoff>& payoff,
                       const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Real premium_;
        Date secondExpiryDate_;
        Real secondStrike_;
    };

    class HolderExtensibleOption::arguments : public OneAssetOption::arguments {
      public:
        Real premium;
        Date secondExpiryDate;
        Real secondStrike;

        void validate() const override;
    };

    class HolderExtensibleOption::engine
        : public GenericEngine<HolderExtensibleOption::arguments,
                               HolderExtensibleOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="262">
    <source>exoticoptions/kirkspreadoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/kirkspreadoptionengine.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    KirkSpreadOptionEngine::KirkSpreadOptionEngine(ext::shared_ptr<BlackProcess> process1,
                                                   ext::shared_ptr<BlackProcess> process2,
                                                   Handle<Quote> correlation)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(std::move(correlation)) {
        registerWith(process1_);
        registerWith(process2_);
        registerWith(rho_);
    }

    void KirkSpreadOptionEngine::calculate() const {

        // First: tests on types
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "not a plain-vanilla payoff");

        // forward values - futures, so b=0
        Real forward1 = process1_->stateVariable()->value();
        Real forward2 = process2_->stateVariable()->value();

        Date exerciseDate = arguments_.exercise->lastDate();

        // Volatilities
        Real sigma1 =
            process1_->blackVolatility()->blackVol(exerciseDate,forward1);
        Real sigma2 =
            process2_->blackVolatility()->blackVol(exerciseDate,forward2);

        DiscountFactor riskFreeDiscount =
            process1_->riskFreeRate()->discount(exerciseDate);

        Real strike = payoff->strike();

        // Unique F (forward) value for pricing
        Real F = forward1/(forward2+strike);

        // Its volatility
        Real sigma =
            sqrt(pow(sigma1,2)
                 + pow((sigma2*(forward2/(forward2+strike))),2)
                 - 2*rho_->value()*sigma1*sigma2*(forward2/(forward2+strike)));

        // Day counter and Dates handling variables
        DayCounter rfdc = process1_->riskFreeRate()->dayCounter();
        Time t = rfdc.yearFraction(process1_->riskFreeRate()->referenceDate(),
                                   arguments_.exercise->lastDate());

        // Black-Scholes solution values
        Real d1 = (log(F)+ 0.5*pow(sigma,2)*t) / (sigma*sqrt(t));
        Real d2 = d1 - sigma*sqrt(t);

        NormalDistribution pdf;
        CumulativeNormalDistribution cum;
        Real Nd1 = cum(d1);
        Real Nd2 = cum(d2);
        Real NMd1 = cum(-d1);
        Real NMd2 = cum(-d2);

        Option::Type optionType = payoff->optionType();

        if (optionType==Option::Call) {
            results_.value = riskFreeDiscount*(F*Nd1-Nd2)*(forward2+strike);
        } else {
            results_.value = riskFreeDiscount*(NMd2 -F*NMd1)*(forward2+strike);
        }

        Real callValue = optionType == Option::Call ? results_.value : riskFreeDiscount*(F*Nd1-Nd2)*(forward2+strike);
        results_.theta = -((log(riskFreeDiscount)/t)*callValue
                           + riskFreeDiscount*(forward1*sigma)/(2*sqrt(t))*pdf(d1));
    }

}

]]></document_content>
  </document>
  <document index="263">
    <source>exoticoptions/kirkspreadoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file kirkspreadoptionengine.hpp
    \brief Kirk approximation for European spread option on futures
*/

#ifndef quantlib_kirk_spread_option_engine_hpp
#define quantlib_kirk_spread_option_engine_hpp

#include <ql/experimental/exoticoptions/spreadoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Kirk approximation for European spread option on futures
    class KirkSpreadOptionEngine : public SpreadOption::engine {
      public:
        KirkSpreadOptionEngine(ext::shared_ptr<BlackProcess> process1,
                               ext::shared_ptr<BlackProcess> process2,
                               Handle<Quote> correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<BlackProcess> process1_;
        ext::shared_ptr<BlackProcess> process2_;
        Handle<Quote> rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="264">
    <source>exoticoptions/margrabeoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    MargrabeOption::MargrabeOption(Integer Q1,
                                   Integer Q2,
                                   const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(ext::shared_ptr<Payoff>(new NullPayoff), exercise),
      Q1_(Q1),
      Q2_(Q2) {}

    Real MargrabeOption::delta1() const {
        calculate();
        QL_REQUIRE(delta1_ != Null<Real>(), "delta1 not provided");
        return delta1_;
    }

    Real MargrabeOption::delta2() const {
        calculate();
        QL_REQUIRE(delta2_ != Null<Real>(), "delta2 not provided");
        return delta2_;
    }

    Real MargrabeOption::gamma1() const {
        calculate();
        QL_REQUIRE(gamma1_ != Null<Real>(), "gamma1 not provided");
        return gamma1_;
    }

    Real MargrabeOption::gamma2() const {
        calculate();
        QL_REQUIRE(gamma2_ != Null<Real>(), "gamma2 not provided");
        return gamma2_;
    }

    void MargrabeOption::setupArguments(PricingEngine::arguments* args) const {

        MultiAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<MargrabeOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");

        moreArgs->Q1 = Q1_;
        moreArgs->Q2 = Q2_;
    }

    void MargrabeOption::arguments::validate() const {

        MultiAssetOption::arguments::validate();

        QL_REQUIRE(Q1 != Null<Integer>(), "unspecified quantity for asset 1");
        QL_REQUIRE(Q2 != Null<Integer>(), "unspecified quantity for asset 2");
        QL_REQUIRE(Q1 > 0, "quantity of asset 1 must be positive");
        QL_REQUIRE(Q2 > 0, "quantity of asset 2 must be positive");
    }

    void MargrabeOption::fetchResults(const PricingEngine::results* r) const {
        MultiAssetOption::fetchResults(r);
        const auto* results = dynamic_cast<const MargrabeOption::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");
        delta1_          = results->delta1;
        delta2_          = results->delta2;
        gamma1_          = results->gamma1;
        gamma2_          = results->gamma2;
    }

}
]]></document_content>
  </document>
  <document index="265">
    <source>exoticoptions/margrabeoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file margrabeoption.hpp
    \brief Margrabe option on two assets
*/

#ifndef quantlib_margrabe_option_hpp
#define quantlib_margrabe_option_hpp

#include <ql/instruments/multiassetoption.hpp>

namespace QuantLib {

    //! Margrabe option on two assets
    /*! This option gives the holder the right to exchange Q2 stocks
        of the second asset for Q1 stocks of the first at expiration.

        \ingroup instruments
    */
    class MargrabeOption : public MultiAssetOption {
      public:
        class arguments;
        class results;
        class engine;
        MargrabeOption(Integer Q1,
                       Integer Q2,
                       const ext::shared_ptr<Exercise>&);
        void setupArguments(PricingEngine::arguments*) const override;
        Real delta1() const;
        Real delta2() const;
        Real gamma1() const;
        Real gamma2() const;
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        Integer Q1_;
        Integer Q2_;
        mutable Real delta1_, delta2_, gamma1_, gamma2_;
    };

    //! Extra %arguments for Margrabe option
    class MargrabeOption::arguments
        : public MultiAssetOption::arguments {
      public:
        arguments() : Q1(Null<Integer>()),
                      Q2(Null<Integer>()) {}
        void validate() const override;
        Integer Q1;
        Integer Q2;
    };

    //! Extra %results for Margrabe option
    class MargrabeOption::results
        : public MultiAssetOption::results {
      public:
        results() : delta1(Null<Real>()),
                    delta2(Null<Real>()),
                    gamma1(Null<Real>()),
                    gamma2(Null<Real>()) {}
        Real delta1;
        Real delta2;
        Real gamma1;
        Real gamma2;
        void reset() override {
            MultiAssetOption::results::reset();
            delta1 = Null<Real>();
            delta2 = Null<Real>();
            gamma1 = Null<Real>();
            gamma2 = Null<Real>();
        }
    };

    //! %Margrabe option %engine base class
    class MargrabeOption::engine
        : public GenericEngine<MargrabeOption::arguments,
                               MargrabeOption::results> {};
}


#endif
]]></document_content>
  </document>
  <document index="266">
    <source>exoticoptions/mceverestengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/mceverestengine.hpp>

namespace QuantLib {

    EverestMultiPathPricer::EverestMultiPathPricer(Real notional,
                                                   Real guarantee,
                                                   DiscountFactor discount)
    : notional_(notional), guarantee_(guarantee), discount_(discount) {}

    Real EverestMultiPathPricer::operator()(const MultiPath& multiPath) const {

        Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        Size numAssets = multiPath.assetNumber();
        QL_REQUIRE(numAssets>0, "there must be some paths");

        // We search the yield min
        Real minYield = multiPath[0].back() / multiPath[0].front() - 1.0;
        for (Size j=1; j<numAssets; ++j) {
            Rate yield = multiPath[j].back() / multiPath[j].front() - 1.0;
            minYield = std::min(minYield, yield);
        }
        return (1.0 + minYield + guarantee_) * notional_ * discount_;
    }

}

]]></document_content>
  </document>
  <document index="267">
    <source>exoticoptions/mceverestengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mceverestengine.hpp
    \brief Monte Carlo engine for Everest options
*/

#ifndef quantlib_mc_everest_engine_hpp
#define quantlib_mc_everest_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/everestoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCEverestEngine : public EverestOption::engine,
                            public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        MCEverestEngine(ext::shared_ptr<StochasticProcessArray>,
                        Size timeSteps,
                        Size timeStepsPerYear,
                        bool brownianBridge,
                        bool antitheticVariate,
                        Size requiredSamples,
                        Real requiredTolerance,
                        Size maxSamples,
                        BigNatural seed);
        void calculate() const override {

            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();

            if (RNG::allowsErrorEstimate) {
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
            }

            Real notional = arguments_.notional;
            DiscountFactor discount = endDiscount();
            results_.yield = results_.value/(notional * discount) - 1.0;
        }

      private:
        DiscountFactor endDiscount() const;
        // McEverest implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo Everest-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCEverestEngine {
      public:
        explicit MakeMCEverestEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCEverestEngine& withSteps(Size steps);
        MakeMCEverestEngine& withStepsPerYear(Size steps);
        MakeMCEverestEngine& withBrownianBridge(bool b = true);
        MakeMCEverestEngine& withAntitheticVariate(bool b = true);
        MakeMCEverestEngine& withSamples(Size samples);
        MakeMCEverestEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCEverestEngine& withMaxSamples(Size samples);
        MakeMCEverestEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class EverestMultiPathPricer : public PathPricer<MultiPath> {
      public:
        explicit EverestMultiPathPricer(Real notional,
                                        Rate guarantee,
                                        DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        Real notional_;
        Rate guarantee_;
        DiscountFactor discount_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCEverestEngine<RNG, S>::MCEverestEngine(
        ext::shared_ptr<StochasticProcessArray> processes,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCEverestEngine<RNG,S>::timeGrid() const {
        Time residualTime = processes_->time(
                                       this->arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

    template <class RNG, class S>
    inline DiscountFactor MCEverestEngine<RNG,S>::endDiscount() const {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return process->riskFreeRate()->discount(
                                             arguments_.exercise->lastDate());
    }

    template <class RNG, class S>
    inline ext::shared_ptr<typename MCEverestEngine<RNG,S>::path_pricer_type>
    MCEverestEngine<RNG,S>::pathPricer() const {

        return ext::shared_ptr<
                         typename MCEverestEngine<RNG,S>::path_pricer_type>(
                              new EverestMultiPathPricer(arguments_.notional,
                                                         arguments_.guarantee,
                                                         endDiscount()));
    }


    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG, S>::MakeMCEverestEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      steps_(Null<Size>()), stepsPerYear_(Null<Size>()), samples_(Null<Size>()),
      maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCEverestEngine<RNG,S>::operator
    ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCEverestEngine<RNG,S>(process_,
                                   steps_,
                                   stepsPerYear_,
                                   brownianBridge_,
                                   antithetic_,
                                   samples_, tolerance_,
                                   maxSamples_,
                                   seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="268">
    <source>exoticoptions/mchimalayaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/mchimalayaengine.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    HimalayaMultiPathPricer::HimalayaMultiPathPricer(ext::shared_ptr<Payoff> payoff,
                                                     DiscountFactor discount)
    : payoff_(std::move(payoff)), discount_(discount) {}

    Real HimalayaMultiPathPricer::operator()(const MultiPath& multiPath)
                                                                      const {
        Size numAssets = multiPath.assetNumber();
        Size numNodes = multiPath.pathSize();
        QL_REQUIRE(numAssets > 0, "no asset given");

        std::vector<bool> remainingAssets(numAssets, true);
        Real averagePrice = 0.0;
        Size fixings = numNodes-1;
        for (Size i = 1; i < numNodes; i++) {
            Real bestPrice = 0.0;
            Real bestYield = QL_MIN_REAL;
            // dummy assignement to avoid compiler warning
            Size removeAsset = 0;
            for (Size j = 0; j < numAssets; j++) {
                if (remainingAssets[j]) {
                    Real price = multiPath[j][i];
                    Real yield = price/multiPath[j].front();
                    if (yield >= bestYield) {
                        bestPrice = price;
                        removeAsset = j;
                    }
                }
            }
            remainingAssets[removeAsset] = false;
            averagePrice += bestPrice;
        }
        averagePrice /= std::min(fixings, numAssets);

        Real payoff = (*payoff_)(averagePrice);
        return payoff * discount_;
    }

}

]]></document_content>
  </document>
  <document index="269">
    <source>exoticoptions/mchimalayaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mchimalayaengine.hpp
    \brief Monte Carlo engine for Himalaya options
*/

#ifndef quantlib_mc_himalaya_engine_hpp
#define quantlib_mc_himalaya_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/himalayaoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCHimalayaEngine : public HimalayaOption::engine,
                             public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        MCHimalayaEngine(ext::shared_ptr<StochasticProcessArray>,
                         bool brownianBridge,
                         bool antitheticVariate,
                         Size requiredSamples,
                         Real requiredTolerance,
                         Size maxSamples,
                         BigNatural seed);

        void calculate() const override {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();

            if (RNG::allowsErrorEstimate)
            results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }

      private:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo Himalaya-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCHimalayaEngine {
      public:
        explicit MakeMCHimalayaEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCHimalayaEngine& withBrownianBridge(bool b = true);
        MakeMCHimalayaEngine& withAntitheticVariate(bool b = true);
        MakeMCHimalayaEngine& withSamples(Size samples);
        MakeMCHimalayaEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCHimalayaEngine& withMaxSamples(Size samples);
        MakeMCHimalayaEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class HimalayaMultiPathPricer : public PathPricer<MultiPath> {
      public:
        HimalayaMultiPathPricer(ext::shared_ptr<Payoff> payoff, DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        ext::shared_ptr<Payoff> payoff_;
        DiscountFactor discount_;
    };

    // template definitions

    template <class RNG, class S>
    inline MCHimalayaEngine<RNG, S>::MCHimalayaEngine(
        ext::shared_ptr<StochasticProcessArray> processes,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCHimalayaEngine<RNG,S>::timeGrid() const {

        std::vector<Time> fixingTimes;
        for (Size i=0; i<arguments_.fixingDates.size(); i++) {
            Time t = processes_->time(arguments_.fixingDates[i]);
            QL_REQUIRE(t >= 0.0, "seasoned options are not handled");
            if (i > 0) {
                QL_REQUIRE(t > fixingTimes.back(), "fixing dates not sorted");
            }
            fixingTimes.push_back(t);
        }

        return TimeGrid(fixingTimes.begin(), fixingTimes.end());
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCHimalayaEngine<RNG,S>::path_pricer_type>
    MCHimalayaEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<
                         typename MCHimalayaEngine<RNG,S>::path_pricer_type>(
            new HimalayaMultiPathPricer(arguments_.payoff,
                                        process->riskFreeRate()->discount(
                                           arguments_.exercise->lastDate())));
    }


    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG, S>::MakeMCHimalayaEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCHimalayaEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        return ext::shared_ptr<PricingEngine>(new
            MCHimalayaEngine<RNG,S>(process_,
                                    brownianBridge_,
                                    antithetic_,
                                    samples_,
                                    tolerance_,
                                    maxSamples_,
                                    seed_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="270">
    <source>exoticoptions/mcpagodaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/mcpagodaengine.hpp>

namespace QuantLib {

    PagodaMultiPathPricer::PagodaMultiPathPricer(Real roof, Real fraction,
                                                 DiscountFactor discount)
    : discount_(discount), roof_(roof), fraction_(fraction) {}

    Real PagodaMultiPathPricer::operator()(const MultiPath& multiPath) const {

        Size numAssets = multiPath.assetNumber();
        Size numSteps = multiPath.pathSize();

        Real averagePerformance = 0.0;
        for (Size i = 1; i < numSteps; i++) {
            for (Size j = 0; j < numAssets; j++) {
                averagePerformance +=
                    multiPath[j].front() *
                    (multiPath[j][i]/multiPath[j][i-1] - 1.0);
            }
        }
        averagePerformance /= numAssets;

        return discount_ * fraction_
            * std::max<Real>(0.0, std::min(roof_, averagePerformance));
    }

}

]]></document_content>
  </document>
  <document index="271">
    <source>exoticoptions/mcpagodaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcpagodaengine.hpp
    \brief Monte Carlo engine for pagoda options
*/

#ifndef quantlib_mc_pagoda_engine_hpp
#define quantlib_mc_pagoda_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/pagodaoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for pagoda options using Monte Carlo simulation
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCPagodaEngine : public PagodaOption::engine,
                           public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCPagodaEngine(ext::shared_ptr<StochasticProcessArray>,
                       bool brownianBridge,
                       bool antitheticVariate,
                       Size requiredSamples,
                       Real requiredTolerance,
                       Size maxSamples,
                       BigNatural seed);
        void calculate() const override {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      private:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo pagoda-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCPagodaEngine {
      public:
        explicit MakeMCPagodaEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCPagodaEngine& withBrownianBridge(bool b = true);
        MakeMCPagodaEngine& withAntitheticVariate(bool b = true);
        MakeMCPagodaEngine& withSamples(Size samples);
        MakeMCPagodaEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCPagodaEngine& withMaxSamples(Size samples);
        MakeMCPagodaEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class PagodaMultiPathPricer : public PathPricer<MultiPath> {
      public:
        PagodaMultiPathPricer(Real roof, Real fraction,
                              DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        DiscountFactor discount_;
        Real roof_, fraction_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCPagodaEngine<RNG, S>::MCPagodaEngine(ext::shared_ptr<StochasticProcessArray> processes,
                                                  bool brownianBridge,
                                                  bool antitheticVariate,
                                                  Size requiredSamples,
                                                  Real requiredTolerance,
                                                  Size maxSamples,
                                                  BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCPagodaEngine<RNG,S>::timeGrid() const {

        std::vector<Time> fixingTimes;
        for (Size i=0; i<arguments_.fixingDates.size(); i++) {
            Time t = processes_->time(arguments_.fixingDates[i]);
            QL_REQUIRE(t >= 0.0, "seasoned options are not handled");
            if (i > 0) {
                QL_REQUIRE(t > fixingTimes.back(), "fixing dates not sorted");
            }
            fixingTimes.push_back(t);
        }

        return TimeGrid(fixingTimes.begin(), fixingTimes.end());
    }


    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCPagodaEngine<RNG,S>::path_pricer_type>
    MCPagodaEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<
                         typename MCPagodaEngine<RNG,S>::path_pricer_type>(
            new PagodaMultiPathPricer(arguments_.roof, arguments_.fraction,
                                      process->riskFreeRate()->discount(
                                           arguments_.exercise->lastDate())));
    }


    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG, S>::MakeMCPagodaEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCPagodaEngine<RNG,S>::operator
    ext::shared_ptr<PricingEngine>() const {
        return ext::shared_ptr<PricingEngine>(new
            MCPagodaEngine<RNG,S>(process_,
                                  brownianBridge_,
                                  antithetic_,
                                  samples_, tolerance_,
                                  maxSamples_,
                                  seed_));
    }

}



#endif
]]></document_content>
  </document>
  <document index="272">
    <source>exoticoptions/pagodaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/pagodaoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    PagodaOption::PagodaOption(const std::vector<Date>& fixingDates,
                               Real roof,
                               Real fraction)
    : MultiAssetOption(ext::shared_ptr<Payoff>(new NullPayoff),
                       ext::shared_ptr<Exercise>(
                                   new EuropeanExercise(fixingDates.back()))),
      fixingDates_(fixingDates), roof_(roof), fraction_(fraction) {}


    void PagodaOption::setupArguments(PricingEngine::arguments* args) const {
        MultiAssetOption::setupArguments(args);

        auto* arguments = dynamic_cast<PagodaOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->fixingDates = fixingDates_;
        arguments->roof = roof_;
        arguments->fraction = fraction_;
    }


    PagodaOption::arguments::arguments()
    : roof(Null<Real>()), fraction(Null<Real>()) {}

    void PagodaOption::arguments::validate() const {
        MultiAssetOption::arguments::validate();
        QL_REQUIRE(!fixingDates.empty(), "no fixingDates given");
        QL_REQUIRE(roof != Null<Real>(), "no roof given");
        QL_REQUIRE(fraction != Null<Real>(), "no fraction given");
    }

}
]]></document_content>
  </document>
  <document index="273">
    <source>exoticoptions/pagodaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pagodaoption.hpp
    \brief Roofed Asian option on a number of assets
*/

#ifndef quantlib_pagoda_option_hpp
#define quantlib_pagoda_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    //! Roofed Asian option on a number of assets
    /*! The payoff is a given fraction multiplied by the minimum
        between a given roof and the positive portfolio performance.
        If the performance of the portfolio is below then the payoff
        is null.

        \warning This implementation still does not manage seasoned
                 options.

        \ingroup instruments
    */
    class PagodaOption : public MultiAssetOption {
      public:
        class engine;
        class arguments;
        PagodaOption(const std::vector<Date>& fixingDates,
                     Real roof,
                     Real fraction);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        std::vector<Date> fixingDates_;
        Real roof_;
        Real fraction_;
    };


    class PagodaOption::arguments : public MultiAssetOption::arguments {
      public:
        arguments();
        void validate() const override;
        std::vector<Date> fixingDates;
        Real roof; Real fraction;
    };


    //! %Pagoda-option %engine base class
    class PagodaOption::engine
        : public GenericEngine<PagodaOption::arguments,
                               PagodaOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="274">
    <source>exoticoptions/partialtimebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/partialtimebarrieroption.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    PartialTimeBarrierOption::PartialTimeBarrierOption(
                           PartialBarrier::Type barrierType,
                           PartialBarrier::Range barrierRange,
                           Real barrier,
                           Real rebate,
                           Date coverEventDate,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrierRange_(barrierRange),
      barrier_(barrier), rebate_(rebate),
      coverEventDate_(coverEventDate) {}

    void PartialTimeBarrierOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<PartialTimeBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrierRange = barrierRange_;
        moreArgs->barrier = barrier_;
        moreArgs->rebate = rebate_;
        moreArgs->coverEventDate = coverEventDate_;
    }

    PartialTimeBarrierOption::arguments::arguments()
    : barrierType(PartialBarrier::Type(-1)),
      barrierRange(PartialBarrier::Range(-1)),
      barrier(Null<Real>()), rebate(Null<Real>()),
      coverEventDate(Null<Date>()) {}

    void PartialTimeBarrierOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        
        // checking barrier type and suitable barrier range
        switch (barrierType) {
          case PartialBarrier::DownIn:
          case PartialBarrier::UpIn:
            QL_REQUIRE(barrierRange == PartialBarrier::Start ||
                       barrierRange == PartialBarrier::End,
                       "in-barrier requires Start or End range");
            break;
          case PartialBarrier::DownOut:
          case PartialBarrier::UpOut:
            QL_REQUIRE(barrierRange == PartialBarrier::Start ||
                       barrierRange == PartialBarrier::EndB1 ||
                       barrierRange == PartialBarrier::EndB2,
                       "out-barrier requires Start, EndB1 or EndB2 range");
            break;
          default:
            QL_FAIL("unknown barrier type");
        }

        QL_REQUIRE(barrier != Null<Real>(), "no barrier given");
        QL_REQUIRE(rebate != Null<Real>(), "no rebate given");
        QL_REQUIRE(coverEventDate != Null<Date>(), "no cover event date given");
        QL_REQUIRE(coverEventDate < exercise->lastDate(),
                   "cover event date equal or later than exercise date");
    }

}

]]></document_content>
  </document>
  <document index="275">
    <source>exoticoptions/partialtimebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file partialtimebarrieroption.hpp
    \brief Partial-time barrier option
*/

#ifndef quantlib_partial_time_barrier_option_hpp
#define quantlib_partial_time_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    struct PartialBarrier : public Barrier {
        enum Range { Start, End, EndB1, EndB2 };
    };

    class PartialTimeBarrierOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        PartialTimeBarrierOption(PartialBarrier::Type barrierType,
            PartialBarrier::Range barrierRange,
            Real barrier,
            Real rebate,
            Date coverEventDate,
            const ext::shared_ptr<StrikedTypePayoff>& payoff,
            const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        PartialBarrier::Type barrierType_;
        PartialBarrier::Range barrierRange_;
        Real barrier_;
        Real rebate_;
        Date coverEventDate_;
    };

    //! %Arguments for barrier option calculation
    class PartialTimeBarrierOption::arguments
        : public OneAssetOption::arguments {
      public:
        arguments();
        PartialBarrier::Type barrierType;
        PartialBarrier::Range barrierRange;
        Real barrier;
        Real rebate;
        Date coverEventDate;
        void validate() const override;
    };

    //! %Partial-Time-Barrier-Option %engine base class
    class PartialTimeBarrierOption::engine
        : public GenericEngine<PartialTimeBarrierOption::arguments,
                               PartialTimeBarrierOption::results> {
    };

}


#endif
]]></document_content>
  </document>
  <document index="276">
    <source>exoticoptions/simplechooseroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/simplechooseroption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    SimpleChooserOption::SimpleChooserOption(
                                  Date choosingDate,
                                  Real strike,
                                  const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(ext::shared_ptr<Payoff>(
                                new PlainVanillaPayoff(Option::Call, strike)),
                     exercise),
      choosingDate_(choosingDate) {}

    void SimpleChooserOption::setupArguments(
                                    PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<SimpleChooserOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->choosingDate=choosingDate_;
    }

    void SimpleChooserOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(choosingDate != Date(), " no choosing date given");
        QL_REQUIRE(choosingDate < exercise->lastDate(),
                   "choosing date later than or equal to maturity date");
    }

}
]]></document_content>
  </document>
  <document index="277">
    <source>exoticoptions/simplechooseroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file simplechooseroption.hpp
    \brief Simple chooser option on a single asset
*/

#ifndef quantlib_simple_chooser_option_hpp
#define quantlib_simple_chooser_option_hpp

#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib {

    //! Simple chooser option
    /*! This option gives the holder the right to choose, at a future
        date prior to exercise, whether the option should be a call or
        a put.  The exercise date and strike are the same for both
        call and put option.
    */
    class SimpleChooserOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        SimpleChooserOption(Date choosingDate,
                            Real strike,
                            const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Date choosingDate_;
    };

    //! Extra %arguments for single chooser option
    class SimpleChooserOption::arguments
        : public OneAssetOption::arguments {
      public:
        arguments() : choosingDate(Null<Date>()) {}
        void validate() const override;
        Date choosingDate;
    };

    //! Simple chooser option %engine base class
    class SimpleChooserOption::engine
        : public GenericEngine<SimpleChooserOption::arguments,
                               SimpleChooserOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="278">
    <source>exoticoptions/spreadoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file spreadoption.hpp
    \brief Spread option on two assets
*/

#ifndef quantlib_spread_option_hpp
#define quantlib_spread_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Spread option on two assets
    class SpreadOption : public MultiAssetOption {
      public:
        class engine;
        SpreadOption(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                     const ext::shared_ptr<Exercise>& exercise)
        : MultiAssetOption(payoff, exercise) {}
    };

    //! %Spread option %engine base class
    class SpreadOption::engine
        : public GenericEngine<SpreadOption::arguments,
                               SpreadOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="279">
    <source>exoticoptions/twoassetbarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/twoassetbarrieroption.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    TwoAssetBarrierOption::TwoAssetBarrierOption(
                           Barrier::Type barrierType,
                           Real barrier,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : Option(payoff, exercise), barrierType_(barrierType), barrier_(barrier) {}

    void TwoAssetBarrierOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        Option::setupArguments(args);
        auto* moreArgs = dynamic_cast<TwoAssetBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier = barrier_;
    }
    
    bool TwoAssetBarrierOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }

    TwoAssetBarrierOption::arguments::arguments()
    : barrierType(Barrier::Type(-1)), barrier(Null<Real>()) {}

    void TwoAssetBarrierOption::arguments::validate() const {
        Option::arguments::validate();

        switch (barrierType) {
          case Barrier::DownIn:
          case Barrier::UpIn:
          case Barrier::DownOut:
          case Barrier::UpOut:
            break;
          default:
            QL_FAIL("unknown type");
        }

        QL_REQUIRE(barrier != Null<Real>(), "no barrier given");
    }

    bool TwoAssetBarrierOption::engine::triggered(Real underlying) const {
        switch (arguments_.barrierType) {
          case Barrier::DownIn:
          case Barrier::DownOut:
            return underlying < arguments_.barrier;
          case Barrier::UpIn:
          case Barrier::UpOut:
            return underlying > arguments_.barrier;
          default:
            QL_FAIL("unknown type");
        }
    }

}

]]></document_content>
  </document>
  <document index="280">
    <source>exoticoptions/twoassetbarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file twoassetbarrieroption.hpp
    \brief Barrier option on two assets
*/

#ifndef quantlib_two_asset_barrier_option_hpp
#define quantlib_two_asset_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! %Barrier option on two assets
    /*! \ingroup instruments */
    class TwoAssetBarrierOption : public Option {
      public:
        class arguments;
        class engine;
        TwoAssetBarrierOption(
                      Barrier::Type barrierType,
                      Real barrier,
                      const ext::shared_ptr<StrikedTypePayoff>& payoff,
                      const ext::shared_ptr<Exercise>& exercise);

        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        Barrier::Type barrierType_;
        Real barrier_;
    };


    //! %Arguments for two-asset %barrier %option calculation
    class TwoAssetBarrierOption::arguments : public Option::arguments {
      public:
        arguments();
        Barrier::Type barrierType;
        Real barrier;
        void validate() const override;
    };

    //! %Two-asset barrier-option %engine base class
    class TwoAssetBarrierOption::engine
        : public GenericEngine<TwoAssetBarrierOption::arguments,
                               TwoAssetBarrierOption::results> {
      protected:
        bool triggered(Real underlying) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="281">
    <source>exoticoptions/twoassetcorrelationoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/exoticoptions/twoassetcorrelationoption.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    TwoAssetCorrelationOption::TwoAssetCorrelationOption(
                           Option::Type type,
                           Real strike1,
                           Real strike2,
                           const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(ext::make_shared<PlainVanillaPayoff>(type, strike1),
                       exercise), X2_(strike2) {}

    void TwoAssetCorrelationOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        MultiAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<TwoAssetCorrelationOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");

        moreArgs->X2 = X2_;
    }

}

]]></document_content>
  </document>
  <document index="282">
    <source>exoticoptions/twoassetcorrelationoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file twoassetcorrelationoption.hpp
    \brief Two-asset correlation option
*/

#ifndef quantlib_two_asset_correlation_option_hpp
#define quantlib_two_asset_correlation_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class TwoAssetCorrelationOption : public MultiAssetOption {
      public:
        class arguments;
        class engine;
        TwoAssetCorrelationOption(Option::Type type,
                                  Real strike1,
                                  Real strike2,
                                  const ext::shared_ptr<Exercise>&);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Real X2_;
    };

    class TwoAssetCorrelationOption::arguments
        : public MultiAssetOption::arguments {
      public:
        arguments() : X2(Null<Real>()) {}
        void validate() const override {
            MultiAssetOption::arguments::validate();
            QL_REQUIRE(X2 != Null<Real>(), "no X2 given");
        }
        Real X2;
    };

    class TwoAssetCorrelationOption::engine
        : public GenericEngine<TwoAssetCorrelationOption::arguments,
                               TwoAssetCorrelationOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="283">
    <source>exoticoptions/writerextensibleoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/experimental/exoticoptions/writerextensibleoption.hpp>
#include <utility>

namespace QuantLib {

    WriterExtensibleOption::WriterExtensibleOption(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff1,
        const ext::shared_ptr<Exercise>& exercise1,
        const ext::shared_ptr<PlainVanillaPayoff>& payoff2,
        ext::shared_ptr<Exercise> exercise2)
    : OneAssetOption(payoff1, exercise1), payoff2_(payoff2), exercise2_(std::move(exercise2)) {}

    void WriterExtensibleOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* otherArguments = dynamic_cast<WriterExtensibleOption::arguments*>(args);
        QL_REQUIRE(otherArguments != nullptr, "wrong arguments type");

        otherArguments->payoff2 = payoff2_;
        otherArguments->exercise2 = exercise2_;
    }

    bool WriterExtensibleOption::isExpired() const {
        return detail::simple_event(exercise2_->lastDate()).hasOccurred();
    }

    void WriterExtensibleOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(payoff2, "no second payoff given");
        QL_REQUIRE(exercise2, "no second exercise given");
        QL_REQUIRE(exercise2->lastDate() > exercise->lastDate(),
                   "second exercise date is not later than the first");
    }

}
]]></document_content>
  </document>
  <document index="284">
    <source>exoticoptions/writerextensibleoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file writerextensibleoption.hpp
    \brief Writer-extensible option
*/

#ifndef quantlib_writer_extensible_option_hpp
#define quantlib_writer_extensible_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! Writer-extensible option
    class WriterExtensibleOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        /*!
          \param payoff1    The first payoff
          \param exercise1  The first exercise date
          \param payoff2    The payoff of the extended option
          \param exercise2  The second exercise date
        */
        WriterExtensibleOption(const ext::shared_ptr<PlainVanillaPayoff>& payoff1,
                               const ext::shared_ptr<Exercise>& exercise1,
                               const ext::shared_ptr<PlainVanillaPayoff>& payoff2,
                               ext::shared_ptr<Exercise> exercise2);
        // inspectors
        ext::shared_ptr<Payoff> payoff2() { return payoff2_; }
        ext::shared_ptr<Exercise> exercise2() { return exercise2_; };
        // Instrument interface
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        ext::shared_ptr<StrikedTypePayoff> payoff2_;
        ext::shared_ptr<Exercise> exercise2_;
    };

    //! Additional arguments for writer-extensible option
    class WriterExtensibleOption::arguments
        : public OneAssetOption::arguments {
      public:
        void validate() const override;
        ext::shared_ptr<Payoff> payoff2;
        ext::shared_ptr<Exercise> exercise2;
    };

    //! Base engine
    class WriterExtensibleOption::engine :
        public GenericEngine<WriterExtensibleOption::arguments,
                             WriterExtensibleOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="285">
    <source>finitedifferences/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    dynprogvppintrinsicvalueengine.hpp \
    fdextoujumpvanillaengine.hpp \
	fdklugeextouspreadengine.hpp \
	fdmblackscholesfwdop.hpp \
	fdmdupire1dop.hpp \
	fdmexpextouinnervaluecalculator.hpp \
	fdmextendedornsteinuhlenbeckop.hpp \
	fdmextoujumpmodelinnervalue.hpp \
	fdmextoujumpop.hpp \
	fdmextoujumpsolver.hpp \
	fdhestondoublebarrierengine.hpp \
	fdmhestongreensfct.hpp \
	fdmhestonfwdop.hpp \
	fdmklugeextouop.hpp \
	fdmklugeextousolver.hpp \
	fdmsimple2dextousolver.hpp \
    fdmsimple3dextoujumpsolver.hpp \
	fdmspreadpayoffinnervalue.hpp \
	fdmsquarerootfwdop.hpp \
	fdmvppstartlimitstepcondition.hpp \
	fdmvppstepcondition.hpp \
	fdmvppstepconditionfactory.hpp \
	fdmzabrop.hpp \
	fdornsteinuhlenbeckvanillaengine.hpp \
	fdsimpleextoujumpswingengine.hpp \
    fdsimpleextoustorageengine.hpp \
	fdsimpleklugeextouvppengine.hpp \
	glued1dmesher.hpp \
	modtriplebandlinearop.hpp \
	vanillavppoption.hpp

cpp_files = \
	dynprogvppintrinsicvalueengine.cpp \
    fdextoujumpvanillaengine.cpp \
	fdklugeextouspreadengine.cpp \
	fdmblackscholesfwdop.cpp \
	fdmdupire1dop.cpp \
	fdmextendedornsteinuhlenbeckop.cpp \
	fdmextoujumpop.cpp \
	fdmextoujumpsolver.cpp \
	fdhestondoublebarrierengine.cpp \
	fdmhestongreensfct.cpp \
	fdmhestonfwdop.cpp \
	fdmklugeextouop.cpp \
	fdmsquarerootfwdop.cpp \
	fdmvppstartlimitstepcondition.cpp \
	fdmvppstepcondition.cpp \
	fdmvppstepconditionfactory.cpp \
	fdmzabrop.cpp \
	fdornsteinuhlenbeckvanillaengine.cpp \
	fdsimpleextoujumpswingengine.cpp \
    fdsimpleextoustorageengine.cpp \
    fdsimpleklugeextouvppengine.cpp \
	glued1dmesher.cpp \
	vanillavppoption.cpp

if UNITY_BUILD

nodist_libMultiDimFDM_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libMultiDimFDM_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libMultiDimFDM.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="286">
    <source>finitedifferences/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/finitedifferences/dynprogvppintrinsicvalueengine.hpp>
#include <ql/experimental/finitedifferences/fdextoujumpvanillaengine.hpp>
#include <ql/experimental/finitedifferences/fdklugeextouspreadengine.hpp>
#include <ql/experimental/finitedifferences/fdmblackscholesfwdop.hpp>
#include <ql/experimental/finitedifferences/fdmdupire1dop.hpp>
#include <ql/experimental/finitedifferences/fdmexpextouinnervaluecalculator.hpp>
#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpsolver.hpp>
#include <ql/experimental/finitedifferences/fdhestondoublebarrierengine.hpp>
#include <ql/experimental/finitedifferences/fdmhestongreensfct.hpp>
#include <ql/experimental/finitedifferences/fdmhestonfwdop.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextouop.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextousolver.hpp>
#include <ql/experimental/finitedifferences/fdmsimple2dextousolver.hpp>
#include <ql/experimental/finitedifferences/fdmsimple3dextoujumpsolver.hpp>
#include <ql/experimental/finitedifferences/fdmspreadpayoffinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmsquarerootfwdop.hpp>
#include <ql/experimental/finitedifferences/fdmvppstartlimitstepcondition.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepconditionfactory.hpp>
#include <ql/experimental/finitedifferences/fdmzabrop.hpp>
#include <ql/experimental/finitedifferences/fdornsteinuhlenbeckvanillaengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoujumpswingengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoustorageengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleklugeextouvppengine.hpp>
#include <ql/experimental/finitedifferences/glued1dmesher.hpp>
#include <ql/experimental/finitedifferences/modtriplebandlinearop.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>

]]></document_content>
  </document>
  <document index="287">
    <source>finitedifferences/dynprogvppintrinsicvalueengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dynprogvppintrinsicvalueengine.cpp
*/

#include <ql/experimental/finitedifferences/dynprogvppintrinsicvalueengine.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepconditionfactory.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>


namespace QuantLib {
    namespace {
        class SparkSpreadPrice : public FdmInnerValueCalculator {
          public:
            SparkSpreadPrice(Real heatRate,
                             const std::vector<Real>& fuelPrices,
                             const std::vector<Real>& powerPrices)
            : heatRate_(heatRate),
              fuelPrices_(fuelPrices),
              powerPrices_(powerPrices) {}

            Real innerValue(const FdmLinearOpIterator&, Time t) override {
                Size i = (Size) t;
                QL_REQUIRE(i < powerPrices_.size(), "invalid time");
                return powerPrices_[i] - heatRate_*fuelPrices_[i];
            }
            Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
                return innerValue(iter, t);
            }

          private:
            const Real heatRate_;
            const std::vector<Real>& fuelPrices_;
            const std::vector<Real>& powerPrices_;
        };


        class FuelPrice : public FdmInnerValueCalculator {
          public:
            explicit FuelPrice(const std::vector<Real>& fuelPrices)
            : fuelPrices_(fuelPrices) {}

            Real innerValue(const FdmLinearOpIterator&, Time t) override {
                Size i = (Size) t;
                QL_REQUIRE(i < fuelPrices_.size(), "invalid time");
                return fuelPrices_[(Size) t];
            }
            Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
                return innerValue(iter, t);
            }

          private:
            const std::vector<Real>& fuelPrices_;
        };
    }

    DynProgVPPIntrinsicValueEngine::DynProgVPPIntrinsicValueEngine(
        std::vector<Real> fuelPrices,
        std::vector<Real> powerPrices,
        Real fuelCostAddon,
        ext::shared_ptr<YieldTermStructure> rTS)
    : fuelPrices_(std::move(fuelPrices)), powerPrices_(std::move(powerPrices)),
      fuelCostAddon_(fuelCostAddon), rTS_(std::move(rTS)) {}

    void DynProgVPPIntrinsicValueEngine::calculate() const {
        const ext::shared_ptr<FdmInnerValueCalculator> fuelPrice(
            new FuelPrice(fuelPrices_));
        const ext::shared_ptr<FdmInnerValueCalculator> sparkSpreadPrice(
            new SparkSpreadPrice(arguments_.heatRate,fuelPrices_,powerPrices_));

        const FdmVPPStepConditionFactory stepConditionFactory(arguments_);

        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(stepConditionFactory.stateMesher()));

        const FdmVPPStepConditionMesher mesh = { 0, mesher };

        const ext::shared_ptr<FdmVPPStepCondition> stepCondition(
            stepConditionFactory.build(mesh, fuelCostAddon_,
                                       fuelPrice, sparkSpreadPrice));

        Array state(mesher->layout()->dim()[0], 0.0);
        for (Size j=powerPrices_.size(); j > 0; --j) {
            stepCondition->applyTo(state, (Time) j-1);
        }

        results_.value = stepCondition->maxValue(state);
    }
}

]]></document_content>
  </document>
  <document index="288">
    <source>finitedifferences/dynprogvppintrinsicvalueengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dynprogvppintrinsicvalueengine.hpp
    \brief intrinsic value engine using dynamic programming
*/

#ifndef quantlib_dp_vpp_intrinsic_value_engine_hpp
#define quantlib_dp_vpp_intrinsic_value_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <vector>

namespace QuantLib {

    class YieldTermStructure;

    class DynProgVPPIntrinsicValueEngine
        : public GenericEngine<VanillaVPPOption::arguments,
                               VanillaVPPOption::results> {
      public:
        DynProgVPPIntrinsicValueEngine(std::vector<Real> fuelPrices,
                                       std::vector<Real> powerPrices,
                                       Real fuelCostAddon,
                                       ext::shared_ptr<YieldTermStructure> rTS);

        void calculate() const override;

      private:
        const std::vector<Real> fuelPrices_;
        const std::vector<Real> powerPrices_;
        const Real fuelCostAddon_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="289">
    <source>finitedifferences/fdextoujumpvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdoujumpvanillaengine.cpp
    \brief Finite Differences Ornstein Uhlenbeck plus exponential jumps engine 
           for simple swing options
*/

#include <ql/exercise.hpp>
#include <ql/experimental/finitedifferences/fdextoujumpvanillaengine.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpsolver.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdExtOUJumpVanillaEngine::FdExtOUJumpVanillaEngine(
        ext::shared_ptr<ExtOUWithJumpsProcess> process,
        ext::shared_ptr<YieldTermStructure> rTS,
        Size tGrid,
        Size xGrid,
        Size yGrid,
        ext::shared_ptr<Shape> shape,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), rTS_(std::move(rTS)), shape_(std::move(shape)), tGrid_(tGrid),
      xGrid_(xGrid), yGrid_(yGrid), schemeDesc_(schemeDesc) {}

    void FdExtOUJumpVanillaEngine::calculate() const {
        // 1. Mesher
        const Time maturity 
            = rTS_->dayCounter().yearFraction(rTS_->referenceDate(),
                                              arguments_.exercise->lastDate());
        const ext::shared_ptr<StochasticProcess1D> ouProcess(
            process_->getExtendedOrnsteinUhlenbeckProcess());
        const ext::shared_ptr<Fdm1dMesher> xMesher(
            new FdmSimpleProcess1dMesher(xGrid_, ouProcess,maturity));

        const ext::shared_ptr<Fdm1dMesher> yMesher(
            new ExponentialJump1dMesher(yGrid_, 
                                        process_->beta(), 
                                        process_->jumpIntensity(),
                                        process_->eta()));

        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(xMesher, yMesher));

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
            new FdmExtOUJumpModelInnerValue(arguments_.payoff, mesher, shape_));

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                                DividendSchedule(), arguments_.exercise, 
                                mesher, calculator, 
                                rTS_->referenceDate(), rTS_->dayCounter());

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;
        
        // 5. set-up solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                    calculator, maturity, tGrid_, 0 };

        const ext::shared_ptr<FdmExtOUJumpSolver> solver(
            new FdmExtOUJumpSolver(Handle<ExtOUWithJumpsProcess>(process_), 
                                   rTS_, solverDesc, schemeDesc_));
      
        const Real x = process_->initialValues()[0];
        const Real y = process_->initialValues()[1];
        results_.value = solver->valueAt(x, y);      
    }
}
]]></document_content>
  </document>
  <document index="290">
    <source>finitedifferences/fdextoujumpvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimplebsswingengine.hpp
    \brief Finite Differences Ornstein Uhlenbeck plus exponential jumps engine 
           for vanilla options
*/

#ifndef quantlib_fd_simple_ou_jump_swing_engine_hpp
#define quantlib_fd_simple_ou_jump_swing_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class ExtOUWithJumpsProcess;

    class FdExtOUJumpVanillaEngine
        : public GenericEngine<VanillaOption::arguments,
                               VanillaOption::results> {
      public:
        typedef FdmExtOUJumpModelInnerValue::Shape Shape;
        FdExtOUJumpVanillaEngine(ext::shared_ptr<ExtOUWithJumpsProcess> p,
                                 ext::shared_ptr<YieldTermStructure> rTS,
                                 Size tGrid = 50,
                                 Size xGrid = 200,
                                 Size yGrid = 50,
                                 ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
                                 const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const ext::shared_ptr<Shape> shape_;
        const Size tGrid_, xGrid_, yGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="291">
    <source>finitedifferences/fdhestondoublebarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/finitedifferences/fdhestondoublebarrierengine.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/barrier/fdhestonrebateengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <utility>

namespace QuantLib {

    FdHestonDoubleBarrierEngine::FdHestonDoubleBarrierEngine(
        const ext::shared_ptr<HestonModel>& model,
        Size tGrid,
        Size xGrid,
        Size vGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        ext::shared_ptr<LocalVolTermStructure> leverageFct,
        const Real mixingFactor)
    : GenericModelEngine<HestonModel, DoubleBarrierOption::arguments, DoubleBarrierOption::results>(
          model),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)), mixingFactor_(mixingFactor) {}

    void FdHestonDoubleBarrierEngine::calculate() const {

        QL_REQUIRE(arguments_.barrierType == DoubleBarrier::KnockOut,
                "only Knock-Out double barrier options are supported");

        // 1. Mesher
        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const Time maturity = process->time(arguments_.exercise->lastDate());

        // 1.1 The variance mesher
        const Size tGridMin = 5;
        const Size tGridAvgSteps = std::max(tGridMin, tGrid_/50);

        const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> vMesher
            = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>(
                  vGrid_, process, leverageFct_, maturity, tGridAvgSteps, 0.0001, mixingFactor_);

        // 1.2 The equity mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        Real xMin = std::log(arguments_.barrier_lo);
        Real xMax = std::log(arguments_.barrier_hi);

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_,
                FdmBlackScholesMesher::processHelper(
                    process->s0(), process->dividendYield(),
                    process->riskFreeRate(), vMesher->volaEstimate()),
                maturity, payoff->strike(), xMin, xMax));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher, vMesher));

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                new FdmLogInnerValue(payoff, mesher, 0));

        // 3. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");

        ext::shared_ptr<FdmStepConditionComposite> conditions(
                new FdmStepConditionComposite(stoppingTimes, stepConditions));

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;
        boundaries.push_back(FdmBoundaryConditionSet::value_type(
            new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                     FdmDirichletBoundary::Lower)));

        boundaries.push_back(FdmBoundaryConditionSet::value_type(
            new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                     FdmDirichletBoundary::Upper)));

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        ext::shared_ptr<FdmHestonSolver> solver(new FdmHestonSolver(
                    Handle<HestonProcess>(process), solverDesc, schemeDesc_,
                    Handle<FdmQuantoHelper>(), leverageFct_, mixingFactor_));

        const Real spot = process->s0()->value();
        results_.value = solver->valueAt(spot, process->v0());
        results_.delta = solver->deltaAt(spot, process->v0());
        results_.gamma = solver->gammaAt(spot, process->v0());
        results_.theta = solver->thetaAt(spot, process->v0());
    }
}
]]></document_content>
  </document>
  <document index="292">
    <source>finitedifferences/fdhestondoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhestondoublebarrierengine.hpp
    \brief Finite-Differences Heston double barrier option engine
*/

#ifndef quantlib_fd_heston_double_barrier_engine_hpp
#define quantlib_fd_heston_double_barrier_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>


namespace QuantLib {

    //! Finite-Differences Heston Double Barrier Option engine

    /*!
        \ingroup barrierengines
    */
    class FdHestonDoubleBarrierEngine
        : public GenericModelEngine<HestonModel,
                                    DoubleBarrierOption::arguments,
                                    DoubleBarrierOption::results> {
      public:
        // Constructor
        explicit FdHestonDoubleBarrierEngine(
            const ext::shared_ptr<HestonModel>& model,
            Size tGrid = 100,
            Size xGrid = 100,
            Size vGrid = 50,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
            ext::shared_ptr<LocalVolTermStructure> leverageFct =
                ext::shared_ptr<LocalVolTermStructure>(),
            Real mixingFactor = 1.0);

        void calculate() const override;

      private:
        const Size tGrid_, xGrid_, vGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        const Real mixingFactor_;
    };


}

#endif
]]></document_content>
  </document>
  <document index="293">
    <source>finitedifferences/fdklugeextouspreadengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/exercise.hpp>
#include <ql/experimental/finitedifferences/fdklugeextouspreadengine.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextousolver.hpp>
#include <ql/experimental/finitedifferences/fdmspreadpayoffinnervalue.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdKlugeExtOUSpreadEngine::FdKlugeExtOUSpreadEngine(
        ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess,
        ext::shared_ptr<YieldTermStructure> rTS,
        Size tGrid,
        Size xGrid,
        Size yGrid,
        Size uGrid,
        ext::shared_ptr<GasShape> gasShape,
        ext::shared_ptr<PowerShape> powerShape,
        const FdmSchemeDesc& schemeDesc)
    : klugeOUProcess_(std::move(klugeOUProcess)), rTS_(std::move(rTS)), tGrid_(tGrid),
      xGrid_(xGrid), yGrid_(yGrid), uGrid_(uGrid), gasShape_(std::move(gasShape)),
      powerShape_(std::move(powerShape)), schemeDesc_(schemeDesc) {}

    void FdKlugeExtOUSpreadEngine::calculate() const {
        // 1. Mesher
        const Time maturity
            = rTS_->dayCounter().yearFraction(rTS_->referenceDate(),
                                              arguments_.exercise->lastDate());
        const ext::shared_ptr<ExtOUWithJumpsProcess> klugeProcess
                                          = klugeOUProcess_->getKlugeProcess();
        const ext::shared_ptr<StochasticProcess1D> ouProcess
                        = klugeProcess->getExtendedOrnsteinUhlenbeckProcess();
        const ext::shared_ptr<Fdm1dMesher> xMesher(
            new FdmSimpleProcess1dMesher(xGrid_, ouProcess,maturity));

        const ext::shared_ptr<Fdm1dMesher> yMesher(
            new ExponentialJump1dMesher(yGrid_,
                                        klugeProcess->beta(),
                                        klugeProcess->jumpIntensity(),
                                        klugeProcess->eta()));

        const ext::shared_ptr<Fdm1dMesher> uMesher(
            new FdmSimpleProcess1dMesher(uGrid_,
                                         klugeOUProcess_->getExtOUProcess(),
                                         maturity));

        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(xMesher, yMesher, uMesher));

        // 2. Calculator
        ext::shared_ptr<BasketPayoff> basketPayoff =
            ext::dynamic_pointer_cast<BasketPayoff>(arguments_.payoff);
        QL_REQUIRE(basketPayoff," basket payoff expected");

        const ext::shared_ptr<Payoff> zeroStrikeCall(
            new PlainVanillaPayoff(Option::Call, 0.0));

        const ext::shared_ptr<FdmInnerValueCalculator> gasPrice(
            new FdmExpExtOUInnerValueCalculator(zeroStrikeCall,
                                                mesher, gasShape_, 2));

        const ext::shared_ptr<FdmInnerValueCalculator> powerPrice(
            new FdmExtOUJumpModelInnerValue(zeroStrikeCall,mesher,powerShape_));

        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
            new FdmSpreadPayoffInnerValue(basketPayoff, powerPrice, gasPrice));

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                                DividendSchedule(), arguments_.exercise,
                                mesher, calculator,
                                rTS_->referenceDate(), rTS_->dayCounter());

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 5. set-up solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity, tGrid_, 0 };

        const ext::shared_ptr<FdmKlugeExtOUSolver<3> > solver(
            new FdmKlugeExtOUSolver<3>(
                Handle<KlugeExtOUProcess>(klugeOUProcess_),
                rTS_, solverDesc, schemeDesc_));

        std::vector<Real> x(3);
        x[0] = klugeOUProcess_->initialValues()[0];
        x[1] = klugeOUProcess_->initialValues()[1];
        x[2] = klugeOUProcess_->initialValues()[2];

        results_.value = solver->valueAt(x);
    }
}
]]></document_content>
  </document>
  <document index="294">
    <source>finitedifferences/fdklugeextouspreadengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdklugeextouspreadengine.hpp
    \brief FD Kluge/extended Ornstein-Uhlenbeck engine
           for a simple power-gas spread option
*/

#ifndef quantlib_fd_kluge_extou_spread_engine_hpp
#define quantlib_fd_kluge_extou_spread_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmexpextouinnervaluecalculator.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class ExtOUWithJumpsProcess;
    class ExtendedOrnsteinUhlenbeckProcess;

    class FdKlugeExtOUSpreadEngine
        : public GenericEngine<VanillaOption::arguments,
                               VanillaOption::results> {
      public:
          typedef FdmExtOUJumpModelInnerValue::Shape GasShape;
          typedef FdmExtOUJumpModelInnerValue::Shape PowerShape;

          FdKlugeExtOUSpreadEngine(
              ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess,
              ext::shared_ptr<YieldTermStructure> rTS,
              Size tGrid = 25,
              Size xGrid = 50,
              Size yGrid = 10,
              Size uGrid = 25,
              ext::shared_ptr<GasShape> gasShape = ext::shared_ptr<GasShape>(),
              ext::shared_ptr<PowerShape> powerShape = ext::shared_ptr<PowerShape>(),
              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

          void calculate() const override;

        private:
          const ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess_;
          const ext::shared_ptr<YieldTermStructure> rTS_;
          const Size tGrid_, xGrid_, yGrid_, uGrid_;
          const ext::shared_ptr<GasShape> gasShape_;
          const ext::shared_ptr<PowerShape> powerShape_;
          const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="295">
    <source>finitedifferences/fdmblackscholesfwdop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Klaus Spanderen
 Copyright (C) 2014 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/experimental/finitedifferences/fdmblackscholesfwdop.hpp>

namespace QuantLib {

    FdmBlackScholesFwdOp::FdmBlackScholesFwdOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<GeneralizedBlackScholesProcess> & bsProcess,
        Real strike,
        bool localVol,
        Real illegalLocalVolOverwrite,
        Size direction)
    : mesher_(mesher),
      rTS_   (bsProcess->riskFreeRate().currentLink()),
      qTS_   (bsProcess->dividendYield().currentLink()),
      volTS_ (bsProcess->blackVolatility().currentLink()),
      localVol_((localVol) ? bsProcess->localVolatility().currentLink()
                           : ext::shared_ptr<LocalVolTermStructure>()),
      x_ ((localVol) ? Array(Exp(mesher->locations(direction))) : Array()),
      dxMap_ (FirstDerivativeOp(direction, mesher)),
      dxxMap_(SecondDerivativeOp(direction, mesher)),
      mapT_  (direction, mesher),
      strike_(strike),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite),
      direction_(direction) {
    }

    void FdmBlackScholesFwdOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();

        if (localVol_ != nullptr) {
            const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
            const FdmLinearOpIterator endIter = layout->end();

            Array v(layout->size());
            for (FdmLinearOpIterator iter = layout->begin();
                iter != endIter; ++iter) {
                const Size i = iter.index();

                if (illegalLocalVolOverwrite_ < 0.0) {
                    v[i] = square<Real>()(
                        localVol_->localVol(0.5*(t1+t2), x_[i], true));
                }
                else {
                    try {
                        v[i] = square<Real>()(
                            localVol_->localVol(0.5*(t1+t2), x_[i], true));
                    } catch (Error&) {
                        v[i] = square<Real>()(illegalLocalVolOverwrite_);
                    }
                }
            }
            mapT_.axpyb(Array(1, 1.0), dxMap_.multR(- r + q + 0.5*v),
                        dxxMap_.multR(0.5*v), Array(1, 0.0));
        } else {
            const Real v
                = volTS_->blackForwardVariance(t1, t2, strike_)/(t2-t1);
            mapT_.axpyb(Array(1, - r + q + 0.5*v), dxMap_,
                        dxxMap_.mult(0.5*Array(mesher_->layout()->size(), v)),
                        Array(1, 0.0));
        }
    }

    Size FdmBlackScholesFwdOp::size() const { return 1U; }

    Disposable<Array> FdmBlackScholesFwdOp::apply(const Array& u) const {
        return mapT_.apply(u);
    }

    Disposable<Array> FdmBlackScholesFwdOp::apply_direction(
        Size direction, const Array& r) const {
        if (direction == direction_)
            return mapT_.apply(r);
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array> FdmBlackScholesFwdOp::apply_mixed(const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array> FdmBlackScholesFwdOp::solve_splitting(
        Size direction, const Array& r, Real dt) const {
        if (direction == direction_)
            return mapT_.solve_splitting(r, dt, 1.0);
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array> FdmBlackScholesFwdOp::preconditioner(
        const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmBlackScholesFwdOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapT_.toMatrix());
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="296">
    <source>finitedifferences/fdmblackscholesfwdop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Klaus Spanderen
 Copyright (C) 2014 Johannes Gttker-Schnetmann


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholesfwdop.hpp
    \brief Black Scholes linear operator for the Fokker-Planck forward equation
*/

#ifndef quantlib_fdm_black_scholes_fwd_op_hpp
#define quantlib_fdm_black_scholes_fwd_op_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

class FdmBlackScholesFwdOp : public FdmLinearOpComposite {
      public:
        FdmBlackScholesFwdOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
            Real strike, 
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            Size direction = 0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;
      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> rTS_, qTS_;
        const ext::shared_ptr<BlackVolTermStructure> volTS_;
        const ext::shared_ptr<LocalVolTermStructure> localVol_;
        const Array x_;
        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;
        const Real strike_;
        const Real illegalLocalVolOverwrite_;
        const Size direction_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="297">
    <source>finitedifferences/fdmdupire1dop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/finitedifferences/fdmdupire1dop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <boost/numeric/ublas/matrix.hpp>

namespace QuantLib {

FdmDupire1dOp::FdmDupire1dOp(const ext::shared_ptr<FdmMesher> &mesher,
                             const Array &localVolatility)
    : mesher_(mesher), localVolatility_(localVolatility),
      mapT_(SecondDerivativeOp(0, mesher)
                .mult(0.5 * localVolatility * localVolatility)) {}

void FdmDupire1dOp::setTime(Time t1, Time t2) {}

Size FdmDupire1dOp::size() const { return 1; }

Disposable<Array> FdmDupire1dOp::apply(const Array &u) const {
    return mapT_.apply(u);
}

Disposable<Array> FdmDupire1dOp::apply_direction(Size direction,
                                                 const Array &r) const {
    if (direction == 0)
        return mapT_.apply(r);
    QL_FAIL("direction too large");
}

Disposable<Array> FdmDupire1dOp::apply_mixed(const Array &r) const {
    Array s(r);
    return s;
}

Disposable<Array> FdmDupire1dOp::solve_splitting(Size direction, const Array &r,
                                                 Real a) const {

    if (direction == 0) {
        return mapT_.solve_splitting(r, a, 1.0);
    }
    QL_FAIL("direction too large");
}

Disposable<Array> FdmDupire1dOp::preconditioner(const Array &r, Real dt) const {

    return solve_splitting(0, r, dt);
}

Disposable<std::vector<SparseMatrix> > FdmDupire1dOp::toMatrixDecomp() const {
    std::vector<SparseMatrix> retVal(1);
    retVal[0] = mapT_.toMatrix();
    return retVal;
}

}
]]></document_content>
  </document>
  <document index="298">
    <source>finitedifferences/fdmdupire1dop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmdupire1dop.hpp
    \brief Dupire local volatility pricing operator
        Note that time is reversed in order to make backward solvers work
*/

#ifndef quantlib_fdm_dupire1d_op_hpp
#define quantlib_fdm_dupire1d_op_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

class FdmDupire1dOp : public FdmLinearOpComposite {
  public:
    FdmDupire1dOp(const ext::shared_ptr<FdmMesher> &mesher,
                  const Array &localVolatility);

    Size size() const override;
    void setTime(Time t1, Time t2) override;

    Disposable<Array> apply(const Array& r) const override;
    Disposable<Array> apply_mixed(const Array& r) const override;

    Disposable<Array> apply_direction(Size direction, const Array& r) const override;
    Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
    Disposable<Array> preconditioner(const Array& r, Real s) const override;

    Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

  private:
    const ext::shared_ptr<FdmMesher> mesher_;
    const Array localVolatility_;
    TripleBandLinearOp mapT_;
};
}

#endif
]]></document_content>
  </document>
  <document index="299">
    <source>finitedifferences/fdmexpextouinnervaluecalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmexpextouinnervaluecalculator.hpp
    \brief inner value calculator for an exponential extended
           Ornstein Uhlenbeck grid
*/

#ifndef quantlib_fdm_exp_ext_ou_inner_value_calculator_hpp
#define quantlib_fdm_exp_ext_ou_inner_value_calculator_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    class FdmExpExtOUInnerValueCalculator : public FdmInnerValueCalculator {
      public:
        typedef std::vector<std::pair<Time, Real> > Shape;

        FdmExpExtOUInnerValueCalculator(ext::shared_ptr<Payoff> payoff,
                                        ext::shared_ptr<FdmMesher> mesher,
                                        ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
                                        Size direction = 0)
        : direction_(direction), payoff_(std::move(payoff)), mesher_(std::move(mesher)),
          shape_(std::move(shape)) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
            const Real u = mesher_->location(iter, direction_);

            Real f = 0;
            if (shape_ != nullptr) {
                f = std::lower_bound(shape_->begin(), shape_->end(),
                   std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;
            }

            return (*payoff_)(std::exp(f + u));
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const Size direction_;
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<Shape> shape_;
    };

}
#endif
]]></document_content>
  </document>
  <document index="300">
    <source>finitedifferences/fdmextendedornsteinuhlenbeckop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextendedornsteinuhlenbeckop.cpp
*/

#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdmExtendedOrnsteinUhlenbeckOp::FdmExtendedOrnsteinUhlenbeckOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process,
        ext::shared_ptr<YieldTermStructure> rTS,
        FdmBoundaryConditionSet bcSet,
        Size direction)
    : mesher_(mesher), process_(std::move(process)), rTS_(std::move(rTS)), bcSet_(std::move(bcSet)),
      direction_(direction), x_(mesher->locations(direction)), dxMap_(direction, mesher),
      dxxMap_(SecondDerivativeOp(direction, mesher)
                  .mult(0.5 * square<Real>()(process_->volatility()) *
                        Array(mesher->layout()->size(), 1.))),
      mapX_(direction, mesher) {}

    Size FdmExtendedOrnsteinUhlenbeckOp::size() const {
        return mesher_->layout()->dim().size();;
    }

    void FdmExtendedOrnsteinUhlenbeckOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();

        const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
        const FdmLinearOpIterator endIter = layout->end();

        Array drift(layout->size());
        for (FdmLinearOpIterator iter = layout->begin();
             iter!=endIter; ++iter) {
            const Size i = iter.index();
            drift[i] = process_->drift(0.5*(t1+t2), x_[i]);
        }
        mapX_.axpyb(drift, dxMap_, dxxMap_, Array(1, -r));
    }

    Disposable<Array> FdmExtendedOrnsteinUhlenbeckOp::apply(
                                                    const Array& r) const {
        return mapX_.apply(r);
    }

    Disposable<Array> FdmExtendedOrnsteinUhlenbeckOp::apply_mixed(
                                                    const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array> FdmExtendedOrnsteinUhlenbeckOp::apply_direction(
                                    Size direction, const Array& r) const {
        if (direction == direction_) {
            return mapX_.apply(r);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array> FdmExtendedOrnsteinUhlenbeckOp::solve_splitting(
                            Size direction, const Array& r, Real a) const {
        if (direction == direction_) {
            return mapX_.solve_splitting(r, a, 1.0);
        }
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array> FdmExtendedOrnsteinUhlenbeckOp::preconditioner(
                                            const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmExtendedOrnsteinUhlenbeckOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapX_.toMatrix());
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="301">
    <source>finitedifferences/fdmextendedornsteinuhlenbeckop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextendedornsteinuhlenbeckop.hpp
    \brief Ornstein Uhlenbeck process plus jumps (Kluge Model)
*/

#ifndef quantlib_fdm_extended_ornsteinuhlenback_op_hpp
#define quantlib_fdm_extended_ornsteinuhlenback_op_hpp

#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>


namespace QuantLib {

    class FdmMesher;
    class YieldTermStructure;
    class ExtendedOrnsteinUhlenbeckProcess;

    class FdmExtendedOrnsteinUhlenbeckOp : public FdmLinearOpComposite {
      public:
        FdmExtendedOrnsteinUhlenbeckOp(const ext::shared_ptr<FdmMesher>& mesher,
                                       ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> p,
                                       ext::shared_ptr<YieldTermStructure> rTS,
                                       FdmBoundaryConditionSet bcSet,
                                       Size direction = 0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmBoundaryConditionSet bcSet_;
        const Size direction_;

        const Array x_;
        const FirstDerivativeOp dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapX_;

    };

}
#endif
]]></document_content>
  </document>
  <document index="302">
    <source>finitedifferences/fdmextoujumpmodelinnervalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpmodelinnervalue.hpp
    \brief inner value calculator for the Ornstein Uhlenbeck
           plus exponential jumps model (Kluge Model)
*/

#ifndef quantlib_fdm_ext_ou_jump_model_inner_value_hpp
#define quantlib_fdm_ext_ou_jump_model_inner_value_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    class FdmExtOUJumpModelInnerValue : public FdmInnerValueCalculator {
      public:
        typedef std::vector<std::pair<Time, Real> > Shape;

        FdmExtOUJumpModelInnerValue(ext::shared_ptr<Payoff> payoff,
                                    ext::shared_ptr<FdmMesher> mesher,
                                    ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>())
        : payoff_(std::move(payoff)), mesher_(std::move(mesher)), shape_(std::move(shape)) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
            const Real x = mesher_->location(iter, 0);
            const Real y = mesher_->location(iter, 1);

            Real f = 0;
            if (shape_ != nullptr) {
                f = std::lower_bound(shape_->begin(), shape_->end(),
                   std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;
            }
            return (*payoff_)(std::exp(f + x + y));
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<Shape> shape_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="303">
    <source>finitedifferences/fdmextoujumpop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmexpoujumpop.cpp
    \brief Ornstein Uhlenbeck process plus jumps (Kluge Model)
*/

#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>

#if defined(QL_PATCH_MSVC)
#pragma warning(push)
#pragma warning(disable:4180)
#endif

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif

#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/operation.hpp>

#if defined(QL_PATCH_MSVC)
#pragma warning(pop)
#endif

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

namespace QuantLib {

    FdmExtOUJumpOp::FdmExtOUJumpOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<ExtOUWithJumpsProcess>& process,
        const ext::shared_ptr<YieldTermStructure>& rTS,
        const FdmBoundaryConditionSet& bcSet,
        Size integroIntegrationOrder)
    : mesher_ (mesher),
      process_(process),
      rTS_    (rTS),
      bcSet_  (bcSet),
      gaussLaguerreIntegration_(integroIntegrationOrder),
      x_      (mesher->locations(0)),
      ouOp_   (new FdmExtendedOrnsteinUhlenbeckOp(
                   mesher,
                   process->getExtendedOrnsteinUhlenbeckProcess(), rTS, bcSet)),
      dyMap_  (FirstDerivativeOp(1, mesher)
                .mult(-process->beta()*mesher->locations(1)))
    {
        const Real eta     = process_->eta();
        const Real lambda  = process_->jumpIntensity();

        const Array yInt   = gaussLaguerreIntegration_.x();
        const Array weights= gaussLaguerreIntegration_.weights();

        integroPart_ = SparseMatrix(mesher_->layout()->size(),
                                    mesher_->layout()->size());

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        const FdmLinearOpIterator endIter = layout->end();

        Array yLoc(mesher_->layout()->dim()[1]);
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            yLoc[iter.coordinates()[1]] = mesher_->location(iter, 1);
        }

        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {

            const Size diag = iter.index();
            integroPart_(diag, diag) -= lambda;

            const Real y = mesher_->location(iter, 1);
            const Integer yIndex = iter.coordinates()[1];

            for (Size i=0; i < yInt.size(); ++i) {
                const Real weight = std::exp(-yInt[i])*weights[i];

                const Real ys = y + yInt[i]/eta;
                const Integer l = (ys > yLoc.back()) ? yLoc.size()-2
                    : std::upper_bound(yLoc.begin(),
                                       yLoc.end()-1, ys) - yLoc.begin()-1;

                const Real s = (ys-yLoc[l])/(yLoc[l+1]-yLoc[l]);
                integroPart_(diag, layout->neighbourhood(iter, 1, l-yIndex))
                    += weight*lambda*(1-s);
                integroPart_(diag, layout->neighbourhood(iter, 1, l+1-yIndex))
                    += weight*lambda*s;
            }
        }
    }

    Size FdmExtOUJumpOp::size() const {
        return mesher_->layout()->dim().size();;
    }

    void FdmExtOUJumpOp::setTime(Time t1, Time t2) {
        ouOp_->setTime(t1, t2);
    }

    Disposable<Array> FdmExtOUJumpOp::apply(const Array& r) const {
        return ouOp_->apply(r) + dyMap_.apply(r) + integro(r);
    }

    Disposable<Array> FdmExtOUJumpOp::apply_mixed(const Array& r) const {
        return  integro(r);
    }

    Disposable<Array> FdmExtOUJumpOp::apply_direction(Size direction,
                                                      const Array& r) const {
        if (direction == 0)
            return ouOp_->apply_direction(direction, r);
        else if (direction == 1)
            return dyMap_.apply(r);
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array>
        FdmExtOUJumpOp::solve_splitting(Size direction,
                                        const Array& r, Real a) const {
        if (direction == 0) {
            return ouOp_->solve_splitting(direction, r, a);
        }
        else if (direction == 1) {
            return dyMap_.solve_splitting(r, a, 1.0);
        }
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array>
    FdmExtOUJumpOp::preconditioner(const Array& r, Real dt) const {
        return ouOp_->solve_splitting(0, r, dt);
    }

    Disposable<Array> FdmExtOUJumpOp::integro(const Array& r) const {
        return prod(integroPart_, r);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmExtOUJumpOp::toMatrixDecomp() const {
        QL_REQUIRE(bcSet_.empty(), "boundary conditions are not supported");

        std::vector<SparseMatrix> retVal(1, ouOp_->toMatrixDecomp().front());
        retVal.push_back(dyMap_.toMatrix());
        retVal.push_back(integroPart_);

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="304">
    <source>finitedifferences/fdmextoujumpop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpop.hpp
    \brief Ornstein Uhlenbeck process plus jumps (Kluge Model)
*/

#ifndef quantlib_fdm_ext_ou_jump_op_hpp
#define quantlib_fdm_ext_ou_jump_op_hpp

#include <ql/math/matrixutilities/sparsematrix.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {
    
    class FdmMesher;
    class YieldTermStructure;
    class LinearInterpolation;
    class ExtOUWithJumpsProcess;
    class FdmExtendedOrnsteinUhlenbeckOp;
    
    /*! References:
        Kluge, Timo L., 2008. Pricing Swing Options and other 
        Electricity Derivatives, http://eprints.maths.ox.ac.uk/246/1/kluge.pdf
    */

    class FdmExtOUJumpOp : public FdmLinearOpComposite {
      public:
        FdmExtOUJumpOp(const ext::shared_ptr<FdmMesher>& mesher,
                       const ext::shared_ptr<ExtOUWithJumpsProcess>& process,
                       const ext::shared_ptr<YieldTermStructure>& rTS,
                       const FdmBoundaryConditionSet& bcSet,
                       Size integroIntegrationOrder);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;
      private:
        Disposable<Array> integro(const Array& r) const;

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmBoundaryConditionSet bcSet_;
        GaussLaguerreIntegration gaussLaguerreIntegration_;

        const Array x_;
        const ext::shared_ptr<FdmExtendedOrnsteinUhlenbeckOp> ouOp_;

        const TripleBandLinearOp dyMap_;

        SparseMatrix integroPart_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="305">
    <source>finitedifferences/fdmextoujumpsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpsolver.cpp
*/

#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpsolver.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <utility>

namespace QuantLib {

    FdmExtOUJumpSolver::FdmExtOUJumpSolver(Handle<ExtOUWithJumpsProcess> process,
                                           ext::shared_ptr<YieldTermStructure> rTS,
                                           FdmSolverDesc solverDesc,
                                           const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), rTS_(std::move(rTS)), solverDesc_(std::move(solverDesc)),
      schemeDesc_(schemeDesc) {

        registerWith(process_);
    }

    void FdmExtOUJumpSolver::performCalculations() const {
        ext::shared_ptr<FdmLinearOpComposite>op(
            new FdmExtOUJumpOp(solverDesc_.mesher, process_.currentLink(),
                               rTS_, solverDesc_.bcSet, 32));
        
        solver_ = ext::make_shared<Fdm2DimSolver>(
                              solverDesc_, schemeDesc_, op);
    }
    
    Real FdmExtOUJumpSolver::valueAt(Real x, Real y) const {
        calculate();
        return solver_->interpolateAt(x, y);
    }
}

]]></document_content>
  </document>
  <document index="306">
    <source>finitedifferences/fdmextoujumpsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpsolver.hpp
*/

#ifndef quantlib_fdm_ext_ou_jump_solver_hpp
#define quantlib_fdm_ext_ou_jump_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class Fdm2DimSolver;
    class ExtOUWithJumpsProcess;
    class YieldTermStructure;

    class FdmExtOUJumpSolver : public LazyObject {
      public:
        FdmExtOUJumpSolver(Handle<ExtOUWithJumpsProcess> process,
                           ext::shared_ptr<YieldTermStructure> rTS,
                           FdmSolverDesc solverDesc,
                           const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        Real valueAt(Real x, Real y) const;
        
      protected:
        void performCalculations() const override;

      private:
        const Handle<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="307">
    <source>finitedifferences/fdmhestonfwdop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Klaus Spanderen
 Copyright (C) 2014 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonfwdop.cpp
*/

#include <ql/experimental/finitedifferences/fdmhestonfwdop.hpp>
#include <ql/experimental/finitedifferences/modtriplebandlinearop.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <boost/unordered/unordered_map.hpp>
#include <cmath>
#include <utility>

using std::exp;

namespace QuantLib {

    FdmHestonFwdOp::FdmHestonFwdOp(const ext::shared_ptr<FdmMesher>& mesher,
                                   const ext::shared_ptr<HestonProcess>& process,
                                   FdmSquareRootFwdOp::TransformationType type,
                                   ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                   const Real mixingFactor)
    : type_(type), kappa_(process->kappa()), theta_(process->theta()), sigma_(process->sigma()),
      rho_(process->rho()), v0_(process->v0()), mixedSigma_(mixingFactor * sigma_),
      rTS_(process->riskFreeRate().currentLink()), qTS_(process->dividendYield().currentLink()),
      varianceValues_(0.5 * mesher->locations(1)),
      dxMap_(ext::make_shared<FirstDerivativeOp>(0, mesher)),
      dxxMap_(ext::make_shared<ModTripleBandLinearOp>(TripleBandLinearOp(
          type == FdmSquareRootFwdOp::Log ?
              SecondDerivativeOp(0, mesher).mult(0.5 * Exp(mesher->locations(1))) :
              SecondDerivativeOp(0, mesher).mult(0.5 * mesher->locations(1))))),
      boundary_(ext::make_shared<ModTripleBandLinearOp>(TripleBandLinearOp(
          SecondDerivativeOp(0, mesher).mult(Array(mesher->locations(0).size(), 0.0))))),
      mapX_(ext::make_shared<TripleBandLinearOp>(0, mesher)),
      mapY_(ext::make_shared<FdmSquareRootFwdOp>(mesher, kappa_, theta_, mixedSigma_, 1, type)),
      correlation_(ext::make_shared<NinePointLinearOp>(
          type == FdmSquareRootFwdOp::Log ?
              SecondOrderMixedDerivativeOp(0, 1, mesher)
                  .mult(Array(mesher->layout()->size(), rho_ * mixedSigma_)) :
              SecondOrderMixedDerivativeOp(0, 1, mesher)
                  .mult(rho_ * mixedSigma_ * mesher->locations(1)))),
      leverageFct_(std::move(leverageFct)), mesher_(mesher) {
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        // zero flux boundary condition
        const Size n = layout->dim()[1];
        const Real lowerBoundaryFactor = mapY_->lowerBoundaryFactor(type);
        const Real upperBoundaryFactor = mapY_->upperBoundaryFactor(type);

        const Real logFacLow = type == FdmSquareRootFwdOp::Log ? exp(mapY_->v(0)) : 1.0;
        const Real logFacUpp = type == FdmSquareRootFwdOp::Log ? exp(mapY_->v(n+1)) : 1.0;

        const Real alpha = -2*rho_/mixedSigma_*lowerBoundaryFactor*logFacLow;
        const Real beta  = -2*rho_/mixedSigma_*upperBoundaryFactor*logFacUpp;

        ModTripleBandLinearOp fDx(FirstDerivativeOp(0, mesher));

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter; ++iter) {
            if (iter.coordinates()[1] == 0) {
                const Size idx = iter.index();
                if (!leverageFct_) {
                    dxxMap_->upper(idx) += alpha*fDx.upper(idx);
                    dxxMap_->diag(idx) += alpha*fDx.diag(idx);
                    dxxMap_->lower(idx) += alpha*fDx.lower(idx);
                }
                boundary_->upper(idx)= alpha*fDx.upper(idx);
                boundary_->diag(idx) = alpha*fDx.diag(idx);
                boundary_->lower(idx) = alpha*fDx.lower(idx);
            }
            else if (iter.coordinates()[1] == n-1) {
                const Size idx = iter.index();

                if (!leverageFct_) {
                    dxxMap_->upper(idx)+= beta*fDx.upper(idx);
                    dxxMap_->diag(idx) += beta*fDx.diag(idx);
                    dxxMap_->lower(idx) += beta*fDx.lower(idx);
                }
                boundary_->upper(idx)= beta*fDx.upper(idx);
                boundary_->diag(idx) = beta*fDx.diag(idx);
                boundary_->lower(idx) = beta*fDx.lower(idx);
            }
        }
    }

    Size FdmHestonFwdOp::size() const {
        return 2;
    }

    void FdmHestonFwdOp::setTime(Time t1, Time t2){
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();
        if (leverageFct_ != nullptr) {
            L_ = getLeverageFctSlice(t1, t2);
            Array Lsquare = L_*L_;
            if (type_ == FdmSquareRootFwdOp::Plain) {
                mapX_->axpyb( Array(1, -r + q), *dxMap_,
                    dxxMap_->multR(Lsquare).add(boundary_->multR(L_))
                    .add(dxMap_->multR(rho_*mixedSigma_*L_))
                    .add(dxMap_->mult(varianceValues_).multR(Lsquare)),
                              Array());
            } else if (type_ == FdmSquareRootFwdOp::Power) {
                mapX_->axpyb( Array(1, -r + q), *dxMap_,
                    dxxMap_->multR(Lsquare).add(boundary_->multR(L_))
                    .add(dxMap_->multR(rho_*2.0*kappa_*theta_/(mixedSigma_)*L_))
                    .add(dxMap_->mult(varianceValues_).multR(Lsquare)), Array());
            } else if (type_ == FdmSquareRootFwdOp::Log) {
                mapX_->axpyb( Array(1, -r + q), *dxMap_,
                    dxxMap_->multR(Lsquare).add(boundary_->multR(L_))
                    .add(dxMap_->mult(0.5*Exp(2.0*varianceValues_)).multR(Lsquare)),
                              Array());
            }
        } else {
            if (type_ == FdmSquareRootFwdOp::Plain) {
                mapX_->axpyb( - r + q + rho_*mixedSigma_ + varianceValues_, *dxMap_,
                        *dxxMap_, Array());
            } else if (type_ == FdmSquareRootFwdOp::Power) {
                mapX_->axpyb( - r + q + rho_*2.0*kappa_*theta_/(mixedSigma_) + varianceValues_,
                              *dxMap_, *dxxMap_, Array());
            } else if (type_ == FdmSquareRootFwdOp::Log) {
                mapX_->axpyb( - r + q + 0.5*Exp(2.0*varianceValues_), *dxMap_,
                        *dxxMap_, Array());
            }
        }
    }

    Disposable<Array> FdmHestonFwdOp::apply(const Array& u) const {
        if (leverageFct_ != nullptr) {
            return mapX_->apply(u)
                    + mapY_->apply(u)
                    + correlation_->apply(L_*u);
        } else {
            return mapX_->apply(u)
                    + mapY_->apply(u)
                    + correlation_->apply(u);
        }
    }

    Disposable<Array> FdmHestonFwdOp::apply_mixed(const Array& u) const{
        if (leverageFct_ != nullptr) {
            return correlation_->apply(L_*u);
        } else {
            return correlation_->apply(u);
        }
    }

    Disposable<Array> FdmHestonFwdOp::apply_direction(
        Size direction, const Array& u) const {

        if (direction == 0)
            return mapX_->apply(u) ;
        else if (direction == 1)
            return mapY_->apply(u) ;
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmHestonFwdOp::solve_splitting(
        Size direction, const Array& u, Real s) const{
        if (direction == 0) {
            return mapX_->solve_splitting(u, s, 1.0);
        }
        else if (direction == 1) {
            return mapY_->solve_splitting(1, u, s);
        }
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmHestonFwdOp::preconditioner(
        const Array& u, Real dt) const{
        return solve_splitting(1, u, dt);
    }

    Disposable<Array> FdmHestonFwdOp::getLeverageFctSlice(Time t1, Time t2)
    const {
        const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
        Array v(layout->size(), 1.0);

        if (!leverageFct_)
            return v;

        const Real t = 0.5*(t1+t2);
        const Time time = std::min(leverageFct_->maxTime(), t);
                                   //std::max(leverageFct_->minTime(), t));

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin();
             iter!=endIter; ++iter) {
            const Size nx = iter.coordinates()[0];

            if (iter.coordinates()[1] == 0) {
                const Real x = std::exp(mesher_->location(iter, 0));
                const Real spot = std::min(leverageFct_->maxStrike(),
                                           std::max(leverageFct_->minStrike(), x));
                v[nx] = std::max(0.01, leverageFct_->localVol(time, spot, true));
            }
            else {
                v[iter.index()] = v[nx];
            }
        }
        return v;
    }

    Disposable<std::vector<SparseMatrix> > FdmHestonFwdOp::toMatrixDecomp()
        const {

        std::vector<SparseMatrix> retVal(3);

        retVal[0] = mapX_->toMatrix();
        retVal[1] = mapY_->toMatrix();
        retVal[2] = correlation_->toMatrix();

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="308">
    <source>finitedifferences/fdmhestonfwdop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013, 2015 Klaus Spanderen
 Copyright (C) 2014, 2015 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonfwdop.hpp
    \brief Heston Fokker-Planck forward operator
*/

#ifndef quantlib_fdm_heston_fwd_op_hpp
#define quantlib_fdm_heston_fwd_op_hpp

#include <ql/types.hpp>
#include <ql/experimental/finitedifferences/fdmsquarerootfwdop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class FdmMesher;
    class HestonProcess;
    class FirstDerivativeOp;
    class TripleBandLinearOp;
    class NinePointLinearOp;

    class FdmHestonFwdOp : public FdmLinearOpComposite {
      public:
        FdmHestonFwdOp(const ext::shared_ptr<FdmMesher>& mesher,
                       const ext::shared_ptr<HestonProcess>& process,
                       FdmSquareRootFwdOp::TransformationType type = FdmSquareRootFwdOp::Plain,
                       ext::shared_ptr<LocalVolTermStructure> leverageFct =
                           ext::shared_ptr<LocalVolTermStructure>(),
                       Real mixingFactor = 1.0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;
      private:
        Disposable<Array> getLeverageFctSlice(Time t1, Time t2) const;
        const FdmSquareRootFwdOp::TransformationType type_;
        const Real kappa_, theta_, sigma_, rho_, v0_, mixedSigma_;

        const ext::shared_ptr<YieldTermStructure> rTS_;
        const ext::shared_ptr<YieldTermStructure> qTS_;

        const Array varianceValues_;
        const ext::shared_ptr<FirstDerivativeOp> dxMap_;
        const ext::shared_ptr<ModTripleBandLinearOp> dxxMap_;
        const ext::shared_ptr<ModTripleBandLinearOp> boundary_;
        Array L_;

        const ext::shared_ptr<TripleBandLinearOp> mapX_;
        const ext::shared_ptr<FdmSquareRootFwdOp> mapY_;

        const ext::shared_ptr<NinePointLinearOp> correlation_;

        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Array x_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="309">
    <source>finitedifferences/fdmhestongreensfct.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestongreenfct.cpp
    \brief Heston Fokker-Planck Green's function
*/

#include <ql/experimental/finitedifferences/fdmhestongreensfct.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    FdmHestonGreensFct::FdmHestonGreensFct(ext::shared_ptr<FdmMesher> mesher,
                                           ext::shared_ptr<HestonProcess> process,
                                           FdmSquareRootFwdOp::TransformationType trafoType_,
                                           const Real l0)
    : l0_(l0), mesher_(std::move(mesher)), process_(std::move(process)), trafoType_(trafoType_) {}

    Disposable<Array> FdmHestonGreensFct::get(Time t, Algorithm algorithm)
    const {
        const Rate r = process_->riskFreeRate()->forwardRate(0, t, Continuous);
        const Rate q = process_->dividendYield()->forwardRate(0,t, Continuous);

        const Real s0    = process_->s0()->value();
        const Real v0    = process_->v0();
        const Real x0    = std::log(s0) + (r-q-0.5*v0*l0_*l0_)*t;

          const Real rho   = process_->rho();
        const Real theta = process_->theta();
        const Real kappa = process_->kappa();
        const Real sigma = process_->sigma();

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        const FdmLinearOpIterator endIter = layout->end();

        Array p(mesher_->layout()->size());
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            const Real x = mesher_->location(iter, 0);
            const Real v = (trafoType_ != FdmSquareRootFwdOp::Log)
                ? mesher_->location(iter, 1)
                : std::exp(mesher_->location(iter, 1));

            Real retVal;
            switch (algorithm) {
              case ZeroCorrelation:
              {
                const Real sd_x = l0_*std::sqrt(v0*t);
                  const Real p_x = M_1_SQRTPI*M_SQRT1_2/sd_x
                          * std::exp(-0.5*square<Real>()((x - x0)/sd_x));
                  const Real p_v = SquareRootProcessRNDCalculator(
                      v0, kappa, theta, sigma).pdf(v, t);

                  retVal = p_v*p_x;
              }
              break;
              case SemiAnalytical:
                retVal = process_->pdf(x, v, t, 1e-4);
              break;
              case Gaussian:
              {
                const Real sd_x = l0_*std::sqrt(v0*t);
                const Real sd_v = sigma*std::sqrt(v0*t);
                const Real z0 = v0 + kappa*(theta - v0)*t;
                retVal = 1.0/(M_TWOPI*sd_x*sd_v*std::sqrt(1-rho*rho))
                    *std::exp(-(  square<Real>()((x-x0)/sd_x)
                                + square<Real>()((v-z0)/sd_v)
                                - 2*rho*(x-x0)*(v-z0)/(sd_x*sd_v))
                              /(2*(1-rho*rho)) );
              }
              break;
              default:
                QL_FAIL("unknown algorithm");
            }

            switch (trafoType_) {
              case FdmSquareRootFwdOp::Log:
                retVal*=v;
                break;
              case FdmSquareRootFwdOp::Plain:
                break;
              case FdmSquareRootFwdOp::Power:
                retVal*=std::pow(v, 1.0 - 2*kappa*theta/(sigma*sigma));
                break;
              default:
                QL_FAIL("unknown transformation type");
            }

            p[iter.index()] = retVal;
        }

        return p;
    }
}
]]></document_content>
  </document>
  <document index="310">
    <source>finitedifferences/fdmhestongreensfct.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestongreensfct.hpp
    \brief Heston Fokker-Planck Green's function
*/

#ifndef quantlib_fdm_heston_greens_fct_hpp
#define quantlib_fdm_heston_greens_fct_hpp

#include <ql/experimental/finitedifferences/fdmsquarerootfwdop.hpp>

namespace QuantLib {

    class HestonProcess;
    class FdmHestonGreensFct {
      public:
        enum Algorithm { ZeroCorrelation, Gaussian, SemiAnalytical };

        FdmHestonGreensFct(ext::shared_ptr<FdmMesher> mesher,
                           ext::shared_ptr<HestonProcess> process,
                           FdmSquareRootFwdOp::TransformationType trafoType_,
                           Real l0 = 1.0);

        Disposable<Array> get(Time t, Algorithm algorithm) const;

      private:
        const Real l0_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<HestonProcess> process_;
        const FdmSquareRootFwdOp::TransformationType trafoType_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="311">
    <source>finitedifferences/fdmklugeextouop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmexpoujumpop.cpp
    \brief Kluge process (power) plus Ornstein Uhlenbeck process (gas)
*/


#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextouop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>

namespace QuantLib {

    FdmKlugeExtOUOp::FdmKlugeExtOUOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<KlugeExtOUProcess>& klugeOUProcess,
        const ext::shared_ptr<YieldTermStructure>& rTS,
        const FdmBoundaryConditionSet& bcSet,
        Size integroIntegrationOrder)
    : mesher_ (mesher),
      kluge_  (klugeOUProcess->getKlugeProcess()),
      extOU_  (klugeOUProcess->getExtOUProcess()),
      rTS_    (rTS),
      bcSet_  (bcSet),
      klugeOp_(new FdmExtOUJumpOp(mesher, kluge_, rTS, bcSet,
                                  integroIntegrationOrder)),
      ouOp_   (new FdmExtendedOrnsteinUhlenbeckOp(
                  mesher, extOU_,
                  ext::shared_ptr<YieldTermStructure>(
                      new FlatForward(rTS->referenceDate(),
                              Handle<Quote>(ext::shared_ptr<Quote>(
                                      new SimpleQuote(0.0))),
                                      rTS->dayCounter())),
                  bcSet, 2)),
      corrMap_(SecondOrderMixedDerivativeOp(0, 2, mesher).mult(
          Array(mesher->layout()->size(),
                 klugeOUProcess->rho()*extOU_->volatility()
                *kluge_->getExtendedOrnsteinUhlenbeckProcess()
                       ->volatility())))
    { }

    Size FdmKlugeExtOUOp::size() const {
        return mesher_->layout()->dim().size();
    }

    void FdmKlugeExtOUOp::setTime(Time t1, Time t2) {
        ouOp_->setTime(t1, t2);
        klugeOp_->setTime(t1, t2);
    }

    Disposable<Array> FdmKlugeExtOUOp::apply(const Array& r) const {
        return ouOp_->apply(r) + klugeOp_->apply(r) + corrMap_.apply(r);
    }

    Disposable<Array> FdmKlugeExtOUOp::apply_mixed(const Array& r) const {
        return  corrMap_.apply(r) + klugeOp_->apply_mixed(r);
    }

    Disposable<Array> FdmKlugeExtOUOp::apply_direction(Size direction,
                                                       const Array& r) const {
        return klugeOp_->apply_direction(direction, r)
                + ouOp_->apply_direction(direction, r);
    }

    Disposable<Array>
        FdmKlugeExtOUOp::solve_splitting(Size direction,
                                        const Array& r, Real a) const {
        if (direction == 0 || direction == 1) {
            return klugeOp_->solve_splitting(direction, r, a);
        }
        else if (direction == 2) {
            return ouOp_->solve_splitting(direction, r, a);
        }
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array>
        FdmKlugeExtOUOp::preconditioner(const Array& r, Real dt) const {
        return klugeOp_->solve_splitting(0, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmKlugeExtOUOp::toMatrixDecomp() const {
        const std::vector<SparseMatrix> klugeDecomp
            = klugeOp_->toMatrixDecomp();

        std::vector<SparseMatrix> retVal(4);
        retVal[0] = klugeDecomp[0];
        retVal[1] = klugeDecomp[1];
        retVal[2] = ouOp_->toMatrixDecomp().front();
        retVal[3] = corrMap_.toMatrix() + klugeDecomp[2];

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="312">
    <source>finitedifferences/fdmklugeextouop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmklugeextouop.hpp
    \brief Kluge process (power) plus Ornstein Uhlenbeck process (gas)
*/

#ifndef quantlib_fdm_kluge_ext_ou_op_hpp
#define quantlib_fdm_kluge_ext_ou_op_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>


namespace QuantLib {

    class FdmMesher;
    class YieldTermStructure;
    class KlugeExtOUProcess;
    class ExtOUWithJumpsProcess;
    class FdmExtOUJumpOp;
    class FdmExtendedOrnsteinUhlenbeckOp;
    class ExtendedOrnsteinUhlenbeckProcess;

    /*! This class describes a correlated Kluge - extended Ornstein-Uhlenbeck
        process governed by
        \f[
        \begin{array}{rcl}
            P_t &=& \exp(p_t + X_t + Y_t) \\
            dX_t &=& -\alpha X_tdt + \sigma_x dW_t^x \\
            dY_t &=& -\beta Y_{t-}dt + J_tdN_t \\
            \omega(J) &=& \eta e^{-\eta J} \\
            G_t &=& \exp(g_t + U_t) \\
            dU_t &=& -\kappa U_tdt + \sigma_udW_t^u \\
            \rho &=& \mathrm{corr} (dW_t^x, dW_t^u)
         \end{array}
         \f]
    */

    /*! References:
        Kluge, Timo L., 2008. Pricing Swing Options and other
        Electricity Derivatives, http://eprints.maths.ox.ac.uk/246/1/kluge.pdf

        http://spanderen.de/2011/06/13/vpp-pricing-i-stochastic-processes-partial-integro-differential-equation/
    */

    class FdmKlugeExtOUOp : public FdmLinearOpComposite {
      public:
        FdmKlugeExtOUOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<KlugeExtOUProcess>& klugeOUProcess,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            const FdmBoundaryConditionSet& bcSet,
            Size integroIntegrationOrder);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<ExtOUWithJumpsProcess> kluge_;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> extOU_;

        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmBoundaryConditionSet bcSet_;

        const ext::shared_ptr<FdmExtOUJumpOp> klugeOp_;
        const ext::shared_ptr<FdmExtendedOrnsteinUhlenbeckOp> ouOp_;

        const NinePointLinearOp corrMap_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="313">
    <source>finitedifferences/fdmklugeextousolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmklugeextousolver.hpp
    \brief Kluge/extended Ornstein-Uhlenbeck FDM solver
*/

#ifndef quantlib_fdm_kluge_ou_solver_hpp
#define quantlib_fdm_kluge_ou_solver_hpp

#include <ql/experimental/finitedifferences/fdmklugeextouop.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmndimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <utility>

namespace QuantLib {

    class ExtOUWithJumpsProcess;
    class ExtendedOrnsteinUhlenbeckProcess;

    template <Size N=3>
    class FdmKlugeExtOUSolver : public LazyObject {
      public:
        FdmKlugeExtOUSolver(Handle<KlugeExtOUProcess> klugeOUProcess,
                            ext::shared_ptr<YieldTermStructure> rTS,
                            FdmSolverDesc solverDesc,
                            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer())
        : klugeOUProcess_(std::move(klugeOUProcess)), rTS_(std::move(rTS)),
          solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc) {
            registerWith(klugeOUProcess_);
        }

        Real valueAt(const std::vector<Real>& x) const {
            calculate();
            return solver_->interpolateAt(x);
        }

      protected:
        void performCalculations() const override {
            ext::shared_ptr<FdmLinearOpComposite>op(
                new FdmKlugeExtOUOp(solverDesc_.mesher,
                                    klugeOUProcess_.currentLink(),
                                    rTS_, solverDesc_.bcSet, 16));

            solver_ = ext::shared_ptr<FdmNdimSolver<N> >(
                          new FdmNdimSolver<N>(solverDesc_, schemeDesc_, op));
        }

      private:
        const Handle<KlugeExtOUProcess> klugeOUProcess_;
        const ext::shared_ptr<YieldTermStructure> rTS_;

        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<FdmNdimSolver<N> > solver_;
        BOOST_STATIC_ASSERT(N >= 3); // NOLINT(readability-simplify-boolean-expr)
                                     // KlugeExtOU solver can't be applied on meshes
                                     // with less than three dimensions
    };
}

#endif
]]></document_content>
  </document>
  <document index="314">
    <source>finitedifferences/fdmsimple2dextousolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimple2dextousolver.hpp
    \brief solver for simple swing options based on ext OU process
*/


#ifndef quantlib_fdm_2d_ext_ou_solver_hpp
#define quantlib_fdm_2d_ext_ou_solver_hpp

#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    class FdmSimple2dExtOUSolver : public LazyObject {
      public:
        FdmSimple2dExtOUSolver(const Handle<ExtendedOrnsteinUhlenbeckProcess>& process,
                               ext::shared_ptr<YieldTermStructure> rTS,
                               FdmSolverDesc solverDesc,
                               const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer())
        : process_(process), rTS_(std::move(rTS)), solverDesc_(std::move(solverDesc)),
          schemeDesc_(schemeDesc) {
            registerWith(process);
        }

        Real valueAt(Real x, Real y) const {
            calculate();
            return solver_->interpolateAt(x, y);
        }

      protected:
        void performCalculations() const override {
            ext::shared_ptr<FdmLinearOpComposite>op(
                new FdmExtendedOrnsteinUhlenbeckOp(
                                solverDesc_.mesher, process_.currentLink(),
                                rTS_, solverDesc_.bcSet));

            solver_ = ext::make_shared<Fdm2DimSolver>(
                          solverDesc_, schemeDesc_, op);
        }

      private:
        const Handle<ExtendedOrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="315">
    <source>finitedifferences/fdmsimple3dextoujumpsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimple3dextoujumpsolver.hpp
    \brief solver for simple swing options based on ext OU-Jump (Kluge) Model
*/


#ifndef quantlib_fdm_3d_ext_ou_jump_solver_hpp
#define quantlib_fdm_3d_ext_ou_jump_solver_hpp

#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdm3dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    class FdmSimple3dExtOUJumpSolver : public LazyObject {
      public:
        FdmSimple3dExtOUJumpSolver(const Handle<ExtOUWithJumpsProcess>& process,
                                   ext::shared_ptr<YieldTermStructure> rTS,
                                   FdmSolverDesc solverDesc,
                                   const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer())
        : process_(process), rTS_(std::move(rTS)), solverDesc_(std::move(solverDesc)),
          schemeDesc_(schemeDesc) {
            registerWith(process);
        }

        Real valueAt(Real x, Real y, Real z) const {
            calculate();
            return solver_->interpolateAt(x, y, z);
        }

      protected:
        void performCalculations() const override {
            ext::shared_ptr<FdmLinearOpComposite>op(
                new FdmExtOUJumpOp(solverDesc_.mesher,
                                   process_.currentLink(),
                                   rTS_, solverDesc_.bcSet, 32));

            solver_ = ext::make_shared<Fdm3DimSolver>(
                          solverDesc_, schemeDesc_, op);
        }

      private:
        const Handle<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm3DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="316">
    <source>finitedifferences/fdmspreadpayoffinnervalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmspreadpayoffinnervalue.hpp
    \brief inner value calculator for a spread payoff
*/

#ifndef quantlib_fdm_spread_payoff_inner_value_hpp
#define quantlib_fdm_spread_payoff_inner_value_hpp

#include <ql/instruments/basketoption.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {

    class FdmSpreadPayoffInnerValue : public FdmInnerValueCalculator {
      public:
        FdmSpreadPayoffInnerValue(ext::shared_ptr<BasketPayoff> payoff,
                                  ext::shared_ptr<FdmInnerValueCalculator> calc1,
                                  ext::shared_ptr<FdmInnerValueCalculator> calc2)
        : payoff_(std::move(payoff)), calc1_(std::move(calc1)), calc2_(std::move(calc2)) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
            Array a(2);
            a[0] = calc1_->innerValue(iter, t);
            a[1] = calc2_->innerValue(iter, t);

            return (*payoff_)(a);
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const ext::shared_ptr<BasketPayoff> payoff_;
        const ext::shared_ptr<FdmInnerValueCalculator> calc1_;
        const ext::shared_ptr<FdmInnerValueCalculator> calc2_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="317">
    <source>finitedifferences/fdmsquarerootfwdop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Klaus Spanderen
 Copyright (C) 2014 Johannes Gttker-Schnetmann


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsquarerootfwdop.cpp
    \brief Fokker-Planck forward operator for an square root process
*/

#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>

#include <ql/experimental/finitedifferences/fdmsquarerootfwdop.hpp>
#include <ql/experimental/finitedifferences/modtriplebandlinearop.hpp>

#include <boost/math/special_functions/gamma.hpp>
#include <boost/math/distributions/non_central_chi_squared.hpp>

namespace QuantLib {

    FdmSquareRootFwdOp::FdmSquareRootFwdOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        Real kappa, Real theta, Real sigma,
        Size direction, TransformationType transform)
    : direction_(direction),
      kappa_(kappa),
      theta_(theta),
      sigma_(sigma),
      transform_(transform),
      mapX_(transform == Plain ?
          new ModTripleBandLinearOp(FirstDerivativeOp(direction_, mesher)
              .mult(kappa*(mesher->locations(direction_)-theta) + sigma*sigma)
              .add(SecondDerivativeOp(direction_, mesher)
                   .mult(0.5*sigma*sigma*mesher->locations(direction_)))
                .add(Array(mesher->layout()->size(), kappa)))

        : transform == Power ? new ModTripleBandLinearOp(
            SecondDerivativeOp(direction_, mesher)
               .mult(0.5*sigma*sigma*mesher->locations(direction_))
               .add(FirstDerivativeOp(direction_, mesher)
                     .mult(kappa*(mesher->locations(direction_)+theta)))
               .add(Array(mesher->layout()->size(),
                          2*kappa*kappa*theta/(sigma*sigma))))

            : new ModTripleBandLinearOp(FirstDerivativeOp(direction_, mesher)
                    .mult(Exp(-mesher->locations(direction))
                        *( -0.5*sigma*sigma - kappa*theta) + kappa)
                    .add(SecondDerivativeOp(direction_, mesher)
                    .mult(0.5*sigma*sigma*Exp(-mesher->locations(direction))))
                    .add(kappa*theta*Exp(-mesher->locations(direction))))
            ),
      v_  (mesher->layout()->dim()[direction_]) {

        const FdmLinearOpIterator endIter = mesher->layout()->end();
        for (FdmLinearOpIterator iter = mesher->layout()->begin();
            iter != endIter; ++iter) {
            const Real v = mesher->location(iter, direction_);
            v_[iter.coordinates()[direction_]] = v;
        }

        // zero flux boundary condition
        setLowerBC(mesher);
        setUpperBC(mesher);
    }

    void FdmSquareRootFwdOp::setLowerBC(
        const ext::shared_ptr<FdmMesher>& mesher) {
        const Size n = 1;
        Real alpha, beta, gamma;

        getCoeff(alpha, beta, gamma, n);
        const Real f = lowerBoundaryFactor(transform_);

        const Real b = -(h(n-1)+h(n))/zeta(n);
        const Real c =  h(n-1)/zetap(n);

        const FdmLinearOpIterator endIter = mesher->layout()->end();
        for (FdmLinearOpIterator iter = mesher->layout()->begin();
            iter != endIter; ++iter) {
            if (iter.coordinates()[direction_] == 0) {
                const Size idx = iter.index();
                mapX_->diag(idx)  = beta  + f*b; //*v(n-1);
                mapX_->upper(idx) = gamma + f*c; //*v(n-1);
            }
        }
    }

    void FdmSquareRootFwdOp::setUpperBC(
        const ext::shared_ptr<FdmMesher>& mesher) {
        const Size n = v_.size();
        Real alpha, beta, gamma;

        getCoeff(alpha, beta, gamma, n);
        const Real f = upperBoundaryFactor(transform_);

        const Real b = (h(n)+h(n-1))/zeta(n);
        const Real c = -h(n)/zetam(n);

        const FdmLinearOpIterator endIter = mesher->layout()->end();
        for (FdmLinearOpIterator iter = mesher->layout()->begin();
            iter != endIter; ++iter) {
            if (iter.coordinates()[direction_] == n-1) {
                const Size idx = iter.index();
                mapX_->diag(idx) = beta   + f*b; //*v(n+1);
                mapX_->lower(idx) = alpha + f*c; //*v(n+1);
            }
        }
    }

    Real FdmSquareRootFwdOp::lowerBoundaryFactor(TransformationType transform) const {
        if (transform == Plain) {
            return f0Plain();
        }
        else if (transform == Power) {
            return f0Power();
        }
        else if (transform == Log) {
            return f0Log();
        }
        else
            QL_FAIL("unknown transform");
    }

    Real FdmSquareRootFwdOp::upperBoundaryFactor(TransformationType transform) const {
        if (transform == Plain) {
            return f1Plain();
        }
        else if (transform == Power) {
            return f1Power();
        }
        else if (transform == Log) {
            return f1Log();
        }
        else
            QL_FAIL("unknown transform");
    }

    Real FdmSquareRootFwdOp::f0Plain() const {
        const Size n = 1;
        const Real a = -(2*h(n-1)+h(n))/zetam(n);
        const Real alpha = sigma_*sigma_*v(n)/zetam(n) - mu(n)*h(n)/zetam(n);
        const Real nu = a*v(n-1) + (2*kappa_*(v(n-1)-theta_) + sigma_*sigma_)
                                        /(sigma_*sigma_);

        return alpha/nu*v(n-1);
    }

    Real FdmSquareRootFwdOp::f1Plain() const {
        const Size n = v_.size();
        const Real a =  (2*h(n)+h(n-1))/zetap(n);
        const Real gamma = sigma_*sigma_*v(n)/zetap(n) + mu(n)*h(n-1)/zetap(n);
        const Real nu = a*v(n+1) + (2*kappa_*(v(n+1)-theta_) + sigma_*sigma_)
                        /(sigma_*sigma_);

        return gamma/nu*v(n+1);
    }

    Real FdmSquareRootFwdOp::f0Power() const {
        const Size n = 1;
        const Real mu = kappa_*(v(n)+theta_);
        const Real a = -(2*h(n-1)+h(n))/zetam(n);
        const Real alpha = sigma_*sigma_*v(n)/zetam(n) - mu*h(n)/zetam(n);
        const Real nu  = a*v(n-1) +2*(kappa_*v(n-1)/(sigma_*sigma_));

        return alpha/nu*v(n-1);
    }

    Real FdmSquareRootFwdOp::f1Power() const {
        const Size n = v_.size();
        const Real mu = kappa_*(v(n)+theta_);
        const Real a =  (2*h(n)+h(n-1))/zetap(n);
        const Real gamma = sigma_*sigma_*v(n)/zetap(n) + mu*h(n-1)/zetap(n);
        const Real nu = a*v(n+1) +2*(kappa_*v(n+1)/(sigma_*sigma_));

        return gamma/nu*v(n+1); 
    }

    Real FdmSquareRootFwdOp::f0Log() const {
        const Size n = 1;
        const Real mu = ((-kappa_*theta_-sigma_*sigma_/2.0)*exp(-v(1))+kappa_);
        const Real a = -(2*h(n-1)+h(n))/zetam(n);
        const Real alpha = sigma_*sigma_*exp(-v(n))/zetam(n) - mu*h(n)/zetam(n);
        const Real nu = a*exp(-v(n-1)) + 2*kappa_*(1-theta_*exp(-v(n-1)))
                        /(sigma_*sigma_);

        return alpha/nu*exp(-v(n-1));
    }

    Real FdmSquareRootFwdOp::f1Log() const {
        const Size n = v_.size();
        const Real mu = ((-kappa_*theta_-sigma_*sigma_/2.0)*exp(-v(n))+kappa_);
        const Real a =  (2*h(n)+h(n-1))/zetap(n);
        const Real gamma = sigma_*sigma_*exp(-v(n))/zetap(n) + mu*h(n-1)/zetap(n);
        const Real nu = a*exp(-v(n+1)) + 2*kappa_*(1-theta_*exp(-v(n+1)))
                        /(sigma_*sigma_);

        return gamma/nu*exp(-v(n+1));
    }

    Real FdmSquareRootFwdOp::v(Size i) const {
        if (i > 0 && i <= v_.size()) {
            return v_[i-1];
        }
        else if (i == 0) {
            if (transform_ == Log) {
                return 2*v_[0] - v_[1];
//              log(std::max(0.5*exp(v_[0]), exp(v_[0] - 0.01 * (v_[1] - v_[0]))));
            } else {
                return std::max(0.5*v_[0], v_[0] - 0.01 * (v_[1] - v_[0]));
            }
        }
        else if (i == v_.size()+1) {
            return v_.back() + (v_.back() - *(v_.end()-2));
        }
        else {
            QL_FAIL("unknown index");
        }
    }

    Real FdmSquareRootFwdOp::h(Size i) const {
        return v(i+1) - v(i);
    }
    Real FdmSquareRootFwdOp::mu(Size i) const {
        return kappa_*(v(i) - theta_) + sigma_*sigma_;
    }
    Real FdmSquareRootFwdOp::zetam(Size i) const {
        return h(i-1)*(h(i-1)+h(i));
    }
    Real FdmSquareRootFwdOp::zeta(Size i) const {
        return h(i-1)*h(i);
    }
    Real FdmSquareRootFwdOp::zetap(Size i) const {
        return h(i)*(h(i-1)+h(i));
    }

    Size FdmSquareRootFwdOp::size() const {
        return 1;
    }
    void FdmSquareRootFwdOp::setTime(Time, Time) {
    }

    void FdmSquareRootFwdOp::getCoeff(Real& alpha, Real& beta,
                                               Real& gamma, Size n) const {
        if (transform_ == Plain) {
            getCoeffPlain(alpha, beta, gamma, n);
        }
        else if (transform_ == Power) {
            getCoeffPower(alpha, beta, gamma, n);
        }
        else if (transform_ == Log) {
            getCoeffLog(alpha, beta, gamma, n);
        } 
    }

    void FdmSquareRootFwdOp::getCoeffPlain(Real& alpha, Real& beta,
                                               Real& gamma, Size n) const {
        alpha =   sigma_*sigma_*v(n)/zetam(n) - mu(n)*h(n)/zetam(n);
        beta  = - sigma_*sigma_*v(n)/zeta(n)
                    + mu(n)*(h(n)-h(n-1))/zeta(n) + kappa_;
        gamma =   sigma_*sigma_*v(n)/zetap(n) + mu(n)*h(n-1)/zetap(n);

    }

    void FdmSquareRootFwdOp::getCoeffLog(Real& alpha, Real& beta,
                                               Real& gamma, Size n) const {
        const Real mu = ((-kappa_*theta_-sigma_*sigma_/2.0)*exp(-v(n))+kappa_);
        alpha =   sigma_*sigma_*exp(-v(n))/zetam(n) - mu*h(n)/zetam(n);
        beta  = - sigma_*sigma_*exp(-v(n))/zeta(n)
                          + mu*(h(n)-h(n-1))/zeta(n) + kappa_*theta_*exp(-v(n));
        gamma =   sigma_*sigma_*exp(-v(n))/zetap(n) + mu*h(n-1)/zetap(n);
    }

    void FdmSquareRootFwdOp::getCoeffPower(Real& alpha, Real& beta,
                                               Real& gamma, Size n) const {
        const Real mu = kappa_*(theta_+v(n));
        alpha = (sigma_*sigma_*v(n) - mu*h(n))/zetam(n);
        beta = (-sigma_*sigma_*v(n) + mu*(h(n)-h(n-1)))/zeta(n)
                                + 2*kappa_*kappa_*theta_/(sigma_*sigma_);
        gamma=  (sigma_*sigma_*v(n) + mu*h(n-1))/zetap(n);
    }

    Disposable<Array> FdmSquareRootFwdOp::apply(const Array& p) const {
        return mapX_->apply(p);
    }

    Disposable<Array> FdmSquareRootFwdOp::apply_mixed(const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }
    Disposable<Array> FdmSquareRootFwdOp::apply_direction(
        Size direction, const Array& r) const {
        if (direction == direction_) {
            return mapX_->apply(r);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }
    Disposable<Array> FdmSquareRootFwdOp::solve_splitting(
        Size direction, const Array& r, Real dt) const {
        if (direction == direction_) {
            return mapX_->solve_splitting(r, dt, 1.0);
        }
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array> FdmSquareRootFwdOp::preconditioner(
        const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmSquareRootFwdOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapX_->toMatrix());
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="318">
    <source>finitedifferences/fdmsquarerootfwdop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Klaus Spanderen
 Copyright (C) 2014 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsquarerootfwdop.hpp
    \brief Square root linear operator for the Fokker-Planck forward equation
*/

#ifndef quantlib_fdm_square_root_fwd_op_hpp
#define quantlib_fdm_square_root_fwd_op_hpp

#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {
    class FdmMesher;
    class SquareRootProcess;
    class TripleBandLinearOp;
    class ModTripleBandLinearOp;

    class FdmSquareRootFwdOp : public FdmLinearOpComposite {
      public:
        enum TransformationType { Plain, Power, Log };

        FdmSquareRootFwdOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            Real kappa, Real theta, Real sigma,
            Size direction,
            TransformationType type = Plain);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

        Real lowerBoundaryFactor(TransformationType type = Plain) const;
        Real upperBoundaryFactor(TransformationType type = Plain) const;
        Real v(Size i) const;

      private:
        void setLowerBC(const ext::shared_ptr<FdmMesher>& mesher);
        void setUpperBC(const ext::shared_ptr<FdmMesher>& mesher);

        void getCoeff(Real& alpha, Real& beta,
                               Real& gamma, Size n) const;
        void getCoeffPlain(Real& alpha, Real& beta,
                               Real& gamma, Size n) const;
        void getCoeffPower(Real& alpha, Real& beta,
                               Real& gamma, Size n) const;
        void getCoeffLog(Real& alpha, Real& beta,
                               Real& gamma, Size n) const;

        Real f0Plain() const;
        Real f1Plain() const;
        Real f0Power() const;
        Real f1Power() const;
        Real f0Log() const;
        Real f1Log() const;

        Real h    (Size i) const;
        Real zetam(Size i) const;
        Real zeta (Size i) const;
        Real zetap(Size i) const;
        Real mu   (Size i) const;

        const Size direction_;
        const Real kappa_, theta_, sigma_;
        const TransformationType transform_;
        ext::shared_ptr<ModTripleBandLinearOp> mapX_;
        Array v_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="319">
    <source>finitedifferences/fdmvppstartlimitstepcondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstartlimitstepcondition.cpp
*/

#include <ql/math/array.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/experimental/finitedifferences/fdmvppstartlimitstepcondition.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>


namespace QuantLib {

    FdmVPPStartLimitStepCondition::FdmVPPStartLimitStepCondition(
        const FdmVPPStepConditionParams& params,
        Size nStarts,
        const FdmVPPStepConditionMesher& mesh,
        const ext::shared_ptr<FdmInnerValueCalculator>& gasPrice,
        const ext::shared_ptr<FdmInnerValueCalculator>& sparkSpreadPrice)
    : FdmVPPStepCondition(params,
                          nStates(params.tMinUp, params.tMinDown, nStarts),
                          mesh, gasPrice, sparkSpreadPrice),
      nStarts_(nStarts) {
        QL_REQUIRE(tMinUp_ > 0,   "minimum up time must be greater than one");
        QL_REQUIRE(tMinDown_ > 0, "minimum down time must be greater than one");
    }

    Disposable<Array> FdmVPPStartLimitStepCondition::changeState(
        const Real gasPrice, const Array& state, Time) const {
        const Real startUpCost
                = startUpFixCost_ + (gasPrice + fuelCostAddon_)*startUpFuel_;

        Array retVal(state.size());
        const Size sss = 2*tMinUp_ + tMinDown_;

        for (Size i=0; i < nStates_; ++i) {
            const Size j = i % sss;

            if (j < tMinUp_-1) {
                retVal[i] = std::max(state[i+1], state[tMinUp_+i+1]);
            }
            else if (j == tMinUp_-1) {
                retVal[i] = std::max(state[i+tMinUp_+1],
                                     std::max(state[i], state[i+tMinUp_]));
            }
            else if (j < 2*tMinUp_) {
                retVal[i] = retVal[i-tMinUp_];
            }
            else if (j <  2*tMinUp_+tMinDown_-1) {
                retVal[i] = state[i+1];
            }
            else if (nStarts_ == Null<Size>()) {
                retVal[i] = std::max(state[i],
                    std::max(state.front(), state[tMinUp_]) - startUpCost);

            }
            else if (i >= sss) {
                retVal[i] = std::max(state[i],
                    std::max(state[i+1-2*sss], state[i+1-2*sss+tMinUp_])
                            - startUpCost);
            }
            else {
                retVal[i] = state[i];
            }
        }

        return retVal;
    }

    Size FdmVPPStartLimitStepCondition::nStates(Size tMinUp, Size tMinDown,
                                                Size nStarts) {
        return (2*tMinUp+tMinDown)*((nStarts == Null<Size>())? 1 : nStarts+1);
    }

    Real FdmVPPStartLimitStepCondition::maxValue(const Array& states) const {
        return *std::max_element(states.begin(), states.end());
    }

}
]]></document_content>
  </document>
  <document index="320">
    <source>finitedifferences/fdmvppstartlimitstepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstartlimitstepcondition.hpp
    \brief VPP incl start limit step condition for FD models
*/

#ifndef quantlib_fdm_vpp_start_limit_step_condition_hpp
#define quantlib_fdm_vpp_start_limit_step_condition_hpp

#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    class FdmVPPStartLimitStepCondition : public FdmVPPStepCondition {
      public:
        FdmVPPStartLimitStepCondition(
            const FdmVPPStepConditionParams& params,
            Size nStarts,
            const FdmVPPStepConditionMesher& mesh,
            const ext::shared_ptr<FdmInnerValueCalculator>& gasPrice,
            const ext::shared_ptr<FdmInnerValueCalculator>& sparkSpreadPrice);

        static Size nStates(Size tMinUp, Size tMinDown, Size nStarts);
        Real maxValue(const Array& states) const override;

      private:
        Disposable<Array> changeState(Real gasPrice, const Array& state, Time t) const override;

        const Size nStarts_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="321">
    <source>finitedifferences/fdmvppstepcondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstepcondition.cpp
*/

#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>
#include <ql/math/array.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {
    FdmVPPStepCondition::FdmVPPStepCondition(
        const FdmVPPStepConditionParams& params,
        Size nStates,
        const FdmVPPStepConditionMesher& mesh,
        ext::shared_ptr<FdmInnerValueCalculator> gasPrice,
        ext::shared_ptr<FdmInnerValueCalculator> sparkSpreadPrice)
    : heatRate_(params.heatRate), pMin_(params.pMin), pMax_(params.pMax), tMinUp_(params.tMinUp),
      tMinDown_(params.tMinDown), startUpFuel_(params.startUpFuel),
      startUpFixCost_(params.startUpFixCost), fuelCostAddon_(params.fuelCostAddon),
      stateDirection_(mesh.stateDirection), nStates_(nStates), mesher_(mesh.mesher),
      gasPrice_(std::move(gasPrice)), sparkSpreadPrice_(std::move(sparkSpreadPrice)),
      stateEvolveFcts_(nStates_) {

        QL_REQUIRE(nStates_ == mesher_->layout()->dim()[stateDirection_],
                   "mesher does not fit to vpp arguments");

        for (Size i=0; i < nStates_; ++i) {
            const Size j = i % (2*tMinUp_ + tMinDown_);

            if (j < tMinUp_) {
                stateEvolveFcts_[i] = [&](Real x){ return evolveAtPMin(x); };
            }
            else if (j < 2*tMinUp_){
                stateEvolveFcts_[i] = [&](Real x) { return evolveAtPMax(x); };
            }
        }
    }


    Size FdmVPPStepCondition::nStates() const {
        return nStates_;
    }


    void FdmVPPStepCondition::applyTo(Array& a, Time t) const {
        ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();

        const Size nStates = layout->dim()[stateDirection_];
        const FdmLinearOpIterator endIter = layout->end();

        for (FdmLinearOpIterator iter=layout->begin();iter != endIter; ++iter) {
            a[iter.index()] += evolve(iter, t);
        }

        for (FdmLinearOpIterator iter=layout->begin();iter != endIter; ++iter) {
            if (iter.coordinates()[stateDirection_] == 0U) {

                Array x(nStates);
                for (Size i=0; i < nStates; ++i) {
                    x[i] = a[layout->neighbourhood(iter, stateDirection_, i)];
                }

                const Real gasPrice = gasPrice_->innerValue(iter, t);
                x = changeState(gasPrice, x, t);
                for (Size i=0; i < nStates; ++i) {
                    a[layout->neighbourhood(iter, stateDirection_, i)] = x[i];
                }
            }
        }
    }

    Real FdmVPPStepCondition::evolve(
        const FdmLinearOpIterator& iter, Time t) const {

        const Size state = iter.coordinates()[stateDirection_];

        if (!(stateEvolveFcts_[state])) {
            return 0.0;
        }
        else {
            const Real sparkSpread = sparkSpreadPrice_->innerValue(iter, t);
            return stateEvolveFcts_[state](sparkSpread);
        }
    }


    Real FdmVPPStepCondition::evolveAtPMin(Real sparkSpread) const {
        return pMin_*(sparkSpread - heatRate_*fuelCostAddon_);
    }

    Real FdmVPPStepCondition::evolveAtPMax(Real sparkSpread) const {
        return pMax_*(sparkSpread - heatRate_*fuelCostAddon_);
    }
}
]]></document_content>
  </document>
  <document index="322">
    <source>finitedifferences/fdmvppstepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstepcondition.hpp
    \brief VPP step condition for FD models
*/

#ifndef quantlib_fdm_vpp_step_condition_hpp
#define quantlib_fdm_vpp_step_condition_hpp

#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/shared_ptr.hpp>
#include <ql/functional.hpp>
#include <vector>

namespace QuantLib {
    class FdmMesher;
    class FdmLinearOpIterator;
    class FdmInnerValueCalculator;

    struct FdmVPPStepConditionParams {
        const Real heatRate;
        const Real pMin; const Real pMax;
        const Size tMinUp; const Size tMinDown;
        const Real startUpFuel; const Real startUpFixCost;
        const Real fuelCostAddon;
    };

    struct FdmVPPStepConditionMesher {
        const Size stateDirection;
        const ext::shared_ptr<FdmMesher> mesher;
    };

    class FdmVPPStepCondition : public StepCondition<Array> {
      public:
        FdmVPPStepCondition(const FdmVPPStepConditionParams& params,
                            Size nStates,
                            const FdmVPPStepConditionMesher& mesh,
                            ext::shared_ptr<FdmInnerValueCalculator> gasPrice,
                            ext::shared_ptr<FdmInnerValueCalculator> sparkSpreadPrice);

        Size nStates() const;
        void applyTo(Array& a, Time t) const override;

        virtual Real maxValue(const Array& states) const = 0;

      protected:
        Real evolveAtPMin(Real sparkSpread) const;
        Real evolveAtPMax(Real sparkSpread) const;

        Real evolve(const FdmLinearOpIterator& iter, Time t) const;

        virtual Disposable<Array> changeState(
            Real gasPrice, const Array& state, Time t) const = 0;

        const Real heatRate_;
        const Real pMin_, pMax_;
        const Size tMinUp_, tMinDown_;
        const Real startUpFuel_, startUpFixCost_;
        const Real fuelCostAddon_;
        const Size stateDirection_;
        const Size nStates_;

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<FdmInnerValueCalculator> gasPrice_;
        const ext::shared_ptr<FdmInnerValueCalculator> sparkSpreadPrice_;

        std::vector<ext::function<Real (Real)> > stateEvolveFcts_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="323">
    <source>finitedifferences/fdmvppstepconditionfactory.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstepconditionfactory.cpp
*/

#include <ql/experimental/finitedifferences/fdmvppstartlimitstepcondition.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepconditionfactory.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <utility>

namespace QuantLib {

    FdmVPPStepConditionFactory::FdmVPPStepConditionFactory(VanillaVPPOption::arguments args)
    : args_(std::move(args)) {
        QL_REQUIRE(!(   args_.nStarts       != Null<Size>()
                     && args_.nRunningHours != Null<Size>()),
                   "start and running hour limt together is not supported");

        if (   args_.nRunningHours == Null<Size>()
            && args_.nStarts == Null<Size>()) {
            type_ = Vanilla;
        }
        else if (args_.nRunningHours == Null<Size>()) {
            type_ = StartLimit;
        }
        else {
            type_ = RunningHourLimit;
        }
    }

    ext::shared_ptr<Fdm1dMesher>
    FdmVPPStepConditionFactory::stateMesher() const {
        Size nStates;
        switch (type_) {
          case Vanilla:
            nStates = 2*args_.tMinUp + args_.tMinDown;
            break;
          case StartLimit:
            nStates = FdmVPPStartLimitStepCondition::nStates(
                       args_.tMinUp,args_.tMinDown, args_.nStarts);
            break;
          default:
            QL_FAIL("vpp type is not supported");
        }

        return ext::shared_ptr<Fdm1dMesher>(
            new Uniform1dMesher(0.0, 1.0, nStates));
    }

    ext::shared_ptr<FdmVPPStepCondition> FdmVPPStepConditionFactory::build(
        const FdmVPPStepConditionMesher& mesh,
        Real fuelCostAddon,
        const ext::shared_ptr<FdmInnerValueCalculator>& fuel,
        const ext::shared_ptr<FdmInnerValueCalculator>& spark) const {

        const FdmVPPStepConditionParams params = {
            args_.heatRate, args_.pMin, args_.pMax,
            args_.tMinUp, args_.tMinDown,
            args_.startUpFuel, args_.startUpFixCost,
            fuelCostAddon
        };

        switch (type_) {
          case Vanilla:
          case StartLimit:
              return ext::shared_ptr<FdmVPPStepCondition>(
                  new FdmVPPStartLimitStepCondition(params, args_.nStarts,
                          mesh, fuel, spark));
              break;
          default:
            QL_FAIL("vpp type is not supported");
        }
    }
}
]]></document_content>
  </document>
  <document index="324">
    <source>finitedifferences/fdmvppstepconditionfactory.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstepconditionfactory.hpp
    \brief factory for VPP step conditions for FD models
*/

#ifndef quantlib_fdm_vpp_step_condition_factory_hpp
#define quantlib_fdm_vpp_step_condition_factory_hpp

#include <ql/math/array.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>

namespace QuantLib {
    class Fdm1dMesher;

    class FdmVPPStepConditionFactory {
      public:
        explicit FdmVPPStepConditionFactory(VanillaVPPOption::arguments args);

        ext::shared_ptr<Fdm1dMesher> stateMesher() const;
        ext::shared_ptr<FdmVPPStepCondition> build(
            const FdmVPPStepConditionMesher& mesh,
            Real fuelCostAddon,
            const ext::shared_ptr<FdmInnerValueCalculator>& fuel,
            const ext::shared_ptr<FdmInnerValueCalculator>& spark) const;

      private:
        enum Type { Vanilla, StartLimit, RunningHourLimit } type_;

        const VanillaVPPOption::arguments args_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="325">
    <source>finitedifferences/fdmzabrop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/finitedifferences/fdmzabrop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>

namespace QuantLib {

FdmZabrUnderlyingPart::FdmZabrUnderlyingPart(
    const ext::shared_ptr<FdmMesher> &mesher, const Real beta, const Real nu,
    const Real rho, const Real gamma)
    : volatilityValues_(mesher->locations(1)),
      forwardValues_(mesher->locations(0)),
      mapT_(SecondDerivativeOp(0, mesher)
                .mult(0.5 * volatilityValues_ * volatilityValues_ *
                      Pow(forwardValues_, 2.0 * beta))),
      mesher_(mesher) {}

void FdmZabrUnderlyingPart::setTime(Time t1, Time t2) {}

const TripleBandLinearOp &FdmZabrUnderlyingPart::getMap() const {
    return mapT_;
}

FdmZabrVolatilityPart::FdmZabrVolatilityPart(
    const ext::shared_ptr<FdmMesher> &mesher, const Real beta, const Real nu,
    const Real rho, const Real gamma)
    : volatilityValues_(mesher->locations(1)),
      forwardValues_(mesher->locations(0)),
      mapT_(SecondDerivativeOp(1, mesher).mult(
          0.5 * nu * nu * Pow(volatilityValues_, 2.0 * gamma))),
      mesher_(mesher) {}

void FdmZabrVolatilityPart::setTime(Time t1, Time t2) {}

const TripleBandLinearOp &FdmZabrVolatilityPart::getMap() const {
    return mapT_;
}

FdmZabrOp::FdmZabrOp(const ext::shared_ptr<FdmMesher> &mesher,
                     const Real beta, const Real nu, const Real rho,
                     const Real gamma)
    : volatilityValues_(mesher->locations(1)),
      forwardValues_(mesher->locations(0)),
      dxyMap_(SecondOrderMixedDerivativeOp(0, 1, mesher)
                  .mult(nu * rho * Pow(Abs(volatilityValues_), gamma + 1.0) *
                        Pow(forwardValues_, beta))),
      dxMap_(FdmZabrUnderlyingPart(mesher, beta, nu, rho, gamma)),
      dyMap_(FdmZabrVolatilityPart(mesher, beta, nu, rho, gamma)) {}

void FdmZabrOp::setTime(Time t1, Time t2) {
    dxMap_.setTime(t1, t2);
    dyMap_.setTime(t1, t2);
}

Size FdmZabrOp::size() const { return 2; }

Disposable<Array> FdmZabrOp::apply(const Array &u) const {
    return dyMap_.getMap().apply(u) + dxMap_.getMap().apply(u) +
           dxyMap_.apply(u);
}

Disposable<Array> FdmZabrOp::apply_direction(Size direction,
                                             const Array &r) const {
    if (direction == 0)
        return dxMap_.getMap().apply(r);
    else if (direction == 1)
        return dyMap_.getMap().apply(r);
    else
        QL_FAIL("direction too large");
}

Disposable<Array> FdmZabrOp::apply_mixed(const Array &r) const {
    return dxyMap_.apply(r);
}

Disposable<Array> FdmZabrOp::solve_splitting(Size direction, const Array &r,
                                             Real a) const {

    if (direction == 0) {
        return dxMap_.getMap().solve_splitting(r, a, 1.0);
    } else if (direction == 1) {
        return dyMap_.getMap().solve_splitting(r, a, 1.0);
    } else
        QL_FAIL("direction too large");
}

Disposable<Array> FdmZabrOp::preconditioner(const Array &r, Real dt) const {

    return solve_splitting(0, r, dt);
}

Disposable<std::vector<SparseMatrix> > FdmZabrOp::toMatrixDecomp() const {
    std::vector<SparseMatrix> retVal(3);
    retVal[0] = dxMap_.getMap().toMatrix();
    retVal[1] = dyMap_.getMap().toMatrix();
    retVal[2] = dxyMap_.toMatrix();
    return retVal;
}

}
]]></document_content>
  </document>
  <document index="326">
    <source>finitedifferences/fdmzabrop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmzabrop.hpp
    \brief Zabr linear pricing operator
*/

#ifndef quantlib_fdm_zabr_op_hpp
#define quantlib_fdm_zabr_op_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

class FdmZabrUnderlyingPart {
  public:
    FdmZabrUnderlyingPart(
        const ext::shared_ptr<FdmMesher>& mesher, Real beta, Real nu, Real rho, Real gamma);

    void setTime(Time t1, Time t2);
    const TripleBandLinearOp &getMap() const;

  protected:
    const Array volatilityValues_;
    const Array forwardValues_;
    TripleBandLinearOp mapT_;

    const ext::shared_ptr<FdmMesher> mesher_;
};

class FdmZabrVolatilityPart {
  public:
    FdmZabrVolatilityPart(
        const ext::shared_ptr<FdmMesher>& mesher, Real beta, Real nu, Real rho, Real gamma);

    void setTime(Time t1, Time t2);
    const TripleBandLinearOp &getMap() const;

  protected:
    const Array volatilityValues_;
    const Array forwardValues_;
    TripleBandLinearOp mapT_;

    const ext::shared_ptr<FdmMesher> mesher_;
};

class FdmZabrOp : public FdmLinearOpComposite {
  public:
    FdmZabrOp(const ext::shared_ptr<FdmMesher>& mesher,
              Real beta,
              Real nu,
              Real rho,
              Real gamma = 1.0); // gamma=1.0 recovers the classic sabr model

    Size size() const override;
    void setTime(Time t1, Time t2) override;

    Disposable<Array> apply(const Array& r) const override;
    Disposable<Array> apply_mixed(const Array& r) const override;

    Disposable<Array> apply_direction(Size direction, const Array& r) const override;
    Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
    Disposable<Array> preconditioner(const Array& r, Real s) const override;

    Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

  private:
    const Array volatilityValues_;
    const Array forwardValues_;
    NinePointLinearOp dxyMap_;
    FdmZabrUnderlyingPart dxMap_;
    FdmZabrVolatilityPart dyMap_;
};
}

#endif
]]></document_content>
  </document>
  <document index="327">
    <source>finitedifferences/fdornsteinuhlenbeckvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/finitedifferences/fdornsteinuhlenbeckvanillaengine.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmornsteinuhlenbeckop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        class FdmOUInnerValue : public FdmInnerValueCalculator {
          public:
            FdmOUInnerValue(ext::shared_ptr<Payoff> payoff,
                            ext::shared_ptr<FdmMesher> mesher,
                            Size direction)
            : payoff_(std::move(payoff)), mesher_(std::move(mesher)), direction_(direction) {}


            Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
                const Real s = mesher_->location(iter, direction_);
                return (*payoff_)(s);
            }

            Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
                return innerValue(iter, t);
            }

          private:
            const ext::shared_ptr<Payoff> payoff_;
            const ext::shared_ptr<FdmMesher> mesher_;
            const Size direction_;
        };
    }

    FdOrnsteinUhlenbeckVanillaEngine::FdOrnsteinUhlenbeckVanillaEngine(
        ext::shared_ptr<OrnsteinUhlenbeckProcess> process,
        const ext::shared_ptr<YieldTermStructure>& rTS,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        Real epsilon,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), rTS_(rTS), tGrid_(tGrid), xGrid_(xGrid),
      dampingSteps_(dampingSteps), epsilon_(epsilon), schemeDesc_(schemeDesc) {
        registerWith(process_);
        registerWith(rTS);
    }

    void FdOrnsteinUhlenbeckVanillaEngine::calculate() const {

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        const DayCounter dc = rTS_->dayCounter();
        const Date referenceDate = rTS_->referenceDate();

        const Time maturity = dc.yearFraction(
            referenceDate, arguments_.exercise->lastDate());

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmSimpleProcess1dMesher(
                xGrid_, process_, maturity, 1, epsilon_));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher));

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
            new FdmOUInnerValue(payoff, mesher, 0));

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                                    arguments_.cashFlow, arguments_.exercise,
                                    mesher, calculator,
                                    referenceDate, dc);

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions, calculator,
                                     maturity, tGrid_, dampingSteps_ };

        const ext::shared_ptr<FdmOrnsteinUhlenbeckOp> op(
            new FdmOrnsteinUhlenbeckOp(mesher, process_, rTS_, 0));

        const ext::shared_ptr<Fdm1DimSolver> solver(
                new Fdm1DimSolver(solverDesc, schemeDesc_, op));

        const Real spot = process_->x0();

        results_.value = solver->interpolateAt(spot);
        results_.delta = solver->derivativeX(spot);
        results_.gamma = solver->derivativeXX(spot);
        results_.theta = solver->thetaAt(spot);
    }
}
]]></document_content>
  </document>
  <document index="328">
    <source>finitedifferences/fdornsteinuhlenbeckvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesvanillaengine.hpp
    \brief Finite-Differences Black Scholes vanilla option engine
*/

#ifndef quantlib_fd_ornstein_uhlenbeck_vanilla_engine_hpp
#define quantlib_fd_ornstein_uhlenbeck_vanilla_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/dividendvanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class OrnsteinUhlenbeckProcess;

    class FdOrnsteinUhlenbeckVanillaEngine
         : public DividendVanillaOption::engine {
      public:
        // Constructor
        FdOrnsteinUhlenbeckVanillaEngine(
            ext::shared_ptr<OrnsteinUhlenbeckProcess>,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            Real epsilon = 0.0001,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<OrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const Size tGrid_, xGrid_, dampingSteps_;
        const Real epsilon_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="329">
    <source>finitedifferences/fdsimpleextoujumpswingengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoujumpswingengine.cpp
    \brief Finite Differences engine for simple swing options
*/


#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmsimple3dextoujumpsolver.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoujumpswingengine.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdm3dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimpleswingcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdSimpleExtOUJumpSwingEngine::FdSimpleExtOUJumpSwingEngine(
        ext::shared_ptr<ExtOUWithJumpsProcess> process,
        ext::shared_ptr<YieldTermStructure> rTS,
        Size tGrid,
        Size xGrid,
        Size yGrid,
        ext::shared_ptr<Shape> shape,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), rTS_(std::move(rTS)), shape_(std::move(shape)), tGrid_(tGrid),
      xGrid_(xGrid), yGrid_(yGrid), schemeDesc_(schemeDesc) {}

    void FdSimpleExtOUJumpSwingEngine::calculate() const {

        // 1. Exercise
        ext::shared_ptr<SwingExercise> swingExercise(
            ext::dynamic_pointer_cast<SwingExercise>(arguments_.exercise));

        QL_REQUIRE(swingExercise, "Swing exercise supported only");

        // 2. Mesher
        const std::vector<Time> exerciseTimes
            = swingExercise->exerciseTimes(rTS_->dayCounter(),
                                           rTS_->referenceDate());

        const Time maturity = exerciseTimes.back();
        const ext::shared_ptr<StochasticProcess1D> ouProcess(
                              process_->getExtendedOrnsteinUhlenbeckProcess());
        const ext::shared_ptr<Fdm1dMesher> xMesher(
                     new FdmSimpleProcess1dMesher(xGrid_, ouProcess,maturity));

        const ext::shared_ptr<Fdm1dMesher> yMesher(
                        new ExponentialJump1dMesher(yGrid_,
                                                    process_->beta(),
                                                    process_->jumpIntensity(),
                                                    process_->eta()));
        const ext::shared_ptr<Fdm1dMesher> exerciseMesher(
                       new Uniform1dMesher(
                           0, static_cast<Real>(arguments_.maxExerciseRights),
                           arguments_.maxExerciseRights+1));

        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(xMesher, yMesher, exerciseMesher));

        // 3. Calculator
        ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                                    new FdmZeroInnerValue());
        // 4. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        // 4.1 Bermudan step conditions
        stoppingTimes.push_back(exerciseTimes);

        ext::shared_ptr<FdmInnerValueCalculator> exerciseCalculator(
            new FdmExtOUJumpModelInnerValue(arguments_.payoff, mesher, shape_));

        stepConditions.push_back(ext::shared_ptr<StepCondition<Array> >(
            new FdmSimpleSwingCondition(
                exerciseTimes, mesher, exerciseCalculator,
                2, arguments_.minExerciseRights)));

        ext::shared_ptr<FdmStepConditionComposite> conditions(
                new FdmStepConditionComposite(stoppingTimes, stepConditions));


        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. set-up solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity, tGrid_, 0 };

        const ext::shared_ptr<FdmSimple3dExtOUJumpSolver> solver(
            new FdmSimple3dExtOUJumpSolver(
                                    Handle<ExtOUWithJumpsProcess>(process_),
                                    rTS_, solverDesc, schemeDesc_));

        const Real x = process_->initialValues()[0];
        const Real y = process_->initialValues()[1];

        results_.value = solver->valueAt(x, y, 0.0);
    }
}
]]></document_content>
  </document>
  <document index="330">
    <source>finitedifferences/fdsimpleextoujumpswingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoujumpswingengine.hpp
    \brief Finite Differences engine for simple swing options
*/

#ifndef quantlib_fd_simple_ext_ou_jump_swing_engine_hpp
#define quantlib_fd_simple_ext_ou_jump_swing_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>

namespace QuantLib {

    //! Finite-Differences engine for simple swing options

    class YieldTermStructure;
    class ExtOUWithJumpsProcess;

    class FdSimpleExtOUJumpSwingEngine
        : public GenericEngine<VanillaSwingOption::arguments,
                               VanillaSwingOption::results> {
      public:
        typedef FdmExtOUJumpModelInnerValue::Shape Shape;

        FdSimpleExtOUJumpSwingEngine(
            ext::shared_ptr<ExtOUWithJumpsProcess> p,
            ext::shared_ptr<YieldTermStructure> rTS,
            Size tGrid = 50,
            Size xGrid = 200,
            Size yGrid = 50,
            ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const ext::shared_ptr<Shape> shape_;
        const Size tGrid_, xGrid_, yGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="331">
    <source>finitedifferences/fdsimpleextoustorageengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 Copyright (C) 2014 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoustorageengine.cpp
    \brief Finite Differences extended OU engine for simple storage options
*/

#include <ql/experimental/finitedifferences/fdmexpextouinnervaluecalculator.hpp>
#include <ql/experimental/finitedifferences/fdmsimple2dextousolver.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoustorageengine.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/math/comparison.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimplestoragecondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/fdsimplebsswingengine.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        class FdmStorageValue : public FdmInnerValueCalculator {
          public:
            explicit FdmStorageValue(ext::shared_ptr<FdmMesher> mesher)
            : mesher_(std::move(mesher)) {}

            Real innerValue(const FdmLinearOpIterator& iter, Time) override {
                const Real s = std::exp(mesher_->location(iter, 0));
                const Real v = mesher_->location(iter, 1);
                return s*v;
            }
            Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
                return innerValue(iter, t);
            }

          private:
            const ext::shared_ptr<FdmMesher> mesher_;

        };

        class LessButNotCloseEnough {
          public:
            bool operator()(Real a, Real b) const {
                return !(close_enough(a, b, 100) || b < a);
            }
        };
    }

    FdSimpleExtOUStorageEngine::FdSimpleExtOUStorageEngine(
        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process,
        ext::shared_ptr<YieldTermStructure> rTS,
        Size tGrid,
        Size xGrid,
        Size yGrid,
        ext::shared_ptr<Shape> shape,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), rTS_(std::move(rTS)), tGrid_(tGrid), xGrid_(xGrid),
      yGrid_(yGrid), shape_(std::move(shape)), schemeDesc_(schemeDesc) {}

    void FdSimpleExtOUStorageEngine::calculate() const {

        // 1. Exercise
        QL_REQUIRE(arguments_.exercise->type() == Exercise::Bermudan,
                   "Bermudan exercise supported only");

        // 2. Mesher
        const Time maturity
            = rTS_->dayCounter().yearFraction(rTS_->referenceDate(),
                                              arguments_.exercise->lastDate());

        const ext::shared_ptr<Fdm1dMesher> xMesher(
                     new FdmSimpleProcess1dMesher(xGrid_, process_, maturity));

        ext::shared_ptr<Fdm1dMesher> storageMesher;

        if(yGrid_ == Null<Size>()){
            //elevator mesher
            std::vector<Real> storageValues(1, arguments_.capacity);
            storageValues.reserve(
                Size(arguments_.capacity/arguments_.changeRate)+1);

            for (Real level=0; level <= arguments_.capacity;
                    level+=arguments_.changeRate) {
                    storageValues.push_back(level);
                    storageValues.push_back(arguments_.capacity - level);
            }

            const std::set<Real, LessButNotCloseEnough>    orderedValues(
                storageValues.begin(), storageValues.end());
            storageValues.assign(orderedValues.begin(), orderedValues.end());

            storageMesher =    ext::shared_ptr<Fdm1dMesher>(
                new Predefined1dMesher(storageValues));
        }
        else {
            // uniform mesher
            storageMesher = ext::shared_ptr<Fdm1dMesher>(
                new Uniform1dMesher(0, arguments_.capacity, yGrid_));
        }

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(xMesher, storageMesher));

        // 3. Calculator
        ext::shared_ptr<FdmInnerValueCalculator> storageCalculator(
                                                  new FdmStorageValue(mesher));

        // 4. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        // 4.1 Bermudan step conditions
        std::vector<Time> exerciseTimes;
        for (auto i : arguments_.exercise->dates()) {
            const Time t = rTS_->dayCounter().yearFraction(rTS_->referenceDate(), i);

            QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
            exerciseTimes.push_back(t);
        }
        stoppingTimes.push_back(exerciseTimes);

        ext::shared_ptr<Payoff> payoff(
                                    new PlainVanillaPayoff(Option::Call, 0.0));

        ext::shared_ptr<FdmInnerValueCalculator> underlyingCalculator(
            new FdmExpExtOUInnerValueCalculator(payoff, mesher, shape_));

        stepConditions.push_back(ext::shared_ptr<StepCondition<Array> >(
            new FdmSimpleStorageCondition(exerciseTimes,
                                          mesher, underlyingCalculator,
                                          arguments_.changeRate)));

        ext::shared_ptr<FdmStepConditionComposite> conditions(
                new FdmStepConditionComposite(stoppingTimes, stepConditions));

        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     storageCalculator, maturity, tGrid_, 0 };

        ext::shared_ptr<FdmSimple2dExtOUSolver> solver(
                new FdmSimple2dExtOUSolver(
                           Handle<ExtendedOrnsteinUhlenbeckProcess>(process_),
                           rTS_, solverDesc, schemeDesc_));

        const Real x = process_->x0();
        const Real y = arguments_.load;

        results_.value = solver->valueAt(x, y);
    }
}
]]></document_content>
  </document>
  <document index="332">
    <source>finitedifferences/fdsimpleextoustorageengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 Copyright (C) 2014 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoustorageengine.hpp
    \brief Finite Differences extended OU engine for simple storage options
*/

#ifndef quantlib_fd_simple_ext_ou_storage_engine_hpp
#define quantlib_fd_simple_ext_ou_storage_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillastorageoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class ExtendedOrnsteinUhlenbeckProcess;
    class YieldTermStructure;

    class FdSimpleExtOUStorageEngine
        : public GenericEngine<VanillaStorageOption::arguments,
                               VanillaStorageOption::results> {
      public:
        typedef std::vector<std::pair<Time, Real> > Shape;


        FdSimpleExtOUStorageEngine(ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> p,
                                   ext::shared_ptr<YieldTermStructure> rTS,
                                   Size tGrid = 50,
                                   Size xGrid = 100,
                                   Size yGrid = Null<Size>(),
                                   ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
                                   const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const Size tGrid_, xGrid_, yGrid_;
        const ext::shared_ptr<Shape> shape_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="333">
    <source>finitedifferences/fdsimpleklugeextouvppengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleklugeouvppengine.cpp
    \brief Finite Differences engine for simple vpp options
*/


#include <ql/experimental/finitedifferences/fdmexpextouinnervaluecalculator.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextousolver.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepconditionfactory.hpp>
#include <ql/experimental/finitedifferences/fdsimpleklugeextouvppengine.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <list>
#include <utility>

namespace QuantLib {

    namespace {
        class FdmSparkSpreadInnerValue : public FdmInnerValueCalculator {

          public:
            FdmSparkSpreadInnerValue(ext::shared_ptr<BasketPayoff> basketPayoff,
                                     ext::shared_ptr<FdmInnerValueCalculator> fuelPrice,
                                     ext::shared_ptr<FdmInnerValueCalculator> powerPrice)
            : basketPayoff_(std::move(basketPayoff)), fuelPrice_(std::move(fuelPrice)),
              powerPrice_(std::move(powerPrice)) {}

            Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
                Array s(2);
                s[0] = powerPrice_->innerValue(iter, t);
                s[1] = fuelPrice_->innerValue(iter, t);

                return (*basketPayoff_)(s);
            }
            Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
                return innerValue(iter, t);
            }

          private:
            const ext::shared_ptr<BasketPayoff> basketPayoff_;
            const ext::shared_ptr<FdmInnerValueCalculator> fuelPrice_;
            const ext::shared_ptr<FdmInnerValueCalculator> powerPrice_;
        };
    }


    FdSimpleKlugeExtOUVPPEngine::FdSimpleKlugeExtOUVPPEngine(
        ext::shared_ptr<KlugeExtOUProcess> process,
        ext::shared_ptr<YieldTermStructure> rTS,
        ext::shared_ptr<Shape> fuelShape,
        ext::shared_ptr<Shape> powerShape,
        Real fuelCostAddon,
        Size tGrid,
        Size xGrid,
        Size yGrid,
        Size gGrid,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), rTS_(std::move(rTS)), fuelCostAddon_(fuelCostAddon),
      fuelShape_(std::move(fuelShape)), powerShape_(std::move(powerShape)), tGrid_(tGrid),
      xGrid_(xGrid), yGrid_(yGrid), gGrid_(gGrid), schemeDesc_(schemeDesc) {}

    void FdSimpleKlugeExtOUVPPEngine::calculate() const {

        ext::shared_ptr<SwingExercise> swingExercise(
            ext::dynamic_pointer_cast<SwingExercise>(arguments_.exercise));

        QL_REQUIRE(swingExercise, "Swing exercise supported only");

        const FdmVPPStepConditionFactory stepConditionFactory(arguments_);

        // 1. Exercise definition
        const std::vector<Time> exerciseTimes
            = swingExercise->exerciseTimes(rTS_->dayCounter(),
                                           rTS_->referenceDate());

        // 2. mesher set-up
        const Time maturity = exerciseTimes.back();
        const ext::shared_ptr<ExtOUWithJumpsProcess> klugeProcess
            = process_->getKlugeProcess();

        const ext::shared_ptr<StochasticProcess1D> klugeOUProcess
            = klugeProcess->getExtendedOrnsteinUhlenbeckProcess();

        const ext::shared_ptr<Fdm1dMesher> xMesher(
            new FdmSimpleProcess1dMesher(xGrid_, klugeOUProcess, maturity));

        const ext::shared_ptr<Fdm1dMesher> yMesher(
            new ExponentialJump1dMesher(yGrid_,
                                        klugeProcess->beta(),
                                        klugeProcess->jumpIntensity(),
                                        klugeProcess->eta(), 1e-3));

        const ext::shared_ptr<Fdm1dMesher> gMesher(
            new FdmSimpleProcess1dMesher(gGrid_,
                                         process_->getExtOUProcess(),maturity));

        const ext::shared_ptr<Fdm1dMesher> exerciseMesher(
            stepConditionFactory.stateMesher());

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(xMesher, yMesher, gMesher, exerciseMesher));

        // 3. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> zeroInnerValue(
            new FdmZeroInnerValue());

        const ext::shared_ptr<Payoff> zeroStrikeCall(
            new PlainVanillaPayoff(Option::Call, 0.0));

        const ext::shared_ptr<FdmInnerValueCalculator> fuelPrice(
            new FdmExpExtOUInnerValueCalculator(zeroStrikeCall,
                                                mesher, fuelShape_, 2));

        const ext::shared_ptr<FdmInnerValueCalculator> powerPrice(
            new FdmExtOUJumpModelInnerValue(zeroStrikeCall,mesher,powerShape_));

        const ext::shared_ptr<FdmInnerValueCalculator> sparkSpread(
            new FdmSparkSpreadInnerValue(
                ext::dynamic_pointer_cast<BasketPayoff>(arguments_.payoff),
                fuelPrice, powerPrice));

        // 4. Step conditions
        std::list<std::vector<Time> > stoppingTimes;
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;

        // 4.1 Bermudan step conditions
        stoppingTimes.push_back(exerciseTimes);
        const FdmVPPStepConditionMesher mesh = {3U, mesher};

        const ext::shared_ptr<FdmVPPStepCondition> stepCondition(
            stepConditionFactory.build(mesh, fuelCostAddon_,
                                       fuelPrice, sparkSpread));

        stepConditions.push_back(stepCondition);

        const ext::shared_ptr<FdmStepConditionComposite> conditions(
            new FdmStepConditionComposite(stoppingTimes, stepConditions));

        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. set-up solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     zeroInnerValue, maturity, tGrid_, 0 };

        const ext::shared_ptr<FdmKlugeExtOUSolver<4> > solver(
            new FdmKlugeExtOUSolver<4>(Handle<KlugeExtOUProcess>(process_),
                                       rTS_, solverDesc, schemeDesc_));

        std::vector<Real> x(4);
        x[0] = process_->initialValues()[0];
        x[1] = process_->initialValues()[1];
        x[2] = process_->initialValues()[2];
        
        const Real tol = 1e-8;
        const Real maxExerciseValue = exerciseMesher->locations().back();
        const Real minExerciseValue = exerciseMesher->locations().front();

        Array results(exerciseMesher->size());
        for (Size i=0; i < results.size(); ++i) {

            x[3] = std::max(minExerciseValue + tol,
                            std::min(exerciseMesher->location(i),
                                     maxExerciseValue - tol));
            results[i] = solver->valueAt(x);
        }
        results_.value = stepCondition->maxValue(results);
    }
}
]]></document_content>
  </document>
  <document index="334">
    <source>finitedifferences/fdsimpleklugeextouvppengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoujumpswingengine.hpp
    \brief Finite Differences engine for simple vpp options
*/

#ifndef quantlib_fd_simple_kluge_ou_vpp_engine_hpp
#define quantlib_fd_simple_kluge_ou_vpp_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>

namespace QuantLib {

    //! Finite-Differences engine for simple vpp options

    class YieldTermStructure;
    class KlugeExtOUProcess;

    class FdSimpleKlugeExtOUVPPEngine
        : public GenericEngine<VanillaVPPOption::arguments,
                               VanillaVPPOption::results> {
      public:
        typedef FdmExtOUJumpModelInnerValue::Shape Shape;

        FdSimpleKlugeExtOUVPPEngine(ext::shared_ptr<KlugeExtOUProcess> process,
                                    ext::shared_ptr<YieldTermStructure> rTS,
                                    ext::shared_ptr<Shape> fuelShape,
                                    ext::shared_ptr<Shape> powerShape,
                                    Real fuelCostAddon,
                                    Size tGrid = 1,
                                    Size xGrid = 50,
                                    Size yGrid = 10,
                                    Size gGrid = 20,
                                    const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const ext::shared_ptr<KlugeExtOUProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const Real fuelCostAddon_;
        const ext::shared_ptr<Shape> fuelShape_;
        const ext::shared_ptr<Shape> powerShape_;
        const Size tGrid_, xGrid_, yGrid_, gGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="335">
    <source>finitedifferences/glued1dmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file glued1dmesher.cpp
    \brief One-dimensional grid mesher combining two existing ones
*/

#include <ql/experimental/finitedifferences/glued1dmesher.hpp>
#include <ql/errors.hpp>
#include <ql/math/comparison.hpp>
#include <ql/utilities/null.hpp>

namespace QuantLib {

    Glued1dMesher::Glued1dMesher(
        const Fdm1dMesher& leftMesher,
        const Fdm1dMesher& rightMesher)
    : Fdm1dMesher(leftMesher.locations().size()+rightMesher.locations().size()
                  - ( close(leftMesher.locations().back(),
                      rightMesher.locations().front()) ? 1 :0) ),
      commonPoint_( close(leftMesher.locations().back(),
                    rightMesher.locations().front()) ) {

        QL_REQUIRE(leftMesher.locations().back()
                    <= rightMesher.locations().front(),
            "left meshers rightmost point (" <<
            leftMesher.locations().back() <<
            ") may not be greater than right meshers leftmost point (" <<
            rightMesher.locations().front() << ")");

        std::copy(leftMesher.locations().begin(),leftMesher.locations().end(),
                  locations_.begin());
        std::copy(rightMesher.locations().begin() + (commonPoint_ ? 1 : 0),
                  rightMesher.locations().end(),
                  locations_.begin()+leftMesher.locations().size());

        for (Size i=0; i < locations_.size()-1; ++i) {
            dplus_[i] = dminus_[i+1] = locations_[i+1] - locations_[i];
        }
        dplus_.back() = dminus_.front() = Null<Real>();
    }
}
]]></document_content>
  </document>
  <document index="336">
    <source>finitedifferences/glued1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file glued1dmesher.hpp
    \brief One-dimensional grid mesher combining two existing ones
*/

#ifndef quantlib_glued_1d_mesher_hpp
#define quantlib_glued_1d_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>

namespace QuantLib {

    class Glued1dMesher : public Fdm1dMesher {
      public:
        Glued1dMesher(
            const Fdm1dMesher& leftMesher,
            const Fdm1dMesher& rightMesher);
      private:
          const bool commonPoint_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="337">
    <source>finitedifferences/modtriplebandlinearop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file modtriplebandlinearop.hpp
    \brief modifiable triple band linear operator
*/

#ifndef quantlib_mod_triple_band_linear_op_hpp
#define quantlib_mod_triple_band_linear_op_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>

namespace QuantLib {

    class ModTripleBandLinearOp : public TripleBandLinearOp {
      public:
        ModTripleBandLinearOp(Size direction,
                              const ext::shared_ptr<FdmMesher>& mesher)
        : TripleBandLinearOp(direction, mesher) { }

        explicit ModTripleBandLinearOp(const TripleBandLinearOp& m)
        : TripleBandLinearOp(m) { }

        Real lower(Size i) const { return lower_[i]; }
        Real& lower(Size i) { return lower_[i]; }
        Real diag(Size i) const { return diag_[i]; }
        Real& diag(Size i) { return diag_[i]; }
        Real upper(Size i) const { return upper_[i]; }
        Real& upper(Size i) { return upper_[i]; }
    };
}

#endif
]]></document_content>
  </document>
  <document index="338">
    <source>finitedifferences/vanillavppoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillavppoption.cpp
*/


#include <ql/event.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>

namespace QuantLib {
    namespace {

        class IdenticalPayoff : public Payoff {
          public:
            std::string name() const override { return "IdenticalPayoff"; }
            std::string description() const override { return name(); }
            Real operator()(Real price) const override { return price; }
        };
    }

    VanillaVPPOption::VanillaVPPOption(
        Real heatRate,
        Real pMin, Real pMax,
        Size tMinUp, Size tMinDown,
        Real startUpFuel, Real startUpFixCost,
        const ext::shared_ptr<SwingExercise>& exercise,
        Size nStarts, Size nRunningHours)
    : MultiAssetOption(ext::shared_ptr<Payoff>(), exercise),
      heatRate_(heatRate),
      pMin_(pMin), pMax_(pMax),
      tMinUp_(tMinUp), tMinDown_(tMinDown),
      startUpFuel_(startUpFuel),
      startUpFixCost_(startUpFixCost),
      nStarts_(nStarts),
      nRunningHours_(nRunningHours) {
        Array weigths(2);
        weigths[0] = 1.0; weigths[1] = -heatRate;

        payoff_ = ext::shared_ptr<Payoff>(new AverageBasketPayoff(
            ext::shared_ptr<Payoff>(new IdenticalPayoff()), weigths));
    }

    void VanillaVPPOption::arguments::validate() const {
        QL_REQUIRE(exercise, "no exercise given");
        QL_REQUIRE(nStarts == Null<Size>() || nRunningHours == Null<Size>(),
                "either a start limit or fuel limit is supported");
    }

    void VanillaVPPOption::setupArguments(
                                PricingEngine::arguments* args) const {

        MultiAssetOption::setupArguments(args);

        auto* arguments = dynamic_cast<VanillaVPPOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->heatRate       = heatRate_;
        arguments->pMin           = pMin_;
        arguments->pMax           = pMax_;
        arguments->tMinUp         = tMinUp_;
        arguments->tMinDown       = tMinDown_;
        arguments->startUpFuel    = startUpFuel_;
        arguments->startUpFixCost = startUpFixCost_;
        arguments->nStarts        = nStarts_;
        arguments->nRunningHours  = nRunningHours_;
    }

    bool VanillaVPPOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }
}

]]></document_content>
  </document>
  <document index="339">
    <source>finitedifferences/vanillavppoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillavppoption.hpp
    \brief vanilla virtual power plant option
*/

#ifndef quantlib_vanilla_vpp_option_hpp
#define quantlib_vanilla_vpp_option_hpp

#include <ql/instruments/multiassetoption.hpp>

namespace QuantLib {
    class BasketPayoff;
    class SwingExercise;

    class VanillaVPPOption : public MultiAssetOption {
      public:
        class arguments;
        VanillaVPPOption(Real heatRate,
                         Real pMin, Real pMax,
                         Size tMinUp, Size tMinDown,
                         Real startUpFuel, Real startUpFixCost,
                         const ext::shared_ptr<SwingExercise>& exercise,
                         Size nStarts = Null<Size>(),
                         Size nRunningHours = Null<Size>());

        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        const Real heatRate_;
        const Real pMin_, pMax_;
        const Size tMinUp_, tMinDown_;
        const Real startUpFuel_, startUpFixCost_;
        const Size nStarts_, nRunningHours_;
    };

    class VanillaVPPOption::arguments
        : public virtual MultiAssetOption::arguments {
      public:
        arguments() = default;
        void validate() const override;

        Real heatRate;
        Real pMin, pMax;
        Size tMinUp, tMinDown;
        Real startUpFuel, startUpFixCost;
        Size nStarts, nRunningHours;
    };
}

#endif
]]></document_content>
  </document>
  <document index="340">
    <source>forward/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    analytichestonforwardeuropeanengine.hpp

cpp_files = \
    analytichestonforwardeuropeanengine.cpp

if UNITY_BUILD

nodist_libForward_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libForward_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libForward.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="341">
    <source>forward/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/forward/analytichestonforwardeuropeanengine.hpp>

]]></document_content>
  </document>
  <document index="342">
    <source>forward/analytichestonforwardeuropeanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/forward/analytichestonforwardeuropeanengine.hpp>
#include <utility>

namespace QuantLib {


    class P12Integrand {
      private:
        ext::shared_ptr<AnalyticHestonEngine>& engine_;
        Real logK_, phiRightLimit_;
        Time tenor_;
        std::complex<Real> i_, adj_;
      public:
        P12Integrand(ext::shared_ptr<AnalyticHestonEngine>& engine,
                     Real logK,
                     Time tenor,
                     bool P1, // true for P1, false for P2
                     Real phiRightLimit = 100) : engine_(engine), logK_(logK),
            phiRightLimit_(phiRightLimit), tenor_(tenor), i_(std::complex<Real>(0.0, 1.0)) {

            // Only difference between P1 and P2 integral is the additional term in the chF evaluation
            if (P1) {
                adj_ = std::complex<Real>(0.0, -1.0);
            } else {
                adj_ = std::complex<Real>(0.0, 0.0);
            }
        }

        // QL Gaussian Quadrature - map phi from [-1 to 1] to {0, phiRightLimit] 
        double operator()(double phi) const {
            double phiDash = (0.5+1e-8+0.5*phi) * phiRightLimit_; // Map phi to full range
            return 0.5*phiRightLimit_*std::real((std::exp(-phiDash*logK_*i_) / (phiDash*i_)) * engine_->chF(phiDash+adj_, tenor_));
        }
    };


    class P12HatIntegrand {
      private:
        Time tenor_, resetTime_;
        Handle<Quote>& s0_;
        bool P1_;
        Real logK_, phiRightLimit_, nuRightLimit_;
        const AnalyticHestonForwardEuropeanEngine* const parent_;
        GaussLegendreIntegration innerIntegrator_;
      public:
        P12HatIntegrand(Time tenor,
                        Time resetTime,
                        Handle<Quote>& s0,
                        Real logK,
                        bool P1, // true for P1, false for P2
                        const AnalyticHestonForwardEuropeanEngine* const parent,
                        Real phiRightLimit,
                        Real nuRightLimit) : tenor_(tenor), resetTime_(resetTime),
            s0_(s0), P1_(P1), logK_(logK), phiRightLimit_(phiRightLimit),
            nuRightLimit_(nuRightLimit), parent_(parent), innerIntegrator_(128) {}
        double operator()(double nu) const {

            // Rescale nu to [-1, 1]
            Real nuDash = nuRightLimit_ * (0.5 * nu + 0.5 + 1e-8);

            // Calculate the chF from var(t) to expiry
            ext::shared_ptr<AnalyticHestonEngine> engine = parent_->forwardChF(s0_, nuDash);
            P12Integrand pIntegrand(engine, logK_, tenor_, P1_, phiRightLimit_);
            Real p1Integral = innerIntegrator_(pIntegrand);

            // Calculate the value of the propagator to nu
            Real propagator = parent_->propagator(resetTime_, nuDash);

            // Take the product, and scale integral's value back up to [0, right_lim]
            return propagator * (0.5 + p1Integral/M_PI);
        }
    };


    AnalyticHestonForwardEuropeanEngine::AnalyticHestonForwardEuropeanEngine(
        ext::shared_ptr<HestonProcess> process, Size integrationOrder)
    : process_(std::move(process)), integrationOrder_(integrationOrder), outerIntegrator_(128) {

        v0_ = process_->v0();
        rho_ = process_->rho();
        kappa_ = process_->kappa();
        theta_ = process_->theta();
        sigma_ = process_->sigma();
        s0_ = process_->s0();

        QL_REQUIRE(sigma_ > 0.1,
                   "Very low values (<~10%) for Heston Vol-of-Vol cause numerical issues" \
                   "in this implementation of the propagator function, try using" \
                   "MCForwardEuropeanHestonEngine Monte-Carlo engine instead");

        riskFreeRate_ = process_->riskFreeRate();
        dividendYield_ = process_->dividendYield();

        // Some of the required constant intermediate variables can be calculated now
        kappaHat_ = kappa_ - rho_ * sigma_;
        thetaHat_ = kappa_ * theta_ / kappaHat_;
        R_ = 4 * kappaHat_ * thetaHat_ / (sigma_ * sigma_);
    }


    void AnalyticHestonForwardEuropeanEngine::calculate() const {
        // This is a european option pricer
        QL_REQUIRE(this->arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        // We only price plain vanillas
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(this->arguments_.payoff);
        QL_REQUIRE(payoff, "non plain vanilla payoff given");

        Time resetTime = this->process_->time(this->arguments_.resetDate);
        Time expiryTime = this->process_->time(this->arguments_.exercise->lastDate());
        Time tenor = expiryTime - resetTime;
        Real moneyness = this->arguments_.moneyness;

        // K needs to be scaled to forward AT RESET TIME, not spot...
        Real expiryDcf = riskFreeRate_->discount(expiryTime);
        Real resetDcf = riskFreeRate_->discount(resetTime);
        Real expiryDividendDiscount = dividendYield_->discount(expiryTime);
        Real resetDividendDiscount = dividendYield_->discount(resetTime);
        Real expiryRatio = expiryDcf / expiryDividendDiscount;
        Real resetRatio = resetDcf / resetDividendDiscount;

        QL_REQUIRE(resetTime >= 0.0, "Reset Date cannot be in the past");
        QL_REQUIRE(expiryTime >= 0.0, "Expiry Date cannot be in the past");

        // Use some heuristics to decide upon phiRightLimit and nuRightLimit
        Real phiRightLimit = 100.0;
        Real nuRightLimit = std::max(2.0, 10.0 * (1+std::max(0.0, rho_)) * sigma_ * std::sqrt(resetTime * std::max(v0_, theta_)));

        // do the 2D integral calculation. For very short times, we just fall back on the standard
        // calculation, both for accuracy and because tStar==0 causes some numerical issues...
        std::pair<Real, Real> P1HatP2Hat;
        if (resetTime <= 1e-3) {
            Handle<Quote> tempQuote(ext::shared_ptr<Quote>(new SimpleQuote(s0_->value())));
            P1HatP2Hat = calculateP1P2(tenor, tempQuote, moneyness * s0_->value(), expiryRatio, phiRightLimit);
        } else {
            P1HatP2Hat = calculateP1P2Hat(tenor, resetTime, moneyness, expiryRatio/resetRatio, phiRightLimit, nuRightLimit);
        }

        // Apply the payoff functions
        Real value = 0.0;
        Real F = s0_->value() / expiryRatio;
        switch (payoff->optionType()){
            case Option::Call:
                value = expiryDcf * (F*P1HatP2Hat.first - moneyness*s0_->value()*P1HatP2Hat.second/resetRatio);
                break;
            case Option::Put:
                value = expiryDcf * (moneyness*s0_->value()*(1-P1HatP2Hat.second)/resetRatio - F*(1-P1HatP2Hat.first));
                break;
            default:
                QL_FAIL("unknown option type");
            }

        results_.value = value;

        results_.additionalResults["dcf"] = expiryDcf;
        results_.additionalResults["qf"] = expiryDividendDiscount;
        results_.additionalResults["expiryRatio"] = expiryRatio;
        results_.additionalResults["resetRatio"] = resetRatio;
        results_.additionalResults["moneyness"] = moneyness;
        results_.additionalResults["s0"] = s0_->value();
        results_.additionalResults["fwd"] = F;
        results_.additionalResults["resetTime"] = resetTime;
        results_.additionalResults["expiryTime"] = expiryTime;
        results_.additionalResults["P1Hat"] = P1HatP2Hat.first;
        results_.additionalResults["P2Hat"] = P1HatP2Hat.second;
        results_.additionalResults["phiRightLimit"] = phiRightLimit;
        results_.additionalResults["nuRightLimit"] = nuRightLimit;
    }


    std::pair<Real, Real> AnalyticHestonForwardEuropeanEngine::calculateP1P2Hat(Time tenor,
                                                                                Time resetTime,
                                                                                Real moneyness,
                                                                                Real ratio,
                                                                                Real phiRightLimit,
                                                                                Real nuRightLimit) const {

        Handle<Quote> unitQuote(ext::shared_ptr<Quote>(new SimpleQuote(1.0)));

        // Re-expressing moneyness in terms of the forward here (strike fixes to spot, but in
        // our pricing calculation we need to compare it to the future at expiry)
        Real logMoneyness = std::log(moneyness*ratio);

        P12HatIntegrand p1HatIntegrand(tenor, resetTime, unitQuote, logMoneyness, true, this, phiRightLimit, nuRightLimit);
        P12HatIntegrand p2HatIntegrand(tenor, resetTime, unitQuote, logMoneyness, false, this, phiRightLimit, nuRightLimit);

        Real p1HatIntegral = 0.5 * nuRightLimit * outerIntegrator_(p1HatIntegrand);
        Real p2HatIntegral = 0.5 * nuRightLimit * outerIntegrator_(p2HatIntegrand);

        std::pair<Real, Real> P1HatP2Hat(p1HatIntegral, p2HatIntegral);

        return P1HatP2Hat;
    }


    Real AnalyticHestonForwardEuropeanEngine::propagator(Time resetTime,
                                                         Real varReset) const {
        Real B, Lambda, term1, term2, term3;

        B = 4 * kappaHat_ / (sigma_ * sigma_ * (1 - std::exp(-kappaHat_ * resetTime)));
        Lambda = B * std::exp(-kappaHat_ * resetTime) * v0_;

        // Now construct equation (18) from the paper term-by-term
        term1 = std::exp(-0.5*(B * varReset + Lambda)) * B / 2;
        term2 = std::pow(B * varReset / Lambda, 0.5*(R_/2 - 1));
        term3 = modifiedBesselFunction_i(R_/2 - 1,std::sqrt(Lambda * B * varReset));

        return term1 * term2 * term3;
    }

    ext::shared_ptr<AnalyticHestonEngine> AnalyticHestonForwardEuropeanEngine::forwardChF(
                                      Handle<Quote>& spotReset,
                                      Real varReset) const {

        // Probably a wasteful implementation here, could be improved by importing
        // only the CF-generating parts of the AnalyticHestonEngine (currently private)
        ext::shared_ptr<HestonProcess> hestonProcess(new
            HestonProcess(riskFreeRate_, dividendYield_, spotReset,
                varReset, kappa_, theta_, sigma_, rho_));

        ext::shared_ptr<HestonModel> hestonModel(new HestonModel(hestonProcess));

        ext::shared_ptr<AnalyticHestonEngine> analyticHestonEngine(
            new AnalyticHestonEngine(hestonModel, integrationOrder_));

        // Not sure how to pass only the chF, so just pass the whole thing for now!
        return analyticHestonEngine;
    }


    std::pair<Real, Real> AnalyticHestonForwardEuropeanEngine::calculateP1P2(Time tenor,
                                                                             Handle<Quote>& St,
                                                                             Real K,
                                                                             Real ratio,
                                                                             Real phiRightLimit) const {

        ext::shared_ptr<AnalyticHestonEngine> engine = forwardChF(St, v0_);
        Real logK = std::log(K*ratio/St->value());

        // Integrate the CF and the complex integrand over positive phi
        GaussLegendreIntegration integrator = GaussLegendreIntegration(128);
        P12Integrand p1Integrand(engine, logK, tenor, true, phiRightLimit);
        P12Integrand p2Integrand(engine, logK, tenor, false, phiRightLimit);

        Real p1Integral = integrator(p1Integrand);
        Real p2Integral = integrator(p2Integrand);

        std::pair<Real, Real> P1P2(0.5 + p1Integral/M_PI, 0.5 + p2Integral/M_PI);

        return P1P2;
    }
}
]]></document_content>
  </document>
  <document index="343">
    <source>forward/analytichestonforwardeuropeanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytichestonforwardeuropeanengine.hpp
    \brief analytic heston engine for forward-starting european options
*/

#ifndef quantlib_analytic_heston_forward_european_engine_hpp
#define quantlib_analytic_heston_forward_european_engine_hpp

#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/math/modifiedbessel.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/exercise.hpp>
#include <ql/quotes/simplequote.hpp>

namespace QuantLib {

    //! Analytic Heston engine incl. stochastic interest rates
    /*! This class is pricing a european option under the following process

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d) S dt +\sqrt{v} S dW_1 \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dW_1 dW_2 &=& \rho dt \\
        \end{array}
        \f]

        References:

        Implements the analytical solution for forward-starting 
        strike-reset options descriped in "On the Pricing of Forward 
        Starting Options under Stochastic Volatility", S. Kruse (2003)

        \ingroup forwardengines

        \test
        - For tReset > 0, price from the analytic pricer is compared
          to the MC priver for calls/puts at various moneynesses
        - For tReset ~ 0, price from the analytic pricer is compared
          to the Heston analytic vanilla pricer for various options
    */

    class AnalyticHestonForwardEuropeanEngine : public GenericEngine<ForwardOptionArguments<VanillaOption::arguments>,
                                                       VanillaOption::results> {
      public:
        explicit AnalyticHestonForwardEuropeanEngine(ext::shared_ptr<HestonProcess> process,
                                                     Size integrationOrder = 144);

        void calculate() const override;

        // The evolution probability function from t0 to tReset
        Real propagator(Time resetTime,
                        Real varReset) const;

        // Forward characteristic function for given (t, vt, St)
        ext::shared_ptr<AnalyticHestonEngine> forwardChF(
                                            Handle<Quote>& spotReset,
                                            Real varReset) const;

      private:
        // Parameters for the internal chF generators
        ext::shared_ptr<HestonProcess> process_;
        Size integrationOrder_;

        // Initial process params
        Real v0_, rho_, kappa_, theta_, sigma_;
        Handle<YieldTermStructure> dividendYield_;
        Handle<YieldTermStructure> riskFreeRate_;
        Handle<Quote> s0_;

        // Some intermediate calculation constant parameters
        Real kappaHat_, thetaHat_, R_;

        // The integrator for nu. This pricer needs to perform nested integrations, the outer
        // integrator should be non-adaptive as this can cause very long runtimes. Gaussian
        // Quadrature has been found to work well.
        GaussLegendreIntegration outerIntegrator_;

        // Integrate over characteristic function to generate P1, P2 (fall back on this
        // when reset time is very close, to avoid numerical issues with tReset=0s)
        std::pair<Real, Real> calculateP1P2(Time t,
                                            Handle<Quote>& St,
                                            Real K,
                                            Real ratio,
                                            Real phiRightLimit = 100) const;

        // Integrate P1, P2 over te propagator function to calculate forward-start price
        std::pair<Real, Real> calculateP1P2Hat(Time tenor,
                                               Time resetTime,
                                               Real K,
                                               Real ratio,
                                               Real phiRightLimit = 100,
                                               Real nuRightLimit = 2.0) const;

    };
}

#endif
]]></document_content>
  </document>
  <document index="344">
    <source>fx/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    blackdeltacalculator.hpp \
    deltavolquote.hpp

cpp_files = \
    blackdeltacalculator.cpp \
    deltavolquote.cpp

if UNITY_BUILD

nodist_libFX_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libFX_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libFX.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="345">
    <source>fx/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/fx/blackdeltacalculator.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>

]]></document_content>
  </document>
  <document index="346">
    <source>fx/blackdeltacalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/fx/blackdeltacalculator.hpp>

namespace QuantLib {

    BlackDeltaCalculator::BlackDeltaCalculator(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev):
    dt_(dt), ot_(ot),
    dDiscount_(dDiscount), fDiscount_(fDiscount),
    stdDev_(stdDev), spot_(spot),
    forward_(spot*fDiscount/dDiscount), phi_(Integer(ot)) {

        QL_REQUIRE(spot_>0.0,
                   "positive spot value required: " <<
                   spot_ << " not allowed");
        QL_REQUIRE(dDiscount_>0.0,
                   "positive domestic discount factor required: " <<
                   dDiscount_ << " not allowed");
        QL_REQUIRE(fDiscount_>0.0,
                   "positive foreign discount factor required: " <<
                   fDiscount_ << " not allowed");
        QL_REQUIRE(stdDev_>=0.0,
                   "non-negative standard deviation required: "
                   << stdDev_ << " not allowed");

        fExpPos_    =forward_*std::exp(0.5*stdDev_*stdDev_);
        fExpNeg_    =forward_*std::exp(-0.5*stdDev_*stdDev_);
    }


    Real BlackDeltaCalculator::deltaFromStrike(Real strike) const {

        QL_REQUIRE(strike >=0.0,
                   "positive strike value required: " <<
                   strike << " not allowed");

        Real res=0.0;

        switch(dt_){
          case DeltaVolQuote::Spot:
            res=phi_*fDiscount_*cumD1(strike);
            break;

          case DeltaVolQuote::Fwd:
            res=phi_*cumD1(strike);
            break;

          case DeltaVolQuote::PaSpot:
            res=phi_*fDiscount_*cumD2(strike)*strike/forward_;
            break;

          case DeltaVolQuote::PaFwd:
            res=phi_*cumD2(strike)*strike/forward_;
            break;

          default:
            QL_FAIL("invalid delta type");
        }
        return res;
    }

    Real BlackDeltaCalculator::strikeFromDelta(Real delta) const {
        return(strikeFromDelta(delta, dt_));
    }

    Real BlackDeltaCalculator::strikeFromDelta(Real delta,
                                               DeltaVolQuote::DeltaType dt)
                                                                        const{
        Real res=0.0;
        Real arg=0.0;
        InverseCumulativeNormal f;

        QL_REQUIRE(delta*phi_>=0.0, "Option type and delta are incoherent.");

        switch (dt) {
          case DeltaVolQuote::Spot:
            QL_REQUIRE(std::fabs(delta)<=fDiscount_,
                       "Spot delta out of range.");

            arg=-phi_*f(phi_*delta/fDiscount_)*stdDev_+0.5*stdDev_*stdDev_;
            res=forward_*std::exp(arg);
            break;

          case DeltaVolQuote::Fwd:
            QL_REQUIRE(std::fabs(delta)<=1.0,
                       "Forward delta out of range.");

            arg=-phi_*f(phi_*delta)*stdDev_+0.5*stdDev_*stdDev_;
            res=forward_*std::exp(arg);
            break;

          case DeltaVolQuote::PaSpot:
          case DeltaVolQuote::PaFwd: {
              // This has to be solved numerically. One of the
              // problems is that the premium adjusted call delta is
              // not monotonic in strike, such that two solutions
              // might occur. The one right to the max of the delta is
              // considered to be the correct strike.  Some proper
              // interval bounds for the strike need to be chosen, the
              // numerics can otherwise be very unreliable and
              // unstable.  I've chosen Brent over Newton, since the
              // interval can be specified explicitly and we can not
              // run into the area on the left of the maximum.  The
              // put delta doesn't have this property and can be
              // solved without any problems, but also numerically.

              BlackDeltaPremiumAdjustedSolverClass f(
                       ot_, dt , spot_,dDiscount_, fDiscount_, stdDev_,delta);

              Brent solver;
              solver.setMaxEvaluations(1000);
              Real accuracy = 1.0e-10;

              Real rightLimit=0.0;
              Real leftLimit=0.0;

              // Strike of not premium adjusted is always to the right of premium adjusted
              if (dt==DeltaVolQuote::PaSpot) {
                  rightLimit=strikeFromDelta(delta, DeltaVolQuote::Spot);
              } else {
                  rightLimit=strikeFromDelta(delta, DeltaVolQuote::Fwd);
              }

              if (phi_<0) { // if put
                  res=solver.solve(f, accuracy, rightLimit, 0.0, spot_*100.0);
                  break;
              } else {

                  // find out the left limit which is the strike
                  // corresponding to the value where premium adjusted
                  // deltas have their maximum.

                  BlackDeltaPremiumAdjustedMaxStrikeClass g(
                               ot_,dt, spot_,dDiscount_, fDiscount_, stdDev_);

                  leftLimit=solver.solve(g, accuracy, rightLimit*0.5,
                                         0.0, rightLimit);

                  Real guess=leftLimit+(rightLimit-leftLimit)*0.5;

                  res=solver.solve(f, accuracy, guess, leftLimit, rightLimit);
              } // end if phi<0 else

              break;
          }

          default:
            QL_FAIL("invalid delta type");
        }

        return res;
    }

    Real BlackDeltaCalculator::atmStrike(DeltaVolQuote::AtmType atmT) const {

        Real res=0.0;

        switch(atmT) {
          case DeltaVolQuote::AtmSpot:
            res=spot_;
            break;

          case DeltaVolQuote::AtmDeltaNeutral:
            if(dt_==DeltaVolQuote::Spot || dt_==DeltaVolQuote::Fwd){
                res=fExpPos_;
            } else {
                res=fExpNeg_;
            }
            break;

          case DeltaVolQuote::AtmFwd:
            res=forward_;
            break;

          case DeltaVolQuote::AtmGammaMax: case DeltaVolQuote::AtmVegaMax:
            res=fExpPos_;
            break;

          case DeltaVolQuote::AtmPutCall50:
            QL_REQUIRE(dt_==DeltaVolQuote::Fwd,
                       "|PutDelta|=CallDelta=0.50 only possible for forward delta.");
            res=fExpPos_;
            break;

          default:
            QL_FAIL("invalid atm type");
        }

        return res;
    }


    Real BlackDeltaCalculator::cumD1(Real strike) const {

        Real d1_=0.0;
        Real cum_d1_pos_ = 1.0; // N(d1)
        Real cum_d1_neg_ = 0.0; // N(-d1)

        CumulativeNormalDistribution f;

        if (stdDev_>=QL_EPSILON) {
            if(strike>0) {
                d1_ = std::log(forward_/strike)/stdDev_ + 0.5*stdDev_;
                return f(phi_*d1_);
            }
        } else {
            if (forward_<strike) {
                cum_d1_pos_ = 0.0;
                cum_d1_neg_ = 1.0;
            } else if(forward_==strike){
                d1_ = 0.5*stdDev_;
                return f(phi_*d1_);
            }
        }

        if (phi_>0) { // if Call
            return cum_d1_pos_;
        } else {
            return cum_d1_neg_;
        }
    }


    Real BlackDeltaCalculator::nD1(Real strike) const {

        Real d1_=0.0;
        Real n_d1_ = 0.0; // n(d1)

        if (stdDev_>=QL_EPSILON){
            if(strike>0){
                d1_ = std::log(forward_/strike)/stdDev_ + 0.5*stdDev_;
                CumulativeNormalDistribution f;
                n_d1_ = f.derivative(d1_);
            }
        }

        return n_d1_;
    }


    Real BlackDeltaCalculator::cumD2(Real strike) const {

        Real d2_=0.0;
        Real cum_d2_pos_= 1.0;  // N(d2)
        Real cum_d2_neg_= 0.0;  // N(-d2)

        CumulativeNormalDistribution f;

        if (stdDev_>=QL_EPSILON){

            if(strike>0){
                d2_ = std::log(forward_/strike)/stdDev_ - 0.5*stdDev_;
                return f(phi_*d2_);
            }

        } else {

            if (forward_<strike) {
                cum_d2_pos_= 0.0;
                cum_d2_neg_= 1.0;
            } else if (forward_==strike) {
                d2_ = -0.5*stdDev_;
                return(f(phi_*d2_));
            }

        }

        if (phi_>0) { // if Call
            return cum_d2_pos_;
        } else {
            return cum_d2_neg_;
        }
    }


    Real BlackDeltaCalculator::nD2(Real strike) const {

        Real d2_=0.0;
        Real n_d2_= 0.0; // n(d2)

        if (stdDev_>=QL_EPSILON){
            if(strike>0){
                d2_ = std::log(forward_/strike)/stdDev_ - 0.5*stdDev_;
                CumulativeNormalDistribution f;
                n_d2_ = f.derivative(d2_);
            }
        }

        return n_d2_;
    }


    void BlackDeltaCalculator::setDeltaType(DeltaVolQuote::DeltaType dt){
        dt_=dt;
    }

    void BlackDeltaCalculator::setOptionType(Option::Type ot){
        ot_=ot;
        phi_=Integer(ot_);
    }


    // helper classes

    BlackDeltaPremiumAdjustedSolverClass::BlackDeltaPremiumAdjustedSolverClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev,
                        Real delta):
    bdc_(ot,dt,spot,dDiscount,fDiscount,stdDev), delta_(delta) {}


    Real BlackDeltaPremiumAdjustedSolverClass::operator()(Real strike) const {
        return bdc_.deltaFromStrike(strike)-delta_;
    }


    BlackDeltaPremiumAdjustedMaxStrikeClass::BlackDeltaPremiumAdjustedMaxStrikeClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev):
    bdc_(ot,dt,spot,dDiscount,fDiscount,stdDev), stdDev_(stdDev) {}

    Real BlackDeltaPremiumAdjustedMaxStrikeClass::operator()(Real strike) const {
        return bdc_.cumD2(strike)*stdDev_ - bdc_.nD2(strike);
    }

}
]]></document_content>
  </document>
  <document index="347">
    <source>fx/blackdeltacalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackdeltacalculator.hpp
    \brief Black-Scholes formula delta calculator class
*/

#ifndef quantlib_black_delta_calculator_hpp
#define quantlib_black_delta_calculator_hpp

#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>

namespace QuantLib {

    //! Black delta calculator class
    /*! Class includes many operations needed for different applications
        in FX markets, which has special quoation mechanisms, since
        every price can be expressed in both numeraires.
    */
    class BlackDeltaCalculator {
      public:
        // A parsimonious constructor is chosen, which for example
        // doesn't need a strike. The reason for this is, that we'd
        // like this class to calculate deltas for different strikes
        // many times, e.g. in a numerical routine, which will be the
        // case in the smile setup procedure.
        BlackDeltaCalculator(Option::Type ot,
                             DeltaVolQuote::DeltaType dt,
                             Real spot,
                             DiscountFactor dDiscount,   // domestic discount
                             DiscountFactor fDiscount,   // foreign discount
                             Real stdDev);

        // Give strike, receive delta according to specified type
        Real deltaFromStrike(Real strike) const;
        // Give delta according to specified type, receive strike
        Real strikeFromDelta(Real delta) const;

        Real cumD1(Real strike) const;    // N(d1) or N(-d1)
        Real cumD2(Real strike) const;    // N(d2) or N(-d2)

        Real nD1(Real strike) const;      // n(d1)
        Real nD2(Real strike) const;      // n(d2)

        void setDeltaType(DeltaVolQuote::DeltaType dt);
        void setOptionType(Option::Type ot);

        // The following function can be calculated without an explicit strike
        Real atmStrike(DeltaVolQuote::AtmType atmT) const;

      private:
        // alternative delta type
        Real strikeFromDelta(Real delta, DeltaVolQuote::DeltaType dt) const;


        DeltaVolQuote::DeltaType dt_;
        Option::Type ot_;
        DiscountFactor dDiscount_, fDiscount_;

        Real stdDev_, spot_, forward_;
        Integer phi_;
        Real fExpPos_,fExpNeg_;
    };


    class BlackDeltaPremiumAdjustedSolverClass {
      public:
        BlackDeltaPremiumAdjustedSolverClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev,
                        Real delta);

        Real operator()(Real strike) const;

      private:
        BlackDeltaCalculator bdc_;
        Real delta_;
    };


    class BlackDeltaPremiumAdjustedMaxStrikeClass {
      public:
        BlackDeltaPremiumAdjustedMaxStrikeClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev);

        Real operator()(Real strike) const;

      private:
        BlackDeltaCalculator bdc_;
        Real stdDev_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="348">
    <source>fx/deltavolquote.cpp</source>
    <document_content><![CDATA[/*/ -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/fx/deltavolquote.hpp>
#include <utility>

namespace QuantLib {

    DeltaVolQuote::DeltaVolQuote(Real delta, Handle<Quote> vol, Time maturity, DeltaType deltaType)
    : delta_(delta), vol_(std::move(vol)), deltaType_(deltaType), maturity_(maturity),
      atmType_(DeltaVolQuote::AtmNull) {

        registerWith(vol_); // observe vol
    }

    DeltaVolQuote::DeltaVolQuote(Handle<Quote> vol,
                                 DeltaType deltaType,
                                 Time maturity,
                                 AtmType atmType)
    : vol_(std::move(vol)), deltaType_(deltaType), maturity_(maturity), atmType_(atmType) {

        registerWith(vol_);
    }

    Real DeltaVolQuote::value() const {
        return vol_->value();
    }

    Real DeltaVolQuote::delta() const {
        return delta_;
    }

    Time DeltaVolQuote::maturity() const {
        return maturity_;
    }

    bool DeltaVolQuote::isValid() const {
        return !vol_.empty() && vol_->isValid();
    }

    void DeltaVolQuote::update() {
        notifyObservers(); // let observers know, that something has changed
    }

    DeltaVolQuote::AtmType DeltaVolQuote::atmType() const {
        return atmType_;
    }

    DeltaVolQuote::DeltaType DeltaVolQuote::deltaType() const {
        return deltaType_;
    }

}
]]></document_content>
  </document>
  <document index="349">
    <source>fx/deltavolquote.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file deltavolquote.hpp
    \brief Class for the quotation of delta vs vol.
*/

#ifndef quantlib_delta_vol_quote_hpp
#define quantlib_delta_vol_quote_hpp

#include <ql/quote.hpp>
#include <ql/handle.hpp>

namespace QuantLib {

    //! Class for the quotation of delta vs vol.
    /*! It includes the various delta quotation types
        in FX markets as well as ATM types.
    */
    class DeltaVolQuote : public Quote,
                          public Observer {
      public:
        enum DeltaType {
            Spot,        // Spot Delta, e.g. usual Black Scholes delta
            Fwd,         // Forward Delta
            PaSpot,      // Premium Adjusted Spot Delta
            PaFwd        // Premium Adjusted Forward Delta
        };

        enum AtmType {
            AtmNull,         // Default, if not an atm quote
            AtmSpot,         // K=S_0
            AtmFwd,          // K=F
            AtmDeltaNeutral, // Call Delta = Put Delta
            AtmVegaMax,      // K such that Vega is Maximum
            AtmGammaMax,     // K such that Gamma is Maximum
            AtmPutCall50     // K such that Call Delta=0.50 (only for Fwd Delta)
        };

        // Standard constructor delta vs vol.
        DeltaVolQuote(Real delta, Handle<Quote> vol, Time maturity, DeltaType deltaType);

        // Additional constructor, if special atm quote is used
        DeltaVolQuote(Handle<Quote> vol, DeltaType deltaType, Time maturity, AtmType atmType);

        void update() override;

        Real value() const override;
        Real delta() const;
        Time maturity() const;

        AtmType atmType()   const;
        DeltaType deltaType() const;

        bool isValid() const override;

      private:
          Real delta_;
          Handle<Quote> vol_;
          DeltaType deltaType_;
          Time maturity_;
          AtmType atmType_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="350">
    <source>inflation/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    cpicapfloorengines.hpp \
    cpicapfloortermpricesurface.hpp \
    genericindexes.hpp \
    interpolatedyoyoptionletstripper.hpp \
    kinterpolatedyoyoptionletvolatilitysurface.hpp \
    piecewiseyoyoptionletvolatility.hpp \
    polynomial2Dspline.hpp \
    yoycapfloortermpricesurface.hpp \
    yoyoptionlethelpers.hpp \
    yoyoptionletstripper.hpp \
    yoyinflationoptionletvolatilitystructure2.hpp

cpp_files = \
    cpicapfloorengines.cpp \
    cpicapfloortermpricesurface.cpp \
    yoycapfloortermpricesurface.cpp \
    yoyoptionlethelpers.cpp

if UNITY_BUILD

nodist_libInflation_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libInflation_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libInflation.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="351">
    <source>inflation/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/inflation/cpicapfloorengines.hpp>
#include <ql/experimental/inflation/cpicapfloortermpricesurface.hpp>
#include <ql/experimental/inflation/genericindexes.hpp>
#include <ql/experimental/inflation/interpolatedyoyoptionletstripper.hpp>
#include <ql/experimental/inflation/kinterpolatedyoyoptionletvolatilitysurface.hpp>
#include <ql/experimental/inflation/piecewiseyoyoptionletvolatility.hpp>
#include <ql/experimental/inflation/polynomial2Dspline.hpp>
#include <ql/experimental/inflation/yoycapfloortermpricesurface.hpp>
#include <ql/experimental/inflation/yoyoptionlethelpers.hpp>
#include <ql/experimental/inflation/yoyoptionletstripper.hpp>
#include <ql/experimental/inflation/yoyinflationoptionletvolatilitystructure2.hpp>

]]></document_content>
  </document>
  <document index="352">
    <source>inflation/cpicapfloorengines.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*!
 \file cpicapfloorengines.cpp
 \brief Engines for CPI options
 \ingroup PricingEngines
 */


#include <ql/experimental/inflation/cpicapfloorengines.hpp>
#include <ql/experimental/inflation/cpicapfloortermpricesurface.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <utility>


namespace QuantLib {


    InterpolatingCPICapFloorEngine::InterpolatingCPICapFloorEngine(
        Handle<CPICapFloorTermPriceSurface> priceSurf)
    : priceSurf_(std::move(priceSurf)) {
        registerWith(priceSurf_);
    }


    void InterpolatingCPICapFloorEngine::calculate() const
    {
        Real npv = 0.0;

        // what is the difference between the observationLag of the surface
        // and the observationLag of the cap/floor?
        // \TODO next line will fail if units are different
        Period lagDiff = arguments_.observationLag - priceSurf_->observationLag();
        // next line will fail if units are different if Period() is not well written
        QL_REQUIRE(lagDiff >= Period(0, Months), "InterpolatingCPICapFloorEngine: "
                   "lag difference must be non-negative: " << lagDiff);

        // we now need an effective maturity to use in the price surface because this uses
        // maturity of calibration instruments as its time axis, N.B. this must also
        // use the roll because the surface does
        Date effectiveMaturity = arguments_.payDate - lagDiff;


        // what interpolation do we use? Index / flat / linear
        if (arguments_.observationInterpolation == CPI::AsIndex) {
            // same as index means we can just use the price surface
            // since this uses the index
            if (arguments_.type == Option::Call) {
                npv = priceSurf_->capPrice(effectiveMaturity, arguments_.strike);
            } else {
                npv = priceSurf_->floorPrice(effectiveMaturity, arguments_.strike);
            }


        } else {
            std::pair<Date,Date> dd = inflationPeriod(effectiveMaturity, arguments_.infIndex->frequency());
            Real priceStart = 0.0;

            if (arguments_.type == Option::Call) {
                priceStart = priceSurf_->capPrice(dd.first, arguments_.strike);
            } else {
                priceStart = priceSurf_->floorPrice(dd.first, arguments_.strike);
            }

            // if we use a flat index vs the interpolated one ...
            if (arguments_.observationInterpolation == CPI::Flat) {
                // then use the price for the first day in the period because the value cannot change after then
                npv = priceStart;

            } else {
                // linear interpolation will be very close
                Real priceEnd = 0.0;
                if (arguments_.type == Option::Call) {
                    priceEnd = priceSurf_->capPrice((dd.second+Period(1,Days)), arguments_.strike);
                } else {
                    priceEnd = priceSurf_->floorPrice((dd.second+Period(1,Days)), arguments_.strike);
                }

                npv = priceStart + (priceEnd - priceStart) * (effectiveMaturity - dd.first)
                / ( (dd.second+Period(1,Days)) - dd.first); // can't get to next period'
            }

        }
        results_.value = npv;
    }





} // namespace QuantLib
]]></document_content>
  </document>
  <document index="353">
    <source>inflation/cpicapfloorengines.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*!
    \file cpicapfloorengines.hpp
    \brief Engines for CPI options
    \ingroup PricingEngines
*/

#ifndef quantlib_cpicapfloorengines_hpp
#define quantlib_cpicapfloorengines_hpp

#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/instruments/cpicapfloor.hpp>


namespace QuantLib {


    class CPICapFloorTermPriceSurface;


    //! This engine only adds timing functionality (e.g. different lag)
    //! w.r.t. an existing interpolated price surface.
    class InterpolatingCPICapFloorEngine : public CPICapFloor::engine {
        public:
          explicit InterpolatingCPICapFloorEngine(Handle<CPICapFloorTermPriceSurface>);

          void calculate() const override;
          virtual std::string name() const { return "InterpolatingCPICapFloorEngine"; }

          ~InterpolatingCPICapFloorEngine() override = default;

        protected:
          Handle<CPICapFloorTermPriceSurface> priceSurf_;
    };








} // namespace QuantLib

#endif // cpicapfloorengines_hpp
]]></document_content>
  </document>
  <document index="354">
    <source>inflation/cpicapfloortermpricesurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/experimental/inflation/cpicapfloortermpricesurface.hpp>
#include <utility>


namespace QuantLib {

    CPICapFloorTermPriceSurface::CPICapFloorTermPriceSurface(
        Real nominal,
        Real baseRate, // avoids an uncontrolled crash if index has no TS
        const Period& observationLag,
        const Calendar& cal, // calendar in index may not be useful
        const BusinessDayConvention& bdc,
        const DayCounter& dc,
        const Handle<ZeroInflationIndex>& zii,
        Handle<YieldTermStructure> yts,
        const std::vector<Rate>& cStrikes,
        const std::vector<Rate>& fStrikes,
        const std::vector<Period>& cfMaturities,
        const Matrix& cPrice,
        const Matrix& fPrice)
    : InflationTermStructure(
          0, cal, baseRate, observationLag, zii->frequency(), zii->interpolated(), dc),
      zii_(zii), nominalTS_(std::move(yts)), cStrikes_(cStrikes), fStrikes_(fStrikes),
      cfMaturities_(cfMaturities), cPrice_(cPrice), fPrice_(fPrice), nominal_(nominal), bdc_(bdc) {

        // does the index have a TS?
        QL_REQUIRE(!zii_->zeroInflationTermStructure().empty(), "ZITS missing from index");
        QL_REQUIRE(!nominalTS_.empty(), "nominal TS missing");
              
        // data consistency checking, enough data?
        QL_REQUIRE(fStrikes_.size() > 1, "not enough floor strikes");
        QL_REQUIRE(cStrikes_.size() > 1, "not enough cap strikes");
        QL_REQUIRE(cfMaturities_.size() > 1, "not enough maturities");
        QL_REQUIRE(fStrikes_.size() == fPrice.rows(),
                   "floor strikes vs floor price rows not equal");
        QL_REQUIRE(cStrikes_.size() == cPrice.rows(),
                   "cap strikes vs cap price rows not equal");
        QL_REQUIRE(cfMaturities_.size() == fPrice.columns(),
                   "maturities vs floor price columns not equal");
        QL_REQUIRE(cfMaturities_.size() == cPrice.columns(),
                   "maturities vs cap price columns not equal");

        // data has correct properties (positive, monotonic)?
        for(Size j = 0; j <cfMaturities_.size(); j++) {
            QL_REQUIRE( cfMaturities[j] > Period(0,Days), "non-positive maturities");
            if(j>0) {
                QL_REQUIRE( cfMaturities[j] > cfMaturities[j-1],
                            "non-increasing maturities");
            }
            for(Size i = 0; i <fPrice_.rows(); i++) {
                QL_REQUIRE( fPrice_[i][j] > 0.0,
                            "non-positive floor price: " << fPrice_[i][j] );
                if(i>0) {
                    QL_REQUIRE( fPrice_[i][j] >= fPrice_[i-1][j],
                                "non-increasing floor prices");
                }
            }
            for(Size i = 0; i <cPrice_.rows(); i++) {
                QL_REQUIRE( cPrice_[i][j] > 0.0,
                            "non-positive cap price: " << cPrice_[i][j] );
                if(i>0) {
                    QL_REQUIRE( cPrice_[i][j] <= cPrice_[i-1][j],
                                "non-decreasing cap prices: " 
                               << cPrice_[i][j] << " then " << cPrice_[i-1][j]);
                }
            }
        }


        // Get the set of strikes, noting that repeats, overlaps are
        // expected between caps and floors but that no overlap in the
        // output is allowed so no repeats or overlaps are used
        cfStrikes_ = std::vector<Rate>();
        for(Size i = 0; i <fStrikes_.size(); i++)
            cfStrikes_.push_back( fStrikes[i] );
        Real eps = 0.0000001;
        Rate maxFstrike = fStrikes_.back();
        for(Size i = 0; i < cStrikes_.size(); i++) {
            Rate k = cStrikes[i];
            if (k > maxFstrike + eps) cfStrikes_.push_back(k);
        }

        // final consistency checking
        QL_REQUIRE(cfStrikes_.size() > 2, "overall not enough strikes");
        for (Size i = 1; i < cfStrikes_.size(); i++)
            QL_REQUIRE( cfStrikes_[i] > cfStrikes_[i-1],
                        "cfStrikes not increasing");
    }


    Date CPICapFloorTermPriceSurface::cpiOptionDateFromTenor(const Period& p) const
    {
        return calendar().adjust(referenceDate() + p, businessDayConvention());
    }

    
    Real CPICapFloorTermPriceSurface::price(const Period &d, Rate k) const {
        return this->price(cpiOptionDateFromTenor(d), k);
    }
    

    Real CPICapFloorTermPriceSurface::capPrice(const Period &d, Rate k) const {
        return this->capPrice(cpiOptionDateFromTenor(d), k);
    }
    

    Real CPICapFloorTermPriceSurface::floorPrice(const Period &d, Rate k) const {
        return this->floorPrice(cpiOptionDateFromTenor(d), k);
    }
    
    
    

}

]]></document_content>
  </document>
  <document index="355">
    <source>inflation/cpicapfloortermpricesurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cpicapfloortermpricesurface.hpp
    \brief cpi inflation cap and floor term price structure.  N.B.
           cpi cap/floors have a single (one) flow (unlike nominal
           caps) because they observe cumulative inflation up to
           their maturity.  Options are on CPI(T)/CPI(0) but strikes
           are quoted for yearly average inflation, so require transformation
           via (1+quote)^T to obtain actual strikes.  These are consistent
           with ZCIIS quoting conventions.

    The single-flow property of CPI cap/floors means that no stripping
    is required.  Additionally CPI swaps, i.e. ZCIIS zero coupon inflation
    indexed swaps are usually the most liquid of all the inflation products.
    These two facts mean that we can use a Zero Inflation term structure to
    give ATM.

*/

#ifndef quantlib_cpi_capfloor_term_price_surface_hpp
#define quantlib_cpi_capfloor_term_price_surface_hpp

#include <ql/termstructures/inflationtermstructure.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/math/interpolations/interpolation2d.hpp>
#include <ql/experimental/inflation/polynomial2Dspline.hpp>
#include <ql/indexes/inflationindex.hpp>


namespace QuantLib {

    //! Provides cpi cap/floor prices by interpolation and put/call parity (not cap/floor/swap* parity).
    /*!
        The inflation index MUST contain a ZeroInflationTermStructure as
        this is used to create ATM.  Unlike YoY price surfaces we
        assume that 1) an ATM ZeroInflationTermStructure is available
        and 2) that it is safe to use it.  This is supported by the
        fact that no stripping is required for CPI cap/floors as they
        only give one flow.

        cpi cap/floors have a single (one) flow (unlike nominal
        caps) because they observe cumulative inflation up to
        their maturity.  Options are on CPI(T)/CPI(0) but strikes
        are quoted for yearly average inflation, so require transformation
        via (1+quote)^T to obtain actual strikes.  These are consistent
        with ZCIIS quoting conventions.

        The observationLag is that for the referenced instrument prices.
        Strikes are as-quoted not as-used.
    */
    class CPICapFloorTermPriceSurface : public InflationTermStructure {
      public:
        CPICapFloorTermPriceSurface(
            Real nominal,
            Real baseRate, // avoids an uncontrolled crash if index has no TS
            const Period& observationLag,
            const Calendar& cal, // calendar in index may not be useful
            const BusinessDayConvention& bdc,
            const DayCounter& dc,
            const Handle<ZeroInflationIndex>& zii,
            Handle<YieldTermStructure> yts,
            const std::vector<Rate>& cStrikes,
            const std::vector<Rate>& fStrikes,
            const std::vector<Period>& cfMaturities,
            const Matrix& cPrice,
            const Matrix& fPrice);

        //! \name InflationTermStructure interface
        //@{
        Period observationLag() const override;
        Date baseDate() const override;
        //@}

        //! is based on
        Handle<ZeroInflationIndex> zeroInflationIndex() const { return zii_; }


        //! inspectors
        /*! \note you don't know if price() is a cap or a floor
                  without checking the ZeroInflation ATM level.
        */
        //@{
        virtual Real nominal() const;
        virtual BusinessDayConvention businessDayConvention() const;
        //@}

        //! \warning you MUST remind the compiler in any descendants with the using:: mechanism
        //!          because you overload the names
        //! remember that the strikes use the quoting convention
        //@{
        virtual Real price(const Period &d, Rate k) const;
        virtual Real capPrice(const Period &d, Rate k) const;
        virtual Real floorPrice(const Period &d, Rate k) const;
        virtual Real price(const Date &d, Rate k) const = 0;
        virtual Real capPrice(const Date &d, Rate k) const = 0;
        virtual Real floorPrice(const Date &d, Rate k) const = 0;
        //@}

        virtual std::vector<Rate> strikes() const {return cfStrikes_;}
        virtual std::vector<Rate> capStrikes() const {return cStrikes_;}
        virtual std::vector<Rate> floorStrikes() const {return fStrikes_;}
        virtual std::vector<Period> maturities() const {return cfMaturities_;}

        virtual const Matrix &capPrices() const { return cPrice_; }
        virtual const Matrix &floorPrices() const { return fPrice_; }

        virtual Rate minStrike() const {return cfStrikes_.front();};
        virtual Rate maxStrike() const {return cfStrikes_.back();};
        virtual Date minDate() const {return referenceDate()+cfMaturities_.front();}// \TODO deal with index interpolation
        Date maxDate() const override { return referenceDate() + cfMaturities_.back(); }
        //@}


        virtual Date cpiOptionDateFromTenor(const Period& p) const;

      protected:
        virtual bool checkStrike(Rate K) {
            return ( minStrike() <= K && K <= maxStrike() );
        }
        virtual bool checkMaturity(const Date& d) {
            return ( minDate() <= d && d <= maxDate() );
        }



        Handle<ZeroInflationIndex> zii_;
        Handle<YieldTermStructure> nominalTS_;
        // data
        std::vector<Rate> cStrikes_;
        std::vector<Rate> fStrikes_;
        std::vector<Period> cfMaturities_;
        mutable std::vector<Real> cfMaturityTimes_;
        Matrix cPrice_;
        Matrix fPrice_;
        // constructed
        mutable std::vector<Rate> cfStrikes_;
      private:
        Real nominal_;
        BusinessDayConvention bdc_;
    };



    template<class Interpolator2D>
    class InterpolatedCPICapFloorTermPriceSurface
        : public CPICapFloorTermPriceSurface {
            public:
            InterpolatedCPICapFloorTermPriceSurface(Real nominal,
                                                Rate startRate,
                                                const Period &observationLag,
                                                const Calendar &cal,
                                                const BusinessDayConvention &bdc,
                                                const DayCounter &dc,
                                                const Handle<ZeroInflationIndex>& zii,
                                                const Handle<YieldTermStructure>& yts,
                                                const std::vector<Rate> &cStrikes,
                                                const std::vector<Rate> &fStrikes,
                                                const std::vector<Period> &cfMaturities,
                                                const Matrix &cPrice,
                                                const Matrix &fPrice,
                                                const Interpolator2D &interpolator2d = Interpolator2D());

            //! \name LazyObject interface
            //@{
            void performCalculations() const;
            //@}

            //! required to allow for method hiding
            //@{
            using CPICapFloorTermPriceSurface::price;
            using CPICapFloorTermPriceSurface::capPrice;
            using CPICapFloorTermPriceSurface::floorPrice;
            //@}

            //! remember that the strikes use the quoting convention
            //@{
            Real price(const Date& d, Rate k) const override;
            Real capPrice(const Date& d, Rate k) const override;
            Real floorPrice(const Date& d, Rate k) const override;
            //@}

        protected:

            // data for surfaces and curve
            mutable Matrix cPriceB_;
            mutable Matrix fPriceB_;
            mutable Interpolation2D capPrice_, floorPrice_;
            mutable Interpolator2D interpolator2d_;
    };



    // template definitions, for some reason DOXYGEN doesn't like the first one

    #ifndef __DOXYGEN__

    template<class Interpolator2D>
    InterpolatedCPICapFloorTermPriceSurface<Interpolator2D>::
    InterpolatedCPICapFloorTermPriceSurface(Real nominal,
                                            Rate startRate,
                                            const Period &observationLag,
                                            const Calendar &cal,
                                            const BusinessDayConvention &bdc,
                                            const DayCounter &dc,
                                            const Handle<ZeroInflationIndex>& zii,
                                            const Handle<YieldTermStructure>& yts,
                                            const std::vector<Rate> &cStrikes,
                                            const std::vector<Rate> &fStrikes,
                                            const std::vector<Period> &cfMaturities,
                                            const Matrix &cPrice,
                                            const Matrix &fPrice,
                                            const Interpolator2D &interpolator2d)
    : CPICapFloorTermPriceSurface(nominal, startRate, observationLag, cal, bdc, dc,
                                  zii, yts, cStrikes, fStrikes, cfMaturities, cPrice, fPrice),
      interpolator2d_(interpolator2d) {
        performCalculations();
    }

    #endif

    namespace detail {
    struct CloseEnoughComparator {
        explicit CloseEnoughComparator(const Real v) : v_(v) {}
        bool operator()(const Real w) const { return close_enough(v_, w); }
        Real v_;
    };
    } // namespace detail

    //! set up the interpolations for capPrice_ and floorPrice_
    //! since we know ATM, and we have single flows,
    //! we can use put/call parity to extend the surfaces
    //! across all strikes
    template<class I2D>
    void InterpolatedCPICapFloorTermPriceSurface<I2D>::
    performCalculations() const {

        cPriceB_ =
            Matrix(cfStrikes_.size(), cfMaturities_.size(), Null<Real>());
        fPriceB_ =
            Matrix(cfStrikes_.size(), cfMaturities_.size(), Null<Real>());

        Handle<ZeroInflationTermStructure> zts = zii_->zeroInflationTermStructure();
        Handle<YieldTermStructure> yts = nominalTS_;
        QL_REQUIRE(!zts.empty(), "Zts is empty!!!");
        QL_REQUIRE(!yts.empty(), "Yts is empty!!!");

        for (Size j = 0; j < cfMaturities_.size(); ++j) {
            Period mat = cfMaturities_[j];
            Real df = yts->discount(cpiOptionDateFromTenor(mat));
            Real atm_quote = zts->zeroRate(cpiOptionDateFromTenor(mat));
            Real atm = std::pow(1.0 + atm_quote, mat.length());
            Real S = atm * df;
            for (Size i = 0; i < cfStrikes_.size(); ++i) {
                Real K_quote = cfStrikes_[i];
                Real K = std::pow(1.0 + K_quote, mat.length());
                Size indF = std::find_if(fStrikes_.begin(), fStrikes_.end(),
                                         detail::CloseEnoughComparator(cfStrikes_[i])) -
                            fStrikes_.begin();
                Size indC = std::find_if(cStrikes_.begin(), cStrikes_.end(),
                                         detail::CloseEnoughComparator(cfStrikes_[i])) -
                            cStrikes_.begin();
                bool isFloorStrike = indF < fStrikes_.size();
                bool isCapStrike = indC < cStrikes_.size();
                if (isFloorStrike) {
                    fPriceB_[i][j] = fPrice_[indF][j];
                    if (!isCapStrike) {
                        cPriceB_[i][j] = fPrice_[indF][j] + S - K * df;
                    }
                }
                if (isCapStrike) {
                    cPriceB_[i][j] = cPrice_[indC][j];
                    if (!isFloorStrike) {
                        fPriceB_[i][j] = cPrice_[indC][j] + K * df - S;
                    }
                }
            }
        }

        // check that all cells are filled
        for (Size i = 0; i < cPriceB_.rows(); ++i) {
            for (Size j = 0; j < cPriceB_.columns(); ++j) {
                QL_REQUIRE(cPriceB_[i][j] != Null<Real>(),
                           "InterpolatedCPICapFloorTermPriceSurface: did not "
                           "fill call price matrix at ("
                               << i << "," << j << "), this is unexpected");
                QL_REQUIRE(fPriceB_[i][j] != Null<Real>(),
                           "InterpolatedCPICapFloorTermPriceSurface: did not "
                           "fill floor price matrix at ("
                               << i << "," << j << "), this is unexpected");
            }
        }

        cfMaturityTimes_.clear();
        for (Size i=0; i<cfMaturities_.size();i++) {
            cfMaturityTimes_.push_back(timeFromReference(cpiOptionDateFromTenor(cfMaturities_[i])));
        }

        capPrice_ = interpolator2d_.interpolate(cfMaturityTimes_.begin(),cfMaturityTimes_.end(),
                                                cfStrikes_.begin(), cfStrikes_.end(),
                                                cPriceB_
                                                );
        capPrice_.enableExtrapolation();

        floorPrice_ = interpolator2d_.interpolate(cfMaturityTimes_.begin(),cfMaturityTimes_.end(),
                                                  cfStrikes_.begin(), cfStrikes_.end(),
                                                  fPriceB_
                                                  );
        floorPrice_.enableExtrapolation();
    }

    //! remember that the strike uses the quoting convention
    template<class I2D>
    Real InterpolatedCPICapFloorTermPriceSurface<I2D>::
    price(const Date &d, Rate k) const {

        Rate atm = zeroInflationIndex()->zeroInflationTermStructure()->zeroRate(d);
        return k > atm ? capPrice(d,k): floorPrice(d,k);
    }

    //! remember that the strike uses the quoting convention
    template<class I2D>
    Real InterpolatedCPICapFloorTermPriceSurface<I2D>::
    capPrice(const Date &d, Rate k) const {
        Time t = timeFromReference(d);
        return capPrice_(t,k);
    }

    //! remember that the strike uses the quoting convention
    template<class I2D>
    Real InterpolatedCPICapFloorTermPriceSurface<I2D>::
    floorPrice(const Date &d, Rate k) const {
        Time t = timeFromReference(d);
        return floorPrice_(t,k);
    }

    // inline

    inline Period CPICapFloorTermPriceSurface::observationLag() const {
        return zeroInflationIndex()->zeroInflationTermStructure()->observationLag();
    }

    inline Date CPICapFloorTermPriceSurface::baseDate() const {
        return zeroInflationIndex()->zeroInflationTermStructure()->baseDate();
    }

    inline Real CPICapFloorTermPriceSurface::nominal() const {
        return nominal_;
    }

    inline BusinessDayConvention
    CPICapFloorTermPriceSurface::businessDayConvention() const {
        return bdc_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="356">
    <source>inflation/genericindexes.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file genericindexes.hpp
    \brief Generic inflation indexes
*/

#ifndef quantlib_generic_inflation_indexes_hpp
#define quantlib_generic_inflation_indexes_hpp

#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! Generic geographical/economic region
    class GenericRegion : public Region {
      public:
        GenericRegion() {
            static ext::shared_ptr<Data> GENERICdata(
                                               new Data("Generic","GENERIC"));
            data_ = GENERICdata;
        }
    };


    //! Generic CPI index
    class GenericCPI : public ZeroInflationIndex {
      public:
        GenericCPI(Frequency frequency,
                   bool revised,
                   bool interpolated,
                   const Period &lag,
                   const Currency &ccy,
                   const Handle<ZeroInflationTermStructure>& ts =
                                         Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("CPI",
                             GenericRegion(),
                             revised,
                             interpolated,
                             frequency,
                             lag,
                             ccy,
                             ts) {}
    };


    //! Genuine year-on-year Generic CPI (i.e. not a ratio)
    class YYGenericCPI : public YoYInflationIndex {
      public:
        YYGenericCPI(Frequency frequency,
                     bool revised,
                     bool interpolated,
                     const Period &lag,
                     const Currency &ccy,
                     const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_CPI",
                            GenericRegion(),
                            revised,
                            interpolated,
                            false,
                            frequency,
                            lag,
                            ccy,
                            ts) {}
    };

    //! Fake year-on-year GenericCPI (i.e. a ratio)
    class YYGenericCPIr : public YoYInflationIndex {
      public:
        YYGenericCPIr(Frequency frequency,
                      bool revised,
                      bool interpolated,
                      const Period &lag,
                      const Currency &ccy,
                      const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_CPI",
                            GenericRegion(),
                            revised,
                            interpolated,
                            true,
                            frequency,
                            lag,
                            ccy,
                            ts) {}
    };

}

#endif

]]></document_content>
  </document>
  <document index="357">
    <source>inflation/interpolatedyoyoptionletstripper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file interpolatedyoyoptionletstripper.hpp
    \brief interpolated yoy inflation-cap stripping
*/

#ifndef quantlib_interpolated_yoy_optionlet_stripper_hpp
#define quantlib_interpolated_yoy_optionlet_stripper_hpp

#include <ql/experimental/inflation/genericindexes.hpp>
#include <ql/experimental/inflation/piecewiseyoyoptionletvolatility.hpp>
#include <ql/experimental/inflation/yoyoptionlethelpers.hpp>
#include <ql/experimental/inflation/yoyoptionletstripper.hpp>
#include <ql/instruments/makeyoyinflationcapfloor.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <utility>


namespace QuantLib {

    /*! The interpolated version interpolates along each K (as opposed
        to fitting a model, say).

        \bug Tests currently fail.
    */
    template <class Interpolator1D>
    class InterpolatedYoYOptionletStripper : public YoYOptionletStripper {
      public:

        //! YoYOptionletStripper interface
        //@{
        void initialize(const ext::shared_ptr<YoYCapFloorTermPriceSurface>&,
                        const ext::shared_ptr<YoYInflationCapFloorEngine>&,
                        Real slope) const override;
        Rate minStrike() const override { return YoYCapFloorTermPriceSurface_->strikes().front(); }
        Rate maxStrike() const override { return YoYCapFloorTermPriceSurface_->strikes().back(); }
        std::vector<Rate> strikes() const override {
            return YoYCapFloorTermPriceSurface_->strikes();
        }
        std::pair<std::vector<Rate>, std::vector<Volatility> > slice(const Date& d) const override;
        //@}

      protected:
        mutable std::vector<ext::shared_ptr<YoYOptionletVolatilitySurface> >
        volCurves_;

        // used to set up the first point on each vol curve
        // using assumptions on unobserved vols at start
        class ObjectiveFunction {
          public:
            ObjectiveFunction(YoYInflationCapFloor::Type type,
                              Real slope,
                              Rate K,
                              Period& lag,
                              Natural fixingDays,
                              const ext::shared_ptr<YoYInflationIndex>& anIndex,
                              const ext::shared_ptr<YoYCapFloorTermPriceSurface>&,
                              ext::shared_ptr<YoYInflationCapFloorEngine> p,
                              Real priceToMatch);
            Real operator()(Volatility guess) const;
          protected:
            Real slope_;
            Rate K_;
            Frequency frequency_;
            bool indexIsInterpolated_;
            std::vector<Time> tvec_;
            std::vector<Date> dvec_;
            mutable std::vector<Volatility> vvec_;
            ext::shared_ptr<YoYInflationCapFloor> capfloor_;
            Real priceToMatch_;
            ext::shared_ptr<YoYCapFloorTermPriceSurface> surf_;
            Period lag_;
            ext::shared_ptr<YoYInflationCapFloorEngine> p_;
        };
    };


    // template definitions

    template <class Interpolator1D>
    InterpolatedYoYOptionletStripper<Interpolator1D>::ObjectiveFunction::ObjectiveFunction(
        YoYInflationCapFloor::Type type,
        Real slope,
        Rate K,
        Period& lag,
        Natural fixingDays,
        const ext::shared_ptr<YoYInflationIndex>& anIndex,
        const ext::shared_ptr<YoYCapFloorTermPriceSurface>& surf,
        ext::shared_ptr<YoYInflationCapFloorEngine> p,
        Real priceToMatch)
    : slope_(slope), K_(K), frequency_(anIndex->frequency()),
      indexIsInterpolated_(anIndex->interpolated()), tvec_(std::vector<Time>(2)),
      dvec_(std::vector<Date>(2)), vvec_(std::vector<Volatility>(2)), priceToMatch_(priceToMatch),
      surf_(surf), p_(std::move(p)) {

        lag_ = surf_->observationLag();
        capfloor_ =
            MakeYoYInflationCapFloor(type, anIndex,
                                     (Size)std::floor(0.5+surf->timeFromReference(surf->minMaturity())),
                                     surf->calendar(), lag)
            .withNominal(10000.0)
            .withStrike(K);

        // shortest time available from price surface
        dvec_[0] = surf_->baseDate();
        dvec_[1] = surf_->minMaturity() +
                   Period(7, Days);
        tvec_[0] = surf_->dayCounter().yearFraction(surf_->referenceDate(),
                                                    dvec_[0] );
        tvec_[1] = surf_->dayCounter().yearFraction(surf_->referenceDate(),
                                                    dvec_[1]);

        Size n = (Size)std::floor(0.5 + surf->timeFromReference(surf_->minMaturity()));
        QL_REQUIRE( n > 0,
                    "first maturity in price surface not > 0: "
                    << n);

        capfloor_->setPricingEngine(p_);
        // pricer already setup just need to do the volatility surface each time
    }


    template <class Interpolator1D>
    Real InterpolatedYoYOptionletStripper<Interpolator1D>::
    ObjectiveFunction::operator()(Volatility guess) const {

        vvec_[1] = guess;
        vvec_[0] = guess - slope_ * (tvec_[1] - tvec_[0]) * guess;
        // could have Interpolator1D instead of Linear
        ext::shared_ptr<InterpolatedYoYOptionletVolatilityCurve<Linear> >
        vCurve(
            new InterpolatedYoYOptionletVolatilityCurve<Linear>(
                                               0, TARGET(), ModifiedFollowing,
                                               Actual365Fixed(), lag_,
                                               frequency_, indexIsInterpolated_,
                                               dvec_, vvec_,
                                               -1.0, 3.0) ); // strike limits
        Handle<YoYOptionletVolatilitySurface> hCurve(vCurve);
        p_->setVolatility(hCurve);
        // hopefully this gets to the pricer ... then
        return priceToMatch_ - capfloor_->NPV();
    }


    template <class Interpolator1D>
    void InterpolatedYoYOptionletStripper<Interpolator1D>::
    initialize(const ext::shared_ptr<YoYCapFloorTermPriceSurface> &s,
               const ext::shared_ptr<YoYInflationCapFloorEngine> &p,
               const Real slope) const {
        YoYCapFloorTermPriceSurface_ = s;
        p_ = p;
        lag_ = YoYCapFloorTermPriceSurface_->observationLag();
        frequency_ = YoYCapFloorTermPriceSurface_->frequency();
        indexIsInterpolated_ = YoYCapFloorTermPriceSurface_->indexIsInterpolated();
        Natural fixingDays_ = YoYCapFloorTermPriceSurface_->fixingDays();
        Natural settlementDays = 0; // always
        Calendar cal = YoYCapFloorTermPriceSurface_->calendar();
        BusinessDayConvention bdc =
            YoYCapFloorTermPriceSurface_->businessDayConvention();
        DayCounter dc = YoYCapFloorTermPriceSurface_->dayCounter();

        // switch from caps to floors when out of floors
        Rate maxFloor = YoYCapFloorTermPriceSurface_->floorStrikes().back();
        YoYInflationCapFloor::Type useType = YoYInflationCapFloor::Floor;
        Period TPmin = YoYCapFloorTermPriceSurface_->maturities().front();
        // create a "fake index" based on Generic, this should work
        // provided that the lag and frequency are correct
        RelinkableHandle<YoYInflationTermStructure> hYoY(
                                       YoYCapFloorTermPriceSurface_->YoYTS());
        ext::shared_ptr<YoYInflationIndex> anIndex(
                                           new YYGenericCPI(frequency_, false,
                                                            false, lag_,
                                                            Currency(), hYoY));

        // strip each K separatly
        for (Size i=0; i<YoYCapFloorTermPriceSurface_->strikes().size(); i++) {
            Rate K = YoYCapFloorTermPriceSurface_->strikes()[i];
            if (K > maxFloor) useType = YoYInflationCapFloor::Cap;

            // solve for the initial point on the vol curve
            Brent solver;
            Real solverTolerance_ = 1e-7;
             // these are VOLATILITY guesses (always +)
            Real lo = 0.00001, hi = 0.08;
            Real guess = (hi+lo)/2.0;
            Real found;
            Real priceToMatch =
                (useType == YoYInflationCapFloor::Cap ?
                 YoYCapFloorTermPriceSurface_->capPrice(TPmin, K) :
                 YoYCapFloorTermPriceSurface_->floorPrice(TPmin, K));

            try{
                found = solver.solve(
                      ObjectiveFunction(useType, slope, K, lag_, fixingDays_,
                                        anIndex, YoYCapFloorTermPriceSurface_,
                                        p_, priceToMatch),
                      solverTolerance_, guess, lo, hi );
            } catch( std::exception &e) {
                QL_FAIL("failed to find solution here because: " << e.what());
            }

            // ***create helpers***
            Real notional = 10000; // work in bps
            std::vector<ext::shared_ptr<BootstrapHelper<YoYOptionletVolatilitySurface> > > helperInstruments;
            std::vector<ext::shared_ptr<YoYOptionletHelper> > helpers;
            for (Size j = 0; j < YoYCapFloorTermPriceSurface_->maturities().size(); j++){
                Period Tp = YoYCapFloorTermPriceSurface_->maturities()[j];

                Real nextPrice =
                    (useType == YoYInflationCapFloor::Cap ?
                     YoYCapFloorTermPriceSurface_->capPrice(Tp, K) :
                     YoYCapFloorTermPriceSurface_->floorPrice(Tp, K));

                Handle<Quote> quote1(ext::shared_ptr<Quote>(
                                               new SimpleQuote( nextPrice )));
                // helper should be an integer number of periods away,
                // this is enforced by rounding
                Size nT = (Size)floor(s->timeFromReference(s->yoyOptionDateFromTenor(Tp))+0.5);
                helpers.push_back(ext::shared_ptr<YoYOptionletHelper>(
                          new YoYOptionletHelper(quote1, notional, useType,
                                                 lag_,
                                                 dc, cal,
                                                 fixingDays_,
                                                 anIndex, K, nT, p_)));

                ext::shared_ptr<ConstantYoYOptionletVolatility> yoyVolBLACK(
                          new ConstantYoYOptionletVolatility(found, settlementDays,
                                                             cal, bdc, dc,
                                                             lag_, frequency_,
                                                             false,
                                                             // -100% to +300%
                                                             -1.0,3.0));

                helpers[j]->setTermStructure(
                       // gets underlying pointer & removes const
                       const_cast<ConstantYoYOptionletVolatility*>(
                                                          yoyVolBLACK.get()));
                helperInstruments.push_back(helpers[j]);
            }
            // ***bootstrap***
            // this is the artificial vol at zero so that first section works
            Real Tmin = s->timeFromReference(s->yoyOptionDateFromTenor(TPmin));
            Volatility baseYoYVolatility = found - slope * Tmin * found;
            Rate eps = std::max(K, 0.02) / 1000.0;
            Rate minStrike = K-eps;
            Rate maxStrike = K+eps;
            ext::shared_ptr<
                PiecewiseYoYOptionletVolatilityCurve<Interpolator1D> > testPW(
                new PiecewiseYoYOptionletVolatilityCurve<Interpolator1D>(
                                            settlementDays, cal, bdc, dc, lag_,
                                            frequency_, indexIsInterpolated_,
                                            minStrike, maxStrike,
                                            baseYoYVolatility,
                                            helperInstruments) );
            testPW->recalculate();
            volCurves_.push_back(testPW);
        }
    }


    template <class Interpolator1D>
    std::pair<std::vector<Rate>, std::vector<Volatility> >
    InterpolatedYoYOptionletStripper<Interpolator1D>::slice(
                                                        const Date &d) const {

        const std::vector<Real>& Ks = strikes();

        const Size nK = Ks.size();

        std::pair<std::vector<Rate>, std::vector<Volatility> > result =
            std::make_pair(std::vector<Rate>(nK), std::vector<Volatility>(nK));

        for (Size i = 0; i < nK; i++) {
            Rate K = Ks[i];
            Volatility v = volCurves_[i]->volatility(d, K);
            result.first[i] = K;
            result.second[i] = v;
        }

        return result;
    }

}

#endif

]]></document_content>
  </document>
  <document index="358">
    <source>inflation/kinterpolatedyoyoptionletvolatilitysurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file kinterpolatedyoyoptionletvolatilitysurface.hpp
    \brief K-interpolated yoy optionlet volatility
*/

#ifndef quantlib_k_interpolated_yoy_optionlet_volatility_surface_hpp
#define quantlib_k_interpolated_yoy_optionlet_volatility_surface_hpp

#include <ql/experimental/inflation/yoyoptionletstripper.hpp>
#include <utility>

namespace QuantLib {

    //! K-interpolated YoY optionlet volatility
    /*! The stripper provides curves in the T direction along each K.
        We don't know whether this is interpolating or fitting in the
        T direction.  Our K direction interpolations are not model
        fitting.

        An alternative design would be a
        FittedYoYOptionletVolatilitySurface taking a model, e.g. SABR
        in the interest rate world.  This could use the same stripping
        in the T direction along each K.

        \bug Tests currently fail.
    */
    template<class Interpolator1D>
    class KInterpolatedYoYOptionletVolatilitySurface
        : public YoYOptionletVolatilitySurface {
      public:
        //! \name Constructor
        //! calculate the reference date based on the global evaluation date
        KInterpolatedYoYOptionletVolatilitySurface(
            Natural settlementDays,
            const Calendar&,
            BusinessDayConvention bdc,
            const DayCounter& dc,
            const Period& lag,
            const ext::shared_ptr<YoYCapFloorTermPriceSurface>& capFloorPrices,
            ext::shared_ptr<YoYInflationCapFloorEngine> pricer,
            ext::shared_ptr<YoYOptionletStripper> yoyOptionletStripper,
            Real slope,
            const Interpolator1D& interpolator = Interpolator1D(),
            VolatilityType volType = ShiftedLognormal,
            Real displacement = 0.0);

        Real minStrike() const override;
        Real maxStrike() const override;
        Date maxDate() const override;
        std::pair<std::vector<Rate>, std::vector<Volatility> > Dslice(
                                                         const Date &d) const;

      protected:
        virtual Volatility volatilityImpl(const Date &d,
                                          Rate strike) const;
        Volatility volatilityImpl(Time length, Rate strike) const override;
        virtual void performCalculations() const;

        ext::shared_ptr<YoYCapFloorTermPriceSurface> capFloorPrices_;
        ext::shared_ptr<YoYInflationCapFloorEngine> yoyInflationCouponPricer_;
        ext::shared_ptr<YoYOptionletStripper> yoyOptionletStripper_;

        mutable Interpolator1D factory1D_;
        mutable Real slope_;
        mutable bool lastDateisSet_;
        mutable Date lastDate_;
        mutable Interpolation tempKinterpolation_;
        mutable std::pair<std::vector<Rate>, std::vector<Volatility> > slice_;
      private:
        void updateSlice(const Date &d) const;
    };


    // template definitions

    template <class Interpolator1D>
    KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
        KInterpolatedYoYOptionletVolatilitySurface(
            const Natural settlementDays,
            const Calendar& cal,
            const BusinessDayConvention bdc,
            const DayCounter& dc,
            const Period& lag,
            const ext::shared_ptr<YoYCapFloorTermPriceSurface>& capFloorPrices,
            ext::shared_ptr<YoYInflationCapFloorEngine> pricer,
            ext::shared_ptr<YoYOptionletStripper> yoyOptionletStripper,
            const Real slope,
            const Interpolator1D& interpolator,
            VolatilityType volType,
            Real displacement)
    : YoYOptionletVolatilitySurface(settlementDays,
                                    cal,
                                    bdc,
                                    dc,
                                    lag,
                                    capFloorPrices->yoyIndex()->frequency(),
                                    capFloorPrices->yoyIndex()->interpolated(),
                                    volType,
                                    displacement),
      capFloorPrices_(capFloorPrices), yoyInflationCouponPricer_(std::move(pricer)),
      yoyOptionletStripper_(std::move(yoyOptionletStripper)), factory1D_(interpolator),
      slope_(slope), lastDateisSet_(false) {
        performCalculations();
    }


    template<class Interpolator1D>
    Date KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    maxDate() const {
        Size n = capFloorPrices_->maturities().size();
        return referenceDate()+capFloorPrices_->maturities()[n-1];
    }


    template<class Interpolator1D>
    Real KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    minStrike() const {
        return capFloorPrices_->strikes().front();
    }


    template<class Interpolator1D>
    Real KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    maxStrike() const {
        return capFloorPrices_->strikes().back();
    }


    template<class Interpolator1D>
    void KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    performCalculations() const {

        // slope is the assumption on the initial caplet volatility change
        yoyOptionletStripper_->initialize(capFloorPrices_,
                                          yoyInflationCouponPricer_,
                                          slope_);
    }


    template<class Interpolator1D>
    Volatility KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    volatilityImpl(const Date &d, Rate strike) const {
        updateSlice(d);
        if (this->allowsExtrapolation()) {
            this->tempKinterpolation_.enableExtrapolation();
        }
        return tempKinterpolation_(strike);
    }


    template<class Interpolator1D>
    std::pair<std::vector<Rate>, std::vector<Volatility> >
    KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    Dslice(const Date &d) const {
        updateSlice(d);
        return slice_;
    }


    template<class Interpolator1D>
    Volatility KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    volatilityImpl(Time length,  Rate strike) const {

        auto years = (Natural)floor(length);
        auto days = (Natural)floor((length - years) * 365.0);
        Date d = referenceDate() + Period(years, Years) + Period(days, Days);

        return this->volatilityImpl(d, strike);
    }

    template<class Interpolator1D>
    void KInterpolatedYoYOptionletVolatilitySurface<Interpolator1D>::
    updateSlice(const Date &d) const {

        if (!lastDateisSet_ || d != lastDate_ ) {
            slice_ = yoyOptionletStripper_->slice(d);

            tempKinterpolation_ =
                factory1D_.interpolate( slice_.first.begin(),
                                        slice_.first.end(),
                                        slice_.second.begin() );
            lastDateisSet_ = true;
            lastDate_ = d;
        }
    }

}

#endif

]]></document_content>
  </document>
  <document index="359">
    <source>inflation/piecewiseyoyoptionletvolatility.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file piecewiseyoyoptionletvolatility.hpp
    \brief piecewise yoy inflation volatility term structure
*/

#ifndef quantlib_piecewise_yoy_optionlet_volatility_hpp
#define quantlib_piecewise_yoy_optionlet_volatility_hpp

#include <ql/experimental/inflation/yoyinflationoptionletvolatilitystructure2.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/iterativebootstrap.hpp>
#include <utility>

namespace QuantLib {

    //! traits for inflation-volatility bootstrap
    class YoYInflationVolatilityTraits {
      public:
        typedef BootstrapHelper<YoYOptionletVolatilitySurface> helper;

        // start of curve data
        static Date initialDate(const YoYOptionletVolatilitySurface *s) {
            return s->baseDate();
        }
        // value at reference date
        static Real initialValue(const YoYOptionletVolatilitySurface *s) {
            return s->baseLevel();  // REALLLYYYY important because
                                    // generally don't have a clue
                                    // what this should be - embodies
                                    // assumptions on early options
                                    // that are _not_ quoted
        }

        // guesses
        template <class C>
        static Real guess(Size i,
                          const C* c,
                          bool validData,
                          Size) // firstAliveHelper
        {
            if (validData) // previous iteration value
                return c->data()[i];

            if (i==1) // first pillar
                return 0.005;

            // could/should extrapolate
            return 0.002;
        }

        // constraints
        template <class C>
        static Real minValueAfter(Size i,
                                  const C* c,
                                  bool,
                                  Size) // firstAliveHelper
        {
            return std::max(0.0, c->data()[i-1] - 0.02); // vol cannot be negative
        }
        template <class C>
        static Real maxValueAfter(Size i,
                                  const C* c,
                                  bool,
                                  Size) // firstAliveHelper
        {
            return c->data()[i-1] + 0.02;
        }

        // root-finding update
        static void updateGuess(std::vector<Real> &vols,
                                Real level,
                                Size i) {
            vols[i] = level;
        }
        // upper bound for convergence loop
        static Size maxIterations() {return 25;}
    };


    //! Piecewise year-on-year inflation volatility term structure
    /*! We use a flat smile for bootstrapping at constant K.  Happily
        most of the work has already been done in the bootstrapping
        classes.  We only need to add special attention for the start
        where there is usually no data, only assumptions.
    */
    template <class Interpolator,
              template <class> class Bootstrap = IterativeBootstrap,
              class Traits = YoYInflationVolatilityTraits>
    class PiecewiseYoYOptionletVolatilityCurve
        : public InterpolatedYoYOptionletVolatilityCurve<Interpolator>,
          public LazyObject {
      private:
        typedef InterpolatedYoYOptionletVolatilityCurve<Interpolator>
                                                                   base_curve;
        typedef PiecewiseYoYOptionletVolatilityCurve<Interpolator,
                                                     Bootstrap,
                                                     Traits> this_curve;
      public:
        typedef Traits traits_type;
        typedef Interpolator interpolator_type;

        PiecewiseYoYOptionletVolatilityCurve(
            Natural settlementDays,
            const Calendar& cal,
            BusinessDayConvention bdc,
            const DayCounter& dc,
            const Period& lag,
            Frequency frequency,
            bool indexIsInterpolated,
            Rate minStrike,
            Rate maxStrike,
            Volatility baseYoYVolatility,
            std::vector<ext::shared_ptr<typename Traits::helper> > instruments,
            Real accuracy = 1.0e-12,
            const Interpolator& interpolator = Interpolator())
        : base_curve(settlementDays,
                     cal,
                     bdc,
                     dc,
                     lag,
                     frequency,
                     indexIsInterpolated,
                     minStrike,
                     maxStrike,
                     baseYoYVolatility,
                     interpolator),
          instruments_(std::move(instruments)), accuracy_(accuracy) {
            bootstrap_.setup(this);
        }

        //! \name Inflation interface
        //@{
        Date baseDate() const override;
        Date maxDate() const override;
        //@
        //! \name Inspectors
        //@{
        const std::vector<Time>& times() const override;
        const std::vector<Date>& dates() const override;
        const std::vector<Real>& data() const override;
        std::vector<std::pair<Date, Real> > nodes() const override;
        //@}
        //! \name Observer interface
        //@{
        void update() override;
        //@}
      private:
        // methods
        void performCalculations() const override;
        // data members
        std::vector<ext::shared_ptr<typename Traits::helper> > instruments_;
        Real accuracy_;

        friend class Bootstrap<this_curve>;
        friend class BootstrapError<this_curve>;
        Bootstrap<this_curve> bootstrap_;
    };


    // inline and template definitions

    template <class I, template <class> class B, class T>
    inline Date PiecewiseYoYOptionletVolatilityCurve<I,B,T>::baseDate() const {
        this->calculate();
        return base_curve::baseDate();
    }

    template <class I, template <class> class B, class T>
    inline Date PiecewiseYoYOptionletVolatilityCurve<I,B,T>::maxDate() const {
        this->calculate();
        return base_curve::maxDate();
    }

    template <class I, template <class> class B, class T>
    const std::vector<Time>&
    PiecewiseYoYOptionletVolatilityCurve<I,B,T>::times() const {
        calculate();
        return base_curve::times();
    }

    template <class I, template <class> class B, class T>
    const std::vector<Date>&
    PiecewiseYoYOptionletVolatilityCurve<I,B,T>::dates() const {
        calculate();
        return base_curve::dates();
    }

    template <class I, template <class> class B, class T>
    const std::vector<Real>&
    PiecewiseYoYOptionletVolatilityCurve<I,B,T>::data() const {
        calculate();
        return base_curve::data();
    }

    template <class I, template <class> class B, class T>
    std::vector<std::pair<Date, Real> >
    PiecewiseYoYOptionletVolatilityCurve<I,B,T>::nodes() const {
        calculate();
        return base_curve::nodes();
    }

    template <class I, template <class> class B, class T>
    void
    PiecewiseYoYOptionletVolatilityCurve<I,B,T>::performCalculations() const {
        bootstrap_.calculate();
    }

    template <class I, template <class> class B, class T>
    void PiecewiseYoYOptionletVolatilityCurve<I,B,T>::update() {
        base_curve::update();
        LazyObject::update();
    }

}

#endif
]]></document_content>
  </document>
  <document index="360">
    <source>inflation/polynomial2Dspline.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2004 StatPro Italia srl
 Copyright (C) 2009 Bernd Engelmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file polynomial2Dspline.hpp
    \brief polynomial interpolation in the y-direction, spline interpolation x-direction
*/

#ifndef quantlib_polynomial2D_spline_hpp
#define quantlib_polynomial2D_spline_hpp

#include <ql/math/interpolations/interpolation2d.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>

namespace QuantLib {

    namespace detail {

        template <class I1, class I2, class M>
        class Polynomial2DSplineImpl
            : public Interpolation2D::templateImpl<I1,I2,M> {
          public:
            Polynomial2DSplineImpl(const I1& xBegin, const I1& xEnd,
                                   const I2& yBegin, const I2& yEnd, const M& zData)
            : Interpolation2D::templateImpl<I1,I2,M>(xBegin,xEnd,
                                                     yBegin,yEnd,
                                                     zData) {
                calculate();
            }
            void calculate() {
                QL_REQUIRE(this->zData_.rows() == this->yEnd_ - this->yBegin_,
                    "size mismatch of the interpolation data");

                polynomials_.reserve(this->zData_.columns());
                for (Size i=0; i<(this->zData_.columns()); ++i)
                    polynomials_.push_back(Parabolic(
                        this->yBegin_, this->yEnd_,
                        this->zData_.column_begin(i)));
            }
            Real value(Real x,
                       Real y) const {
                std::vector<Real> section(polynomials_.size());
                for (Size i=0; i<polynomials_.size(); ++i)
                    section[i] = polynomials_[i](y, true);

                QL_REQUIRE(section.size() == this->xEnd_ - this->xBegin_,
                           "size mismatch of the interpolation data");

                CubicInterpolation spline(
                    this->xBegin_, this->xEnd_,
                    section.begin(),
                    CubicInterpolation::Spline, true,
                    CubicInterpolation::SecondDerivative, 0.0,
                    CubicInterpolation::SecondDerivative, 0.0);
                return spline(x,true);
            }
          private:
            std::vector<Interpolation> polynomials_;
        };

    }

    //! polynomial2D-spline interpolation between discrete points
    class Polynomial2DSpline : public Interpolation2D {
      public:
        /*! \pre the \f$ x \f$ and \f$ y \f$ values must be sorted. */
        template <class I1, class I2, class M>
        Polynomial2DSpline(const I1& xBegin, const I1& xEnd,
                           const I2& yBegin, const I2& yEnd,
                           const M& zData) {
            impl_ = ext::shared_ptr<Interpolation2D::Impl>(
                  new detail::Polynomial2DSplineImpl<I1,I2,M>(xBegin, xEnd,
                                                              yBegin, yEnd, zData));
        }
    };

    //! polynomial2D-spline-interpolation factory
    class Polynomial {
      public:
        template <class I1, class I2, class M>
        Interpolation2D interpolate(const I1& xBegin, const I1& xEnd,
                                    const I2& yBegin, const I2& yEnd,
                                    const M& z) const {
            return Polynomial2DSpline(xBegin,xEnd,yBegin,yEnd,z);
        }
    };

}

#endif
]]></document_content>
  </document>
  <document index="361">
    <source>inflation/yoycapfloortermpricesurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/inflation/yoycapfloortermpricesurface.hpp>
#include <utility>

namespace QuantLib {

    YoYCapFloorTermPriceSurface::YoYCapFloorTermPriceSurface(
        Natural fixingDays,
        const Period& lag,
        const ext::shared_ptr<YoYInflationIndex>& yii,
        Rate baseRate,
        Handle<YieldTermStructure> nominal,
        const DayCounter& dc,
        const Calendar& cal,
        const BusinessDayConvention& bdc,
        const std::vector<Rate>& cStrikes,
        const std::vector<Rate>& fStrikes,
        const std::vector<Period>& cfMaturities,
        const Matrix& cPrice,
        const Matrix& fPrice)
    : InflationTermStructure(0, cal, baseRate, lag, yii->frequency(), yii->interpolated(), dc),
      fixingDays_(fixingDays), bdc_(bdc), yoyIndex_(yii), nominalTS_(std::move(nominal)),
      cStrikes_(cStrikes), fStrikes_(fStrikes), cfMaturities_(cfMaturities), cPrice_(cPrice),
      fPrice_(fPrice) {

        // data consistency checking, enough data?
        QL_REQUIRE(fStrikes_.size() > 1, "not enough floor strikes");
        QL_REQUIRE(cStrikes_.size() > 1, "not enough cap strikes");
        QL_REQUIRE(cfMaturities_.size() > 1, "not enough maturities");
        QL_REQUIRE(fStrikes_.size() == fPrice.rows(),
                   "floor strikes vs floor price rows not equal");
        QL_REQUIRE(cStrikes_.size() == cPrice.rows(),
                   "cap strikes vs cap price rows not equal");
        QL_REQUIRE(cfMaturities_.size() == fPrice.columns(),
                   "maturities vs floor price columns not equal");
        QL_REQUIRE(cfMaturities_.size() == cPrice.columns(),
                   "maturities vs cap price columns not equal");

        // data has correct properties (positive, monotonic)?
        for(Size j = 0; j <cfMaturities_.size(); j++) {
            QL_REQUIRE( cfMaturities[j] > Period(0,Days), "non-positive maturities");
            if(j>0) {
                QL_REQUIRE( cfMaturities[j] > cfMaturities[j-1],
                            "non-increasing maturities");
            }
            for(Size i = 0; i <fPrice_.rows(); i++) {
                QL_REQUIRE( fPrice_[i][j] > 0.0,
                            "non-positive floor price: " << fPrice_[i][j] );
                if(i>0) {
                    QL_REQUIRE( fPrice_[i][j] >= fPrice_[i-1][j],
                                "non-increasing floor prices");
                }
            }
            for(Size i = 0; i <cPrice_.rows(); i++) {
                QL_REQUIRE( cPrice_[i][j] > 0.0,
                            "non-positive cap price: " << cPrice_[i][j] );
                if(i>0) {
                    QL_REQUIRE( cPrice_[i][j] <= cPrice_[i-1][j],
                                "non-decreasing cap prices");
                }
            }
        }


        // Get the set of strikes, noting that repeats, overlaps are
        // expected between caps and floors but that no overlap in the
        // output is allowed so no repeats or overlaps are used
        cfStrikes_ = std::vector<Rate>();
        for(Size i = 0; i <fStrikes_.size(); i++)
            cfStrikes_.push_back( fStrikes[i] );
        Real eps = 0.0000001;
        Rate maxFstrike = fStrikes_.back();
        for(Size i = 0; i < cStrikes_.size(); i++) {
            Rate k = cStrikes[i];
            if (k > maxFstrike + eps) cfStrikes_.push_back(k);
        }

        // final consistency checking
        QL_REQUIRE(cfStrikes_.size() > 2, "overall not enough strikes");
        for (Size i = 1; i < cfStrikes_.size(); i++)
            QL_REQUIRE( cfStrikes_[i] > cfStrikes_[i-1],
                        "cfStrikes not increasing");
    }

    Date YoYCapFloorTermPriceSurface::yoyOptionDateFromTenor(const Period& p) const
    {
        return referenceDate() + p;
    }

    Real YoYCapFloorTermPriceSurface::price(const Period &d, const Rate k) const {
        return price(yoyOptionDateFromTenor(d), k);
    }

    Real YoYCapFloorTermPriceSurface::capPrice(const Period &d, const Rate k) const {
        return capPrice(yoyOptionDateFromTenor(d), k);
    }

    Real YoYCapFloorTermPriceSurface::floorPrice(const Period &d, const Rate k) const {
        return floorPrice(yoyOptionDateFromTenor(d), k);
    }

    Rate YoYCapFloorTermPriceSurface::atmYoYSwapRate(const Period &d,
                        bool extrapolate) const {
        return atmYoYSwapRate(yoyOptionDateFromTenor(d), extrapolate);
    }

    Rate YoYCapFloorTermPriceSurface::atmYoYRate(const Period &d,
                                                 const Period& obsLag,
                    bool extrapolate) const {
        return atmYoYRate(yoyOptionDateFromTenor(d), obsLag, extrapolate);
    }



}

]]></document_content>
  </document>
  <document index="362">
    <source>inflation/yoycapfloortermpricesurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon
 Copyright (C) 2009 Bernd Engelmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file yoyoptionlethelpers.hpp
    \brief yoy inflation cap and floor term-price structure
*/

#ifndef quantlib_yoy_capfloor_term_price_surface_hpp
#define quantlib_yoy_capfloor_term_price_surface_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/termstructures/inflation/piecewiseyoyinflationcurve.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/experimental/inflation/polynomial2Dspline.hpp>
#include <cmath>

namespace QuantLib {

    //! Abstract base class, inheriting from InflationTermStructure
    /*! Since this can create a yoy term structure it does take
        a YoY index.

        \todo deal with index interpolation.
    */
    class YoYCapFloorTermPriceSurface : public InflationTermStructure {
      public:
        YoYCapFloorTermPriceSurface(Natural fixingDays,
                                    const Period& yyLag,
                                    const ext::shared_ptr<YoYInflationIndex>& yii,
                                    Rate baseRate,
                                    Handle<YieldTermStructure> nominal,
                                    const DayCounter& dc,
                                    const Calendar& cal,
                                    const BusinessDayConvention& bdc,
                                    const std::vector<Rate>& cStrikes,
                                    const std::vector<Rate>& fStrikes,
                                    const std::vector<Period>& cfMaturities,
                                    const Matrix& cPrice,
                                    const Matrix& fPrice);

        //-! inflation term structure interface
        //-@{
        //- virtual Date maxDate() { return yoy_->maxDate();}
        //- virtual Date baseDate() { return yoy_->baseDate();}
        //-@}

        //! atm yoy swaps from put-call parity on cap/floor data
        /*! uses interpolation (on surface price data), yearly maturities. */
        virtual std::pair<std::vector<Time>, std::vector<Rate> >
        atmYoYSwapTimeRates() const = 0;
        virtual std::pair<std::vector<Date>, std::vector<Rate> >
        atmYoYSwapDateRates() const = 0;

        //! derived from yoy swap rates
        virtual ext::shared_ptr<YoYInflationTermStructure> YoYTS() const = 0;
        //! index yoy is based on
        ext::shared_ptr<YoYInflationIndex> yoyIndex() const { return yoyIndex_; }

        //! inspectors
        /*! \note you don't know if price() is a cap or a floor
                  without checking the YoYSwapATM level.
            \note atm cap/floor prices are generally
                  inaccurate because they are from extrapolation
                  and intersection.
        */
        //@{
        virtual BusinessDayConvention businessDayConvention() const {return bdc_;}
        virtual Natural fixingDays() const {return fixingDays_;}
        virtual Real price(const Date& d, Rate k) const = 0;
        virtual Real capPrice(const Date& d, Rate k) const = 0;
        virtual Real floorPrice(const Date& d, Rate k) const = 0;
        virtual Rate atmYoYSwapRate(const Date &d,
                                    bool extrapolate = true) const = 0;
        virtual Rate atmYoYRate(const Date &d,
                                const Period &obsLag = Period(-1,Days),
                                bool extrapolate = true) const = 0;

        virtual Real price(const Period& d, Rate k) const;
        virtual Real capPrice(const Period& d, Rate k) const;
        virtual Real floorPrice(const Period& d, Rate k) const;
        virtual Rate atmYoYSwapRate(const Period &d,
                                    bool extrapolate = true) const;
        virtual Rate atmYoYRate(const Period &d,
                                const Period &obsLag = Period(-1,Days),
                                bool extrapolate = true) const;

        virtual std::vector<Rate> strikes() const {return cfStrikes_;}
        virtual std::vector<Rate> capStrikes() const {return cStrikes_;}
        virtual std::vector<Rate> floorStrikes() const {return fStrikes_;}
        virtual std::vector<Period> maturities() const {return cfMaturities_;}
        virtual Rate minStrike() const {return cfStrikes_.front();};
        virtual Rate maxStrike() const {return cfStrikes_.back();};
        virtual Date minMaturity() const {return referenceDate()+cfMaturities_.front();}// \TODO deal with index interpolation
        virtual Date maxMaturity() const {return referenceDate()+cfMaturities_.back();}
        //@}

        virtual Date yoyOptionDateFromTenor(const Period& p) const;

      protected:
        virtual bool checkStrike(Rate K) {
            return ( minStrike() <= K && K <= maxStrike() );
        }
        virtual bool checkMaturity(const Date& d) {
            return ( minMaturity() <= d && d <= maxMaturity() );
        }

        // defaults, mostly used for building yoy-fwd curve from put-call parity
        //  ext::shared_ptr<YieldTermStructure> nominal_;
        //  Period lag_;
        //  Calendar cal_;
        Natural fixingDays_;
        BusinessDayConvention bdc_;
        ext::shared_ptr<YoYInflationIndex> yoyIndex_;
        Handle<YieldTermStructure> nominalTS_;
        // data
        std::vector<Rate> cStrikes_;
        std::vector<Rate> fStrikes_;
        std::vector<Period> cfMaturities_;
        mutable std::vector<Real> cfMaturityTimes_;
        Matrix cPrice_;
        Matrix fPrice_;
        // constructed
        mutable std::vector<Rate> cfStrikes_;
        mutable ext::shared_ptr<YoYInflationTermStructure> yoy_;
        mutable std::pair<std::vector<Time>, std::vector<Rate> > atmYoYSwapTimeRates_;
        mutable std::pair<std::vector<Date>, std::vector<Rate> > atmYoYSwapDateRates_;
    };


    template<class Interpolator2D, class Interpolator1D>
    class InterpolatedYoYCapFloorTermPriceSurface
        : public YoYCapFloorTermPriceSurface {
      public:
        InterpolatedYoYCapFloorTermPriceSurface(
                      Natural fixingDays,
                      const Period &yyLag,  // observation lag
                      const ext::shared_ptr<YoYInflationIndex>& yii,
                      Rate baseRate,
                      const Handle<YieldTermStructure> &nominal,
                      const DayCounter &dc,
                      const Calendar &cal,
                      const BusinessDayConvention &bdc,
                      const std::vector<Rate> &cStrikes,
                      const std::vector<Rate> &fStrikes,
                      const std::vector<Period> &cfMaturities,
                      const Matrix &cPrice,
                      const Matrix &fPrice,
                      const Interpolator2D &interpolator2d = Interpolator2D(),
                      const Interpolator1D &interpolator1d = Interpolator1D());

        //! inflation term structure interface
        //@{
        Date maxDate() const override { return yoy_->maxDate(); }
        Date baseDate() const override { return yoy_->baseDate(); }
        //@}
        Natural fixingDays() const override { return fixingDays_; }

        //! \name YoYCapFloorTermPriceSurface interface
        //@{
        std::pair<std::vector<Time>, std::vector<Rate> > atmYoYSwapTimeRates() const override {
            return atmYoYSwapTimeRates_;
        }
        std::pair<std::vector<Date>, std::vector<Rate> > atmYoYSwapDateRates() const override {
            return atmYoYSwapDateRates_;
        }
        ext::shared_ptr<YoYInflationTermStructure> YoYTS() const override { return yoy_; }
        Rate price(const Date& d, Rate k) const override;
        Real floorPrice(const Date& d, Rate k) const override;
        Real capPrice(const Date& d, Rate k) const override;
        Rate atmYoYSwapRate(const Date& d, bool extrapolate = true) const override {
            return atmYoYSwapRateCurve_(timeFromReference(d),extrapolate);
        }
        Rate atmYoYRate(const Date& d,
                        const Period& obsLag = Period(-1, Days),
                        bool extrapolate = true) const override {
            // work in terms of maturity-of-instruments
            // so ask for rate with observation lag
            // Third parameter = force linear interpolation of yoy
            return yoy_->yoyRate(d, obsLag, false, extrapolate);
        }
        //@}

        //! \name LazyObject interface
        //@{
        void update() override;
        void performCalculations() const;
        //@}

      protected:
        //! intersection of cap and floor price surfaces at given strikes
        void intersect() const;
        class ObjectiveFunction {
          public:
            ObjectiveFunction(Time t, const Interpolation2D&, const Interpolation2D&);
            Real operator()(Rate guess) const;
          protected:
            const Time t_;
            const Interpolation2D &a_, &b_; // work on references
        };

        //! mess of making it, i.e. create instruments from quotes and bootstrap
        void calculateYoYTermStructure() const;

        // data for surfaces and curve
        mutable std::vector<Rate> cStrikesB_;
        mutable std::vector<Rate> fStrikesB_;
        mutable Matrix cPriceB_;
        mutable Matrix fPriceB_;
        mutable Interpolation2D capPrice_, floorPrice_;
        mutable Interpolation2D floorPrice2_;
        mutable Interpolator2D interpolator2d_;
        mutable Interpolation atmYoYSwapRateCurve_;
        mutable Interpolator1D interpolator1d_;
    };



    // template definitions

    #ifndef __DOXYGEN__

    template<class I2D, class I1D>
    InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    InterpolatedYoYCapFloorTermPriceSurface(
                                    Natural fixingDays,
                                    const Period &yyLag,
                                    const ext::shared_ptr<YoYInflationIndex>& yii,
                                    Rate baseRate,
                                    const Handle<YieldTermStructure> &nominal,
                                    const DayCounter &dc,
                                    const Calendar &cal,
                                    const BusinessDayConvention &bdc,
                                    const std::vector<Rate> &cStrikes,
                                    const std::vector<Rate> &fStrikes,
                                    const std::vector<Period> &cfMaturities,
                                    const Matrix &cPrice,
                                    const Matrix &fPrice,
                                    const I2D &interpolator2d,
                                    const I1D &interpolator1d)
    : YoYCapFloorTermPriceSurface(fixingDays, yyLag, yii,
                                  baseRate, nominal, dc, cal, bdc,
                                  cStrikes, fStrikes, cfMaturities,
                                  cPrice, fPrice),
      interpolator2d_(interpolator2d), interpolator1d_(interpolator1d) {
        performCalculations();
    }

    #endif

    template<class I2D, class I1D>
    void InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    update() {
        notifyObservers();
    }


    template<class I2D, class I1D>
    void InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    performCalculations() const {
        // calculate all the useful things
        // ... first the intersection of the cap and floor surfs
        intersect();

        // ... then the yoy term structure, which requires instruments
        // and a bootstrap
        calculateYoYTermStructure();
    }


    template<class I2D, class I1D>
    InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::ObjectiveFunction::
    ObjectiveFunction(const Time t,
                      const Interpolation2D &a,
                      const Interpolation2D &b)
    : t_(t), a_(a), b_(b) {
        // do nothing more
    }


    template<class I2D, class I1D>
    Rate InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    price(const Date &d, const Rate k) const {
        Rate atm = atmYoYSwapRate(d);
        return k > atm ? capPrice(d,k): floorPrice(d,k);
    }


    template<class I2D, class I1D>
    Rate InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    capPrice(const Date &d, const Rate k) const {
        Time t = timeFromReference(d);
        return capPrice_(t,k);
    }


    template<class I2D, class I1D>
    Rate InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    floorPrice(const Date &d, const Rate k) const {
        Time t = timeFromReference(d);
        return floorPrice_(t,k);
    }


    template<class I2D, class I1D>
    Real InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::ObjectiveFunction::
    operator()(Rate guess) const {
        // allow extrapolation because the overlap is typically insufficient
        // looking for a zero
        return ( a_(t_,guess,true) - b_(t_,guess,true) );
    }


    template<class I2D, class I1D>
    void InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    intersect() const {


        // TODO: define the constants outside the code
        const Real maxSearchRange = 0.0201;
        const Real maxExtrapolationMaturity = 5.01;
        const Real searchStep = 0.0050;
        const Real intrinsicValueAddOn = 0.001;

        std::vector<bool> validMaturity(cfMaturities_.size(),false);

        cfMaturityTimes_.clear();
        for (Size i=0; i<cfMaturities_.size();i++) {
            cfMaturityTimes_.push_back(timeFromReference(
                    yoyOptionDateFromTenor(cfMaturities_[i])));
        }

        capPrice_ = interpolator2d_.interpolate(
                            cfMaturityTimes_.begin(),cfMaturityTimes_.end(),
                            cStrikes_.begin(), cStrikes_.end(),
                            cPrice_
                            );
        capPrice_.enableExtrapolation();

        floorPrice_ = interpolator2d_.interpolate(
                            cfMaturityTimes_.begin(),cfMaturityTimes_.end(),
                            fStrikes_.begin(), fStrikes_.end(),
                            fPrice_
                            );
        floorPrice_.enableExtrapolation();

        atmYoYSwapDateRates_.first.clear();
        atmYoYSwapDateRates_.second.clear();
        atmYoYSwapTimeRates_.first.clear();
        atmYoYSwapTimeRates_.second.clear();
        Brent solver;
        Real solverTolerance_ = 1e-7;
        Real lo,hi,guess;
        std::vector<Real> minSwapRateIntersection(cfMaturityTimes_.size());
        std::vector<Real> maxSwapRateIntersection(cfMaturityTimes_.size());
        std::vector<Time> tmpSwapMaturities;
        std::vector<Rate> tmpSwapRates;
        for (Size i = 0; i < cfMaturities_.size(); i++) {
            Time t = cfMaturityTimes_[i];
            // determine the sum of discount factors
            Size numYears = (Size)std::lround(t);
            Real sumDiscount = 0.0;
            for (Size j=0; j<numYears; ++j)
                sumDiscount += nominalTS_->discount(j + 1.0);
            // determine the minimum value of the ATM swap point
            Real tmpMinSwapRateIntersection = -1.e10;
            Real tmpMaxSwapRateIntersection = 1.e10;
            for (Size j=0; j<fStrikes_.size(); ++j) {
                Real price = floorPrice_(t,fStrikes_[j]);
                Real minSwapRate = fStrikes_[j] - price / (sumDiscount * 10000);
                if (minSwapRate > tmpMinSwapRateIntersection)
                    tmpMinSwapRateIntersection = minSwapRate;
            }
            for (Size j=0; j<cStrikes_.size(); ++j) {
                Real price = capPrice_(t,cStrikes_[j]);
                Real maxSwapRate = cStrikes_[j] + price / (sumDiscount * 10000);
                if (maxSwapRate < tmpMaxSwapRateIntersection)
                    tmpMaxSwapRateIntersection = maxSwapRate;
            }
            maxSwapRateIntersection[i] = tmpMaxSwapRateIntersection;
            minSwapRateIntersection[i] = tmpMinSwapRateIntersection;

            // find the interval where the intersection lies
            bool trialsExceeded = false;
            int numTrials = (int)(maxSearchRange / searchStep);
            if ( floorPrice_(t,fStrikes_.back()) > capPrice_(t,fStrikes_.back()) ) {
                int counter = 1;
                bool stop = false;
                Real strike = 0.0;
                while (!stop) {
                    strike = fStrikes_.back() - counter * searchStep;
                    if (floorPrice_(t, strike) < capPrice_(t, strike))
                        stop = true;
                    counter++;
                    if (counter == numTrials + 1) {
                        if (!stop) {
                            stop = true;
                            trialsExceeded = true;
                        }
                    }
                }
                lo = strike;
                hi = strike + searchStep;
            } else {
                int counter = 1;
                bool stop = false;
                Real strike = 0.0;
                while (!stop) {
                    strike = fStrikes_.back() + counter * searchStep;
                    if (floorPrice_(t, strike) > capPrice_(t, strike))
                        stop = true;
                    counter++;
                    if (counter == numTrials + 1) {
                        if (!stop) {
                            stop = true;
                            trialsExceeded = true;
                        }
                    }
                }
                lo = strike - searchStep;
                hi = strike;
            }

            guess = (hi+lo)/2.0;
            Rate kI = -999.999;

            if (!trialsExceeded) {
                try{
                    kI = solver.solve(  ObjectiveFunction(t, capPrice_, floorPrice_), solverTolerance_, guess, lo, hi );
                } catch( std::exception &e) {
                    QL_FAIL("cap/floor intersection finding failed at t = " << t << ", error msg: "<< e.what());
                }
                // error message if kI is economically nonsensical (only if t is large)
                if (kI <= minSwapRateIntersection[i]) {
                    if (t > maxExtrapolationMaturity)
                        QL_FAIL("cap/floor intersection finding failed at t = " << t <<
                                ", error msg: intersection value is below the arbitrage free lower bound "
                                << minSwapRateIntersection[i]);
                }
                else
                {
                    tmpSwapMaturities.push_back(t);
                    tmpSwapRates.push_back(kI);
                    validMaturity[i] = true;
                }
            }
            else
            {
                // error message if t is too large
                if (t > maxExtrapolationMaturity)
                    QL_FAIL("cap/floor intersection finding failed at t = " << t <<
                            ", error msg: no interection found inside the admissible range");
            }
        }

        // extrapolation of swap rates if necessary
        //Polynomial2D tmpInterpol;
        //Interpolation interpol = tmpInterpol.interpolate(tmpSwapMaturities.begin(), tmpSwapMaturities.end(), tmpSwapRates.begin());
        //interpol.enableExtrapolation();
        int counter = 0;
        for (Size i=0; i<cfMaturities_.size(); ++i) {
            if ( !validMaturity[i] ) {
                atmYoYSwapDateRates_.first.push_back(referenceDate()+cfMaturities_[i]);
                atmYoYSwapTimeRates_.first.push_back(timeFromReference(referenceDate()+cfMaturities_[i]));
                // atmYoYSwapRates_->second.push_back(interpol((*cfMaturities_)[i]));
                // Heuristic: overwrite the the swap rate with a value that guarantees that the
                // intrinsic value of all options is lower than the price
                Real newSwapRate = minSwapRateIntersection[i] + intrinsicValueAddOn;
                if (newSwapRate > maxSwapRateIntersection[i])
                    newSwapRate = 0.5 * (minSwapRateIntersection[i] + maxSwapRateIntersection[i]);
                atmYoYSwapTimeRates_.second.push_back(newSwapRate);
                atmYoYSwapDateRates_.second.push_back(newSwapRate);
            } else {
                atmYoYSwapTimeRates_.first.push_back(tmpSwapMaturities[counter]);
                atmYoYSwapTimeRates_.second.push_back(tmpSwapRates[counter]);
                atmYoYSwapDateRates_.first.push_back(
                    yoyOptionDateFromTenor(cfMaturities_.at(counter)));
                atmYoYSwapDateRates_.second.push_back(tmpSwapRates[counter]);
                counter++;
            }
        }

        // create the swap curve using the factory
        atmYoYSwapRateCurve_ =
            interpolator1d_.interpolate(atmYoYSwapTimeRates_.first.begin(),
                                        atmYoYSwapTimeRates_.first.end(),
                                        atmYoYSwapTimeRates_.second.begin());
    }


    template<class I2D, class I1D>
    void InterpolatedYoYCapFloorTermPriceSurface<I2D,I1D>::
    calculateYoYTermStructure() const {

        // which yoy-swap points to use in building the yoy-fwd curve?
        // for now pick every year
        Size nYears = (Size)std::lround(timeFromReference(referenceDate()+cfMaturities_.back()));

        std::vector<ext::shared_ptr<BootstrapHelper<YoYInflationTermStructure> > > YYhelpers;
        for (Size i=1; i<=nYears; i++) {
            Date maturity = nominalTS_->referenceDate() + Period(i,Years);
            Handle<Quote> quote(ext::shared_ptr<Quote>(
                               new SimpleQuote( atmYoYSwapRate( maturity ) )));//!
            ext::shared_ptr<BootstrapHelper<YoYInflationTermStructure> >
            anInstrument(
                new YearOnYearInflationSwapHelper(
                                quote, observationLag(), maturity,
                                calendar(), bdc_, dayCounter(),
                                yoyIndex(), nominalTS_));
            YYhelpers.push_back (anInstrument);
        }

        // usually this base rate is known
        // however for the data to be self-consistent
        // we pick this as the end of the curve
        Rate baseYoYRate = atmYoYSwapRate( referenceDate() );//!

        // Linear is OK because we have every year
        ext::shared_ptr<PiecewiseYoYInflationCurve<Linear> >   pYITS(
              new PiecewiseYoYInflationCurve<Linear>(
                      nominalTS_->referenceDate(),
                      calendar(), dayCounter(), observationLag(), yoyIndex()->frequency(),
                      yoyIndex()->interpolated(), baseYoYRate,
                      YYhelpers));
        pYITS->recalculate();
        yoy_ = pYITS;   // store

        // check that helpers are repriced
        const Real eps = 1e-5;
        for (Size i=0; i<YYhelpers.size(); i++) {
            Rate original = atmYoYSwapRate( yoyOptionDateFromTenor(Period(i+1,Years)) );
            QL_REQUIRE(fabs(YYhelpers[i]->impliedQuote() - original) <eps,
                       "could not reprice helper "<< i
                       << ", data " << original
                       << ", implied quote " << YYhelpers[i]->impliedQuote()
            );
        }
    }

}


#endif
]]></document_content>
  </document>
  <document index="363">
    <source>inflation/yoyinflationoptionletvolatilitystructure2.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file yoyinflationoptionletvolatilitystructure2.hpp
    \brief experimental yoy inflation volatility structures
 */

#ifndef quantlib_yoy_optionlet_volatility_structures2_hpp
#define quantlib_yoy_optionlet_volatility_structures2_hpp

#include <ql/termstructures/voltermstructure.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>
#include <ql/termstructures/interpolatedcurve.hpp>
#include <ql/termstructures/volatility/inflation/yoyinflationoptionletvolatilitystructure.hpp>

namespace QuantLib {

    //! Interpolated flat smile surface
    /*! Interpolated in T direction and constant in K direction. */
    template <class Interpolator1D>
    class InterpolatedYoYOptionletVolatilityCurve
        : public YoYOptionletVolatilitySurface,
          protected InterpolatedCurve<Interpolator1D> {
    public:
        //! \name Constructor
        //@{
        //! calculate the reference date based on the global evaluation date
        /*! The dates are those of the volatility ... there is no lag
            on the dates <b>but</b> they are relative to a start date
            earlier than the reference date as always for inflation.
        */
        InterpolatedYoYOptionletVolatilityCurve(Natural settlementDays,
                                                const Calendar&,
                                                BusinessDayConvention bdc,
                                                const DayCounter& dc,
                                                const Period &lag,
                                                Frequency frequency,
                                                bool indexIsInterpolated,
                                                const std::vector<Date> &d,
                                                const std::vector<Volatility> &v,
                                                Rate minStrike,
                                                Rate maxStrike,
                                                const Interpolator1D &i =
                                                            Interpolator1D());
        //@}

        ~InterpolatedYoYOptionletVolatilityCurve() override = default;

        //! \name Limits
        //@{
        //! the minimum strike for which the term structure can return vols
        Real minStrike() const override { return minStrike_; }
        //! the maximum strike for which the term structure can return vols
        Real maxStrike() const override { return maxStrike_; }
        Date maxDate() const override {
            //FIXME approx
            return optionDateFromTenor(Period((int)ceil(this->interpolation_.xMax()),Years));
        }
        //@}

        //! \name Bootstrap interface
        //@{
        virtual const std::vector<Time>& times() const {return this->times_;}
        virtual const std::vector<Date>& dates() const {return dates_;}
        virtual const std::vector<Real>& data() const {return this->data_;}
        virtual std::vector<std::pair<Date, Real> > nodes() const {return nodes_;}
        //@}

    protected:
        // we need a second constructor for when we have no data
        // this is protected as we only expect to use it in the
        // piecewise versions
        InterpolatedYoYOptionletVolatilityCurve(Natural settlementDays,
                                                const Calendar&,
                                                BusinessDayConvention bdc,
                                                const DayCounter& dc,
                                                const Period &lag,
                                                Frequency frequency,
                                                bool indexIsInterpolated,
                                                Rate minStrike,
                                                Rate maxStrike,
                                                Volatility baseYoYVolatility,
                                                const Interpolator1D &i =
                                                            Interpolator1D());

        // we do specify data representation here
        // because the bootstrapper needs this specifically
        mutable std::vector<Date> dates_;
        std::vector<std::pair<Date, Real> > nodes_;
        //@}

        //! implements the actual volatility calculation in derived classes
        Volatility volatilityImpl(Time length, Rate strike) const override;

        Rate minStrike_, maxStrike_;
    };



    template<class Interpolator1D>
    InterpolatedYoYOptionletVolatilityCurve<Interpolator1D>::
    InterpolatedYoYOptionletVolatilityCurve(Natural settlementDays,
                                            const Calendar &cal,
                                            BusinessDayConvention bdc,
                                            const DayCounter& dc,
                                            const Period &lag,
                                            Frequency frequency,
                                            bool indexIsInterpolated,
                                            const std::vector<Date> &d,
                                            const std::vector<Volatility> &v,
                                            Rate minStrike,
                                            Rate maxStrike,
                                            const Interpolator1D &i)
    : YoYOptionletVolatilitySurface(settlementDays, cal, bdc, dc, lag,
                                    frequency, indexIsInterpolated),
      InterpolatedCurve<Interpolator1D>(i),
      dates_(d), minStrike_(minStrike), maxStrike_(maxStrike) {
        QL_REQUIRE(d.size() == v.size(),
                   "must have same number of dates and vols: "
                   << d.size() << " vs " << v.size());
        QL_REQUIRE(d.size() > 1,
                   "must have at least two dates: " << d.size());

        for (Size j = 0; j < d.size(); j++ ){
            this->times_.push_back( this->timeFromReference(dates_[j]) );
            this->data_.push_back(v[j]),
            nodes_.push_back( std::make_pair( dates_[j], this->data_[j]) );
        }

        this->setupInterpolation();
        // set the base vol level to that predicted by the interpolation
        // this is allowed by the extrapolation
        Time baseTime = this->timeFromReference(baseDate());
        setBaseLevel(this->interpolation_(baseTime,true));
    }


    template<class Interpolator1D>
    InterpolatedYoYOptionletVolatilityCurve<Interpolator1D>::
    InterpolatedYoYOptionletVolatilityCurve(Natural settlementDays,
                                            const Calendar &cal,
                                            BusinessDayConvention bdc,
                                            const DayCounter& dc,
                                            const Period &lag,
                                            Frequency frequency,
                                            bool indexIsInterpolated,
                                            Rate minStrike,
                                            Rate maxStrike,
                                            Volatility baseYoYVolatility,
                                            const Interpolator1D &i)
    : YoYOptionletVolatilitySurface(settlementDays, cal, bdc, dc, lag,
                                    frequency, indexIsInterpolated),
      InterpolatedCurve<Interpolator1D>(i),
      minStrike_(minStrike), maxStrike_(maxStrike) {
        // don't have the data yet except for the base volatility
        // must set to communicate with bootstrap
        setBaseLevel(baseYoYVolatility);
    }



    //! For the curve strike is ignored because the smile is (can only be) flat.
    template<class Interpolator1D>
    inline Volatility InterpolatedYoYOptionletVolatilityCurve<Interpolator1D>::
    volatilityImpl(const Time t,
                   Rate) const {
        return this->interpolation_(t);
    }

} // namespace QuantLib

#endif
]]></document_content>
  </document>
  <document index="364">
    <source>inflation/yoyoptionlethelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/inflation/yoyoptionlethelpers.hpp>
#include <ql/instruments/makeyoyinflationcapfloor.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    YoYOptionletHelper::YoYOptionletHelper(const Handle<Quote>& price,
                                           Real notional,
                                           YoYInflationCapFloor::Type capFloorType,
                                           Period& lag,
                                           DayCounter yoyDayCounter,
                                           Calendar paymentCalendar,
                                           Natural fixingDays,
                                           ext::shared_ptr<YoYInflationIndex> index,
                                           Rate strike,
                                           Size n,
                                           ext::shared_ptr<YoYInflationCapFloorEngine> pricer)
    : BootstrapHelper<YoYOptionletVolatilitySurface>(price), notional_(notional),
      capFloorType_(capFloorType), lag_(lag), fixingDays_(fixingDays), index_(std::move(index)),
      strike_(strike), n_(n), yoyDayCounter_(std::move(yoyDayCounter)),
      calendar_(std::move(paymentCalendar)), pricer_(std::move(pricer)) {

        // build the instrument to reprice (only need do this once)
        yoyCapFloor_ =
            MakeYoYInflationCapFloor(capFloorType_, index_,
                                     n_, calendar_, lag_)
            .withNominal(notional)
            .withFixingDays(fixingDays_)
            .withPaymentDayCounter(yoyDayCounter_)
            .withStrike(strike_);

        // dates already build in lag of index/instrument
        // these are the dates of the values of the index
        // that fix the capfloor
          earliestDate_ = ext::dynamic_pointer_cast<YoYInflationCoupon>(
              yoyCapFloor_->yoyLeg().front())->fixingDate();
          latestDate_ = ext::dynamic_pointer_cast<YoYInflationCoupon>(
              yoyCapFloor_->yoyLeg().back())->fixingDate();

        // each reprice is resetting the inflation surf in the
        // pricer... so set the pricer
        yoyCapFloor_->setPricingEngine(pricer_);
        // haven't yet set the vol (term structure = surface)
    }


    Real YoYOptionletHelper::impliedQuote() const {
        yoyCapFloor_->recalculate();
        return yoyCapFloor_->NPV();
    }


    void YoYOptionletHelper::setTermStructure(
                                           YoYOptionletVolatilitySurface* v) {

        BootstrapHelper<YoYOptionletVolatilitySurface>::setTermStructure(v);
        // set up a new yoyCapFloor
        // but this one does NOT own its inflation term structure
        const bool own = false;
        // create a handle to the new vol surface
        Handle<YoYOptionletVolatilitySurface> volSurf(
            ext::shared_ptr<YoYOptionletVolatilitySurface>(v, null_deleter()),
            own);
        // in this case all we need to do is reset the vol in the pricer
        // we must do it because the surface is a different one each time
        // i.e. the pointer (handle) changes, not just what it points to
        pricer_->setVolatility(volSurf);
    }

}

]]></document_content>
  </document>
  <document index="365">
    <source>inflation/yoyoptionlethelpers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file yoyoptionlethelpers.hpp
    \brief helpers for YoY inflation-volatility bootstrap
*/

#ifndef quantlib_yoy_optionlet_helpers_hpp
#define quantlib_yoy_optionlet_helpers_hpp

#include <ql/experimental/inflation/yoyinflationoptionletvolatilitystructure2.hpp>
#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>
#include <ql/termstructures/bootstraphelper.hpp>

namespace QuantLib {

    //! Year-on-year inflation-volatility bootstrap helper.
    class YoYOptionletHelper
        : public BootstrapHelper<YoYOptionletVolatilitySurface> {
      public:
        YoYOptionletHelper(const Handle<Quote>& price,
                           Real notional, // get the price level right
                                          // (e.g. bps = 10,000)
                           YoYInflationCapFloor::Type capFloorType,
                           Period& lag,
                           DayCounter yoyDayCounter,
                           Calendar paymentCalendar,
                           Natural fixingDays,
                           ext::shared_ptr<YoYInflationIndex> index,
                           Rate strike,
                           Size n,
                           ext::shared_ptr<YoYInflationCapFloorEngine> pricer);
        void setTermStructure(YoYOptionletVolatilitySurface*) override;
        Real impliedQuote() const override;

      protected:
        Real notional_; // get the price level right (e.g. bps = 10,000)
        YoYInflationCapFloor::Type capFloorType_;
        Period lag_;
        Natural fixingDays_;
        ext::shared_ptr<YoYInflationIndex> index_;  // VERY important - has
                                                      // nominal & yoy curves
        Rate strike_;
        Size n_;  // how many payments
        DayCounter yoyDayCounter_;
        Calendar calendar_;
        ext::shared_ptr<YoYInflationCapFloorEngine> pricer_;
        // what you make
        ext::shared_ptr<YoYInflationCapFloor> yoyCapFloor_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="366">
    <source>inflation/yoyoptionletstripper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file yoyoptionletstripper.hpp
    \brief yoy inflation-cap stripping
*/

#ifndef quantlib_yoy_optionlet_stripper_hpp
#define quantlib_yoy_optionlet_stripper_hpp

#include <ql/experimental/inflation/yoyinflationoptionletvolatilitystructure2.hpp>
#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>
#include <ql/experimental/inflation/yoycapfloortermpricesurface.hpp>

namespace QuantLib {

    //! Interface for inflation cap stripping, i.e. from price surfaces.
    /*! Strippers return K slices of the volatility surface at a given T.
        In initialize they actually do the stripping along each K.
    */
    class YoYOptionletStripper {
      public:
        virtual ~YoYOptionletStripper() = default;

        //! YoYOptionletStripper interface
        //@{
        virtual void initialize(const ext::shared_ptr<YoYCapFloorTermPriceSurface>&,
                                const ext::shared_ptr<YoYInflationCapFloorEngine>&,
                                Real slope) const = 0;
        virtual Rate minStrike() const = 0;
        virtual Rate maxStrike() const = 0;
        virtual std::vector<Rate> strikes() const = 0;
        virtual std::pair<std::vector<Rate>, std::vector<Volatility> >
        slice(const Date &d) const = 0;
        //@}

      protected:
        mutable ext::shared_ptr<YoYCapFloorTermPriceSurface>
                                                 YoYCapFloorTermPriceSurface_;
        mutable ext::shared_ptr<YoYInflationCapFloorEngine> p_;
        mutable Period lag_;
        mutable Frequency frequency_;
        mutable bool indexIsInterpolated_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="367">
    <source>lattices/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    extendedbinomialtree.hpp

cpp_files = \
    extendedbinomialtree.cpp

if UNITY_BUILD

nodist_libLattices_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libLattices_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libLattices.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="368">
    <source>lattices/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/lattices/extendedbinomialtree.hpp>

]]></document_content>
  </document>
  <document index="369">
    <source>lattices/extendedbinomialtree.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2005 StatPro Italia srl
 Copyright (C) 2008 John Maiden

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/lattices/extendedbinomialtree.hpp>
#include <ql/math/distributions/binomialdistribution.hpp>

namespace QuantLib {

    ExtendedJarrowRudd::ExtendedJarrowRudd(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : ExtendedEqualProbabilitiesBinomialTree<ExtendedJarrowRudd>(
                                                        process, end, steps) {
        // drift removed
        up_ = process->stdDeviation(0.0, x0_, dt_);
    }

    Real ExtendedJarrowRudd::upStep(Time stepTime) const {
        return treeProcess_->stdDeviation(stepTime, x0_, dt_);
    }



    ExtendedCoxRossRubinstein::ExtendedCoxRossRubinstein(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : ExtendedEqualJumpsBinomialTree<ExtendedCoxRossRubinstein>(
                                                        process, end, steps) {

        dx_ = process->stdDeviation(0.0, x0_, dt_);
        pu_ = 0.5 + 0.5*this->driftStep(0.0)/dx_;
        pd_ = 1.0 - pu_;

        QL_REQUIRE(pu_<=1.0, "negative probability");
        QL_REQUIRE(pu_>=0.0, "negative probability");
    }

    Real ExtendedCoxRossRubinstein::dxStep(Time stepTime) const {
        return this->treeProcess_->stdDeviation(stepTime, x0_, dt_);
    }

    Real ExtendedCoxRossRubinstein::probUp(Time stepTime) const {
        return 0.5 + 0.5*this->driftStep(stepTime)/dxStep(stepTime);
    }


    ExtendedAdditiveEQPBinomialTree::ExtendedAdditiveEQPBinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : ExtendedEqualProbabilitiesBinomialTree<ExtendedAdditiveEQPBinomialTree>(
                                                        process, end, steps) {

          up_ = - 0.5 * this->driftStep(0.0) + 0.5 *
            std::sqrt(4.0*process->variance(0.0, x0_, dt_)-
                      3.0*this->driftStep(0.0)*this->driftStep(0.0));
    }

    Real ExtendedAdditiveEQPBinomialTree::upStep(Time stepTime) const {
        return (- 0.5 * this->driftStep(stepTime) + 0.5 *
            std::sqrt(4.0*this->treeProcess_->variance(stepTime, x0_, dt_)-
            3.0*this->driftStep(stepTime)*this->driftStep(stepTime)));
    }




    ExtendedTrigeorgis::ExtendedTrigeorgis(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : ExtendedEqualJumpsBinomialTree<ExtendedTrigeorgis>(process, end, steps) {

        dx_ = std::sqrt(process->variance(0.0, x0_, dt_)+
            this->driftStep(0.0)*this->driftStep(0.0));
        pu_ = 0.5 + 0.5*this->driftStep(0.0)/this->dxStep(0.0);
        pd_ = 1.0 - pu_;

        QL_REQUIRE(pu_<=1.0, "negative probability");
        QL_REQUIRE(pu_>=0.0, "negative probability");
    }

    Real ExtendedTrigeorgis::dxStep(Time stepTime) const {
        return std::sqrt(this->treeProcess_->variance(stepTime, x0_, dt_)+
            this->driftStep(stepTime)*this->driftStep(stepTime));
    }

    Real ExtendedTrigeorgis::probUp(Time stepTime) const {
        return 0.5 + 0.5*this->driftStep(stepTime)/dxStep(stepTime);
    }


    ExtendedTian::ExtendedTian(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : ExtendedBinomialTree<ExtendedTian>(process, end, steps) {

        Real q = std::exp(process->variance(0.0, x0_, dt_));

        Real r = std::exp(this->driftStep(0.0))*std::sqrt(q);

        up_ = 0.5 * r * q * (q + 1 + std::sqrt(q * q + 2 * q - 3));
        down_ = 0.5 * r * q * (q + 1 - std::sqrt(q * q + 2 * q - 3));

        pu_ = (r - down_) / (up_ - down_);
        pd_ = 1.0 - pu_;

        // doesn't work
        //     treeCentering_ = (up_+down_)/2.0;
        //     up_ = up_-treeCentering_;

        QL_REQUIRE(pu_<=1.0, "negative probability");
        QL_REQUIRE(pu_>=0.0, "negative probability");
    }

    Real ExtendedTian::underlying(Size i, Size index) const {
        Time stepTime = i*this->dt_;
        Real q = std::exp(this->treeProcess_->variance(stepTime, x0_, dt_));
        Real r = std::exp(this->driftStep(stepTime))*std::sqrt(q);

        Real up = 0.5 * r * q * (q + 1 + std::sqrt(q * q + 2 * q - 3));
        Real down = 0.5 * r * q * (q + 1 - std::sqrt(q * q + 2 * q - 3));

        return x0_ * std::pow(down, Real(BigInteger(i)-BigInteger(index)))
            * std::pow(up, Real(index));
    }

    Real ExtendedTian::probability(Size i, Size, Size branch) const {
        Time stepTime = i*this->dt_;
        Real q = std::exp(this->treeProcess_->variance(stepTime, x0_, dt_));
        Real r = std::exp(this->driftStep(stepTime))*std::sqrt(q);

        Real up = 0.5 * r * q * (q + 1 + std::sqrt(q * q + 2 * q - 3));
        Real down = 0.5 * r * q * (q + 1 - std::sqrt(q * q + 2 * q - 3));

        Real pu = (r - down) / (up - down);
        Real pd = 1.0 - pu;

        return (branch == 1 ? pu : pd);
    }


    ExtendedLeisenReimer::ExtendedLeisenReimer(const ext::shared_ptr<StochasticProcess1D>& process,
                                               Time end,
                                               Size steps,
                                               Real strike)
    : ExtendedBinomialTree<ExtendedLeisenReimer>(
          process, end, ((steps % 2) != 0U ? steps : steps + 1)),
      end_(end), oddSteps_((steps % 2) != 0U ? steps : steps + 1), strike_(strike) {

        QL_REQUIRE(strike>0.0, "strike " << strike << "must be positive");
        Real variance = process->variance(0.0, x0_, end);

        Real ermqdt = std::exp(this->driftStep(0.0) + 0.5*variance/oddSteps_);
        Real d2 = (std::log(x0_/strike) + this->driftStep(0.0)*oddSteps_ ) /
            std::sqrt(variance);

        pu_ = PeizerPrattMethod2Inversion(d2, oddSteps_);
        pd_ = 1.0 - pu_;
        Real pdash = PeizerPrattMethod2Inversion(d2+std::sqrt(variance),
                                                 oddSteps_);
        up_ = ermqdt * pdash / pu_;
        down_ = (ermqdt - pu_ * up_) / (1.0 - pu_);
    }

    Real ExtendedLeisenReimer::underlying(Size i, Size index) const {
        Time stepTime = i*this->dt_;
        Real variance = this->treeProcess_->variance(stepTime, x0_, end_);
        Real ermqdt = std::exp(this->driftStep(stepTime) + 0.5*variance/oddSteps_);
        Real d2 = (std::log(x0_/strike_) + this->driftStep(stepTime)*oddSteps_ ) /
            std::sqrt(variance);

        Real pu = PeizerPrattMethod2Inversion(d2, oddSteps_);
        Real pdash = PeizerPrattMethod2Inversion(d2+std::sqrt(variance),
            oddSteps_);
        Real up = ermqdt * pdash / pu;
        Real down = (ermqdt - pu * up) / (1.0 - pu);

        return x0_ * std::pow(down, Real(BigInteger(i)-BigInteger(index)))
            * std::pow(up, Real(index));
    }

    Real ExtendedLeisenReimer::probability(Size i, Size, Size branch) const {
        Time stepTime = i*this->dt_;
        Real variance = this->treeProcess_->variance(stepTime, x0_, end_);
        Real d2 = (std::log(x0_/strike_) + this->driftStep(stepTime)*oddSteps_ ) /
            std::sqrt(variance);

        Real pu = PeizerPrattMethod2Inversion(d2, oddSteps_);
        Real pd = 1.0 - pu;

        return (branch == 1 ? pu : pd);
    }



    Real ExtendedJoshi4::computeUpProb(Real k, Real dj) const {
        Real alpha = dj/(std::sqrt(8.0));
        Real alpha2 = alpha*alpha;
        Real alpha3 = alpha*alpha2;
        Real alpha5 = alpha3*alpha2;
        Real alpha7 = alpha5*alpha2;
        Real beta = -0.375*alpha-alpha3;
        Real gamma = (5.0/6.0)*alpha5 + (13.0/12.0)*alpha3
            +(25.0/128.0)*alpha;
        Real delta = -0.1025 *alpha- 0.9285 *alpha3
            -1.43 *alpha5 -0.5 *alpha7;
        Real p =0.5;
        Real rootk= std::sqrt(k);
        p+= alpha/rootk;
        p+= beta /(k*rootk);
        p+= gamma/(k*k*rootk);
        // delete next line to get results for j three tree
        p+= delta/(k*k*k*rootk);
        return p;
    }

    ExtendedJoshi4::ExtendedJoshi4(const ext::shared_ptr<StochasticProcess1D>& process,
                                   Time end,
                                   Size steps,
                                   Real strike)
    : ExtendedBinomialTree<ExtendedJoshi4>(process, end, ((steps % 2) != 0U ? steps : steps + 1)),
      end_(end), oddSteps_((steps % 2) != 0U ? steps : steps + 1), strike_(strike) {

        QL_REQUIRE(strike>0.0, "strike " << strike << "must be positive");
        Real variance = process->variance(0.0, x0_, end);

        Real ermqdt = std::exp(this->driftStep(0.0) + 0.5*variance/oddSteps_);
        Real d2 = (std::log(x0_/strike) + this->driftStep(0.0)*oddSteps_ ) /
            std::sqrt(variance);

        pu_ = computeUpProb((oddSteps_-1.0)/2.0,d2 );
        pd_ = 1.0 - pu_;
        Real pdash = computeUpProb((oddSteps_-1.0)/2.0,d2+std::sqrt(variance));
        up_ = ermqdt * pdash / pu_;
        down_ = (ermqdt - pu_ * up_) / (1.0 - pu_);
    }

    Real ExtendedJoshi4::underlying(Size i, Size index) const {
        Time stepTime = i*this->dt_;
        Real variance = this->treeProcess_->variance(stepTime, x0_, end_);
        Real ermqdt = std::exp(this->driftStep(stepTime) + 0.5*variance/oddSteps_);
        Real d2 = (std::log(x0_/strike_) + this->driftStep(stepTime)*oddSteps_ ) /
            std::sqrt(variance);

        Real pu = computeUpProb((oddSteps_-1.0)/2.0,d2 );
        Real pdash = computeUpProb((oddSteps_-1.0)/2.0,d2+std::sqrt(variance));
        Real up = ermqdt * pdash / pu;
        Real down = (ermqdt - pu * up) / (1.0 - pu);

        return x0_ * std::pow(down, Real(BigInteger(i)-BigInteger(index)))
            * std::pow(up, Real(index));
    }

    Real ExtendedJoshi4::probability(Size i, Size, Size branch) const {
        Time stepTime = i*this->dt_;
        Real variance = this->treeProcess_->variance(stepTime, x0_, end_);
        Real d2 = (std::log(x0_/strike_) + this->driftStep(stepTime)*oddSteps_ ) /
            std::sqrt(variance);

        Real pu = computeUpProb((oddSteps_-1.0)/2.0,d2 );
        Real pd = 1.0 - pu;

        return (branch == 1 ? pu : pd);
    }

}
]]></document_content>
  </document>
  <document index="370">
    <source>lattices/extendedbinomialtree.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2005 StatPro Italia srl
 Copyright (C) 2008 John Maiden

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extendedbinomialtree.hpp
    \brief Time-dependent binomial tree class
*/

#ifndef quantlib_extended_binomial_tree_hpp
#define quantlib_extended_binomial_tree_hpp

#include <ql/methods/lattices/tree.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    //! Binomial tree base class
    /*! \ingroup lattices */
    template <class T>
    class ExtendedBinomialTree : public Tree<T> {
      public:
        enum Branches { branches = 2 };
        ExtendedBinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end,
                        Size steps)
        : Tree<T>(steps+1), x0_(process->x0()), dt_(end/steps),
          treeProcess_(process) {}
        Size size(Size i) const {
            return i+1;
        }
        Size descendant(Size, Size index, Size branch) const {
            return index + branch;
        }
      protected:
        //time dependent drift per step
        Real driftStep(Time driftTime) const {
            return this->treeProcess_->drift(driftTime, x0_) * dt_;
        }

        Real x0_;
        Time dt_;


        ext::shared_ptr<StochasticProcess1D> treeProcess_;
    };


    //! Base class for equal probabilities binomial tree
    /*! \ingroup lattices */
    template <class T>
    class ExtendedEqualProbabilitiesBinomialTree
        : public ExtendedBinomialTree<T> {
      public:
        ExtendedEqualProbabilitiesBinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end,
                        Size steps)
        : ExtendedBinomialTree<T>(process, end, steps) {}
        virtual ~ExtendedEqualProbabilitiesBinomialTree() = default;

        Real underlying(Size i, Size index) const {
            Time stepTime = i*this->dt_;
            BigInteger j = 2*BigInteger(index) - BigInteger(i);
            // exploiting the forward value tree centering
            return this->x0_*std::exp(i*this->driftStep(stepTime) + j*this->upStep(stepTime));
        }

        Real probability(Size, Size, Size) const { return 0.5; }
      protected:
        //the tree dependent up move term at time stepTime
        virtual Real upStep(Time stepTime) const = 0;
        Real up_;
    };


    //! Base class for equal jumps binomial tree
    /*! \ingroup lattices */
    template <class T>
    class ExtendedEqualJumpsBinomialTree : public ExtendedBinomialTree<T> {
      public:
        ExtendedEqualJumpsBinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end,
                        Size steps)
        : ExtendedBinomialTree<T>(process, end, steps) {}
        virtual ~ExtendedEqualJumpsBinomialTree() = default;

        Real underlying(Size i, Size index) const {
            Time stepTime = i*this->dt_;
            BigInteger j = 2*BigInteger(index) - BigInteger(i);
            // exploiting equal jump and the x0_ tree centering
            return this->x0_*std::exp(j*this->dxStep(stepTime));
        }

        Real probability(Size i, Size, Size branch) const {
            Time stepTime = i*this->dt_;
            Real upProb = this->probUp(stepTime);
            Real downProb = 1 - upProb;
            return (branch == 1 ? upProb : downProb);
        }
      protected:
        //probability of a up move
        virtual Real probUp(Time stepTime) const = 0;
        //time dependent term dx_
        virtual Real dxStep(Time stepTime) const = 0;

        Real dx_, pu_, pd_;
    };


    //! Jarrow-Rudd (multiplicative) equal probabilities binomial tree
    /*! \ingroup lattices */
    class ExtendedJarrowRudd
        : public ExtendedEqualProbabilitiesBinomialTree<ExtendedJarrowRudd> {
      public:
        ExtendedJarrowRudd(const ext::shared_ptr<StochasticProcess1D>&,
                           Time end,
                           Size steps,
                           Real strike);
      protected:
        Real upStep(Time stepTime) const override;
    };


    //! Cox-Ross-Rubinstein (multiplicative) equal jumps binomial tree
    /*! \ingroup lattices */
    class ExtendedCoxRossRubinstein
        : public ExtendedEqualJumpsBinomialTree<ExtendedCoxRossRubinstein> {
      public:
        ExtendedCoxRossRubinstein(const ext::shared_ptr<StochasticProcess1D>&,
                                  Time end,
                                  Size steps,
                                  Real strike);
      protected:
        Real dxStep(Time stepTime) const override;
        Real probUp(Time stepTime) const override;
    };


    //! Additive equal probabilities binomial tree
    /*! \ingroup lattices */
    class ExtendedAdditiveEQPBinomialTree
        : public ExtendedEqualProbabilitiesBinomialTree<
                                            ExtendedAdditiveEQPBinomialTree> {
      public:
        ExtendedAdditiveEQPBinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>&,
                        Time end,
                        Size steps,
                        Real strike);

      protected:
        Real upStep(Time stepTime) const override;
    };


    //! %Trigeorgis (additive equal jumps) binomial tree
    /*! \ingroup lattices */
    class ExtendedTrigeorgis
        : public ExtendedEqualJumpsBinomialTree<ExtendedTrigeorgis> {
      public:
        ExtendedTrigeorgis(const ext::shared_ptr<StochasticProcess1D>&,
                           Time end,
                           Size steps,
                           Real strike);
    protected:
      Real dxStep(Time stepTime) const override;
      Real probUp(Time stepTime) const override;
    };


    //! %Tian tree: third moment matching, multiplicative approach
    /*! \ingroup lattices */
    class ExtendedTian : public ExtendedBinomialTree<ExtendedTian> {
      public:
        ExtendedTian(const ext::shared_ptr<StochasticProcess1D>&,
                     Time end,
                     Size steps,
                     Real strike);

        Real underlying(Size i, Size index) const;
        Real probability(Size, Size, Size branch) const;
      protected:
        Real up_, down_, pu_, pd_;
    };

    //! Leisen & Reimer tree: multiplicative approach
    /*! \ingroup lattices */
    class ExtendedLeisenReimer
        : public ExtendedBinomialTree<ExtendedLeisenReimer> {
      public:
        ExtendedLeisenReimer(const ext::shared_ptr<StochasticProcess1D>&,
                             Time end,
                             Size steps,
                             Real strike);

        Real underlying(Size i, Size index) const;
        Real probability(Size, Size, Size branch) const;
      protected:
        Time end_;
        Size oddSteps_;
        Real strike_, up_, down_, pu_, pd_;
    };


     class ExtendedJoshi4 : public ExtendedBinomialTree<ExtendedJoshi4> {
      public:
        ExtendedJoshi4(const ext::shared_ptr<StochasticProcess1D>&,
                       Time end,
                       Size steps,
                       Real strike);

        Real underlying(Size i, Size index) const;
        Real probability(Size, Size, Size branch) const;
      protected:
        Real computeUpProb(Real k, Real dj) const;
        Time end_;
        Size oddSteps_;
        Real strike_, up_, down_, pu_, pd_;
    };


}


#endif
]]></document_content>
  </document>
  <document index="371">
    <source>math/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    claytoncopularng.hpp \
    convolvedstudentt.hpp \
    expm.hpp \
    farliegumbelmorgensterncopularng.hpp \
    fireflyalgorithm.hpp \
    frankcopularng.hpp \
    gaussiancopulapolicy.hpp \
    gaussiannoncentralchisquaredpolynomial.hpp \
    hybridsimulatedannealing.hpp \
    hybridsimulatedannealingfunctors.hpp \
    isotropicrandomwalk.hpp \
    laplaceinterpolation.hpp \
    latentmodel.hpp \
    levyflightdistribution.hpp \
    moorepenroseinverse.hpp \
    multidimintegrator.hpp \
    multidimquadrature.hpp \
    particleswarmoptimization.hpp \
    piecewisefunction.hpp \
    piecewiseintegral.hpp \
    polarstudenttrng.hpp \
    tcopulapolicy.hpp \
    zigguratrng.hpp

cpp_files = \
    convolvedstudentt.cpp \
    expm.cpp \
    fireflyalgorithm.cpp \
    gaussiancopulapolicy.cpp \
    gaussiannoncentralchisquaredpolynomial.cpp \
    multidimintegrator.cpp \
    multidimquadrature.cpp \
    particleswarmoptimization.cpp \
    piecewiseintegral.cpp \
    tcopulapolicy.cpp \
    zigguratrng.cpp

if UNITY_BUILD

nodist_libMath_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libMath_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libMath.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="372">
    <source>math/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/math/claytoncopularng.hpp>
#include <ql/experimental/math/convolvedstudentt.hpp>
#include <ql/experimental/math/expm.hpp>
#include <ql/experimental/math/farliegumbelmorgensterncopularng.hpp>
#include <ql/experimental/math/fireflyalgorithm.hpp>
#include <ql/experimental/math/frankcopularng.hpp>
#include <ql/experimental/math/gaussiancopulapolicy.hpp>
#include <ql/experimental/math/gaussiannoncentralchisquaredpolynomial.hpp>
#include <ql/experimental/math/hybridsimulatedannealing.hpp>
#include <ql/experimental/math/hybridsimulatedannealingfunctors.hpp>
#include <ql/experimental/math/isotropicrandomwalk.hpp>
#include <ql/experimental/math/laplaceinterpolation.hpp>
#include <ql/experimental/math/latentmodel.hpp>
#include <ql/experimental/math/levyflightdistribution.hpp>
#include <ql/experimental/math/moorepenroseinverse.hpp>
#include <ql/experimental/math/multidimintegrator.hpp>
#include <ql/experimental/math/multidimquadrature.hpp>
#include <ql/experimental/math/particleswarmoptimization.hpp>
#include <ql/experimental/math/piecewisefunction.hpp>
#include <ql/experimental/math/piecewiseintegral.hpp>
#include <ql/experimental/math/polarstudenttrng.hpp>
#include <ql/experimental/math/tcopulapolicy.hpp>
#include <ql/experimental/math/zigguratrng.hpp>

]]></document_content>
  </document>
  <document index="373">
    <source>math/claytoncopularng.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file claytoncopularng.hpp
    \brief Clayton copula random-number generator
*/

#ifndef quantlib_clayton_copula_rng_hpp
#define quantlib_clayton_copula_rng_hpp

#include <ql/methods/montecarlo/sample.hpp>
#include <ql/errors.hpp>
#include <vector>

namespace QuantLib {

    //! Clayton copula random-number generator
    template <class RNG>
    class ClaytonCopulaRng {
      public:
        typedef Sample<std::vector<Real> > sample_type;
        typedef RNG urng_type;
        explicit ClaytonCopulaRng(const RNG& uniformGenerator,Real theta);
        sample_type next() const;
      private:
        Real theta_;
        RNG uniformGenerator_;
    };

    template <class RNG>
    ClaytonCopulaRng<RNG>::ClaytonCopulaRng(const RNG& ug, Real th)
    : uniformGenerator_(ug), theta_(th) {
        QL_REQUIRE(th >= -1.0,
                   "theta (" << th << ") must be greater or equal to -1");
        QL_REQUIRE(th != 0.0,
                   "theta (" << th << ") must be different from 0");
    }

    template <class RNG>
    inline typename ClaytonCopulaRng<RNG>::sample_type
    ClaytonCopulaRng<RNG>::next() const {
        typename RNG::sample_type v1 = uniformGenerator_.next();
        typename RNG::sample_type v2 = uniformGenerator_.next();
        Real u1 = v1.value;
        Real u2 = std::pow(std::pow(v1.value,-theta_)*(std::pow(v2.value,-theta_/(theta_+1.0))-1.0)+1.0,-1.0/theta_);
        std::vector<Real> u;
        u.push_back(u1);
        u.push_back(u2);
        return sample_type(u,v1.weight*v2.weight);
    }

}


#endif
]]></document_content>
  </document>
  <document index="374">
    <source>math/convolvedstudentt.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/convolvedstudentt.hpp>
#include <ql/errors.hpp>
#include <ql/math/factorial.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/functional.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#include <boost/math/distributions/students_t.hpp>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

namespace QuantLib {

    CumulativeBehrensFisher::CumulativeBehrensFisher(const std::vector<Integer>& degreesFreedom,
                                                     const std::vector<Real>& factors)
    : degreesFreedom_(degreesFreedom), factors_(factors), polyConvolved_(std::vector<Real>(1, 1.))

    {
        QL_REQUIRE(degreesFreedom.size() == factors.size(),
            "Incompatible sizes in convolution.");
        for (int i : degreesFreedom) {
            QL_REQUIRE(i % 2 != 0, "Even degree of freedom not allowed");
            QL_REQUIRE(i >= 0, "Negative degree of freedom not allowed");
        }
        for(Size i=0; i<degreesFreedom_.size(); i++)
            polynCharFnc_.push_back(polynCharactT((degreesFreedom[i]-1)/2));
        // adjust the polynomial coefficients by the factors in the linear
        //   combination:
        for(Size i=0; i<degreesFreedom_.size(); i++) {
            Real multiplier = 1.;
            for(Size k=1; k<polynCharFnc_[i].size(); k++) {
                multiplier *= std::abs(factors_[i]);
                polynCharFnc_[i][k] *= multiplier;
            }
        }
        //convolution, here it is a product of polynomials and exponentials
        for (auto& i : polynCharFnc_)
            polyConvolved_ = convolveVectorPolynomials(polyConvolved_, i);
        // trim possible zeros that might have arised:
        auto it = polyConvolved_.rbegin();
        while (it != polyConvolved_.rend()) {
            if (*it == 0.) {
                polyConvolved_.pop_back();
                it = polyConvolved_.rbegin();
              }else{
                  break;
              }
          }
          // cache 'a' value (the exponent)
          for(Size i=0; i<degreesFreedom_.size(); i++)
              a_ += std::sqrt(static_cast<Real>(degreesFreedom_[i]))
                * std::abs(factors_[i]);
          a2_ = a_ * a_;
    }

    Disposable<std::vector<Real> >
    CumulativeBehrensFisher::polynCharactT(Natural n) const {
        Natural nu = 2 * n +1;
        std::vector<Real> low(1,1.), high(1,1.);
        high.push_back(std::sqrt(static_cast<Real>(nu)));
        if(n==0) return low;
        if(n==1) return high;

        for(Size k=1; k<n; k++) {
            std::vector<Real> recursionFactor(1,0.); // 0 coef
            recursionFactor.push_back(0.); // 1 coef
            recursionFactor.push_back(nu/((2.*k+1.)*(2.*k-1.))); // 2 coef
            std::vector<Real> lowUp =
                convolveVectorPolynomials(recursionFactor, low);
            //add them up:
            for(Size i=0; i<high.size(); i++)
                lowUp[i] += high[i];
            low = high;
            high = lowUp;
        }
        return high;
    }

    Disposable<std::vector<Real> >
    CumulativeBehrensFisher::convolveVectorPolynomials(
        const std::vector<Real>& v1,
        const std::vector<Real>& v2) const {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(!v1.empty() && !v2.empty(),
            "Incorrect vectors in polynomial.");
    #endif

        const std::vector<Real>& shorter = v1.size() < v2.size() ? v1 : v2;
        const std::vector<Real>& longer = (v1 == shorter) ? v2 : v1;

        Size newDegree = v1.size()+v2.size()-2;
        std::vector<Real> resultB(newDegree+1, 0.);
        for(Size polyOrdr=0; polyOrdr<resultB.size(); polyOrdr++) {
            for(Size i=std::max<Integer>(0, polyOrdr-longer.size()+1);
                i<=std::min(polyOrdr, shorter.size()-1); i++)
                resultB[polyOrdr] += shorter[i]*longer[polyOrdr-i];
        }
        return resultB;
    }

    Probability CumulativeBehrensFisher::operator()(const Real x) const {
        // 1st & 0th terms with the table integration
        Real integral = polyConvolved_[0] * std::atan(x/a_);
        Real squared = a2_ + x*x;
        Real rootsqr = std::sqrt(squared);
        Real atan2xa = std::atan2(-x,a_);
        if(polyConvolved_.size()>1)
            integral += polyConvolved_[1] * x/squared;

        for(Size exponent = 2; exponent <polyConvolved_.size(); exponent++) {
            integral -= polyConvolved_[exponent] *
                Factorial::get(exponent-1) * std::sin((exponent)*atan2xa)
                    /std::pow(rootsqr, static_cast<Real>(exponent));
         }
        return .5 + integral / M_PI;
    }

    Probability
    CumulativeBehrensFisher::density(const Real x) const {
        Real squared = a2_ + x*x;
        Real integral = polyConvolved_[0] * a_ / squared;
        Real rootsqr = std::sqrt(squared);
        Real atan2xa = std::atan2(-x,a_);
        for(Size exponent=1; exponent <polyConvolved_.size(); exponent++) {
            integral += polyConvolved_[exponent] *
                Factorial::get(exponent) * std::cos((exponent+1)*atan2xa)
                    /std::pow(rootsqr, static_cast<Real>(exponent+1) );
        }
        return integral / M_PI;
    }



    InverseCumulativeBehrensFisher::InverseCumulativeBehrensFisher(
        const std::vector<Integer>& degreesFreedom,
        const std::vector<Real>& factors,
        Real accuracy)
    : normSqr_(std::inner_product(factors.begin(), factors.end(),
        factors.begin(), 0.)),
      accuracy_(accuracy), distrib_(degreesFreedom, factors) { }

    Real InverseCumulativeBehrensFisher::operator()(const Probability q) const {
        Probability effectiveq;
        Real sign;
        // since the distrib is symmetric solve only on the right side:
        if(q==0.5) {
            return 0.;
        }else if(q < 0.5) {
            sign = -1.;
            effectiveq = 1.-q;
        }else{
            sign = 1.;
            effectiveq = q;
        }
        Real xMin =
            InverseCumulativeNormal::standard_value(effectiveq) * normSqr_;
        // inversion will fail at the Brent's bounds-check if this is not enough
        // (q is very close to 1.), in a bad combination fails around 1.-1.e-7
        Real xMax = 1.e6;
        return sign *
            Brent().solve([&](Real x){ return distrib_(x) - effectiveq; },
                          accuracy_, (xMin+xMax)/2., xMin, xMax);
    }

}
]]></document_content>
  </document>
  <document index="375">
    <source>math/convolvedstudentt.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef convolved_student_t_hpp
#define convolved_student_t_hpp

#include <ql/types.hpp>
#include <ql/utilities/disposable.hpp>
#include <vector>
#include <numeric>
#include <functional>

namespace QuantLib {

    /*! \brief Cumulative (generalized) BehrensFisher distribution.

    Exact analitical computation of the cumulative probability distribution of
    the linear combination of an arbitrary number (not just two) of T random
    variables of odd integer order. Adapted from the algorithm in:\par
        V. Witkovsky, Journal of Statistical Planning and Inference 94
        (2001) 1-13\par
    see also:\par
        On the distribution of a linear combination of t-distributed
        variables; Glenn Alan Walker, Ph.D.thesis University of Florida 1977\par
        'Convolutions of the T Distribution'; S. Nadarajah, D. K. Dey in
        Computers and Mathematics with Applications 49 (2005) 715-721\par
    The last reference provides direct expressions for some of the densities
    when the linear combination of only two Ts is just an addition. It can be
    used for testing the results here.\par
    Another available test on this algorithm stems from the realization that a
    linear convex (\f$ \sum a_i=1\f$) combination of Ts of order one is stable
    in the distribution sense (but this result is often of no practical use
    because of its non-finite variance).\par
    This implementation is for two or more T variables in the linear
    combination albeit these must be of odd order. The case of exactly two T of
    odd order is known to be a finite mixture of Ts but that result is not used
    here. On this line see 'Linearization coefficients of Bessel polynomials'
    C.Berg, C.Vignat; February 2008; arXiv:math/0506458

        \todo Implement the series expansion solution for the addition of
        two Ts of even order described in: 'On the density of the sum of two
        independent Student t-random vectors' C.Berg, C.Vignat; June 2009;
        eprint arXiv:0906.3037
    */
    class CumulativeBehrensFisher { // ODD orders only by now, rename?
    public:
        typedef Probability result_type;
        typedef Real argument_type;
        /*!
            @param degreesFreedom Degrees of freedom of the Ts convolved. The
                algorithm is limited to odd orders only.
            @param factors Factors in the linear combination of the Ts.
        */
        CumulativeBehrensFisher(
            const std::vector<Integer>& degreesFreedom = std::vector<Integer>(),
            const std::vector<Real>& factors = std::vector<Real>());

        //! Degrees of freedom of the Ts involved in the convolution.
        const std::vector<Integer>& degreeFreedom() const {
            return degreesFreedom_;
        }
        //! Factors in the linear combination.
        const std::vector<Real>& factors() const {
            return factors_;
        }
    private:
        /*! \brief Student t characteristic polynomials.

        Generates the polynomial coefficients defining the characteristic
        function of a T distribution \f$T_\nu\f$ of odd order; \f$\nu=2n+1\f$.
        In general the characteristic function is given by:
        \f[
        \phi_{\nu}(t) = \varphi_{n}(t) \exp{-\nu^{1/2}|t|} ;\,where\,\nu = 2n+1
        \f]
        where \f$ \varphi \f$ are polynomials that are computed recursively.

        The convolved characteristic function is the product of the two previous
        characteristic functions and the problem is then the convolution (a
        product) of two polynomials.

            @param n Natural number defining the order of the T for which
            the characteristic function is to be computed. The order of the
             T is then \f$ \nu=2n+1 \f$
        */
        // move outside of the class, as a separate problem?
        Disposable<std::vector<Real> > polynCharactT(Natural n) const;

        Disposable<std::vector<Real> > convolveVectorPolynomials(
            const std::vector<Real>& v1,
            const std::vector<Real>& v2) const ;
    public:
        /*! \brief Returns the cumulative probability of the resulting
        distribution.\par
            To obtain the cumulative probability the Gil-Pelaez theorem
              is applied:\par
            First compute the characteristic function of the linear combination
            variable by multiplying the individual characteristic functions.
            Then transform back integrating the characteristic function
            according to the GP theorem; this is done here analytically feeding
            in the expression of the total characteristic
            function this:
            \f[ \int_0^{\infty}x^n e^{-ax}sin(bx)dx =
                (-1)^n \Gamma(n+1) \frac{sin((n+1)arctg2(-b/a))}
                    {(\sqrt{a^2+b^2})^{n+1}}; for\,a>0,\,b>0
            \f]
            and for the first term I use:
            \f[
            \int_0^{\infty} \frac{e^{-ax}sin(bx)}{x} dx = arctg2(b/a)
            \f]
            The GP complex integration is simplified thanks to the symetry of
            the distribution.
        */
      Probability operator()(Real x) const;

      /*! \brief Returns the probability density of the resulting
      distribution.\par
          Similarly to the cumulative probability, Gil-Pelaez theorem is
          applied, the integration is similar.

          \todo Implement in a separate class? given the name of this class..
      */
      Probability density(Real x) const;

    private:
        mutable std::vector<Integer> degreesFreedom_;
        mutable std::vector<Real> factors_;

        mutable std::vector<std::vector<Real> > polynCharFnc_;
        mutable std::vector<Real> polyConvolved_;

        // cached factor in the exponential of the characteristic function
        mutable Real a_ = 0., a2_;
    };



    /*! \brief Inverse of the cumulative of the convolution of odd-T
    distributions

    Finds the inverse through a root solver. To find limits for the solver
    domain use is made of the property that the convolved distribution is
    bounded above by the normalized gaussian. If the coeffiecient in the linear
    combination add up to a number below one the T of order one can be used as
    a limit below but in general this is not necessarily the case and a constant
    is used.
    Also the fact that the combination is symmetric is used.
     */
    class InverseCumulativeBehrensFisher {
    public:
        typedef Real result_type;
        typedef Probability argument_type;
        /*!
            @param degreesFreedom Degrees of freedom of the Ts convolved. The
                algorithm is limited to odd orders only.
            @param factors Factors in the linear combination of the Ts.
            @param accuracy The accuracy of the root-solving process.
        */
        InverseCumulativeBehrensFisher(
            const std::vector<Integer>& degreesFreedom = std::vector<Integer>(),
            const std::vector<Real>& factors = std::vector<Real>(),
            Real accuracy = 1.e-6);
        //! Returns the cumulative inverse value.
        Real operator()(Probability q) const;

      private:
        mutable Real normSqr_, accuracy_;
        mutable CumulativeBehrensFisher distrib_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="376">
    <source>math/expm.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expm.cpp
    \brief matrix exponential
*/


#include <ql/experimental/math/expm.hpp>
#include <ql/math/ode/adaptiverungekutta.hpp>
#include <algorithm>
#include <numeric>
#include <utility>

namespace QuantLib {

    namespace {
        class MatrixVectorProductFct {
          public:
            explicit MatrixVectorProductFct(Matrix m) : m_(std::move(m)) {}

            // implements x = M*y
            Disposable<std::vector<Real> > operator()(
                Real t, const std::vector<Real>& y) {

                std::vector<Real> result(m_.rows());
                for (Size i=0; i < result.size(); i++) {
                    result[i] = std::inner_product(y.begin(), y.end(),
                                                   m_.row_begin(i), 0.0);
                }
                return result;
            }
          private:
            const Matrix m_;
        };
    }

    Disposable<Matrix> Expm(const Matrix& M, Real t, Real tol) {
        const Size n = M.rows();
        QL_REQUIRE(n == M.columns(), "Expm expects a square matrix");

        AdaptiveRungeKutta<> rk(tol);
        AdaptiveRungeKutta<>::OdeFct odeFct = MatrixVectorProductFct(M);

        Matrix result(n, n);
        for (Size i=0; i < n; ++i) {
            std::vector<Real> x0(n, 0.0);
            x0[i] = 1.0;

            const std::vector<Real> r = rk(odeFct, x0, 0.0, t);
            std::copy(r.begin(), r.end(), result.column_begin(i));
        }
        return result;
    }
}
]]></document_content>
  </document>
  <document index="377">
    <source>math/expm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expm.hpp
    \brief matrix exponential
*/

#ifndef quantlib_expm_hpp
#define quantlib_expm_hpp

#include <ql/math/matrix.hpp>

namespace QuantLib {

    //! matrix exponential based on the ordinary differential equations method

    /*! References:

        C. Moler; C. Van Loan, 1978,
        Nineteen Dubious Ways to Compute the Exponential of a Matrix
        http://xa.yimg.com/kq/groups/22199541/1399635765/name/moler-nineteen.pdf
    */

    //! returns the matrix exponential exp(t*M)
    Disposable<Matrix> Expm(const Matrix& M, Real t=1.0, Real tol=QL_EPSILON);
}

#endif
]]></document_content>
  </document>
  <document index="378">
    <source>math/farliegumbelmorgensterncopularng.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file farliegumbelmorgensterncopularng.hpp
    \brief Farlie-Gumbel-Morgenstern copula random-number generator
*/

#ifndef quantlib_farlie_gumbel_morgenstern_copula_rng_hpp
#define quantlib_farlie_gumbel_morgenstern_copula_rng_hpp

#include <ql/methods/montecarlo/sample.hpp>
#include <ql/errors.hpp>
#include <vector>

namespace QuantLib {

    //! Farlie-Gumbel-Morgenstern copula random-number generator
    template <class RNG>
    class FarlieGumbelMorgensternCopulaRng {
      public:
        typedef Sample<std::vector<Real> > sample_type;
        typedef RNG urng_type;
        explicit FarlieGumbelMorgensternCopulaRng(const RNG& uniformGenerator,
                                                  Real theta);
        sample_type next() const;
      private:
        Real theta_;
        RNG uniformGenerator_;
    };

    template <class RNG>
    FarlieGumbelMorgensternCopulaRng<RNG>::FarlieGumbelMorgensternCopulaRng(
                                                       const RNG& ug, Real th)
    : uniformGenerator_(ug), theta_(th) {
        QL_REQUIRE(th >= -1.0 && th <= 1.00,
                   "theta (" << th << ") must be in [-1,1]");
    }

    template <class RNG>
    inline typename FarlieGumbelMorgensternCopulaRng<RNG>::sample_type
    FarlieGumbelMorgensternCopulaRng<RNG>::next() const {
        typename RNG::sample_type v1 = uniformGenerator_.next();
        typename RNG::sample_type v2 = uniformGenerator_.next();
        Real u1 = v1.value;
        Real a = theta_*(2.0*u1-1.0);
        Real b = pow(1.0-theta_*(2.0*u1-1.0),2.0)+4.0*theta_*v2.value*(2.0*u1-1.0);
        Real u2 = (2.0*v2.value)/(sqrt(b)-a);
        std::vector<Real> u;
        u.push_back(u1);
        u.push_back(u2);
        return sample_type(u,v1.weight*v2.weight);
    }

}


#endif
]]></document_content>
  </document>
  <document index="379">
    <source>math/fireflyalgorithm.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Andres Hernandez

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/fireflyalgorithm.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <algorithm>
#include <cmath>
#include <utility>

namespace QuantLib {
    FireflyAlgorithm::FireflyAlgorithm(Size M,
                                       ext::shared_ptr<Intensity> intensity,
                                       ext::shared_ptr<RandomWalk> randomWalk,
                                       Size Mde,
                                       Real mutation,
                                       Real crossover,
                                       unsigned long seed)
    : mutation_(mutation), crossover_(crossover), M_(M), Mde_(Mde), Mfa_(M_ - Mde_),
      intensity_(std::move(intensity)), randomWalk_(std::move(randomWalk)),
      drawIndex_(base_generator_type(seed), uniform_integer(Mfa_, Mde > 0 ? M_ - 1 : M_)),
      rng_(seed) {
        QL_REQUIRE(M_ >= Mde_,
            "Differential Evolution subpopulation cannot be larger than total population");
    }

    void FireflyAlgorithm::startState(Problem &P, const EndCriteria &endCriteria) {
        N_ = P.currentValue().size();
        x_.reserve(M_);
        xI_.reserve(M_);
        xRW_.reserve(M_);
        values_.reserve(M_);
        uX_ = P.constraint().upperBound(P.currentValue());
        lX_ = P.constraint().lowerBound(P.currentValue());
        Array bounds = uX_ - lX_;

        //Random initialization is done by Sobol sequence
        SobolRsg sobol(N_);

        //Prepare containers
        for (Size i = 0; i < M_; i++) {
            const SobolRsg::sample_type::value_type &sample = sobol.nextSequence().value;
            x_.emplace_back(N_, 0.0);
            xI_.emplace_back(N_, 0.0);
            xRW_.emplace_back(N_, 0.0);
            Array& x = x_.back();
            for (Size j = 0; j < N_; j++) {
                //Assign X=lb+(ub-lb)*random
                x[j] = lX_[j] + bounds[j] * sample[j];
            }
            //Evaluate point
            values_.emplace_back(P.value(x), i);
        }

        //init intensity & randomWalk
        intensity_->init(this);
        randomWalk_->init(this);
    }

    EndCriteria::Type FireflyAlgorithm::minimize(Problem &P, const EndCriteria &endCriteria) {
        QL_REQUIRE(!P.constraint().empty(), "Firefly Algorithm is a constrained optimizer");
        EndCriteria::Type ecType = EndCriteria::None;
        P.reset();
        Size iteration = 0;
        Size iterationStat = 0;
        Size maxIteration = endCriteria.maxIterations();
        Size maxIStationary = endCriteria.maxStationaryStateIterations();
        
        startState(P, endCriteria);

        bool isFA = Mfa_ > 0;
        //Variables for DE
        Array z(N_, 0.0);
        Size indexR1, indexR2;
        uniform_integer::param_type nParam(0, N_ - 1);

        //Set best value & position
        Real bestValue = values_[0].first;
        Size bestPosition = 0;
        for (Size i = 1; i < M_; i++) {
            if (values_[i].first < bestValue) {
                bestPosition = i;
                bestValue = values_[i].first;
            }
        }
        Array bestX = x_[bestPosition];

        //Run optimization
        do {
            iteration++;
            iterationStat++;
            //Check if stopping criteria is met
            if (iteration > maxIteration || iterationStat > maxIStationary)
                break;

            //Divide into two subpopulations
            //First sort values
            std::sort(values_.begin(), values_.end());

            //Differential evolution
            if(Mfa_ < M_){
                Size indexBest = values_[0].second;
                Array& xBest = x_[indexBest];
                for (Size i = Mfa_; i < M_; i++) { 
                    if (!isFA) {
                        //Pure DE requires random index
                        indexBest = drawIndex_();
                        xBest = x_[indexBest];
                    }
                    do { 
                        indexR1 = drawIndex_(); 
                    } while(indexR1 == indexBest);
                    do { 
                        indexR2 = drawIndex_(); 
                    } while(indexR2 == indexBest || indexR2 == indexR1);
                    
                    Size index = values_[i].second;
                    Array& x   = x_[index];
                    Array& xR1 = x_[indexR1];
                    Array& xR2 = x_[indexR2];
					Size rIndex = drawIndex_(nParam);
                    for (Size j = 0; j < N_; j++) {
                        if (j == rIndex || rng_.nextReal() <= crossover_) {
                            //Change x[j] according to crossover
                            z[j] = xBest[j] + mutation_*(xR1[j] - xR2[j]);
                        } else {
                            z[j] = x[j];
                        }
                        //Enforce bounds on positions
                        if (z[j] < lX_[j]) {
                            z[j] = lX_[j];
                        }
                        else if (z[j] > uX_[j]) {
                            z[j] = uX_[j];
                        }
                    }
                    Real val = P.value(z);
                    if (val < values_[index].first) {
                        //Accept new point
                        x = z;
                        values_[index].first = val;
                        //mark best
                        if (val < bestValue) {
                            bestValue = val;
                            bestX = x;
                            iterationStat = 0;
                        }
                    }
                }
            }
                
            //Firefly algorithm
            if(isFA){
                //According to the intensity, determine best global position
                intensity_->findBrightest();

                //Prepare random walk
                randomWalk_->walk();

                //Loop over particles
                for (Size i = 0; i < Mfa_; i++) {
                    Size index = values_[i].second;
                    Array& x   = x_[index];
                    Array& xI  = xI_[index];
                    Array& xRW = xRW_[index];

                    //Loop over dimensions
                    for (Size j = 0; j < N_; j++) {
                        //Update position
                        z[j] = x[j] + xI[j] + xRW[j];
                        //Enforce bounds on positions
                        if (z[j] < lX_[j]) {
                            z[j] = lX_[j];
                        }
                        else if (z[j] > uX_[j]) {
                            z[j] = uX_[j];
                        }
                    }
                    Real val = P.value(z);
                    if(!std::isnan(val))
					{
						//Accept new point
                        x = z;
                        values_[index].first = val;
                        //mark best
                        if (val < bestValue) {
                            bestValue = val;
                            bestX = x;
                            iterationStat = 0;
                        }
					}
                }
            }
        } while (true);
        if (iteration > maxIteration)
            ecType = EndCriteria::MaxIterations;
        else
            ecType = EndCriteria::StationaryPoint;

        //Set result to best point
        P.setCurrentValue(bestX);
        P.setFunctionValue(bestValue);
        return ecType;
    }

    void FireflyAlgorithm::Intensity::findBrightest() {
        //Brightest ignores all others
        Array& xI = (*xI_)[(*values_)[0].second];
        for (Size j = 0; j < N_; j++) {
            xI[j] = 0.0;
        }

        for (Size i = 1; i < Mfa_; i++) {
            //values_ is already sorted
            Size index = (*values_)[i].second;
            const Array& x = (*x_)[index];
            Array& xI = (*xI_)[index];
            for (Size j = 0; j < N_; j++) {
                xI[j] = 0.0;
            }
            Real valueX = (*values_)[i].first;
            for (Size k = 0; k < i - 1; k++){
                const Array& y = (*x_)[(*values_)[k].second];
                Real valueY = (*values_)[k].first;
                Real intensity = intensityImpl(valueX, valueY, distance(x, y));
                xI += intensity*(y - x);
            }
        }
    }
}

]]></document_content>
  </document>
  <document index="380">
    <source>math/fireflyalgorithm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Andres Hernandez

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fireflyalgorithm.hpp
\brief Implementation based on:
Yang, Xin-She (2009) Firefly Algorithm, Levy Flights and Global
Optimization. Research and Development in Intelligent Systems XXVI, pp 209-218.
http://arxiv.org/pdf/1003.1464.pdf
*/

#ifndef quantlib_optimization_fireflyalgorithm_hpp
#define quantlib_optimization_fireflyalgorithm_hpp

#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/experimental/math/isotropicrandomwalk.hpp>
#include <ql/experimental/math/levyflightdistribution.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/randomnumbers/seedgenerator.hpp>

#include <boost/random/mersenne_twister.hpp>
typedef boost::mt19937 base_generator_type;

#include <boost/random/normal_distribution.hpp>
typedef boost::random::normal_distribution<QuantLib::Real> BoostNormalDistribution;
#include <boost/random/uniform_int_distribution.hpp>
typedef boost::random::uniform_int_distribution<QuantLib::Size> uniform_integer;
#include <boost/random/variate_generator.hpp>
typedef boost::variate_generator<base_generator_type, uniform_integer> variate_integer;

#include <cmath>

namespace QuantLib {

    /*! The main process is as follows:
    M individuals are used to explore the N-dimensional parameter space:
    \f$ X_{i}^k = (X_{i, 1}^k, X_{i, 2}^k, \ldots, X_{i, N}^k) \f$ is the kth-iteration 
    for the ith-individual. X is updated via the rule
    \f[
    X_{i, j}^{k+1} = X_{i, j}^k + I(X^k)_{i,j} + RandomWalk_{i,j}^k
    \f]

    The intensity function I(X) should be monotonic
    The optimization stops either because the number of iterations has been reached
    or because the stationary function value limit has been reached.

    The current implementation extends the normal Firefly Algorithm with a 
    differential evolution (DE) optimizer according to:
    Afnizanfaizal Abdullah, et al. "A New Hybrid Firefly Algorithm for Complex and 
    Nonlinear Problem". Volume 151 of the series Advances in Intelligent and Soft 
    Computing pp 673-680, 2012.
    http://link.springer.com/chapter/10.1007%2F978-3-642-28765-7_81
    
    In effect this implementation provides a fully fledged DE global optimizer 
    as well. The Firefly Algorithm was easy to combine with DE because it already 
    contained a step where the current solutions are sorted. The population is 
    then divided into two subpopulations based on their order. The subpopulation 
    with the best results are updated via the firefly algorithm. The worse 
    subpopulation is updated via the DE operator:
    \f[
    Y^{k+1} = X_{best}^k + F(X_{r1}^k - X_{r2}^k)
    \f]
    and 
    \f[
    X_{i,j}^{k+1} = Y_{i,j}^{k+1}\ \text{if} R_{i,j} <= C
    \f]
    \f[
    X_{i,j}^{k+1} = X_{i,j}^{k+1}\ \text{otherwise}
    \f]
    where C is the crossover constant, and R is a random uniformly distributed
    number.
    */
    class FireflyAlgorithm : public OptimizationMethod {
      public:
        class RandomWalk;
        class Intensity;
        friend class RandomWalk;
        friend class Intensity;
        FireflyAlgorithm(Size M,
                         ext::shared_ptr<Intensity> intensity,
                         ext::shared_ptr<RandomWalk> randomWalk,
                         Size Mde = 0,
                         Real mutationFactor = 1.0,
                         Real crossoverFactor = 0.5,
                         unsigned long seed = SeedGenerator::instance().get());
        void startState(Problem &P, const EndCriteria &endCriteria);
        EndCriteria::Type minimize(Problem& P, const EndCriteria& endCriteria) override;

      protected:
        std::vector<Array> x_, xI_, xRW_; 
        std::vector<std::pair<Real, Size> > values_;
        Array lX_, uX_;
        Real mutation_, crossover_;
        Size M_, N_, Mde_, Mfa_;
        ext::shared_ptr<Intensity> intensity_;
        ext::shared_ptr<RandomWalk> randomWalk_;
        variate_integer drawIndex_;
        MersenneTwisterUniformRng rng_;
    };

    //! Base intensity class
    /*! Derived classes need to implement only intensityImpl
    */
    class FireflyAlgorithm::Intensity {
        friend class FireflyAlgorithm;
    public:
      virtual ~Intensity() = default;
      //! find brightest firefly for each firefly
      void findBrightest();
    protected:
        Size Mfa_, N_;
        const std::vector<Array> *x_;
        const std::vector<std::pair<Real, Size> > *values_;
        std::vector<Array> *xI_;

        virtual Real intensityImpl(Real valueX, Real valueY, Real distance) = 0;
        inline Real distance(const Array& x, const Array& y) const {
            Real d = 0.0;
            for (Size i = 0; i < N_; i++) {
                Real diff = x[i] - y[i];
                d += diff*diff;
            }
            return d;
        }

    private:
        void init(FireflyAlgorithm *fa) {
            x_ = &fa->x_;
            xI_ = &fa->xI_;
            values_ = &fa->values_;
            Mfa_ = fa->Mfa_;
            N_ = fa->N_;
        }
    };

    //! Exponential Intensity
    /*  Exponentially decreasing intensity
    */
    class ExponentialIntensity : public FireflyAlgorithm::Intensity {
      public:
          ExponentialIntensity(Real beta0, Real betaMin, Real gamma)
              : beta0_(beta0), betaMin_(betaMin), gamma_(gamma) {}
      protected:
        Real intensityImpl(Real valueX, Real valueY, Real d) override {
            return (beta0_ - betaMin_) * std::exp(-gamma_ * d) + betaMin_;
        }
          Real beta0_, betaMin_, gamma_;
    };

    //! Inverse Square Intensity
    /*  Inverse law square
    */
    class InverseLawSquareIntensity : public FireflyAlgorithm::Intensity {
    public:
        InverseLawSquareIntensity(Real beta0, Real betaMin)
            : beta0_(beta0), betaMin_(betaMin) {}
    protected:
      Real intensityImpl(Real valueX, Real valueY, Real d) override {
          return (beta0_ - betaMin_) / (d + QL_EPSILON) + betaMin_;
      }
        Real beta0_, betaMin_;
    };

    //! Base Random Walk class
    /*! Derived classes need to implement only walkImpl
    */
    class FireflyAlgorithm::RandomWalk {
        friend class FireflyAlgorithm;
    public:
      virtual ~RandomWalk() = default;
      //! perform random walk
      void walk() {
          for (Size i = 0; i < Mfa_; i++) {
              walkImpl((*xRW_)[(*values_)[i].second]);
          }
        }
    protected:
        Size Mfa_, N_;
        const std::vector<Array> *x_;
        const std::vector<std::pair<Real, Size> > *values_;
        std::vector<Array> *xRW_;
        Array *lX_, *uX_;

        virtual void walkImpl(Array & xRW) = 0;
        virtual void init(FireflyAlgorithm *fa) {
            x_ = &fa->x_;
            xRW_ = &fa->xRW_;
            values_ = &fa->values_;
            Mfa_ = fa->Mfa_;
            N_ = fa->N_;
            lX_ = &fa->lX_;
            uX_ = &fa->uX_;
        }
    };

    //! Distribution Walk
    /*  Random walk given by distribution template parameter. The
        distribution must be compatible with boost's Random 
        variate_generator
    */
    template <class Distribution>
    class DistributionRandomWalk : public FireflyAlgorithm::RandomWalk {
      public:
        typedef IsotropicRandomWalk<Distribution, base_generator_type> WalkRandom;
        explicit DistributionRandomWalk(Distribution dist, 
                                        Real delta = 0.9, 
                                        unsigned long seed = SeedGenerator::instance().get())
        : walkRandom_(base_generator_type(seed), dist, 1, Array(1, 1.0), seed),
          delta_(delta) {}
      protected:
        void walkImpl(Array& xRW) override {
            walkRandom_.nextReal(&xRW[0]);
            xRW *= delta_;
        }
        void init(FireflyAlgorithm* fa) override {
            FireflyAlgorithm::RandomWalk::init(fa);
            walkRandom_.setDimension(N_, *lX_, *uX_);
        }
        WalkRandom walkRandom_;
        Real delta_;
    };
    
    //! Gaussian Walk
    /*  Gaussian random walk
    */
    class GaussianWalk : public DistributionRandomWalk<BoostNormalDistribution> {
      public:
        explicit GaussianWalk(Real sigma, 
                              Real delta = 0.9, 
                              unsigned long seed = SeedGenerator::instance().get())
        : DistributionRandomWalk<BoostNormalDistribution>(
                           BoostNormalDistribution(0.0, sigma), delta, seed){}
    };

    //! Levy Flight Random Walk
    /*  Levy flight random walk
    */
    class LevyFlightWalk : public DistributionRandomWalk<LevyFlightDistribution> {
      public:
        explicit LevyFlightWalk(Real alpha, 
                                Real xm = 0.5, 
                                Real delta = 0.9,
                                unsigned long seed = SeedGenerator::instance().get())
        : DistributionRandomWalk<LevyFlightDistribution>(
                            LevyFlightDistribution(xm, alpha), delta, seed) {}
    };

    //! Decreasing Random Walk
    /*  Gaussian random walk, but size of step decreases with each iteration step
    */
    class DecreasingGaussianWalk : public GaussianWalk {
      public:
        explicit DecreasingGaussianWalk(
            Real sigma,
            Real delta = 0.9,
            unsigned long seed = SeedGenerator::instance().get())
        : GaussianWalk(sigma, delta, seed), delta0_(delta) {}
      protected:
        void walkImpl(Array& xRW) override {
            iteration_++;
            if (iteration_ > Mfa_) {
                //Every time all the fireflies have been processed
                //multiply delta by itself
                iteration_ = 0;
                delta_ *= delta_;
            }
            GaussianWalk::walkImpl(xRW);
        }
        void init(FireflyAlgorithm* fa) override {
            GaussianWalk::init(fa);
            iteration_ = 0;
            delta_ = delta0_;
        }

      private:
        Real delta0_;
        Size iteration_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="381">
    <source>math/frankcopularng.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file frankcopularng.hpp
    \brief Frank copula random-number generator
*/

#ifndef quantlib_frank_copula_rng_hpp
#define quantlib_frank_copula_rng_hpp

#include <ql/methods/montecarlo/sample.hpp>
#include <ql/errors.hpp>
#include <vector>

namespace QuantLib {

    //! Frank copula random-number generator
    template <class RNG>
    class FrankCopulaRng {
      public:
        typedef Sample<std::vector<Real> > sample_type;
        typedef RNG urng_type;
        explicit FrankCopulaRng(const RNG& uniformGenerator, Real theta);
        sample_type next() const;
      private:
        Real theta_;
        RNG uniformGenerator_;
    };

    template <class RNG>
    FrankCopulaRng<RNG>::FrankCopulaRng(const RNG& ug, Real th)
    : uniformGenerator_(ug), theta_(th) {
     QL_REQUIRE(th != 0.0,
                   "theta (" << th << ") must be different from 0");
    }

    template <class RNG>
    inline typename FrankCopulaRng<RNG>::sample_type
    FrankCopulaRng<RNG>::next() const {
        typename RNG::sample_type v1 = uniformGenerator_.next();
        typename RNG::sample_type v2 = uniformGenerator_.next();
        Real u1 = v1.value;
        Real u2 = (-1.0/theta_)*log(1.0+(v2.value*(1.0-exp(-theta_)))/(v2.value*(exp(-theta_*v1.value)-1.0)-exp(-theta_*v1.value)));
        std::vector<Real> u;
        u.push_back(u1);
        u.push_back(u2);
        return sample_type(u,v1.weight*v2.weight);
    }

}


#endif
]]></document_content>
  </document>
  <document index="382">
    <source>math/gaussiancopulapolicy.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/gaussiancopulapolicy.hpp>

namespace QuantLib {

    const NormalDistribution GaussianCopulaPolicy::density_ = 
        NormalDistribution();
    const CumulativeNormalDistribution GaussianCopulaPolicy::cumulative_ = 
        CumulativeNormalDistribution();

}
]]></document_content>
  </document>
  <document index="383">
    <source>math/gaussiancopulapolicy.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_gaussian_copula_policy_hpp
#define quantlib_gaussian_copula_policy_hpp

#include <ql/utilities/disposable.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <vector>
#include <numeric>
#include <algorithm>

namespace QuantLib {

    /*! Gaussian Latent Model's copula policy. Its simplicity is a result of 
      the convolution stability of the Gaussian distribution.
    */
    /* This is the only case that would have allowed the policy to be static, 
    but other copulas will need parameters and initialization.*/
    struct GaussianCopulaPolicy {

        typedef int initTraits;

        explicit GaussianCopulaPolicy(
            const std::vector<std::vector<Real> >& factorWeights = 
                std::vector<std::vector<Real> >(), 
            const initTraits& dummy = int())
        : numFactors_(factorWeights.size() + factorWeights[0].size())
        {
            /* check factors in LM are normalized. */
            for (const auto& factorWeight : factorWeights) {
                Real factorsNorm = std::inner_product(factorWeight.begin(), factorWeight.end(),
                                                      factorWeight.begin(), 0.);
                QL_REQUIRE(factorsNorm < 1., 
                    "Non normal random factor combination.");
            }
            /* check factor matrix is squared .......... */
        }

        /*! Number of independent random factors. 
        This is the only methos that ould stop the class from being static, it
        is needed for the MC generator construction.
        */
        Size numFactors() const {
            return numFactors_;
        }

        //! returns a copy of the initialization arguments
        initTraits getInitTraits() const {
            return initTraits();
        }

        /*! Cumulative probability of a given latent variable 
            The iVariable parameter is the index of the requested variable.
        */
        Probability cumulativeY(Real val, Size iVariable) const {
            return cumulative_(val);
        }
        //! Cumulative probability of the idiosyncratic factors (all the same)
        Probability cumulativeZ(Real z) const {
            return cumulative_(z);
        }
        /*! Probability density of a given realization of values of the systemic
          factors (remember they are independent). In the normal case, since 
          they all follow the same law it is just a trivial product of the same 
          density. 
          Intended to be used in numerical integration of an arbitrary function 
          depending on those values.
        */
        Probability density(const std::vector<Real>& m) const {
            return std::accumulate(m.begin(), m.end(), Real(1.),
                                   [&](Real x, Real y){ return x*density_(y); });
        }
        /*! Returns the inverse of the cumulative distribution of the (modelled) 
          latent variable (as indexed by iVariable). The normal stability avoids
          the convolution of the factors' distributions
        */
        Real inverseCumulativeY(Probability p, Size iVariable) const {
            return InverseCumulativeNormal::standard_value(p);
        }
        /*! Returns the inverse of the cumulative distribution of the 
        idiosyncratic factor (identically distributed for all latent variables)
        */
        Real inverseCumulativeZ(Probability p) const {
            return InverseCumulativeNormal::standard_value(p);
        }
        /*! Returns the inverse of the cumulative distribution of the 
          systemic factor iFactor.
        */
        Real inverseCumulativeDensity(Probability p, Size iFactor) const {
            return InverseCumulativeNormal::standard_value(p);
        }
        //! 
        //to use this (by default) version, the generator must be a uniform one.
        Disposable<std::vector<Real> > 
            allFactorCumulInverter(const std::vector<Real>& probs) const {
            std::vector<Real> result;
            result.resize(probs.size());
            std::transform(probs.begin(), probs.end(), result.begin(),
                           [&](Real p){ return InverseCumulativeNormal::standard_value(p); });
            return result;
        }
    private:
        mutable Size numFactors_;
        // no op =
        static const NormalDistribution density_;
        static const CumulativeNormalDistribution cumulative_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="384">
    <source>math/gaussiannoncentralchisquaredpolynomial.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussiannoncentralchisquaredpolynomial.hpp
    \brief non central chi squared polynomials for Gaussian quadratures
*/

#ifndef quantlib_gaussian_non_central_chi_squared_polynomial_hpp
#define quantlib_gaussian_non_central_chi_squared_polynomial_hpp

#include <ql/functional.hpp>
#include <ql/math/integrals/momentbasedgaussianpolynomial.hpp>

namespace QuantLib {

    class GaussNonCentralChiSquaredPolynomial
            : public MomentBasedGaussianPolynomial<Real> {
      public:
        GaussNonCentralChiSquaredPolynomial(Real nu, Real lambda);

        Real w(Real x) const override;
        Real moment(Size i) const override;

      private:
        const Real nu_, lambda_;

        static std::vector<ext::function<Real(Real, Real)> > moments;
    };
}

#endif
]]></document_content>
  </document>
  <document index="385">
    <source>math/hybridsimulatedannealing.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Andres Hernandez

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hybridsimulatedannealing.hpp
\brief Implementation based on:
Very Fast Simulated Re-Annealing, Lester Ingber,
Mathl. Comput. Modelling, 967-973, 1989
*/

#ifndef quantlib_optimization_hybridsimulatedannealing_hpp
#define quantlib_optimization_hybridsimulatedannealing_hpp

#include <ql/experimental/math/hybridsimulatedannealingfunctors.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/math/optimization/problem.hpp>
#include <utility>

namespace QuantLib {

    /*! Method is fairly straightforward:
    1) Sampler provides a probability density (based on current value) for the parameters. Each
    iteration a new draw is made from it to find a new point
    2) Probability determines whether the new point, obtained from Sampler, is accepted or not
    3) Temperature is a schedule T(k) for the iteration k, which affects the Sampler and Probability
    4) Reannealing is a departure from the traditional Boltzmann Annealing method: it rescales
    the iteration k independently for each dimension so as to improve convergence

    The hybrid in the name is because one can provide it a local optimizer for use whenever any new
    best point is found or at every accepted point, in which case is used is chose by the user.

    Class Sampler must implement the following interface:
    \code
    void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const;
    \endcode
    Class Probability must implement the following interface:
    \code
    bool operator()(Real currentValue, Real newValue, const Array &temp) const;
    \endcode
    Class Temperature must implement the following interface:
    \code
    void operator()(Array &newTemp, const Array &currTemp, const Array &steps) const;
    \endcode
    Class Reannealing must implement the following interface:
    \code
    void operator()(Array & steps, const Array &currentPoint,
    Real aCurrentValue, const Array & currTemp) const;
    \endcode
    */
    template <class Sampler, class Probability, class Temperature, class Reannealing = ReannealingTrivial>
    class HybridSimulatedAnnealing : public OptimizationMethod {
      public:
        enum LocalOptimizeScheme {
            NoLocalOptimize,
            EveryNewPoint,
            EveryBestPoint
        };
        enum ResetScheme {
            NoResetScheme,
            ResetToBestPoint,
            ResetToOrigin
        };

        HybridSimulatedAnnealing(const Sampler& sampler,
                                 const Probability& probability,
                                 Temperature temperature,
                                 const Reannealing& reannealing = ReannealingTrivial(),
                                 Real startTemperature = 200.0,
                                 Real endTemperature = 0.01,
                                 Size reAnnealSteps = 50,
                                 ResetScheme resetScheme = ResetToBestPoint,
                                 Size resetSteps = 150,
                                 ext::shared_ptr<OptimizationMethod> localOptimizer =
                                     ext::shared_ptr<OptimizationMethod>(),
                                 LocalOptimizeScheme optimizeScheme = EveryBestPoint)
        : sampler_(sampler), probability_(probability), temperature_(std::move(temperature)),
          reannealing_(reannealing), startTemperature_(startTemperature),
          endTemperature_(endTemperature),
          reAnnealSteps_(reAnnealSteps == 0 ? QL_MAX_INTEGER : reAnnealSteps),
          resetScheme_(resetScheme), resetSteps_(resetSteps == 0 ? QL_MAX_INTEGER : resetSteps),
          localOptimizer_(localOptimizer),
          optimizeScheme_(localOptimizer != nullptr ? optimizeScheme : NoLocalOptimize) {
            if (!localOptimizer)
                localOptimizer.reset(new LevenbergMarquardt);
        }

        EndCriteria::Type minimize(Problem& P, const EndCriteria& endCriteria) override;

      private:
        Sampler sampler_;
        Probability probability_;
        Temperature temperature_;
        Reannealing reannealing_;
        Real startTemperature_;
        Real endTemperature_;
        Size reAnnealSteps_;
        ResetScheme resetScheme_;
        Size resetSteps_;
        ext::shared_ptr<OptimizationMethod> localOptimizer_;
        LocalOptimizeScheme optimizeScheme_;
    };

    template <class Sampler, class Probability, class Temperature, class Reannealing>
    EndCriteria::Type HybridSimulatedAnnealing<Sampler, Probability, Temperature, Reannealing>::minimize(Problem &P, const EndCriteria &endCriteria) {
        EndCriteria::Type ecType = EndCriteria::None;
        P.reset();
        reannealing_.setProblem(P);
        Array x = P.currentValue();
        Size n = x.size();
        Size k = 1;
        Size kStationary = 1;
        Size kReAnneal = 1;
        Size kReset = 1;
        Size maxK = endCriteria.maxIterations();
        Size maxKStationary = endCriteria.maxStationaryStateIterations();
        bool temperatureBreached = false;
        Array currentTemperature(n, startTemperature_);
        Array annealStep(n, 1.0);
        Array bestPoint(x);
        Array currentPoint(x);
        const Array& startingPoint(x);
        Array newPoint(x);
        Real bestValue = P.value(bestPoint);
        Real currentValue = bestValue;
        Real startingValue = bestValue; //to reset to starting point if desired
        while (k <= maxK && kStationary <= maxKStationary && !temperatureBreached)
        {
            //Draw a new sample point
            sampler_(newPoint, currentPoint, currentTemperature);
            try{
                //Evaluate new point
                Real newValue = P.value(newPoint);
				
                //Determine if new point is accepted
                if (probability_(currentValue, newValue, currentTemperature)) {
                    if (optimizeScheme_ == EveryNewPoint) {
                        P.setCurrentValue(newPoint);
                        P.setFunctionValue(newValue);
                        localOptimizer_->minimize(P, endCriteria);
                        newPoint = P.currentValue();
                        newValue = P.functionValue();
                    }
                    currentPoint = newPoint;
                    currentValue = newValue;
                }

                //Check if we have a new best point
                if (newValue < bestValue) {
                    if (optimizeScheme_ == EveryBestPoint) {
                        P.setCurrentValue(newPoint);
                        P.setFunctionValue(newValue);
                        localOptimizer_->minimize(P, endCriteria);
                        newPoint = P.currentValue();
                        newValue = P.functionValue();
                    }
                    kStationary = 0;
                    bestValue = newValue;
                    bestPoint = newPoint;
                }
            } catch(...){
                //Do nothing, move on to new draw
            }
            //Increase steps
            k++;
            kStationary++;
            for (double& i : annealStep)
                i++;

            //Reanneal if necessary
            if (kReAnneal == reAnnealSteps_) {
                kReAnneal = 0;
                reannealing_(annealStep, currentPoint, currentValue, currentTemperature);
            }
            kReAnneal++;

            //Reset if necessary
            if (kReset == resetSteps_) {
                kReset = 0;
                switch (resetScheme_) {
                case NoResetScheme:
                    break;
                case ResetToOrigin:
                    currentPoint = startingPoint;
                    currentValue = startingValue;
                    break;
                case ResetToBestPoint:
                    currentPoint = bestPoint;
                    currentValue = bestValue;
                    break;
                }
            }
            kReset++;

            //Update the current temperature according to current step
            temperature_(currentTemperature, currentTemperature, annealStep);

            //Check if temperature condition is breached
            for (Size i = 0; i < n; i++)
                temperatureBreached = temperatureBreached && currentTemperature[i] < endTemperature_;
        }
        
        //Change end criteria type if appropriate
        if (k > maxK)
            ecType = EndCriteria::MaxIterations;
        else if (kStationary > maxKStationary)
            ecType = EndCriteria::StationaryPoint;

        //Set result to best point
        P.setCurrentValue(bestPoint);
        P.setFunctionValue(bestValue);
        return ecType;
    }

    typedef HybridSimulatedAnnealing<SamplerGaussian, ProbabilityBoltzmannDownhill, TemperatureExponential, ReannealingTrivial> GaussianSimulatedAnnealing;
    typedef HybridSimulatedAnnealing<SamplerLogNormal, ProbabilityBoltzmannDownhill, TemperatureExponential, ReannealingTrivial> LogNormalSimulatedAnnealing;
    typedef HybridSimulatedAnnealing<SamplerMirrorGaussian, ProbabilityBoltzmannDownhill, TemperatureExponential, ReannealingTrivial> MirrorGaussianSimulatedAnnealing;
    typedef HybridSimulatedAnnealing<SamplerGaussian, ProbabilityBoltzmannDownhill, TemperatureExponential, ReannealingFiniteDifferences> GaussianSimulatedReAnnealing;
    typedef HybridSimulatedAnnealing<SamplerVeryFastAnnealing, ProbabilityBoltzmannDownhill, TemperatureVeryFastAnnealing, ReannealingTrivial> VeryFastSimulatedAnnealing;
    typedef HybridSimulatedAnnealing<SamplerVeryFastAnnealing, ProbabilityBoltzmannDownhill, TemperatureVeryFastAnnealing, ReannealingFiniteDifferences> VeryFastSimulatedReAnnealing;
}

#endif
]]></document_content>
  </document>
  <document index="386">
    <source>math/hybridsimulatedannealingfunctors.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Andres Hernandez

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hybridsimulatedannealingfunctors.hpp
\brief Functors for use on HybridSimulatedAnnealing
*/

#ifndef HYBRIDSIMULATEDANNEALINGFUNCTORS_H
#define HYBRIDSIMULATEDANNEALINGFUNCTORS_H

#include <ql/math/array.hpp>
#include <ql/math/randomnumbers/seedgenerator.hpp>
#include <ql/math/optimization/problem.hpp>

#include <boost/random/mersenne_twister.hpp>
typedef boost::mt19937 base_generator_type;

#include <boost/random/normal_distribution.hpp>
#include <boost/random/lognormal_distribution.hpp>
#include <boost/random/cauchy_distribution.hpp>
#include <boost/random/uniform_real_distribution.hpp>
typedef boost::random::uniform_real_distribution<double> uniform;
typedef boost::random::normal_distribution<> normal_random;
typedef boost::random::lognormal_distribution<> lognormal_random;
typedef boost::random::cauchy_distribution<> cauchy_random;

#include <boost/random/variate_generator.hpp>
typedef boost::variate_generator<base_generator_type&, uniform > uniform_variate;
typedef boost::variate_generator<base_generator_type, normal_random > normal_variate;
typedef boost::variate_generator<base_generator_type&, lognormal_random > lognormal_variate;
typedef boost::variate_generator<base_generator_type&, cauchy_random > cauchy_variate;

#include <algorithm> //for std::max
#include <cmath>     //for log
#include <utility>
#include <vector>

namespace QuantLib
{
    //! Lognormal Sampler
    /*!    Sample from lognormal distribution. This means that the parameter space
    must have support on the positve side of the real line only.
    */
    class SamplerLogNormal
    {
    public:
        explicit SamplerLogNormal(unsigned long seed = SeedGenerator::instance().get()) :
            generator_(seed),
            distribution_(0.0, 1.0), gaussian_(generator_, distribution_) {};
        SamplerLogNormal(const SamplerLogNormal& sampler) : generator_(sampler.gaussian_.engine()),
            distribution_(sampler.gaussian_.distribution()),
            gaussian_(generator_, distribution_) {};
        SamplerLogNormal& operator=(const SamplerLogNormal& sampler) {
            generator_ = sampler.gaussian_.engine();
            distribution_ = sampler.gaussian_.distribution();
            gaussian_ = normal_variate(generator_, distribution_);
            return *this;
        }

        inline void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const {
            QL_REQUIRE(newPoint.size() == currentPoint.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == temp.size(), "Incompatible input");
            for (Size i = 0; i < currentPoint.size(); i++)
                newPoint[i] = currentPoint[i] * exp(sqrt(temp[i])*gaussian_());
        };
    private:
        base_generator_type generator_;
        normal_random distribution_;
        mutable normal_variate gaussian_;
    };

    //! Gaussian Sampler
    /*!    Sample from normal distribution. This means that the parameter space
    must have support on the whole real line.
    */
    class SamplerGaussian
    {
    public:
        explicit SamplerGaussian(unsigned long seed = SeedGenerator::instance().get()) :
            generator_(seed),
            distribution_(0.0, 1.0), gaussian_(generator_, distribution_) {};
        SamplerGaussian(const SamplerGaussian& sampler) : generator_(sampler.gaussian_.engine()),
            distribution_(sampler.gaussian_.distribution()),
            gaussian_(generator_, distribution_) {};
        SamplerGaussian& operator=(const SamplerGaussian& sampler) {
            generator_ = sampler.gaussian_.engine();
            distribution_ = sampler.gaussian_.distribution();
            gaussian_ = normal_variate(generator_, distribution_);
            return *this;
        }

        inline void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const {
            QL_REQUIRE(newPoint.size() == currentPoint.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == temp.size(), "Incompatible input");
            for (Size i = 0; i < currentPoint.size(); i++)
                newPoint[i] = currentPoint[i] + std::sqrt(temp[i])*gaussian_();
        };
    private:
        base_generator_type generator_;
        normal_random distribution_;
        mutable normal_variate gaussian_;
    };
    
    //! Gaussian Ring Sampler
    /*! Sample from normal distribution, but constrained to lie within
     * .boundaries. If the value ends up beyond the boundary, the value
     * is circled back from the other side.
    */
    class SamplerRingGaussian
    {
    public:
      SamplerRingGaussian(Array lower,
                          Array upper,
                          unsigned long seed = SeedGenerator::instance().get())
      : generator_(seed), distribution_(0.0, 1.0), gaussian_(generator_, distribution_),
        lower_(std::move(lower)), upper_(std::move(upper)){};
      SamplerRingGaussian(const SamplerRingGaussian& sampler)
      : generator_(sampler.gaussian_.engine()), distribution_(sampler.gaussian_.distribution()),
        gaussian_(generator_, distribution_), lower_(sampler.lower_), upper_(sampler.upper_){};
      SamplerRingGaussian& operator=(const SamplerRingGaussian& sampler) {
          generator_ = sampler.gaussian_.engine();
          distribution_ = sampler.gaussian_.distribution();
          gaussian_ = normal_variate(generator_, distribution_);
          lower_ = sampler.lower_;
          upper_ = sampler.upper_;
          return *this;
        }

        inline void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const {
            QL_REQUIRE(newPoint.size() == currentPoint.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == temp.size(), "Incompatible input");
            for (Size i = 0; i < currentPoint.size(); i++){
                newPoint[i] = currentPoint[i] + std::sqrt(temp[i])*gaussian_();
                while(newPoint[i] < lower_[i] || newPoint[i] > upper_[i]){
					if(newPoint[i] < lower_[i]){
						newPoint[i] = upper_[i] + newPoint[i] - lower_[i];
					} else {
						newPoint[i] = lower_[i] + newPoint[i] - upper_[i];
					}
				} 
            }
        };
    private:
        base_generator_type generator_;
        normal_random distribution_;
        mutable normal_variate gaussian_;
        Array lower_, upper_;
    };
    
    //! Gaussian Mirror Sampler
    /*! Sample from normal distribution, but constrained to lie within
     * .boundaries. If the value ends up beyond the boundary, the value
     * is reflected back.
    */
    class SamplerMirrorGaussian
    {
    public:
      SamplerMirrorGaussian(Array lower,
                            Array upper,
                            unsigned long seed = SeedGenerator::instance().get())
      : generator_(seed), distribution_(0.0, 1.0), gaussian_(generator_, distribution_),
        lower_(std::move(lower)), upper_(std::move(upper)){};
      SamplerMirrorGaussian(const SamplerMirrorGaussian& sampler)
      : generator_(sampler.gaussian_.engine()), distribution_(sampler.gaussian_.distribution()),
        gaussian_(generator_, distribution_), lower_(sampler.lower_), upper_(sampler.upper_){};
      SamplerMirrorGaussian& operator=(const SamplerMirrorGaussian& sampler) {
          generator_ = sampler.gaussian_.engine();
          distribution_ = sampler.gaussian_.distribution();
          gaussian_ = normal_variate(generator_, distribution_);
          lower_ = sampler.lower_;
          upper_ = sampler.upper_;
          return *this;
        }

        inline void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const {
            QL_REQUIRE(newPoint.size() == currentPoint.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == temp.size(), "Incompatible input");
            for (Size i = 0; i < currentPoint.size(); i++){
                newPoint[i] = currentPoint[i] + std::sqrt(temp[i])*gaussian_();
                while(newPoint[i] < lower_[i] || newPoint[i] > upper_[i]){
					if(newPoint[i] < lower_[i]){
						newPoint[i] = lower_[i] + lower_[i] - newPoint[i];
					} else {
						newPoint[i] = upper_[i] + upper_[i] - newPoint[i];
					}
				}
            }
        };
    private:
        base_generator_type generator_;
        normal_random distribution_;
        mutable normal_variate gaussian_;
        Array lower_, upper_;
    };

    //! Cauchy Sampler
    /*!    Sample from cauchy distribution. This means that the parameter space
    must have support on the positive whole real line. For lower dimensions
    it could be faster than the Gaussian sampler, specially when combined
    with the Cauchy temperature.
    */
    class SamplerCauchy
    {
    public:
        explicit SamplerCauchy(unsigned long seed = SeedGenerator::instance().get()) :
            generator_(seed),
            distribution_(0.0, 1.0), cauchy_(generator_, distribution_) {};
        SamplerCauchy(const SamplerCauchy& sampler) : generator_(sampler.cauchy_.engine()),
            distribution_(sampler.cauchy_.distribution()),
            cauchy_(generator_, distribution_) {};

        inline void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const {
            QL_REQUIRE(newPoint.size() == currentPoint.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == temp.size(), "Incompatible input");
            for (Size i = 0; i < currentPoint.size(); i++)
                newPoint[i] = currentPoint[i] + temp[i] * cauchy_();
        };
    protected:
        base_generator_type generator_;
        cauchy_random distribution_;
        mutable cauchy_variate cauchy_;
    };

    //! Very Fast Annealing Sampler
    /*!    For consistency should be used with TemperatureVeryFastAnnealing.
    Requires that the parameter space be bounded above and below.
    */
    class SamplerVeryFastAnnealing
    {
    public:
      SamplerVeryFastAnnealing(Array lower,
                               Array upper,
                               unsigned long seed = SeedGenerator::instance().get())
      : lower_(std::move(lower)), upper_(std::move(upper)), generator_(seed),
        uniform_(generator_, distribution_) {
          QL_REQUIRE(lower_.size() == upper_.size(), "Incompatible input");
      };
        SamplerVeryFastAnnealing(const SamplerVeryFastAnnealing& sampler) :
            lower_(sampler.lower_), upper_(sampler.upper_),
            generator_(sampler.uniform_.engine()), distribution_(sampler.uniform_.distribution()),
            uniform_(generator_, distribution_) {
            QL_REQUIRE(lower_.size() == upper_.size(), "Incompatible input");
        };

        inline void operator()(Array &newPoint, const Array &currentPoint, const Array &temp) const {
            QL_REQUIRE(newPoint.size() == currentPoint.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == lower_.size(), "Incompatible input");
            QL_REQUIRE(newPoint.size() == temp.size(), "Incompatible input");
            for (Size i = 0; i < currentPoint.size(); i++) {
                newPoint[i] = lower_[i] - 1.0;
                while (newPoint[i] < lower_[i] || newPoint[i] > upper_[i]) {
                    Real draw = uniform_();
                    Real sign = static_cast<int>(0.5 < draw) - static_cast<int>(draw < 0.5);
                    Real y = sign*temp[i] * (std::pow(1.0 + 1.0 / temp[i],
                                                      std::abs(2 * draw - 1.0)) - 1.0);
                    newPoint[i] = currentPoint[i] + y*(upper_[i] - lower_[i]);
                }
            }
        };
    private:
        Array lower_, upper_;
        base_generator_type generator_;
        uniform distribution_;
        mutable uniform_variate uniform_;
    };

    //! Always Downhill Probability
    /*!    Only points that improve on the current solution are accepted.
    Depending on the problem, this makes it very unlikely that the
    optimizer will be able to escape a local optimum.
    */
    struct ProbabilityAlwaysDownhill {
        inline bool operator()(Real currentValue, Real newValue, const Array &temp) const {
            return currentValue > newValue; //return true if new value is lower than old value
        }
    };

    //! Boltzmann Probability
    /*!    The probability of accepting a new point is sampled from a Boltzmann distribution.
    A point is accepted if \f$ \frac{1}{1+exp(-(current-new)/T)} > u \f$
    where \f$ u \f$ is drawn from a uniform distribution.
    */
    class ProbabilityBoltzmann {
    public:
        explicit ProbabilityBoltzmann(unsigned long seed = SeedGenerator::instance().get()) :
            generator_(seed),
            uniform_(generator_, distribution_) {};
        ProbabilityBoltzmann(const ProbabilityBoltzmann &probability) :
            generator_(probability.uniform_.engine()), distribution_(probability.uniform_.distribution()),
            uniform_(generator_, distribution_) {};
        inline bool operator()(Real currentValue, Real newValue, const Array &temp) const {
            Real temperature = *std::max_element(temp.begin(), temp.end());
            return (1.0 / (1.0 + exp((newValue - currentValue) / temperature))) > uniform_();
        }
    private:
        base_generator_type generator_;
        uniform distribution_;
        mutable uniform_variate uniform_;
    };
    //! Boltzmann Downhill Probability
    /*!    Similarly to the Boltzmann Probability, but if new < current, then the point is
    always accepted.
    */
    class ProbabilityBoltzmannDownhill
    {
    public:
        explicit ProbabilityBoltzmannDownhill(unsigned long seed = SeedGenerator::instance().get()) :
            generator_(seed),
            uniform_(generator_, distribution_) {};
        ProbabilityBoltzmannDownhill(const ProbabilityBoltzmannDownhill& probability) :
            generator_(probability.uniform_.engine()), distribution_(probability.uniform_.distribution()),
            uniform_(generator_, distribution_) {};
        inline bool operator()(Real currentValue, Real newValue, const Array &temp) const {
            if (newValue < currentValue)
                return true;
            double mTemperature = *std::max_element(temp.begin(), temp.end());
            return (1.0 / (1.0 + exp((newValue - currentValue) / mTemperature))) > uniform_();
        }
    private:
        base_generator_type generator_;
        uniform distribution_;
        mutable uniform_variate uniform_;
    };
    //! Temperature Boltzmann
    /*!    For use with the Gaussian sampler
    */
    class TemperatureBoltzmann {
    public:
        TemperatureBoltzmann(Real initialTemp, Size dimension)
            : initialTemp_(dimension, initialTemp) {}
        inline void operator()(Array &newTemp, const Array &currTemp, const Array &steps) const {
            QL_REQUIRE(currTemp.size() == initialTemp_.size(), "Incompatible input");
            QL_REQUIRE(currTemp.size() == newTemp.size(), "Incompatible input");
            for (Size i = 0; i < initialTemp_.size(); i++)
                newTemp[i] = initialTemp_[i] / log(steps[i]);
        }
    private:
        Array initialTemp_;
    };
    //! Temperature Cauchy
    /*!    For use with the Cauchy sampler
    */
    class TemperatureCauchy {
    public:
        TemperatureCauchy(Real initialTemp, Size dimension)
            : initialTemp_(dimension, initialTemp) {}
        inline void operator()(Array &newTemp, const Array &currTemp, const Array &steps) const {
            QL_REQUIRE(currTemp.size() == initialTemp_.size(), "Incompatible input");
            QL_REQUIRE(currTemp.size() == newTemp.size(), "Incompatible input");
            for (Size i = 0; i < initialTemp_.size(); i++)
                newTemp[i] = initialTemp_[i] / steps[i];
        }
    private:
        Array initialTemp_;
    };

    class TemperatureCauchy1D {
    public:
        TemperatureCauchy1D(Real initialTemp, Size dimension) :
            inverseN_(1.0 / dimension),
            initialTemp_(dimension, initialTemp) {}
        inline void operator()(Array &newTemp, const Array &currTemp, const Array &steps) const {
            QL_REQUIRE(currTemp.size() == initialTemp_.size(), "Incompatible input");
            QL_REQUIRE(currTemp.size() == newTemp.size(), "Incompatible input");
            for (Size i = 0; i < initialTemp_.size(); i++)
                newTemp[i] = initialTemp_[i] / std::pow(steps[i], inverseN_);
        }
    private:
        Real inverseN_;
        Array initialTemp_;
    };

    class TemperatureExponential {
    public:
        TemperatureExponential(Real initialTemp, Size dimension, Real power = 0.95)
            : initialTemp_(dimension, initialTemp), power_(power) {}
        inline void operator()(Array &newTemp, const Array &currTemp, const Array &steps) const {
            QL_REQUIRE(currTemp.size() == initialTemp_.size(), "Incompatible input");
            QL_REQUIRE(currTemp.size() == newTemp.size(), "Incompatible input");
            for (Size i = 0; i < initialTemp_.size(); i++)
                newTemp[i] = initialTemp_[i] * std::pow(power_, steps[i]);
        }
    private:
        Array initialTemp_;
        Real power_;
    };
    //! Temperature Very Fast Annealing
    /*!    For use with the Very Fast Annealing sampler
    */
    class TemperatureVeryFastAnnealing {
    public:
        TemperatureVeryFastAnnealing(Real initialTemp, Real finalTemp, Real maxSteps, Size dimension)
            :inverseN_(1.0 / dimension), initialTemp_(dimension, initialTemp),
            finalTemp_(dimension, finalTemp), exponent_(dimension, 0.0) {
            Real coeff = std::pow(maxSteps, -inverseN_);
            for (Size i = 0; i < initialTemp_.size(); i++)
                exponent_[i] = -log(finalTemp_[i] / initialTemp_[i])*coeff;
        }
        inline void operator()(Array &newTemp, const Array &currTemp, const Array &steps) const {
            QL_REQUIRE(currTemp.size() == initialTemp_.size(), "Incompatible input");
            QL_REQUIRE(currTemp.size() == newTemp.size(), "Incompatible input");
            for (Size i = 0; i < initialTemp_.size(); i++)
                newTemp[i] = initialTemp_[i] * exp(-exponent_[i] * std::pow(steps[i], inverseN_));
        }
    private:
        Real inverseN_;
        Array initialTemp_, finalTemp_, exponent_;
    };
    //! Reannealing Trivial
    /*!    No reannealing is performed
    */
    struct ReannealingTrivial {
        ReannealingTrivial() = default;
        ;
        inline void setProblem(Problem &P) {};
        inline void operator()(Array & steps, const Array &currentPoint,
            Real aCurrentValue, const Array & currTemp) const {};
    };
    //! Reannealing Finite Difference
    /*!    In multidimensional problems, different dimensions might have different
    sensitivities, and might have dimensions on which the solution is rather
    insensitive. If possible, the search should concentrate more on the more
    sensitive dimensions, therefore a reannealing schedule might raise the
    temperature seen by those more fruitful dimensions so as to allow for more
    movement along the dimensions of interest
    */
    class ReannealingFiniteDifferences {
    public:
        ReannealingFiniteDifferences(Real initialTemp,
            Size dimension,
            const Array & lower = Array(),
            const Array & upper = Array(),
            Real stepSize = 1e-7,
            Real minSize = 1e-10,
            Real functionTol = 1e-10)
            : stepSize_(stepSize), minSize_(minSize),
            functionTol_(functionTol), N_(dimension), bound_(false),
            lower_(lower), upper_(upper), initialTemp_(dimension, initialTemp),
            bounded_(dimension, 1.0) {
            if (!lower.empty() && !upper.empty()) {
                QL_REQUIRE(lower.size() == N_, "Incompatible input");
                QL_REQUIRE(upper.size() == N_, "Incompatible input");
                bound_ = true;
                for (Size i = 0; i < N_; i++) {
                    bounded_[i] = upper[i] - lower[i];
                }
            }
        }
        inline void setProblem(Problem &P) { problem_ = &P; };
        inline void operator()(Array & steps, const Array &currentPoint,
            Real currentValue, const Array & currTemp) const {
            QL_REQUIRE(currTemp.size() == N_, "Incompatible input");
            QL_REQUIRE(steps.size() == N_, "Incompatible input");

            Array finiteDiffs(N_, 0.0);
            double finiteDiffMax = 0.0;
            Array ofssetPoint(currentPoint);
            for (Size i = 0; i < N_; i++) {
                ofssetPoint[i] += stepSize_;
                finiteDiffs[i] = bounded_[i] * std::abs((problem_->value(ofssetPoint) - currentValue) / stepSize_);
                ofssetPoint[i] -= stepSize_;
                if (finiteDiffs[i] < minSize_)
                    finiteDiffs[i] = minSize_;
                if (finiteDiffs[i] > finiteDiffMax)
                    finiteDiffMax = finiteDiffs[i];
            }
            for (Size i = 0; i < N_; i++) {
                Real tRatio = initialTemp_[i] / currTemp[i];
                Real sRatio = finiteDiffMax / finiteDiffs[i];
                if (sRatio*tRatio < functionTol_)
                    steps[i] = std::pow(std::fabs(std::log(functionTol_)),
                                        Integer(N_));
                else
                    steps[i] = std::pow(std::fabs(std::log(sRatio*tRatio)),
                                        Integer(N_));
            }
        }
    private:
        Problem *problem_;
        Real stepSize_, minSize_, functionTol_;
        Size N_;
        bool bound_;
        Array lower_, upper_, initialTemp_, bounded_;
    };
}
#endif // HYBRIDSIMULATEDANNEALINGFUNCTORS_H
]]></document_content>
  </document>
  <document index="387">
    <source>math/isotropicrandomwalk.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Andres Hernandez

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file isotropicrandomwalk.hpp
    \brief Isotropic random walk
*/

#ifndef quantlib_isotropic_random_walk_hpp
#define quantlib_isotropic_random_walk_hpp

#include <ql/math/array.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/mathconstants.hpp>
#include <boost/random/variate_generator.hpp>
#include <utility>

namespace QuantLib {

    //! Isotropic random walk
    /*! A variate is used to draw from a random element of a 
        probability distribution. The draw corresponds to the 
        radius of a d-dimensional sphere. The position on the
        surface of the d-dimensional sphere is randomly chosen
        with all points on the surface having the same probability,
        i.e. all directions are isotropic and the step is randomly
        drawn from the given variate.
    */
    template <class Distribution, class Engine>
    class IsotropicRandomWalk {
      public:
        typedef boost::variate_generator<Engine, Distribution> VariateGenerator;
        IsotropicRandomWalk(const Engine& eng,
                            Distribution dist,
                            Size dim,
                            Array weights = Array(),
                            unsigned long seed = 0)
        : variate_(eng, dist), rng_(seed), weights_(std::move(weights)), dim_(dim) {
            if (weights_.empty())
                weights_ = Array(dim, 1.0);
            else
                QL_REQUIRE(dim_ == weights_.size(), "Invalid weights");
        }
        template <class InputIterator>
        inline void nextReal(InputIterator first) const {
            Real radius = variate_();
            Array::const_iterator weight = weights_.begin();
            if (dim_ > 1) {
                //Isotropic random direction
                Real phi = M_PI*rng_.nextReal();
                for (Size i = 0; i < dim_ - 2; i++) {
                    *first++ = radius*cos(phi)*(*weight++);
                    radius *= sin(phi);
                    phi = M_PI*rng_.nextReal();
                }
                *first++ = radius*cos(2.0*phi)*(*weight++);
                *first = radius*sin(2.0*phi)*(*weight);
            }
            else {
                if (rng_.nextReal() < 0.5)
                    *first = -radius*(*weight);
                else
                    *first = radius*(*weight);
            }
        }
        inline void setDimension(Size dim) { 
            dim_ = dim;
            weights_ = Array(dim, 1.0);
        }
        inline void setDimension(Size dim, const Array& weights) {
            QL_REQUIRE(dim == weights.size(), "Invalid weights");
            dim_ = dim;
            weights_ = weights;
        }
        /*!
        The isotropic random walk will not adjust its draw to be within the lower and upper bounds,
        but if the limits are provided, they are used to rescale the sphere so as to make it to an
        ellipsoid, with different radius in different dimensions.
        */
        inline void setDimension(Size dim,
            const Array& lowerBound, const Array& upperBound) {
            QL_REQUIRE(dim == lowerBound.size(),
                "Incompatible dimension and lower bound");
            QL_REQUIRE(dim == upperBound.size(),
                "Incompatible dimension and upper bound");
            //Find largest bound
            Array bounds = upperBound - lowerBound;
            Real maxBound = bounds[0];
            for (Size j = 1; j < dim; j++) {
                if (bounds[j] > maxBound) maxBound = bounds[j];
            }
            //weights by dimension is the size of the bound
            //divided by the largest bound
            maxBound = 1.0 / maxBound;
            bounds *= maxBound;
            setDimension(dim, bounds);
        }
      protected:
        mutable VariateGenerator variate_;
        MersenneTwisterUniformRng rng_;
        Array weights_;
        Size dim_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="388">
    <source>math/laplaceinterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file laplaceinterpolation.hpp
    \brief Laplace interpolation of missing values
*/

#ifndef quantlib_laplace_interpolation
#define quantlib_laplace_interpolation

#include <ql/math/matrixutilities/bicgstab.hpp>
#include <ql/math/matrixutilities/sparsematrix.hpp>

namespace QuantLib {

/*! reference: Numerical Recipes, 3rd edition, ch. 3.8
    two dimensional reconstruction of missing (i.e. null)
    values using laplace interpolation assuming an
    equidistant grid */

template <class M> void laplaceInterpolation(M &A, Real relTol = 1E-6) {

    struct f_A {
        const SparseMatrix &g;
        explicit f_A(const SparseMatrix &g) : g(g) {}
        Disposable<Array> operator()(const Array &x) const {
            return prod(g, x);
        }
    };

    Size m = A.rows();
    Size n = A.columns();

    QL_REQUIRE(n > 1 && m > 1, "matrix (" << m << "," << n
                                          << ") must at least be 2x2");

    SparseMatrix g(m * n, m * n, 5 * m * n);
    Array rhs(m * n, 0.0), guess(m * n, 0.0);
    Real guessTmp = 0.0;
    Size i1, i2, i3, i4, j1, j2, j3, j4;
    bool inner;

    for (Size l = 0, i = 0; i < m; ++i) {
        for (Size j = 0; j < n; ++j) {

            inner = false;

            // top
            if (i == 0) {
                if (j == 0) {
                    i1 = 0;
                    j1 = 1;
                    i2 = 1;
                    j2 = 0;
                } else {
                    if (j == n - 1) {
                        i1 = 0;
                        j1 = n - 2;
                        i2 = 1;
                        j2 = n - 1;
                    } else {
                        i1 = i2 = 0;
                        j1 = j - 1;
                        j2 = j + 1;
                    }
                }
            }

            // bottom
            if (i == m - 1) {
                if (j == 0) {
                    i1 = m - 1;
                    j1 = 1;
                    i2 = m - 2;
                    j2 = 0;
                } else {
                    if (j == n - 1) {
                        i1 = m - 1;
                        j1 = n - 2;
                        i2 = m - 2;
                        j2 = n - 1;
                    } else {
                        i1 = i2 = m - 1;
                        j1 = j - 1;
                        j2 = j + 1;
                    }
                }
            }

            // left / right
            if (i > 0 && i < m - 1) {
                if (j == 0 || j == n - 1) {
                    j1 = j2 = j;
                    i1 = i - 1;
                    i2 = i + 1;
                } else {
                    inner = true;
                    i1 = i - 1;
                    i2 = i - 1;
                    i3 = i + 1;
                    i4 = i + 1;
                    j1 = j - 1;
                    j2 = j + 1;
                    j3 = j - 1;
                    j4 = j + 1;
                }
            }

            g(l, i * n + j) = 1.0;
            if (A[i][j] == Null<Real>()) {
                if (inner) {
                    g(l, i1 * n + j1) = -0.25;
                    g(l, i2 * n + j2) = -0.25;
                    g(l, i3 * n + j3) = -0.25;
                    g(l, i4 * n + j4) = -0.25;
                } else {
                    g(l, i1 * n + j1) = -0.5;
                    g(l, i2 * n + j2) = -0.5;
                }
                rhs[l] = 0.0;
                guess[l] = guessTmp;
            } else {
                rhs[l] = A[i][j];
                guess[l] = guessTmp = A[i][j];
            }
            ++l;
        }
    }

    // solve the equation (preconditioner is identiy)
    Array s = BiCGstab(f_A(g), 10 * m * n, relTol)
                  .solve(rhs, guess)
                  .x;

    // replace missing values by solution
    for (Size i = 0; i < m; ++i) {
        for (Size j = 0; j < n; ++j) {
            if (A[i][j] == Null<Real>()) {
                A[i][j] = s[i * n + j];
            }
        }
    }
};

} // namespace QuantLib

#endif // include guard
]]></document_content>
  </document>
  <document index="389">
    <source>math/latentmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_latent_model_hpp
#define quantlib_latent_model_hpp

#include <ql/experimental/math/multidimquadrature.hpp>
#include <ql/experimental/math/multidimintegrator.hpp>
#include <ql/math/integrals/trapezoidintegral.hpp>
#include <ql/math/randomnumbers/randomsequencegenerator.hpp>
#include <ql/experimental/math/gaussiancopulapolicy.hpp>
#include <ql/experimental/math/tcopulapolicy.hpp>
#include <ql/math/randomnumbers/boxmullergaussianrng.hpp>
#include <ql/math/functional.hpp>
#include <ql/experimental/math/polarstudenttrng.hpp>
#include <ql/handle.hpp>
#include <ql/quote.hpp>
#include <vector>

/*! \file latentmodel.hpp
    \brief Generic multifactor latent variable model.
*/

namespace QuantLib {

    namespace detail {
        // havent figured out how to do this in-place
        struct multiplyV {
            typedef Disposable<std::vector<Real> > result_type;
            Disposable<std::vector<Real> > 
                operator()(Real d,  Disposable<std::vector<Real> > v) 
            {
                std::transform(v.begin(), v.end(), v.begin(), 
                               multiply_by<Real>(d));
                return v;
            }
        };
    }

    //! \name Latent model direct integration facility.
    //@{
    /* Things trying to achieve here:
    1.- Unify the two branches of integrators in the library, they do not 
      hang from a common base class and here a common ptr for the 
      factory is needed.
    2.- Have a common signature for the integration call.
    3.- Factory construction so integrable latent models can choose the 
      integration algorithm separately.
    */
    class LMIntegration {
    public:
        // Interface with actual integrators:
        // integral of a scalar function
        virtual Real integrate(const ext::function<Real (
            const std::vector<Real>& arg)>& f) const = 0;
        // integral of a vector function
        /* I had to use a different name, since the compiler does not
        recognise the overload; MSVC sees the argument as 
        ext::function<Signature> in both cases....   
        I could do the as with the quadratures and have this as a template 
        function and spez for the vector case but I prefer to understand
        why the overload fails....
                    FIX ME
        */
        virtual Disposable<std::vector<Real> > integrateV(
            const ext::function<Disposable<std::vector<Real> >  (
            const std::vector<Real>& arg)>& f) const {
            QL_FAIL("No vector integration provided");
        }
        virtual ~LMIntegration() = default;
    };

    //CRTP-ish for joining the integrations, class above to have the factory
    template <class I_T>
    class IntegrationBase : 
        public I_T, public LMIntegration {// diamond on 'integrate'
     // this class template always to be fully specialized:
     private:
       IntegrationBase() = default;
       ~IntegrationBase() override = default;
    };
    //@}
    
    // gcc reports value collision with heston engine (?!) thats why the name
    namespace LatentModelIntegrationType {
        typedef 
        enum LatentModelIntegrationType {
            #ifndef QL_PATCH_SOLARIS
            GaussianQuadrature,
            #endif
            Trapezoid
            // etc....
        } LatentModelIntegrationType;
    }

    #ifndef QL_PATCH_SOLARIS

    /* class template specializations. I havent use CRTP type cast directly
    because the signature of the integrators is different, grid integration
    needs the domain. */
    template<> class IntegrationBase<GaussianQuadMultidimIntegrator> : 
    public GaussianQuadMultidimIntegrator, public LMIntegration {
    public:
        IntegrationBase(Size dimension, Size order) 
        : GaussianQuadMultidimIntegrator(dimension, order) {}
        Real integrate(const ext::function<Real(const std::vector<Real>& arg)>& f) const override {
            return GaussianQuadMultidimIntegrator::integrate<Real>(f);
        }
        Disposable<std::vector<Real> > integrateV(
            const ext::function<Disposable<std::vector<Real> >(const std::vector<Real>& arg)>& f)
            const override {
            return GaussianQuadMultidimIntegrator::integrate<Disposable<std::vector<Real> > >(f);
        }
        ~IntegrationBase() override = default;
    };

    #endif

    template<> class IntegrationBase<MultidimIntegral> : 
        public MultidimIntegral, public LMIntegration {
    public:
        IntegrationBase(
            const std::vector<ext::shared_ptr<Integrator> >& integrators, 
            Real a, Real b) 
        : MultidimIntegral(integrators), 
          a_(integrators.size(),a), b_(integrators.size(),b) {}
        Real integrate(const ext::function<Real(const std::vector<Real>& arg)>& f) const override {
            return MultidimIntegral::operator()(f, a_, b_);
        }
        // disposable vector version here....
        ~IntegrationBase() override = default;
        const std::vector<Real> a_, b_;
    };

    // Intended to replace OneFactorCopula

    /*!
    \brief Generic multifactor latent variable model.\par
        In this model set up one considers latent (random) variables 
        \f$ Y_i \f$ described by:
        \f[
        \begin{array}{ccccc}
        Y_1 & = & \sum_k M_k a_{1,k} & + \sqrt{1-\sum_k a_{1,k}^2} Z_1 & 
            \sim \Phi_{Y_1}\nonumber \\
        ... & = &      ... & ...   & \nonumber \\
        Y_i & = & \sum_k M_k a_{i,k} & + \sqrt{1-\sum_k a_{i,k}^2} Z_i & 
            \sim \Phi_{Y_i}\nonumber \\
        ... & = &      ... & ...   & \nonumber \\
        Y_N & = & \sum_k M_k a_{N,k} & + \sqrt{1-\sum_k a_{N,k}^2} Z_N & 
            \sim \Phi_{Y_N}
        \end{array}
        \f]
        where the systemic \f$ M_k \f$ and idiosyncratic \f$ Z_i \f$ (this last 
        one known as error term in some contexts) random variables have 
        independent zero-mean unit-variance distributions. A restriction of the 
        model implemented here is that the N idiosyncratic variables all follow 
        the same probability law \f$ \Phi_Z(z)\f$ (but they are still 
        independent random variables) Also the model is normalized 
        so that: \f$-1\leq a_{i,k} \leq 1\f$ (technically the \f$Y_i\f$ are 
        convex linear combinations). The correlation between \f$Y_i\f$ and 
        \f$Y_j\f$ is then \f$\sum_k a_{i,k} a_{j,k}\f$. 
        \f$\Phi_{Y_i}\f$ denotes the cumulative distribution function of 
        \f$Y_i\f$ which in general differs for each latent variable.\par
        In its single factor set up this model is usually employed in derivative
        pricing and it is best to use it through integration of the desired 
        statistical properties of the model; in its multifactorial version (with
        typically around a dozen factors) it is used in the context of portfolio
        risk metrics; because of the number of variables it is best to opt for a
        simulation to compute model properties/magnitudes. 
        For this reason this class template provides a random factor sample 
        interface and an integration interface that will be instantiated by 
        derived concrete models as needed. The class is neutral on the 
        integration and random generation algorithms\par
        The latent variables are typically treated as unobservable magnitudes 
        and they serve to model one or several magnitudes related to them 
        through some function
        \f[
        \begin{array}{ccc}
        F_i(Y_i) & = & 
            F_i(\sum_k M_k a_{i,k} + \sqrt{1-\sum_k a_{i,k}^2} Z_i )\nonumber \\
        & = & F_i(M_1,..., M_k, ..., M_K, Z_i)
        \end{array}
        \f]
        The transfer function can have a more generic form: 
        \f$F_i(Y_1,....,Y_N)\f$ but here the model is restricted to a one to 
        one relation between the latent variables and the modelled ones. Also 
        it is assumed that \f$F_i(y_i; \tau)\f$ is monotonic in \f$y_i\f$; it 
        can then be inverted and the relation of the cumulative probability of 
        \f$F_i\f$ and \f$Y_i\f$ is simple:
        \f[
        \int_{\infty}^b \phi_{F_i} df = 
            \int_{\infty}^{F_i^{-1}(b)} \phi_{Y_i} dy
        \f]
        If  \f$t\f$ is some value of the functional or modelled variable, 
        \f$y\f$ is mapped to \f$t\f$ such that percentiles match, i.e. 
        \f$F_Y(y)=Q_i(t)\f$ or \f$y=F_Y^{-1}(Q_i(t))\f$.
        The class provides an integration facility of arbitrary functions 
        dependent on the model states. It also provides random number generation
        interfaces for usage of the model in monte carlo simulations.\par
        Now let \f$\Phi_Z(z)\f$ be the cumulated distribution function of (all 
        equal as mentioned) \f$Z_i\f$. For a given realization of \f$M_k\f$, 
        this determines the distribution of \f$y\f$:
        \f[
        Prob \,(Y_i < y|M_k) = \Phi_Z \left( \frac{y-\sum_k a_{i,k}\,M_k}
            {\sqrt{1-\sum_k a_{i,k}^2}}\right)
        \qquad
        \mbox{or}
        \qquad
        Prob \,(t_i < t|M) = \Phi_Z \left( \frac
            {F_{Y_{i}}^{-1}(Q_i(t))-\sum_k a_{i,k}\,M_k}
            {\sqrt{1-\sum_k a_{i,k}^2}}
        \right)
        \f]
        The distribution functions of \f$ M_k, Z_i \f$ are specified in
        specific copula template classes. The distribution function 
        of \f$ Y_i \f$ is then given by the convolution
        \f[
        F_{Y_{i}}(y) = Prob\,(Y_i<y) = 
        \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty}\:
        D_Z(z)\,\prod_k D_{M_{k}}(m_k) \quad
        \Theta \left(y - \sum_k a_{i,k}m_k - 
            \sqrt{1-\sum_k a_{i,k}^2}\,z\right)\,d\bar{m}\,dz,
        \qquad
        \Theta (x) = \left\{
        \begin{array}{ll}
        1 & x \geq 0 \\
        0 & x < 0
        \end{array}\right.
        \f]
        where \f$ D_Z(z) \f$ and \f$ D_M(m) \f$ are the probability
        densities of \f$ Z\f$ and \f$ M, \f$ respectively.\par
        This convolution can also be written
        \f[
        F_{Y_{i}}(y) = Prob \,(Y_i < y) =
        \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty} 
            D_{M_{k}}(m_k)\,dm_k\:
        \int_{-\infty}^{g(y,\vec{a},\vec{m})} D_Z(z)\,dz, \qquad
        g(y,\vec{a},\vec{m}) = \frac{y - \sum_k a_{i,k}m_k}
            {\sqrt{1-\sum_k a_{i,k}^2}}, \qquad \sum_k a_{i,k}^2 < 1
        \f]
        In general, \f$ F_{Y_{i}}(y) \f$ needs to be computed numerically.\par
        The policy class template separates the copula function (the 
        distributions involved) and the functionality (i.e. what the latent  
        model represents: a default probability, a recovery...). Since the  
        copula methods for the 
        probabilities are to be called repeatedly from an integration or a MC 
        simulation, virtual tables are avoided and template parameter mechnics 
        is preferred.\par
        There is nothing at this level enforncing the requirement 
        on the factor distributions to be of zero mean and unit variance. Thats 
        the user responsibility and the model fails to behave correctly if it 
        is not the case.\par
        Derived classes should implement a modelled magnitude (default time, 
        etc) and will provide probability distributions and conditional values.
        They could also provide functionality for the parameter inversion 
        problem, the (e.g.) time at which the modeled variable first takes a 
        given value. This problem has solution/sense depending on the transfer 
        function \f$F_i(Y_i)\f$ characteristics.

        To make direct integration and simulation time efficient virtual 
        functions have been avoided in accessing methods in the copula policy 
        and in the sampling of the random factors
    */
    template <class copulaPolicyImpl>
    class LatentModel 
        : public virtual Observer , public virtual Observable 
    {//observer if factors as quotes
    public:
      void update() override;
      //! \name Copula interface.
      //@{
      typedef copulaPolicyImpl copulaType;
      /*! Cumulative probability of the \f$ Y_i \f$ modelled latent random
          variable to take a given value.
      */
      Probability cumulativeY(Real val, Size iVariable) const {
          return copula_.cumulativeY(val, iVariable);
        }
        //! Cumulative distribution of Z, the idiosyncratic/error factors.
        Probability cumulativeZ(Real z) const {
            return copula_.cumulativeZ(z);
        }
        //! Density function of M, the market/systemic factors.
        Probability density(const std::vector<Real>& m) const {
            #if defined(QL_EXTRA_SAFETY_CHECKS)
                QL_REQUIRE(m.size() == nFactors_, 
                    "Factor size must match that of model.");
            #endif
            return copula_.density(m);
        }
        //! Inverse cumulative distribution of the systemic factor iFactor.
        Real inverseCumulativeDensity(Probability p, Size iFactor) const {
            return copula_.inverseCumulativeDensity(p, iFactor);
        }
        /*! Inverse cumulative value of the i-th random latent variable with a 
         given probability. */
        Real inverseCumulativeY(Probability p, Size iVariable) const {
            return copula_.inverseCumulativeY(p, iVariable);
        }
        /*! Inverse cumulative value of the idiosyncratic variable with a given 
        probability. */
        Real inverseCumulativeZ(Probability p) const {
            return copula_.inverseCumulativeZ(p);
        }
        /*! All factor cumulative inversion. Used in integrations and sampling.
            Inverts all the cumulative random factors probabilities in the 
            model. These are all the systemic factors plus all the idiosyncratic
            ones, so the size of the inversion is the number of systemic factors
            plus the number of latent modelled variables*/
        Disposable<std::vector<Real> > 
            allFactorCumulInverter(const std::vector<Real>& probs) const {
            return copula_.allFactorCumulInverter(probs);
        }
        //@}

        /*! The value of the latent variable Y_i conditional to
            (given) a set of values of the factors.

            The passed allFactors vector contains values for all the
            independent factors in the model (systemic and
            idiosyncratic, in that order). A full sample is required,
            i.e. all the idiosyncratic values are expected to be
            present even if only the relevant one is used.
        */
        Real latentVarValue(const std::vector<Real>& allFactors, 
                            Size iVar) const 
        {
            return std::inner_product(factorWeights_[iVar].begin(), 
                // systemic term:
                factorWeights_[iVar].end(), allFactors.begin(),
                // idiosyncratic term:
                allFactors[numFactors()+iVar] * idiosyncFctrs_[iVar]);
        }
        // \to do write variants of the above, although is the most common case

        const copulaType& copula() const {
            return copula_;
        }


    //  protected:
        //! \name Latent model random factor number generator facility.
        //@{
        /*!  Allows generation or random samples of the latent variable. 

            Generates samples of all the factors in the latent model according 
            to the given copula as random sequence. The default implementation 
            given uses the inversion in the copula policy (which must be 
            present).
            USNG is expected to be a uniform sequence generator in the default 
            implementation. 
        */
        /*
            Several (very different) usages make the spez non trivial
            The final goal is to obtain a sequence generator of the factor 
            samples, several routes are possible depending on the algorithms:
            
            1.- URNG -> Sequence Gen -> CopulaInversion  
              e.g.: CopulaInversion(RandomSequenceGenerator<MersenneTwisterRNG>)
            2.- PseudoRSG ------------> CopulaInversion
              e.g.: CopulaInversion(SobolRSG)
            3.- URNG -> SpecificMapping -> Sequence Gen  (bypasses the copula 
                for performance)
              e.g.: RandomSequenceGenerator<BoxMullerGaussianRng<
                MersenneTwisterRNG> > 
            
            Notice that the order the three algorithms involved (uniform gen, 
            sequence construction, distribution mapping) is not always the same.
            (in fact there could be some other ways to generate but these are 
            the ones in the library now.)
            Difficulties arise when wanting to use situation 3.- whith a generic
            RNG, leaving it unspecified
            
            Derived classes might specialize (on the copula
            type) to another type of generator if a more efficient algorithm 
            that the distribution inversion is available; rewritig then the 
            nextSequence method for a particular copula implementation.
            Some combinations of generators might make no sense, while it 
            could be possible to block template classes corresponding to those
            cases its not done (yet?) (e.g. a BoxMuller under a TCopula.)
            Dimensionality coherence (between the generator and the copula) 
            should have been checked by the client code.
            In multithread usage the sequence generator is expect to be already
            in position.
            To sample the latent variable itself users should call 
            LatentModel::latentVarValue with these samples.
        */
        // Cant use InverseCumulativeRsg since the inverse there has to return a
        //   real number and here a vector is needed, the function inverted here
        //   is multivalued.
        template <class USNG, 
            // dummy template parameter to allow for 'full' specialization of 
            // inner class without specialization of the outer.
            bool = true>
        class FactorSampler {
        public:
            typedef Sample<std::vector<Real> > sample_type;
            explicit FactorSampler(const copulaType& copula, 
                BigNatural seed = 0) 
            : sequenceGen_(copula.numFactors(), seed), // base case construction
              x_(std::vector<Real>(copula.numFactors()), 1.0),
              copula_(copula) { }
            /*! Returns a sample of the factor set \f$ M_k\,Z_i\f$. 
            This method has the vocation of being specialized at particular 
            types of the copula with a more efficient inversion to generate the 
            random variables modelled (e.g. Box-Muller for a gaussian).
            Here a default implementation is provided based directly on the 
            inversion of the cumulative distribution from the copula.
            Care has to be taken in potential specializations that the generator
            algorithm is compatible with an eventual concurrence of the 
            simulations.
             */
            const sample_type& nextSequence() const {
                typename USNG::sample_type sample =
                    sequenceGen_.nextSequence();
                //Not possible to overload operator member access in Disposable
                //return copula_.allFactorCumulInverter(sample.value).value;
                x_.value = copula_.allFactorCumulInverter(sample.value);
                return x_;
            }
        private:
            USNG sequenceGen_;// copy, we might be mutithreaded
            mutable sample_type x_;
            // no copies
            const copulaType& copula_;
        };
        //@}
    protected:
        /* \todo Move integrator traits like number of quadrature points, 
        integration domain dimensions, etc to the copula through a static 
        member function. Since they depend on the nature of the probability 
        density distribution thats where they belong.
        This is why theres one factory per copula policy template parameter 
        (even if this is not used...yet)
        */
        class IntegrationFactory {
        public:
            static ext::shared_ptr<LMIntegration> createLMIntegration(
                Size dimension, 
                LatentModelIntegrationType::LatentModelIntegrationType type = 
                    #ifndef QL_PATCH_SOLARIS
                    LatentModelIntegrationType::GaussianQuadrature)
                    #else
                    LatentModelIntegrationType::Trapezoid)
                    #endif
            {
                switch(type) {
                    #ifndef QL_PATCH_SOLARIS
                    case LatentModelIntegrationType::GaussianQuadrature:
                        return 
                            ext::make_shared<
                            IntegrationBase<GaussianQuadMultidimIntegrator> >(
                                dimension, 25);
                    #endif
                    case LatentModelIntegrationType::Trapezoid:
                        {
                        std::vector<ext::shared_ptr<Integrator> > integrals;
                        for(Size i=0; i<dimension; i++)
                            integrals.push_back(
                            ext::make_shared<TrapezoidIntegral<Default> >(
                                1.e-4, 20));
                        /* This integration domain is tailored for the T 
                        distribution; it is too wide for normals or Ts of high
                        order. 
                        \todo This needs to be solved by having the copula to 
                        provide the integration traits for any integration 
                        algorithm since it is the copula that knows the relevant
                        domain for its density distributions. Also to be able to
                        block integrations which will fail; like a quadrature  
                        here in some cases.
                        */
                        return 
                          ext::make_shared<IntegrationBase<MultidimIntegral> >
                               (integrals, -35., 35.);
                        }
                    default:
                        QL_FAIL("Unknown latent model integration type.");
                }
            }
        private:
          IntegrationFactory() = default;
        };
        //@}


    public:
        // model size, number of latent variables modelled
        Size size() const {return nVariables_;}
        //! Number of systemic factors.
        Size numFactors() const {return nFactors_;}
        //! Number of total free random factors; systemic and idiosyncratic.
        Size numTotalFactors() const { return nVariables_ + nFactors_; }

        /*! Constructs a LM with an arbitrary number of latent variables
          and factors given by the dimensions of the passed matrix.
            @param factorsWeights Ordering is factorWeights_[iVar][iFactor]
            @param ini Initialization variables. Trait type from the copula 
              policy to allow for static policies (this solution needs to be 
              revised, possibly drop the static policy and create a policy 
              member in LatentModel)
        */
        explicit LatentModel(
            const std::vector<std::vector<Real> >& factorsWeights, 
            const typename copulaType::initTraits& ini = 
                copulaType::initTraits());
        /*! Constructs a LM with an arbitrary number of latent variables 
          depending only on one random factor but contributing to each latent
          variable through different weights.
            @param factorsWeight Ordering is factorWeights_[iVariable]
            @param ini Initialization variables. Trait type from the copula 
              policy to allow for static policies (this solution needs to be 
              revised, possibly drop the static policy and create a policy 
              member in LatentModel)
        */
        explicit LatentModel(const std::vector<Real>& factorsWeight,
            const typename copulaType::initTraits& ini = 
                copulaType::initTraits());
        /*! Constructs a LM with an arbitrary number of latent variables 
          depending only on one random factor with the same weight for all
          latent variables.

            correlSqr is the weight, same for all.

            ini is a trait type from the copula policy, to allow for
            static policies (this solution needs to be revised,
            possibly drop the static policy and create a policy member
            in LatentModel)
        */
        explicit LatentModel(Real correlSqr,
                             Size nVariables,
                             const typename copulaType::initTraits& ini = copulaType::initTraits());
        /*! Constructs a LM with an arbitrary number of latent variables 
          depending only on one random factor with the same weight for all
          latent variables. The weight is observed and this constructor is
          intended to be used when the model relates to a market value.

            singleFactorCorrel is the weight/mkt-factor, same for all.

            ini is a trait type from the copula policy, to allow for
            static policies (this solution needs to be revised,
            possibly drop the static policy and create a policy member
            in LatentModel)
        */
        explicit LatentModel(const Handle<Quote>& singleFactorCorrel,
            Size nVariables,
            const typename copulaType::initTraits& ini = 
                copulaType::initTraits());

        //! Provides values of the factors \f$ a_{i,k} \f$ 
        const std::vector<std::vector<Real> >& factorWeights() const {
            return factorWeights_;
        }
        //! Provides values of the normalized idiosyncratic factors \f$ Z_i \f$
        const std::vector<Real>& idiosyncFctrs() const {return idiosyncFctrs_;}

        //! Latent variable correlations:
        Real latentVariableCorrel(Size iVar1, Size iVar2) const {
            // true for any normalized combination
            Real init = (iVar1 == iVar2 ? 
                idiosyncFctrs_[iVar1] * idiosyncFctrs_[iVar1] : 0.);
            return std::inner_product(factorWeights_[iVar1].begin(), 
                factorWeights_[iVar1].end(), factorWeights_[iVar2].begin(), 
                    init);
        }
        //! \name Integration facility interface
        //@{
        /*! Integrates an arbitrary scalar function over the density domain(i.e.
         computes its expected value).
        */
        Real integratedExpectedValue(
            const ext::function<Real(const std::vector<Real>& v1)>& f) const {
            // function composition: composes the integrand with the density 
            //   through a product.
            return integration()->integrate(
                [&](const std::vector<Real>& x){ return copula_.density(x) * f(x); });
        }
        /*! Integrates an arbitrary vector function over the density domain(i.e.
         computes its expected value).
        */
        Disposable<std::vector<Real> > integratedExpectedValueV(
            // const ext::function<std::vector<Real>(
            const ext::function<Disposable<std::vector<Real> >(
                const std::vector<Real>& v1)>& f ) const {
            detail::multiplyV M;
            return integration()->integrateV(//see note in LMIntegrators base class
                [&](const std::vector<Real>& x){ return M(copula_.density(x), f(x)); });
        }
    protected:
        // Integrable models must provide their integrator.
        // Arguable, not having the integration in the LM class saves that 
        //   memory but have an entry in the VT... 
        virtual const ext::shared_ptr<LMIntegration>& integration() const {
            QL_FAIL("Integration non implemented in Latent model.");
        }
        //@}

        // Ordering is: factorWeights_[iVariable][iFactor]
        mutable std::vector<std::vector<Real> > factorWeights_;
        /* This is a duplicated value from the data above chosen for memory 
        reasons.
        I have opted for this one value redundant memory rather than have the 
        memory load of the observable in all factors. Typically Latent models 
        are used in two very different ways: with many factors and not linked 
        to a market observable (typical matrix size above is of tens of 
        thousands entries) or with just one observable value and the matrix is 
        just a scalar. Otherwise, to remove the redundancy, the matrix 
        factorWeights_ should be one of Quotes Handles.
        Yet it is not entirely true that quotes might be used only in pricing, 
        think sensitivity analysis....
        \todo Reconsider this, see how expensive truly is.
        */
        mutable Handle<Quote> cachedMktFactor_;

        // updated only by correlation observability and constructors.
        // \sqrt{1-\sum_k \beta_{i,k}^2} the addition being along the factors. 
        // It has therefore the size of the basket. Cached for perfomance
        mutable std::vector<Real> idiosyncFctrs_;
        //! Number of systemic factors.
        mutable Size nFactors_;//matches idiosyncFctrs_[0].size();i=0 or any
        //! Number of latent model variables, idiosyncratic terms or model dim
        mutable Size nVariables_;// matches idiosyncFctrs_.size() 

        mutable copulaType copula_;
    };




    // Defines ----------------------------------------------------------------

#ifndef __DOXYGEN__

    template <class Impl>
    LatentModel<Impl>::LatentModel(
        const std::vector<std::vector<Real> >& factorWeights,
        const typename Impl::initTraits& ini)
    : factorWeights_(factorWeights),
      nFactors_(factorWeights[0].size()), 
      nVariables_(factorWeights.size()), copula_(factorWeights, ini)
    {
        for(Size i=0; i<factorWeights.size(); i++) {
            idiosyncFctrs_.push_back(std::sqrt(1.-
                    std::inner_product(factorWeights[i].begin(), 
                factorWeights[i].end(), 
                factorWeights[i].begin(), 0.)));
            // while at it, check sizes are coherent:
            QL_REQUIRE(factorWeights[i].size() == nFactors_, 
                "Name " << i << " provides a different number of factors");
        }
    }

    template <class Impl>
    LatentModel<Impl>::LatentModel(
        const std::vector<Real>& factorWeights,
        const typename Impl::initTraits& ini)
    : nFactors_(1),
      nVariables_(factorWeights.size())
    {
        for (double factorWeight : factorWeights)
            factorWeights_.emplace_back(1, factorWeight);
        for (double factorWeight : factorWeights)
            idiosyncFctrs_.push_back(std::sqrt(1. - factorWeight * factorWeight));
        //convert row to column vector....
        copula_ = copulaType(factorWeights_, ini);
    }

    template <class Impl>
    LatentModel<Impl>::LatentModel(
        const Real correlSqr,
        Size nVariables,
        const typename Impl::initTraits& ini)
    : factorWeights_(nVariables, std::vector<Real>(1, correlSqr)),
      idiosyncFctrs_(nVariables, 
        std::sqrt(1.-correlSqr*correlSqr)),
      nFactors_(1), 
      nVariables_(nVariables),
      copula_(factorWeights_, ini)
    { }

    template <class Impl>
    LatentModel<Impl>::LatentModel(
        const Handle<Quote>& singleFactorCorrel,
        Size nVariables,
        const typename Impl::initTraits& ini)
    : factorWeights_(nVariables, std::vector<Real>(1, 
        std::sqrt(singleFactorCorrel->value()))),
      cachedMktFactor_(singleFactorCorrel),
      idiosyncFctrs_(nVariables, 
        std::sqrt(1.-singleFactorCorrel->value())),
      nFactors_(1), 
      nVariables_(nVariables),
      copula_(factorWeights_, ini)
    {
        registerWith(cachedMktFactor_);
    }

#endif

    template <class Impl>
    void LatentModel<Impl>::update() {
        /* only registration with the single market correl quote. If we get 
        register with something else remember that the quote stores correlation
        and the model need factor values; which for one factor models are the
        square root of the correlation.
        */
        factorWeights_ = std::vector<std::vector<Real> >(nVariables_, 
            std::vector<Real>(1, std::sqrt(cachedMktFactor_->value())));
        idiosyncFctrs_ = std::vector<Real>(nVariables_, 
            std::sqrt(1.-cachedMktFactor_->value()));
        copula_ = copulaType(factorWeights_, copula_.getInitTraits());
        notifyObservers();
    }

#ifndef __DOXYGEN__

    //----Template partial specializations of the random FactorSampler--------
    /*
    Notice that while the default template needs a sequence generator the 
    specializations need a number generator. This is forced at the time the 
    concrete policy class is used in the template parameter, if it has been 
    specialized it needs the sample type typedef to match at compilation. 
    
    Notice here the outer class template is specialized only, leaving the inner
    generator still a class template. Apparently old versions of gcc (3.x) bug 
    on this one not recognizing the specialization.
    */
    /*! \brief  Specialization for direct Gaussian Box-Muller generation.\par
    The implementation of Box-Muller in the library is the rejection variant so
    do not use it within a multithreaded simulation.
    */
    template<class TC> template<class URNG, bool dummy>
    class LatentModel<TC>
        ::FactorSampler <RandomSequenceGenerator<BoxMullerGaussianRng<URNG> > ,
            dummy> {
        typedef URNG urng_type;
    public:
        //Size below must be == to the numb of factors idiosy + systemi
        typedef Sample<std::vector<Real> > sample_type;
        explicit FactorSampler(const GaussianCopulaPolicy& copula,
                               BigNatural seed = 0) 
        : boxMullRng_(copula.numFactors(), 
            BoxMullerGaussianRng<urng_type>(urng_type(seed))){ }
        const sample_type& nextSequence() const {
                return boxMullRng_.nextSequence();
        }
    private:
        RandomSequenceGenerator<BoxMullerGaussianRng<urng_type> > boxMullRng_;
    };

    /*! \brief Specialization for direct T samples generation.\par
    The PolarT is a rejection algorithm so do not use it within a 
    multithreaded simulation.
    The RandomSequenceGenerator class does not admit heterogeneous 
    distribution samples so theres a trick here since the template parameter is 
    not what it is used internally.
    */
    template<class TC> template<class URNG, bool dummy>//uniform number expected
    class LatentModel<TC>
        ::FactorSampler<RandomSequenceGenerator<PolarStudentTRng<URNG> > , 
            dummy> {
        typedef URNG urng_type;
    public:
        typedef Sample<std::vector<Real> > sample_type;
        explicit FactorSampler(const TCopulaPolicy& copula, BigNatural seed = 0)
        : sequence_(std::vector<Real> (copula.numFactors()), 1.0),
          urng_(seed) {
            // 1 == urng.dimension() is enforced by the sample type
            const std::vector<Real>& varF = copula.varianceFactors();
            for (double i : varF) // ...use back inserter lambda
                trng_.push_back(PolarStudentTRng<urng_type>(2. / (1. - i * i), urng_));
        }
        const sample_type& nextSequence() const {
            Size i=0;
            for(; i<trng_.size(); i++)//systemic samples plus one idiosyncratic
                sequence_.value[i] = trng_[i].next().value;
            for(; i<sequence_.value.size(); i++)//rest of idiosyncratic samples
                sequence_.value[i] = trng_.back().next().value;
            return sequence_;
        }
    private:
        mutable sample_type sequence_;
        urng_type urng_;
        mutable std::vector<PolarStudentTRng<urng_type> > trng_;
    };

#endif

}                    


#endif
]]></document_content>
  </document>
  <document index="390">
    <source>math/levyflightdistribution.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Andres Hernandez

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file levyflightdistribution.hpp
    \brief Levy Flight, aka Pareto Type I, distribution as needed by Boost Random
*/

#ifndef quantlib_levy_flight_distribution_hpp
#define quantlib_levy_flight_distribution_hpp

#include <ql/types.hpp>
#include <ql/errors.hpp>
#include <boost/random/detail/config.hpp>
#include <boost/random/detail/operators.hpp>
#include <boost/random/uniform_01.hpp>
#include <iosfwd>

namespace QuantLib {

    //! Levy Flight distribution as needed by Boost Random
    /*! The levy flight distribution is a random distribution with 
        the following form:
        \f[
        p(x) = \frac{\alpha x_m^{\alpha}}{x^{\alpha+1}}
        \f]
        with support over \f$ x \in [x_m, \infty) \f$
        and the parameter \f$ \alpha > 0 \f$.

        Levy Flight is normally defined as \f$ x_m = 1 \f$ and \f$ 0 <
        \alpha < 2 \f$, which is where \f$ p(x) \f$ has an infinite
        variance. However, the more general version, known as Pareto
        Type I, is well defined for \f$ \alpha > 2 \f$, so the current
        implementation does not restrict \f$ \alpha \f$ to be smaller
        than 2.
    */
    class LevyFlightDistribution
    {
      public:
        typedef Real input_type;
        typedef Real result_type;

        class param_type
        {
          public:

            typedef LevyFlightDistribution distribution_type;

            /*!    Constructs parameters with a given xm and alpha
                Requires: alpha > 0
            */
            param_type(Real xm = 1.0, Real alpha = 1.0)
              : xm_(xm), alpha_(alpha) { QL_REQUIRE(alpha_ > 0.0, "alpha must be larger than 0"); }

            //! Returns the xm parameter of the distribution
            Real xm() const { return xm_; }
            
            //! Returns the alpha parameter of the distribution
            Real alpha() const { return alpha_; }

            //! Writes the parameters to a @c std::ostream
            BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)
            {
                os << parm.xm_ << " " << parm.alpha_;
                return os;
            }
            
            //! Reads the parameters from a @c std::istream
            BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)
            {
                is >> parm.xm_ >> std::ws >> parm.alpha_;
                return is;
            }

            //! Returns true if the two sets of parameters are equal
            BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)
            { return lhs.xm_ == rhs.xm_ && lhs.alpha_ == rhs.alpha_; }

            //! Returns true if the two sets of parameters are different
            BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(param_type)

        private:
            Real xm_;
            Real alpha_;
        };

        //! \name Constructors
        //@{
        /*! Constructs a LevyFlightDistribution with a given xm and alpha
            Requires: alpha > 0
        */
        explicit LevyFlightDistribution(Real xm = 1.0, Real alpha = 1.0)
          : xm_(xm), alpha_(alpha) { QL_REQUIRE(alpha_ > 0.0, "alpha must be larger than 0"); }

        //!Constructs a LevyFlightDistribution from its parameters
        explicit LevyFlightDistribution(const param_type& parm)
          : xm_(parm.xm()), alpha_(parm.alpha()) {}

        // compiler-generated copy ctor and assignment operator are fine
        //@}

        //! \name Inspectors
        //@{
        //! Returns the xm parameter of the distribution
        Real xm() const { return xm_; }
            
        //! Returns the alpha parameter of the distribution
        Real alpha() const { return alpha_; }

        //! Returns the smallest value that the distribution can produce
        Real min BOOST_PREVENT_MACRO_SUBSTITUTION () const
        { return xm_; }
        //! Returns the largest value that the distribution can produce
        Real max BOOST_PREVENT_MACRO_SUBSTITUTION () const
        { return QL_MAX_REAL; }

        //! Returns the parameters of the distribution
        param_type param() const { return {xm_, alpha_}; }
        //@}
        
        //! Sets the parameters of the distribution
        void param(const param_type& parm) { 
            xm_ = parm.xm();
            alpha_ = parm.alpha();
        }

        /*! Effects: Subsequent uses of the distribution do not depend
            on values produced by any engine prior to invoking reset.
        */
        void reset() { }
        
        //! Returns the value of the pdf for x
        Real operator()(Real x) const{
            using std::pow;
            if(x < xm_) return 0.0;
            return alpha_*pow(xm_/x, alpha_)/x;
        }
        
        /*!    Returns a random variate distributed according to the
            levy flight distribution.
        */
        template<class Engine>
        result_type operator()(Engine& eng) const{
            using std::pow;
            return xm_*pow(boost::random::uniform_01<Real>()(eng), -1.0/alpha_);
        }

        /*!    Returns a random variate distributed according to the
            levy flight with parameters specified by parm
        */
        template<class Engine>
        result_type operator()(Engine& eng, const param_type& parm) const{
            return LevyFlightDistribution (parm)(eng);
        }

        //! Writes the distribution to a std::ostream
        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, LevyFlightDistribution, ed)
        {
            os << ed.xm_ << " " << ed.alpha_;
            return os;
        }

        //! Reads the distribution from a std::istream
        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, LevyFlightDistribution, ed)
        {
            is >> ed.xm_ >> std::ws >> ed.alpha_;
            return is;
        }

        /*! Returns true iff the two distributions will produce identical
            sequences of values given equal generators.
        */
        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(LevyFlightDistribution, lhs, rhs)
        { return lhs.xm_ == rhs.xm_ && lhs.alpha_ == rhs.alpha_; }
        
        /*!    Returns true iff the two distributions will produce different
            sequences of values given equal generators.
        */
        BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(LevyFlightDistribution)

    private:
        result_type xm_;
        result_type alpha_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="391">
    <source>math/moorepenroseinverse.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file moorepenroseinverse.hpp
    \brief Moore Penrose inverse of a real matrix
*/

#ifndef quantlib_moore_penrose_inverse
#define quantlib_moore_penrose_inverse

#include <ql/math/matrixutilities/svd.hpp>

namespace QuantLib {

/*! Reference:
    http://de.mathworks.com/help/matlab/ref/pinv.html
    https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse */

inline Disposable<Matrix> moorePenroseInverse(const Matrix &A,
                                              const Real tol = Null<Real>()) {

    Size m = A.rows();
    Size n = A.columns();

    SVD svd(A);

    Real tol0 = tol;
    if (tol0 == Null<Real>()) {
        tol0 = std::max(m, n) * QL_EPSILON * std::abs(svd.singularValues()[0]);
    }

    Matrix sp(n, n, 0.0);
    for (Size i = 0; i < n; ++i) {
        if (std::abs(svd.singularValues()[i]) > tol0) {
            sp(i, i) = 1.0 / svd.singularValues()[i];
        }
    }

    Matrix res = svd.V() * sp * transpose(svd.U());
    return res;
};

} // namespace QuantLib

#endif // include guard
]]></document_content>
  </document>
  <document index="392">
    <source>math/multidimintegrator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/multidimintegrator.hpp>

namespace QuantLib {

    MultidimIntegral::MultidimIntegral(
            const std::vector<ext::shared_ptr<Integrator> >& integrators)
    : integrators_(integrators), 
      integrationLevelEntries_(maxDimensions_),
      varBuffer_(integrators.size(), 0.) {
        QL_REQUIRE(integrators.size() <= maxDimensions_, 
            "Too many dimensions in integration.");
        spawnFcts<maxDimensions_>();
    }

}
]]></document_content>
  </document>
  <document index="393">
    <source>math/multidimintegrator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_math_multidimintegrator_hpp
#define quantlib_math_multidimintegrator_hpp

#include <ql/types.hpp>
#include <ql/errors.hpp>
#include <ql/math/integrals/integral.hpp>
#include <ql/functional.hpp>
#include <vector>

namespace QuantLib {

    /*! \brief Integrates a vector or scalar function of vector domain. 
        
        Uses a collection of arbitrary 1D integrators along each of the 
        dimensions. A template recursion along dimensions avoids calling depth 
        test or virtual functions.\par
        This class generalizes to an arbitrary number of dimensions the 
        functionality in class TwoDimensionalIntegral  
    */
    class MultidimIntegral {
    public:
        explicit MultidimIntegral(
            const std::vector<ext::shared_ptr<Integrator> >& integrators);

        // scalar variant
        /*! f is the integrand function; a and b are the lower and
            upper integration limit domain for each dimension.
        */
        Real operator()(
            const ext::function<Real (const std::vector<Real>&)>& f,
            const std::vector<Real>& a,
            const std::vector<Real>& b) const 
        {
            QL_REQUIRE((a.size()==b.size())&&(b.size()==integrators_.size()), 
                "Incompatible integration problem dimensions");
            return integrationLevelEntries_[integrators_.size()-1](f, a, b);
        }
        // to do: write std::vector<Real> operator()(...) version

    private:
        static const Size maxDimensions_ = 15;

        /* Here is the tradeoff; this is avoiding the dimension limits checks 
        during integration at the price of these asignments during construction.
        Explicit template instantiation is of no use, an object is needed 
        (notice 'this' is needed for the asignment.)
        If not all the dimensions up the maximum number are used the waste goes
        into storage of the functions (in fact only one is used)
        */
        template<Size depth>
        void spawnFcts() const;
        // Splits the integration in cross-sections per dimension.
        template<int T_N> 
        Real vectorBinder (
            const ext::function<Real (const std::vector<Real>&)>& f,
            Real z,
            const std::vector<Real>& a,
            const std::vector<Real>& b) const ;
        // actual integration of dimension nT
        template<int nT>
        Real integrate(
            const ext::function<Real (const std::vector<Real>&)>& f,
            const std::vector<Real>& a,
            const std::vector<Real>& b) const;

        const std::vector<ext::shared_ptr<Integrator> > integrators_;

        /* typedef (const ext::function<Real 
            (const std::vector<Real>&arg1)>&arg2) integrableFunctType;
        */

        /* vector of, functions returning reals And taking as argument: 
        1.- a const ref to a function taking vectors 
        2.- a vector, 3. another vector. typedefs eventually...
         at first sight this might look like mimicking a virtual table, it isnt 
         that. The reason is to be able to select the correct integration 
         dimension at run time, this can not be done before because of the 
         template argument restriction to be constant known at compilation.
        */
        mutable std::vector<ext::function<Real (//<- members: integrate<N>
            // integrable function:
            const ext::function<Real (const std::vector<Real>&)>&, 
            const std::vector<Real>&, //<- a
            const std::vector<Real>&) //<- b
            > > 
            integrationLevelEntries_;

        /* One can avoid the passing around of the ct refs to a and b but the 
        price is to keep a copy of them (they are unknown at construction time)
         On the other hand the vector integration variable has to be created.*/
        mutable std::vector<Real> varBuffer_;

    };

    // spez last call/dimension
    template<>
    Real inline MultidimIntegral::vectorBinder<0> (
        const ext::function<Real (const std::vector<Real>&)>& f, 
        Real z,
        const std::vector<Real>& a,
        const std::vector<Real>& b) const
    {
        varBuffer_[0] = z;
        return f(varBuffer_);
    }

    template<>
    void inline MultidimIntegral::spawnFcts<1>() const {
        integrationLevelEntries_[0] = 
            ext::bind(&MultidimIntegral::integrate<0>, this,
                      ext::placeholders::_1, ext::placeholders::_2, ext::placeholders::_3);
    }

    template<int nT>
    inline Real MultidimIntegral::integrate(
        const ext::function<Real (const std::vector<Real>&)>& f,
        const std::vector<Real>& a,
        const std::vector<Real>& b) const 
    {
        return 
            (*integrators_[nT])(
                ext::bind(&MultidimIntegral::vectorBinder<nT>, this, f, 
                    ext::placeholders::_1, ext::cref(a), ext::cref(b)), a[nT], b[nT]);
    }

    template<int T_N> 
    inline Real MultidimIntegral::vectorBinder (
        const ext::function<Real (const std::vector<Real>&)>& f,
        Real z,
        const std::vector<Real>& a,
        const std::vector<Real>& b) const 
    {
        varBuffer_[T_N] = z;
        return integrate<T_N-1>(f, a, b);
    }

    template<Size depth>
    void MultidimIntegral::spawnFcts() const {
        integrationLevelEntries_[depth-1] =
          ext::bind(&MultidimIntegral::integrate<depth-1>, this, 
            ext::placeholders::_1, ext::placeholders::_2, ext::placeholders::_3);
        spawnFcts<depth-1>();
    }

}

#endif
]]></document_content>
  </document>
  <document index="394">
    <source>math/multidimquadrature.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/multidimquadrature.hpp>

#ifndef QL_PATCH_SOLARIS

namespace QuantLib {

    GaussianQuadMultidimIntegrator::GaussianQuadMultidimIntegrator(
        Size dimension, Size quadOrder, Real mu) 
        : integral_(quadOrder, mu),
          integralV_(quadOrder, mu),
          integrationEntries_(maxDimensions_),
          integrationEntriesVR_(maxDimensions_),
          dimension_(dimension),
          varBuffer_(dimension_, 0.)
    {
        spawnFcts<maxDimensions_>();
    }

}

#endif
]]></document_content>
  </document>
  <document index="395">
    <source>math/multidimquadrature.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_math_multidimquadrature_hpp
#define quantlib_math_multidimquadrature_hpp

#include <ql/qldefines.hpp>

/* Currently, this doesn't compile under Sun C++ (see
   https://github.com/lballabio/QuantLib/issues/223).  Until that's
   fixed, we disable it so that the rest of the library can be built.
*/

#ifndef QL_PATCH_SOLARIS

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/functional.hpp>
#include <ql/functional.hpp>

namespace QuantLib {

    namespace detail {
        typedef Disposable<std::vector<Real> > DispArray;
    }

    /*! \brief Integrates a vector or scalar function of vector domain. 
        
        A template recursion along dimensions avoids calling depth 
        test or virtual functions.

        \todo Add coherence test between the integrand function dimensions (the
        vector size) and the declared dimension in the constructor.

        \todo Split into integrator classes for functions returning scalar and 
            vector?
    */
    class GaussianQuadMultidimIntegrator {
    private:
        // Vector integration. Quadrature to functions returning a vector of 
        // real numbers, turns 1D quadratures into ND
        class VectorIntegrator : public GaussHermiteIntegration {
        public:
            explicit VectorIntegrator(Size n, Real mu = 0.0) 
            : GaussHermiteIntegration(n, mu) {}

            template <class F> // todo: fix copies.
            detail::DispArray operator()(const F& f) const {
                //first one, we do not know the size of the vector returned by f
                Integer i = order()-1;
                std::vector<Real> term = f(x_[i]);// potential copy! @#$%^!!!
                std::for_each(term.begin(), term.end(), 
                              multiply_by<Real>(w_[i]));
                std::vector<Real> sum = term;
           
                for (i--; i >= 0; --i) {
                    term = f(x_[i]);// potential copy! @#$%^!!!
                    // sum[j] += term[j] * w_[i];
                    std::transform(term.begin(), term.end(), sum.begin(), 
                                   sum.begin(),
                                   [&](Real x, Real y){ return w_[i]*x + y; });
                }
                return sum;
            }
        };

    public:
        /*!
            @param dimension The number of dimensions of the argument of the 
            function we want to integrate.
            @param quadOrder Quadrature order.
            @param mu Parameter in the Gauss Hermite weight (i.e. points load).
        */
        GaussianQuadMultidimIntegrator(Size dimension, Size quadOrder, 
            Real mu = 0.);
        //! Integration quadrature order.
        Size order() const {return integralV_.order();}

        //! Integrates function f over \f$ R^{dim} \f$
        /* This function is just syntax since the only thing it does is calling 
        to integrate<RetType> which has to exist for the type returned by the 
        function. So theres one redundant call but there should not be any extra 
        cost... up to the compiler. It can not be templated all the way since
        the integration entries functions can not be templates.
        Most times integrands will return a scalar or vector but could be a 
        matrix too. Also vectors might be returned as vector or Disposable 
        wrapped (which is preferred and I have removed the plain vector
        version).
         */
        template<class RetType_T>
        RetType_T operator()(const ext::function<RetType_T (
            const std::vector<Real>& arg)>& f) const 
        {
            return integrate<RetType_T>(f);
        }


        //---------------------------------------------------------
        /* Boost fails on MSVC2008 to recognise the return type when 
        calling op()  , its not boost, its me.... FIX ME*/

        // Declare, spezializations follow.
        template<class RetType_T>
        RetType_T integrate(const ext::function<RetType_T (
            const std::vector<Real>& v1)>& f) const;

    private:
        /* The maximum number of dimensions of the integration variable domain
            A higher than this number of dimension would presumably be 
           impractical and another integration algorithm (MC) should be 
           considered.
           \to do Consider moving it to a library configuration variable.
        */
        static const Size maxDimensions_ = 15;

        //! \name Integration entry points generation
        //@{
        //! Recursive template methods to statically generate (at this 
        //    class construction time) handles to the integration entry points
        template<Size levelSpawn>
        void spawnFcts() const {
            integrationEntries_[levelSpawn-1] =
                [&](ext::function<Real (const std::vector<Real>&)> f, Real x){
                    return scalarIntegrator<levelSpawn>(f, x);
                };
            integrationEntriesVR_[levelSpawn-1] =
                [&](const ext::function<detail::DispArray(const std::vector<Real>&)>& f, Real x){
                    return vectorIntegratorVR<levelSpawn>(f, x);
                };
            spawnFcts<levelSpawn-1>();
        }
        //@}

        //---------------------------------------------------------

        template <int intgDepth>
        Real scalarIntegrator(
            const ext::function<Real (const std::vector<Real>& arg1)>& f,
            const Real mFctr) const 
        {
            varBuffer_[intgDepth-1] = mFctr;
            return integral_([&](Real x){ return scalarIntegrator<intgDepth-1>(f, x); });
        }

        template <int intgDepth>
        detail::DispArray vectorIntegratorVR(
            const ext::function<detail::DispArray(const std::vector<Real>& arg1)>& f,
            const Real mFctr) const 
        {
            varBuffer_[intgDepth-1] = mFctr;
            return integralV_([&](Real x){ return vectorIntegratorVR<intgDepth-1>(f, x); });
        }

        // Same object for all dimensions poses problems when using the 
        //   parallelized integrals version.
        //! The actual integrators.
        GaussHermiteIntegration integral_;
        VectorIntegrator integralV_;

        //! Buffer to allow acces to integrations. We do not know at which 
        //    level/dimension we are going to start integration
        // \todo Declare typedefs for traits
        mutable std::vector<
        ext::function<Real (ext::function<Real (
            const std::vector<Real>& varg2)> f1, 
            const Real r3)> > integrationEntries_;
        mutable std::vector<
        ext::function<detail::DispArray (const ext::function<detail::DispArray(
            const std::vector<Real>& vvarg2)>& vf1, 
            const Real vr3)> > integrationEntriesVR_;

        Size dimension_;
        // integration veriable buffer
        mutable std::vector<Real> varBuffer_;
    };


    // Template specializations ---------------------------------------------

    template<>
    inline Real GaussianQuadMultidimIntegrator::operator()(
        const ext::function<Real (const std::vector<Real>& v1)>& f) const
    {
        // integration entry level is selected now
        return integral_([&](Real x){ return integrationEntries_[dimension_-1](ext::cref(f), x); });
    }

    // Scalar integrand version (merge with vector case?)
    template<>
    inline Real GaussianQuadMultidimIntegrator::integrate<Real>(
        const ext::function<Real (const std::vector<Real>& v1)>& f) const 
    {
        // integration variables
        // call vector quadrature integration with the function and start 
        // values, kicks in recursion over the dimensions of the integration
        // variable.
        return integral_([&](Real x){ return integrationEntries_[dimension_-1](ext::cref(f), x); });
    }

    // Vector integrand version
    template<>
    inline detail::DispArray GaussianQuadMultidimIntegrator::integrate<detail::DispArray>(
        const ext::function<detail::DispArray (const std::vector<Real>& v1)>& f) const
    {
        return integralV_([&](Real x){ return integrationEntriesVR_[dimension_-1](ext::cref(f), x); });
    } 

    //! Terminal integrand; scalar function version
    template<> 
    inline Real GaussianQuadMultidimIntegrator::scalarIntegrator<1>(
        const ext::function<Real (const std::vector<Real>& arg1)>& f,
        const Real mFctr) const
    {
        varBuffer_[0] = mFctr;
        return f(varBuffer_);
    }

    //! Terminal integrand; disposable vector function version
    template<>
    inline detail::DispArray
        GaussianQuadMultidimIntegrator::vectorIntegratorVR<1>(
        const ext::function<detail::DispArray (const std::vector<Real>& arg1)>& f,
        const Real mFctr) const 
    {
        varBuffer_[0] = mFctr;
        return f(varBuffer_);
    }

    //! Terminal level:
    template<>
    inline void GaussianQuadMultidimIntegrator::spawnFcts<1>() const {
        integrationEntries_[0] = [&](const ext::function<Real(const std::vector<Real>&)>& f,
                                     Real x) { return scalarIntegrator<1>(f, x); };
        integrationEntriesVR_[0] =
            [&](const ext::function<detail::DispArray(const std::vector<Real>&)>& f, Real x) {
                return vectorIntegratorVR<1>(f, x);
            };
    }

}

#endif

#endif
]]></document_content>
  </document>
  <document index="396">
    <source>math/particleswarmoptimization.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Andres Hernandez

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/particleswarmoptimization.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <cmath>
#include <utility>

using std::sqrt;

namespace QuantLib {
    ParticleSwarmOptimization::ParticleSwarmOptimization(Size M,
                                                         ext::shared_ptr<Topology> topology,
                                                         ext::shared_ptr<Inertia> inertia,
                                                         Real c1,
                                                         Real c2,
                                                         unsigned long seed)
    : M_(M), rng_(seed), topology_(std::move(topology)), inertia_(std::move(inertia)) {
        Real phi = c1 + c2;
        QL_ENSURE(phi*phi - 4 * phi, "Invalid phi");
        c0_ = 2.0 / std::abs(2.0 - phi - sqrt(phi*phi - 4 * phi));
        c1_ = c0_*c1;
        c2_ = c0_*c2;
    }

    ParticleSwarmOptimization::ParticleSwarmOptimization(Size M,
                                                         ext::shared_ptr<Topology> topology,
                                                         ext::shared_ptr<Inertia> inertia,
                                                         Real omega,
                                                         Real c1,
                                                         Real c2,
                                                         unsigned long seed)
    : M_(M), c0_(omega), c1_(c1), c2_(c2), rng_(seed), topology_(std::move(topology)),
      inertia_(std::move(inertia)) {}

    void ParticleSwarmOptimization::startState(Problem &P, const EndCriteria &endCriteria) {
        QL_REQUIRE(topology_, "Invalid topology");
        QL_REQUIRE(inertia_, "Invalid inertia");
        N_ = P.currentValue().size();
        topology_->setSize(M_);
        inertia_->setSize(M_, N_, c0_, endCriteria);
        X_.reserve(M_);
        V_.reserve(M_);
        pBX_.reserve(M_);
        pBF_ = Array(M_);
        gBX_.reserve(M_);
        gBF_ = Array(M_);
        uX_ = P.constraint().upperBound(P.currentValue());
        lX_ = P.constraint().lowerBound(P.currentValue());
        Array bounds = uX_ - lX_;

        //Random initialization is done by Sobol sequence
        SobolRsg sobol(N_ * 2);

        //Prepare containers
        for (Size i = 0; i < M_; i++) {
            const SobolRsg::sample_type::value_type &sample = sobol.nextSequence().value;
            X_.emplace_back(N_, 0.0);
            Array& x = X_.back();
            V_.emplace_back(N_, 0.0);
            Array& v = V_.back();
            gBX_.emplace_back(N_, 0.0);
            for (Size j = 0; j < N_; j++) {
                //Assign X=lb+(ub-lb)*random
                x[j] = lX_[j] + bounds[j] * sample[2 * j];
                //Assign V=(ub-lb)*2*random-(ub-lb) -> between (lb-ub) and (ub-lb)
                v[j] = bounds[j] * (2.0*sample[2 * j + 1] - 1.0);
            }
            //Evaluate X and assign as personal best
            pBX_.push_back(X_.back());
            pBF_[i] = P.value(X_.back());
        }

        //init topology & inertia
        topology_->init(this);
        inertia_->init(this);
    }

    EndCriteria::Type ParticleSwarmOptimization::minimize(Problem &P, const EndCriteria &endCriteria) {
        QL_REQUIRE(!P.constraint().empty(), "PSO is a constrained optimizer");

        EndCriteria::Type ecType = EndCriteria::None;
        P.reset();
        Size iteration = 0;
        Size iterationStat = 0;
        Size maxIteration = endCriteria.maxIterations();
        Size maxIStationary = endCriteria.maxStationaryStateIterations();
        Real bestValue = QL_MAX_REAL;
        Size bestPosition = 0;

        startState(P, endCriteria);
        //Set best value & position
        for (Size i = 0; i < M_; i++) {
            if (pBF_[i] < bestValue) {
                bestValue = pBF_[i];
                bestPosition = i;
            }
        }

        //Run optimization
        do {
            iteration++;
            iterationStat++;
            //Check if stopping criteria is met
            if (iteration > maxIteration || iterationStat > maxIStationary)
                break;

            //According to the topology, determine best global position
            topology_->findSocialBest();

            //Call inertia to change internal state
            inertia_->setValues();

            //Loop over particles
            for (Size i = 0; i < M_; i++) {
                Array& x = X_[i];
                Array& pB = pBX_[i];
                const Array& gB = gBX_[i];
                Array& v = V_[i];

                //Loop over dimensions
                for (Size j = 0; j < N_; j++) {
                    //Update velocity
                    v[j] += c1_*rng_.nextReal()*(pB[j] - x[j]) + c2_*rng_.nextReal()*(gB[j] - x[j]);
                    //Update position
                    x[j] += v[j];
                    //Enforce bounds on positions
                    if (x[j] < lX_[j]) {
                        x[j] = lX_[j];
                        v[j] = 0.0;
                    }
                    else if (x[j] > uX_[j]) {
                        x[j] = uX_[j];
                        v[j] = 0.0;
                    }
                }
                //Evaluate x
                Real f = P.value(x);
                if (f < pBF_[i]) {
                    //Update personal best
                    pBF_[i] = f;
                    pB = x;
                    //Check stationary condition
                    if (f < bestValue) {
                        bestValue = f;
                        bestPosition = i;
                        iterationStat = 0;
                    }
                }
            }
        } while (true);
        if (iteration > maxIteration)
            ecType = EndCriteria::MaxIterations;
        else
            ecType = EndCriteria::StationaryPoint;

        //Set result to best point
        P.setCurrentValue(pBX_[bestPosition]);
        P.setFunctionValue(bestValue);
        return ecType;
    }

    void AdaptiveInertia::setValues() {
        Real currBest = (*pBF_)[0];
        for (Size i = 1; i < M_; i++) {
            if (currBest >(*pBF_)[i]) currBest = (*pBF_)[i];
        }
        if (started_) { //First iteration leaves inertia unchanged
            if (currBest < best_) {
                best_ = currBest;
                adaptiveCounter--;
            }
            else {
                adaptiveCounter++;
            }
            if (adaptiveCounter > sh_) {
                c0_ = std::max(minInertia_, std::min(maxInertia_, c0_*0.5));
            }
            else if (adaptiveCounter < sl_) {
                c0_ = std::max(minInertia_, std::min(maxInertia_, c0_*2.0));
            }
        }
        else {
            best_ = currBest;
            started_ = true;
        }
        for (Size i = 0; i < M_; i++) {
            (*V_)[i] *= c0_;
        }
    }

    void KNeighbors::findSocialBest() {
        for (Size i = 0; i < M_; i++) {
            Real bestF = (*pBF_)[i];
            Size bestX = 0;
            //Search K_ neightbors upwards
            Size upper = std::min(i + K_, M_);
            //Search K_ neighbors downwards
            Size lower = std::max(i, K_ + 1) - K_ - 1;
            for (Size j = lower; j < upper; j++) {
                if ((*pBF_)[j] < bestF) {
                    bestF = (*pBF_)[j];
                    bestX = j;
                }
            }
            if (i + K_ >= M_) { //loop around if i+K >= M_
                for (Size j = 0; j < i + K_ - M_; j++) {
                    if ((*pBF_)[j] < bestF) {
                        bestF = (*pBF_)[j];
                        bestX = j;
                    }
                }
            }
            else if (i < K_) {//loop around from above
                for (Size j = M_ - (K_ - i) - 1; j < M_; j++) {
                    if ((*pBF_)[j] < bestF) {
                        bestF = (*pBF_)[j];
                        bestX = j;
                    }
                }
            }
            (*gBX_)[i] = (*pBX_)[bestX];
            (*gBF_)[i] = bestF;
        }
    }

    ClubsTopology::ClubsTopology(
        Size defaultClubs, Size totalClubs,
        Size maxClubs, Size minClubs,
        Size resetIteration, unsigned long seed) :
        totalClubs_(totalClubs), maxClubs_(maxClubs),
        minClubs_(minClubs), defaultClubs_(defaultClubs),
        iteration_(0), resetIteration_(resetIteration),
        bestByClub_(totalClubs, 0), worstByClub_(totalClubs, 0),
        generator_(seed), distribution_(1, totalClubs_) {
        QL_REQUIRE(totalClubs_ >= defaultClubs_,
            "Total number of clubs must be larger or equal than default clubs");
        QL_REQUIRE(defaultClubs_ >= minClubs_,
            "Number of default clubs must be larger or equal than minimum clubs");
        QL_REQUIRE(maxClubs_ >= defaultClubs_,
            "Number of maximum clubs must be larger or equal than default clubs");
        QL_REQUIRE(totalClubs_ >= maxClubs_,
            "Total number of clubs must be larger or equal than maximum clubs");
    }

    void ClubsTopology::setSize(Size M) {
        M_ = M;

        if (defaultClubs_ < totalClubs_) {
            clubs4particles_ = std::vector<std::vector<bool> >(M_, std::vector<bool>(totalClubs_, false));
            particles4clubs_ = std::vector<std::vector<bool> >(totalClubs_, std::vector<bool>(M_, false));
            //Assign particles to clubs randomly
            for (Size i = 0; i < M_; i++) {
                std::vector<bool> &clubSet = clubs4particles_[i];
                for (Size j = 0; j < defaultClubs_; j++) {
                    Size index = distribution_(generator_);
                    while (clubSet[index]) { index = distribution_(generator_); }
                    clubSet[index] = true;
                    particles4clubs_[index][i] = true;
                }
            }
        }
        else {
            //Since totalClubs_ == defaultClubs_, then just initialize to true
            clubs4particles_ = std::vector<std::vector<bool> >(M_, std::vector<bool>(totalClubs_, true));
            particles4clubs_ = std::vector<std::vector<bool> >(totalClubs_, std::vector<bool>(M_, true));
        }
    }

    void ClubsTopology::findSocialBest() {
        //Update iteration
        iteration_++;
        bool reset = false;
        if (iteration_ == resetIteration_) {
            iteration_ = 0;
            reset = true;
        }

        //Find best by current club
        for (Size i = 0; i < totalClubs_; i++) {
            Real bestByClub = QL_MAX_REAL;
            Real worstByClub = -QL_MAX_REAL;
            Size bestP = 0;
            Size worstP = 0;
            const std::vector<bool> &particlesSet = particles4clubs_[i];
            for (Size j = 0; j < M_; j++) {
                if (particlesSet[j]) {
                    if (bestByClub >(*pBF_)[j]) {
                        bestByClub = (*pBF_)[j];
                        bestP = j;
                    }
                    else if (worstByClub < (*pBF_)[j]) {
                        worstByClub = (*pBF_)[j];
                        worstP = j;
                    }
                }
            }
            bestByClub_[i] = bestP;
            worstByClub_[i] = worstP;
        }

        //Update clubs && global best
        for (Size i = 0; i < M_; i++) {
            std::vector<bool> &clubSet = clubs4particles_[i];
            bool best = true;
            bool worst = true;
            Size currentClubs = 0;
            for (Size j = 0; j < totalClubs_; j++) {
                if (clubSet[j]) {
                    //If still thought of the best, check if best in club j
                    if (best && i != bestByClub_[j]) best = false;
                    //If still thought of the worst, check if worst in club j
                    if (worst && i != worstByClub_[j]) worst = false;
                    //Update currentClubs
                    currentClubs++;
                }
            }
            //Update clubs
            if (best) {
                //Leave random club
                leaveRandomClub(i, currentClubs);
            }
            else if (worst) {
                //Join random club
                joinRandomClub(i, currentClubs);
            }
            else if (reset && currentClubs != defaultClubs_) {
                //If membership != defaultClubs_, then leave or join accordingly
                if (currentClubs < defaultClubs_) {
                    //Join random club
                    joinRandomClub(i, currentClubs);
                }
                else {
                    //Leave random club
                    leaveRandomClub(i, currentClubs);
                }
            }

            //Update global best
            Real bestNeighborF = QL_MAX_REAL;
            Size bestNeighborX = 0;
            for (Size j = 0; j < totalClubs_; j++) {
                if (clubSet[j] && bestNeighborF >(*pBF_)[bestByClub_[j]]) {
                    bestNeighborF = (*pBF_)[bestByClub_[j]];
                    bestNeighborX = j;
                }
            }
            (*gBX_)[i] = (*pBX_)[bestNeighborX];
            (*gBF_)[i] = bestNeighborF;
        }
    }

    void ClubsTopology::leaveRandomClub(Size particle, Size currentClubs) {
        Size randIndex = distribution_(generator_,
            uniform_integer::param_type(1, currentClubs));
        Size index = 1;
        std::vector<bool> &clubSet = clubs4particles_[particle];
        for (Size j = 0; j < totalClubs_; j++) {
            if (clubSet[j]) {
                if (index == randIndex) {
                    clubSet[j] = false;
                    particles4clubs_[j][particle] = false;
                    break;
                }
                index++;
            }
        }
    }

    void ClubsTopology::joinRandomClub(Size particle, Size currentClubs) {
        Size randIndex = totalClubs_ == currentClubs ? 1 :
            distribution_(generator_, uniform_integer::param_type(1, totalClubs_ - currentClubs));
        Size index = 1;
        std::vector<bool> &clubSet = clubs4particles_[particle];
        for (Size j = 0; j < totalClubs_; j++) {
            if (!clubSet[j]) {
                if (index == randIndex) {
                    clubSet[j] = true;
                    particles4clubs_[j][particle] = true;
                    break;
                }
                index++;
            }
        }
    }
}

]]></document_content>
  </document>
  <document index="397">
    <source>math/particleswarmoptimization.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Andres Hernandez

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file particleswarmoptimization.hpp
\brief Implementation based on:
Clerc, M., Kennedy, J. (2002) The particle swarm-explosion, stability and
convergence in a multidimensional complex space. IEEE Transactions on Evolutionary
Computation, 6(2): 5873.
*/

#ifndef quantlib_optimization_particleswarmoptimization_hpp
#define quantlib_optimization_particleswarmoptimization_hpp

#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/experimental/math/isotropicrandomwalk.hpp>
#include <ql/experimental/math/levyflightdistribution.hpp>
#include <ql/math/randomnumbers/seedgenerator.hpp>

#include <boost/random/mersenne_twister.hpp>
typedef boost::mt19937 base_generator_type;

#include <boost/random/uniform_int_distribution.hpp>
typedef boost::random::uniform_int_distribution<QuantLib::Size> uniform_integer;

namespace QuantLib {

    /*! The process is as follows:
    M individuals are used to explore the N-dimensional parameter space:
    \f$ X_{i}^k = (X_{i, 1}^k, X_{i, 2}^k, \ldots, X_{i, N}^k) \f$ is the kth-iteration for the ith-individual.

    X is updated via the rule
    \f[
    X_{i, j}^{k+1} = X_{i, j}^k + V_{i, j}^{k+1}
    \f]
    with V being the "velocity" that updates the position:
    \f[
    V_{i, j}^{k+1} = \chi\left(V_{i, j}^k + c_1 r_{i, j}^k (P_{i, j}^k - X_{i, j}^k)
    + c_2 R_{i, j}^k (G_{i, j}^k - X_{i, j}^k)\right)
    \f]
    where c are constants, r and R are uniformly distributed random numbers in the range [0, 1], and
    \f$ P_{i, j} \f$ is the personal best parameter set for individual i up to iteration k
    \f$ G_{i, j} \f$ is the global best parameter set for the swarm up to iteration k.
    \f$ c_1 \f$ is the self recognition coefficient
    \f$ c_2 \f$ is the social recognition coefficient

    This version is known as the PSO with constriction factor (PSO-Co).
    PSO with inertia factor (PSO-In) updates the velocity according to:
    \f[
    V_{i, j}^{k+1} = \omega V_{i, j}^k + \hat{c}_1 r_{i, j}^k (P_{i, j}^k - X_{i, j}^k)
    + \hat{c}_2 R_{i, j}^k (G_{i, j}^k - X_{i, j}^k)
    \f]
    and is accessible from PSO-Co by setting \f$ \omega = \chi \f$,
    and \f$ \hat{c}_{1,2} = \chi c_{1,2} \f$.

    These two versions of PSO are normally referred to as canonical PSO.

    Convergence of PSO-Co is improved if \f$ \chi \f$ is chosen as
    \f$ \chi = \frac{2}{\vert 2-\phi-\sqrt{\phi^2 - 4\phi}\vert} \f$,
    with \f$ \phi = c_1 + c_2 \f$.
    Stable convergence is achieved if \f$ \phi >= 4 \f$. Clerc and Kennedy recommend
    \f$ c_1 = c_2 = 2.05 \f$ and \f$ \phi = 4.1 \f$.

    Different topologies can be chosen for G, e.g. instead of it being the best
    of the swarm, it is the best of the nearest neighbours, or some other form.

    In the canonical PSO, the inertia function is trivial. It is simply a
    constant (the inertia) multiplying the previous iteration's velocity. The
    value of the inertia constant determines the weight of a global search over
    local search. Like in the case of the topology, other possibilities for the
    inertia function are also possible, e.g. a function that interpolates between a
    high inertia at the beginning of the optimization (hence prioritizing a global
    search) and a low inertia towards the end of the optimization (hence prioritizing
    a local search).

    The optimization stops either because the number of iterations has been reached
    or because the stationary function value limit has been reached.
    */
    class ParticleSwarmOptimization : public OptimizationMethod {
      public:
        class Inertia;
        class Topology;
        friend class Inertia;
        friend class Topology;
        ParticleSwarmOptimization(Size M,
                                  ext::shared_ptr<Topology> topology,
                                  ext::shared_ptr<Inertia> inertia,
                                  Real c1 = 2.05,
                                  Real c2 = 2.05,
                                  unsigned long seed = SeedGenerator::instance().get());
        explicit ParticleSwarmOptimization(Size M,
                                           ext::shared_ptr<Topology> topology,
                                           ext::shared_ptr<Inertia> inertia,
                                           Real omega,
                                           Real c1,
                                           Real c2,
                                           unsigned long seed = SeedGenerator::instance().get());
        void startState(Problem &P, const EndCriteria &endCriteria);
        EndCriteria::Type minimize(Problem& P, const EndCriteria& endCriteria) override;

      protected:
        std::vector<Array> X_, V_, pBX_, gBX_;
        Array pBF_, gBF_;
        Array lX_, uX_;
        Size M_, N_;
        Real c0_, c1_, c2_;
        MersenneTwisterUniformRng rng_;
        ext::shared_ptr<Topology> topology_;
        ext::shared_ptr<Inertia> inertia_;
    };

    //! Base inertia class used to alter the PSO state
    /*! This pure virtual base class provides the access to the PSO state
    which the particular inertia algorithm will change upon each iteration.
    */
    class ParticleSwarmOptimization::Inertia {
        friend class ParticleSwarmOptimization;
      public:
        virtual ~Inertia() = default;
        //! initialize state for current problem
        virtual void setSize(Size M, Size N, Real c0, const EndCriteria &endCriteria) = 0;
        //! produce changes to PSO state for current iteration
        virtual void setValues() = 0;
      protected:
        ParticleSwarmOptimization *pso_;
        std::vector<Array> *X_, *V_, *pBX_, *gBX_;
        Array *pBF_, *gBF_;
        Array *lX_, *uX_;

        virtual void init(ParticleSwarmOptimization *pso) {
            pso_ = pso;
            X_ = &pso_->X_;
            V_ = &pso_->V_;
            pBX_ = &pso_->pBX_;
            gBX_ = &pso_->gBX_;
            pBF_ = &pso_->pBF_;
            gBF_ = &pso_->gBF_;
            lX_ = &pso_->lX_;
            uX_ = &pso_->uX_;
        }
    };

    //! Trivial Inertia
    /*     Inertia is a static value
    */
    class TrivialInertia : public ParticleSwarmOptimization::Inertia {
      public:
        inline void setSize(Size M, Size N, Real c0, const EndCriteria& endCriteria) override {
            c0_ = c0;
            M_ = M;
        }
        inline void setValues() override {
            for (Size i = 0; i < M_; i++) {
                (*V_)[i] *= c0_;
            }
        }

      private:
        Real c0_;
        Size M_;
    };

    //! Simple Random Inertia
    /*     Inertia value gets multiplied with a random number
    between (threshold, 1)
    */
    class SimpleRandomInertia : public ParticleSwarmOptimization::Inertia {
      public:
        SimpleRandomInertia(Real threshold = 0.5, unsigned long seed = SeedGenerator::instance().get())
            : threshold_(threshold), rng_(seed) {
            QL_REQUIRE(threshold_ >= 0.0 && threshold_ < 1.0, "Threshold must be a Real in [0, 1)");
        }
        inline void setSize(Size M, Size N, Real c0, const EndCriteria& endCriteria) override {
            M_ = M;
            c0_ = c0;
        }
        inline void setValues() override {
            for (Size i = 0; i < M_; i++) {
                Real val = c0_*(threshold_ + (1.0 - threshold_)*rng_.nextReal());
                (*V_)[i] *= val;
            }
        }

      private:
        Real c0_, threshold_;
        Size M_;
        MersenneTwisterUniformRng rng_;
    };

    //! Decreasing Inertia
    /*     Inertia value gets decreased every iteration until it reaches
    a value of threshold when iteration reaches the maximum level
    */
    class DecreasingInertia : public ParticleSwarmOptimization::Inertia {
      public:
        DecreasingInertia(Real threshold = 0.5)
            : threshold_(threshold) {
            QL_REQUIRE(threshold_ >= 0.0 && threshold_ < 1.0, "Threshold must be a Real in [0, 1)");
        }
        inline void setSize(Size M, Size N, Real c0, const EndCriteria& endCriteria) override {
            N_ = N;
            c0_ = c0;
            iteration_ = 0;
            maxIterations_ = endCriteria.maxIterations();
        }
        inline void setValues() override {
            Real c0 = c0_*(threshold_ + (1.0 - threshold_)*(maxIterations_ - iteration_) / maxIterations_);
            for (Size i = 0; i < M_; i++) {
                (*V_)[i] *= c0;
            }
        }

      private:
        Real c0_, threshold_;
        Size M_, N_, maxIterations_, iteration_;
    };

    //! AdaptiveInertia
    /*    Alen Lukic, Approximating Kinetic Parameters Using Particle
    Swarm Optimization.
    */
    class AdaptiveInertia : public ParticleSwarmOptimization::Inertia {
      public:
        AdaptiveInertia(Real minInertia, Real maxInertia, Size sh = 5, Size sl = 2)
            :minInertia_(minInertia), maxInertia_(maxInertia),
            sh_(sh), sl_(sl) {};
        inline void setSize(Size M, Size N, Real c0, const EndCriteria& endCriteria) override {
            M_ = M;
            c0_ = c0;
            adaptiveCounter = 0;
            best_ = QL_MAX_REAL;
            started_ = false;
        }
        void setValues() override;

      private:
        Real c0_, best_;
        Real minInertia_, maxInertia_;
        Size M_;
        Size sh_, sl_;
        Size adaptiveCounter;
        bool started_;
    };

    //! Levy Flight Inertia
    /*    As long as the particle keeps getting frequent updates to its
    personal best value, the inertia behaves like a SimpleRandomInertia,
    but after a number of iterations without improvement, the behaviour
    changes to that of a Levy flight ~ u^{-1/\alpha}
    */
    class LevyFlightInertia : public ParticleSwarmOptimization::Inertia {
      public:
        typedef IsotropicRandomWalk<LevyFlightDistribution, base_generator_type> IsotropicLevyFlight;
        LevyFlightInertia(Real alpha, Size threshold,
                          unsigned long seed = SeedGenerator::instance().get())
            :rng_(seed), flight_(base_generator_type(seed), LevyFlightDistribution(1.0, alpha),
                1, Array(1, 1.0), seed),
            threshold_(threshold) {};
        inline void setSize(Size M, Size N, Real c0, const EndCriteria& endCriteria) override {
            M_ = M;
            N_ = N;
            c0_ = c0;
            adaptiveCounter_ = std::vector<Size>(M_, 0);
        }
        inline void setValues() override {
            for (Size i = 0; i < M_; i++) {
                if ((*pBF_)[i] < personalBestF_[i]) {
                    personalBestF_[i] = (*pBF_)[i];
                    adaptiveCounter_[i] = 0;
                }
                else {
                    adaptiveCounter_[i]++;
                }
                if (adaptiveCounter_[i] <= threshold_) {
                    //Simple Random Inertia
                    (*V_)[i] *= c0_*(0.5 + 0.5*rng_.nextReal());
                }
                else {
                    //If particle has not found a new personal best after threshold_ iterations
                    //then trigger a Levy flight pattern for the speed
                    flight_.nextReal<Real *>(&(*V_)[i][0]);
                }
            }
        }

      protected:
        void init(ParticleSwarmOptimization* pso) override {
            ParticleSwarmOptimization::Inertia::init(pso);
            personalBestF_ = *pBF_;
            flight_.setDimension(N_, *lX_, *uX_);
        }

      private:
        MersenneTwisterUniformRng rng_;
        IsotropicLevyFlight flight_;
        Array personalBestF_;
        std::vector<Size> adaptiveCounter_;
        Real c0_;
        Size M_, N_;
        Size threshold_;
    };

    //! Base topology class used to determine the personal and global best
    /*! This pure virtual base class provides the access to the PSO state
    which the particular topology algorithm will change upon each iteration.
    */
    class ParticleSwarmOptimization::Topology {
        friend class ParticleSwarmOptimization;
      public:
        virtual ~Topology() = default;
        //! initialize state for current problem
        virtual void setSize(Size M) = 0;
        //! produce changes to PSO state for current iteration
        virtual void findSocialBest() = 0;
      protected:
        ParticleSwarmOptimization *pso_;
        std::vector<Array> *X_, *V_, *pBX_, *gBX_;
        Array *pBF_, *gBF_;
      private:
        void init(ParticleSwarmOptimization *pso) {
            pso_ = pso;
            X_ = &pso_->X_;
            V_ = &pso_->V_;
            pBX_ = &pso_->pBX_;
            gBX_ = &pso_->gBX_;
            pBF_ = &pso_->pBF_;
            gBF_ = &pso_->gBF_;
        }
    };

    //! Global Topology
    /*  The global best as seen by each particle is the best from amongst
    all particles
    */
    class GlobalTopology : public ParticleSwarmOptimization::Topology {
      public:
        inline void setSize(Size M) override { M_ = M; }
        inline void findSocialBest() override {
            Real bestF = (*pBF_)[0];
            Size bestP = 0;
            for (Size i = 1; i < M_; i++) {
                if (bestF < (*pBF_)[i]) {
                    bestF = (*pBF_)[i];
                    bestP = i;
                }
            }
            Array& x = (*pBX_)[bestP];
            for (Size i = 0; i < M_; i++) {
                if (i != bestP) {
                    (*gBX_)[i] = x;
                    (*gBF_)[i] = bestF;
                }
            }
        }

      private:
        Size M_;
    };

    //! K-Neighbor Topology
    /*  The global best as seen by each particle is the best from amongst
    the previous K and next K neighbors. For particle I, the best is
    then taken from amongst the [I - K, I + K] particles.
    */
    class KNeighbors : public ParticleSwarmOptimization::Topology {
      public:
        KNeighbors(Size K = 1) :K_(K) {
            QL_REQUIRE(K > 0, "Neighbors need to be larger than 0");
        }
        inline void setSize(Size M) override {
            M_ = M;
            QL_ENSURE(K_ < M, "Number of neighbors need to be smaller than total particles in swarm");
        }
        void findSocialBest() override;

      private:
        Size K_, M_;
    };

    //! Clubs Topology
    /*  H.M. Emara,  Adaptive Clubs-based Particle Swarm Optimization
    Each particle is originally assigned to a default number of clubs
    from among the total set. The best as seen by each particle is the
    best from amongst the clubs to which the particle belongs.
    Underperforming particles join more clubs randomly (up to a maximum
    number) to widen the particles that influence them, while
    overperforming particles leave clubs randomly (down to a minimum
    number) to avoid early convergence to local minima.
    */
    class ClubsTopology : public ParticleSwarmOptimization::Topology {
      public:
        ClubsTopology(Size defaultClubs, Size totalClubs,
            Size maxClubs, Size minClubs,
            Size resetIteration, unsigned long seed = SeedGenerator::instance().get());
        void setSize(Size M) override;
        void findSocialBest() override;

      private:
        Size totalClubs_, maxClubs_, minClubs_, defaultClubs_;
        Size iteration_, resetIteration_;
        Size M_;
        std::vector<std::vector<bool> > clubs4particles_;
        std::vector<std::vector<bool> > particles4clubs_;
        std::vector<Size> bestByClub_;
        std::vector<Size> worstByClub_;
        base_generator_type generator_;
        uniform_integer distribution_;

        void leaveRandomClub(Size particle, Size currentClubs);
        void joinRandomClub(Size particle, Size currentClubs);
    };

}

#endif
]]></document_content>
  </document>
  <document index="398">
    <source>math/piecewisefunction.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file piecewisefunction.hpp
    \brief utility macro for piecewise functions
*/

#ifndef quantlib_piecewise_function_hpp
#define quantlib_piecewise_function_hpp

#include <ql/qldefines.hpp>
#include <algorithm>

/*! This defines a piecewise constant function which is RCLL and takes
    the values Y[0], Y[1], ... Y[n] on the intervals
    (-\infty, X[0]), [ X[1], X[2] ), ... , [ X[n-1], \infty)
    Normally Y.size() should be X.size() + 1. If more values for Y are
    given, they are ignored. If less values are given the last given
    value is kept the same for the remaining intervals.
    If X.size() is 0 a constant function taking the value Y[0] is
    evaluated.

    \warning If Y.size() is 0, an invalid access occurs. This
             condition is not checked for performance reasons.
*/

#define QL_PIECEWISE_FUNCTION(X, Y, x)                                         \
    Y[std::min<std::size_t>(                                                   \
        std::upper_bound(X.begin(), X.end(), x) - X.begin(), Y.size() - 1)]

#endif
]]></document_content>
  </document>
  <document index="399">
    <source>math/piecewiseintegral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/piecewiseintegral.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    PiecewiseIntegral::PiecewiseIntegral(ext::shared_ptr<Integrator> integrator,
                                         std::vector<Real> criticalPoints,
                                         const bool avoidCriticalPoints)
    : Integrator(1.0, 1), integrator_(std::move(integrator)),
      criticalPoints_(std::move(criticalPoints)),
      eps_(avoidCriticalPoints ? (1.0 + QL_EPSILON) : 1.0) {

        std::sort(criticalPoints_.begin(), criticalPoints_.end());
        std::vector<Real>::const_iterator end =
            std::unique(criticalPoints_.begin(), criticalPoints_.end(),
                        static_cast<bool (*)(Real, Real)>(close_enough));
        criticalPoints_.resize(end - criticalPoints_.begin());
    }

} // namespace QuantLib
]]></document_content>
  </document>
  <document index="400">
    <source>math/piecewiseintegral.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file piecewiseintegral.hpp
    \brief Integral of a piecewise well behaved function using
           a custom integrator for the pieces. It can be forced
           that the function is integrated only over intervals
           strictly not containing the critical points
*/

#ifndef quantlib_piecewise_integral_hpp
#define quantlib_piecewise_integral_hpp

#include <ql/math/integrals/integral.hpp>
#include <ql/math/comparison.hpp>
#include <ql/shared_ptr.hpp>
#include <algorithm>
#include <vector>

namespace QuantLib {

class PiecewiseIntegral : public Integrator {
  public:
    PiecewiseIntegral(ext::shared_ptr<Integrator> integrator,
                      std::vector<Real> criticalPoints,
                      bool avoidCriticalPoints = true);

  protected:
    Real integrate(const ext::function<Real(Real)>& f, Real a, Real b) const override;

  private:
    Real integrate_h(const ext::function<Real(Real)> &f, Real a,
                     Real b) const;
    const ext::shared_ptr<Integrator> integrator_;
    std::vector<Real> criticalPoints_;
    const Real eps_;
};

// inline

inline Real PiecewiseIntegral::integrate_h(const ext::function<Real(Real)> &f,
                                           Real a, Real b) const {

    if (!close_enough(a, b))
        return (*integrator_)(f, a, b);
    else
        return 0.0;
}

inline Real PiecewiseIntegral::integrate(const ext::function<Real(Real)> &f,
                                         Real a, Real b) const {

    auto a0 = std::lower_bound(criticalPoints_.begin(), criticalPoints_.end(), a);

    auto b0 = std::lower_bound(criticalPoints_.begin(), criticalPoints_.end(), b);

    if (a0 == criticalPoints_.end()) {
        Real tmp = 1.0;
        if (!criticalPoints_.empty()) {
            if (close_enough(a, criticalPoints_.back())) {
                tmp = eps_;
            }
        }
        return integrate_h(f, a * tmp, b);
    }

    Real res = 0.0;

    if (!close_enough(a, *a0)) {
        res += integrate_h(f, a, std::min(*a0 / eps_, b));
    }

    if (b0 == criticalPoints_.end()) {
        --b0;
        if (!close_enough(*b0, b)) {
            res += integrate_h(f, (*b0) * eps_, b);
        }
    }

    for (auto x = a0; x < b0; ++x) {
        res += integrate_h(f, (*x) * eps_, std::min(*(x + 1) / eps_, b));
    }

    return res;
}

} // namespace QuantLib

#endif
]]></document_content>
  </document>
  <document index="401">
    <source>math/polarstudenttrng.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file polarstudenttrng.hpp
    \brief Polar Student t random-number generator
*/

#ifndef quantlib_polar_student_t_rng_h
#define quantlib_polar_student_t_rng_h

#include <ql/methods/montecarlo/sample.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    //! Student t random number generator
    /*! Polar transformation based Student T random number generator.
        See "Polar Generation of Random Variates With the t-Distribution",
        Ralph W. Bailey, April 1994, in Mathematics of Computation, Vol 62-206
        page 779.
        The one implemented here is a variant of this algorithm from "Random 
        Number Generation and Monte Carlo Methods", Springer, 2003, page 185. 
        Using a uniform RNG on a [-1,1] support, the extra call to the uniform
        generator (used for the sign of the sample) is avoided.

        Class RNG must implement the following interface:
        \code
            URNG::sample_type RNG::next() const;
        \endcode

        \warning do not use with a low-discrepancy sequence generator.
    */
    template <class URNG>
    class PolarStudentTRng {
      public:
        typedef Sample<Real> sample_type;
        typedef URNG urng_type;

        explicit PolarStudentTRng(Real degFreedom, BigNatural seed = 0) 
            : uniformGenerator_(seed),
              degFreedom_(degFreedom) {
          QL_REQUIRE(degFreedom_ > 0, 
              "Invalid degrees of freedom parameter.");
        }

        explicit PolarStudentTRng(Real degFreedom, const URNG& urng) 
            : uniformGenerator_(urng), 
              degFreedom_(degFreedom) {
          QL_REQUIRE(degFreedom_ > 0, 
              "Invalid degrees of freedom parameter.");
        }

        //! returns a sample from a Student-t distribution
        sample_type next() const;
    private:
        URNG uniformGenerator_;
        mutable Real degFreedom_;
    };

    template <class URNG>
    inline typename PolarStudentTRng<URNG>::sample_type
    PolarStudentTRng<URNG>::next() const {
        Real u, v, rSqr;
        do{
            //samples remapped to [-1,1]:
            v = 2.* uniformGenerator_.next().value - 1.;
            u = 2.* uniformGenerator_.next().value - 1.;
            rSqr = v*v + u*u;
        }while(rSqr >= 1.);
        return {u * std::sqrt(degFreedom_ * (std::pow(rSqr, -2. / degFreedom_) - 1.) / rSqr), 1.};
    }

}

#endif
]]></document_content>
  </document>
  <document index="402">
    <source>math/tcopulapolicy.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/tcopulapolicy.hpp>
#include <numeric>
#include <algorithm>

namespace QuantLib {

    TCopulaPolicy::TCopulaPolicy(
        const std::vector<std::vector<Real> >& factorWeights, 
        const initTraits& vals)
    {
        for (int tOrder : vals.tOrders) {
            // require no T is of order 2 (finite variance)
            QL_REQUIRE(tOrder > 2, "Non finite variance T in latent model.");

            distributions_.emplace_back(tOrder);
            // inverses T variaces used in normalization of the random factors
            // For low values of the T order this number is very close to zero 
            // and it enters the expressions dividing them, which introduces 
            // numerical errors.
            varianceFactors_.push_back(std::sqrt((tOrder - 2.) / tOrder));
        }

        for (const auto& factorWeight : factorWeights) {
            // This ensures the latent model is 'canonical'
            QL_REQUIRE(vals.tOrders.size() == factorWeight.size() + 1,
                       // num factors plus one
                       "Incompatible number of T functions and number of factors.");

            Real factorsNorm = std::inner_product(factorWeight.begin(), factorWeight.end(),
                                                  factorWeight.begin(), 0.);
            QL_REQUIRE(factorsNorm < 1., 
                "Non normal random factor combination.");
            Real idiosyncFctr = std::sqrt(1.-factorsNorm);

            // linear comb factors ajusted for the variance renormalization:
            std::vector<Real> normFactorWeights;
            for (Size iFactor = 0; iFactor < factorWeight.size(); iFactor++)
                normFactorWeights.push_back(factorWeight[iFactor] * varianceFactors_[iFactor]);
            // idiosincratic term, all Z factors are assumed identical.
            normFactorWeights.push_back(idiosyncFctr * varianceFactors_.back());
            latentVarsCumul_.emplace_back(vals.tOrders, normFactorWeights);
            latentVarsInverters_.emplace_back(vals.tOrders, normFactorWeights);
        }
    }

    Disposable<std::vector<Real> > 
    TCopulaPolicy::allFactorCumulInverter(
        const std::vector<Real>& probs) const 
    {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(probs.size()-latentVarsCumul_.size() 
            == distributions_.size()-1, 
            "Incompatible sample and latent model sizes");
    #endif

        std::vector<Real> result(probs.size());
        Size indexSystemic = 0;
        std::transform(probs.begin(), probs.begin() + varianceFactors_.size()-1,
                       result.begin(),
                       [&](Probability p) { return inverseCumulativeDensity(p, indexSystemic++); });
        std::transform(probs.begin() + varianceFactors_.size()-1, probs.end(),
                       result.begin()+ varianceFactors_.size()-1,
                       [&](Probability p) { return inverseCumulativeZ(p); });
        return result;
    }

}
]]></document_content>
  </document>
  <document index="403">
    <source>math/tcopulapolicy.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_tcopula_policy_hpp
#define quantlib_tcopula_policy_hpp

#include <ql/errors.hpp>
#include <ql/utilities/disposable.hpp>
#include <ql/experimental/math/convolvedstudentt.hpp>
#include <ql/functional.hpp>
#include <boost/math/distributions/students_t.hpp>
#include <vector>

namespace QuantLib {

    /*! \brief Student-T Latent Model's copula policy.

    Describes the copula of a set of normalized Student-T independent random 
    factors to be fed into the latent variable model. 
    The latent model requires the independent variables to be of unit variance 
    so the policy expects the factors coefficients to be as usual and the T 
    variables to be normalized, the normalization is performed by the policy. 
    To normalize the random variables they are divided by the square root of 
    the variance of each T (\f$ \frac{\nu}{\nu-2}\f$)
    */
    class TCopulaPolicy {
    public:
        /*! Stores the parameters defining the factors random variable 
        T-distributions. As it is now the latent models are restricted to
        having the same distribution for all idiosyncratic factors, so only
        one parameter is needed for them.
        */
        typedef 
            struct { 
                std::vector<Integer> tOrders;
            } initTraits;

        /*! Delayed initialization of the distribution parameters and caches. 
        To be called by the latent model. */
        /* \todo 
        Explore other constructors, with different vector dimensions, defining
        simpler combinations (only one correlation, only one variable) might
        simplify memory.
        */
        explicit TCopulaPolicy(
            const std::vector<std::vector<Real> >& factorWeights = 
                std::vector<std::vector<Real> >(), 
            const initTraits& vals = initTraits());

        //! Number of independent random factors.
        Size numFactors() const {
            return latentVarsInverters_.size() + varianceFactors_.size() - 1;
        }

        //! returns a copy of the initialization arguments
        //... better to have a cache?
        initTraits getInitTraits() const {
            initTraits data;
            data.tOrders.resize(distributions_.size());
            for (Size i=0; i<distributions_.size(); ++i) {
                data.tOrders[i] = static_cast<Integer>(
                    distributions_[i].degrees_of_freedom());
            }
            return data;
        }
        const std::vector<Real>& varianceFactors() const {
            return varianceFactors_;
        }
        /*! Cumulative probability of a given latent variable.
            The iVariable parameter is the index of the requested variable.
        */
        Probability cumulativeY(Real val, Size iVariable) const {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(iVariable < latentVarsCumul_.size(), 
                "Latent variable index out of bounds.");
    #endif
            return latentVarsCumul_[iVariable](val);
        }
        //! Cumulative probability of the idiosyncratic factors (all the same)
        Probability cumulativeZ(Real z) const {
            return boost::math::cdf(distributions_.back(), z / 
                varianceFactors_.back());
        }
        /*! Probability density of a given realization of values of the systemic
          factors (remember they are independent).
          Intended to be used in numerical integration of an arbitrary function 
          depending on those values.
        */
        Probability density(const std::vector<Real>& m) const {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(m.size() == distributions_.size()-1, 
                "Incompatible sample and latent model sizes");
    #endif
            Real prodDensities = 1.;
            for(Size i=0; i<m.size(); i++) 
                prodDensities *= boost::math::pdf(distributions_[i], 
                    m[i] /varianceFactors_[i]) /varianceFactors_[i];
                 // accumulate lambda
            return prodDensities;
        }
        /*! Returns the inverse of the cumulative distribution of the (modelled) 
          latent variable (as indexed by iVariable). Involves the convolution
          of the factors' distributions.
        */
        Real inverseCumulativeY(Probability p, Size iVariable) const {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(iVariable < latentVarsCumul_.size(), 
                "Latent variable index out of bounds.");
    #endif
            return latentVarsInverters_[iVariable](p);
        }
        /*! Returns the inverse of the cumulative distribution of the 
        idiosincratic factor. The LM here is limited to all idiosincratic 
        factors following the same distribution.
        */
        Real inverseCumulativeZ(Probability p) const {
            return boost::math::quantile(distributions_.back(), p)
                * varianceFactors_.back();
        }
        /*! Returns the inverse of the cumulative distribution of the 
          systemic factor iFactor.
        */
        Real inverseCumulativeDensity(Probability p, Size iFactor) const {
    #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(iFactor < distributions_.size()-1, 
                "Random factor variable index out of bounds.");
    #endif
            return boost::math::quantile(distributions_[iFactor], p)
                * varianceFactors_[iFactor];
        }
        //to use this (by default) version, the generator must be a uniform one.
        Disposable<std::vector<Real> > 
            allFactorCumulInverter(const std::vector<Real>& probs) const;
    private:
        mutable std::vector<boost::math::students_t_distribution<> > 
            distributions_;
        mutable std::vector<Real> varianceFactors_;
        mutable std::vector<CumulativeBehrensFisher> latentVarsCumul_;
        mutable std::vector<InverseCumulativeBehrensFisher> 
            latentVarsInverters_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="404">
    <source>math/zigguratrng.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/math/zigguratrng.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <cmath>

namespace QuantLib {

    namespace {

        // tail probability
        const Real p_ = 2.880541027242713E-004;
        const Real q_ = 1.0 - p_;

        /* The tabulated values were calculated following Marsaglia
           and Tsang (2000). */

        // values of exp(-0.5*x*x)
        const Real f_ [128] = {
            1.000000000000000E+000, 9.635996931557717E-001,
            9.362826817083744E-001, 9.130436479920410E-001,
            8.922816508023054E-001, 8.732430489268560E-001,
            8.555006078850665E-001, 8.387836053106493E-001,
            8.229072113952640E-001, 8.077382946961230E-001,
            7.931770117838610E-001, 7.791460859417049E-001,
            7.655841739092376E-001, 7.524415591857053E-001,
            7.396772436833397E-001, 7.272569183545073E-001,
            7.151515074204785E-001, 7.033360990258188E-001,
            6.917891434460373E-001, 6.804918410064157E-001,
            6.694276673577075E-001, 6.585820000586550E-001,
            6.479418211185520E-001, 6.374954773431460E-001,
            6.272324852578157E-001, 6.171433708265636E-001,
            6.072195366326060E-001, 5.974531509518134E-001,
            5.878370544418217E-001, 5.783646811267034E-001,
            5.690299910747226E-001, 5.598274127106959E-001,
            5.507517931210564E-001, 5.417983550317252E-001,
            5.329626593899887E-001, 5.242405726789938E-001,
            5.156282382498731E-001, 5.071220510813057E-001,
            4.987186354765854E-001, 4.904148252893227E-001,
            4.822076463348397E-001, 4.740943006982505E-001,
            4.660721526945719E-001, 4.581387162728729E-001,
            4.502916436869279E-001, 4.425287152802475E-001,
            4.348478302546628E-001, 4.272469983095633E-001,
            4.197243320540391E-001, 4.122780401070255E-001,
            4.049064208114891E-001, 3.976078564980433E-001,
            3.903808082413902E-001, 3.832238110598844E-001,
            3.761354695144552E-001, 3.691144536682758E-001,
            3.621594953730338E-001, 3.552693848515477E-001,
            3.484429675498729E-001, 3.416791412350141E-001,
            3.349768533169716E-001, 3.283350983761528E-001,
            3.217529158792090E-001, 3.152293880681579E-001,
            3.087636380092523E-001, 3.023548277894802E-001,
            2.960021568498564E-001, 2.897048604458110E-001,
            2.834622082260129E-001, 2.772735029218981E-001,
            2.711380791410257E-001, 2.650553022581624E-001,
            2.590245673987112E-001, 2.530452985097663E-001,
            2.471169475146971E-001, 2.412389935477517E-001,
            2.354109422657280E-001, 2.296323252343031E-001,
            2.239026993871343E-001, 2.182216465563709E-001,
            2.125887730737364E-001, 2.070037094418741E-001,
            2.014661100762035E-001, 1.959756531181106E-001,
            1.905320403209139E-001, 1.851349970107136E-001,
            1.797842721249623E-001, 1.744796383324025E-001,
            1.692208922389250E-001, 1.640078546849280E-001,
            1.588403711409353E-001, 1.537183122095867E-001,
            1.486415742436971E-001, 1.436100800919331E-001,
            1.386237799858510E-001, 1.336826525846477E-001,
            1.287867061971040E-001, 1.239359802039816E-001,
            1.191305467087186E-001, 1.143705124498883E-001,
            1.096560210158178E-001, 1.049872554103546E-001,
            1.003644410295456E-001, 9.578784912257826E-002,
            9.125780082763474E-002, 8.677467189554304E-002,
            8.233889824295743E-002, 7.795098251465470E-002,
            7.361150188475492E-002, 6.932111739418027E-002,
            6.508058521363191E-002, 6.089077034856640E-002,
            5.675266348153862E-002, 5.266740190350321E-002,
            4.863629586028410E-002, 4.466086220087247E-002,
            4.074286807479065E-002, 3.688438878696881E-002,
            3.308788614650520E-002, 2.935631744025387E-002,
            2.569329193614964E-002, 2.210330461611161E-002,
            1.859210273716583E-002, 1.516729801067205E-002,
            1.183947865798232E-002, 8.624484412930473E-003,
            5.548995220816476E-003, 2.669629083902507E-003
        };

        // acceptance thresholds 2^24*x[i]/x[i+1]. k_[0] is special
        const Size k_[128] = {
            15555141,        0, 12590647, 14272656,
            14988942, 15384587, 15635012, 15807564,
            15933580, 16029597, 16105158, 16166150,
            16216402, 16258511, 16294298, 16325081,
            16351834, 16375294, 16396029, 16414482,
            16431005, 16445883, 16459346, 16471581,
            16482747, 16492974, 16502372, 16511034,
            16519042, 16526462, 16533356, 16539772,
            16545758, 16551351, 16556587, 16561496,
            16566104, 16570437, 16574515, 16578357,
            16581980, 16585401, 16588633, 16591688,
            16594579, 16597314, 16599905, 16602358,
            16604682, 16606885, 16608972, 16610949,
            16612822, 16614597, 16616276, 16617865,
            16619367, 16620786, 16622125, 16623387,
            16624575, 16625690, 16626735, 16627713,
            16628624, 16629470, 16630253, 16630974,
            16631634, 16632233, 16632773, 16633254,
            16633677, 16634041, 16634346, 16634593,
            16634781, 16634910, 16634979, 16634987,
            16634934, 16634817, 16634637, 16634390,
            16634075, 16633689, 16633231, 16632698,
            16632085, 16631390, 16630609, 16629737,
            16628768, 16627698, 16626520, 16625226,
            16623808, 16622257, 16620563, 16618714,
            16616696, 16614494, 16612091, 16609465,
            16606593, 16603449, 16599999, 16596206,
            16592025, 16587402, 16582273, 16576559,
            16570163, 16562965, 16554812, 16545511,
            16534809, 16522368, 16507733, 16490265,
            16469045, 16442690, 16409026, 16364394,
            16302111, 16208408, 16049219, 15707338
        };

        // values of 2^{-24}*x[i]. w_[0] is special.
        const Real w_[128] = {
            2.213171867573477E-007, 1.623158840564778E-008,
            2.162882274558596E-008, 2.542424120326624E-008,
            2.845751269184242E-008, 3.103351823837397E-008,
            3.330064883086164E-008, 3.534334554922425E-008,
            3.721467240506913E-008, 3.895036212891571E-008,
            4.057573787247544E-008, 4.210946627340346E-008,
            4.356574479471913E-008, 4.495565083232566E-008,
            4.628801273561392E-008, 4.756999377168848E-008,
            4.880749623079987E-008, 5.000544871575862E-008,
            5.116801519263080E-008, 5.229875022755345E-008,
            5.340071633852936E-008, 5.447657412343023E-008,
            5.552865246542405E-008, 5.655900391923845E-008,
            5.756944891143612E-008, 5.856161138431779E-008,
            5.953694781545649E-008, 6.049677105184184E-008,
            6.144227004387700E-008, 6.237452630714050E-008,
            6.329452775023089E-008, 6.420318036567782E-008,
            6.510131817439508E-008, 6.598971173307500E-008,
            6.686907545162751E-008, 6.774007391947947E-008,
            6.860332740181531E-008, 6.945941663712532E-008,
            7.030888704386109E-008, 7.115225242518010E-008,
            7.198999824564194E-008, 7.282258454149729E-008,
            7.365044851627824E-008, 7.447400686528278E-008,
            7.529365786588351E-008, 7.610978326509584E-008,
            7.692274999129007E-008, 7.773291171314836E-008,
            7.854061026581177E-008, 7.934617696152180E-008,
            8.014993379984568E-008, 8.095219459071287E-008,
            8.175326600192373E-008, 8.255344854147119E-008,
            8.335303748390705E-008, 8.415232374905104E-008,
            8.495159474056128E-008, 8.575113515123489E-008,
            8.655122774137352E-008, 8.735215409611426E-008,
            8.815419536728245E-008, 8.895763300505963E-008,
            8.976274948457178E-008, 9.056982903238356E-008,
            9.137915835783214E-008, 9.219102739414587E-008,
            9.300573005436895E-008, 9.382356500725440E-008,
            9.464483647849558E-008, 9.546985508294559E-008,
            9.629893869382930E-008, 9.713241335539087E-008,
            9.797061424595009E-008, 9.881388669897357E-008,
            9.966258729051657E-008, 1.005170850022725E-007,
            1.013777624705017E-007, 1.022450173323223E-007,
            1.031192636822607E-007, 1.040009336536155E-007,
            1.048904791411299E-007, 1.057883736837368E-007,
            1.066951145288121E-007, 1.076112249025135E-007,
            1.085372565144899E-007, 1.094737923296323E-007,
            1.104214496447496E-007, 1.113808835142578E-007,
            1.123527905763905E-007, 1.133379133403490E-007,
            1.143370450055439E-007, 1.153510348970830E-007,
            1.163807946174674E-007, 1.174273050337859E-007,
            1.184916242434419E-007, 1.195748966907839E-007,
            1.206783636434635E-007, 1.218033752829236E-007,
            1.229514047207811E-007, 1.241240643255547E-007,
            1.253231248369812E-007, 1.265505378645533E-007,
            1.278084625218070E-007, 1.290992971506620E-007,
            1.304257173581136E-007, 1.317907219454484E-007,
            1.331976887933646E-007, 1.346504434266883E-007,
            1.361533438964878E-007, 1.377113869008423E-007,
            1.393303418955523E-007, 1.410169225999109E-007,
            1.427790092234294E-007, 1.446259406525023E-007,
            1.465689049606532E-007, 1.486214710528821E-007,
            1.508003278008381E-007, 1.531263366890930E-007,
            1.556260733859904E-007, 1.583341605221148E-007,
            1.612969382476045E-007, 1.645785196056458E-007,
            1.682713836756925E-007, 1.725163463961286E-007,
            1.775441320326934E-007, 1.837747608550914E-007,
            1.921108355867039E-007, 2.051961336074264E-007
        };

    }

    ZigguratRng::ZigguratRng(unsigned long seed)
    : mt32_(seed) {}

    Real ZigguratRng::nextGaussian() const {
        static const int c[2] = {-1, 1};
        Real x;

        for (;;) {
            unsigned long j = mt32_.nextInt32(); // generate 32 bits of randomness
            int f = j & 1; // 1 bit to choose a tails
            j >>= 1;
            unsigned long i = j & 0x7f; // 7 bits to choose a strip
            j >>= 7; // the last 24 bits for accepttion/rejection
            x = (c[f]*static_cast<long>(j))*w_[i]; // x is uniform
                                                   // within the i-th strip
            if (j < k_[i]) // if true, accept x
                break;

            // handle rejections
            if (i!=0) { // upper strips
                if ((f_[i-1]-f_[i])*mt32_.nextReal() + f_[i] < std::exp(-0.5*x*x))
                    break;
            } else { // base strip, sample from the tail
                x = c[f]*InverseCumulativeNormal::standard_value(
                                                      p_*mt32_.nextReal()+q_);
                break;
            }
        }

        return x;
    }

}
]]></document_content>
  </document>
  <document index="405">
    <source>math/zigguratrng.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zigguratrng.hpp
    \brief Ziggurat random-number generator
*/

#ifndef quantlib_ziggurat_generator_hpp
#define quantlib_ziggurat_generator_hpp

#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/randomnumbers/randomsequencegenerator.hpp>

namespace QuantLib {

    //! Ziggurat random-number generator
    /*! This generator returns standard normal variates using the
        Ziggurat method.  The underlying RNG is mt19937 (32 bit
        version). The algorithm is described in Marsaglia and Tsang
        (2000). "The Ziggurat Method for Generating Random
        Variables". Journal of Statistical Software 5 (8).  Note that
        step 2 from the above paper reuses the rightmost 8 bits of the
        random integer, which creates correlation between steps 1 and
        2.  This implementation was written from scratch, following
        Marsaglia and Tsang.  It avoids the correlation by using only
        the leftmost 24 bits of mt19937's output.

        Note that the GNU GSL implementation uses a different value
        for the right-most step. The GSL value is somewhat different
        from the one reported by Marsaglia and Tsang because GSL uses
        a different tail. This implementation uses the same right-most
        step as reported by Marsaglia and Tsang.  The generator was
        put through Marsaglia's Diehard battery of tests and didn't
        exibit any abnormal behavior.
    */
    class ZigguratRng {
      public:
        typedef Sample<Real> sample_type;
        explicit ZigguratRng(unsigned long seed = 0);
        sample_type next() const { return {nextGaussian(), 1.0}; }

      private:
        mutable MersenneTwisterUniformRng mt32_;
        Real nextGaussian() const;
    };

    // RNG traits for Ziggurat generator
    struct Ziggurat {
        // typedefs
        typedef ZigguratRng rng_type;
        typedef RandomSequenceGenerator<rng_type> rsg_type;
        // more traits
        enum { allowsErrorEstimate = 1 };
        // factory
        static rsg_type make_sequence_generator(Size dimension,
                                                BigNatural seed) {
            return rsg_type(dimension, seed);
        }
    };

}

#endif
]]></document_content>
  </document>
  <document index="406">
    <source>mcbasket/Makefile.am</source>
    <document_content><![CDATA[

AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    adaptedpathpayoff.hpp \
    longstaffschwartzmultipathpricer.hpp \
    mcamericanpathengine.hpp \
    mclongstaffschwartzpathengine.hpp \
    mcpathbasketengine.hpp \
    pathmultiassetoption.hpp \
    pathpayoff.hpp

cpp_files = \
    adaptedpathpayoff.cpp \
    longstaffschwartzmultipathpricer.cpp \
    mcpathbasketengine.cpp \
    pathmultiassetoption.cpp

if UNITY_BUILD

nodist_libMcBasket_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libMcBasket_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libMcBasket.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="407">
    <source>mcbasket/adaptedpathpayoff.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/mcbasket/adaptedpathpayoff.hpp>

namespace QuantLib {

  /*
    Initializing maximumTimeRead_ to -1 would make more sense,
    but it is unsigned and 0 has exactly the same behaviour.
   */
  AdaptedPathPayoff::ValuationData::ValuationData(
                                              const Matrix       & path,
                                              const std::vector<Handle<YieldTermStructure> > & forwardTermStructures,
                                              Array              & payments,
                                              Array              & exercises,
                                              std::vector<Array> & states) :
    path_(path),
    forwardTermStructures_(forwardTermStructures),
    payments_(payments), exercises_(exercises), states_(states),
    maximumTimeRead_(0)
  { }

  Size AdaptedPathPayoff::ValuationData::numberOfTimes() const {
    return path_.columns();
  }

  Size AdaptedPathPayoff::ValuationData::numberOfAssets() const {
    return path_.rows();
  }

  Real AdaptedPathPayoff::ValuationData::getAssetValue(Size time, Size asset) {
    maximumTimeRead_ = std::max(maximumTimeRead_, time);

    return path_[asset][time];
  }

  const Handle<YieldTermStructure> & AdaptedPathPayoff::ValuationData::getYieldTermStructure(Size time) {
    maximumTimeRead_ = std::max(maximumTimeRead_, time);

    return forwardTermStructures_[time];
  }

  void AdaptedPathPayoff::ValuationData::setPayoffValue(Size time, Real value) {
    /*
      This is to ensure the payoff is an adapted function.
      We prevent payments to depend on future fixings.
     */
    QL_REQUIRE(time >= maximumTimeRead_,
               "not adapted payoff: looking into the future");

    payments_[time] = value;
  }

  void AdaptedPathPayoff::ValuationData::setExerciseData(
                                     Size time, Real exercise, Array & state) {
    /*
      This is to ensure the payoff is an adapted function.
      We prevent payments to depend on future fixings.
     */
    QL_REQUIRE(time >= maximumTimeRead_,
               "not adapted payoff: looking into the future");

    if (!exercises_.empty())
      exercises_[time] = exercise;

    if (!states_.empty())
      std::swap(states_[time], state);
  }


  void AdaptedPathPayoff::value(const Matrix       & path,
                                const std::vector<Handle<YieldTermStructure> > & forwardTermStructures,
                                Array              & payments,
                                Array              & exercises,
                                std::vector<Array> & states) const {
    ValuationData data(path, forwardTermStructures, payments, exercises, states);

    operator()(data);
  }
}
]]></document_content>
  </document>
  <document index="408">
    <source>mcbasket/adaptedpathpayoff.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file adaptedpathpayoff.hpp
    \brief Adapted Option payoff classes
*/

#ifndef quantlib_adapted_path_payoff_hpp
#define quantlib_adapted_path_payoff_hpp

#include <ql/experimental/mcbasket/pathpayoff.hpp>

namespace QuantLib {

    class AdaptedPathPayoff : public PathPayoff {
    public:

        class ValuationData {
        public:
            Size numberOfTimes() const;
            Size numberOfAssets() const;

            Real getAssetValue(Size time, Size asset);

            const Handle<YieldTermStructure> & getYieldTermStructure(Size time);

            void setPayoffValue(Size time, Real value);

            // set the exercise payoff if the option is exercised at time "time"
            // it destroys state
            void setExerciseData(Size time, Real exercise, Array & state);

        private:

            friend class AdaptedPathPayoff;

            ValuationData(const Matrix       & path, 
                          const std::vector<Handle<YieldTermStructure> > & forwardTermStructures,
                          Array              & payments, 
                          Array              & exercises, 
                          std::vector<Array> & states);

            const Matrix & path_;
            const std::vector<Handle<YieldTermStructure> > & forwardTermStructures_;

            Array & payments_;
            Array & exercises_;
            std::vector<Array> & states_;

            Size maximumTimeRead_;
        };

        void value(const Matrix& path,
                   const std::vector<Handle<YieldTermStructure> >& forwardTermStructures,
                   Array& payments,
                   Array& exercises,
                   std::vector<Array>& states) const override;

      protected:

        /*
          Key method of this class.

          It computes the payoff by calling ValuationData::setPayoffValue();
          and provides early exercise information 
          via ValuationData::setExerciseData();
         */
        virtual void operator()(ValuationData & data) const = 0;
    };
}

#endif
]]></document_content>
  </document>
  <document index="409">
    <source>mcbasket/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/mcbasket/adaptedpathpayoff.hpp>
#include <ql/experimental/mcbasket/longstaffschwartzmultipathpricer.hpp>
#include <ql/experimental/mcbasket/mcamericanpathengine.hpp>
#include <ql/experimental/mcbasket/mclongstaffschwartzpathengine.hpp>
#include <ql/experimental/mcbasket/mcpathbasketengine.hpp>
#include <ql/experimental/mcbasket/pathmultiassetoption.hpp>
#include <ql/experimental/mcbasket/pathpayoff.hpp>

]]></document_content>
  </document>
  <document index="410">
    <source>mcbasket/longstaffschwartzmultipathpricer.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/mcbasket/longstaffschwartzmultipathpricer.hpp>
#include <ql/math/generallinearleastsquares.hpp>
#include <ql/utilities/tracing.hpp>
#include <utility>

namespace QuantLib {

    LongstaffSchwartzMultiPathPricer::PathInfo::PathInfo(Size numberOfTimes)
        : payments(numberOfTimes, 0.0),
          exercises(numberOfTimes, 0.0),
          states(numberOfTimes) {
    }

    Size LongstaffSchwartzMultiPathPricer::PathInfo::pathLength() const {
        return states.size();
    }


    LongstaffSchwartzMultiPathPricer::LongstaffSchwartzMultiPathPricer(
        const ext::shared_ptr<PathPayoff>& payoff,
        const std::vector<Size>& timePositions,
        std::vector<Handle<YieldTermStructure> > forwardTermStructures,
        Array discounts,
        Size polynomOrder,
        LsmBasisSystem::PolynomType polynomType)
    : calibrationPhase_(true), payoff_(payoff), coeff_(new Array[timePositions.size() - 1]),
      lowerBounds_(new Real[timePositions.size()]), timePositions_(timePositions),
      forwardTermStructures_(std::move(forwardTermStructures)), dF_(std::move(discounts)),
      v_(LsmBasisSystem::multiPathBasisSystem(
          payoff->basisSystemDimension(), polynomOrder, polynomType)) {
        QL_REQUIRE(   polynomType == LsmBasisSystem::Monomial
                   || polynomType == LsmBasisSystem::Laguerre
                   || polynomType == LsmBasisSystem::Hermite
                   || polynomType == LsmBasisSystem::Hyperbolic
                   || polynomType == LsmBasisSystem::Chebyshev2nd,
                   "insufficient polynom type");
    }

    /*
      Extract the relevant information from the whole path
     */
    LongstaffSchwartzMultiPathPricer::PathInfo 
    LongstaffSchwartzMultiPathPricer::transformPath(const MultiPath& multiPath)
    const {
        const Size numberOfAssets = multiPath.assetNumber();
        const Size numberOfTimes = timePositions_.size();

        Matrix path(numberOfAssets, numberOfTimes, Null<Real>());

        for (Size i = 0; i < numberOfTimes; ++i) {
            const Size pos = timePositions_[i];
            for (Size j = 0; j < numberOfAssets; ++j)
                path[j][i] = multiPath[j][pos];
        }
        
        PathInfo info(numberOfTimes);

        payoff_->value(path, forwardTermStructures_, info.payments, info.exercises, info.states);

        return info;
    }

    Real LongstaffSchwartzMultiPathPricer::operator()(
                                            const MultiPath& multiPath) const {
        PathInfo path = transformPath(multiPath);

        if (calibrationPhase_) {
            // store paths for the calibration
            // only the relevant part
            paths_.push_back(path);
            // result doesn't matter
            return 0.0;
        }

        // exercise at time t, cancels all payment AFTER t

        const Size len = path.pathLength();
        Real price = 0.0;

        // this is the last event date
        {
            const Real payoff = path.payments[len - 1];
            const Real exercise = path.exercises[len - 1];
            const Array & states = path.states[len - 1];
            const bool canExercise = !states.empty();

            // at the end the continuation value is 0.0
            if (canExercise && exercise > 0.0)
                price += exercise;
            price += payoff;
        }

        for (Integer i = len - 2; i >= 0; --i) {
            price *= dF_[i + 1] / dF_[i];

            const Real exercise = path.exercises[i];

            /*
              coeff_[i].size()
              - 0 => never exercise
              - v_.size() => use estimated continuation value 
                (if > lowerBounds_[i])
              - v_.size() + 1 => always exercise

              In any case if states is empty, no exercise is allowed.
             */
            const Array & states = path.states[i];
            const bool canExercise = !states.empty();

            if (canExercise) {
                if (coeff_[i].size() == v_.size() + 1) {   
                    // special value always exercise
                    price = exercise;
                }
                else {
                    if (!coeff_[i].empty() && exercise > lowerBounds_[i]) {
                        
                        Real continuationValue = 0.0;
                        for (Size l = 0; l < v_.size(); ++l) {
                            continuationValue += coeff_[i][l] * v_[l](states);
                        }
                        
                        if (continuationValue < exercise) {
                            price = exercise;
                        }
                    }
                }
            }
            const Real payoff = path.payments[i];
            price += payoff;
        }

        return price * dF_[0];
    }

    void LongstaffSchwartzMultiPathPricer::calibrate() {
        const Size n = paths_.size(); // number of paths
        Array prices(n, 0.0), exercise(n, 0.0);

        const Size basisDimension = payoff_->basisSystemDimension();

        const Size len = paths_[0].pathLength();

        /*
          We try to estimate the lower bound of the continuation value,
          so that only itm paths contribute to the regression.
         */

        for (Size j = 0; j < n; ++j) {
            const Real payoff = paths_[j].payments[len - 1];
            const Real exercise = paths_[j].exercises[len - 1];
            const Array & states = paths_[j].states[len - 1];
            const bool canExercise = !states.empty();

            // at the end the continuation value is 0.0
            if (canExercise && exercise > 0.0)
                prices[j] += exercise;
            prices[j] += payoff;
        }

        lowerBounds_[len - 1] = *std::min_element(prices.begin(), prices.end());

        std::vector<bool> lsExercise(n);

        for (Integer i = len - 2; i >= 0; --i) {
            std::vector<Real>  y;
            std::vector<Array> x;

            // prices are discounted up to time i
            const Real discountRatio = dF_[i + 1] / dF_[i];
            prices *= discountRatio;
            lowerBounds_[i + 1] *= discountRatio;

            //roll back step
            for (Size j = 0; j < n; ++j) {
                exercise[j] = paths_[j].exercises[i];

                // If states is empty, no exercise in this path
                // and the path will not partecipate to the Lesat Square regression

                const Array & states = paths_[j].states[i];
                QL_REQUIRE(states.empty() || states.size() == basisDimension, 
                           "Invalid size of basis system");

                // only paths that could potentially create exercise opportunities
                // partecipate to the regression

                // if exercise is lower than minimum continuation value, no point in considering it
                if (!states.empty() && exercise[j] > lowerBounds_[i + 1]) {
                    x.push_back(states);
                    y.push_back(prices[j]);
                }
            }

            if (v_.size() <=  x.size()) {
                coeff_[i] = GeneralLinearLeastSquares(x, y, v_).coefficients();
            }
            else {
            // if number of itm paths is smaller then the number of
            // calibration functions -> never exercise
                QL_TRACE("Not enough itm paths: default decision is NEVER");
                coeff_[i] = Array(0);
            }

            /* attempt to avoid static arbitrage given by always or never exercising.

               always is absolute: regardless of the lowerBoundContinuationValue_ (this could be changed)
               but it still honours "canExercise"
             */
            Real sumOptimized = 0.0;
            Real sumNoExercise = 0.0;
            Real sumAlwaysExercise = 0.0; // always, if allowed

            for (Size j = 0, k = 0; j < n; ++j) {
                sumNoExercise += prices[j];
                lsExercise[j] = false;

                const bool canExercise = !paths_[j].states[i].empty();
                if (canExercise) {
                    sumAlwaysExercise += exercise[j];
                    if (!coeff_[i].empty() && exercise[j] > lowerBounds_[i + 1]) {
                        Real continuationValue = 0.0;
                        for (Size l = 0; l < v_.size(); ++l) {
                            continuationValue += coeff_[i][l] * v_[l](x[k]);
                        }
                        
                        if (continuationValue < exercise[j]) {
                            lsExercise[j] = true;
                        }
                        ++k;
                    }
                }
                else {
                    sumAlwaysExercise += prices[j];
                }

                sumOptimized += lsExercise[j] ? exercise[j] : prices[j];
            }

            sumOptimized /= n;
            sumNoExercise /= n;
            sumAlwaysExercise /= n;

            QL_TRACE(   "Time index: " << i 
                     << ", LowerBound: " << lowerBounds_[i + 1] 
                     << ", Optimum: " << sumOptimized 
                     << ", Continuation: " << sumNoExercise 
                     << ", Termination: " << sumAlwaysExercise);

            if (  sumOptimized >= sumNoExercise 
                && sumOptimized >= sumAlwaysExercise) {
                
                QL_TRACE("Accepted LS decision");
                for (Size j = 0; j < n; ++j) {
                    // lsExercise already contains "canExercise"
                    prices[j] = lsExercise[j] ? exercise[j] : prices[j];
                }
            }
            else if (sumAlwaysExercise > sumNoExercise) {
                QL_TRACE("Overridden bad LS decision: ALWAYS");
                for (Size j = 0; j < n; ++j) {
                    const bool canExercise = !paths_[j].states[i].empty();
                    prices[j] = canExercise ? exercise[j] : prices[j];
                }
                // special value to indicate always exercise
                coeff_[i] = Array(v_.size() + 1); 
            }
            else {
                QL_TRACE("Overridden bad LS decision: NEVER");
                // prices already contain the continuation value
                // special value to indicate never exercise
                coeff_[i] = Array(0); 
            }

            // then we add in any case the payment at time t
            // which is made even if cancellation happens at t
            for (Size j = 0; j < n; ++j) {
                const Real payoff = paths_[j].payments[i];
                prices[j] += payoff;
            }

            lowerBounds_[i] = *std::min_element(prices.begin(), prices.end());
        }

        // remove calibration paths
        paths_.clear();
        // entering the calculation phase
        calibrationPhase_ = false;
    }
}
]]></document_content>
  </document>
  <document index="411">
    <source>mcbasket/longstaffschwartzmultipathpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_longstaff_schwartz_multi_path_pricer_hpp
#define quantlib_longstaff_schwartz_multi_path_pricer_hpp

#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/montecarlo/pathpricer.hpp>
#include <ql/methods/montecarlo/multipath.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/experimental/mcbasket/pathpayoff.hpp>
#include <ql/functional.hpp>
#include <memory>

namespace QuantLib {

    //! Longstaff-Schwarz path pricer for early exercise options
    /*! References:

        Francis Longstaff, Eduardo Schwartz, 2001. Valuing American Options
        by Simulation: A Simple Least-Squares Approach, The Review of
        Financial Studies, Volume 14, No. 1, 113-147

        \ingroup mcarlo

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    class LongstaffSchwartzMultiPathPricer : public PathPricer<MultiPath> {
      public:
        LongstaffSchwartzMultiPathPricer(const ext::shared_ptr<PathPayoff>&,
                                         const std::vector<Size>&,
                                         std::vector<Handle<YieldTermStructure> >,
                                         Array,
                                         Size,
                                         LsmBasisSystem::PolynomType);

        Real operator()(const MultiPath& multiPath) const override;
        virtual void calibrate();

      protected:
        struct PathInfo {
            explicit PathInfo(Size numberOfTimes);

            Size pathLength() const;

            Array                   payments;
            Array                   exercises;
            std::vector<Array>      states;
        };

        PathInfo transformPath(const MultiPath& path) const;

        bool  calibrationPhase_;

        const ext::shared_ptr<PathPayoff> payoff_;

        std::unique_ptr<Array[]> coeff_;
        std::unique_ptr<Real[]> lowerBounds_;

        const std::vector<Size> timePositions_;
        const std::vector<Handle<YieldTermStructure> > forwardTermStructures_;
        const Array dF_;

        mutable std::vector<PathInfo> paths_;
        const std::vector<ext::function<Real(Array)> > v_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="412">
    <source>mcbasket/mcamericanpathengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_american_path_montecarlo_engine_hpp
#define quantlib_american_path_montecarlo_engine_hpp

#include <ql/experimental/mcbasket/longstaffschwartzmultipathpricer.hpp>
#include <ql/experimental/mcbasket/mclongstaffschwartzpathengine.hpp>
#include <ql/experimental/mcbasket/pathmultiassetoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/termstructures/yield/impliedtermstructure.hpp>
#include <utility>

namespace QuantLib {

    //! least-square Monte Carlo engine
    /*! \warning This method is intrinsically weak for out-of-the-money
                 options.

        \ingroup basketengines
    */
    template <class RNG = PseudoRandom>
    class MCAmericanPathEngine
        : public MCLongstaffSchwartzPathEngine<
                            PathMultiAssetOption::engine,MultiVariate,RNG> {
      public:
        MCAmericanPathEngine(const ext::shared_ptr<StochasticProcessArray>&,
                               Size timeSteps,
                               Size timeStepsPerYear,
                               bool brownianBridge,
                               bool antitheticVariate,
                               bool controlVariate,
                               Size requiredSamples,
                               Real requiredTolerance,
                               Size maxSamples,
                               BigNatural seed,
                               Size nCalibrationSamples = Null<Size>());
      protected:
        ext::shared_ptr<LongstaffSchwartzMultiPathPricer>
                                                      lsmPathPricer() const;
    };


    //! Monte Carlo American basket-option engine factory
    template <class RNG = PseudoRandom>
    class MakeMCAmericanPathEngine {
      public:
        explicit MakeMCAmericanPathEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCAmericanPathEngine& withSteps(Size steps);
        MakeMCAmericanPathEngine& withStepsPerYear(Size steps);
        MakeMCAmericanPathEngine& withBrownianBridge(bool b = true);
        MakeMCAmericanPathEngine& withAntitheticVariate(bool b = true);
        MakeMCAmericanPathEngine& withControlVariate(bool b = true);
        MakeMCAmericanPathEngine& withSamples(Size samples);
        MakeMCAmericanPathEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCAmericanPathEngine& withMaxSamples(Size samples);
        MakeMCAmericanPathEngine& withSeed(BigNatural seed);
        MakeMCAmericanPathEngine& withCalibrationSamples(Size samples);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_, controlVariate_;
        Size steps_, stepsPerYear_, samples_, maxSamples_, calibrationSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    template <class RNG> inline
    MCAmericanPathEngine<RNG>::MCAmericanPathEngine(
                   const ext::shared_ptr<StochasticProcessArray>& processes,
                   Size timeSteps,
                   Size timeStepsPerYear,
                   bool brownianBridge,
                   bool antitheticVariate,
                   bool controlVariate,
                   Size requiredSamples,
                   Real requiredTolerance,
                   Size maxSamples,
                   BigNatural seed,
                   Size nCalibrationSamples)
        : MCLongstaffSchwartzPathEngine<PathMultiAssetOption::engine,
                                    MultiVariate,RNG>(processes,
                                                      timeSteps,
                                                      timeStepsPerYear,
                                                      brownianBridge,
                                                      antitheticVariate,
                                                      controlVariate,
                                                      requiredSamples,
                                                      requiredTolerance,
                                                      maxSamples,
                                                      seed,
                                                      nCalibrationSamples) {}

    template <class RNG>
    inline ext::shared_ptr<LongstaffSchwartzMultiPathPricer>
    MCAmericanPathEngine<RNG>::lsmPathPricer() const {

        ext::shared_ptr<StochasticProcessArray> processArray =
            ext::dynamic_pointer_cast<StochasticProcessArray>(this->process_);
        QL_REQUIRE(processArray && processArray->size()>0,
                   "Stochastic process array required");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
               processArray->process(0));
        QL_REQUIRE(process, "generalized Black-Scholes process required");

        const TimeGrid theTimeGrid = this->timeGrid();

        const std::vector<Time> & times = theTimeGrid.mandatoryTimes();
        const Size numberOfTimes = times.size();

        const std::vector<Date> & fixings = this->arguments_.fixingDates;

        QL_REQUIRE(fixings.size() == numberOfTimes, "Invalid dates/times");

        std::vector<Size> timePositions(numberOfTimes);
        Array discountFactors(numberOfTimes);
        std::vector<Handle<YieldTermStructure> > forwardTermStructures(numberOfTimes);

        const Handle<YieldTermStructure> & riskFreeRate = process->riskFreeRate();

        for (Size i = 0; i < numberOfTimes; ++i) {
            timePositions[i] = theTimeGrid.index(times[i]);
            discountFactors[i] = riskFreeRate->discount(times[i]);
            forwardTermStructures[i] = Handle<YieldTermStructure>(
                ext::make_shared<ImpliedTermStructure>(riskFreeRate,
                                                         fixings[i]));
        }

        const Size polynomialOrder = 2;
        const LsmBasisSystem::PolynomType polynomType = LsmBasisSystem::Monomial;

        return ext::make_shared<LongstaffSchwartzMultiPathPricer> (
            this->arguments_.payoff,
                                                 timePositions,
                                                 forwardTermStructures,
                                                 discountFactors,
                                                 polynomialOrder,
                                                 polynomType);
    }


    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>::MakeMCAmericanPathEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      controlVariate_(false), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), calibrationSamples_(Null<Size>()),
      tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanPathEngine<RNG>&
    MakeMCAmericanPathEngine<RNG>::withCalibrationSamples(Size samples) {
        calibrationSamples_ = samples;
        return *this;
    }

    template <class RNG>
    inline
    MakeMCAmericanPathEngine<RNG>::operator
    ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCAmericanPathEngine<RNG>(process_,
                                        steps_,
                                        stepsPerYear_,
                                        brownianBridge_,
                                        antithetic_,
                                        controlVariate_,
                                        samples_,
                                        tolerance_,
                                        maxSamples_,
                                        seed_,
                                        calibrationSamples_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="413">
    <source>mcbasket/mclongstaffschwartzpathengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_mc_longstaff_schwartz_path_engine_hpp
#define quantlib_mc_longstaff_schwartz_path_engine_hpp

#include <ql/experimental/mcbasket/longstaffschwartzmultipathpricer.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <utility>

namespace QuantLib {

    //! Longstaff-Schwarz Monte Carlo engine for early exercise options
    /*! References:

        Francis Longstaff, Eduardo Schwartz, 2001. Valuing American Options
        by Simulation: A Simple Least-Squares Approach, The Review of
        Financial Studies, Volume 14, No. 1, 113-147

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    template <class GenericEngine, template <class> class MC,
              class RNG, class S = Statistics>
    class MCLongstaffSchwartzPathEngine : public GenericEngine,
                                      public McSimulation<MC,RNG,S> {
      public:
        typedef typename MC<RNG>::path_type path_type;
        typedef typename McSimulation<MC,RNG,S>::stats_type
            stats_type;
        typedef typename McSimulation<MC,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MC,RNG,S>::path_generator_type
            path_generator_type;

        MCLongstaffSchwartzPathEngine(ext::shared_ptr<StochasticProcess> process,
                                      Size timeSteps,
                                      Size timeStepsPerYear,
                                      bool brownianBridge,
                                      bool antitheticVariate,
                                      bool controlVariate,
                                      Size requiredSamples,
                                      Real requiredTolerance,
                                      Size maxSamples,
                                      BigNatural seed,
                                      Size nCalibrationSamples = Null<Size>());

        void calculate() const;

      protected:
        virtual ext::shared_ptr<LongstaffSchwartzMultiPathPricer> 
                                                    lsmPathPricer() const = 0;

        TimeGrid timeGrid() const;
        ext::shared_ptr<path_pricer_type> pathPricer() const;
        ext::shared_ptr<path_generator_type> pathGenerator() const;

        ext::shared_ptr<StochasticProcess> process_;
        const Size timeSteps_;
        const Size timeStepsPerYear_;
        const bool brownianBridge_;
        const Size requiredSamples_;
        const Real requiredTolerance_;
        const Size maxSamples_;
        const Size seed_;
        const Size nCalibrationSamples_;

        mutable ext::shared_ptr<LongstaffSchwartzMultiPathPricer> pathPricer_;
    };

    template <class GenericEngine, template <class> class MC, class RNG, class S>
    inline MCLongstaffSchwartzPathEngine<GenericEngine, MC, RNG, S>::MCLongstaffSchwartzPathEngine(
        ext::shared_ptr<StochasticProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        bool controlVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed,
        Size nCalibrationSamples)
    : McSimulation<MC, RNG, S>(antitheticVariate, controlVariate), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), brownianBridge_(brownianBridge),
      requiredSamples_(requiredSamples), requiredTolerance_(requiredTolerance),
      maxSamples_(maxSamples), seed_(seed),
      nCalibrationSamples_((nCalibrationSamples == Null<Size>()) ? 2048 : nCalibrationSamples) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " 
                    << timeStepsPerYear << " not allowed");
        this->registerWith(process_);
    }

    template <class GenericEngine, template <class> class MC,
              class RNG, class S>
    inline
    ext::shared_ptr<typename
        MCLongstaffSchwartzPathEngine<GenericEngine,MC,RNG,S>::path_pricer_type>
        MCLongstaffSchwartzPathEngine<GenericEngine,MC,RNG,S>::pathPricer() 
        const {

        QL_REQUIRE(pathPricer_, "path pricer unknown");
        return pathPricer_;
    }

    template <class GenericEngine, template <class> class MC,
              class RNG, class S>
    inline
    void MCLongstaffSchwartzPathEngine<GenericEngine,MC,RNG,S>::calculate() 
    const {
        pathPricer_ = this->lsmPathPricer();
        this->mcModel_ = ext::shared_ptr<MonteCarloModel<MC,RNG,S> >(
                          new MonteCarloModel<MC,RNG,S>
                              (pathGenerator(), pathPricer_,
                               stats_type(), this->antitheticVariate_));

        this->mcModel_->addSamples(nCalibrationSamples_);
        this->pathPricer_->calibrate();

        McSimulation<MC,RNG,S>::calculate(requiredTolerance_,
                                          requiredSamples_,
                                          maxSamples_);
        this->results_.value = this->mcModel_->sampleAccumulator().mean();
        if (RNG::allowsErrorEstimate) {
            this->results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }
    }

    template <class GenericEngine, template <class> class MC,
              class RNG, class S>
    inline
    TimeGrid MCLongstaffSchwartzPathEngine<GenericEngine,MC,RNG,S>::timeGrid()
        const {
        const std::vector<Date> & fixings = this->arguments_.fixingDates;
        const Size numberOfFixings = fixings.size();

        std::vector<Time> fixingTimes(numberOfFixings);
        for (Size i = 0; i < numberOfFixings; ++i) {
            fixingTimes[i] =
                this->process_->time(fixings[i]);
        }

        const Size numberOfTimeSteps = timeSteps_ != Null<Size>() ? timeSteps_ : timeStepsPerYear_ * fixingTimes.back();

        return TimeGrid(fixingTimes.begin(), fixingTimes.end(), numberOfTimeSteps);
     }

    template <class GenericEngine, template <class> class MC,
              class RNG, class S>
    inline
    ext::shared_ptr<typename
    MCLongstaffSchwartzPathEngine<GenericEngine,MC,RNG,S>::path_generator_type>
    MCLongstaffSchwartzPathEngine<GenericEngine,MC,RNG,S>::pathGenerator() 
    const {

        Size dimensions = process_->factors();
        TimeGrid grid = this->timeGrid();
        typename RNG::rsg_type generator =
            RNG::make_sequence_generator(dimensions*(grid.size()-1),seed_);
        return ext::shared_ptr<path_generator_type>(
                   new path_generator_type(process_,
                                           grid, generator, brownianBridge_));
    }
}


#endif
]]></document_content>
  </document>
  <document index="414">
    <source>mcbasket/mcpathbasketengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/mcbasket/mcpathbasketengine.hpp>
#include <utility>

namespace QuantLib {

    EuropeanPathMultiPathPricer::EuropeanPathMultiPathPricer(
        ext::shared_ptr<PathPayoff>& payoff,
        std::vector<Size> timePositions,
        std::vector<Handle<YieldTermStructure> > forwardTermStructures,
        Array discounts)
    : payoff_(payoff), timePositions_(std::move(timePositions)),
      forwardTermStructures_(std::move(forwardTermStructures)), discounts_(std::move(discounts)) {}

    Real EuropeanPathMultiPathPricer::operator()(const MultiPath& multiPath)
                                                                       const {

        Size n = multiPath.pathSize();
        QL_REQUIRE(n > 0, "the path cannot be empty");

        Size numberOfAssets = multiPath.assetNumber();
        QL_REQUIRE(numberOfAssets > 0, "there must be some paths");

        const Size numberOfTimes = timePositions_.size();

        Matrix path(numberOfAssets, numberOfTimes, Null<Real>());

        for (Size i = 0; i < numberOfTimes; ++i) {
            const Size pos = timePositions_[i];
            for (Size j = 0; j < numberOfAssets; ++j)
                path[j][i] = multiPath[j][pos];
        }

        Array values(numberOfTimes, 0.0);

        // ignored
        Array exercises;
        std::vector<Array> states;

        payoff_->value(path, forwardTermStructures_, values, exercises, states);

        // in this engine we ignore early exercise

        Real discountedPayoff = DotProduct(values, discounts_);

        return discountedPayoff;
    }

}

]]></document_content>
  </document>
  <document index="415">
    <source>mcbasket/mcpathbasketengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcpathbasketengine.hpp
    \brief Path-dependent European basket MC engine
*/

#ifndef quantlib_mc_path_basket_engine_hpp
#define quantlib_mc_path_basket_engine_hpp

#include <ql/experimental/mcbasket/pathmultiassetoption.hpp>
#include <ql/experimental/mcbasket/pathpayoff.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/termstructures/yield/impliedtermstructure.hpp>
#include <ql/timegrid.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for path dependent basket options using
    //  Monte Carlo simulation
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCPathBasketEngine  : public PathMultiAssetOption::engine,
                                public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
                                                          path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
                                                             path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
                                                                   stats_type;
        // constructor
        MCPathBasketEngine(ext::shared_ptr<StochasticProcessArray>,
                           Size timeSteps,
                           Size timeStepsPerYear,
                           bool brownianBridge,
                           bool antitheticVariate,
                           bool controlVariate,
                           Size requiredSamples,
                           Real requiredTolerance,
                           Size maxSamples,
                           BigNatural seed);

        void calculate() const override {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:

        // McSimulation implementation
        TimeGrid timeGrid() const;
        ext::shared_ptr<path_generator_type> pathGenerator() const;
        ext::shared_ptr<path_pricer_type> pathPricer() const;

        // data members
        ext::shared_ptr<StochasticProcessArray> process_;
        Size timeSteps_;
        Size timeStepsPerYear_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    class EuropeanPathMultiPathPricer : public PathPricer<MultiPath> {
      public:
        EuropeanPathMultiPathPricer(ext::shared_ptr<PathPayoff>& payoff,
                                    std::vector<Size> timePositions,
                                    std::vector<Handle<YieldTermStructure> > forwardTermStructures,
                                    Array discounts);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        ext::shared_ptr<PathPayoff> payoff_;
        std::vector<Size> timePositions_;
        std::vector<Handle<YieldTermStructure> > forwardTermStructures_;
        Array discounts_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCPathBasketEngine<RNG, S>::MCPathBasketEngine(
        ext::shared_ptr<StochasticProcessArray> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        bool controlVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, controlVariate),
      process_(std::move(process)), timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, "
                   << timeStepsPerYear << " not allowed");
        this->registerWith(process_);
    }


    template<class RNG, class S>
    inline
    ext::shared_ptr<typename MCPathBasketEngine<RNG,S>::path_generator_type>
    MCPathBasketEngine<RNG,S>::pathGenerator() const {

        ext::shared_ptr<PathPayoff> payoff = arguments_.payoff;
        QL_REQUIRE(payoff, "non-basket payoff given");

        Size numAssets = process_->size();

        TimeGrid grid = timeGrid();

        typename RNG::rsg_type gen =
            RNG::make_sequence_generator(numAssets * (grid.size() - 1), seed_);

        return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_,
                                                 grid, gen, brownianBridge_));
    }

    template <class RNG, class S>
    inline TimeGrid MCPathBasketEngine<RNG,S>::timeGrid() const {
        const std::vector<Date> & fixings = this->arguments_.fixingDates;
        const Size numberOfFixings = fixings.size();

        std::vector<Time> fixingTimes(numberOfFixings);
        for (Size i = 0; i < numberOfFixings; ++i) {
            fixingTimes[i] =
                this->process_->time(fixings[i]);
        }

        const Size numberOfTimeSteps = timeSteps_ != Null<Size>() ? timeSteps_ : timeStepsPerYear_ * fixingTimes.back();

        return TimeGrid(fixingTimes.begin(), fixingTimes.end(), numberOfTimeSteps);
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCPathBasketEngine<RNG,S>::path_pricer_type>
    MCPathBasketEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PathPayoff> payoff = arguments_.payoff;
        QL_REQUIRE(payoff, "non-basket payoff given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                       process_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        const TimeGrid theTimeGrid = timeGrid();

        const std::vector<Time> & times = theTimeGrid.mandatoryTimes();
        const Size numberOfTimes = times.size();

        const std::vector<Date> & fixings = this->arguments_.fixingDates;

        QL_REQUIRE(fixings.size() == numberOfTimes, "Invalid dates/times");

        std::vector<Size> timePositions(numberOfTimes);
        Array discountFactors(numberOfTimes);
        std::vector<Handle<YieldTermStructure> > forwardTermStructures(numberOfTimes);

        const Handle<YieldTermStructure> & riskFreeRate = process->riskFreeRate();

        for (Size i = 0; i < numberOfTimes; ++i) {
            timePositions[i] = theTimeGrid.index(times[i]);
            discountFactors[i] = riskFreeRate->discount(times[i]);
            forwardTermStructures[i] = Handle<YieldTermStructure>(
                ext::make_shared<ImpliedTermStructure>(riskFreeRate,
                                                         fixings[i]));
        }

        return ext::shared_ptr<
            typename MCPathBasketEngine<RNG,S>::path_pricer_type>(
                        new EuropeanPathMultiPathPricer(payoff, timePositions,
                                                        forwardTermStructures,
                                                        discountFactors));
    }


    //! Monte Carlo Path Basket engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCPathBasketEngine {
      public:
        explicit MakeMCPathBasketEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCPathBasketEngine& withSteps(Size steps);
        MakeMCPathBasketEngine& withStepsPerYear(Size steps);
        MakeMCPathBasketEngine& withBrownianBridge(bool b = true);
        MakeMCPathBasketEngine& withSamples(Size samples);
        MakeMCPathBasketEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCPathBasketEngine& withMaxSamples(Size samples);
        MakeMCPathBasketEngine& withSeed(BigNatural seed);
        MakeMCPathBasketEngine& withAntitheticVariate(bool b = true);
        MakeMCPathBasketEngine& withControlVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool antithetic_, controlVariate_;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG, S>::MakeMCPathBasketEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), antithetic_(false), controlVariate_(false),
      steps_(Null<Size>()), stepsPerYear_(Null<Size>()), samples_(Null<Size>()),
      maxSamples_(Null<Size>()), tolerance_(Null<Real>()), brownianBridge_(false), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPathBasketEngine<RNG,S>&
    MakeMCPathBasketEngine<RNG,S>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCPathBasketEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                       const {
        return ext::shared_ptr<PricingEngine>(new
            MCPathBasketEngine<RNG,S>(process_,
                                      steps_,
                                      stepsPerYear_,
                                      brownianBridge_,
                                      antithetic_,
                                      controlVariate_,
                                      samples_,
                                      tolerance_,
                                      maxSamples_,
                                      seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="416">
    <source>mcbasket/pathmultiassetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/mcbasket/pathmultiassetoption.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    PathMultiAssetOption::PathMultiAssetOption(
                            const ext::shared_ptr<PricingEngine>& engine) {
        if (engine != nullptr)
            setPricingEngine(engine);
    }

    bool PathMultiAssetOption::isExpired() const {
        return detail::simple_event(fixingDates().back()).hasOccurred();
    }

    void PathMultiAssetOption::setupExpired() const {
        NPV_ = 0.0;
    }

    void PathMultiAssetOption::setupArguments(PricingEngine::arguments* args)
                                                                       const {
        auto* arguments = dynamic_cast<PathMultiAssetOption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff            = pathPayoff();
        arguments->fixingDates       = fixingDates();
    }

    void PathMultiAssetOption::arguments::validate() const {
        QL_REQUIRE(payoff,                 "no payoff given");
        QL_REQUIRE(!fixingDates.empty(), "no dates given");
    }
}

]]></document_content>
  </document>
  <document index="417">
    <source>mcbasket/pathmultiassetoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pathmultiassetoption.hpp
    \brief Option on multiple assets
*/

#ifndef quantlib_path_multiasset_option_hpp
#define quantlib_path_multiasset_option_hpp

#include <ql/instrument.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/math/matrix.hpp>
#include <ql/experimental/mcbasket/pathpayoff.hpp>

namespace QuantLib {

    //! Base class for path-dependent options on multiple assets
    class PathMultiAssetOption : public Instrument {
      public:
        explicit PathMultiAssetOption(
                        const ext::shared_ptr<PricingEngine>& engine
                                        = ext::shared_ptr<PricingEngine>());

        //! \name Instrument interface
        //@{
        class arguments;
        class results;
        class engine;

        bool isExpired() const override;

        void setupArguments(PricingEngine::arguments*) const override;

        virtual ext::shared_ptr<PathPayoff> pathPayoff()  const = 0;
        virtual std::vector<Date>             fixingDates() const = 0;

      protected:
        void setupExpired() const override;
    };

    //! %Arguments for multi-asset option calculation
    class PathMultiAssetOption::arguments
        : public virtual PricingEngine::arguments {
      public:
        arguments() = default;
        void validate() const override;

        ext::shared_ptr<PathPayoff>        payoff;
        std::vector<Date>                    fixingDates;
    };

    //! %Results from multi-asset option calculation
    class PathMultiAssetOption::results : public Instrument::results {
      public:
        void reset() override { Instrument::results::reset(); }
    };

    class PathMultiAssetOption::engine
        : public GenericEngine<PathMultiAssetOption::arguments,
                               PathMultiAssetOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="418">
    <source>mcbasket/pathpayoff.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andrea Odetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pathpayoff.hpp
    \brief Option payoff classes
*/

#ifndef quantlib_path_payoff_hpp
#define quantlib_path_payoff_hpp

#include <ql/math/matrix.hpp>
#include <ql/patterns/visitor.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/handle.hpp>
#include <functional>

namespace QuantLib {

    //! Abstract base class for path-dependent option payoffs
    class PathPayoff {
      public:
        virtual ~PathPayoff() = default;
        //! \name Payoff interface
        //@{
        /*! \warning This method is used for output and comparison between
                payoffs. It is <b>not</b> meant to be used for writing
                switch-on-type code.
        */
        virtual std::string name() const = 0;
        virtual std::string description() const = 0;


        /*
          This function returns all the payoff and early termination payments 
          for a single path. If the option is cancelled at time i, all payments
          on and before i are taken into account + the value of exercises[i].
          i.e.: cancellation at i does not cancel payments[i]!

          forwardTermStructures contains the yield term structure at each fixing date

          leave states empty to signal exercise is not possible
          in that case, exercises[] will not be accessed.
         */

        virtual void value(const Matrix       & path, 
                           const std::vector<Handle<YieldTermStructure> > & forwardTermStructures,
                           Array              & payments, 
                           Array              & exercises, 
                           std::vector<Array> & states) const = 0;

        /*
          Dimension of the basis functions.
          It must be the same as the size of every element of states in value().
         */

        virtual Size basisSystemDimension() const = 0;

        //@}
        //! \name Visitability
        //@{
        virtual void accept(AcyclicVisitor&);
        //@}
    };


    // inline definitions

    inline void PathPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<PathPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a path-payoff visitor");
    }
}


#endif
]]></document_content>
  </document>
  <document index="419">
    <source>models/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    hestonslvfdmmodel.hpp \
    hestonslvmcmodel.hpp \
    normalclvmodel.hpp \
    squarerootclvmodel.hpp

cpp_files = \
    hestonslvfdmmodel.cpp \
    hestonslvmcmodel.cpp \
    normalclvmodel.cpp \
    squarerootclvmodel.cpp

if UNITY_BUILD

nodist_libModels_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libModels_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libModels.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="420">
    <source>models/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/models/hestonslvfdmmodel.hpp>
#include <ql/experimental/models/hestonslvmcmodel.hpp>
#include <ql/experimental/models/normalclvmodel.hpp>
#include <ql/experimental/models/squarerootclvmodel.hpp>

]]></document_content>
  </document>
  <document index="421">
    <source>models/hestonslvfdmmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/experimental/finitedifferences/fdmhestonfwdop.hpp>
#include <ql/experimental/models/hestonslvfdmmodel.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/integrals/discreteintegrals.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/schemes/craigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/hundsdorferscheme.hpp>
#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmmesherintegral.hpp>
#include <ql/methods/finitedifferences/utilities/localvolrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/timegrid.hpp>
#include <functional>
#include <memory>
#include <utility>

namespace QuantLib {

    namespace {
        ext::shared_ptr<Fdm1dMesher> varianceMesher(
            const SquareRootProcessRNDCalculator& rnd,
            Time t0, Time t1, Size vGrid,
            Real v0, const HestonSLVFokkerPlanckFdmParams& params) {

            std::vector<ext::tuple<Real, Real, bool> > cPoints;

            const Real v0Density = params.v0Density;
            const Real upperBoundDensity = params.vUpperBoundDensity;
            const Real lowerBoundDensity = params.vLowerBoundDensity;

            Real lowerBound = Null<Real>(), upperBound = -Null<Real>();

            for (Size i=0; i <= 10; ++i) {
                const Time t = t0 + i/10.0*(t1-t0);
                lowerBound = std::min(
                    lowerBound, rnd.invcdf(params.vLowerEps, t));
                upperBound = std::max(
                    upperBound, rnd.invcdf(1.0-params.vUpperEps, t));
            }

            lowerBound = std::max(lowerBound, params.vMin);
            switch (params.trafoType) {
                case FdmSquareRootFwdOp::Log:
                  {
                    lowerBound = std::log(lowerBound);
                    upperBound = std::log(upperBound);

                    const Real v0Center = std::log(v0);

                    cPoints = {
                        {lowerBound, lowerBoundDensity, false},
                        {v0Center, v0Density, true},
                        {upperBound, upperBoundDensity, false}
                    };

                    return ext::make_shared<Concentrating1dMesher>(
                        lowerBound, upperBound, vGrid, cPoints, 1e-8);
                  }
                break;
                case FdmSquareRootFwdOp::Plain:
                  {
                      const Real v0Center = v0;

                      cPoints = {
                          {lowerBound, lowerBoundDensity, false},
                          {v0Center, v0Density, true},
                          {upperBound, upperBoundDensity, false}
                      };

                      return ext::make_shared<Concentrating1dMesher>(
                          lowerBound, upperBound, vGrid, cPoints, 1e-8);
                  }
                break;
                case FdmSquareRootFwdOp::Power:
                {
                    const Real v0Center = v0;

                    cPoints = {
                        {lowerBound, lowerBoundDensity, false},
                        {v0Center, v0Density, true},
                        {upperBound, upperBoundDensity, false}
                    };

                    return ext::make_shared<Concentrating1dMesher>(
                        lowerBound, upperBound, vGrid, cPoints, 1e-8);
                }
                break;
                default:
                    QL_FAIL("transformation type is not implemented");
            }
        }

        Real integratePDF(const Array& p,
                          const ext::shared_ptr<FdmMesherComposite>& mesher,
                          FdmSquareRootFwdOp::TransformationType trafoType,
                          Real alpha) {

            if (trafoType != FdmSquareRootFwdOp::Power) {
                return FdmMesherIntegral(
                        mesher, DiscreteSimpsonIntegral()).integrate(p);
            }
            else {
                Array tp(p.size());
                const FdmLinearOpIterator end = mesher->layout()->end();
                for (FdmLinearOpIterator iter = mesher->layout()->begin();
                    iter != end; ++iter) {
                    const Size idx = iter.index();
                    const Real nu = mesher->location(iter, 1);

                    tp[idx] = p[idx]*std::pow(nu, alpha-1);
                }

                return FdmMesherIntegral(
                        mesher, DiscreteSimpsonIntegral()).integrate(tp);
            }
        }


        Disposable<Array> rescalePDF(
            const Array& p,
            const ext::shared_ptr<FdmMesherComposite>& mesher,
            FdmSquareRootFwdOp::TransformationType trafoType, Real alpha) {

            Array retVal = p/integratePDF(p, mesher, trafoType, alpha);

            return retVal;
        }


        template <class Interpolator>
        Disposable<Array> reshapePDF(
            const Array& p,
            const ext::shared_ptr<FdmMesherComposite>& oldMesher,
            const ext::shared_ptr<FdmMesherComposite>& newMesher,
            const Interpolator& interp = Interpolator()) {

            const ext::shared_ptr<FdmLinearOpLayout> oldLayout
                = oldMesher->layout();
            const ext::shared_ptr<FdmLinearOpLayout> newLayout
                = newMesher->layout();

            QL_REQUIRE(   oldLayout->size() == newLayout->size()
                       && oldLayout->size() == p.size(),
                       "inconsistent mesher or vector size given");

            Matrix m(oldLayout->dim()[1], oldLayout->dim()[0]);
            for (Size i=0; i < m.rows(); ++i) {
                std::copy(p.begin() + i*m.columns(),
                          p.begin() + (i+1)*m.columns(), m.row_begin(i));
            }
            const Interpolation2D interpol = interp.interpolate(
                oldMesher->getFdm1dMeshers()[0]->locations().begin(),
                oldMesher->getFdm1dMeshers()[0]->locations().end(),
                oldMesher->getFdm1dMeshers()[1]->locations().begin(),
                oldMesher->getFdm1dMeshers()[1]->locations().end(), m);

            Array pNew(p.size());
            const FdmLinearOpIterator endIter = newLayout->end();
            for (FdmLinearOpIterator iter = newLayout->begin();
                iter != endIter; ++iter) {
                const Real x = newMesher->location(iter, 0);
                const Real v = newMesher->location(iter, 1);

                if (   x > interpol.xMax() || x < interpol.xMin()
                    || v > interpol.yMax() || v < interpol.yMin() ) {
                    pNew[iter.index()] = 0;
                }
                else {
                    pNew[iter.index()] = interpol(x, v);
                }
            }

            return pNew;
        }

        class FdmScheme {
          public:
            virtual ~FdmScheme() = default;
            virtual void step(Array& a, Time t) = 0;
            virtual void setStep(Time dt) = 0;
        };

        template <class T>
        class FdmSchemeWrapper : public FdmScheme {
          public:
            explicit FdmSchemeWrapper(T* scheme)
            : scheme_(scheme) { }

            void step(Array& a, Time t) override { scheme_->step(a, t); }
            void setStep(Time dt) override { scheme_->setStep(dt); }

          private:
            const std::unique_ptr<T> scheme_;
        };

        ext::shared_ptr<FdmScheme> fdmSchemeFactory(
            const FdmSchemeDesc desc,
            const ext::shared_ptr<FdmLinearOpComposite>& op) {

            switch (desc.type) {
              case FdmSchemeDesc::HundsdorferType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<HundsdorferScheme>(
                          new HundsdorferScheme(desc.theta, desc.mu, op)));
              case FdmSchemeDesc::DouglasType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<DouglasScheme>(
                          new DouglasScheme(desc.theta, op)));
              case FdmSchemeDesc::CraigSneydType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<CraigSneydScheme>(
                          new CraigSneydScheme(desc.theta, desc.mu, op)));
              case FdmSchemeDesc::ModifiedCraigSneydType:
                  return ext::shared_ptr<FdmScheme>(
                     new FdmSchemeWrapper<ModifiedCraigSneydScheme>(
                          new ModifiedCraigSneydScheme(
                              desc.theta, desc.mu, op)));
              case FdmSchemeDesc::ImplicitEulerType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<ImplicitEulerScheme>(
                          new ImplicitEulerScheme(op)));
              case FdmSchemeDesc::ExplicitEulerType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<ExplicitEulerScheme>(
                          new ExplicitEulerScheme(op)));
              default:
                  QL_FAIL("Unknown scheme type");
            }
        }
    }

    HestonSLVFDMModel::HestonSLVFDMModel(Handle<LocalVolTermStructure> localVol,
                                         Handle<HestonModel> hestonModel,
                                         const Date& endDate,
                                         HestonSLVFokkerPlanckFdmParams params,
                                         const bool logging,
                                         std::vector<Date> mandatoryDates,
                                         const Real mixingFactor)
    : localVol_(std::move(localVol)), hestonModel_(std::move(hestonModel)), endDate_(endDate),
      params_(std::move(params)), mandatoryDates_(std::move(mandatoryDates)),
      mixingFactor_(mixingFactor), logging_(logging) {

        registerWith(localVol_);
        registerWith(hestonModel_);
    }

    ext::shared_ptr<HestonProcess> HestonSLVFDMModel::hestonProcess() const {
        return hestonModel_->process();
    }

    ext::shared_ptr<LocalVolTermStructure> HestonSLVFDMModel::localVol() const {
        return localVol_.currentLink();
    }

    ext::shared_ptr<LocalVolTermStructure>
    HestonSLVFDMModel::leverageFunction() const {
        calculate();

        return leverageFunction_;
    }

    void HestonSLVFDMModel::performCalculations() const {
        logEntries_.clear();

        const ext::shared_ptr<HestonProcess> hestonProcess
            = hestonModel_->process();
        const ext::shared_ptr<Quote> spot
            = hestonProcess->s0().currentLink();
        const ext::shared_ptr<YieldTermStructure> rTS
            = hestonProcess->riskFreeRate().currentLink();
        const ext::shared_ptr<YieldTermStructure> qTS
            = hestonProcess->dividendYield().currentLink();

        const Real v0    = hestonProcess->v0();
        const Real kappa = hestonProcess->kappa();
        const Real theta = hestonProcess->theta();
        const Real sigma = hestonProcess->sigma();
        const Real mixedSigma = mixingFactor_ * sigma;
        const Real alpha = 2*kappa*theta/(mixedSigma*mixedSigma);

        const Size xGrid = params_.xGrid;
        const Size vGrid = params_.vGrid;

        const DayCounter dc = rTS->dayCounter();
        const Date referenceDate = rTS->referenceDate();

        const Time T = dc.yearFraction(referenceDate, endDate_);

        QL_REQUIRE(referenceDate < endDate_,
            "reference date must be smaller than final calibration date");

        QL_REQUIRE(localVol_->maxTime() >= T,
            "final calibration maturity exceeds local volatility surface");

        // set-up exponential time step scheme
        const Time maxDt = 1.0/params_.tMaxStepsPerYear;
        const Time minDt = 1.0/params_.tMinStepsPerYear;

        Time tIdx=0.0;
        std::vector<Time> times(1, tIdx);
        times.reserve(Size(T*params_.tMinStepsPerYear));
        while (tIdx < T) {
            const Real decayFactor = std::exp(-params_.tStepNumberDecay*tIdx);
            const Time dt = maxDt*decayFactor + minDt*(1.0-decayFactor);

            times.push_back(std::min(T, tIdx+=dt));
        }

        for (auto mandatoryDate : mandatoryDates_) {
            times.push_back(dc.yearFraction(referenceDate, mandatoryDate));
        }

        const ext::shared_ptr<TimeGrid> timeGrid(
            new TimeGrid(times.begin(), times.end()));

        // build 1d meshers
        const LocalVolRNDCalculator localVolRND(
            spot, rTS, qTS, localVol_.currentLink(),
            timeGrid, xGrid,
            params_.x0Density,
            params_.localVolEpsProb,
            params_.maxIntegrationIterations);

        const std::vector<Size> rescaleSteps
            = localVolRND.rescaleTimeSteps();

        const SquareRootProcessRNDCalculator squareRootRnd(
            v0, kappa, theta, mixedSigma);

        const FdmSquareRootFwdOp::TransformationType trafoType
          = params_.trafoType;

        std::vector<ext::shared_ptr<Fdm1dMesher> > xMesher, vMesher;
        xMesher.reserve(timeGrid->size());
        vMesher.reserve(timeGrid->size());

        xMesher.push_back(localVolRND.mesher(0.0));
        vMesher.push_back(ext::make_shared<Predefined1dMesher>(
            std::vector<Real>(vGrid, v0)));

        Size rescaleIdx = 0;
        for (Size i=1; i < timeGrid->size(); ++i) {
            xMesher.push_back(localVolRND.mesher(timeGrid->at(i)));

            if ((rescaleIdx < rescaleSteps.size())
                && (i == rescaleSteps[rescaleIdx])) {
                ++rescaleIdx;
                vMesher.push_back(varianceMesher(squareRootRnd,
                    timeGrid->at(rescaleSteps[rescaleIdx-1]),
                    (rescaleIdx < rescaleSteps.size())
                        ? timeGrid->at(rescaleSteps[rescaleIdx])
                        : timeGrid->back(),
                    vGrid, v0, params_));
            }
            else
                vMesher.push_back(vMesher.back());
        }

        // start probability distribution
        ext::shared_ptr<FdmMesherComposite> mesher
            = ext::make_shared<FdmMesherComposite>(
                xMesher.at(1), vMesher.at(1));

        const Volatility lv0
            = localVol_->localVol(0.0, spot->value())/std::sqrt(v0);

        ext::shared_ptr<Matrix> L(new Matrix(xGrid, timeGrid->size()));

        const Real l0 = lv0;
        std::fill(L->column_begin(0),L->column_end(0), l0);
        std::fill(L->column_begin(1),L->column_end(1), l0);

        // create strikes from meshers
        std::vector<ext::shared_ptr<std::vector<Real> > > vStrikes(
            timeGrid->size());

        for (Size i=0; i < timeGrid->size(); ++i) {
            vStrikes[i] = ext::make_shared<std::vector<Real> >(xGrid);
            if (xMesher[i]->locations().front()
                  == xMesher[i]->locations().back()) {
                std::fill(vStrikes[i]->begin(), vStrikes[i]->end(),
                    std::exp(xMesher[i]->locations().front()));
            }
            else {
                std::transform(xMesher[i]->locations().begin(),
                               xMesher[i]->locations().end(),
                               vStrikes[i]->begin(),
                               static_cast<Real(*)(Real)>(std::exp));
            }
        }

        const ext::shared_ptr<FixedLocalVolSurface> leverageFct(
            new FixedLocalVolSurface(referenceDate, times, vStrikes, L, dc));

        ext::shared_ptr<FdmLinearOpComposite> hestonFwdOp(
            new FdmHestonFwdOp(mesher, hestonProcess, trafoType, leverageFct, mixingFactor_));

        Array p = FdmHestonGreensFct(mesher, hestonProcess, trafoType, lv0)
            .get(timeGrid->at(1), params_.greensAlgorithm);

        if (logging_) {
            const LogEntry entry = { timeGrid->at(1),
                ext::make_shared<Array>(p), mesher };
            logEntries_.push_back(entry);
        }

        for (Size i=2; i < times.size(); ++i) {
            const Time t = timeGrid->at(i);
            const Time dt = t - timeGrid->at(i-1);

            if (   mesher->getFdm1dMeshers()[0] != xMesher[i]
                || mesher->getFdm1dMeshers()[1] != vMesher[i]) {
                const ext::shared_ptr<FdmMesherComposite> newMesher(
                    new FdmMesherComposite(xMesher[i], vMesher[i]));

                p = reshapePDF<Bilinear>(p, mesher, newMesher);
                mesher = newMesher;

                p = rescalePDF(p, mesher, trafoType, alpha);

                hestonFwdOp = ext::shared_ptr<FdmLinearOpComposite>(
                                new FdmHestonFwdOp(mesher, hestonProcess,
                                               trafoType, leverageFct));
            }

            Array pn = p;
            const Array x(Exp(
                Array(mesher->getFdm1dMeshers()[0]->locations().begin(),
                      mesher->getFdm1dMeshers()[0]->locations().end())));
            const Array v(
                    mesher->getFdm1dMeshers()[1]->locations().begin(),
                    mesher->getFdm1dMeshers()[1]->locations().end());

            // predictor corrector steps
            for (Size r=0; r < params_.predictionCorretionSteps; ++r) {
                const FdmSchemeDesc fdmSchemeDesc
                    = (i < params_.nRannacherTimeSteps + 2)
                        ? FdmSchemeDesc::ImplicitEuler()
                        : params_.schemeDesc;

                const ext::shared_ptr<FdmScheme> fdmScheme(
                    fdmSchemeFactory(fdmSchemeDesc, hestonFwdOp));

                for (Size j=0; j < x.size(); ++j) {
                    Array pSlice(vGrid);
                    for (Size k=0; k < vGrid; ++k)
                        pSlice[k] = pn[j + k*xGrid];

                    const Real pInt = (trafoType == FdmSquareRootFwdOp::Power)
                       ? DiscreteSimpsonIntegral()(v, Pow(v, alpha-1)*pSlice)
                       : DiscreteSimpsonIntegral()(v, pSlice);

                    const Real vpInt = (trafoType == FdmSquareRootFwdOp::Log)
                      ? DiscreteSimpsonIntegral()(v, Exp(v)*pSlice)
                      : (trafoType == FdmSquareRootFwdOp::Power)
                      ? DiscreteSimpsonIntegral()(v, Pow(v, alpha)*pSlice)
                      : DiscreteSimpsonIntegral()(v, v*pSlice);

                    const Real scale = pInt/vpInt;
                    const Volatility localVol = localVol_->localVol(t, x[j]);

                    const Real l = (scale >= 0.0)
                      ? localVol*std::sqrt(scale) : 1.0;

                    (*L)[j][i] = std::min(50.0, std::max(0.001, l));

                    leverageFct->setInterpolation(Linear());
                }

                const Real sLowerBound = std::max(x.front(),
                    std::exp(localVolRND.invcdf(
                        params_.leverageFctPropEps, t)));
                const Real sUpperBound = std::min(x.back(),
                    std::exp(localVolRND.invcdf(
                        1.0-params_.leverageFctPropEps, t)));

                const Real lowerL = leverageFct->localVol(t, sLowerBound);
                const Real upperL = leverageFct->localVol(t, sUpperBound);

                for (Size j=0; j < x.size(); ++j) {
                    if (x[j] < sLowerBound)
                        std::fill(L->row_begin(j)+i,
                          std::min(L->row_begin(j)+i+1, L->row_end(j)),
                          lowerL);
                    else if (x[j] > sUpperBound)
                        std::fill(L->row_begin(j)+i,
                          std::min(L->row_begin(j)+i+1, L->row_end(j)),
                          upperL);
                    else if ((*L)[j][i] == Null<Real>())
                        QL_FAIL("internal error");
                }
                leverageFct->setInterpolation(Linear());

                pn = p;

                fdmScheme->setStep(dt);
                fdmScheme->step(pn, t);
            }
            p = pn;
            p = rescalePDF(p, mesher, trafoType, alpha);

            if (logging_) {
                const LogEntry entry
                    = { t, ext::make_shared<Array>(p), mesher };
                logEntries_.push_back(entry);
            }
        }

        leverageFunction_ = leverageFct;
    }

    const std::list<HestonSLVFDMModel::LogEntry>& HestonSLVFDMModel::logEntries()
    const {
        performCalculations();
        return logEntries_;
    }
}

]]></document_content>
  </document>
  <document index="422">
    <source>models/hestonslvfdmmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvfdmmodel.hpp
    \brief Heston stochastic local volatility model
*/

#ifndef quantlib_heston_slv_model_hpp
#define quantlib_heston_slv_model_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/experimental/finitedifferences/fdmhestongreensfct.hpp>

#include <list>

namespace QuantLib {

class SimpleQuote;
    class HestonModel;
    class LocalVolTermStructure;

    struct HestonSLVFokkerPlanckFdmParams {
        const Size xGrid, vGrid;
        const Size tMaxStepsPerYear, tMinStepsPerYear;
        const Real tStepNumberDecay;

        // Rannacher smoothing steps at the beginning
        const Size nRannacherTimeSteps;

        const Size predictionCorretionSteps;

        // local volatility forward equation
        const Real x0Density;
        const Real localVolEpsProb;
        const Size maxIntegrationIterations;

        // variance mesher definition
        const Real vLowerEps, vUpperEps, vMin;
        const Real v0Density, vLowerBoundDensity, vUpperBoundDensity;

        // do not calculate leverage function if prob is smaller than eps
        const Real leverageFctPropEps;

        // algorithm to get to the start configuration at time point one
        const FdmHestonGreensFct::Algorithm greensAlgorithm;
        const FdmSquareRootFwdOp::TransformationType trafoType;

        // define finite difference scheme
        const FdmSchemeDesc schemeDesc;
    };

    class HestonSLVFDMModel : public LazyObject {
      public:
        HestonSLVFDMModel(Handle<LocalVolTermStructure> localVol,
                          Handle<HestonModel> hestonModel,
                          const Date& endDate,
                          HestonSLVFokkerPlanckFdmParams params,
                          bool logging = false,
                          std::vector<Date> mandatoryDates = std::vector<Date>(),
                          Real mixingFactor = 1.0);

        ext::shared_ptr<HestonProcess> hestonProcess() const;
        ext::shared_ptr<LocalVolTermStructure> localVol() const;
        ext::shared_ptr<LocalVolTermStructure> leverageFunction() const;

        struct LogEntry {
            const Time t;
            const ext::shared_ptr<Array> prob;
            const ext::shared_ptr<FdmMesherComposite> mesher;
        };

        const std::list<LogEntry>& logEntries() const;

      protected:
        void performCalculations() const override;

        const Handle<LocalVolTermStructure> localVol_;
        const Handle<HestonModel> hestonModel_;
        const Date endDate_;
        const HestonSLVFokkerPlanckFdmParams params_;
        const std::vector<Date> mandatoryDates_;
        const Real mixingFactor_;

        mutable ext::shared_ptr<LocalVolTermStructure> leverageFunction_;

        const bool logging_;
        mutable std::list<LogEntry> logEntries_;
    };
}


#endif

]]></document_content>
  </document>
  <document index="423">
    <source>models/hestonslvmcmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvmcmodel.cpp
*/

#include <ql/math/functional.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>
#include <ql/experimental/models/hestonslvmcmodel.hpp>
#include <ql/experimental/processes/hestonslvprocess.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#include <boost/multi_array.hpp>
#include <utility>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#    pragma GCC diagnostic pop
#endif

namespace QuantLib {
    HestonSLVMCModel::HestonSLVMCModel(
        Handle<LocalVolTermStructure> localVol,
        Handle<HestonModel> hestonModel,
        ext::shared_ptr<BrownianGeneratorFactory> brownianGeneratorFactory,
        const Date& endDate,
        Size timeStepsPerYear,
        Size nBins,
        Size calibrationPaths,
        const std::vector<Date>& mandatoryDates,
        const Real mixingFactor)
    : localVol_(std::move(localVol)), hestonModel_(std::move(hestonModel)),
      brownianGeneratorFactory_(std::move(brownianGeneratorFactory)), endDate_(endDate),
      nBins_(nBins), calibrationPaths_(calibrationPaths), mixingFactor_(mixingFactor) {

        registerWith(localVol_);
        registerWith(hestonModel_);

        const DayCounter dc = hestonModel_->process()->riskFreeRate()->dayCounter();
        const Date refDate = hestonModel_->process()->riskFreeRate()->referenceDate();

        std::vector<Time> gridTimes;
        gridTimes.reserve(mandatoryDates.size()+1);
        for (auto mandatoryDate : mandatoryDates) {
            gridTimes.push_back(dc.yearFraction(refDate, mandatoryDate));
        }
        gridTimes.push_back(dc.yearFraction(refDate, endDate));

        timeGrid_ = ext::make_shared<TimeGrid>(gridTimes.begin(), gridTimes.end(),
                std::max(Size(2), Size(gridTimes.back()*timeStepsPerYear)));
    }

    ext::shared_ptr<HestonProcess> HestonSLVMCModel::hestonProcess() const {
        return hestonModel_->process();
    }

    ext::shared_ptr<LocalVolTermStructure> HestonSLVMCModel::localVol() const {
        return localVol_.currentLink();
    }

    ext::shared_ptr<LocalVolTermStructure>
    HestonSLVMCModel::leverageFunction() const {
        calculate();

        return leverageFunction_;
    }

    void HestonSLVMCModel::performCalculations() const {
        const ext::shared_ptr<HestonProcess> hestonProcess
            = hestonModel_->process();
        const ext::shared_ptr<Quote> spot
            = hestonProcess->s0().currentLink();

        const Real v0            = hestonProcess->v0();
        const DayCounter dc      = hestonProcess->riskFreeRate()->dayCounter();
        const Date referenceDate = hestonProcess->riskFreeRate()->referenceDate();

        const Volatility lv0
            = localVol_->localVol(0.0, spot->value())/std::sqrt(v0);

        const ext::shared_ptr<Matrix> L(new Matrix(nBins_, timeGrid_->size()));

        std::vector<ext::shared_ptr<std::vector<Real> > >
            vStrikes(timeGrid_->size());
        for (Size i=0; i < timeGrid_->size(); ++i) {
            const Integer u = nBins_/2;
            const Real dx = spot->value()*std::sqrt(QL_EPSILON);

            vStrikes[i] = ext::make_shared<std::vector<Real> >(nBins_);

            for (Integer j=0; j < Integer(nBins_); ++j)
                vStrikes[i]->at(j) = spot->value() + (j - u)*dx;
        }

        std::fill(L->column_begin(0),L->column_end(0), lv0);

        leverageFunction_ = ext::make_shared<FixedLocalVolSurface>(
            referenceDate,
            std::vector<Time>(timeGrid_->begin(), timeGrid_->end()),
            vStrikes, L, dc);

        const ext::shared_ptr<HestonSLVProcess> slvProcess
            = ext::make_shared<HestonSLVProcess>(hestonProcess, leverageFunction_, mixingFactor_);

        std::vector<std::pair<Real, Real> > pairs(
                calibrationPaths_, std::make_pair(spot->value(), v0));

        const Size k = calibrationPaths_ / nBins_;
        const Size m = calibrationPaths_ % nBins_;

        const Size timeSteps = timeGrid_->size()-1;

        typedef boost::multi_array<Real, 3> path_type;
        path_type paths(boost::extents[calibrationPaths_][timeSteps][2]);

        const ext::shared_ptr<BrownianGenerator> brownianGenerator =
            brownianGeneratorFactory_->create(2, timeSteps);

        for (Size i=0; i < calibrationPaths_; ++i) {
            brownianGenerator->nextPath();
            std::vector<Real> tmp(2);
            for (Size j=0; j < timeSteps; ++j) {
                brownianGenerator->nextStep(tmp);
                paths[i][j][0] = tmp[0];
                paths[i][j][1] = tmp[1];
            }
        }

        for (Size n=1; n < timeGrid_->size(); ++n) {
            const Time t = timeGrid_->at(n-1);
            const Time dt = timeGrid_->dt(n-1);

            Array x0(2), dw(2);

            for (Size i=0; i < calibrationPaths_; ++i) {
                x0[0] = pairs[i].first;
                x0[1] = pairs[i].second;

                dw[0] = paths[i][n-1][0];
                dw[1] = paths[i][n-1][1];

                x0 = slvProcess->evolve(t, x0, dt, dw);

                pairs[i].first = x0[0];
                pairs[i].second = x0[1];
            }

            std::sort(pairs.begin(), pairs.end());

            Size s = 0U, e = 0U;
            for (Size i=0; i < nBins_; ++i) {
                const Size inc = k + static_cast<unsigned long>(i < m);
                e = s + inc;

                Real sum=0.0;
                for (Size j=s; j < e; ++j) {
                    sum+=pairs[j].second;
                }
                sum/=inc;

                vStrikes[n]->at(i) = 0.5*(pairs[e-1].first + pairs[s].first);
                (*L)[i][n] = std::sqrt(square<Real>()(
                     localVol_->localVol(t, vStrikes[n]->at(i), true))/sum);

                s = e;
            }

            leverageFunction_->setInterpolation<Linear>();
        }
    }
}
]]></document_content>
  </document>
  <document index="424">
    <source>models/hestonslvmcmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvmcmodel.hpp
    \brief Calibration of a Heston stochastic local volatility model based on MC
*/

#ifndef quantlib_heston_slv_mc_model_hpp
#define quantlib_heston_slv_mc_model_hpp

#include <ql/handle.hpp>
#include <ql/timegrid.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>

namespace QuantLib {
    /*! References:

        Anthonie W. van der Stoep,Lech A. Grzelak, Cornelis W. Oosterlee, 2013,
        The Heston Stochastic-Local Volatility Model: Efficient Monte Carlo Simulation
        http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2278122
    */

    class HestonSLVMCModel : public LazyObject {
      public:
        HestonSLVMCModel(Handle<LocalVolTermStructure> localVol,
                         Handle<HestonModel> hestonModel,
                         ext::shared_ptr<BrownianGeneratorFactory> brownianGeneratorFactory,
                         const Date& endDate,
                         Size timeStepsPerYear = 365,
                         Size nBins = 201,
                         Size calibrationPaths = (1 << 15),
                         const std::vector<Date>& mandatoryDates = std::vector<Date>(),
                         Real mixingFactor = 1.0);

        ext::shared_ptr<HestonProcess> hestonProcess() const;
        ext::shared_ptr<LocalVolTermStructure> localVol() const;
        ext::shared_ptr<LocalVolTermStructure> leverageFunction() const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<LocalVolTermStructure> localVol_;
        const Handle<HestonModel> hestonModel_;
        const ext::shared_ptr<BrownianGeneratorFactory> brownianGeneratorFactory_;
        const Date endDate_;
        const Size nBins_, calibrationPaths_;
        const Real mixingFactor_;
        ext::shared_ptr<TimeGrid> timeGrid_;

        mutable ext::shared_ptr<FixedLocalVolSurface> leverageFunction_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="425">
    <source>models/normalclvmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file normalclvmodel.cpp
*/

#include <ql/exercise.hpp>
#include <ql/experimental/models/normalclvmodel.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/methods/finitedifferences/utilities/gbsmrndcalculator.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <utility>


namespace QuantLib {

    NormalCLVModel::NormalCLVModel(const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
                                   ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess,
                                   const std::vector<Date>& maturityDates,
                                   Size lagrangeOrder,
                                   Real pMax,
                                   Real pMin)
    : x_(M_SQRT2 * GaussHermiteIntegration(lagrangeOrder).x()),
      sigma_((pMax != Null<Real>()) ?
                 x_.back() / InverseCumulativeNormal()(pMax) :
                 (pMin != Null<Real>()) ? x_.front() / InverseCumulativeNormal()(pMin) : 1.0),
      bsProcess_(bsProcess), ouProcess_(std::move(ouProcess)), maturityDates_(maturityDates),
      rndCalculator_(ext::make_shared<GBSMRNDCalculator>(bsProcess)),
      maturityTimes_(maturityDates.size()) {

        registerWith(bsProcess_);
        registerWith(ouProcess_);

        for (Size i=0; i < maturityTimes_.size(); ++i) {
            maturityTimes_[i] = bsProcess_->time(maturityDates[i]);
            QL_REQUIRE(i==0 || maturityTimes_[i-1] < maturityTimes_[i],
                    "dates must be sorted");
        }
    }

    Real NormalCLVModel::cdf(const Date& d, Real k) const {
        return rndCalculator_->cdf(k, bsProcess_->time(d));
    }


    Real NormalCLVModel::invCDF(const Date& d, Real q) const {
        return rndCalculator_->invcdf(q, bsProcess_->time(d));
    }

    Disposable<Array> NormalCLVModel::collocationPointsX(const Date& d) const {
        const Time t = bsProcess_->time(d);

        const Real expectation
            = ouProcess_->expectation(0.0, ouProcess_->x0(), t);
        const Real stdDeviation
            = ouProcess_->stdDeviation(0.0, ouProcess_->x0(), t);

        return expectation + stdDeviation*x_;
    }

    Disposable<Array> NormalCLVModel::collocationPointsY(const Date& d) const {
        Array s(x_.size());

        CumulativeNormalDistribution N;
        for (Size i=0, n=s.size(); i < n; ++i) {
            s[i] = invCDF(d, N(x_[i]/sigma_));
        }

        return s;
    }


    ext::function<Real(Time, Real)> NormalCLVModel::g() const {
        calculate();
        return g_;
    }

    NormalCLVModel::MappingFunction::MappingFunction(
        const NormalCLVModel& model)
    : y_(model.x_.size()),
      sigma_(model.sigma_),
      ouProcess_(model.ouProcess_),
      data_(ext::make_shared<InterpolationData>(model)) {

        for (Size i=0; i < data_->s_.columns(); ++i) {
            const Array y = model.collocationPointsY(model.maturityDates_[i]);
            std::copy(y.begin(), y.end(), data_->s_.column_begin(i));
        }

        for (Size i=0; i < data_->s_.rows(); ++i) {
            data_->interpl_.emplace_back(data_->t_.begin(), data_->t_.end(),
                                         data_->s_.row_begin(i));
        }
    }


    Real NormalCLVModel::MappingFunction::operator()(Time t, Real x) const {
        for (Size i=0; i < y_.size(); ++i) {
            y_[i] = data_->interpl_[i](t, true);
        }

        const Real expectation
            = ouProcess_->expectation(0.0, ouProcess_->x0(), t);
        const Real stdDeviation
            = ouProcess_->stdDeviation(0.0, ouProcess_->x0(), t);

        const Real r = sigma_*(x-expectation)/stdDeviation;

        return data_->lagrangeInterpl_.value(y_, r);
    }

    void NormalCLVModel::performCalculations() const {
        g_ = ext::function<Real(Time, Real)>(MappingFunction(*this));
    }
}
]]></document_content>
  </document>
  <document index="426">
    <source>models/normalclvmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file normalclvmodel.hpp
    \brief CLV model with a normally distributed kernel process
*/

#ifndef quantlib_normal_clv_model_hpp
#define quantlib_normal_clv_model_hpp

#include <ql/patterns/lazyobject.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/interpolations/lagrangeinterpolation.hpp>
#include <ql/math/matrix.hpp>
#include <ql/time/date.hpp>
#include <ql/functional.hpp>

namespace QuantLib {
    /*! References:

        A. Grzelak, 2016, The CLV Framework -
        A Fresh Look at Efficient Pricing with Smile

        http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2747541
    */

    class PricingEngine;
    class GBSMRNDCalculator;
    class OrnsteinUhlenbeckProcess;
    class GeneralizedBlackScholesProcess;

    class NormalCLVModel : public LazyObject {
      public:
        NormalCLVModel(const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
                       ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess,
                       const std::vector<Date>& maturityDates,
                       Size lagrangeOrder,
                       Real pMax = Null<Real>(),
                       Real pMin = Null<Real>());

        // cumulative distribution function of the BS process
        Real cdf(const Date& d, Real x) const;

        // inverse cumulative distribution function of the BS process
        Real invCDF(const Date& d, Real q) const;

        // collocation points of the Ornstein-Uhlenbeck process
        Disposable<Array> collocationPointsX(const Date& d) const;

        // collocation points for the underlying Y
        Disposable<Array> collocationPointsY(const Date& d) const;

        // CLV mapping function
        ext::function<Real(Time, Real)> g() const;

      protected:
        void performCalculations() const override;

      private:
        class MappingFunction {
          public:
            explicit MappingFunction(const NormalCLVModel& model);

            Real operator()(Time t, Real x) const;

          private:
            mutable Array y_;
            const Volatility sigma_;
            const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess_;

            struct InterpolationData {
                explicit InterpolationData(const NormalCLVModel& model)
                : s_(model.x_.size(), model.maturityDates_.size()),
                  x_(model.x_),
                  t_(model.maturityTimes_),
                  lagrangeInterpl_(x_.begin(), x_.end(), x_.begin()) {}

                Matrix s_;
                std::vector<LinearInterpolation> interpl_;

                const Array x_;
                const std::vector<Time> t_;
                const LagrangeInterpolation lagrangeInterpl_;
            };

            const ext::shared_ptr<InterpolationData> data_;
        };


        const Array x_;
        const Volatility sigma_;
        const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess_;
        const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess_;
        const std::vector<Date> maturityDates_;
        const ext::shared_ptr<GBSMRNDCalculator> rndCalculator_;

        std::vector<Time> maturityTimes_;
        mutable ext::function<Real(Time, Real)> g_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="427">
    <source>models/squarerootclvmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file squarerootclvmodel.cpp
    \brief CLV model with a square root kernel process
*/

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/squarerootprocess.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>

#include <ql/experimental/models/squarerootclvmodel.hpp>
#include <ql/methods/finitedifferences/utilities/gbsmrndcalculator.hpp>

#include <boost/math/distributions/non_central_chi_squared.hpp>

#include <utility>

namespace QuantLib {
    SquareRootCLVModel::SquareRootCLVModel(
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
        ext::shared_ptr<SquareRootProcess> sqrtProcess,
        std::vector<Date> maturityDates,
        Size lagrangeOrder,
        Real pMax,
        Real pMin)
    : pMax_(pMax), pMin_(pMin), bsProcess_(bsProcess), sqrtProcess_(std::move(sqrtProcess)),
      maturityDates_(std::move(maturityDates)), lagrangeOrder_(lagrangeOrder),
      rndCalculator_(ext::make_shared<GBSMRNDCalculator>(bsProcess)) {}

    Real SquareRootCLVModel::cdf(const Date& d, Real k) const {
        return rndCalculator_->cdf(k, bsProcess_->time(d));
    }


    Real SquareRootCLVModel::invCDF(const Date& d, Real q) const {
        return rndCalculator_->invcdf(q, bsProcess_->time(d));
    }

    std::pair<Real, Real> SquareRootCLVModel::nonCentralChiSquaredParams(
        const Date& d) const {

        const Time t = bsProcess_->time(d);

        const Real kappa = sqrtProcess_->a();
        const Real theta = sqrtProcess_->b();
        const Real sigma = sqrtProcess_->sigma();

        const Real df  = 4*theta*kappa/(sigma*sigma);
        const Real ncp = 4*kappa*std::exp(-kappa*t)
            / (sigma*sigma*(1-std::exp(-kappa*t)))*sqrtProcess_->x0();

        return std::make_pair(df, ncp);
    }


    Disposable<Array> SquareRootCLVModel::collocationPointsX(const Date& d)
    const {
        const std::pair<Real, Real> p = nonCentralChiSquaredParams(d);

        Array x = GaussianQuadrature(lagrangeOrder_,
            GaussNonCentralChiSquaredPolynomial(p.first, p.second))
             .x();

        std::sort(x.begin(), x.end());

        const boost::math::non_central_chi_squared_distribution<Real>
            dist(p.first, p.second);

        const Real xMin = std::max(x.front(),
            (pMin_ == Null<Real>())
                ? 0.0 : boost::math::quantile(dist, pMin_));

        const Real xMax = std::min(x.back(),
            (pMax_ == Null<Real>())
            ? QL_MAX_REAL : boost::math::quantile(dist, pMax_));

        const Real b = xMin - x.front();
        const Real a = (xMax - xMin)/(x.back() - x.front());

        for (double& i : x) {
            i = a * i + b;
        }

        return x;
    }

    Disposable<Array> SquareRootCLVModel::collocationPointsY(const Date& d)
    const {

        const Array x = collocationPointsX(d);
        const std::pair<Real, Real> params = nonCentralChiSquaredParams(d);
        const boost::math::non_central_chi_squared_distribution<Real>
            dist(params.first, params.second);

        Array s(x.size());
        for (Size i=0, n=s.size(); i < n; ++i) {
            const Real q = boost::math::cdf(dist, x[i]);

            s[i] = invCDF(d, q);
        }

        return s;
    }

    ext::function<Real(Time, Real)> SquareRootCLVModel::g() const {
        calculate();
        return g_;
    }

    void SquareRootCLVModel::performCalculations() const {
        g_ = ext::function<Real(Time, Real)>(MappingFunction(*this));
    }

    SquareRootCLVModel::MappingFunction::MappingFunction(
        const SquareRootCLVModel& model)
    : s_(ext::make_shared<Matrix>(
         model.maturityDates_.size(), model.lagrangeOrder_)),
      x_(ext::make_shared<Matrix>(
         model.maturityDates_.size(), model.lagrangeOrder_)) {

        std::vector<Date> maturityDates = model.maturityDates_;
        std::sort(maturityDates.begin(), maturityDates.end());

        const ext::shared_ptr<GeneralizedBlackScholesProcess>&
            bsProcess = model.bsProcess_;

        for (Size i=0, n = maturityDates.size(); i < n; ++i) {
            const Date maturityDate = maturityDates[i];

            const Array x = model.collocationPointsX(maturityDate);
            const Array y = model.collocationPointsY(maturityDate);

            std::copy(x.begin(), x.end(), x_->row_begin(i));
            std::copy(y.begin(), y.end(), s_->row_begin(i));

            const Time maturity = bsProcess->time(maturityDate);

            interpl.insert(
                std::make_pair(maturity,
                    ext::make_shared<LagrangeInterpolation>(
                        x_->row_begin(i), x_->row_end(i),
                        s_->row_begin(i))));
        }
    }

    Real SquareRootCLVModel::MappingFunction::operator()(Time t,Real x) const {
        const interpl_type::const_iterator ge = interpl.lower_bound(t);

        if (close_enough(ge->first, t)) {
            return (*ge->second)(x, true);
        }

        QL_REQUIRE(ge != interpl.end() && ge != interpl.begin(),
             "extrapolation to large or small t is not allowed");

        const Time t1 = ge->first;
        const Real y1 = (*ge->second)(x, true);

        interpl_type::const_iterator lt = ge;
        std::advance(lt, -1);

        const Time t0 = lt->first;
        const Real y0 = (*lt->second)(x, true);

        return y0 + (y1 - y0)/(t1 - t0)*(t - t0);
    }
}
]]></document_content>
  </document>
  <document index="428">
    <source>models/squarerootclvmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file squarerootclvmodel.hpp
    \brief CLV model with a square root kernel process
*/

#ifndef quantlib_square_root_clv_model_hpp
#define quantlib_square_root_clv_model_hpp

#include <ql/time/date.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/math/interpolations/lagrangeinterpolation.hpp>
#include <ql/math/matrix.hpp>
#include <ql/experimental/math/gaussiannoncentralchisquaredpolynomial.hpp>
#include <ql/functional.hpp>
#include <map>

namespace QuantLib {

    class GBSMRNDCalculator;
    class SquareRootProcess;
    class GeneralizedBlackScholesProcess;

    class SquareRootCLVModel : public LazyObject {
      public:
        SquareRootCLVModel(const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
                           ext::shared_ptr<SquareRootProcess> sqrtProcess,
                           std::vector<Date> maturityDates,
                           Size lagrangeOrder,
                           Real pMax = Null<Real>(),
                           Real pMin = Null<Real>());

        // cumulative distribution function of the BS process
        Real cdf(const Date& d, Real x) const;

        // inverse cumulative distribution function of the BS process
        Real invCDF(const Date& d, Real q) const;

        // collocation points of the square root process
        Disposable<Array> collocationPointsX(const Date& d) const;

        // collocation points for the underlying Y
        Disposable<Array> collocationPointsY(const Date& d) const;

        // CLV mapping function
        ext::function<Real(Time, Real)> g() const;

      protected:
        void performCalculations() const override;

      private:
        class MappingFunction {
          public:
            explicit MappingFunction(const SquareRootCLVModel& model);

            Real operator()(Time t, Real x) const;

          private:
            const ext::shared_ptr<Matrix> s_, x_;
            typedef std::map<Time, ext::shared_ptr<LagrangeInterpolation> >
                interpl_type;

            interpl_type interpl;
        };

        std::pair<Real, Real> nonCentralChiSquaredParams(const Date& d) const;

        const Real pMax_, pMin_;
        const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess_;
        const ext::shared_ptr<SquareRootProcess> sqrtProcess_;
        const std::vector<Date> maturityDates_;
        const Size lagrangeOrder_;
        const ext::shared_ptr<GBSMRNDCalculator> rndCalculator_;

        mutable ext::function<Real(Time, Real)> g_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="429">
    <source>processes/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    extouwithjumpsprocess.hpp \
    extendedblackscholesprocess.hpp \
    extendedornsteinuhlenbeckprocess.hpp \
    gemanroncoroniprocess.hpp \
    hestonslvprocess.hpp \
    klugeextouprocess.hpp \
    vegastressedblackscholesprocess.hpp

cpp_files = \
	extouwithjumpsprocess.cpp \
    extendedblackscholesprocess.cpp \
    extendedornsteinuhlenbeckprocess.cpp \
    gemanroncoroniprocess.cpp \
    hestonslvprocess.cpp \
    klugeextouprocess.cpp \
    vegastressedblackscholesprocess.cpp

if UNITY_BUILD

nodist_libProcesses_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libProcesses_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libProcesses.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="430">
    <source>processes/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/experimental/processes/extendedblackscholesprocess.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/gemanroncoroniprocess.hpp>
#include <ql/experimental/processes/hestonslvprocess.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/experimental/processes/vegastressedblackscholesprocess.hpp>

]]></document_content>
  </document>
  <document index="431">
    <source>processes/extendedblackscholesprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hvermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/processes/extendedblackscholesprocess.hpp>

namespace QuantLib {

    ExtendedBlackScholesMertonProcess::ExtendedBlackScholesMertonProcess(
                              const Handle<Quote>& x0,
                              const Handle<YieldTermStructure>& dividendTS,
                              const Handle<YieldTermStructure>& riskFreeTS,
                              const Handle<BlackVolTermStructure>& blackVolTS,
                              const ext::shared_ptr<discretization>& d,
                              Discretization evolDisc)
    : GeneralizedBlackScholesProcess(x0,dividendTS,riskFreeTS,blackVolTS,d),
      discretization_(evolDisc) {}

    Real ExtendedBlackScholesMertonProcess::drift(Time t, Real x) const {
        Real sigma = diffusion(t,x);
        // we could be more anticipatory if we know the right dt
        // for which the drift will be used
        Time t1 = t + 0.0001;
        return riskFreeRate()->forwardRate(t,t1,Continuous,NoFrequency,true)
             - dividendYield()->forwardRate(t,t1,Continuous,NoFrequency,true)
             - 0.5 * sigma * sigma;
    }

    Real ExtendedBlackScholesMertonProcess::diffusion(Time t, Real x) const {
        return blackVolatility()->blackVol(t, x, true);
    }

    Real ExtendedBlackScholesMertonProcess::evolve(Time t0, Real x0,
                                                   Time dt, Real dw) const {
        Real predictor, sigma0, sigma1;
        Time t1;
        Rate rate0, rate1;
        Real driftterm, diffusionterm, corrector;
        switch (discretization_) {
          case Milstein:
            // Milstein scheme
            return apply(x0, drift(t0, x0)*dt
                           + 0.5*std::pow(diffusion(t0, x0),2)*(dw*dw-1)*dt
                           + diffusion(t0,x0)*std::sqrt(dt)*dw);
            break;
          case Euler:
            // Usual Euler scheme
            return apply(expectation(t0,x0,dt), stdDeviation(t0,x0,dt)*dw);
            break;
          case PredictorCorrector:
            // Predictor-Corrector scheme with equal weighting
            predictor =
                apply(expectation(t0,x0,dt), stdDeviation(t0,x0,dt)*dw);
            t1 = t0 + 0.0001;
            sigma0 = diffusion(t0,x0);
            sigma1 = diffusion(t0+dt,predictor);
            rate0 =
                riskFreeRate()->forwardRate(t0,t1,Continuous,NoFrequency,true)
              - dividendYield()->forwardRate(t0,t1,Continuous,NoFrequency,true)
              - 0.5*std::pow(sigma0,2);
            rate1 =
                riskFreeRate()->forwardRate(t0+dt,t1+dt,Continuous,
                                            NoFrequency,true)
              - dividendYield()->forwardRate(t0+dt,t1+dt,
                                             Continuous,NoFrequency,true)
              - 0.5*std::pow(sigma1,2);
            driftterm = 0.5*rate1+0.5*rate0;
            diffusionterm = 0.5*(sigma1+sigma0);
            corrector =
                apply(x0,driftterm*dt+diffusionterm*std::sqrt(dt)*dw);
            return corrector;
            break;
          default:
            QL_FAIL("unknown discretization scheme");
        }
    }

}
]]></document_content>
  </document>
  <document index="432">
    <source>processes/extendedblackscholesprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hvermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extendedblackscholesprocess.hpp
    \brief experimental Black-Scholes-Merton process
*/

#ifndef quantlib_extended_black_scholes_process_hpp
#define quantlib_extended_black_scholes_process_hpp

#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! experimental Black-Scholes-Merton stochastic process
    /*! This class allows to choose a built-in discretization scheme

        \ingroup processes
    */
    class ExtendedBlackScholesMertonProcess
        : public GeneralizedBlackScholesProcess {
      public:
        enum Discretization { Euler, Milstein, PredictorCorrector };
        ExtendedBlackScholesMertonProcess(
            const Handle<Quote>& x0,
            const Handle<YieldTermStructure>& dividendTS,
            const Handle<YieldTermStructure>& riskFreeTS,
            const Handle<BlackVolTermStructure>& blackVolTS,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization),
            Discretization evolDisc = Milstein);
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real evolve(Time t0, Real x0, Time dt, Real dw) const override;

      private:
        const Discretization discretization_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="433">
    <source>processes/extendedornsteinuhlenbeckprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class integrand {
            ext::function<Real (Real)> b;
            Real speed;
          public:
            integrand(ext::function<Real(Real)> b, Real speed) : b(std::move(b)), speed(speed) {}
            Real operator()(Real x) const {
                return b(x) * std::exp(speed*x);
            }
        };

    }

    ExtendedOrnsteinUhlenbeckProcess::ExtendedOrnsteinUhlenbeckProcess(
        Real speed,
        Volatility vol,
        Real x0,
        ext::function<Real(Real)> b,
        Discretization discretization,
        Real intEps)
    : speed_(speed), vol_(vol), b_(std::move(b)), intEps_(intEps),
      ouProcess_(new OrnsteinUhlenbeckProcess(speed, vol, x0)), discretization_(discretization) {
        QL_REQUIRE(speed_ >= 0.0, "negative a given");
        QL_REQUIRE(vol_ >= 0.0, "negative volatility given");
    }

    Real ExtendedOrnsteinUhlenbeckProcess::x0() const {
        return ouProcess_->x0();
    }
    
    Real ExtendedOrnsteinUhlenbeckProcess::drift(Time t, Real x) const {
        return ouProcess_->drift(t, x) + speed_*b_(t);
    }

    Real ExtendedOrnsteinUhlenbeckProcess::diffusion(Time t, Real x) const{
        return ouProcess_->diffusion(t, x);
    }

    Real ExtendedOrnsteinUhlenbeckProcess::stdDeviation(
                                           Time t0, Real x0, Time dt) const{
        return ouProcess_->stdDeviation(t0, x0, dt);
    }

    Real ExtendedOrnsteinUhlenbeckProcess::variance(
                                           Time t0, Real x0, Time dt) const{
        return ouProcess_->variance(t0, x0, dt);
    }

    Real ExtendedOrnsteinUhlenbeckProcess::speed() const {
        return speed_;
    }

    Real ExtendedOrnsteinUhlenbeckProcess::volatility() const {
        return vol_;
    }

    Real ExtendedOrnsteinUhlenbeckProcess::expectation(
                                          Time t0, Real x0, Time dt) const {
        switch (discretization_) {
          case MidPoint:
            return ouProcess_->expectation(t0, x0, dt)
                    + b_(t0+0.5*dt)*(1.0 - std::exp(-speed_*dt));
            break;
          case Trapezodial:
            {
              const Time t = t0+dt;
              const Time u = t0;
              const Real bt = b_(t);
              const Real bu = b_(u);
              const Real ex = std::exp(-speed_*dt);

              return ouProcess_->expectation(t0, x0, dt)
                    + bt-ex*bu - (bt-bu)/(speed_*dt)*(1-ex);
            }
            break;
          case GaussLobatto:
              return ouProcess_->expectation(t0, x0, dt)
                  + speed_*std::exp(-speed_*(t0+dt))
                  * GaussLobattoIntegral(100000, intEps_)(integrand(b_, speed_),
                                                          t0, t0+dt);
            break;
          default:
            QL_FAIL("unknown discretization scheme");
        }
    }
}

]]></document_content>
  </document>
  <document index="434">
    <source>processes/extendedornsteinuhlenbeckprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extendedornsteinuhlenbeckprocess.hpp
    \brief extended Ornstein-Uhlenbeck process
*/

#ifndef quantlib_extended_ornstein_uhlenbeck_process_hpp
#define quantlib_extended_ornstein_uhlenbeck_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/functional.hpp>

namespace QuantLib {

    class OrnsteinUhlenbeckProcess;

    //! Extended Ornstein-Uhlenbeck process class
    /*! This class describes the Ornstein-Uhlenbeck process governed by
        \f[
            dx = a (b(t) - x_t) dt + \sigma dW_t.
        \f]

        \ingroup processes
    */
    class ExtendedOrnsteinUhlenbeckProcess : public StochasticProcess1D {
      public:
        enum Discretization { MidPoint, Trapezodial, GaussLobatto };

        ExtendedOrnsteinUhlenbeckProcess(Real speed,
                                         Volatility sigma,
                                         Real x0,
                                         ext::function<Real(Real)> b,
                                         Discretization discretization = MidPoint,
                                         Real intEps = 1e-4);

        //! \name StochasticProcess interface
        //@{
        Real x0() const override;
        Real speed() const;
        Real volatility() const;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real x0, Time dt) const override;
        //@}
      private:
        const Real speed_;
        const Volatility vol_;
        const ext::function<Real (Real)> b_;
        const Real intEps_;
        const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess_;
        const Discretization discretization_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="435">
    <source>processes/extouwithjumpsprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expouwithjumpsprocess.cpp
    \brief Ornstein Uhlenbeck process plus exp jumps (Kluge Model)
*/

#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <utility>

namespace QuantLib {

    ExtOUWithJumpsProcess::ExtOUWithJumpsProcess(
        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process,
        Real Y0,
        Real beta,
        Real jumpIntensity,
        Real eta)
    : Y0_(Y0), beta_(beta), jumpIntensity_(jumpIntensity), eta_(eta),
      ouProcess_(std::move(process)) {}

    Size ExtOUWithJumpsProcess::size() const {
        return 2;
    }    
    Size ExtOUWithJumpsProcess::factors() const {
        return 3;
    }
    ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess>
        ExtOUWithJumpsProcess::getExtendedOrnsteinUhlenbeckProcess() const {
        return ouProcess_;
    }
    Real ExtOUWithJumpsProcess::beta() const {
        return beta_;
    }
    Real ExtOUWithJumpsProcess::jumpIntensity() const {
        return jumpIntensity_;
    }
    Real ExtOUWithJumpsProcess::eta() const {
        return eta_;
    }

    Disposable<Array> ExtOUWithJumpsProcess::initialValues() const {
        Array retVal(2);
        retVal[0] = ouProcess_->x0();
        retVal[1] = Y0_;
        
        return retVal;
    }
    
    Disposable<Array> ExtOUWithJumpsProcess::drift(Time t, const Array& x) const {
        Array retVal(2);
        retVal[0] = ouProcess_->drift(t, x[0]);
        retVal[1] = -beta_*x[1];
        
        return retVal;
    }

    Disposable<Matrix> 
    ExtOUWithJumpsProcess::diffusion(Time t, const Array& x) const {
        Matrix retVal(2, 2, 0.0);    
        retVal[0][0] = ouProcess_->diffusion(t, x[0]);
        
        return retVal;
    }

    Disposable<Array> ExtOUWithJumpsProcess::evolve(
        Time t0, const Array& x0, Time dt, const Array& dw) const {
        
        Array retVal(2);
        retVal[0] = ouProcess_->evolve(t0, x0[0], dt, dw[0]);
        retVal[1] = x0[1]*std::exp(-beta_*dt);
                
        const Real u1 = std::max(QL_EPSILON, std::min(cumNormalDist_(dw[1]), 
                                                      1.0-QL_EPSILON));

        const Time interarrival = -1.0/jumpIntensity_*std::log(u1);
        if (interarrival < dt) {
            const Real u2 = std::max(QL_EPSILON, std::min(cumNormalDist_(dw[2]), 
                                                          1.0-QL_EPSILON));
            const Real jumpSize = -1.0/eta_*std::log(u2);
            retVal[1] += jumpSize;
        }
        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="436">
    <source>processes/extouwithjumpsprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extouwithjumpsprocess.hpp
    \brief Ornstein Uhlenbeck process plus exp jumps (Kluge Model)
*/

#ifndef quantlib_ext_ou_with_jumps_process_hpp
#define quantlib_ext_ou_with_jumps_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    class ExtendedOrnsteinUhlenbeckProcess;

    /*! This class describes a Ornstein Uhlenbeck model plus exp jump, 
        an extension of the Lucia and Schwartz model
        \f[
        \begin{array}{rcl}
        S &=& exp(X_t + Y_t) \\
        dX_t  &=& \alpha(\mu(t)-X_t)dt + \sigma dW_t \\
        dY_t  &=& -\beta Y_{t-}dt + J_tdN_t \\
        \omega(J)&=& \eta_u e^{-\eta_u J}
        \end{array}
        \f]
        
        \ingroup processes
    */


    /*! References:
        T. Kluge, 2008. Pricing Swing Options and other 
        Electricity Derivatives, http://eprints.maths.ox.ac.uk/246/1/kluge.pdf
        
        B. Hambly, S. Howison, T. Kluge, Modelling spikes and pricing 
        swing options in electricity markets,
        http://people.maths.ox.ac.uk/hambly/PDF/Papers/elec.pdf
    */
        

    class ExtOUWithJumpsProcess : public StochasticProcess {
      public:
        ExtOUWithJumpsProcess(ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process,
                              Real Y0,
                              Real beta,
                              Real jumpIntensity,
                              Real eta);

        Size size() const override;
        Size factors() const override;

        Disposable<Array> initialValues() const override;
        Disposable<Array> drift(Time t, const Array& x) const override;
        Disposable<Matrix> diffusion(Time t, const Array& x) const override;
        Disposable<Array> evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess>
                                 getExtendedOrnsteinUhlenbeckProcess() const;

        Real beta()          const;
        Real eta()           const;
        Real jumpIntensity() const;

      private:
        const Real Y0_, beta_, jumpIntensity_, eta_;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess_;
        
        const CumulativeNormalDistribution cumNormalDist_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="437">
    <source>processes/gemanroncoroniprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gemanroncoroniprocess.cpp
    \brief Geman-Roncoroni process
*/

#include <ql/math/functional.hpp>
#include <ql/processes/eulerdiscretization.hpp>
#include <ql/experimental/processes/gemanroncoroniprocess.hpp>


namespace QuantLib {

    GemanRoncoroniProcess::GemanRoncoroniProcess(
                                      Real x0, 
                                      Real alpha, Real beta, 
                                      Real gamma, Real delta, 
                                      Real eps, Real zeta, Real d, 
                                      Real k,  Real tau,
                                      Real sig2, Real a, Real b,
                                      Real theta1, Real theta2, Real theta3,
                                      Real psi)
    : StochasticProcess1D(ext::shared_ptr<discretization>(
                                                    new EulerDiscretization)),
      x0_(x0),
      alpha_(alpha), beta_(beta),
      gamma_(gamma), delta_(delta),
      eps_(eps), zeta_(zeta), d_(d), 
      k_(k), tau_(tau),
      sig2_(sig2), a_(a), b_(b),
      theta1_(theta1), theta2_(theta2), theta3_(theta3),
      psi_(psi) {  
    }

    Real GemanRoncoroniProcess::x0() const {
        return x0_;
    }

    Real GemanRoncoroniProcess::drift(Time t, Real x) const {
        const Real mu = alpha_ + beta_*t + gamma_*std::cos(eps_+2*M_PI*t)
                                         + delta_*std::cos(zeta_+4*M_PI*t);
        const Real muPrime = beta_ - gamma_*2*M_PI*std::sin(eps_+2*M_PI*t)
                                   - delta_*4*M_PI*std::sin(zeta_+4*M_PI*t);

        return muPrime + theta1_*(mu-x);
    }
    
    Real GemanRoncoroniProcess::diffusion(Time t, Real /*x*/) const {
        return std::sqrt(sig2_ + a_*square<Real>()(std::cos(M_PI*t+b_)));
    }

    Real GemanRoncoroniProcess::stdDeviation(Time t0, Real /*x0*/, Time dt) const {
        const Volatility sig2t = sig2_+a_*square<Real>()(std::cos(M_PI*t0+b_));
        
        return std::sqrt(sig2t/(2*theta1_)*(1.0-std::exp(-2*theta1_*dt)));
    }

    Real GemanRoncoroniProcess::evolve(Time t0, Real x0, 
                                       Time dt, Real dw) const {
        // random number generator for the jump part 
        if (!urng_) {
            typedef PseudoRandom::urng_type urng_type;
            urng_ = ext::make_shared<urng_type>((unsigned long)(1234UL * dw + 56789UL));
        }
        Array du(3); 
        du[0] = urng_->next().value; 
        du[1] = urng_->next().value;

        return evolve(t0, x0, dt, dw, du);
    }

    Real GemanRoncoroniProcess::evolve(Time t0, Real x0, Time dt,
                                       Real dw, const Array& du) const {
        Real retVal;
        const Time t = t0 + 0.5*dt;
        const Real mu = alpha_ + beta_*t + gamma_*std::cos(eps_ +2*M_PI*t)
                                         + delta_*std::cos(zeta_+4*M_PI*t);
        
        const Real j = -1.0/theta3_
                        *std::log(1.0+du[1]*(std::exp(-theta3_*psi_)-1.0));

        if (x0 <= mu+d_) {
            retVal = StochasticProcess1D::evolve(t, x0, dt, dw);
            
            const Real jumpIntensity
                = theta2_*(2.0/(1+std::fabs(std::sin(M_PI*(t-tau_)/k_)))-1);            
            const Time interarrival = -1.0/jumpIntensity*std::log(du[0]);

            if (interarrival < dt) {
                retVal += j;
            }
        }
        else {
            retVal = x0-j;
        }

        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="438">
    <source>processes/gemanroncoroniprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gemanroncoroniprocess.hpp
    \brief Geman-Roncoroni process
*/

#ifndef quantlib_geman_roncoroni_process_hpp
#define quantlib_geman_roncoroni_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>

namespace QuantLib {

    //! Geman-Roncoroni process class
    /*! This class describes the Geman-Roncoroni process governed by
        \f[
        \begin{array}{rcl}
            dE(t) &=& \left[ \frac{\partial}{\partial t} \mu(t)
                +\theta_1 \left(\mu(t)-E(t^-)\right)\right]dt
                +\sigma dW(t) + h(E(t^-))dJ(t) \\
            \mu(t)&=& \alpha + \beta t +\gamma \cos(\epsilon+2\pi t)
                +\delta \cos(\zeta + 4\pi t)
        \end{array}
        \f]

        \ingroup processes
    */
    class GemanRoncoroniProcess : public StochasticProcess1D {
      public:
        GemanRoncoroniProcess(Real x0, 
                              Real alpha, Real beta, 
                              Real gamma, Real delta, 
                              Real eps, Real zeta, Real d, 
                              Real k, Real tau,
                              Real sig2, Real a, Real b,
                              Real theta1, Real theta2, Real theta3,
                              Real psi);

        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real evolve(Time t0, Real x0, Time dt, Real dw) const override;

        Real evolve(Time t0, Real x0, Time dt, Real dw, const Array& du) const;
        
    private:
        // avoid clang++ warnings
        using StochasticProcess::evolve;

        const Real x0_;
        const Real alpha_, beta_, gamma_, delta_;
        const Real eps_, zeta_, d_; 
        const Real k_, tau_;
        const Real sig2_, a_, b_;
        const Real theta1_, theta2_, theta3_;
        const Real psi_;
        mutable ext::shared_ptr<PseudoRandom::urng_type> urng_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="439">
    <source>processes/hestonslvprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvprocess.cpp
    \brief Heston stochastic local volatility process
*/

#include <ql/experimental/processes/hestonslvprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>
#include <utility>

namespace QuantLib {

    HestonSLVProcess::HestonSLVProcess(const ext::shared_ptr<HestonProcess>& hestonProcess,
                                       ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                       const Real mixingFactor)
    : mixingFactor_(mixingFactor), hestonProcess_(hestonProcess),
      leverageFct_(std::move(leverageFct)) {
        registerWith(hestonProcess);
        update();
    };

    void HestonSLVProcess::update() {
        v0_    = hestonProcess_->v0();
        kappa_ = hestonProcess_->kappa();
        theta_ = hestonProcess_->theta();
        sigma_ = hestonProcess_->sigma();
        rho_   = hestonProcess_->rho();
        mixedSigma_ = mixingFactor_ * sigma_;
    }

    Disposable<Array> HestonSLVProcess::drift(Time t, const Array& x) const {
        Array tmp(2);

        const Volatility vol =
           std::max(1e-8, std::sqrt(x[1])*leverageFct_->localVol(t, x[0], true));

        tmp[0] = riskFreeRate()->forwardRate(t, t, Continuous)
               - dividendYield()->forwardRate(t, t, Continuous)
               - 0.5*vol*vol;

        tmp[1] = kappa_*(theta_ - x[1]);

        return tmp;
    }

    Disposable<Matrix> HestonSLVProcess::diffusion(Time t, const Array& x)
    const {

        const Real vol =
            std::max(1e-8, std::sqrt(x[1])*leverageFct_->localVol(t, x[0], true));

        const Real sigma2 = mixedSigma_ * std::sqrt(x[1]);
        const Real sqrhov = std::sqrt(1.0 - rho_*rho_);

        Matrix tmp(2,2);
        tmp[0][0] = vol;          tmp[0][1] = 0.0;
        tmp[1][0] = rho_*sigma2;  tmp[1][1] = sqrhov*sigma2;

        return tmp;
    }

    Disposable<Array> HestonSLVProcess::evolve(
        Time t0, const Array& x0, Time dt, const Array& dw) const {
        Array retVal(2);

        const Real ex = std::exp(-kappa_*dt);

        const Real m  =  theta_+(x0[1]-theta_)*ex;
        const Real s2 =  x0[1]*mixedSigma_*mixedSigma_*ex/kappa_*(1-ex)
                       + theta_*mixedSigma_*mixedSigma_/(2*kappa_)*(1-ex)*(1-ex);
        const Real psi = s2/(m*m);

        if (psi < 1.5) {
            const Real b2 = 2/psi-1+std::sqrt(2/psi*(2/psi-1));
            const Real b  = std::sqrt(b2);
            const Real a  = m/(1+b2);

            retVal[1] = a*(b+dw[1])*(b+dw[1]);
        }
        else {
            const Real p = (psi-1)/(psi+1);
            const Real beta = (1-p)/m;
            const Real u = CumulativeNormalDistribution()(dw[1]);

            retVal[1] = ((u <= p) ? 0.0 : std::log((1-p)/(1-u))/beta);
        }

        const Real mu = riskFreeRate()->forwardRate(t0, t0+dt, Continuous)
             - dividendYield()->forwardRate(t0, t0+dt, Continuous);

        const Real rho1 = std::sqrt(1-rho_*rho_);

        const Volatility l_0 = leverageFct_->localVol(t0, x0[0], true);
        const Real v_0 = 0.5*(x0[1]+retVal[1])*l_0*l_0;

        retVal[0] = x0[0]*std::exp(mu*dt - 0.5*v_0*dt
            + rho_/mixedSigma_*l_0 * (
                  retVal[1] - kappa_*theta_*dt
                  + 0.5*(x0[1]+retVal[1])*kappa_*dt - x0[1])
            + rho1*std::sqrt(v_0*dt)*dw[0]);

        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="440">
    <source>processes/hestonslvprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvprocess.hpp
    \brief Heston stochastic local volatility process
*/

#ifndef quantlib_heston_slv_process_hpp
#define quantlib_heston_slv_process_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class HestonSLVProcess : public StochasticProcess {
      public:
        HestonSLVProcess(const ext::shared_ptr<HestonProcess>& hestonProcess,
                         ext::shared_ptr<LocalVolTermStructure> leverageFct,
                         Real mixingFactor = 1.0);

        Size size() const override { return Size(2); }
        Size factors() const override { return Size(2); }

        void update() override;

        Disposable<Array> initialValues() const override { return hestonProcess_->initialValues(); }
        Disposable<Array> apply(const Array& x0, const Array& dx) const override {
            return hestonProcess_->apply(x0, dx);
        }

        Disposable<Array> drift(Time t, const Array& x) const override;
        Disposable<Matrix> diffusion(Time t, const Array& x) const override;
        Disposable<Array> evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        Real v0()    const { return v0_; }
        Real rho()   const { return rho_; }
        Real kappa() const { return kappa_; }
        Real theta() const { return theta_; }
        Real sigma() const { return sigma_; }
        Real mixingFactor() const { return mixingFactor_; }
        ext::shared_ptr<LocalVolTermStructure> leverageFct() const {
            return leverageFct_;
        }

        const Handle<Quote>& s0() const { return hestonProcess_->s0(); }
        const Handle<YieldTermStructure>& dividendYield() const {
            return hestonProcess_->dividendYield();
        }
        const Handle<YieldTermStructure>& riskFreeRate() const {
            return hestonProcess_->riskFreeRate();
        }

        Time time(const Date& d) const override { return hestonProcess_->time(d); }

      private:
        Real kappa_, theta_, sigma_, rho_, v0_, mixingFactor_, mixedSigma_;

        const ext::shared_ptr<HestonProcess> hestonProcess_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="441">
    <source>processes/klugeextouprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    KlugeExtOUProcess::KlugeExtOUProcess(
        Real rho,
        ext::shared_ptr<ExtOUWithJumpsProcess> klugeProcess,
        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess)
    : rho_(rho), sqrtMRho_(std::sqrt(1 - rho * rho)), klugeProcess_(std::move(klugeProcess)),
      ouProcess_(std::move(ouProcess)) {}

    Size KlugeExtOUProcess::size() const {
        return klugeProcess_->size() + 1;
    }

    Size KlugeExtOUProcess::factors() const {
        return klugeProcess_->factors() + 1;
    }

    Disposable<Array> KlugeExtOUProcess::initialValues() const {
        Array retVal(size());
        const Array x0 = klugeProcess_->initialValues();
        std::copy(x0.begin(), x0.end(), retVal.begin());
        retVal.back() = ouProcess_->x0();

        return retVal;
    }

    Disposable<Array> KlugeExtOUProcess::drift(Time t, const Array& x) const {
        Array retVal(size());
        Array mu = klugeProcess_->drift(t, x);
        std::copy(mu.begin(), mu.end(), retVal.begin());
        retVal.back() = ouProcess_->drift(t, x.back());

        return retVal;
    }

    Disposable<Matrix> KlugeExtOUProcess::diffusion(Time t, const Array& x)
        const{
        Matrix retVal(size(), factors(), 0.0);

        Volatility vol = ouProcess_->diffusion(t, x.back());

        retVal[0][0]              = klugeProcess_->diffusion(t, x)[0][0];
        retVal[size()][0]         = rho_*vol;
        retVal[size()][factors()] = sqrtMRho_*vol;

        return retVal;
    }

    Disposable<Array> KlugeExtOUProcess::evolve(Time t0, const Array& x0,
                                                Time dt, const Array& dw) const{
        Array retVal(size());

        Array ev = klugeProcess_->evolve(t0, x0, dt, dw);
        std::copy(ev.begin(), ev.end(), retVal.begin());

        const Real dz = dw.back()*sqrtMRho_ + dw.front()*rho_;
        retVal.back() = ouProcess_->evolve(t0, x0.back(), dt, dz);

        return retVal;
    }

    ext::shared_ptr<ExtOUWithJumpsProcess>
        KlugeExtOUProcess::getKlugeProcess() const {
        return klugeProcess_;
    }
    ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess>
        KlugeExtOUProcess::getExtOUProcess() const {
        return ouProcess_;
    }

    Real KlugeExtOUProcess::rho() const {
        return rho_;
    }

}

]]></document_content>
  </document>
  <document index="442">
    <source>processes/klugeextouprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file klugeextouprocess.hpp
    \brief joint Kluge process an d Ornstein Uhlenbeck process
*/

#ifndef quantlib_kluge_ext_ou_process_hpp
#define quantlib_kluge_ext_ou_process_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    class ExtOUWithJumpsProcess;
    class ExtendedOrnsteinUhlenbeckProcess;

    /*! This class describes a correlated Kluge - extended Ornstein-Uhlenbeck
        process governed by
        \f[
        \begin{array}{rcl}
            P_t &=& \exp(p_t + X_t + Y_t) \\
            dX_t &=& -\alpha X_tdt + \sigma_x dW_t^x \\
            dY_t &=& -\beta Y_{t-}dt + J_tdN_t \\
            \omega(J) &=& \eta e^{-\eta J} \\
            G_t &=& \exp(g_t + U_t) \\
            dU_t &=& -\kappa U_tdt + \sigma_udW_t^u \\
            \rho &=& \mathrm{corr} (dW_t^x, dW_t^u)
         \end{array}
         \f]
    */

    /*! References:
        B. Hambly, S. Howison, T. Kluge, Modelling spikes and pricing
        swing options in electricity markets,
        http://people.maths.ox.ac.uk/hambly/PDF/Papers/elec.pdf
    */


    class KlugeExtOUProcess : public StochasticProcess {
      public:
        KlugeExtOUProcess(Real rho,
                          ext::shared_ptr<ExtOUWithJumpsProcess> kluge,
                          ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> extOU);

        Size size() const override;
        Size factors() const override;

        Disposable<Array> initialValues() const override;
        Disposable<Array> drift(Time t, const Array& x) const override;
        Disposable<Matrix> diffusion(Time t, const Array& x) const override;
        Disposable<Array> evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        ext::shared_ptr<ExtOUWithJumpsProcess> getKlugeProcess() const;
        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess>
                                                 getExtOUProcess() const;

        Real rho() const;

      private:
        const Real rho_, sqrtMRho_;
        const ext::shared_ptr<ExtOUWithJumpsProcess> klugeProcess_;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="443">
    <source>processes/vegastressedblackscholesprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Michael Heckl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/processes/vegastressedblackscholesprocess.hpp>

namespace QuantLib {

    VegaStressedBlackScholesProcess::VegaStressedBlackScholesProcess(
             const Handle<Quote>& x0,
             const Handle<YieldTermStructure>& dividendTS,
             const Handle<YieldTermStructure>& riskFreeTS,
             const Handle<BlackVolTermStructure>& blackVolTS,
             Time lowerTimeBorderForStressTest,
             Time upperTimeBorderForStressTest,
             Real lowerAssetBorderForStressTest,
             Real upperAssetBorderForStressTest,
             Real stressLevel,
             const ext::shared_ptr<discretization>& disc)
    : GeneralizedBlackScholesProcess(x0, dividendTS, riskFreeTS,
                                     blackVolTS, disc),
      lowerTimeBorderForStressTest_(lowerTimeBorderForStressTest),
      upperTimeBorderForStressTest_(upperTimeBorderForStressTest), 
      lowerAssetBorderForStressTest_(lowerAssetBorderForStressTest), 
      upperAssetBorderForStressTest_(upperAssetBorderForStressTest),
      stressLevel_(stressLevel) {}

    // returns the lower time border for the stress test
    Real VegaStressedBlackScholesProcess::getLowerTimeBorderForStressTest() const {
        return lowerTimeBorderForStressTest_;
    }

    // returns the upper time border for the stress test
    Real VegaStressedBlackScholesProcess::getUpperTimeBorderForStressTest() const {
        return upperTimeBorderForStressTest_;
    }

    // returns the lower asset border for the stress test
    Real VegaStressedBlackScholesProcess::getLowerAssetBorderForStressTest() const {
        return lowerAssetBorderForStressTest_;
    }

    // returns the upper asset border for the stress test
    Real VegaStressedBlackScholesProcess::getUpperAssetBorderForStressTest() const {
        return upperAssetBorderForStressTest_;
    }

    // returns the stress Level
    Real VegaStressedBlackScholesProcess::getStressLevel() const {
        return stressLevel_;
    }


    // set the lower time border for the stress test
    void VegaStressedBlackScholesProcess::setLowerTimeBorderForStressTest(Time LTB) {
        lowerTimeBorderForStressTest_ = LTB;
        update();
    }

    // set the upper time border for the stress test
    void VegaStressedBlackScholesProcess::setUpperTimeBorderForStressTest(Time UTB) {
        upperTimeBorderForStressTest_ = UTB;
        update();
    }

    // set the lower asset border for the stress test
    void VegaStressedBlackScholesProcess::setLowerAssetBorderForStressTest(Real LAB) {
        lowerAssetBorderForStressTest_ = LAB;
        update();
    }

    // set the upper asset border for the stress test
    void VegaStressedBlackScholesProcess::setUpperAssetBorderForStressTest(Real UBA) {
        upperAssetBorderForStressTest_ = UBA;
        update();
    }

    // set the stress Level
    void VegaStressedBlackScholesProcess::setStressLevel(Real SL) {
        stressLevel_ = SL;
        update();
    }



    Real VegaStressedBlackScholesProcess::diffusion(Time t, Real x) const {
        if (lowerTimeBorderForStressTest_ <= t && t <= upperTimeBorderForStressTest_ 
            && lowerAssetBorderForStressTest_ <= x && x <= upperAssetBorderForStressTest_) {
            return GeneralizedBlackScholesProcess::diffusion(t, x)+stressLevel_;
        } else {
            return GeneralizedBlackScholesProcess::diffusion(t, x);
        }
    }

}
]]></document_content>
  </document>
  <document index="444">
    <source>processes/vegastressedblackscholesprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Michael Heckl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vegastressedblackscholesprocess.hpp
    \brief Black-Scholes process which supports local vega stress tests
*/

#ifndef quantlib_vega_stressed_black_scholes_process_hpp
#define quantlib_vega_stressed_black_scholes_process_hpp

#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Black-Scholes process which supports local vega stress tests
    class VegaStressedBlackScholesProcess
        : public GeneralizedBlackScholesProcess {
      public:
        VegaStressedBlackScholesProcess(
            const Handle<Quote>& x0,
            const Handle<YieldTermStructure>& dividendTS,
            const Handle<YieldTermStructure>& riskFreeTS,
            const Handle<BlackVolTermStructure>& blackVolTS,
            Time lowerTimeBorderForStressTest = 0,
            Time upperTimeBorderForStressTest = 1000000,
            Real lowerAssetBorderForStressTest = 0,
            Real upperAssetBorderForStressTest = 1000000,
            Real stressLevel = 0,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization));
        //! \name StochasticProcess1D interface
        //@{
        Real diffusion(Time t, Real x) const override;
        //@}
        //! \name interface for vega stress test
        //@{
        // give back lower time border for stress test
        Real getLowerTimeBorderForStressTest() const;
        // set lower time border for stress test
        void setLowerTimeBorderForStressTest(Time LTB);
        // give back upper time border for stress test
        Real getUpperTimeBorderForStressTest() const;
        // set upper time border for stress test
        void setUpperTimeBorderForStressTest(Time UTB);
        // give back lower asset border for stress test
        Real getLowerAssetBorderForStressTest() const;
        // set lower asset border for stress test
        void setLowerAssetBorderForStressTest(Real LAB);
        // give back upper asset border for stress test
        Real getUpperAssetBorderForStressTest() const;
        // set upper asset border for stress test
        void setUpperAssetBorderForStressTest(Real UBA);
        // give back stress level
        Real getStressLevel() const;
        // set stress level
        void setStressLevel(Real SL);
        //@}
      private:
        Real lowerTimeBorderForStressTest_;
        Real upperTimeBorderForStressTest_;
        Real lowerAssetBorderForStressTest_;
        Real upperAssetBorderForStressTest_;
        Real stressLevel_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="445">
    <source>risk/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    creditriskplus.hpp \
    sensitivityanalysis.hpp

cpp_files = \
    creditriskplus.cpp \
    sensitivityanalysis.cpp

if UNITY_BUILD

nodist_libRisk_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libRisk_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libRisk.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="446">
    <source>risk/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/risk/creditriskplus.hpp>
#include <ql/experimental/risk/sensitivityanalysis.hpp>

]]></document_content>
  </document>
  <document index="447">
    <source>risk/creditriskplus.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2013 Peter Caspers

  This file is part of QuantLib, a free-software/open-source library
  for financial quantitative analysts and developers - http://quantlib.org/

  QuantLib is free software: you can redistribute it and/or modify it
  under the terms of the QuantLib license.  You should have received a
  copy of the license along with this program; if not, please email
  <quantlib-dev@lists.sf.net>. The license is also available online at
  <http://quantlib.org/license.shtml>.

  This program is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/risk/creditriskplus.hpp>
#include <map>
#include <utility>

using std::sqrt;

namespace QuantLib {

    CreditRiskPlus::CreditRiskPlus(std::vector<Real> exposure,
                                   std::vector<Real> defaultProbability,
                                   std::vector<Size> sector,
                                   std::vector<Real> relativeDefaultVariance,
                                   Matrix correlation,
                                   const Real unit)
    : exposure_(std::move(exposure)), pd_(std::move(defaultProbability)),
      sector_(std::move(sector)), relativeDefaultVariance_(std::move(relativeDefaultVariance)),
      correlation_(std::move(correlation)), unit_(unit) {

        m_ = exposure_.size();

        QL_REQUIRE(m_ > 0, "no exposures given");
        QL_REQUIRE(m_ == pd_.size(), "number of exposures ("
                                         << m_
                                         << ") must be equal to number of pds ("
                                         << pd_.size() << ")");
        QL_REQUIRE(m_ == sector_.size(),
                   "number of exposures ("
                       << m_
                       << ") must be equal to number of exposure sectors ("
                       << sector_.size() << ")");

        n_ = correlation_.rows();
        QL_REQUIRE(correlation_.columns() == n_,
                   "correlation matrix (" << n_ << "," << correlation_.columns()
                                          << ") must be a square matrix");

        QL_REQUIRE(relativeDefaultVariance_.size() == n_,
                   "number of relative default variances ("
                       << relativeDefaultVariance_.size() << ")"
                       << " must be equal to number of sectors (" << n_ << ")");

        exposureSum_ = 0.0;
        el_ = 0.0;
        el2_ = 0.0;
        for (Size i = 0; i < m_; ++i) {
            QL_REQUIRE(exposure_[i] >= 0.0, "exposure #"
                                                << i << " is negative ("
                                                << exposure_[i] << ")");
            QL_REQUIRE(pd_[i] > 0.0, "pd #" << i << " is negative (" << pd_[i]
                                            << ")");
            QL_REQUIRE(sector_[i] < n_, "sector #" << i << " (" << sector_[i]
                                                   << ") is out of range 0..."
                                                   << (n_ - 1));
            exposureSum_ += exposure_[i];
            el_ += pd_[i] * exposure_[i];
            el2_ += pd_[i] * exposure_[i]*exposure_[i];
        }

        QL_REQUIRE(unit_ > 0.0, "loss unit (" << unit_ << ") must be positive");

        compute();
    }

    Real CreditRiskPlus::lossQuantile(const Real p) {

        Size i = 0;
        Real sum = loss_[0];
        while(i < upperIndex_-1 && sum < p) {
            ++i;
            sum += loss_[i];
        }

        if(loss_[0] >= p)
            return 0.0;

        Real p1 = sum - loss_[i];
        Real p2 = sum >= p ? sum : 1.0;
        Real l1 = (i - 1) * unit_;
        Real l2 = i * unit_;

        return l1 + (p - p1) / (p2 - p1) * (l2 - l1);
    }

    void CreditRiskPlus::compute() {

        std::vector<Real> sectorPdSum_, sectorSpecTerms_;

        sectorPdSum_ = std::vector<Real>(n_, 0.0);
        sectorExposure_ = std::vector<Real>(n_, 0.0);
        sectorEl_ = std::vector<Real>(n_, 0.0);
        sectorSpecTerms_ = std::vector<Real>(n_, 0.0);
        sectorUl_ = std::vector<Real>(n_, 0.0);
        marginalLoss_ = std::vector<Real>(m_, 0.0);

        std::vector<Real> pdAdj(m_, 0.0);

        // compute exposure bands

        unsigned long maxNu_ = 0;
        upperIndex_ = 0;

        // map of nuC_ to expected loss
        std::map<unsigned long, Real, std::less<unsigned long> > epsNuC_;

        std::map<unsigned long, Real, std::less<unsigned long> >::iterator iter;

        for (Size k = 0; k < m_; ++k) {
            auto exUnit = (unsigned long)(std::floor(0.5 + exposure_[k] / unit_)); // round
            if (exposure_[k] > 0 && exUnit == 0)
                exUnit = 1; // but avoid zero exposure
            if (exUnit > maxNu_)
                maxNu_ = exUnit;
            pdAdj[k] = exposure_[k] > 0.0
                           ? exposure_[k] * pd_[k] / (exUnit * unit_)
                           : 0.0; // adjusted pd
            Real el = exUnit * pdAdj[k];
            if (exUnit > 0) {
                iter = epsNuC_.find(exUnit);
                if (iter == epsNuC_.end()) {
                    epsNuC_.insert(std::pair<unsigned long, Real>(exUnit, el));
                } else {
                    (*iter).second += el;
                }
                upperIndex_ += exUnit;
            }
        }

        // compute per sector figures

        Real pdSum_ = 0;
        for (Size k = 0; k < m_; ++k) {
            pdSum_ += pdAdj[k];
            sectorPdSum_[sector_[k]] += pd_[k];
            sectorExposure_[sector_[k]] += exposure_[k];
            sectorEl_[sector_[k]] += exposure_[k] * pd_[k];
        }

        for (Size i = 0; i < n_; ++i) {

            // precompute sector specific terms (formula 15 in [1])

            sectorSpecTerms_[i] += relativeDefaultVariance_[i] * sectorEl_[i];
            for (Size j = 0; j < n_; ++j) {
                if (j != i) {
                    sectorSpecTerms_[i] +=
                        correlation_[i][j] *
                        std::sqrt(relativeDefaultVariance_[i] *
                                  relativeDefaultVariance_[j]) *
                        sectorEl_[j];
                }
            }
        }

        // compute synthetic standard deviation (formula 12 in [1])

        ul_ = 0.0;
        for (Size i = 0; i < n_; ++i) {
            sectorUl_[i] =
                relativeDefaultVariance_[i] * sectorEl_[i] * sectorEl_[i];
            ul_ += sectorUl_[i];
            for (Size j = 0; j < n_; ++j) {
                if (j != i) {
                    ul_ += correlation_[i][j] *
                           std::sqrt(relativeDefaultVariance_[i] *
                                     relativeDefaultVariance_[j]) *
                           sectorEl_[i] * sectorEl_[j];
                }
            }
        }

        Real matchUl_ = ul_; // formula 13 in [1], rhs
        for (Size k = 0; k < m_; ++k) {
            Real tmp = pd_[k] * exposure_[k] * exposure_[k];
            sectorUl_[sector_[k]] += tmp;
            ul_ += tmp;
        }
        ul_ = std::sqrt(ul_);
        for (Size i = 0; i < n_; ++i)
            sectorUl_[i] = std::sqrt(sectorUl_[i]);

        // compute risk contributions (formula 15 in [1])

        for (Size k = 0; k < m_; ++k) {
            marginalLoss_[k] = pd_[k] * exposure_[k] / ul_ *
                               (sectorSpecTerms_[sector_[k]] + exposure_[k]);
        }

        // compute sigmaC_ and deduced figures

        Real sigmaC_ = pdSum_ * sqrt(matchUl_ / (el_ * el_));
        Real alphaC_ = pdSum_ * pdSum_ / (sigmaC_ * sigmaC_);
        Real betaC_ = sigmaC_ * sigmaC_ / pdSum_;
        Real pC_ = betaC_ / (1.0 + betaC_);

        // compute loss distribution

        loss_.clear();
        loss_.push_back(std::pow(1.0 - pC_, alphaC_)); // A(0)

        Real res;
        for (unsigned long n = 0; n < upperIndex_ - 1; ++n) { // compute A(n+1)
                                                              // recursively
            res = 0.0;
            for (unsigned long j = 0;
                 j <= std::min<unsigned long>(maxNu_ - 1, n); ++j) {
                iter = epsNuC_.find(j + 1);
                if (iter != epsNuC_.end()) {
                    res += (*iter).second * loss_[n - j] * alphaC_;
                    if (j <= n - 1)
                        res += (*iter).second / ((Real)(j + 1)) *
                               ((Real)(n - j)) * loss_[n - j];
                }
            }
            loss_.push_back(res * pC_ / (pdSum_ * ((Real)(n + 1))));
        }
    }
}
]]></document_content>
  </document>
  <document index="448">
    <source>risk/creditriskplus.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2013 Peter Caspers

  This file is part of QuantLib, a free-software/open-source library
  for financial quantitative analysts and developers - http://quantlib.org/

  QuantLib is free software: you can redistribute it and/or modify it
  under the terms of the QuantLib license.  You should have received a
  copy of the license along with this program; if not, please email
  <quantlib-dev@lists.sf.net>. The license is also available online at
  <http://quantlib.org/license.shtml>.

  This program is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file creditriskplus.hpp
    \brief Extended CreditRisk+ Model
*/

#ifndef quantlib_creditriskplus_hpp
#define quantlib_creditriskplus_hpp

#include <ql/qldefines.hpp>
#include <ql/types.hpp>
#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    /*! Extended CreditRisk+ model as described in [1] Integrating Correlations, Risk,
      July 1999 and the references therein.

      \warning the input correlation matrix is not checked for positive
      definiteness

    */

    class CreditRiskPlus {

      public:
        CreditRiskPlus(std::vector<Real> exposure,
                       std::vector<Real> defaultProbability,
                       std::vector<Size> sector,
                       std::vector<Real> relativeDefaultVariance,
                       Matrix correlation,
                       Real unit);

        const std::vector<Real> &loss() { return loss_; }
        const std::vector<Real> &marginalLoss() { return marginalLoss_; }

        Real exposure() const { return exposureSum_; }
        Real expectedLoss() const { return el_; }
        Real unexpectedLoss() const { return ul_; }
        Real relativeDefaultVariance() const {
            return (unexpectedLoss() * unexpectedLoss() - el2_) /
                   (expectedLoss() * expectedLoss());
        }

        const std::vector<Real> &sectorExposures() const {
            return sectorExposure_;
        }
        const std::vector<Real> &sectorExpectedLoss() const {
            return sectorEl_;
        }
        const std::vector<Real> &sectorUnexpectedLoss() const {
            return sectorUl_;
        }

        Real lossQuantile(Real p);

      private:

        const std::vector<Real> exposure_;
        const std::vector<Real> pd_;
        const std::vector<Size> sector_;
        const std::vector<Real> relativeDefaultVariance_;
        const Matrix correlation_;
        const Real unit_;

        Size n_, m_; // number of sectors, exposures

        std::vector<Real> sectorExposure_, sectorEl_, sectorUl_, marginalLoss_,
            loss_;

        Real exposureSum_, el_, el2_, ul_;
        unsigned long upperIndex_;

        void compute();
    };
}

#endif
]]></document_content>
  </document>
  <document index="449">
    <source>risk/sensitivityanalysis.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/risk/sensitivityanalysis.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/instrument.hpp>

using std::vector;
using std::pair;

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             SensitivityAnalysis s) {
        switch (s) {
          case OneSide:
            return out << "OneSide";
          case Centered:
            return out << "Centered";
          default:
            QL_FAIL("unknown SensitivityAnalysis (" << Integer(s) << ")");
        }
    }

    Real aggregateNPV(const vector<ext::shared_ptr<Instrument> >& instruments,
                      const vector<Real>& quant) {
        Size n = instruments.size();
        Real npv = 0.0;
        if (quant.empty() || (quant.size()==1 && quant[0]==1.0)) {
            for (Size k=0; k<n; ++k)
                npv += instruments[k]->NPV();
        } else {
            QL_REQUIRE(quant.size()==n,
                       "dimension mismatch between instruments (" << n <<
                       ") and quantities (" << quant.size() << ")");
            for (Size k=0; k<n; ++k)
                npv += quant[k] * instruments[k]->NPV();
        }
        return npv;
    }

    pair<Real, Real>
    parallelAnalysis(const vector<Handle<SimpleQuote> >& quotes,
                     const vector<ext::shared_ptr<Instrument> >& instruments,
                     const vector<Real>& quantities,
                     Real shift,
                     SensitivityAnalysis type,
                     Real referenceNpv)
    {
        QL_REQUIRE(!quotes.empty(), "empty SimpleQuote vector");
        Size n = quotes.size();

        QL_REQUIRE(shift!=0.0, "zero shift not allowed");

        pair<Real, Real> result(0.0, 0.0);
        if (instruments.empty()) return result;

        if (referenceNpv==Null<Real>())
            referenceNpv = aggregateNPV(instruments, quantities);

        vector<Real> quoteValues(n, Null<Real>());
        for (Size i=0; i<n; ++i)
            if (quotes[i]->isValid())
                quoteValues[i] = quotes[i]->value();
        try {
            for (Size i=0; i<n; ++i)
                if (quotes[i]->isValid())
                    quotes[i]->setValue(quoteValues[i]+shift);
            Real npv = aggregateNPV(instruments, quantities);
            switch (type) {
              case OneSide:
                result.first = (npv-referenceNpv)/shift;
                result.second = Null<Real>();
                break;
              case Centered:
                {
                for (Size i=0; i<n; ++i)
                    if (quotes[i]->isValid())
                        quotes[i]->setValue(quoteValues[i]-shift);
                Real npv2 = aggregateNPV(instruments, quantities);
                result.first = (npv-npv2)/(2.0*shift);
                result.second = (npv-2.0*referenceNpv+npv2)/(shift*shift);
                }
                break;
              default:
                  QL_FAIL("unknown SensitivityAnalysis (" <<
                          Integer(type) << ")");
            }
            for (Size i=0; i<n; ++i)
                if (quotes[i]->isValid())
                    quotes[i]->setValue(quoteValues[i]);
        } catch (...) {
            for (Size i=0; i<n; ++i)
                if (quoteValues[i]!=Null<Real>())
                    quotes[i]->setValue(quoteValues[i]);
            throw;
        }

        return result;
    }

    pair<Real, Real> bucketAnalysis(const Handle<SimpleQuote>& quote,
                                    const vector<ext::shared_ptr<Instrument> >& instruments,
                                    const vector<Real>& quantities,
                                    Real shift,
                                    SensitivityAnalysis type,
                                    Real referenceNpv) {
        QL_REQUIRE(shift!=0.0, "zero shift not allowed");

        pair<Real, Real> result(0.0, 0.0);
        if (instruments.empty()) return result;

        if (referenceNpv==Null<Real>())
            referenceNpv = aggregateNPV(instruments, quantities);

        if (!quote->isValid()) return result;
        Real quoteValue = quote->value();

        try {
            quote->setValue(quoteValue+shift);
            Real npv = aggregateNPV(instruments, quantities);
            switch (type) {
              case OneSide:
                result.first = (npv-referenceNpv)/shift;
                result.second = Null<Real>();
                break;
              case Centered:
                {
                quote->setValue(quoteValue-shift);
                Real npv2 = aggregateNPV(instruments, quantities);
                result.first = (npv-npv2)/(2.0*shift);
                result.second = (npv-2.0*referenceNpv+npv2)/(shift*shift);
                }
                break;
              default:
                  QL_FAIL("unknown SensitivityAnalysis (" <<
                          Integer(type) << ")");
            }
            quote->setValue(quoteValue);
        } catch (...) {
            quote->setValue(quoteValue);
            throw;
        }

        return result;
    }


    void bucketAnalysis(vector<Real>& deltaVector, // delta result
                        vector<Real>& gammaVector, // gamma result
                        vector<Real>& refVals,
                        const Handle<SimpleQuote>& quote,
                        const vector<Handle<Quote> >& params,
                        Real shift,
                        SensitivityAnalysis type) {
        QL_REQUIRE(shift!=0.0, "zero shift not allowed");

        QL_REQUIRE(!params.empty(), "empty parameters vector");
        Size m = params.size();
        deltaVector.resize(m);
        gammaVector.resize(m);

        if (!quote->isValid()) {
            for (Size j=0; j<m; ++j) {
                deltaVector[j]=Null<Real>();
                gammaVector[j]=Null<Real>();
            }
            return;
        }
        Real quoteValue = quote->value();

        if (!refVals.empty()) {
            QL_REQUIRE(refVals.size()==m,
                       "referenceValues has size " <<
                       refVals.size() << ", instead of " << m);
        } else {
            // calculate parameters' reference values
            refVals = vector<Real>(m, Null<Real>());
            for (Size j=0; j<m; ++j) {
                if (params[j]->isValid()) // fault tolerant
                    refVals[j] = params[j]->value();
            }
        }

        try {
            switch (type) {
              case OneSide:
                {
                    quote->setValue(quoteValue+shift);
                    for (Size j=0; j<m; ++j) {
                        gammaVector[j] = Null<Real>();
                        if (refVals[j] != Null<Real>())
                            deltaVector[j] = (params[j]->value()-refVals[j])/shift;
                        else
                            deltaVector[j] = Null<Real>();
                    }
                }
                break;
              case Centered:
                {
                    quote->setValue(quoteValue+shift);
                    vector<Real> plus(m);
                    for (Size j=0; j<m; ++j) {
                        if (refVals[j] != Null<Real>())
                            plus[j] = params[j]->value();
                    }
                    quote->setValue(quoteValue-shift);
                    for (Size j=0; j<m; ++j) {
                        if (refVals[j] != Null<Real>()) {
                            Real minus = params[j]->value();
                            deltaVector[j] = (plus[j]-minus)/(2.0*shift);
                            gammaVector[j] = (plus[j]-2.0*refVals[j]+minus)/(shift*shift);
                        } else {
                            deltaVector[j] = Null<Real>();
                            gammaVector[j] = Null<Real>();
                        }
                    }
                }
                break;
              default:
                  QL_FAIL("unknown SensitivityAnalysis (" <<
                          Integer(type) << ")");
            } // end switch

            // restore the quote to its original state
            quote->setValue(quoteValue);

            return;
        } catch (...) {
            // restore the quote to its original state
            quote->setValue(quoteValue);
            throw;
        }

    }





    pair<vector<Real>, vector<Real> >
    bucketAnalysis(const vector<Handle<SimpleQuote> >& quotes,
                   const vector<ext::shared_ptr<Instrument> >& instr,
                   const vector<Real>& quant,
                   Real shift,
                   SensitivityAnalysis type)
    {
        QL_REQUIRE(!quotes.empty(), "empty SimpleQuote vector");
        Size n = quotes.size();
        pair<vector<Real>, vector<Real> > result(vector<Real>(n, 0.0),
                                                 vector<Real>(n, 0.0));

        if (instr.empty()) return result;

        Real npv = aggregateNPV(instr, quant);

        pair<Real, Real> tmp;
        for (Size i=0; i<n; ++i) {
            tmp = bucketAnalysis(quotes[i], instr, quant, shift, type, npv);
            result.first[i] = tmp.first;
            result.second[i] = tmp.second;
        }

        return result;
    }

    void
    bucketAnalysis(std::vector<std::vector<Real> >& deltaMatrix, // result
                   std::vector<std::vector<Real> >& gammaMatrix, // result
                   const vector<Handle<SimpleQuote> >& quotes,
                   const vector<Handle<Quote> >& parameters,
                   Real shift,
                   SensitivityAnalysis type)
    {
        QL_REQUIRE(!quotes.empty(), "empty SimpleQuote vector");
        QL_REQUIRE(!parameters.empty(), "empty parameters vector");

        Size n = quotes.size();
        deltaMatrix.resize(n);
        gammaMatrix.resize(n);

        Size m = parameters.size();
        vector<Real> referenceValues(m, Null<Real>());
        for (Size i=0; i<m; ++i) {
            if (parameters[i]->isValid())
                referenceValues[i] = parameters[i]->value();
        }

        for (Size i=0; i<n; ++i) {
            bucketAnalysis(deltaMatrix[i], gammaMatrix[i], referenceValues,
                           quotes[i], parameters, shift, type);
        }
    }

    pair<vector<vector<Real> >, vector<vector<Real> > >
    bucketAnalysis(const vector<vector<Handle<SimpleQuote> > >& quotes,
                   const vector<ext::shared_ptr<Instrument> >& instr,
                   const vector<Real>& quant,
                   Real shift,
                   SensitivityAnalysis type)
    {
        QL_REQUIRE(!quotes.empty(), "empty SimpleQuote range");
        Size n = quotes.size();
        vector<vector<Real> > first(n);
        vector<vector<Real> > second(n);
        for (Size i=0; i<n; ++i) {
            Size tmp = quotes[i].size();
            first[i] = vector<Real>(tmp, 0.0);
            second[i] = vector<Real>(tmp, 0.0);
        }

        pair<vector<vector<Real> >, vector<vector<Real> > >
            result(first, second);

        if (instr.empty()) return result;

        Real npv = aggregateNPV(instr, quant);

        pair<Real, Real> tmp;
        for (Size i=0; i<n; ++i) {
          for (Size j=0; j<quotes[i].size(); ++j) {
            tmp = bucketAnalysis(quotes[i][j], instr, quant, shift, type, npv);
            result.first[i][j] = tmp.first;
            result.second[i][j] = tmp.second;
          }
        }

        return result;
    }

}
]]></document_content>
  </document>
  <document index="450">
    <source>risk/sensitivityanalysis.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2010 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sensitivityanalysis.hpp
    \brief sensitivity analysis function
*/

#ifndef quantlib_sensitivity_analysis_hpp
#define quantlib_sensitivity_analysis_hpp

#include <ql/types.hpp>
#include <ql/utilities/null.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    template <class T>
    class Handle;
    class Quote;
    class SimpleQuote;
    class Instrument;

    //! Finite differences calculation
    enum SensitivityAnalysis {
        OneSide, /*!<  */
        Centered /*!<  */
    };

    /*! \relates SensitivityAnalysis */
    std::ostream& operator<<(std::ostream&,
                             SensitivityAnalysis);

    //! utility fuction for weighted sum of NPVs
    Real aggregateNPV(const std::vector<ext::shared_ptr<Instrument> >&,
                      const std::vector<Real>& quantities);

    //! parallel shift PV01 sensitivity analysis for a SimpleQuote vector
    /*! returns a pair of first and second derivative values calculated as
        prescribed by SensitivityAnalysis. Second derivative might not be
        available depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is just one single element equal to one.

        All SimpleQuotes are tweaked together in a parallel fashion.
    */
    std::pair<Real, Real>
    parallelAnalysis(const std::vector<Handle<SimpleQuote> >&,
                     const std::vector<ext::shared_ptr<Instrument> >&,
                     const std::vector<Real>& quantities,
                     Real shift = 0.0001,
                     SensitivityAnalysis type = Centered,
                     Real referenceNpv = Null<Real>());

    //! parallel shift PV01 sensitivity analysis for a SimpleQuote matrix
    /*! returns a pair of first and second derivative values calculated as
        prescribed by SensitivityAnalysis. Second derivative might not be
        available depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is of size one.

        All SimpleQuotes are tweaked together in a parallel fashion.
    */
    std::pair<Real, Real>
    parallelAnalysis(const std::vector<std::vector<Handle<SimpleQuote> > >&,
                     const std::vector<ext::shared_ptr<Instrument> >&,
                     const std::vector<Real>& quantities,
                     Real shift = 0.0001,
                     SensitivityAnalysis type = Centered,
                     Real referenceNpv = Null<Real>());

    //! (bucket) PV01 sensitivity analysis for a (single) SimpleQuote
    /*! returns a pair of first and second derivative values calculated as
        prescribed by SensitivityAnalysis. Second derivative might not be
        available depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is of size one.
    */
    std::pair<Real, Real> bucketAnalysis(const Handle<SimpleQuote>& quote,
                                         const std::vector<ext::shared_ptr<Instrument> >&,
                                         const std::vector<Real>& quantities,
                                         Real shift = 0.0001,
                                         SensitivityAnalysis type = Centered,
                                         Real referenceNpv = Null<Real>());

    //! (bucket) parameters' sensitivity analysis for a (single) SimpleQuote
    /*! returns a vector (one element for each paramet) of pair of first and
        second derivative values calculated as prescribed by
        SensitivityAnalysis. Second derivative might not be available
        depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is of size one.
    */
    void bucketAnalysis(std::vector<Real>& deltaVector, // result
                        std::vector<Real>& gammaVector, // result
                        std::vector<Real>& referenceValues,
                        const Handle<SimpleQuote>& quote,
                        const std::vector<Handle<Quote> >& parameters,
                        Real shift = 0.0001,
                        SensitivityAnalysis type = Centered);

    //! bucket PV01 sensitivity analysis for a SimpleQuote vector
    /*! returns a pair of first and second derivative vectors calculated as
        prescribed by SensitivityAnalysis. Second derivative might not be
        available depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is of size one.

        The (bucket) SimpleQuotes are tweaked one by one separately.
    */
    std::pair<std::vector<Real>, std::vector<Real> >
    bucketAnalysis(const std::vector<Handle<SimpleQuote> >& quotes,
                   const std::vector<ext::shared_ptr<Instrument> >&,
                   const std::vector<Real>& quantities,
                   Real shift = 0.0001,
                   SensitivityAnalysis type = Centered);

    //! bucket parameters' sensitivity analysis for a SimpleQuote vector
    /*! returns a vector (one element for each paramet) of pair of first and
        second derivative vectors calculated as prescribed by
        SensitivityAnalysis. Second derivative might not be available
        depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is of size one.

        The (bucket) SimpleQuotes are tweaked one by one separately.
    */
    void
    bucketAnalysis(std::vector<std::vector<Real> >& deltaMatrix, // result
                   std::vector<std::vector<Real> >& gammaMatrix, // result
                   const std::vector<Handle<SimpleQuote> >& quotes,
                   const std::vector<Handle<Quote> >& parameters,
                   Real shift = 0.0001,
                   SensitivityAnalysis type = Centered);


    //! bucket sensitivity analysis for a SimpleQuote matrix
    /*! returns a pair of first and second derivative metrices calculated as
        prescribed by SensitivityAnalysis. Second derivative might not be
        available depending on SensitivityAnalysis value.

        Empty quantities vector is considered as unit vector. The same if
        the vector is of size one.

        The (bucket) SimpleQuotes are tweaked one by one separately.
    */
    std::pair<std::vector<std::vector<Real> >, std::vector<std::vector<Real> > >
    bucketAnalysis(const std::vector<std::vector<Handle<SimpleQuote> > >&,
                   const std::vector<ext::shared_ptr<Instrument> >&,
                   const std::vector<Real>& quantities,
                   Real shift = 0.0001,
                   SensitivityAnalysis type = Centered);

}

#endif
]]></document_content>
  </document>
  <document index="451">
    <source>shortrate/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    generalizedhullwhite.hpp \
    generalizedornsteinuhlenbeckprocess.hpp

cpp_files = \
    generalizedhullwhite.cpp \
    generalizedornsteinuhlenbeckprocess.cpp

if UNITY_BUILD

nodist_libShortRate_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libShortRate_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libShortRate.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="452">
    <source>shortrate/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/shortrate/generalizedhullwhite.hpp>
#include <ql/experimental/shortrate/generalizedornsteinuhlenbeckprocess.hpp>

]]></document_content>
  </document>
  <document index="453">
    <source>shortrate/generalizedhullwhite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 SunTrust Bank
 Copyright (C) 2010, 2014 Cavit Hafizoglu

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/shortrate/generalizedhullwhite.hpp>
#include <ql/math/integrals/simpsonintegral.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        // integral of mean reversion
        Real integrateMeanReversion(const Interpolation &a,Real t,Real T) {
            if ((T-t) < QL_EPSILON)
                return 0.0;
            SimpsonIntegral integrator(1e-5, 1000);
            Real mr = integrator(a,t,T);
            return mr;
        }

    }

    /* Private function used by solver to determine time-dependent parameter
       df(r) = [theta(t) - a(t) f(r)]dt + sigma(t) dz
       dg = [theta(t) - a(t) g(t)] dt
       dx = -a(t) x dt + sigma(t) dz
       x = f(r) - g(t)
    */
    class GeneralizedHullWhite::Helper {
      public:
        Helper(const Size i,
               const Real xMin,
               const Real dx,
               const Real discountBondPrice,
               const ext::shared_ptr<ShortRateTree>& tree,
               ext::function<Real(Real)> fInv)
        : size_(tree->size(i)), dt_(tree->timeGrid().dt(i)), xMin_(xMin), dx_(dx),
          statePrices_(tree->statePrices(i)), discountBondPrice_(discountBondPrice),
          fInverse_(std::move(fInv)) {}

        Real operator()(const Real theta) const {
            Real value = discountBondPrice_;
            Real x = xMin_;
            for (Size j=0; j<size_; j++) {
                Real discount = std::exp(- fInverse_(theta+x)*dt_);
                value -= statePrices_[j]*discount;
                x += dx_;
            }
            return value;
        };

      private:
        Size size_;
        Time dt_;
        Real xMin_, dx_;
        const Array& statePrices_;
        Real discountBondPrice_;
        ext::function<Real(Real)> fInverse_;
    };

    GeneralizedHullWhite::GeneralizedHullWhite(
        const Handle<YieldTermStructure>& yieldtermStructure,
        const std::vector<Date>& speedstructure,
        const std::vector<Date>& volstructure,
        const std::vector<Real>& speed,
        const std::vector<Real>& vol,
        const ext::function<Real(Real)>& f,
        const ext::function<Real(Real)>& fInverse)
    : OneFactorAffineModel(2), TermStructureConsistentModel(yieldtermStructure),
      speedstructure_(speedstructure),
      volstructure_(volstructure),
      a_(arguments_[0]), sigma_(arguments_[1]),
      f_(f), fInverse_(fInverse) {

        LinearFlat traits;
        initialize(yieldtermStructure,speedstructure,volstructure,
          speed, vol, traits, traits, f, fInverse);
    }

    //classical HW
    GeneralizedHullWhite::GeneralizedHullWhite(
        const Handle<YieldTermStructure>& yieldtermStructure,
        Real a, Real sigma)
    : OneFactorAffineModel(2),
      TermStructureConsistentModel(yieldtermStructure),
      a_(arguments_[0]),
      sigma_(arguments_[1])
    {
        Date ref = yieldtermStructure->referenceDate();
        std::vector<Date> speedstructure,volstructure;
        std::vector<Real> _a, _sigma;
        _a.push_back(a);
        _sigma.push_back(sigma);
        speedstructure.push_back(ref);
        volstructure.push_back(ref);
        BackwardFlat traits;
        initialize(yieldtermStructure,speedstructure,volstructure,
            _a, _sigma, traits, traits, identity, identity);
    }

    void GeneralizedHullWhite::generateArguments() {
        speed_.update();
        vol_.update();
        phi_ = FittingParameter(termStructure(), a(), sigma());
    }

    Real GeneralizedHullWhite::B(Time t, Time T) const {
        // Gurrieri et al, equations (30) and (31)
        Real lnEt = integrateMeanReversion(speed_,0,t);
        Real Et = exp(lnEt);
        Real B = 0;
        Size N = std::min<Size>(Size((T-t)*365), 2000);
        if (N==0) N=1;
        Real dt = 0.5*(T-t)/N;
        Real a,b,c,_t,total=0;
        _t = t;
        c = speed_(_t);
        _t += dt;
        for (Size i=0; i<N; i++) {
            a = c;
            b = speed_(_t);
            c = speed_(_t+dt);
            total += (dt*(2.0/6.0))*(a+4*b+c);
            B += (2*dt) / exp(lnEt+total);
            _t += 2*dt;
        }
        B *= Et;
        return B;
    }

    Real GeneralizedHullWhite::V(Time t, Time T) const {
        // Gurrieri et al, equation (37)
        Real lnEt = integrateMeanReversion(speed_,0,t);
        Real V = 0,Eu;
        Size N = std::min<Size>(Size((T-t)*365), 2000);
        if (N==0) N=1;
        Real dt = 0.5*(T-t)/N;
        Real a,b,c,_t,lnE=lnEt;
        _t = t;
        Real vol = vol_(_t);
        Eu = exp(lnE);
        c = Eu*Eu*vol*vol;
        _t += dt;
        for (Size i=0; i<N; i++) {
            a = c;
            vol = vol_(_t);
            lnE += speed_(_t)*dt;
            Eu = exp(lnE);
            b = Eu*Eu*vol*vol;
            vol = vol_(_t+dt);
            lnE += speed_(_t+dt)*dt;
            Eu = exp(lnE);
            c = Eu*Eu*vol*vol;
            V += (dt*(2.0/6.0))*(a+4*b+c);
            _t += 2*dt;
        }
        return V / (Eu*Eu);
    }

    Real GeneralizedHullWhite::discountBondOption(Option::Type type, Real strike,
                                                  Time maturity,
                                                  Time bondMaturity) const
    {
        /*
        Hull-White bond option pricing with time varying sigma and mean reversion.
        Based on Gurrieri, Nakabayashi & Wong (2009) "Calibration Methods of
        Hull-White Model", https://ssrn.com/abstract=1514192
        */
        Real BtT = B(maturity,bondMaturity);
        Real Vr = V(0,maturity);
        Real Vp = Vr*BtT*BtT;
        Real vol = sqrt(Vp);
        Real f = termStructure()->discount(bondMaturity);
        Real k = termStructure()->discount(maturity)*strike;
        return blackFormula(type, k, f, vol);
    }

    Real GeneralizedHullWhite::A(Time t, Time T) const {
        // Gurrieri et al, equation (43)
        DiscountFactor discount1 = termStructure()->discount(t);
        DiscountFactor discount2 = termStructure()->discount(T);
        Rate forward = termStructure()->forwardRate(t, t, Continuous, NoFrequency);
        Real BtT = B(t,T);
        Real Vr = V(0,t);
        Real AtT = log(discount2/discount1) + BtT*forward - 0.5*BtT*BtT*Vr;
        return exp(AtT);
    }


    ext::shared_ptr<Lattice> GeneralizedHullWhite::tree(
                                                  const TimeGrid& grid) const{

        TermStructureFittingParameter phi(termStructure());
        ext::shared_ptr<ShortRateDynamics> numericDynamics(
            new Dynamics(phi, speed(), vol(), f_, fInverse_));
        ext::shared_ptr<TrinomialTree> trinomial(
            new TrinomialTree(numericDynamics->process(), grid));
        ext::shared_ptr<ShortRateTree> numericTree(
            new ShortRateTree(trinomial, numericDynamics, grid));
        typedef TermStructureFittingParameter::NumericalImpl NumericalImpl;
        ext::shared_ptr<NumericalImpl> impl =
            ext::dynamic_pointer_cast<NumericalImpl>(phi.implementation());

        impl->reset();
        Real value = 1.0;
        Real vMin = -50.0;
        Real vMax = 50.0;

        for (Size i=0; i<(grid.size() - 1); i++) {
            Real discountBond = termStructure()->discount(grid[i+1]);
            Real xMin = trinomial->underlying(i, 0);
            Real dx = trinomial->dx(i);
            Helper finder(i, xMin, dx, discountBond, numericTree, fInverse_);
            Brent s1d;
            s1d.setMaxEvaluations(2000);
            value =s1d.solve(finder, 1e-8, value, vMin, vMax);
            impl->set(grid[i], value);
        }

        return numericTree;
    }

    ext::function<Real (Time)> GeneralizedHullWhite::speed() const {
        return speed_;
    }

    ext::function<Real (Time)> GeneralizedHullWhite::vol() const {
        return vol_;
    }

    //! vector to pass to 'calibrate' to fit only volatility
    std::vector<bool> GeneralizedHullWhite::fixedReversion() const {
        Size na = a_.params().size();
        Size nsigma = sigma_.params().size();
        std::vector<bool> fixr(na+nsigma,false);
        std::fill(fixr.begin(),fixr.begin()+na,true);
        return fixr;
    }

}
]]></document_content>
  </document>
  <document index="454">
    <source>shortrate/generalizedhullwhite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 SunTrust Bank
 Copyright (C) 2010, 2014 Cavit Hafizoglu

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file generalizedhullwhite.hpp
    \brief generalized Hull-White model
*/

#ifndef quantlib_generalized_hull_white_hpp
#define quantlib_generalized_hull_white_hpp

#include <ql/experimental/shortrate/generalizedornsteinuhlenbeckprocess.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Parameter that holds an interpolation object
    class InterpolationParameter : public Parameter {
    private:
        class Impl : public Parameter::Impl {
        public:
          Real value(const Array&, Time t) const override { return interpolator_(t); }
          void reset(const Interpolation& interp) { interpolator_ = interp; }
        private:
            Interpolation interpolator_;
        };
    public:
        explicit InterpolationParameter(
            Size count,
            const Constraint& constraint = NoConstraint())
        : Parameter(count,
            ext::shared_ptr<Parameter::Impl>(
                new InterpolationParameter::Impl()),
                constraint)
        { }
        void reset(const Interpolation &interp) {
            ext::shared_ptr<InterpolationParameter::Impl> impl =
                ext::dynamic_pointer_cast<InterpolationParameter::Impl>(impl_);
            if (impl != nullptr)
                impl->reset(interp);
        }
    };

    //! Generalized Hull-White model class.
    /*! This class implements the standard Black-Karasinski model defined by
        \f[
        d f(r_t) = (\theta(t) - \alpha f(r_t))dt + \sigma dW_t,
        \f]
        where \f$ alpha \f$ and \f$ sigma \f$ are piecewise linear functions.

        \ingroup shortrate
    */
    class GeneralizedHullWhite : public OneFactorAffineModel,
                                 public TermStructureConsistentModel {
      public:

        GeneralizedHullWhite(
            const Handle<YieldTermStructure>& yieldtermStructure,
            const std::vector<Date>& speedstructure,
            const std::vector<Date>& volstructure,
            const std::vector<Real>& speed,
            const std::vector<Real>& vol,
            const ext::function<Real(Real)>& f =
                                            ext::function<Real(Real)>(),
            const ext::function<Real(Real)>& fInverse =
                                            ext::function<Real(Real)>());

        template <class SpeedInterpolationTraits,class VolInterpolationTraits>
        GeneralizedHullWhite(
            const Handle<YieldTermStructure>& yieldtermStructure,
            const std::vector<Date>& speedstructure,
            const std::vector<Date>& volstructure,
            const std::vector<Real>& speed,
            const std::vector<Real>& vol,
            const SpeedInterpolationTraits &speedtraits,
            const VolInterpolationTraits &voltraits,
            const ext::function<Real(Real)>& f =
                                            ext::function<Real(Real)>(),
            const ext::function<Real(Real)>& fInverse =
                                            ext::function<Real(Real)>()) :
            OneFactorAffineModel(2), TermStructureConsistentModel(yieldtermStructure),
            speedstructure_(speedstructure), volstructure_(volstructure),
            a_(arguments_[0]), sigma_(arguments_[1]),
            f_(f), fInverse_(fInverse)
        {
            initialize(yieldtermStructure,speedstructure,volstructure,
                speed,vol,speedtraits,voltraits,f,fInverse);
        }

        ext::shared_ptr<ShortRateDynamics> dynamics() const override {
            QL_FAIL("no defined process for generalized Hull-White model, "
                    "use HWdynamics()");
        }

        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;

        //Analytical calibration of HW

        GeneralizedHullWhite(
                  const Handle<YieldTermStructure>& yieldtermStructure,
                  Real a = 0.1, Real sigma = 0.01);


        ext::shared_ptr<ShortRateDynamics> HWdynamics() const;

        //! Only valid under Hull-White model
        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondMaturity) const override;

        //! vector to pass to 'calibrate' to fit only volatility
        std::vector<bool> fixedReversion() const;

      protected:
        //Analytical calibration of HW
        Real a() const { return a_(0.0); }
        Real sigma() const { return sigma_(0.0); }
        void generateArguments() override;
        Real A(Time t, Time T) const override;
        Real B(Time t, Time T) const override;
        Real V(Time t, Time T) const;

      private:

        class Dynamics;
        class Helper;
        class FittingParameter;// for analytic HW fitting

        std::vector<Date> speedstructure_;
        std::vector<Date> volstructure_;
        std::vector<Time> speedperiods_;
        std::vector<Time> volperiods_;
        Interpolation speed_;
        Interpolation vol_;

        ext::function<Real (Time)> speed() const;
        ext::function<Real (Time)> vol() const;

        Parameter& a_;
        Parameter& sigma_;
        Parameter phi_;

        ext::function<Real(Real)> f_;
        ext::function<Real(Real)> fInverse_;

        static Real identity(Real x) {
            return x;
        }

        template <class SpeedInterpolationTraits,class VolInterpolationTraits>
        void initialize(const Handle<YieldTermStructure>& yieldtermStructure,
            const std::vector<Date>& speedstructure,
            const std::vector<Date>& volstructure,
            const std::vector<Real>& speed,
            const std::vector<Real>& vol,
            const SpeedInterpolationTraits &speedtraits,
            const VolInterpolationTraits &voltraits,
            const ext::function<Real(Real)>& f,
            const ext::function<Real(Real)>& fInverse)
        {
            QL_REQUIRE(speedstructure.size()==speed.size(),
                "mean reversion inputs inconsistent");
            QL_REQUIRE(volstructure.size()==vol.size(),
                "volatility inputs inconsistent");
            if (!f_)
                f_ = identity;
            if (!fInverse_)
                fInverse_ = identity;

            DayCounter dc = yieldtermStructure->dayCounter();
            Date ref = yieldtermStructure->referenceDate();
            for (auto i : speedstructure)
                speedperiods_.push_back(dc.yearFraction(ref, i));
            for (auto i : volstructure)
                volperiods_.push_back(dc.yearFraction(ref, i));

            // interpolator x points to *periods_ vector, y points to
            // the internal Array in the parameter
            InterpolationParameter atemp(speedperiods_.size(), NoConstraint());
            a_ = atemp;
            for (Size i=0; i<speedperiods_.size(); i++)
                a_.setParam(i, speed[i]);
            speed_ = speedtraits.interpolate(speedperiods_.begin(),
                speedperiods_.end(),a_.params().begin());
            speed_.enableExtrapolation();
            atemp.reset(speed_);

            InterpolationParameter sigmatemp(volperiods_.size(), PositiveConstraint());
            sigma_ = sigmatemp;
            for (Size i=0; i<volperiods_.size(); i++)
                sigma_.setParam(i, vol[i]);
            vol_ = voltraits.interpolate(volperiods_.begin(),
                volperiods_.end(),sigma_.params().begin());
            vol_.enableExtrapolation();
            sigmatemp.reset(vol_);

            generateArguments();
            registerWith(yieldtermStructure);
        }
    };

    //! Short-rate dynamics in the generalized Hull-White model
    /*! The short-rate is here

        f(r_t) = x_t + g(t)

        where g is the deterministic time-dependent
        parameter (which can't be determined analytically)
        used for initial term-structure fitting and  x_t is the state
        variable following an Ornstein-Uhlenbeck process.

        In this version, the function f may also be defined as a piece-wise linear
        function and can be calibrated to the away-from-the-money instruments.

    */
    class GeneralizedHullWhite::Dynamics
        : public GeneralizedHullWhite::ShortRateDynamics {
      public:
        Dynamics(Parameter fitting,
                 const ext::function<Real(Time)>& alpha,
                 const ext::function<Real(Time)>& sigma,
                 ext::function<Real(Real)> f,
                 ext::function<Real(Real)> fInverse)
        : ShortRateDynamics(ext::shared_ptr<StochasticProcess1D>(
              new GeneralizedOrnsteinUhlenbeckProcess(alpha, sigma))),
          fitting_(std::move(fitting)), _f_(std::move(f)), _fInverse_(std::move(fInverse)) {}

        //classical HW dynamics
        Dynamics(Parameter fitting, Real a, Real sigma)
        : GeneralizedHullWhite::ShortRateDynamics(
              ext::shared_ptr<StochasticProcess1D>(new OrnsteinUhlenbeckProcess(a, sigma))),
          fitting_(std::move(fitting)), _f_(identity()), _fInverse_(identity()) {}

        Real variable(Time t, Rate r) const override { return _f_(r) - fitting_(t); }

        Real shortRate(Time t, Real x) const override { return _fInverse_(x + fitting_(t)); }

      private:
        Parameter fitting_;
        ext::function<Real(Real)> _f_;
        ext::function<Real(Real)> _fInverse_;
        struct identity {
            Real operator()(Real x) const {return x;};
        };
    };

    //! Analytical term-structure fitting parameter \f$ \varphi(t) \f$.
    /*! \f$ \varphi(t) \f$ is analytically defined by
        \f[
            \varphi(t) = f(t) + \frac{1}{2}[\frac{\sigma(1-e^{-at})}{a}]^2,
        \f]
        where \f$ f(t) \f$ is the instantaneous forward rate at \f$ t \f$.
    */
    class GeneralizedHullWhite::FittingParameter
        : public TermStructureFittingParameter {
      private:
        class Impl : public Parameter::Impl {
          public:
            Impl(Handle<YieldTermStructure> termStructure, Real a, Real sigma)
            : termStructure_(std::move(termStructure)), a_(a), sigma_(sigma) {}

            Real value(const Array&, Time t) const override {
                Rate forwardRate =
                    termStructure_->forwardRate(t, t, Continuous, NoFrequency);
                Real temp = a_ < std::sqrt(QL_EPSILON) ?
                            sigma_*t :
                            sigma_*(1.0 - std::exp(-a_*t))/a_;
                return (forwardRate + 0.5*temp*temp);
            }

          private:
            Handle<YieldTermStructure> termStructure_;
            Real a_, sigma_;
        };
      public:
        FittingParameter(const Handle<YieldTermStructure>& termStructure,
                         Real a, Real sigma)
        : TermStructureFittingParameter(ext::shared_ptr<Parameter::Impl>(
                      new FittingParameter::Impl(termStructure, a, sigma))) {}
    };

    // Analytic fitting dynamics
    inline ext::shared_ptr<OneFactorModel::ShortRateDynamics>
    GeneralizedHullWhite::HWdynamics() const {
        return ext::shared_ptr<ShortRateDynamics>(
          new Dynamics(phi_, a(), sigma()));
    }

    namespace detail {
        template <class I1, class I2>
        class LinearFlatInterpolationImpl;
    }

    //! %Linear interpolation between discrete points with flat extapolation
    /*! \ingroup interpolations */
    class LinearFlatInterpolation : public Interpolation {
      public:
        /*! \pre the \f$ x \f$ values must be sorted. */
        template <class I1, class I2>
        LinearFlatInterpolation(const I1& xBegin, const I1& xEnd,
                            const I2& yBegin) {
            impl_ = ext::shared_ptr<Interpolation::Impl>(new
                detail::LinearFlatInterpolationImpl<I1,I2>(xBegin, xEnd,
                                                       yBegin));
            impl_->update();
        }
    };

    //! %Linear-interpolation with flat-extrapolation factory and traits
    /*! \ingroup interpolations */
    class LinearFlat {
      public:
        template <class I1, class I2>
        Interpolation interpolate(const I1& xBegin, const I1& xEnd,
                                  const I2& yBegin) const {
            return LinearFlatInterpolation(xBegin, xEnd, yBegin);
        }
        static const bool global = false;
        static const Size requiredPoints = 1;
    };

    namespace detail {
        template <class I1, class I2>
        class LinearFlatInterpolationImpl
            : public Interpolation::templateImpl<I1,I2> {
          public:
            LinearFlatInterpolationImpl(const I1& xBegin, const I1& xEnd,
                                    const I2& yBegin)
            : Interpolation::templateImpl<I1,I2>(xBegin, xEnd, yBegin,
                                    LinearFlat::requiredPoints),
              primitiveConst_(xEnd-xBegin), s_(xEnd-xBegin) {}
            void update() override {
                primitiveConst_[0] = 0.0;
                for (Size i=1; i<Size(this->xEnd_-this->xBegin_); ++i) {
                    Real dx = this->xBegin_[i]-this->xBegin_[i-1];
                    s_[i-1] = (this->yBegin_[i]-this->yBegin_[i-1])/dx;
                    primitiveConst_[i] = primitiveConst_[i-1]
                        + dx*(this->yBegin_[i-1] +0.5*dx*s_[i-1]);
                }
            }
            Real value(Real x) const override {
                if (x <= this->xMin())
                    return this->yBegin_[0];
                if (x >= this->xMax())
                    return *(this->yBegin_+(this->xEnd_-this->xBegin_)-1);
                Size i = this->locate(x);
                return this->yBegin_[i] + (x-this->xBegin_[i])*s_[i];
            }
            Real primitive(Real x) const override {
                Size i = this->locate(x);
                Real dx = x-this->xBegin_[i];
                return primitiveConst_[i] +
                    dx*(this->yBegin_[i] + 0.5*dx*s_[i]);
            }
            Real derivative(Real x) const override {
                if (!this->isInRange(x))
                    return 0;
                Size i = this->locate(x);
                return s_[i];
            }
            Real secondDerivative(Real) const override { return 0.0; }

          private:
            std::vector<Real> primitiveConst_, s_;
        };
    }

}


#endif
]]></document_content>
  </document>
  <document index="455">
    <source>shortrate/generalizedornsteinuhlenbeckprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 SunTrust Bank
 Copyright (C) 2010 Cavit Hafizoglu

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/shortrate/generalizedornsteinuhlenbeckprocess.hpp>
#include <utility>

namespace QuantLib {

    GeneralizedOrnsteinUhlenbeckProcess::GeneralizedOrnsteinUhlenbeckProcess(
        ext::function<Real(Time)> speed, ext::function<Real(Time)> vol, Real x0, Real level)
    : x0_(x0), level_(level), speed_(std::move(speed)), volatility_(std::move(vol)) {

        QL_REQUIRE(x0 >= 0.0, "negative initial data given");
        QL_REQUIRE(level >= 0.0, "negative level given");
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::x0() const {
        return x0_;
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::drift(Time t, Real x) const {
        return speed_(t) * (level_ - x);;
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::diffusion(Time t, Real) const {
        return volatility_(t);
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::expectation(
                                             Time t, Real x0, Time dt) const {
        return level_ + (x0 - level_) * std::exp(-speed_(t)*dt);
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::stdDeviation(
                                             Time t, Real x0, Time dt) const {
        return std::sqrt(variance(t,x0,dt));
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::variance(
                                              Time t, Real, Time dt) const {
        Real speed = speed_(t);
        Volatility vol = volatility_(t);

        if (speed < std::sqrt(QL_EPSILON)) {
            // algebraic limit for small speed
            return vol*vol*dt;
        } else {
            return 0.5*vol*vol/speed*(1.0 - std::exp(-2.0*speed*dt));
        }
    }


    Real GeneralizedOrnsteinUhlenbeckProcess::speed(Time t) const {
        return speed_(t);
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::volatility(Time t) const {
        return volatility_(t);
    }

    Real GeneralizedOrnsteinUhlenbeckProcess::level() const {
        return level_;
    }

}

]]></document_content>
  </document>
  <document index="456">
    <source>shortrate/generalizedornsteinuhlenbeckprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 SunTrust Bank
 Copyright (C) 2010 Cavit Hafizoglu

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file generalizedornsteinuhlenbeckprocess.hpp
    \brief Ornstein-Uhlenbeck process with piecewise linear coefficients
*/

#ifndef quantlib_generalized_ornstein_uhlenbeck_process_hpp
#define quantlib_generalized_ornstein_uhlenbeck_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/functional.hpp>

namespace QuantLib {

    //! Piecewise linear Ornstein-Uhlenbeck process class
    /*! This class describes the Ornstein-Uhlenbeck process governed by
        \f[
            dx = a (level - x_t) dt + \sigma dW_t
        \f]

        \ingroup processes

        where the coefficients a and sigma are piecewise linear.
    */
    class GeneralizedOrnsteinUhlenbeckProcess : public StochasticProcess1D {
      public:
        GeneralizedOrnsteinUhlenbeckProcess(ext::function<Real(Time)> speed,
                                            ext::function<Real(Time)> vol,
                                            Real x0 = 0.0,
                                            Real level = 0.0);
        //! \name StochasticProcess1D interface
        //@{
        Real x0() const override;

        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;

        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real x0, Time dt) const override;
        //@}

        Real speed(Time t) const;
        Real volatility(Time t) const;
        Real level() const;

      private:
        Real x0_, level_;
        ext::function<Real (Time)> speed_;
        ext::function<Real (Time)> volatility_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="457">
    <source>swaptions/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
	haganirregularswaptionengine.hpp \
	irregularswap.hpp \
	irregularswaption.hpp

cpp_files = \
	haganirregularswaptionengine.cpp \
	irregularswap.cpp \
	irregularswaption.cpp

if UNITY_BUILD

nodist_libSwaptions_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libSwaptions_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libSwaptions.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="458">
    <source>swaptions/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/swaptions/haganirregularswaptionengine.hpp>
#include <ql/experimental/swaptions/irregularswap.hpp>
#include <ql/experimental/swaptions/irregularswaption.hpp>

]]></document_content>
  </document>
  <document index="459">
    <source>swaptions/haganirregularswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012, 2013 Andre Miemiec
 Copyright (C) 2012 Samuel Tebege

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/exercise.hpp>
#include <ql/experimental/swaptions/haganirregularswaptionengine.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/matrixutilities/svd.hpp>
#include <ql/math/solvers1d/bisection.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <utility>

namespace QuantLib {

    //////////////////////////////////////////////////////////////////////////
    // Implementation of helper class HaganIrregularSwaptionEngine::Basket  //
    //////////////////////////////////////////////////////////////////////////

    HaganIrregularSwaptionEngine::Basket::Basket(
        ext::shared_ptr<IrregularSwap> swap,
        Handle<YieldTermStructure> termStructure,
        Handle<SwaptionVolatilityStructure> volatilityStructure)
    : swap_(std::move(swap)), termStructure_(std::move(termStructure)),
      volatilityStructure_(std::move(volatilityStructure)), targetNPV_(0.0), lambda_(0.0) {

        engine_ = ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(termStructure_));

        // store swap npv
        swap_->setPricingEngine(engine_);
        targetNPV_ = swap_->NPV();

        // build standard swaps

        const Leg& fixedLeg = swap_->fixedLeg();
        const Leg& floatLeg = swap_->floatingLeg();

        Leg fixedCFS, floatCFS;

        for (Size i = 0; i < fixedLeg.size(); ++i) {
            // retrieve fixed rate coupon from fixed leg
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedLeg[i]);
            QL_REQUIRE(coupon, "dynamic cast of fixed leg coupon failed.");

            expiries_.push_back(coupon->date());

            ext::shared_ptr<FixedRateCoupon> newCpn = ext::make_shared<FixedRateCoupon>(
                coupon->date(), 1.0, coupon->rate(), coupon->dayCounter(),
                coupon->accrualStartDate(), coupon->accrualEndDate(),
                coupon->referencePeriodStart(), coupon->referencePeriodEnd());

            fixedCFS.push_back(newCpn);

            annuities_.push_back(10000 * CashFlows::bps(fixedCFS, **termStructure_, true));

            floatCFS.clear();

            for (const auto& j : floatLeg) {
                // retrieve ibor coupon from floating leg
                ext::shared_ptr<IborCoupon> coupon = ext::dynamic_pointer_cast<IborCoupon>(j);
                QL_REQUIRE(coupon, "dynamic cast of float leg coupon failed.");

                if (coupon->date() <= expiries_[i]) {
                    ext::shared_ptr<IborCoupon> newCpn = ext::shared_ptr<IborCoupon>(new IborCoupon(
                        coupon->date(), 1.0, coupon->accrualStartDate(), coupon->accrualEndDate(),
                        coupon->fixingDays(), coupon->iborIndex(), 1.0, coupon->spread(),
                        coupon->referencePeriodStart(), coupon->referencePeriodEnd(),
                        coupon->dayCounter(), coupon->isInArrears()));


                    if (!newCpn->isInArrears())
                        newCpn->setPricer(
                            ext::shared_ptr<FloatingRateCouponPricer>(new BlackIborCouponPricer()));

                    floatCFS.push_back(newCpn);
                }
            }

            Real floatLegNPV = CashFlows::npv(floatCFS, **termStructure_, true);

            fairRates_.push_back(floatLegNPV / annuities_[i]);
        }
    }


    //computes a replication of the swap in terms of a basket of vanilla swaps 
    //by solving a linear system of equation 
    Disposable<Array> HaganIrregularSwaptionEngine::Basket::compute(Rate lambda) const {

        //update members
        lambda_ = lambda;

        Size n = swap_->fixedLeg().size();

        //build linear system of equations
        Matrix arr(n,n,0.0);   
        Array  rhs(n);                   


        //fill the matrix describing the linear system of equations by looping over rows
        for(Size r = 0; r < n; ++r)
        {

            ext::shared_ptr<FixedRateCoupon> cpn_r = ext::dynamic_pointer_cast<FixedRateCoupon>(swap_->fixedLeg()[r]);
                        QL_REQUIRE(cpn_r,"Cast to fixed rate coupon failed.");

            //looping over columns
            for(Size c = r; c < n; ++c){

                //set homogenous part of lse
                arr[r][c] = ( fairRates_[c] + lambda_ ) * cpn_r->accrualPeriod();   
            }

            // add nominal repayment for i-th swap
            arr[r][r] += 1;
        }


        for(Size r = 0; r < n; ++r)
        {
            ext::shared_ptr<FixedRateCoupon> cpn_r = ext::dynamic_pointer_cast<FixedRateCoupon>(swap_->fixedLeg()[r]);

            // set inhomogenity of lse
            Real N_r = cpn_r->nominal();

            if(r < n - 1){

                ext::shared_ptr<FixedRateCoupon> cpn_rp1 = ext::dynamic_pointer_cast<FixedRateCoupon>(swap_->fixedLeg()[r+1]);

                Real N_rp1 = cpn_rp1->nominal();

                rhs[r] = N_r * (cpn_r->rate()) * cpn_r->accrualPeriod() + (N_r - N_rp1);

            } else {

                rhs[r] = N_r * (cpn_r->rate()) * cpn_r->accrualPeriod() + N_r;

            }       

        }


        SVD svd(arr);

        Disposable<Array> weights = svd.solveFor(rhs);

        return weights;

    }



    Real HaganIrregularSwaptionEngine::Basket::operator()(Rate lambda) const {

        Disposable<Array> weights = compute(lambda);

        Real defect = -targetNPV_;

        for(Size i=0; i< weights.size();++i)   defect -= swap_->type()*lambda*weights[i]*annuities_[i];

        return defect;
    }




    //creates a standard swap by deducing its conventions from market data objects
    ext::shared_ptr<VanillaSwap> HaganIrregularSwaptionEngine::Basket::component(Size i) const {

        ext::shared_ptr<IborCoupon> iborCpn   = ext::dynamic_pointer_cast<IborCoupon>(swap_->floatingLeg()[0]);
        QL_REQUIRE(iborCpn,"dynamic cast of float leg coupon failed. Can't find index.");
        ext::shared_ptr<IborIndex>  iborIndex = iborCpn->iborIndex();


        Period dummySwapLength = Period(1,Years);
                        
        ext::shared_ptr<VanillaSwap> memberSwap_ = MakeVanillaSwap(dummySwapLength,iborIndex)
                                                     .withType(swap_->type())
                                                     .withEffectiveDate(swap_->startDate())
                                                     .withTerminationDate(expiries_[i])
                                                     .withRule(DateGeneration::Backward)
                                                     .withDiscountingTermStructure(termStructure_);

        Real stdAnnuity = 10000*CashFlows::bps(memberSwap_->fixedLeg(),**termStructure_,true);

        //compute annuity transformed rate
        Rate transformedRate = (fairRates_[i]+lambda_)*annuities_[i]/stdAnnuity;

        memberSwap_ = MakeVanillaSwap(dummySwapLength,iborIndex,transformedRate)
                                                     .withType(swap_->type())
                                                     .withEffectiveDate(swap_->startDate())
                                                     .withTerminationDate(expiries_[i])
                                                     .withRule(DateGeneration::Backward)
                                                     .withDiscountingTermStructure(termStructure_);


        return memberSwap_;

    }


    ///////////////////////////////////////////////////////////
    // Implementation of class HaganIrregularSwaptionEngine  //
    ///////////////////////////////////////////////////////////


    HaganIrregularSwaptionEngine::HaganIrregularSwaptionEngine(
        Handle<SwaptionVolatilityStructure> volatilityStructure,
        Handle<YieldTermStructure> termStructure)
    : termStructure_(std::move(termStructure)),
      volatilityStructure_(std::move(volatilityStructure)) {
        registerWith(termStructure_);
        registerWith(volatilityStructure_);
    }


    void HaganIrregularSwaptionEngine::calculate() const {

        //check exercise type
        ext::shared_ptr<Exercise> exercise_ = this->arguments_.exercise;
        QL_REQUIRE(exercise_->type() == QuantLib::Exercise::European,"swaption must be european");

        //extract the underlying irregular swap
        ext::shared_ptr<IrregularSwap> swap_  = this->arguments_.swap;

        
        //Reshuffle spread from float to fixed (, i.e. remove spread from float side by finding the adjusted fixed coupon 
        //such that the NPV of the swap stays constant).
        Leg  fixedLeg = swap_->fixedLeg();
        Real fxdLgBPS = CashFlows::bps(fixedLeg,**termStructure_,true);

        Leg  floatLeg = swap_->floatingLeg();
        Real fltLgNPV = CashFlows::npv(floatLeg,**termStructure_,true);
        Real fltLgBPS = CashFlows::bps(floatLeg,**termStructure_,true);
    

        Leg floatCFS,fixedCFS;

        floatCFS.clear();

        for (auto& j : floatLeg) {
            //retrieve ibor coupon from floating leg
            ext::shared_ptr<IborCoupon> coupon = ext::dynamic_pointer_cast<IborCoupon>(j);
            QL_REQUIRE(coupon,"dynamic cast of float leg coupon failed.");

            ext::shared_ptr<IborCoupon> newCpn = ext::shared_ptr<IborCoupon> (
                new  IborCoupon(coupon->date(),
                coupon->nominal(),
                coupon->accrualStartDate(),
                coupon->accrualEndDate(),
                coupon->fixingDays(),
                coupon->iborIndex(),
                coupon->gearing(),
                0.0,
                coupon->referencePeriodStart(),
                coupon->referencePeriodEnd(),
                coupon->dayCounter(),
                coupon->isInArrears())); 


            if (!newCpn->isInArrears())
                newCpn->setPricer(
                             ext::shared_ptr<FloatingRateCouponPricer>(
                                      new BlackIborCouponPricer()));

            floatCFS.push_back(newCpn);
        }


        Real sprdLgNPV = fltLgNPV - CashFlows::npv(floatCFS,**termStructure_,true);
        Rate avgSpread = sprdLgNPV/fltLgBPS/10000;
            
        Rate cpn_adjustment = avgSpread*fltLgBPS/fxdLgBPS;

        fixedCFS.clear();

        for (auto& i : fixedLeg) {
            //retrieve fixed rate coupon from fixed leg
            ext::shared_ptr<FixedRateCoupon> coupon = ext::dynamic_pointer_cast<FixedRateCoupon>(i);
            QL_REQUIRE(coupon,"dynamic cast of fixed leg coupon failed.");

            ext::shared_ptr<FixedRateCoupon> newCpn = ext::make_shared<FixedRateCoupon> (
                coupon->date(),
                coupon->nominal(),
                coupon->rate()-cpn_adjustment,
                coupon->dayCounter(),
                coupon->accrualStartDate(),
                coupon->accrualEndDate(),
                coupon->referencePeriodStart(),
                coupon->referencePeriodEnd()); 

            fixedCFS.push_back(newCpn);
        }


        //this is the irregular swap with spread removed 
        swap_  =  ext::make_shared<IrregularSwap>(arguments_.swap->type(),fixedCFS,floatCFS);



        //Sets up the basket by implementing the methodology described in 
        //P.S.Hagan "Callable Swaps and Bermudan 'Exercise into Swaptions'"
        Basket basket(swap_,termStructure_,volatilityStructure_);  


        ///////////////////////////////////////////////////////////////////////////////////////////////////
        //find lambda                                                                                    //
        ///////////////////////////////////////////////////////////////////////////////////////////////////

        Bisection s1d;

        Rate minLambda = -0.5;
        Rate maxLambda = 0.5;
        s1d.setMaxEvaluations(10000);
        s1d.setLowerBound(minLambda);
        s1d.setUpperBound(maxLambda);
        s1d.solve(basket,1.0e-8,0.01, minLambda, maxLambda);


        /////////////////////////////////////////////////////////////////////////////////////////////////
        //  compute the price of the irreg swaption as the sum of the prices of the regular swaptions  //
        /////////////////////////////////////////////////////////////////////////////////////////////////


        results_.value = HKPrice(basket,exercise_);
    }



    /////////////////////////////////////////////////////////////////////////////////////////
    // Computes irregular swaption price according to P.J. Hunt, J.E. Kennedy:             //
    // "Implied interest rate pricing models", Finance Stochast. 2, 275293 (1998)      //
    /////////////////////////////////////////////////////////////////////////////////////////

    Real  HaganIrregularSwaptionEngine::HKPrice(Basket& basket,ext::shared_ptr<Exercise>& exercise) const {

        // Black 76 Swaption Engine: assumes that the swaptions exercise date equals the swap start date
        ext::shared_ptr<PricingEngine> blackSwaptionEngine = 
             ext::shared_ptr<PricingEngine>(new BlackSwaptionEngine(termStructure_,volatilityStructure_));

        //retrieve weights of underlying swaps
        Disposable<Array> weights = basket.weights();

        Real npv = 0.0;

        for(Size i=0; i<weights.size(); ++i)
        {
            ext::shared_ptr<VanillaSwap> pvSwap_ = basket.component(i);
            Swaption swaption = Swaption(pvSwap_,exercise);
            swaption.setPricingEngine(blackSwaptionEngine);
            npv += weights[i]*swaption.NPV();
        }

        return npv;

    }

    


}
]]></document_content>
  </document>
  <document index="460">
    <source>swaptions/irregularswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2010 Andre Miemiec

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/swaptions/irregularswap.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    IrregularSwap::IrregularSwap(
                     Type type,
                     const Leg& fixLeg,
                     const Leg& floatLeg)
    : Swap(2), type_(type) {


        switch (type_) {
          case Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          case Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          default:
            QL_FAIL("Unknown Irregular-swap type");
        }

        //Fixed leg
        legs_[0] = fixLeg;

        for (Leg::const_iterator i = legs_[0].begin(); i < legs_[0].end(); ++i)
            registerWith(*i);
        
        //Floating Leg
        legs_[1] = floatLeg;

        for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

    }


    void IrregularSwap::setupArguments(PricingEngine::arguments* args) const {

    //Debug: to be done

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<IrregularSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        arguments->type = type_;
        //arguments->nominal = nominal_;

        
        const Leg& fixedCoupons = fixedLeg();

        arguments->fixedResetDates = arguments->fixedPayDates = std::vector<Date>(fixedCoupons.size());
        arguments->fixedNominals   = arguments->fixedCoupons  = std::vector<Real>(fixedCoupons.size());


        for (Size i=0; i<fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i]   = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i]    = coupon->amount();
            arguments->fixedNominals[i]   = coupon->nominal(); 
        }


        const Leg& floatingCoupons = floatingLeg();

        arguments->floatingResetDates   = arguments->floatingPayDates 
                                        = arguments->floatingFixingDates = std::vector<Date>(floatingCoupons.size());
        arguments->floatingAccrualTimes = std::vector<Time>(floatingCoupons.size());
        arguments->floatingSpreads      = std::vector<Spread>(floatingCoupons.size());
        arguments->floatingNominals     = arguments->floatingCoupons = std::vector<Real>(floatingCoupons.size());

        for (Size i=0; i<floatingCoupons.size(); ++i) {
            ext::shared_ptr<IborCoupon> coupon =
                ext::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);

            arguments->floatingResetDates[i]   = coupon->accrualStartDate();
            arguments->floatingPayDates[i]     = coupon->date();

            arguments->floatingFixingDates[i]  = coupon->fixingDate();
            arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
            arguments->floatingSpreads[i]      = coupon->spread();
            arguments->floatingNominals[i]     = coupon->nominal();

            try {
                arguments->floatingCoupons[i] = coupon->amount();
            } catch (Error&) {
                arguments->floatingCoupons[i] = Null<Real>();
            }
        }
        
    }


    Rate IrregularSwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread IrregularSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }

    Real IrregularSwap::fixedLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real IrregularSwap::floatingLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real IrregularSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real IrregularSwap::floatingLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void IrregularSwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void IrregularSwap::fetchResults(const PricingEngine::results* r) const {
        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const IrregularSwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>()) 
                fairRate_ = 0.0; // Debug: legs_[0]->fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = 0.0; //DEBUG: spread_ - NPV_/(legBPS_[1]/basisPoint);
        }
    }

    void IrregularSwap::arguments::validate() const {

        Swap::arguments::validate();

        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual Times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingPayDates.size() == floatingCoupons.size(),
                   "number of floating payment dates different from "
                   "number of floating coupon amounts");
    }

    void IrregularSwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}
]]></document_content>
  </document>
  <document index="461">
    <source>swaptions/irregularswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2006, 2008 Ferdinando Ametrano
 Copyright (C) 2010 Andre Miemiec

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file irregularswap.hpp
    \brief Irregular fixed-rate vs Libor swap
*/

#ifndef quantlib_irregular_swap_hpp
#define quantlib_irregular_swap_hpp

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/instruments/swap.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/schedule.hpp>
#include <boost/optional.hpp>

namespace QuantLib {

    class IborIndex;

    //! Irregular swap: fixed vs floating leg
    class IrregularSwap : public Swap {
      public:
        class arguments;
        class results;
        class engine;
        IrregularSwap(
            Type type,
            const Leg& fixLeg,
            const Leg& floatLeg);
        //! \name Inspectors
        //@{
        Type type() const;

        const Leg& fixedLeg() const;
        const Leg& floatingLeg() const;
        //@}

        //! \name Results
        //@{
        Real fixedLegBPS() const;
        Real fixedLegNPV() const;
        Rate fairRate() const;

        Real floatingLegBPS() const;
        Real floatingLegNPV() const;
        Spread fairSpread() const;
        //@}
        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        Type type_;

        // results
        mutable Rate fairRate_;
        mutable Spread fairSpread_;
    };


    //! %Arguments for irregular-swap calculation
    class IrregularSwap::arguments : public Swap::arguments {
      public:
        arguments() = default;
        Type type = Receiver;


        std::vector<Date> fixedResetDates;
        std::vector<Date> fixedPayDates;
        std::vector<Real> fixedCoupons;
        std::vector<Real> fixedNominals;

        std::vector<Date> floatingResetDates;
        std::vector<Date> floatingFixingDates;
        std::vector<Date> floatingPayDates;
        std::vector<Time> floatingAccrualTimes;
        std::vector<Real> floatingNominals;
        std::vector<Spread> floatingSpreads;
        std::vector<Real> floatingCoupons;

        void validate() const override;
    };

    //! %Results from irregular-swap calculation
    class IrregularSwap::results : public Swap::results {
      public:
        Rate fairRate;
        Spread fairSpread;
        void reset() override;
    };

    class IrregularSwap::engine : public GenericEngine<IrregularSwap::arguments,
                                                       IrregularSwap::results> {};


    // inline definitions

    inline Swap::Type IrregularSwap::type() const {
        return type_;
    }

    inline const Leg& IrregularSwap::fixedLeg() const {
        return legs_[0];
    }

    inline const Leg& IrregularSwap::floatingLeg() const {
        return legs_[1];
    }

}

#endif
]]></document_content>
  </document>
  <document index="462">
    <source>swaptions/irregularswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2010 Andre Miemiec

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/swaptions/irregularswaption.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class IrregularImpliedVolHelper {
          public:
            IrregularImpliedVolHelper(const IrregularSwaption&,
                                      Handle<YieldTermStructure> discountCurve,
                                      Real targetValue);
            Real operator()(Volatility x) const;
            Real derivative(Volatility x) const;
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Handle<YieldTermStructure> discountCurve_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };

        IrregularImpliedVolHelper::IrregularImpliedVolHelper(
            const IrregularSwaption& swaption,
            Handle<YieldTermStructure> discountCurve,
            Real targetValue)
        : discountCurve_(std::move(discountCurve)), targetValue_(targetValue),
          vol_(ext::make_shared<SimpleQuote>(-1.0)) {

            Handle<Quote> h(vol_);
            engine_ = ext::shared_ptr<PricingEngine>(new
                                    BlackSwaptionEngine(discountCurve_, h));
            swaption.setupArguments(engine_->getArguments());

            results_ =
                dynamic_cast<const Instrument::results*>(engine_->getResults());
        }

        Real IrregularImpliedVolHelper::operator()(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            return results_->value-targetValue_;
        }

        Real IrregularImpliedVolHelper::derivative(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            auto vega_ = results_->additionalResults.find("vega");
            QL_REQUIRE(vega_ != results_->additionalResults.end(),
                       "vega not provided");
            return boost::any_cast<Real>(vega_->second);
        }
    }

    std::ostream& operator<<(std::ostream& out,
                             IrregularSettlement::Type t) {
        switch (t) {
          case IrregularSettlement::Physical:
            return out << "Delivery";
          case IrregularSettlement::Cash:
            return out << "Cash";
          default:
            QL_FAIL("unknown IrregularSettlement::Type(" << Integer(t) << ")");
        }
    }

    IrregularSwaption::IrregularSwaption(ext::shared_ptr<IrregularSwap> swap,
                                         const ext::shared_ptr<Exercise>& exercise,
                                         IrregularSettlement::Type delivery)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery) {
        registerWith(swap_);
    }

    bool IrregularSwaption::isExpired() const {
        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void IrregularSwaption::setupArguments(PricingEngine::arguments* args) const {

        swap_->setupArguments(args);

        auto* arguments = dynamic_cast<IrregularSwaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->swap = swap_;
        arguments->settlementType = settlementType_;
        arguments->exercise = exercise_;
    }

    void IrregularSwaption::arguments::validate() const {
        IrregularSwap::arguments::validate();
        QL_REQUIRE(swap, "Irregular swap not set");
        QL_REQUIRE(exercise, "exercise not set");
    }

    Volatility IrregularSwaption::impliedVolatility(
                              Real targetValue,
                              const Handle<YieldTermStructure>& discountCurve,
                              Volatility guess,
                              Real accuracy,
                              Natural maxEvaluations,
                              Volatility minVol,
                              Volatility maxVol) const {
        calculate();
        QL_REQUIRE(!isExpired(), "instrument expired");

        IrregularImpliedVolHelper f(*this, discountCurve, targetValue);
        //Brent solver;
        NewtonSafe solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }

}
]]></document_content>
  </document>
  <document index="463">
    <source>swaptions/irregularswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2010 Andre Miemiec

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file irregularswaption.hpp
    \brief Irregular swaption class
*/

#ifndef quantlib_instruments_irregular_swaption_hpp
#define quantlib_instruments_irregular_swaption_hpp

#include <ql/option.hpp>
#include <ql/experimental/swaptions/irregularswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! %settlement information
    struct IrregularSettlement {
        enum Type { Physical, Cash };
    };

    std::ostream& operator<<(std::ostream& out,
                             IrregularSettlement::Type type);

    //! Irregular %Swaption class
    /*! \ingroup instruments */
    class IrregularSwaption : public Option {
      public:
        class arguments;
        class engine;
        IrregularSwaption(ext::shared_ptr<IrregularSwap> swap,
                          const ext::shared_ptr<Exercise>& exercise,
                          IrregularSettlement::Type delivery = IrregularSettlement::Physical);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        IrregularSettlement::Type settlementType() const { return settlementType_; }
        Swap::Type type() const { return swap_->type(); }
        const ext::shared_ptr<IrregularSwap>& underlyingSwap() const {
            return swap_;
        }
        //@}
        //! implied volatility
        Volatility impliedVolatility(
                              Real price,
                              const Handle<YieldTermStructure>& discountCurve,
                              Volatility guess,
                              Real accuracy = 1.0e-4,
                              Natural maxEvaluations = 100,
                              Volatility minVol = 1.0e-7,
                              Volatility maxVol = 4.0) const;
      private:
        // arguments
        ext::shared_ptr<IrregularSwap> swap_;
        IrregularSettlement::Type settlementType_;
    };

    //! %Arguments for irregular-swaption calculation
    class IrregularSwaption::arguments : public IrregularSwap::arguments,
                                         public Option::arguments {
      public:
        arguments() = default;
        ext::shared_ptr<IrregularSwap> swap;
        IrregularSettlement::Type settlementType = IrregularSettlement::Physical;
        void validate() const override;
    };

    //! base class for irregular-swaption engines
    class IrregularSwaption::engine
        : public GenericEngine<IrregularSwaption::arguments, IrregularSwaption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="464">
    <source>termstructures/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    crosscurrencyratehelpers.hpp \
    multicurvesensitivities.hpp

cpp_files = \
    crosscurrencyratehelpers.cpp


if UNITY_BUILD

nodist_libTermStructures_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libTermStructures_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libTermStructures.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="465">
    <source>termstructures/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/termstructures/crosscurrencyratehelpers.hpp>
#include <ql/experimental/termstructures/multicurvesensitivities.hpp>

]]></document_content>
  </document>
  <document index="466">
    <source>termstructures/crosscurrencyratehelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/experimental/termstructures/crosscurrencyratehelpers.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    ext::shared_ptr<Swap>
    CrossCurrencyBasisSwapRateHelper::buildCrossCurrencyLeg(const Date& evaluationDate,
                                                            const Period& tenor,
                                                            Natural fixingDays,
                                                            const Calendar& calendar,
                                                            BusinessDayConvention convention,
                                                            bool endOfMonth,
                                                            const ext::shared_ptr<IborIndex>& idx,
                                                            Swap::Type type,
                                                            Real notional,
                                                            Spread basis) {
        bool isPayer = (type == Swap::Payer);
        Date referenceDate = calendar.adjust(evaluationDate);
        Date earliestDate = calendar.advance(referenceDate, fixingDays * Days, convention);
        Date maturity = earliestDate + tenor;

        Schedule schedule = MakeSchedule()
                                .from(earliestDate)
                                .to(maturity)
                                .withTenor(idx->tenor())
                                .withCalendar(calendar)
                                .withConvention(convention)
                                .endOfMonth(endOfMonth)
                                .backwards();

        Leg leg = IborLeg(schedule, idx).withNotionals(notional).withSpreads(basis);
        Date lastPaymentDate = leg.back()->date();
        leg.push_back(ext::make_shared<SimpleCashFlow>(notional, lastPaymentDate));

        return ext::make_shared<Swap>(std::vector<Leg>(1, leg), std::vector<bool>(1, isPayer));
    }

    CrossCurrencyBasisSwapRateHelper::CrossCurrencyBasisSwapRateHelper(
        const Handle<Quote>& basis,
        const Period& tenor,
        Natural fixingDays,
        Calendar calendar,
        BusinessDayConvention convention,
        bool endOfMonth,
        ext::shared_ptr<IborIndex> baseCurrencyIndex,
        ext::shared_ptr<IborIndex> quoteCurrencyIndex,
        Handle<YieldTermStructure> collateralCurve,
        bool isFxBaseCurrencyCollateralCurrency,
        bool isBasisOnFxBaseCurrencyLeg)
    : RelativeDateRateHelper(basis), tenor_(tenor), fixingDays_(fixingDays),
      calendar_(std::move(calendar)), convention_(convention), endOfMonth_(endOfMonth),
      baseCcyIdx_(std::move(baseCurrencyIndex)), quoteCcyIdx_(std::move(quoteCurrencyIndex)),
      collateralHandle_(std::move(collateralCurve)),
      isFxBaseCurrencyCollateralCurrency_(isFxBaseCurrencyCollateralCurrency),
      isBasisOnFxBaseCurrencyLeg_(isBasisOnFxBaseCurrencyLeg) {
        registerWith(baseCcyIdx_);
        registerWith(quoteCcyIdx_);
        registerWith(collateralHandle_);

        initializeDates();
    }

    void CrossCurrencyBasisSwapRateHelper::initializeDates() {
        baseCcyLeg_ = CrossCurrencyBasisSwapRateHelper::buildCrossCurrencyLeg(
            evaluationDate_, tenor_, fixingDays_, calendar_, convention_, endOfMonth_, baseCcyIdx_,
            Swap::Receiver);
        quoteCcyLeg_ = CrossCurrencyBasisSwapRateHelper::buildCrossCurrencyLeg(
            evaluationDate_, tenor_, fixingDays_, calendar_, convention_, endOfMonth_, quoteCcyIdx_,
            Swap::Payer);

        earliestDate_ = std::min(baseCcyLeg_->startDate(), quoteCcyLeg_->startDate());
        latestDate_ = std::max(baseCcyLeg_->maturityDate(), quoteCcyLeg_->maturityDate());

        ext::shared_ptr<PricingEngine> otherCcyEngine(
            new DiscountingSwapEngine(termStructureHandle_));
        ext::shared_ptr<PricingEngine> collateralCcyEngine(
            new DiscountingSwapEngine(collateralHandle_));

        if (isFxBaseCurrencyCollateralCurrency_) {
            baseCcyLeg_->setPricingEngine(collateralCcyEngine);
            quoteCcyLeg_->setPricingEngine(otherCcyEngine);
        } else {
            baseCcyLeg_->setPricingEngine(otherCcyEngine);
            quoteCcyLeg_->setPricingEngine(collateralCcyEngine);
        }
    }

    Real CrossCurrencyBasisSwapRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        QL_REQUIRE(!collateralHandle_.empty(), "collateral term structure not set");

        baseCcyLeg_->recalculate();
        Real npvBaseCcy = baseCcyLeg_->NPV();

        quoteCcyLeg_->recalculate();
        Real npvQuoteCcy = quoteCcyLeg_->NPV();

        const Spread basisPoint = 1.0e-4;
        Real bps = isBasisOnFxBaseCurrencyLeg_ ? baseCcyLeg_->legBPS(0) : quoteCcyLeg_->legBPS(0);

        return -(npvQuoteCcy + npvBaseCcy) / bps * basisPoint;
    }

    void CrossCurrencyBasisSwapRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    void CrossCurrencyBasisSwapRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<CrossCurrencyBasisSwapRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }
}
]]></document_content>
  </document>
  <document index="467">
    <source>termstructures/crosscurrencyratehelpers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file crosscurrencyratehelpers.hpp
    \brief FX and cross currency basis swaps rate helpers
*/

#ifndef quantlib_crosscurrencyratehelpers_hpp
#define quantlib_crosscurrencyratehelpers_hpp

#include <ql/termstructures/yield/ratehelpers.hpp>

namespace QuantLib {
    //! Rate helper for bootstrapping over XCCY basis swap rates
    /*! 
    Constant notional cross currency swap helper.
    Unlike marked-to-market cross currency swaps, both notionals
    expressed in base and quote currency remain constant throughout
    the lifetime of the swap.

    For more details see:
    N. Moreni, A. Pallavicini (2015)
    FX Modelling in Collateralized Markets: foreign measures, basis curves
    and pricing formulae.
    */
    class CrossCurrencyBasisSwapRateHelper : public RelativeDateRateHelper {
      public:
        CrossCurrencyBasisSwapRateHelper(const Handle<Quote>& basis,
                                         const Period& tenor,
                                         Natural fixingDays,
                                         Calendar calendar,
                                         BusinessDayConvention convention,
                                         bool endOfMonth,
                                         ext::shared_ptr<IborIndex> baseCurrencyIndex,
                                         ext::shared_ptr<IborIndex> quoteCurrencyIndex,
                                         Handle<YieldTermStructure> collateralCurve,
                                         bool isFxBaseCurrencyCollateralCurrency,
                                         bool isBasisOnFxBaseCurrencyLeg);
        //! \name RateHelper interface
        //@{
        Real impliedQuote() const override;
        void setTermStructure(YieldTermStructure*) override;
        //@}
        //! \name CrossCurrencyBasisSwapRateHelper inspectors
        //@{
        const Leg& baseCurrencyLeg() const;
        const Leg& quoteCurrencyLeg() const;
        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
        //! \name CrossCurrencyBasisSwapRateHelper utility functions.
        //@{
        static ext::shared_ptr<Swap> buildCrossCurrencyLeg(const Date& evaluationDate,
                                                           const Period& tenor,
                                                           Natural fixingDays,
                                                           const Calendar& calendar,
                                                           BusinessDayConvention convention,
                                                           bool endOfMonth,
                                                           const ext::shared_ptr<IborIndex>& idx,
                                                           Swap::Type type,
                                                           Real notional = 1.0,
                                                           Spread basis = 0.0);
        //@}
      protected:
        void initializeDates() override;

        Period tenor_;
        Natural fixingDays_;
        Calendar calendar_;
        BusinessDayConvention convention_;
        bool endOfMonth_;
        ext::shared_ptr<IborIndex> baseCcyIdx_;
        ext::shared_ptr<IborIndex> quoteCcyIdx_;
        Handle<YieldTermStructure> collateralHandle_;
        bool isFxBaseCurrencyCollateralCurrency_;
        bool isBasisOnFxBaseCurrencyLeg_;

        ext::shared_ptr<Swap> baseCcyLeg_;
        ext::shared_ptr<Swap> quoteCcyLeg_;

        RelinkableHandle<YieldTermStructure> termStructureHandle_;
    };

    inline const Leg& CrossCurrencyBasisSwapRateHelper::baseCurrencyLeg() const {
        return baseCcyLeg_->leg(0);
    }

    inline const Leg& CrossCurrencyBasisSwapRateHelper::quoteCurrencyLeg() const {
        return quoteCcyLeg_->leg(0);
    }
}

#endif
]]></document_content>
  </document>
  <document index="468">
    <source>termstructures/multicurvesensitivities.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*!
 Copyright (C) 2016 Michael von den Driesch

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file multicurvesensitivities.hpp
    \brief compute piecewise-curve sensitivities to the input instruments.
*/

#ifndef quantlib_multicurve_sensitivity_hpp
#define quantlib_multicurve_sensitivity_hpp

#include <ql/shared_ptr.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <iostream>
#include <sstream>
#include <utility>

namespace {
    inline QuantLib::Real secondElement(const std::pair<QuantLib::Date, QuantLib::Real>& p) {
        return p.second;
    }
}

namespace QuantLib {

//! Multi curve sensitivities
/*! This class provides a simple (yet most likely not the fastest) way to create sensitivities
  to the <em>par quotes</em>, provided in the piecewiseyieldcurve for stripping. If constructed with more
than one curve, the class iterates over all quotes of the provided curves and shifts each quote of all provided curves
taking interdependence into account.

The class computes the sensitvities as a QuantLib Matrix class in the form:
\f[
\frac{\partial z_i}{\partial q_j}
\f]
where the \f$(z_i)_{i\in \{1,...,n\}}\f$'s are the implied <em>values</em> (being the traits used during curve
constructions, e.g. ZeroYield, Discountfactors or ForwardRates) and the the \f$(q_i)_{i\in \{1,...,n\}}\f$'s are the
quoted par rates.


\note It's the users job to provide all curves that <em>influence</em> the implied rates.

    \ingroup yieldtermstructures

*/
class MultiCurveSensitivities : public LazyObject {
private:
  typedef std::map< std::string, Handle< YieldTermStructure > > curvespec;

public:
  //! Multi curve sensitivties
  /*! @param curves std::map of string (curve name) and handle to piecewiseyieldcurve
  */

  explicit MultiCurveSensitivities(curvespec curves) : curves_(std::move(curves)) {
      for (curvespec::const_iterator it = curves_.begin(); it != curves_.end(); ++it)
          registerWith((*it).second);
      for (curvespec::const_iterator it = curves_.begin(); it != curves_.end(); ++it) {
          ext::shared_ptr<PiecewiseYieldCurve<ZeroYield, Linear> > curve =
              ext::dynamic_pointer_cast<PiecewiseYieldCurve<ZeroYield, Linear> >(
                  it->second.currentLink());
          QL_REQUIRE(curve != nullptr, "Couldn't cast curvename: " << it->first);
          for (auto& instrument : curve->instruments_) {
              allQuotes_.push_back(instrument->quote());
              std::stringstream tmp;
              tmp << QuantLib::io::iso_date(instrument->latestRelevantDate());
              headers_.push_back(it->first + "_" + tmp.str());
          }
      }
  }

  Matrix sensitivities() const;
  Matrix inverseSensitivities() const;
  std::vector< std::string > headers() const { return headers_; }

private:
  //! \name LazyObject interface
  //@{
  void performCalculations() const override;
  //@}
  // methods
  std::vector< Real > allZeros() const;
  std::vector< std::pair< Date, Real > > allNodes() const;
  mutable std::vector< Rate > origZeros_;
  std::vector< Handle< Quote > > allQuotes_;
  std::vector< std::pair< Date, Real > > origNodes_;
  mutable Matrix sensi_, invSensi_;
  curvespec curves_;
  std::vector< std::string > headers_;
};

inline void MultiCurveSensitivities::performCalculations() const {
  std::vector< Rate > sensiVector;
  origZeros_ = allZeros();
  for (const auto& allQuote : allQuotes_) {
      Rate bps = +1e-4;
      Rate origQuote = allQuote->value();
      ext::shared_ptr<SimpleQuote> q =
          ext::dynamic_pointer_cast<SimpleQuote>(allQuote.currentLink());
      q->setValue(origQuote + bps);
      try {
          std::vector<Rate> tmp(allZeros());
          for (Size i = 0; i < tmp.size(); ++i)
              sensiVector.push_back((tmp[i] - origZeros_[i]) / bps);
          q->setValue(origQuote);
      } catch (...) {
          q->setValue(origQuote);
          QL_FAIL("Application of shift to quote led to exception.");
      }
  }
  Matrix result(origZeros_.size(), origZeros_.size(), sensiVector.begin(), sensiVector.end());
  sensi_ = result;
  invSensi_ = inverse(sensi_);
}

inline Matrix MultiCurveSensitivities::sensitivities() const {
  calculate();
  return sensi_;
}

inline Matrix MultiCurveSensitivities::inverseSensitivities() const {
  calculate();
  return invSensi_;
}

inline std::vector< std::pair< Date, Real > > MultiCurveSensitivities::allNodes() const {
  std::vector< std::pair< Date, Real > > result;
  for (const auto& it : curves_) {
      ext::shared_ptr<PiecewiseYieldCurve<ZeroYield, Linear> > curve =
          ext::dynamic_pointer_cast<PiecewiseYieldCurve<ZeroYield, Linear> >(
              it.second.currentLink());
      result.reserve(result.size() + curve->nodes().size() - 1);
      for (std::vector<std::pair<Date, Real> >::const_iterator p = curve->nodes().begin() + 1;
           p != curve->nodes().end(); ++p)
          result.push_back(*p);
  }
  return result;
}

inline std::vector< Real > MultiCurveSensitivities::allZeros() const {
  std::vector< std::pair< Date, Real > > result = allNodes();
  std::vector< Real > zeros;
  std::transform(result.begin(), result.end(), std::back_inserter(zeros), secondElement);
  return zeros;
}
}

#endif
]]></document_content>
  </document>
  <document index="469">
    <source>variancegamma/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    analyticvariancegammaengine.hpp \
    fftengine.hpp \
    fftvanillaengine.hpp \
    fftvariancegammaengine.hpp \
    variancegammamodel.hpp \
    variancegammaprocess.hpp

cpp_files = \
    analyticvariancegammaengine.cpp \
    fftengine.cpp \
    fftvanillaengine.cpp \
    fftvariancegammaengine.cpp \
    variancegammamodel.cpp \
    variancegammaprocess.cpp

if UNITY_BUILD

nodist_libVarianceGamma_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libVarianceGamma_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libVarianceGamma.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="470">
    <source>variancegamma/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/variancegamma/analyticvariancegammaengine.hpp>
#include <ql/experimental/variancegamma/fftengine.hpp>
#include <ql/experimental/variancegamma/fftvanillaengine.hpp>
#include <ql/experimental/variancegamma/fftvariancegammaengine.hpp>
#include <ql/experimental/variancegamma/variancegammamodel.hpp>
#include <ql/experimental/variancegamma/variancegammaprocess.hpp>

]]></document_content>
  </document>
  <document index="471">
    <source>variancegamma/analyticvariancegammaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/variancegamma/analyticvariancegammaengine.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/integrals/kronrodintegral.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class Integrand {
        public:
          Integrand(ext::shared_ptr<StrikedTypePayoff> payoff,
                    Real s0,
                    Real t,
                    Real riskFreeDiscount,
                    Real dividendDiscount,
                    Real sigma,
                    Real nu,
                    Real theta)
          : payoff_(std::move(payoff)), s0_(s0), t_(t), riskFreeDiscount_(riskFreeDiscount),
            dividendDiscount_(dividendDiscount), sigma_(sigma), nu_(nu), theta_(theta) {
              omega_ = std::log(1.0 - theta_ * nu_ - (sigma_ * sigma_ * nu_) / 2.0) / nu_;
              // We can precompute the denominator of the gamma pdf (does not depend on x)
              // shape = t_/nu_, scale = nu_
              GammaFunction gf;
              gammaDenom_ = std::exp(gf.logValue(t_ / nu_)) * std::pow(nu_, t_ / nu_);
          }

            Real operator()(Real x) const {
                // Compute adjusted black scholes price
                Real s0_adj = s0_ * std::exp(theta_ * x + omega_ * t_ + (sigma_ * sigma_ * x) / 2.0);
                Real vol_adj = sigma_ * std::sqrt(x / t_);
                vol_adj *= std::sqrt(t_);

                BlackScholesCalculator bs(payoff_, s0_adj, dividendDiscount_, vol_adj, riskFreeDiscount_);
                Real bsprice = bs.value();

                // Multiply by gamma distribution
                Real gamp = (std::pow(x, t_ / nu_ - 1.0) * std::exp(-x / nu_)) / gammaDenom_;
                Real result = bsprice * gamp;
                return result;
            }

        private:
            ext::shared_ptr<StrikedTypePayoff> payoff_;
            Real s0_;
            Real t_;
            Real riskFreeDiscount_;
            Real dividendDiscount_;
            Rate sigma_;
            Real nu_;
            Real theta_;
            Real omega_;
            Real gammaDenom_;
        };
    }


    VarianceGammaEngine::VarianceGammaEngine(ext::shared_ptr<VarianceGammaProcess> process,
                                             Real absoluteError)
    : process_(std::move(process)), absErr_(absoluteError) {
        QL_REQUIRE(absErr_ > 0, "absolute error must be positive");
        registerWith(process_);
    }

    void VarianceGammaEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
            "not an European Option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(
            arguments_.exercise->lastDate());
        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(arguments_.exercise->lastDate());

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        Time t = rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
            arguments_.exercise->lastDate());

        Integrand f(payoff,
            process_->x0(),
            t, riskFreeDiscount, dividendDiscount,
            process_->sigma(), process_->nu(), process_->theta());

        Real infinity = 15.0 * std::sqrt(process_->nu() * t);
        Real target = absErr_*1e-4;
        Real val = f(infinity);
        while (std::abs(val)>target){
          infinity*=1.5;
          val = f(infinity);
        }
        // the integration is split due to occasional singularities at 0
        Real split = 0.1;
        GaussKronrodNonAdaptive integrator1(absErr_, 1000, 0);
        Real pvA = integrator1(f, 0, split);
        GaussLobattoIntegral integrator2(2000, absErr_);
        Real pvB = integrator2(f, split, infinity);
        results_.value = pvA + pvB;
    }

}
]]></document_content>
  </document>
  <document index="472">
    <source>variancegamma/analyticvariancegammaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticvariancegammaengine.hpp
    \brief Analytic Variance Gamma option engine for vanilla options
*/

#ifndef quantlib_variance_gamma_engine_hpp
#define quantlib_variance_gamma_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/experimental/variancegamma/variancegammaprocess.hpp>

namespace QuantLib {

    //! Variance Gamma Pricing engine for European vanilla options using integral approach
    /*! \ingroup vanillaengines

        \test the correctness of the returned values is tested by
        checking it against known good results.
    */
    class VarianceGammaEngine : public VanillaOption::engine {
    public:
      explicit VarianceGammaEngine(ext::shared_ptr<VarianceGammaProcess>,
                                   Real absoluteError = 1e-5);
      void calculate() const override;

    private:
      ext::shared_ptr<VarianceGammaProcess> process_;
      Real absErr_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="473">
    <source>variancegamma/fftengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/experimental/variancegamma/fftengine.hpp>
#include <ql/math/fastfouriertransform.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <complex>
#include <utility>

namespace QuantLib {

    FFTEngine::FFTEngine(ext::shared_ptr<StochasticProcess1D> process, Real logStrikeSpacing)
    : process_(std::move(process)), lambda_(logStrikeSpacing) {
        registerWith(process_);
    }

    void FFTEngine::calculate() const
    {
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
            "not an European Option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        auto r1 = resultMap_.find(arguments_.exercise->lastDate());
        if (r1 != resultMap_.end())
        {
            auto r2 = r1->second.find(payoff);
            if (r2 != r1->second.end())
            {
                results_.value = r2->second;
                return;
            }
        }
        
        // Option not precalculated - do entire FFT for one option.  Not very efficient - call precalculate!
        calculateUncached(payoff, arguments_.exercise);
    }

    void FFTEngine::update()
    {
        // Process has changed so cached values may no longer be correct
        resultMap_.clear();

        // Call base class implementation
        VanillaOption::engine::update();
    }

    void FFTEngine::calculateUncached(const ext::shared_ptr<StrikedTypePayoff>& payoff,
                                      const ext::shared_ptr<Exercise>& exercise) const {
        ext::shared_ptr<VanillaOption> option(new VanillaOption(payoff, exercise));
        std::vector<ext::shared_ptr<Instrument> > optionList;
        optionList.push_back(option);

        ext::shared_ptr<FFTEngine> tempEngine(clone().release());
        tempEngine->precalculate(optionList);
        option->setPricingEngine(tempEngine);
        results_.value = option->NPV();
    }

    void FFTEngine::precalculate(const std::vector<ext::shared_ptr<Instrument> >& optionList) {
        // Group payoffs by expiry date
        // as with FFT we can compute a bunch of these at once
        resultMap_.clear();

        typedef std::vector<ext::shared_ptr<StrikedTypePayoff> > PayoffList;
        typedef std::map<Date, PayoffList> PayoffMap;
        PayoffMap payoffMap;

        for (const auto& optIt : optionList) {
            ext::shared_ptr<VanillaOption> option = ext::dynamic_pointer_cast<VanillaOption>(optIt);
            QL_REQUIRE(option, "instrument must be option");
            QL_REQUIRE(option->exercise()->type() == Exercise::European,
                "not an European Option");

            ext::shared_ptr<StrikedTypePayoff> payoff =
                ext::dynamic_pointer_cast<StrikedTypePayoff>(option->payoff());
            QL_REQUIRE(payoff, "non-striked payoff given");

            payoffMap[option->exercise()->lastDate()].push_back(payoff);
        }

        std::complex<Real> i1(0, 1);
        Real alpha = 1.25;

        for (PayoffMap::const_iterator payIt = payoffMap.begin(); payIt != payoffMap.end(); ++payIt)
        {
            Date expiryDate = payIt->first;

            // Calculate n large enough for maximum strike, and round up to a power of 2
            Real maxStrike = 0.0;
            for (const auto& payoff : payIt->second) {
                if (payoff->strike() > maxStrike)
                    maxStrike = payoff->strike();
            }
            Real nR = 2.0 * (std::log(maxStrike) + lambda_) / lambda_;
      Size log2_n = (static_cast<Size>((std::log(nR) / std::log(2.0))) + 1);
            Size n = static_cast<std::size_t>(1) << log2_n;

            // Strike range (equation 19,20)
            Real b = n * lambda_ / 2.0;

            // Grid spacing (equation 23)
            Real eta = 2.0 * M_PI / (lambda_ * n);

            // Discount factor
            Real df = discountFactor(expiryDate);
            Real div = dividendYield(expiryDate);

            // Input to fourier transform
            std::vector<std::complex<Real> > fti;
            fti.resize(n);

            // Precalculate any discount factors etc.
            precalculateExpiry(expiryDate);

            for (Size i=0; i<n; i++)
            {
                Real v_j = eta * i;
                Real sw = eta * (3.0 + ((i % 2) == 0 ? -1.0 : 1.0) - ((i == 0) ? 1.0 : 0.0)) / 3.0; 

                std::complex<Real> psi = df * complexFourierTransform(v_j - (alpha + 1)* i1);
                psi = psi / (alpha*alpha + alpha - v_j*v_j + i1 * (2 * alpha + 1.0) * v_j);

                fti[i] = std::exp(i1 * b * v_j)  * sw * psi;
            }

            // Perform fft
            std::vector<std::complex<Real> > results(n);
            FastFourierTransform fft(log2_n);
            fft.transform(fti.begin(), fti.end(), results.begin());

            // Call prices
            std::vector<Real> prices, strikes;
            prices.resize(n);
            strikes.resize(n);
            for (Size i=0; i<n; i++)
            {
                Real k_u = -b + lambda_ * i;
                prices[i] = (std::exp(-alpha * k_u) / M_PI) * results[i].real();
                strikes[i] = std::exp(k_u);
            }

            for (const auto& payoff : payIt->second) {
                Real callPrice = LinearInterpolation(strikes.begin(), strikes.end(),
                                                     prices.begin())(payoff->strike());
                switch (payoff->optionType())
                {
                case Option::Call:
                    resultMap_[expiryDate][payoff] = callPrice;
                    break;
                case Option::Put:
                    resultMap_[expiryDate][payoff] = callPrice - process_->x0() * div + payoff->strike() * df;
                    break;
                default:
                    QL_FAIL("Invalid option type");
                }
            }
        }
    }

}

]]></document_content>
  </document>
  <document index="474">
    <source>variancegamma/fftengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fftengine.hpp
    \brief base class for FFT option pricing engines
*/

#ifndef quantlib_fft_engine_hpp
#define quantlib_fft_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/stochasticprocess.hpp>
#include <complex>

namespace QuantLib {

    //! Base class for FFT pricing engines for European vanilla options
    /*! \ingroup vanillaengines
    
        The FFT engine calculates the values of all options with the same expiry at the same time.
        For that reason it is very inefficient to price options individually.  When using this engine
        you should collect all the options you wish to price in a list and call 
        the engine's precalculate method before calling the NPV method of the option.

        References:
        Carr, P. and D. B. Madan (1998),
        "Option Valuation using the fast Fourier transform,"
        Journal of Computational Finance, 2, 61-73.
    */

    class FFTEngine :
        public VanillaOption::engine {
    public:
      FFTEngine(ext::shared_ptr<StochasticProcess1D> process, Real logStrikeSpacing);
      void calculate() const override;
      void update() override;

      void precalculate(const std::vector<ext::shared_ptr<Instrument> >& optionList);
        #if defined(QL_USE_STD_UNIQUE_PTR)
        virtual std::unique_ptr<FFTEngine> clone() const = 0;
        #else
        virtual std::auto_ptr<FFTEngine> clone() const = 0;
        #endif
    protected:
        virtual void precalculateExpiry(Date d) = 0;
        virtual std::complex<Real> complexFourierTransform(std::complex<Real> u) const = 0;
        virtual Real discountFactor(Date d) const = 0;
        virtual Real dividendYield(Date d) const = 0;
        void calculateUncached(const ext::shared_ptr<StrikedTypePayoff>& payoff,
                               const ext::shared_ptr<Exercise>& exercise) const;

        ext::shared_ptr<StochasticProcess1D> process_;
        Real lambda_;   // Log strike spacing

    private:
        typedef std::map<ext::shared_ptr<StrikedTypePayoff>, Real> PayoffResultMap;
        typedef std::map<Date, PayoffResultMap> ResultMap;
        ResultMap resultMap_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="475">
    <source>variancegamma/fftvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/variancegamma/fftvanillaengine.hpp>
#include <ql/exercise.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/auto_ptr.hpp>
#include <complex>

namespace QuantLib {

    FFTVanillaEngine::FFTVanillaEngine(
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process, Real logStrikeSpacing)
        : FFTEngine(process, logStrikeSpacing)
    {
    }

    QL_UNIQUE_OR_AUTO_PTR<FFTEngine> FFTVanillaEngine::clone() const
    {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(process_);
        return QL_UNIQUE_OR_AUTO_PTR<FFTEngine>(
                                      new FFTVanillaEngine(process, lambda_));
    }

    void FFTVanillaEngine::precalculateExpiry(Date d)
    {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(process_);

        dividendDiscount_ =
            process->dividendYield()->discount(d);
        riskFreeDiscount_ =
            process->riskFreeRate()->discount(d);

        DayCounter rfdc  = process->riskFreeRate()->dayCounter();
        t_ = rfdc.yearFraction(process->riskFreeRate()->referenceDate(), d);

        ext::shared_ptr<BlackConstantVol> constVol = ext::dynamic_pointer_cast<BlackConstantVol>
            (*(process->blackVolatility()));
        QL_REQUIRE(constVol, "Constant volatility required");
        Real vol = constVol->blackVol(0.0, 0.0);
        var_ = vol*vol;
    }

    std::complex<Real> FFTVanillaEngine::complexFourierTransform(std::complex<Real> u) const
    {
        std::complex<Real> i1(0, 1);

        Real s = process_->x0();

        std::complex<Real> phi = std::exp(i1 * u * (std::log(s) - (var_ * t_) / 2.0) 
            - (var_ * u * u * t_) / 2.0); 
        phi = phi * std::pow(dividendDiscount_/ riskFreeDiscount_, i1 * u);
        return phi;
    }

    Real FFTVanillaEngine::discountFactor(Date d) const
    {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(process_);
        return process->riskFreeRate()->discount(d);
    }

    Real FFTVanillaEngine::dividendYield(Date d) const
    {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(process_);
        return process->dividendYield()->discount(d);
    }

}
]]></document_content>
  </document>
  <document index="476">
    <source>variancegamma/fftvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fftvanillaengine.hpp
    \brief FFT engine for vanilla options under a Black Scholes process
*/

#ifndef quantlib_fft_vanilla_engine_hpp
#define quantlib_fft_vanilla_engine_hpp

#include <ql/experimental/variancegamma/fftengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! FFT Pricing engine vanilla options under a Black Scholes process
    /*! \ingroup vanillaengines

        \test the correctness of the returned values is tested by
        comparison with Black Scholes pricing.
    */
    class FFTVanillaEngine : public FFTEngine {
    public:
        explicit FFTVanillaEngine(
            const ext::shared_ptr<GeneralizedBlackScholesProcess>&process,
            Real logStrikeSpacing = 0.001);
        #if defined(QL_USE_STD_UNIQUE_PTR)
        std::unique_ptr<FFTEngine> clone() const override;
#else
        virtual std::auto_ptr<FFTEngine> clone() const;
        #endif
    protected:
      void precalculateExpiry(Date d) override;
      std::complex<Real> complexFourierTransform(std::complex<Real> u) const override;
      Real discountFactor(Date d) const override;
      Real dividendYield(Date d) const override;

    private:
        DiscountFactor dividendDiscount_;
        DiscountFactor riskFreeDiscount_;
        Time t_;
        Real var_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="477">
    <source>variancegamma/fftvariancegammaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/variancegamma/fftvariancegammaengine.hpp>
#include <ql/exercise.hpp>
#include <ql/auto_ptr.hpp>
#include <complex>

namespace QuantLib {

    FFTVarianceGammaEngine::FFTVarianceGammaEngine(
        const ext::shared_ptr<VarianceGammaProcess>& process, Real logStrikeSpacing)
        : FFTEngine(process, logStrikeSpacing)
    {
    }

    QL_UNIQUE_OR_AUTO_PTR<FFTEngine> FFTVarianceGammaEngine::clone() const
    {
        ext::shared_ptr<VarianceGammaProcess> process =
            ext::dynamic_pointer_cast<VarianceGammaProcess>(process_);
        return QL_UNIQUE_OR_AUTO_PTR<FFTEngine>(
                                new FFTVarianceGammaEngine(process, lambda_));
    }

    void FFTVarianceGammaEngine::precalculateExpiry(Date d)
    {
        ext::shared_ptr<VarianceGammaProcess> process =
            ext::dynamic_pointer_cast<VarianceGammaProcess>(process_);

        dividendDiscount_ =
            process->dividendYield()->discount(d);
        riskFreeDiscount_ =
            process->riskFreeRate()->discount(d);

        DayCounter rfdc  = process->riskFreeRate()->dayCounter();
        t_ = rfdc.yearFraction(process->riskFreeRate()->referenceDate(), d);

        sigma_ = process->sigma();
        nu_ = process->nu();
        theta_ = process->theta();
    }

    std::complex<Real> FFTVarianceGammaEngine::complexFourierTransform(std::complex<Real> u) const
    {
        Real s = process_->x0();

        std::complex<Real> i1(0, 1);

        Real omega = std::log(1.0 - theta_ * nu_ - sigma_*sigma_ * nu_ / 2.0) / nu_;
        std::complex<Real> phi = std::exp(i1 * u * (std::log(s) + omega * t_)) 
            * std::pow(dividendDiscount_/ riskFreeDiscount_, i1 * u);
        phi = phi * (std::pow((1.0 - i1 * theta_ * nu_ * u + sigma_*sigma_ * nu_ * u*u / 2.0), (-t_ / nu_)));

        return phi;
    }

    Real FFTVarianceGammaEngine::discountFactor(Date d) const
    {
        ext::shared_ptr<VarianceGammaProcess> process =
            ext::dynamic_pointer_cast<VarianceGammaProcess>(process_);
        return process->riskFreeRate()->discount(d);
    }

    Real FFTVarianceGammaEngine::dividendYield(Date d) const
    {
        ext::shared_ptr<VarianceGammaProcess> process =
            ext::dynamic_pointer_cast<VarianceGammaProcess>(process_);
        return process->dividendYield()->discount(d);
    }

}
]]></document_content>
  </document>
  <document index="478">
    <source>variancegamma/fftvariancegammaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fftvariancegammaengine.hpp
    \brief \brief FFT engine for vanilla options under a Variance Gamma process
*/

#ifndef quantlib_fft_variancegamma_engine_hpp
#define quantlib_fft_variancegamma_engine_hpp

#include <ql/experimental/variancegamma/fftengine.hpp>
#include <ql/experimental/variancegamma/variancegammaprocess.hpp>

namespace QuantLib {

    //! FFT engine for vanilla options under a Variance Gamma process
    /*! \ingroup vanillaengines

        \test the correctness of the returned values is tested by
        comparison with known good values and the analytic approach
    */
    class FFTVarianceGammaEngine : public FFTEngine {
    public:
        explicit FFTVarianceGammaEngine(
            const ext::shared_ptr<VarianceGammaProcess>&process,
            Real logStrikeSpacing = 0.001);
        #if defined(QL_USE_STD_UNIQUE_PTR)
        std::unique_ptr<FFTEngine> clone() const override;
#else
        virtual std::auto_ptr<FFTEngine> clone() const;
        #endif
    protected:
      void precalculateExpiry(Date d) override;
      std::complex<Real> complexFourierTransform(std::complex<Real> u) const override;
      Real discountFactor(Date d) const override;
      Real dividendYield(Date d) const override;

    private:
        DiscountFactor dividendDiscount_;
        DiscountFactor riskFreeDiscount_;
        Time t_;
        Real sigma_;
        Real nu_;
        Real theta_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="479">
    <source>variancegamma/variancegammamodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/variancegamma/variancegammamodel.hpp>
#include <ql/quotes/simplequote.hpp>

namespace QuantLib {

    VarianceGammaModel::VarianceGammaModel(
        const ext::shared_ptr<VarianceGammaProcess> & process)
        : CalibratedModel(3), process_(process) {
            arguments_[0] = ConstantParameter(process->sigma(),
                PositiveConstraint());
            arguments_[1] = ConstantParameter(process->nu(),
                PositiveConstraint());
            arguments_[2] = ConstantParameter(process->theta(),
                NoConstraint());

            generateArguments();

            registerWith(process_->riskFreeRate());
            registerWith(process_->dividendYield());
            registerWith(process_->s0());
    }

    void VarianceGammaModel::generateArguments() {
        process_.reset(new VarianceGammaProcess(process_->s0(),
            process_->dividendYield(),
            process_->riskFreeRate(),
            sigma(), nu(), theta()));
    }

}

]]></document_content>
  </document>
  <document index="480">
    <source>variancegamma/variancegammamodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file variancegammamodel.hpp
    \brief Variance Gamma model
*/

#ifndef quantlib_variance_gamma_model_hpp
#define quantlib_variance_gamma_model_hpp

#include <ql/models/model.hpp>
#include <ql/experimental/variancegamma/variancegammaprocess.hpp>

namespace QuantLib {

    //! Variance Gamma model
    /*! References:

        Dilip B. Madan, Peter Carr, Eric C. Chang (1998)
        "The variance gamma process and option pricing,"
        European Finance Review, 2, 79-105

        \warning calibration is not implemented for VG
    */
    class VarianceGammaModel : public CalibratedModel {
      public:
        explicit VarianceGammaModel(
                      const ext::shared_ptr<VarianceGammaProcess>& process);

        // sigma
        Real sigma() const { return arguments_[0](0.0); }
        // nu
        Real nu() const { return arguments_[1](0.0); }
        // theta
        Real theta() const { return arguments_[2](0.0); }

        // underlying process
        ext::shared_ptr<VarianceGammaProcess> process() const { return process_; }

    protected:
      void generateArguments() override;
      ext::shared_ptr<VarianceGammaProcess> process_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="481">
    <source>variancegamma/variancegammaprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/experimental/variancegamma/variancegammaprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/processes/eulerdiscretization.hpp>
#include <utility>

namespace QuantLib {

    VarianceGammaProcess::VarianceGammaProcess(Handle<Quote> s0,
                                               Handle<YieldTermStructure> dividendYield,
                                               Handle<YieldTermStructure> riskFreeRate,
                                               Real sigma,
                                               Real nu,
                                               Real theta)
    : StochasticProcess1D(ext::shared_ptr<discretization>(new EulerDiscretization)),
      s0_(std::move(s0)), dividendYield_(std::move(dividendYield)),
      riskFreeRate_(std::move(riskFreeRate)), sigma_(sigma), nu_(nu), theta_(theta) {
        registerWith(riskFreeRate_);
        registerWith(dividendYield_);
        registerWith(s0_);
    }

    Real VarianceGammaProcess::x0() const
    {
        return s0_->value();
    }

    Real VarianceGammaProcess::drift(Time /*t*/, Real /*x*/) const
    {
        QL_FAIL("not implemented yet");
    }

    Real VarianceGammaProcess::diffusion(Time /*t*/, Real /*x*/) const
    {
        QL_FAIL("not implemented yet");
    }

    const Handle<Quote>& VarianceGammaProcess::s0() const {
        return s0_;
    }

    const Handle<YieldTermStructure>& VarianceGammaProcess::dividendYield() const {
        return dividendYield_;
    }

    const Handle<YieldTermStructure>& VarianceGammaProcess::riskFreeRate() const {
        return riskFreeRate_;
    }

}
]]></document_content>
  </document>
  <document index="482">
    <source>variancegamma/variancegammaprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file variancegammaprocess.hpp
    \brief Variance Gamma stochastic process
*/

#ifndef quantlib_variance_gamma_process_hpp
#define quantlib_variance_gamma_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    //! Variance gamma process

    /*! This class describes the stochastic volatility
    process.  With a Brownian motion given by
    \f[
        db = \theta dt + \sigma dW_t
    \f]
    then a Variance Gamma process X is defined by evaluating this
    Brownian motion at sample times driven by a Gamma process. If T is
    the value of a Gamma process with mean 1 and variance rate \f$ \nu
    \f$ then the Variance Gamma process is given by
    \f[
        X(t) = B(T)
    \f]

    \ingroup processes
    */
    class VarianceGammaProcess : public StochasticProcess1D {
    public:
      VarianceGammaProcess(Handle<Quote> s0,
                           Handle<YieldTermStructure> dividendYield,
                           Handle<YieldTermStructure> riskFreeRate,
                           Real sigma,
                           Real nu,
                           Real theta);

      Real x0() const override;
      Real drift(Time t, Real x) const override;
      Real diffusion(Time t, Real x) const override;

      Real sigma() const { return sigma_; }
      Real nu() const { return nu_; }
      Real theta() const { return theta_; }

      const Handle<Quote>& s0() const;
      const Handle<YieldTermStructure>& dividendYield() const;
      const Handle<YieldTermStructure>& riskFreeRate() const;

    private:
        Handle<Quote> s0_;
        Handle<YieldTermStructure> dividendYield_, riskFreeRate_;
        Real sigma_, nu_, theta_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="483">
    <source>varianceoption/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    integralhestonvarianceoptionengine.hpp \
    varianceoption.hpp

cpp_files = \
    integralhestonvarianceoptionengine.cpp \
    varianceoption.cpp

if UNITY_BUILD

nodist_libVarianceOption_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libVarianceOption_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libVarianceOption.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="484">
    <source>varianceoption/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/varianceoption/integralhestonvarianceoptionengine.hpp>
#include <ql/experimental/varianceoption/varianceoption.hpp>

]]></document_content>
  </document>
  <document index="485">
    <source>varianceoption/integralhestonvarianceoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Lorella Fatone
 Copyright (C) 2008 Francesca Mariani
 Copyright (C) 2008 Maria Cristina Recchioni
 Copyright (C) 2008 Francesco Zirilli
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/experimental/varianceoption/integralhestonvarianceoptionengine.hpp>
#include <ql/functional.hpp>
#include <complex>
#include <utility>
#include <memory>

namespace QuantLib {

    namespace {

    /*
     *****************************************************************
     **
     ** Parameters defining the initial condition of the Heston model
     ** and the European call option
     **
     *****************************************************************
     */
    /*
     *****************************************************************
     ** Assign: v0, eprice, tau, rtax
     ******************************************************************
     ******************************************************************
     **     v0: initial variance
     ** eprice: realized variance strike price
     **    tau: time to maturity
     *    rtax: risk free interest rate
     ****************************************************************
     */

    typedef std::complex<Real> Complex;

    Real IvopOneDim(Real eps, Real chi, Real theta, Real /*rho*/,
                      Real v0, Real eprice, Time tau, Real rtax)
    {
        Real ss=0.0;
        std::unique_ptr<double[]> xiv(new double[2048*2048+1]);
        double nris=0.0;
        int j=0,mm=0;
        double pi=0,pi2=0;
        double dstep=0;
        Real option=0, impart=0;

        std::unique_ptr<Complex[]> ff(new Complex[2048*2048]);
        Complex xi;
        Complex ui,beta,zita,gamma,csum,vero;
        Complex contrib, caux, caux1,caux2,caux3;

        ui=Complex(0.0,1.0);

        /*
         **********************************************************
         **   i0: initial integrated variance i0=0
         **********************************************************
         */
        Real i0=0.0;
        //s=2.0*chi*theta/(eps*eps)-1.0;

        //s=s+1;

        /*
         *************************************************
         ** Start integration procedure
         *************************************************
         */

        pi= 3.14159265358979324;
        pi2=2.0*pi;
        Real s=2.0*chi*theta/(eps*eps)-1.0;
        /*
         ****************************************
         ** Note that s must be greater than zero
         ****************************************
         */

        if(s<=0)
        {
            QL_FAIL("this parameter must be greater than zero-> " << s);
        }

        ss=s+1;

        /*
         *************************************************
         ** Start integration procedure
         *************************************************

         **************************************************************
         ** The oscillatory integral that approximates the price of
         ** the realized variance option is computed using the method
         ** proposed by Bailey, Swarztrauber in the paper published in
         ** Siam Journal on Scientific Computing Vol 15(5) 1994
         ** p. 1105-1110
         **************************************************************

         **************************************************************
         ** dstep: real number, generally a power of two, that must be
         **        assigned to determine the grid of
         **        integration. Hint: dstep=256 or 512 (dstep<=2048)
         **************************************************************
         */
        dstep=256.0;
        nris=std::sqrt(pi2)/dstep;
        mm=(int)(pi2/(nris*nris));

        /*
         ******************************************
         **  Definition of the integration grid  **
         ******************************************
         */
        for (j=0;j<=mm-1;j++)
        {
            xiv[j+1]=(j-mm/2.0)*nris;
        }

        for (j=0;j<=mm-1;j++)
        {
            xi=xiv[j+1];
            caux=chi*chi;
            caux1=2.0*eps*eps;
            caux1=caux1*xi;
            caux1=caux1*ui;
            caux2=caux1+caux;

            zita=0.5*std::sqrt(caux2);

            caux1=std::exp(-2.0*tau*zita);

            beta=0.5*chi+zita;
            beta=beta+caux1*(zita-0.5*chi);
            gamma=1.0-caux1;

            caux=-ss*tau;
            caux2=caux*(zita-0.5*chi);
            caux=ss*std::log(2.0*(zita/beta));
            caux3=-v0*ui*xi*(gamma/beta);
            caux=caux+caux3;
            caux=caux+caux2;

            ff[j+1]=std::exp(caux);
            if(std::sqrt(std::imag(xi)*std::imag(xi)+std::real(xi)*std::real(xi))>1.e-06)
            {
                contrib=-eprice/(ui*xi);
                caux=ui*xi;
                caux=caux*eprice;
                caux=std::exp(caux);
                caux=caux-1.0;
                caux2=ui*xi*ui*xi;
                contrib=contrib+caux/caux2;
            }
            else
            {
                contrib=eprice*eprice*0.5;
            }
            ff[j+1]=ff[j+1]*contrib;
        }
        csum=0.0;
        for (j=0;j<=mm-1;j++)
        {
            caux=std::pow(-1.0,j);
            caux2=-2.0*pi*(double)mm*(double)j*0.5/(double)mm;
            caux3=ui*caux2;
            csum=csum+ff[j+1]*caux*std::exp(caux3);
        }
        csum=csum*std::sqrt(std::pow(-1.0,mm))*nris/pi2;
        vero=i0-eprice+theta*tau+(1.0-std::exp(-chi*tau))*(v0-theta)/chi;
        csum=csum+vero;
        option=std::exp(-rtax*tau)*std::real(csum);
        impart=std::imag(csum);
        QL_ENSURE(impart <= 1e-12,
                  "imaginary part option (must be zero) = " << impart);
        return option;
    }



    Real IvopTwoDim(Real eps, Real chi, Real theta, Real /*rho*/,
                    Real v0, Time tau, Real rtax,
                    const ext::function<Real(Real)>& payoff) {

        Real ss=0.0;
        std::unique_ptr<double[]> xiv(new double[2048*2048+1]);
        std::unique_ptr<double[]> ivet(new double[2048 * 2048 + 1]);
        double nris=0.0;
        int j=0,mm=0,k=0;
        double pi=0,pi2=0;

        double dstep=0;
        Real ip=0;
        Real payoffval=0;
        Real option=0/*, impart=0*/;

        Real sumr=0;//,sumi=0;
        Complex dxi,z;

        std::unique_ptr<Complex[]> ff(new Complex[2048*2048]);
        Complex xi;
        Complex ui,beta,zita,gamma,csum;
        Complex caux,caux1,caux2,caux3;

        ui=Complex(0.0,1.0);

        /*
         **********************************************************
         **   i0: initial integrated variance i0=0
         **********************************************************
         */
        Real i0=0.0;

        /*
         *************************************************
         ** Start integration procedure
         *************************************************
         */

        pi= 3.14159265358979324;
        pi2=2.0*pi;

        Real s=2.0*chi*theta/(eps*eps)-1.0;
        /*
         ****************************************
         ** Note that s must be greater than zero
         ****************************************
         */

        if(s<=0)
        {
            QL_FAIL("this parameter must be greater than zero-> " << s);
        }

        ss=s+1;

        /*
         *************************************************
         ** Start integration procedure
         *************************************************

         **************************************************************
         ** The oscillatory integral that approximates the price of
         ** the realized variance option is computed using the method
         ** proposed by Bailey, Swarztrauber in the paper published in
         ** Siam Journal on Scientific Computing Vol 15(5) 1994
         ** p. 1105-1110
         **************************************************************

         **************************************************************
         ** dstep: real number, generally a power of two that must be
         **        assigned to determine the grid of
         **        integration. Hint: dstep=256 or 512 (dstep<=2048)
         **************************************************************
         */
        dstep=64.0;
        nris=std::sqrt(pi2)/dstep;
        mm=(int)(pi2/(nris*nris));

        /*
         ******************************************
         **  Definition of the integration grid  **
         ******************************************
         */

        for (j=0;j<=mm-1;j++)
        {
            xiv[j+1]=(j-mm/2.0)*nris;
            ivet[j+1]=(j-mm/2.0)*pi2/((double)mm*nris);
        }

        for (j=0;j<=mm-1;j++)
        {
            xi=xiv[j+1];

            caux=chi*chi;
            caux1=2.0*eps*eps;
            caux1=caux1*xi;
            caux1=caux1*ui;
            caux2=caux1+caux;

            zita=0.5*std::sqrt(caux2);
            caux1=std::exp(-2.0*tau*zita);

            beta=0.5*chi+zita;
            beta=beta+caux1*(zita-0.5*chi);

            gamma=1.0-caux1;

            caux=-ss*tau;
            caux2=caux*(zita-0.5*chi);
            caux=ss*std::log(2.0*(zita/beta));
            caux3=-v0*ui*xi*(gamma/beta);
            caux=caux+caux3;
            caux=caux+caux2;
            ff[j+1]=std::exp(caux);
        }

        sumr=0.0;
        //sumi=0.0;
        for (k=0;k<=mm-1;k++)
        {
            ip=i0-ivet[k+1];
            payoffval=payoff(ip);

            dxi=2.0*pi*(double)k/(double)mm*ui;
            csum=0.0;
            for (j=0;j<=mm-1;j++)
            {
                z=-(double)j*dxi;
                caux=std::pow(-1.0,j);
                csum=csum+ff[j+1]*caux*std::exp(z);
            }
            csum=csum*std::pow(-1.0,k)*nris/pi2;

            sumr=sumr+payoffval*std::real(csum);
            //sumi=sumi+payoffval*std::imag(csum);
        }
        sumr=sumr*nris;
        //sumi=sumi*nris;

        option=std::exp(-rtax*tau)*sumr;
        //impart=sumi;
        //QL_ENSURE(impart <= 1e-3,
        //          "imaginary part option (must be close to zero) = " << impart);
        return option;
    }

    struct payoff_adapter {
        ext::shared_ptr<QuantLib::Payoff> payoff;
        explicit payoff_adapter(ext::shared_ptr<QuantLib::Payoff> payoff)
        : payoff(std::move(payoff)) {}
        Real operator()(Real S) const {
            return (*payoff)(S);
        }
    };

    }

    IntegralHestonVarianceOptionEngine::IntegralHestonVarianceOptionEngine(
        ext::shared_ptr<HestonProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void IntegralHestonVarianceOptionEngine::calculate() const {

        QL_REQUIRE(process_->dividendYield().empty(),
                   "this engine does not manage dividend yields");

        Handle<YieldTermStructure> riskFreeRate = process_->riskFreeRate();

        Real epsilon = process_->sigma();
        Real chi = process_->kappa();
        Real theta = process_->theta();
        Real rho = process_->rho();
        Real v0 = process_->v0();

        Time tau = riskFreeRate->dayCounter().yearFraction(
                                        Settings::instance().evaluationDate(),
                                        arguments_.maturityDate);
        Rate r = riskFreeRate->zeroRate(arguments_.maturityDate,
                                        riskFreeRate->dayCounter(),
                                        Continuous);

        ext::shared_ptr<PlainVanillaPayoff> plainPayoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        if ((plainPayoff != nullptr) && plainPayoff->optionType() == Option::Call) {
            // a specialization for Call options is available
            Real strike = plainPayoff->strike();
            results_.value = IvopOneDim(epsilon, chi, theta, rho,
                                        v0, strike, tau, r)
                * arguments_.notional;
        } else {
            results_.value = IvopTwoDim(epsilon, chi, theta, rho, v0, tau, r,
                                        payoff_adapter(arguments_.payoff))
                * arguments_.notional;
        }
    }

}

]]></document_content>
  </document>
  <document index="486">
    <source>varianceoption/integralhestonvarianceoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file integralhestonvarianceoptionengine.hpp
    \brief integral Heston-model variance-option engine
*/

#ifndef quantlib_integral_heston_variance_option_engine_hpp
#define quantlib_integral_heston_variance_option_engine_hpp

#include <ql/experimental/varianceoption/varianceoption.hpp>
#include <ql/processes/hestonprocess.hpp>

namespace QuantLib {

    //! integral Heston-model variance-option engine
    /*! This engine implements the approach described in
        <http://www.econ.univpm.it/recchioni/finance/w4/>.

        \ingroup forwardengines
    */
    class IntegralHestonVarianceOptionEngine : public VarianceOption::engine  {
      public:
        explicit IntegralHestonVarianceOptionEngine(ext::shared_ptr<HestonProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<HestonProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="487">
    <source>varianceoption/varianceoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/experimental/varianceoption/varianceoption.hpp>
#include <utility>

namespace QuantLib {

    VarianceOption::VarianceOption(ext::shared_ptr<Payoff> payoff,
                                   Real notional,
                                   const Date& startDate,
                                   const Date& maturityDate)
    : payoff_(std::move(payoff)), notional_(notional), startDate_(startDate),
      maturityDate_(maturityDate) {}

    void VarianceOption::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<VarianceOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff = payoff_;
        arguments->notional = notional_;
        arguments->startDate = startDate_;
        arguments->maturityDate = maturityDate_;
    }

    void VarianceOption::arguments::validate() const {
        QL_REQUIRE(payoff, "no strike given");
        QL_REQUIRE(notional != Null<Real>(), "no notional given");
        QL_REQUIRE(notional > 0.0, "negative or null notional given");
        QL_REQUIRE(startDate != Date(), "null start date given");
        QL_REQUIRE(maturityDate != Date(), "null maturity date given");
    }

    bool VarianceOption::isExpired() const {
        return detail::simple_event(maturityDate_).hasOccurred();
    }

}
]]></document_content>
  </document>
  <document index="488">
    <source>varianceoption/varianceoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file varianceoption.hpp
    \brief Variance option
*/

#ifndef quantlib_variance_option_hpp
#define quantlib_variance_option_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/option.hpp>
#include <ql/position.hpp>

namespace QuantLib {

    //! Variance option
    /*! \warning This class does not manage seasoned variance options.

        \ingroup instruments
    */
    class VarianceOption : public Instrument {
      public:
        class arguments;
        class results;
        class engine;
        VarianceOption(ext::shared_ptr<Payoff> payoff,
                       Real notional,
                       const Date& startDate,
                       const Date& maturityDate);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        //@}
        //! \name Inspectors
        //@{
        Date startDate() const;
        Date maturityDate() const;
        Real notional() const;
        ext::shared_ptr<Payoff> payoff() const;
        //@}
        void setupArguments(PricingEngine::arguments* args) const override;

      protected:
        // data members
        ext::shared_ptr<Payoff> payoff_;
        Real notional_;
        Date startDate_, maturityDate_;
    };


    //! %Arguments for forward fair-variance calculation
    class VarianceOption::arguments : public virtual PricingEngine::arguments {
      public:
        arguments() : notional(Null<Real>()) {}
        void validate() const override;
        ext::shared_ptr<Payoff> payoff;
        Real notional;
        Date startDate;
        Date maturityDate;
    };


    //! %Results from variance-option calculation
    class VarianceOption::results : public Instrument::results {};

    //! base class for variance-option engines
    class VarianceOption::engine :
        public GenericEngine<VarianceOption::arguments,
                             VarianceOption::results> {};


    // inline definitions

    inline Date VarianceOption::startDate() const {
        return startDate_;
    }

    inline Date VarianceOption::maturityDate() const {
        return maturityDate_;
    }

    inline Real VarianceOption::notional() const {
        return notional_;
    }

    inline ext::shared_ptr<Payoff> VarianceOption::payoff() const {
        return payoff_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="489">
    <source>volatility/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    abcdatmvolcurve.hpp \
    blackatmvolcurve.hpp \
    blackvolsurface.hpp \
    equityfxvolsurface.hpp \
    extendedblackvariancecurve.hpp \
    extendedblackvariancesurface.hpp \
    interestratevolsurface.hpp \
    noarbsabr.hpp \
    noarbsabrinterpolatedsmilesection.hpp \
    noarbsabrinterpolation.hpp \
    noarbsabrsmilesection.hpp \
    sabrvolsurface.hpp \
    sabrvoltermstructure.hpp \
    sviinterpolatedsmilesection.hpp \
    sviinterpolation.hpp \
    svismilesection.hpp \
    swaptionvolcube1a.hpp \
    volcube.hpp \
    zabr.hpp \
    zabrinterpolatedsmilesection.hpp \
    zabrinterpolation.hpp \
    zabrsmilesection.hpp

cpp_files = \
    abcdatmvolcurve.cpp \
    blackatmvolcurve.cpp \
    blackvolsurface.cpp \
    equityfxvolsurface.cpp \
    extendedblackvariancecurve.cpp \
    extendedblackvariancesurface.cpp \
    interestratevolsurface.cpp \
    noarbsabr.cpp \
    noarbsabrabsprobs.cpp \
    noarbsabrinterpolatedsmilesection.cpp \
    noarbsabrsmilesection.cpp \
    sabrvolsurface.cpp \
    sviinterpolatedsmilesection.cpp \
    svismilesection.cpp \
    volcube.cpp \
    zabr.cpp

if UNITY_BUILD

nodist_libVolatility_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libVolatility_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libVolatility.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="490">
    <source>volatility/abcdatmvolcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/abcdatmvolcurve.hpp>
#include <ql/quote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    // floating reference date, floating market data
    AbcdAtmVolCurve::AbcdAtmVolCurve(Natural settlDays,
                                     const Calendar& cal,
                                     const std::vector<Period>& optionTenors,
                                     const std::vector<Handle<Quote> >& volsHandles,
                                     std::vector<bool> inclusionInInterpolationFlag,
                                     BusinessDayConvention bdc,
                                     const DayCounter& dc)
    : BlackAtmVolCurve(settlDays, cal, bdc, dc), nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors), optionDates_(nOptionTenors_), optionTimes_(nOptionTenors_),
      actualOptionTimes_(nOptionTenors_), volHandles_(volsHandles), vols_(volsHandles.size()),
      actualVols_(volsHandles.size()),
      inclusionInInterpolation_(std::move(inclusionInInterpolationFlag)),
      interpolation_(ext::shared_ptr<AbcdInterpolation>()) // do not initialize with nOptionTenors_
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        initializeVolatilities();
        registerWithMarketData();
        for (Size i=0; i<vols_.size(); ++i)
            vols_[i] = volHandles_[i]->value();
        interpolate();
    }

    void AbcdAtmVolCurve::checkInputs() const
    {
        QL_REQUIRE(!optionTenors_.empty(), "empty option tenor vector");
        QL_REQUIRE(nOptionTenors_==vols_.size(),
                   "mismatch between number of option tenors (" <<
                   nOptionTenors_ << ") and number of volatilities (" <<
                   vols_.size() << ")");
        QL_REQUIRE(optionTenors_[0]>0*Days,
                   "negative first option tenor: " << optionTenors_[0]);
        for (Size i=1; i<nOptionTenors_; ++i)
            QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
                       "non increasing option tenor: " << io::ordinal(i) <<
                       " is " << optionTenors_[i-1] << ", " <<
                       io::ordinal(i+1) << " is " << optionTenors_[i]);
        if (inclusionInInterpolation_.size()==1) {
            inclusionInInterpolation_.resize(nOptionTenors_);
            for(Size j=1; j<nOptionTenors_;++j)
                inclusionInInterpolation_[j] = inclusionInInterpolation_[0];
        } else
            QL_REQUIRE(nOptionTenors_==inclusionInInterpolation_.size(),
                       "mismatch between number of option tenors (" <<
                       nOptionTenors_ << ") and number of inclusion's flags (" <<
                       inclusionInInterpolation_.size() << ")");
    }

    void AbcdAtmVolCurve::registerWithMarketData()
    {
        for (auto& volHandle : volHandles_)
            registerWith(volHandle);
    }

    void AbcdAtmVolCurve::interpolate()
    {
        interpolation_ = ext::make_shared<AbcdInterpolation>(actualOptionTimes_.begin(),
                                              actualOptionTimes_.end(),
                                              actualVols_.begin());
    }

    void AbcdAtmVolCurve::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<AbcdAtmVolCurve>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a AbcdAtmVolCurve visitor");
    }

    void AbcdAtmVolCurve::update()
    {
        // recalculate dates if necessary...
        if (moving_) {
            Date d = Settings::instance().evaluationDate();
            if (evaluationDate_ != d) {
                evaluationDate_ = d;
                initializeOptionDatesAndTimes();
            }
        }
        BlackAtmVolCurve::update();
        LazyObject::update();
    }

    void AbcdAtmVolCurve::initializeOptionDatesAndTimes() const
    {
        // the input time data
        for (Size i=0; i<nOptionTenors_; ++i) {
            optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
            optionTimes_[i] = timeFromReference(optionDates_[i]);
        }
        // the time data used for interpolation
        actualOptionTimes_.clear();
        for (Size i=0; i<nOptionTenors_; ++i) {
            if (inclusionInInterpolation_[i]) {
                actualOptionTimes_.push_back(optionTimes_[i]);
                actualOptionTenors_.push_back(optionTenors_[i]);
            }
        }
    }

    void AbcdAtmVolCurve::initializeVolatilities() {

        actualVols_.clear();
        for (Size i=0; i<nOptionTenors_; ++i) {
            vols_[i] = volHandles_[i]->value();
            if (inclusionInInterpolation_[i])
                actualVols_.push_back(vols_[i]);
        }
    }

    void AbcdAtmVolCurve::performCalculations() const
    {
        // check if date recalculation must be called here
        actualVols_.clear();
        for (Size i=0; i<vols_.size(); ++i) {
            vols_[i] = volHandles_[i]->value();
            if (inclusionInInterpolation_[i])
                actualVols_.push_back(vols_[i]);
        }
        interpolation_->update();
    }

}
]]></document_content>
  </document>
  <document index="491">
    <source>volatility/abcdatmvolcurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file abcdatmvolcurve.hpp
    \brief Abcd-interpolated at-the-money (no-smile) interest rate vol curve
*/

#ifndef quantlib_abcd_atm_vol_curve_hpp
#define quantlib_abcd_atm_vol_curve_hpp

#include <ql/experimental/volatility/blackatmvolcurve.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/math/interpolations/abcdinterpolation.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

namespace QuantLib {

    class Quote;

    //! Abcd-interpolated at-the-money (no-smile) volatility curve
    /*! blah blah
    */
    class AbcdAtmVolCurve : public BlackAtmVolCurve,
                            public LazyObject {
      public:
        //! floating reference date, floating market data
        AbcdAtmVolCurve(Natural settlementDays,
                        const Calendar& cal,
                        const std::vector<Period>& optionTenors,
                        const std::vector<Handle<Quote> >& volsHandles,
                        std::vector<bool> inclusionInInterpolationFlag = std::vector<bool>(1, true),
                        BusinessDayConvention bdc = Following,
                        const DayCounter& dc = Actual365Fixed());
        //! Returns k adjustment factors for option tenors used in interpolation
        std::vector<Real> k() const;
        //! Returns k adjustment factor at time t
        Real k(Time t) const;
        Real a() const;
        Real b() const;
        Real c() const;
        Real d() const;
        Real rmsError() const;
        Real maxError() const;
        EndCriteria::Type endCriteria() const;
        //! \name TermStructure interface
        //@{
        Date maxDate() const override;
        //@}
        //! \name VolatilityTermStructure interface
        //@{
        Real minStrike() const override;
        Real maxStrike() const override;
        //@}
        //! \name LazyObject interface
        //@{
        void update() override;
        void performCalculations() const override;
        //@}
        //! \name some inspectors
        //@{
        const std::vector<Period>& optionTenors() const;
        const std::vector<Period>& optionTenorsInInterpolation() const;
        const std::vector<Date>& optionDates() const;
        const std::vector<Time>& optionTimes() const;
        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      protected:
        //! \name BlackAtmVolCurve interface
        //@{
        //! spot at-the-money variance calculation (k adjusted)
        Real atmVarianceImpl(Time t) const override;
        //! spot at-the-money volatility calculation (k adjusted)
        Volatility atmVolImpl(Time t) const override;
        //@}
      private:
        void checkInputs() const;
        void initializeOptionDatesAndTimes() const;
        void initializeVolatilities();
        void registerWithMarketData();
        void interpolate();

        Size nOptionTenors_;
        std::vector<Period> optionTenors_;
        mutable std::vector<Period> actualOptionTenors_;
        mutable std::vector<Date> optionDates_;
        mutable std::vector<Time> optionTimes_;
        mutable std::vector<Time> actualOptionTimes_;
        Date evaluationDate_;

        std::vector<Handle<Quote> > volHandles_;
        mutable std::vector<Volatility> vols_;
        mutable std::vector<Volatility> actualVols_;

        mutable std::vector<bool> inclusionInInterpolation_;

        ext::shared_ptr<AbcdInterpolation> interpolation_;
    };

    // inline

    inline Date AbcdAtmVolCurve::maxDate() const {
        calculate();
        return optionDateFromTenor(optionTenors_.back());
    }

    inline Real AbcdAtmVolCurve::minStrike() const {
        return QL_MIN_REAL;
    }

    inline Real AbcdAtmVolCurve::maxStrike() const {
        return QL_MAX_REAL;
    }

    inline Real AbcdAtmVolCurve::atmVarianceImpl(Time t) const {
        Volatility vol = atmVolImpl(t);
        return vol*vol*t;
    }

    inline Volatility AbcdAtmVolCurve::atmVolImpl(Time t) const {
        calculate();
        return k(t) * (*interpolation_)(t, true);
    }

    inline const std::vector<Period>& AbcdAtmVolCurve::optionTenors() const {
         return optionTenors_;
    }

    inline const std::vector<Period>& AbcdAtmVolCurve::optionTenorsInInterpolation() const {
        return actualOptionTenors_;
    }

    inline
    const std::vector<Date>& AbcdAtmVolCurve::optionDates() const {
        return optionDates_;
    }

    inline
    const std::vector<Time>& AbcdAtmVolCurve::optionTimes() const {
        return optionTimes_;
    }

    inline
    std::vector<Real> AbcdAtmVolCurve::k() const {
        return interpolation_->k();
    }

    inline
    Real AbcdAtmVolCurve::k(Time t) const {
        return interpolation_->k(t,actualOptionTimes_.begin(),actualOptionTimes_.end());
    }

    inline Real AbcdAtmVolCurve::a() const {
        return interpolation_->a();
    }

    inline Real AbcdAtmVolCurve::b() const {
        return interpolation_->b();
    }

    inline Real AbcdAtmVolCurve::c() const {
        return interpolation_->c();
    }

    inline Real AbcdAtmVolCurve::d() const {
        return interpolation_->d();
    }

    inline Real AbcdAtmVolCurve::rmsError() const {
        return interpolation_->rmsError();
    }
    inline Real AbcdAtmVolCurve::maxError() const {
        return interpolation_->maxError();
    }
}

#endif
]]></document_content>
  </document>
  <document index="492">
    <source>volatility/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/volatility/abcdatmvolcurve.hpp>
#include <ql/experimental/volatility/blackatmvolcurve.hpp>
#include <ql/experimental/volatility/blackvolsurface.hpp>
#include <ql/experimental/volatility/equityfxvolsurface.hpp>
#include <ql/experimental/volatility/extendedblackvariancecurve.hpp>
#include <ql/experimental/volatility/extendedblackvariancesurface.hpp>
#include <ql/experimental/volatility/interestratevolsurface.hpp>
#include <ql/experimental/volatility/noarbsabr.hpp>
#include <ql/experimental/volatility/noarbsabrinterpolatedsmilesection.hpp>
#include <ql/experimental/volatility/noarbsabrinterpolation.hpp>
#include <ql/experimental/volatility/noarbsabrsmilesection.hpp>
#include <ql/experimental/volatility/sabrvolsurface.hpp>
#include <ql/experimental/volatility/sabrvoltermstructure.hpp>
#include <ql/experimental/volatility/sviinterpolatedsmilesection.hpp>
#include <ql/experimental/volatility/sviinterpolation.hpp>
#include <ql/experimental/volatility/svismilesection.hpp>
#include <ql/experimental/volatility/swaptionvolcube1a.hpp>
#include <ql/experimental/volatility/volcube.hpp>
#include <ql/experimental/volatility/zabr.hpp>
#include <ql/experimental/volatility/zabrinterpolatedsmilesection.hpp>
#include <ql/experimental/volatility/zabrinterpolation.hpp>
#include <ql/experimental/volatility/zabrsmilesection.hpp>

]]></document_content>
  </document>
  <document index="493">
    <source>volatility/blackatmvolcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/blackatmvolcurve.hpp>

namespace QuantLib {

    BlackAtmVolCurve::BlackAtmVolCurve(BusinessDayConvention bdc,
                                       const DayCounter& dc)
    : VolatilityTermStructure(bdc, dc) {}

    BlackAtmVolCurve::BlackAtmVolCurve(const Date& refDate,
                                       const Calendar& cal,
                                       BusinessDayConvention bdc,
                                       const DayCounter& dc)
    : VolatilityTermStructure(refDate, cal, bdc, dc) {}

    BlackAtmVolCurve::BlackAtmVolCurve(Natural settlDays,
                                       const Calendar& cal,
                                       BusinessDayConvention bdc,
                                       const DayCounter& dc)
    : VolatilityTermStructure(settlDays, cal, bdc, dc) {}

    Volatility BlackAtmVolCurve::atmVol(const Period& optionTenor,
                                        bool extrapolate) const {
        Date d = optionDateFromTenor(optionTenor);
        return atmVol(d, extrapolate);
    }

    Volatility BlackAtmVolCurve::atmVol(const Date& d,
                                        bool extrapolate) const {
        Time t = timeFromReference(d);
        return atmVol(t, extrapolate);
    }

    Volatility BlackAtmVolCurve::atmVol(Time t,
                                        bool extrapolate) const {
        checkRange(t, extrapolate);
        return atmVolImpl(t);
    }

    Real BlackAtmVolCurve::atmVariance(const Period& optionTenor,
                                       bool extrapolate) const {
        Date d = optionDateFromTenor(optionTenor);
        return atmVariance(d, extrapolate);
    }

    Real BlackAtmVolCurve::atmVariance(const Date& d,
                                       bool extrapolate) const {
        Time t = timeFromReference(d);
        return atmVariance(t, extrapolate);
    }

    Real BlackAtmVolCurve::atmVariance(Time t,
                                       bool extrapolate) const {
        checkRange(t, extrapolate);
        return atmVarianceImpl(t);
    }

    void BlackAtmVolCurve::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<BlackAtmVolCurve>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a BlackAtmVolCurve visitor");
    }

}
]]></document_content>
  </document>
  <document index="494">
    <source>volatility/blackatmvolcurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackatmvolcurve.hpp
    \brief Black at-the-money (no-smile) volatility curve base class
*/

#ifndef quantlib_black_atm_vol_curve_hpp
#define quantlib_black_atm_vol_curve_hpp

#include <ql/termstructures/voltermstructure.hpp>
#include <ql/patterns/visitor.hpp>

namespace QuantLib {

    //! Black at-the-money (no-smile) volatility curve
    /*! This abstract class defines the interface of concrete
        Black at-the-money (no-smile) volatility curves which will be
        derived from this one.

        Volatilities are assumed to be expressed on an annual basis.
    */
    class BlackAtmVolCurve : public VolatilityTermStructure {
      public:
        /*! \name Constructors
            See the TermStructure documentation for issues regarding
            constructors.
        */
        //@{
        //! default constructor
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        BlackAtmVolCurve(BusinessDayConvention bdc = Following,
                         const DayCounter& dc = DayCounter());
        //! initialize with a fixed reference date
        BlackAtmVolCurve(const Date& referenceDate,
                         const Calendar& cal = Calendar(),
                         BusinessDayConvention bdc = Following,
                         const DayCounter& dc = DayCounter());
        //! calculate the reference date based on the global evaluation date
        BlackAtmVolCurve(Natural settlementDays,
                         const Calendar&,
                         BusinessDayConvention bdc = Following,
                         const DayCounter& dc = DayCounter());
        //@}
        ~BlackAtmVolCurve() override = default;
        //! \name Black at-the-money spot volatility
        //@{
        //! spot at-the-money volatility
        Volatility atmVol(const Period& optionTenor,
                          bool extrapolate = false) const;
        //! spot at-the-money volatility
        Volatility atmVol(const Date& maturity,
                          bool extrapolate = false) const;
        //! spot at-the-money volatility
        Volatility atmVol(Time maturity,
                          bool extrapolate = false) const;
        //! spot at-the-money variance
        Real atmVariance(const Period& optionTenor,
                         bool extrapolate = false) const;
        //! spot at-the-money variance
        Real atmVariance(const Date& maturity,
                         bool extrapolate = false) const;
        //! spot at-the-money variance
        Real atmVariance(Time maturity,
                         bool extrapolate = false) const;
        //@}
        //! \name Visitability
        //@{
        virtual void accept(AcyclicVisitor&);
        //@}
      protected:
        /*! \name Calculations

            These methods must be implemented in derived classes to perform
            the actual volatility calculations. When they are called,
            range check has already been performed; therefore, they must
            assume that extrapolation is required.
        */
        //@{
        //! spot at-the-money variance calculation
        virtual Real atmVarianceImpl(Time t) const = 0;
        //! spot at-the-money volatility calculation
        virtual Volatility atmVolImpl(Time t) const = 0;
        //@}
    };

}

#endif
]]></document_content>
  </document>
  <document index="495">
    <source>volatility/blackvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/blackvolsurface.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>

namespace QuantLib {

    BlackVolSurface::BlackVolSurface(BusinessDayConvention bdc,
                                     const DayCounter& dc)
    : BlackAtmVolCurve(bdc, dc) {}

    BlackVolSurface::BlackVolSurface(const Date& refDate,
                                     const Calendar& cal,
                                     BusinessDayConvention bdc,
                                     const DayCounter& dc)
    : BlackAtmVolCurve(refDate, cal, bdc, dc) {}

    BlackVolSurface::BlackVolSurface(Natural settlDays,
                                     const Calendar& cal,
                                     BusinessDayConvention bdc,
                                     const DayCounter& dc)
    : BlackAtmVolCurve(settlDays, cal, bdc, dc) {}

    Real BlackVolSurface::atmVarianceImpl(Time t) const {
        const ext::shared_ptr<SmileSection>& s = smileSectionImpl(t);
        return s->variance(s->atmLevel());
    }

    Volatility BlackVolSurface::atmVolImpl(Time t) const {
        const ext::shared_ptr<SmileSection>& s = smileSectionImpl(t);
        return s->volatility(s->atmLevel());
    }

    void BlackVolSurface::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<BlackVolSurface>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a BlackVolSurface term structure visitor");
    }

}
]]></document_content>
  </document>
  <document index="496">
    <source>volatility/blackvolsurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackvolsurface.hpp
    \brief Black volatility (smile) surface
*/

#ifndef quantlib_black_vol_surface_hpp
#define quantlib_black_vol_surface_hpp

#include <ql/experimental/volatility/blackatmvolcurve.hpp>

namespace QuantLib {

    class SmileSection;

    //! Black volatility (smile) surface
    /*! This abstract class defines the interface of concrete
        Black volatility (smile) surface which will
        be derived from this one.

        Volatilities are assumed to be expressed on an annual basis.

    */
    class BlackVolSurface : public BlackAtmVolCurve {
      public:
        /*! \name Constructors
            See the TermStructure documentation for issues regarding
            constructors.
        */
        //@{
        //! default constructor
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        BlackVolSurface(BusinessDayConvention bdc = Following,
                        const DayCounter& dc = DayCounter());
        //! initialize with a fixed reference date
        BlackVolSurface(const Date& referenceDate,
                        const Calendar& cal = Calendar(),
                        BusinessDayConvention bdc = Following,
                        const DayCounter& dc = DayCounter());
        //! calculate the reference date based on the global evaluation date
        BlackVolSurface(Natural settlementDays,
                        const Calendar&,
                        BusinessDayConvention bdc = Following,
                        const DayCounter& dc = DayCounter());
        //@}
        //! \name Black spot volatility
        //@{
        //! returns the smile for a given option tenor
        ext::shared_ptr<SmileSection> smileSection(const Period&,
                                                     bool extrapolate) const;
        //! returns the smile for a given option date
        ext::shared_ptr<SmileSection> smileSection(const Date&,
                                                     bool extrapolate) const;
        //! returns the smile for a given option time
        ext::shared_ptr<SmileSection> smileSection(Time,
                                                     bool extrapolate) const;
        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      protected:
        //! \name BlackAtmVolCurve interface
        //@{
        //! spot at-the-money variance calculation
        Real atmVarianceImpl(Time t) const override;
        //! spot at-the-money volatility calculation
        Volatility atmVolImpl(Time t) const override;
        //@}
        /*! \name Calculations

            This method must be implemented in derived classes to perform
            the actual volatility calculations. When it is called,
            time check has already been performed; therefore, it must
            assume that time-extrapolation is allowed.
        */
        //@{
        virtual ext::shared_ptr<SmileSection> smileSectionImpl(Time) const=0;
        //@}
    };

    // inline definitions

    inline ext::shared_ptr<SmileSection>
    BlackVolSurface::smileSection(const Period& p,
                                  bool extrapolate) const {
        return smileSection(optionDateFromTenor(p), extrapolate);
    }

    inline ext::shared_ptr<SmileSection>
    BlackVolSurface::smileSection(const Date& d,
                                  bool extrapolate) const {
        return smileSection(timeFromReference(d), extrapolate);
    }

    inline ext::shared_ptr<SmileSection>
    BlackVolSurface::smileSection(Time t,
                                  bool extrapolate) const {
        checkRange(t, extrapolate);
        return smileSectionImpl(t);
    }

}

#endif
]]></document_content>
  </document>
  <document index="497">
    <source>volatility/equityfxvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/equityfxvolsurface.hpp>

namespace QuantLib {

    EquityFXVolSurface::EquityFXVolSurface(BusinessDayConvention bdc,
                                           const DayCounter& dc)
    : BlackVolSurface(bdc, dc) {}

    EquityFXVolSurface::EquityFXVolSurface(const Date& refDate,
                                           const Calendar& cal,
                                           BusinessDayConvention bdc,
                                           const DayCounter& dc)
    : BlackVolSurface(refDate, cal, bdc, dc) {}

    EquityFXVolSurface::EquityFXVolSurface(Natural settlDays,
                                           const Calendar& cal,
                                           BusinessDayConvention bdc,
                                           const DayCounter& dc)
    : BlackVolSurface(settlDays, cal, bdc, dc) {}

    Volatility EquityFXVolSurface::atmForwardVol(const Date& date1,
                                                 const Date& date2,
                                                 bool extrapolate) const {
        QL_REQUIRE(date1<date2, "wrong dates");
        Time t1 = timeFromReference(date1);
        Time t2 = timeFromReference(date2);
        return atmForwardVol(t1, t2, extrapolate);
    }

    Volatility EquityFXVolSurface::atmForwardVol(Time time1,
                                                 Time time2,
                                                 bool extrapolate) const {
        Real fwdVariance = atmForwardVariance(time1, time2, extrapolate);
        Time t = time2-time1;
        return std::sqrt(fwdVariance/t);
    }

    Real EquityFXVolSurface::atmForwardVariance(const Date& date1,
                                                const Date& date2,
                                                bool extrapolate) const {
        QL_REQUIRE(date1<date2, "wrong dates");
        Time t1 = timeFromReference(date1);
        Time t2 = timeFromReference(date2);
        return atmForwardVariance(t1, t2, extrapolate);
    }

    Real EquityFXVolSurface::atmForwardVariance(Time time1,
                                                Time time2,
                                                bool extrapolate) const {
        QL_REQUIRE(time1<time2, "wrong times");
        Real var1 = atmVariance(time1, extrapolate);
        Real var2 = atmVariance(time2, extrapolate);
        QL_ENSURE(var1<var2, "non-increasing variances");
        return var2-var1;
    }

    void EquityFXVolSurface::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<EquityFXVolSurface>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a EquityFXVolSurface term structure visitor");
    }

}
]]></document_content>
  </document>
  <document index="498">
    <source>volatility/equityfxvolsurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file equityfxvolsurface.hpp
    \brief Equity/FX vol (smile) surface
*/

#ifndef quantlib_equity_fx_vol_surface_hpp
#define quantlib_equity_fx_vol_surface_hpp

#include <ql/experimental/volatility/blackvolsurface.hpp>

namespace QuantLib {

    //! Equity/FX volatility (smile) surface
    /*! This abstract class defines the interface of concrete
        Equity/FX volatility (smile) surfaces which will
        be derived from this one.

        Volatilities are assumed to be expressed on an annual basis.

        It's only in absence of smile that the concept of (at-the-money)
        forward volatility makes sense.
    */
    class EquityFXVolSurface : public BlackVolSurface {
      public:
        /*! \name Constructors
            See the TermStructure documentation for issues regarding
            constructors.
        */
        //@{
        //! default constructor
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        explicit EquityFXVolSurface(BusinessDayConvention bdc = Following,
                                    const DayCounter& dc = DayCounter());
        //! initialize with a fixed reference date
        explicit EquityFXVolSurface(const Date& referenceDate,
                                    const Calendar& cal = Calendar(),
                                    BusinessDayConvention bdc = Following,
                                    const DayCounter& dc = DayCounter());
        //! calculate the reference date based on the global evaluation date
        EquityFXVolSurface(Natural settlementDays,
                           const Calendar&,
                           BusinessDayConvention bdc = Following,
                           const DayCounter& dc = DayCounter());
        //@}
        //! \name Black Volatility
        //@{
        //! forward (at-the-money) volatility
        Volatility atmForwardVol(const Date& date1,
                                 const Date& date2,
                                 bool extrapolate = false) const;
        //! forward (at-the-money) volatility
        Volatility atmForwardVol(Time time1,
                                 Time time2,
                                 bool extrapolate = false) const;
        //! forward (at-the-money) variance
        Real atmForwardVariance(const Date& date1,
                                const Date& date2,
                                bool extrapolate = false) const;
        //! forward (at-the-money) variance
        Real atmForwardVariance(Time time1,
                                Time time2,
                                bool extrapolate = false) const;
        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
    };

}

#endif
]]></document_content>
  </document>
  <document index="499">
    <source>volatility/extendedblackvariancecurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hvermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/extendedblackvariancecurve.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <utility>

namespace QuantLib {

    ExtendedBlackVarianceCurve::ExtendedBlackVarianceCurve(const Date& referenceDate,
                                                           const std::vector<Date>& dates,
                                                           std::vector<Handle<Quote> > volatilities,
                                                           DayCounter dayCounter,
                                                           bool forceMonotoneVariance)
    : BlackVarianceTermStructure(referenceDate), dayCounter_(std::move(dayCounter)),
      maxDate_(dates.back()), volatilities_(std::move(volatilities)),
      forceMonotoneVariance_(forceMonotoneVariance) {
        QL_REQUIRE(dates.size() == volatilities_.size(),
                   "size mismatch between dates and volatilities");

        QL_REQUIRE(dates[0] > referenceDate,
                   "cannot have dates_[0] <= referenceDate");

        variances_ = std::vector<Real>(dates.size()+1);
        times_ = std::vector<Time>(dates.size()+1);

        times_[0] = 0.0;
        for (Size j=1; j<=dates.size(); ++j) {
            times_[j] = timeFromReference(dates[j-1]);
            QL_REQUIRE(times_[j]>times_[j-1],
                       "dates must be sorted unique!");
        }

        setVariances();
        setInterpolation<Linear>();

        for (auto& volatilitie : volatilities_)
            registerWith(volatilitie);
    }

    void ExtendedBlackVarianceCurve::setVariances() {
        variances_[0] = 0.0;
        for (Size j=1; j<=volatilities_.size(); j++) {
            Volatility sigma = volatilities_[j-1]->value();
            variances_[j] = times_[j] * sigma * sigma;
            QL_REQUIRE(variances_[j]>=variances_[j-1]
                       || !forceMonotoneVariance_,
                       "variance must be non-decreasing");
        }
    }

    void ExtendedBlackVarianceCurve::update() {
        setVariances();
        varianceCurve_.update();
        notifyObservers();
    }

    Real ExtendedBlackVarianceCurve::blackVarianceImpl(Time t, Real) const {
        if (t<=times_.back()) {
            return varianceCurve_(t, true);
        } else {
            return varianceCurve_(times_.back(), true)*t/times_.back();
        }
    }

}

]]></document_content>
  </document>
  <document index="500">
    <source>volatility/extendedblackvariancecurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hvermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extendedblackvariancecurve.hpp
    \brief Black volatility curve modelled as variance curve
*/

#ifndef quantlib_extended_black_variance_curve_hpp
#define quantlib_extended_black_variance_curve_hpp

#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/handle.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    //! Black volatility curve modelled as variance curve
    /*! This class is similar to BlackVarianceCurve, but extends it to
        use quotes for the input volatilities.
    */
    class ExtendedBlackVarianceCurve : public BlackVarianceTermStructure {
      public:
        ExtendedBlackVarianceCurve(const Date& referenceDate,
                                   const std::vector<Date>& dates,
                                   std::vector<Handle<Quote> > volatilities,
                                   DayCounter dayCounter,
                                   bool forceMonotoneVariance = true);

        DayCounter dayCounter() const override { return dayCounter_; }
        Date maxDate() const override;
        Real minStrike() const override;
        Real maxStrike() const override;

        template <class Interpolator>
        void setInterpolation(const Interpolator& i = Interpolator()) {
            varianceCurve_ = i.interpolate(times_.begin(), times_.end(),
                                           variances_.begin());
            varianceCurve_.update();
            notifyObservers();
        }

        void accept(AcyclicVisitor&) override;
        void update() override;

      private:
        Real blackVarianceImpl(Time t, Real) const override;
        void setVariances();
        DayCounter dayCounter_;
        Date maxDate_;
        std::vector<Handle<Quote> > volatilities_;
        std::vector<Time> times_;
        std::vector<Real> variances_;
        Interpolation varianceCurve_;
        bool forceMonotoneVariance_;
    };

    inline Date ExtendedBlackVarianceCurve::maxDate() const {
        return maxDate_;
    }

    inline Real ExtendedBlackVarianceCurve::minStrike() const {
        return QL_MIN_REAL;
    }

    inline Real ExtendedBlackVarianceCurve::maxStrike() const {
        return QL_MAX_REAL;
    }

    inline void ExtendedBlackVarianceCurve::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<ExtendedBlackVarianceCurve>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            BlackVarianceTermStructure::accept(v);
    }
}


#endif
]]></document_content>
  </document>
  <document index="501">
    <source>volatility/extendedblackvariancesurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hvermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/extendedblackvariancesurface.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <utility>

namespace QuantLib {

    ExtendedBlackVarianceSurface::ExtendedBlackVarianceSurface(
        const Date& referenceDate,
        const Calendar& calendar,
        const std::vector<Date>& dates,
        std::vector<Real> strikes,
        const std::vector<Handle<Quote> >& volatilities,
        DayCounter dayCounter,
        ExtendedBlackVarianceSurface::Extrapolation lowerEx,
        ExtendedBlackVarianceSurface::Extrapolation upperEx)
    : BlackVarianceTermStructure(referenceDate, calendar), dayCounter_(std::move(dayCounter)),
      maxDate_(dates.back()), volatilities_(volatilities), strikes_(std::move(strikes)),
      lowerExtrapolation_(lowerEx), upperExtrapolation_(upperEx) {

        QL_REQUIRE(dates.size()*strikes_.size()==volatilities_.size(),
                   "size mismatch between date vector and vol matrix columns "
                   "and/or between money-strike vector and vol matrix rows");

        QL_REQUIRE(dates[0] > referenceDate,
                   "cannot have dates_[0] <= referenceDate_");


        times_ = std::vector<Time>(dates.size()+1);
        times_[0] = 0.0;

        for (Size j=1; j<=dates.size(); j++) {
            times_[j] = timeFromReference(dates[j-1]);
            QL_REQUIRE(times_[j]>times_[j-1],
                       "dates must be sorted unique");
        }

        variances_ = Matrix(strikes_.size(), dates.size()+1);
        setVariances();

        setInterpolation<Bilinear>();

        for (const auto& volatilitie : volatilities_)
            registerWith(volatilitie);
    }

    void ExtendedBlackVarianceSurface::setVariances() {

        for (Size i=0; i<times_.size()+1; i++) {
            variances_[0][i] = 0.0;
        }
        for (Size j=1; j<=times_.size(); j++) {
            for (Size i=0; i<strikes_.size(); i++) {
                Volatility sigma = volatilities_[i*times_.size()+j-1]->value();
                variances_[i][j] = times_[j] * sigma * sigma;
                QL_REQUIRE(variances_[i][j]>=variances_[i][j-1],
                           "variance must be non-decreasing");
            }
        }
    }

    void ExtendedBlackVarianceSurface::update() {
        setVariances();
        varianceSurface_.update();
        notifyObservers();
    }

    Real ExtendedBlackVarianceSurface::blackVarianceImpl(Time t,
                                                         Real strike) const {

        if (t==0.0) return 0.0;

        // enforce constant extrapolation when required
        if (strike < strikes_.front()
            && lowerExtrapolation_ == ConstantExtrapolation)
            strike = strikes_.front();
        if (strike > strikes_.back()
            && upperExtrapolation_ == ConstantExtrapolation)
            strike = strikes_.back();

        if (t<=times_.back())
            return varianceSurface_(t, strike, true);
        else // t>times_.back() || extrapolate
            return varianceSurface_(times_.back(), strike, true) *
                t/times_.back();
    }

}

]]></document_content>
  </document>
  <document index="502">
    <source>volatility/extendedblackvariancesurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hvermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extendedblackvariancesurface.hpp
    \brief Black volatility surface modelled as variance surface
*/

#ifndef quantlib_extended_black_variance_surface_hpp
#define quantlib_extended_black_variance_surface_hpp

#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/math/matrix.hpp>
#include <ql/math/interpolations/interpolation2d.hpp>
#include <ql/handle.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    //! Black volatility surface modelled as variance surface
    /*! This class is similar to BlackVarianceSurface, but extends it
        to use quotes for the input volatilities.
    */
    class ExtendedBlackVarianceSurface : public BlackVarianceTermStructure {
      public:
        enum Extrapolation { ConstantExtrapolation,
                             InterpolatorDefaultExtrapolation };
        ExtendedBlackVarianceSurface(
            const Date& referenceDate,
            const Calendar& calendar,
            const std::vector<Date>& dates,
            std::vector<Real> strikes,
            const std::vector<Handle<Quote> >& volatilities,
            DayCounter dayCounter,
            Extrapolation lowerExtrapolation = InterpolatorDefaultExtrapolation,
            Extrapolation upperExtrapolation = InterpolatorDefaultExtrapolation);
        DayCounter dayCounter() const override { return dayCounter_; }
        Date maxDate() const override { return maxDate_; }
        Real minStrike() const override { return strikes_.front(); }
        Real maxStrike() const override { return strikes_.back(); }
        template <class Interpolator>
        void setInterpolation(const Interpolator& i = Interpolator()) {
            varianceSurface_ =
                i.interpolate(times_.begin(), times_.end(),
                              strikes_.begin(), strikes_.end(),
                              variances_);
            varianceSurface_.update();
            notifyObservers();
        }
        void accept(AcyclicVisitor&) override;
        void update() override;

      private:
        Real blackVarianceImpl(Time t, Real strike) const override;
        void setVariances();
        DayCounter dayCounter_;
        Date maxDate_;
        const std::vector<Handle<Quote> >& volatilities_;
        std::vector<Real> strikes_;
        std::vector<Time> times_;
        Matrix variances_;
        Interpolation2D varianceSurface_;
        Extrapolation lowerExtrapolation_, upperExtrapolation_;
    };

    inline void ExtendedBlackVarianceSurface::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<ExtendedBlackVarianceSurface>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            BlackVarianceTermStructure::accept(v);
    }

}

#endif
]]></document_content>
  </document>
  <document index="503">
    <source>volatility/interestratevolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/interestratevolsurface.hpp>
#include <utility>

namespace QuantLib {

    InterestRateVolSurface::InterestRateVolSurface(ext::shared_ptr<InterestRateIndex> index,
                                                   BusinessDayConvention bdc,
                                                   const DayCounter& dc)
    : BlackVolSurface(bdc, dc), index_(std::move(index)) {}

    InterestRateVolSurface::InterestRateVolSurface(ext::shared_ptr<InterestRateIndex> index,
                                                   const Date& refDate,
                                                   const Calendar& cal,
                                                   BusinessDayConvention bdc,
                                                   const DayCounter& dc)
    : BlackVolSurface(refDate, cal, bdc, dc), index_(std::move(index)) {}

    InterestRateVolSurface::InterestRateVolSurface(ext::shared_ptr<InterestRateIndex> index,
                                                   Natural settlDays,
                                                   const Calendar& cal,
                                                   BusinessDayConvention bdc,
                                                   const DayCounter& dc)
    : BlackVolSurface(settlDays, cal, bdc, dc), index_(std::move(index)) {}

    Date InterestRateVolSurface::optionDateFromTenor(const Period& p) const {
        ext::shared_ptr<InterestRateIndex> i = index();
        // optionlet style
        Date refDate = i->fixingCalendar().adjust(referenceDate(), Following);
        Date settlement = i->valueDate(refDate);
        Date start = settlement+p;
        return i->fixingDate(start);
    }

    void InterestRateVolSurface::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<InterestRateVolSurface>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            BlackVolSurface::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="504">
    <source>volatility/interestratevolsurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file interestratevolsurface.hpp
    \brief Interest rate volatility (smile) surface
*/

#ifndef quantlib_interest_rate_vol_surface_hpp
#define quantlib_interest_rate_vol_surface_hpp

#include <ql/experimental/volatility/blackvolsurface.hpp>
#include <ql/experimental/volatility/interestratevolsurface.hpp>
#include <ql/indexes/interestrateindex.hpp>

namespace QuantLib {

    //! Interest rate volatility (smile) surface
    /*! This abstract class defines the interface of concrete
        Interest rate volatility (smile) surfaces which will
        be derived from this one.

        Volatilities are assumed to be expressed on an annual basis.
    */
    class InterestRateVolSurface : public BlackVolSurface {
      public:
        /*! \name Constructors
            See the TermStructure documentation for issues regarding
            constructors.
        */
        //@{
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        explicit InterestRateVolSurface(ext::shared_ptr<InterestRateIndex>,
                                        BusinessDayConvention bdc = Following,
                                        const DayCounter& dc = DayCounter());
        //! initialize with a fixed reference date
        InterestRateVolSurface(ext::shared_ptr<InterestRateIndex>,
                               const Date& referenceDate,
                               const Calendar& cal = Calendar(),
                               BusinessDayConvention bdc = Following,
                               const DayCounter& dc = DayCounter());
        //! calculate the reference date based on the global evaluation date
        InterestRateVolSurface(ext::shared_ptr<InterestRateIndex>,
                               Natural settlementDays,
                               const Calendar&,
                               BusinessDayConvention bdc = Following,
                               const DayCounter& dc = DayCounter());
        //@}
        //! \name VolatilityTermStructure interface
        //@{
        //! period/date conversion
        Date optionDateFromTenor(const Period&) const;
        //@}
        const ext::shared_ptr<InterestRateIndex>& index() const;
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      protected:
        ext::shared_ptr<InterestRateIndex> index_;
    };


    // inline

    inline const ext::shared_ptr<InterestRateIndex>&
    InterestRateVolSurface::index() const {
        return index_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="505">
    <source>volatility/noarbsabr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/noarbsabr.hpp>

#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/modifiedbessel.hpp>
#include <boost/math/special_functions/gamma.hpp>
#include <boost/functional/hash.hpp>

namespace QuantLib {

class NoArbSabrModel::integrand {
    const NoArbSabrModel* model;
    Real strike;
  public:
    integrand(const NoArbSabrModel* model, Real strike)
    : model(model), strike(strike) {}
    Real operator()(Real f) const {
        return std::max(f - strike, 0.0) * model->p(f);
    }
};

class NoArbSabrModel::p_integrand {
    const NoArbSabrModel* model;
  public:
    explicit p_integrand(const NoArbSabrModel* model)
    : model(model) {}
    Real operator()(Real f) const {
        return model->p(f);
    }
};

NoArbSabrModel::NoArbSabrModel(const Real expiryTime, const Real forward,
                               const Real alpha, const Real beta, const Real nu,
                               const Real rho)
    : expiryTime_(expiryTime), externalForward_(forward), alpha_(alpha),
      beta_(beta), nu_(nu), rho_(rho), forward_(forward),
      numericalForward_(forward) {

    QL_REQUIRE(expiryTime > 0.0 && expiryTime <= detail::NoArbSabrModel::expiryTime_max,
               "expiryTime (" << expiryTime << ") out of bounds");
    QL_REQUIRE(forward > 0.0, "forward (" << forward << ") must be positive");
    QL_REQUIRE(beta >= detail::NoArbSabrModel::beta_min && beta <= detail::NoArbSabrModel::beta_max,
               "beta (" << beta << ") out of bounds");
    Real sigmaI = alpha * std::pow(forward, beta - 1.0);
    QL_REQUIRE(sigmaI >= detail::NoArbSabrModel::sigmaI_min &&
                   sigmaI <= detail::NoArbSabrModel::sigmaI_max,
               "sigmaI = alpha*forward^(beta-1.0) ("
                   << sigmaI << ") out of bounds, alpha=" << alpha
                   << " beta=" << beta << " forward=" << forward);
    QL_REQUIRE(nu >= detail::NoArbSabrModel::nu_min && nu <= detail::NoArbSabrModel::nu_max,
               "nu (" << nu << ") out of bounds");
    QL_REQUIRE(rho >= detail::NoArbSabrModel::rho_min && rho <= detail::NoArbSabrModel::rho_max,
               "rho (" << rho << ") out of bounds");

    // determine a region sufficient for integration in the normal case

    fmin_ = fmax_ = forward_;
    for (Real tmp = p(fmax_);
         tmp > std::max(detail::NoArbSabrModel::i_accuracy / std::max(1.0, fmax_ - fmin_),
                        detail::NoArbSabrModel::density_threshold);
         tmp = p(fmax_)) {
        fmax_ *= 2.0;
    }
    for (Real tmp = p(fmin_);
         tmp > std::max(detail::NoArbSabrModel::i_accuracy / std::max(1.0, fmax_ - fmin_),
                        detail::NoArbSabrModel::density_threshold);
         tmp = p(fmin_)) {
        fmin_ *= 0.5;
    }
    fmin_ = std::max(detail::NoArbSabrModel::strike_min, fmin_);

    QL_REQUIRE(fmax_ > fmin_, "could not find a reasonable integration domain");

    integrator_ =
        ext::make_shared<GaussLobattoIntegral>(
            detail::NoArbSabrModel::i_max_iterations, detail::NoArbSabrModel::i_accuracy);

    detail::D0Interpolator d0(forward_, expiryTime_, alpha_, beta_, nu_, rho_);
    absProb_ = d0();

    try {
        Brent b;
        Real start = std::sqrt(externalForward_ - detail::NoArbSabrModel::strike_min);
        Real tmp =
            b.solve([&](Real x){ return forwardError(x); },
                    detail::NoArbSabrModel::forward_accuracy, start,
                    std::min(detail::NoArbSabrModel::forward_search_step, start / 2.0));
        forward_ = tmp * tmp + detail::NoArbSabrModel::strike_min;
    } catch (Error&) {
        // fall back to unadjusted forward
        forward_ = externalForward_;
    }

    Real d = forwardError(std::sqrt(forward_ - detail::NoArbSabrModel::strike_min));
    numericalForward_ = d + externalForward_;
}

Real NoArbSabrModel::optionPrice(const Real strike) const {
    if (p(std::max(forward_, strike)) < detail::NoArbSabrModel::density_threshold)
        return 0.0;
    return (1.0 - absProb_) *
        ((*integrator_)(integrand(this, strike),
                        strike, std::max(fmax_, 2.0 * strike)) /
            numericalIntegralOverP_);
}

Real NoArbSabrModel::digitalOptionPrice(const Real strike) const {
    if (strike < QL_MIN_POSITIVE_REAL)
        return 1.0;
    if (p(std::max(forward_, strike)) < detail::NoArbSabrModel::density_threshold)
        return 0.0;
    return (1.0 - absProb_)
        * ((*integrator_)(p_integrand(this),
                          strike, std::max(fmax_, 2.0 * strike)) /
           numericalIntegralOverP_);
}

Real NoArbSabrModel::forwardError(const Real forward) const {
    forward_ = forward * forward + detail::NoArbSabrModel::strike_min;
    numericalIntegralOverP_ = (*integrator_)(p_integrand(this),
                                             fmin_, fmax_);
    return optionPrice(0.0) - externalForward_;
}

Real NoArbSabrModel::p(const Real f) const {

    if (f < detail::NoArbSabrModel::density_lower_bound ||
        forward_ < detail::NoArbSabrModel::density_lower_bound)
        return 0.0;

    Real fOmB = std::pow(f, 1.0 - beta_);
    Real FOmB = std::pow(forward_, 1.0 - beta_);

    Real zf = fOmB / (alpha_ * (1.0 - beta_));
    Real zF = FOmB / (alpha_ * (1.0 - beta_));
    Real z = zF - zf;

    // Real JzF = std::sqrt(1.0 - 2.0 * rho_ * nu_ * zF + nu_ * nu_ * zF * zF);
    Real Jmzf = std::sqrt(1.0 + 2.0 * rho_ * nu_ * zf + nu_ * nu_ * zf * zf);
    Real Jz = std::sqrt(1.0 - 2.0 * rho_ * nu_ * z + nu_ * nu_ * z * z);

    Real xz = std::log((Jz - rho_ + nu_ * z) / (1.0 - rho_)) / nu_;
    Real Bp_B = beta_ / FOmB;
    // Real Bpp_B = beta_ * (2.0 * beta_ - 1.0) / (FOmB * FOmB);
    Real kappa1 = 0.125 * nu_ * nu_ * (2.0 - 3.0 * rho_ * rho_) -
                  0.25 * rho_ * nu_ * alpha_ * Bp_B;
    // Real kappa2 = alpha_ * alpha_ * (0.25 * Bpp_B - 0.375 * Bp_B * Bp_B);
    Real gamma = 1.0 / (2.0 * (1.0 - beta_));
    Real sqrtOmR = std::sqrt(1.0 - rho_ * rho_);
    Real h = 0.5 * beta_ * rho_ / ((1.0 - beta_) * Jmzf * Jmzf) *
             (nu_ * zf * std::log(zf * Jz / zF) +
              (1 + rho_ * nu_ * zf) / sqrtOmR *
                  (std::atan((nu_ * z - rho_) / sqrtOmR) +
                   std::atan(rho_ / sqrtOmR)));

    Real res =
        std::pow(Jz, -1.5) / (alpha_ * std::pow(f, beta_) * expiryTime_) *
        std::pow(zf, 1.0 - gamma) * std::pow(zF, gamma) *
        std::exp(-(xz * xz) / (2.0 * expiryTime_) +
                 (h + kappa1 * expiryTime_)) *
        modifiedBesselFunction_i_exponentiallyWeighted(gamma,
                                                       zF * zf / expiryTime_);
    return res;
}

namespace detail {

D0Interpolator::D0Interpolator(const Real forward, const Real expiryTime,
                               const Real alpha, const Real beta, const Real nu,
                               const Real rho)
    : forward_(forward), expiryTime_(expiryTime), alpha_(alpha), beta_(beta),
      nu_(nu), rho_(rho), gamma_(1.0 / (2.0 * (1.0 - beta_))) {

    sigmaI_ = alpha_ * std::pow(forward_, beta_ - 1.0);

    tauG_ = {
        0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0,
        3.25, 3.5, 3.75, 4.0, 4.25, 4.5, 4.75, 5.0, 5.25, 5.5, 5.75, 6.0, 6.25,
        6.5, 6.75, 7.0, 7.25, 7.5, 7.75, 8.0, 8.25, 8.5, 8.75, 9.0, 9.25, 9.5,
        9.75, 10.0, 10.25, 10.5, 10.75, 11.0, 11.25, 11.5, 11.75, 12.0, 12.25,
        12.5, 12.75, 13.0, 13.25, 13.5, 13.75, 14.0, 14.25, 14.5, 14.75, 15.0,
        15.25, 15.5, 15.75, 16.0, 16.25, 16.5, 16.75, 17.0, 17.25, 17.5, 17.75,
        18.0, 18.25, 18.5, 18.75, 19.0, 19.25, 19.5, 19.75, 20.0, 20.25, 20.5,
        20.75, 21.0, 21.25, 21.5, 21.75, 22.0, 22.25, 22.5, 22.75, 23.0, 23.25,
        23.5, 23.75, 24.0, 24.25, 24.5, 24.75, 25.0, 25.25, 25.5, 25.75, 26.0,
        26.25, 26.5, 26.75, 27.0, 27.25, 27.5, 27.75, 28.0, 28.25, 28.5, 28.75,
        29.0, 29.25, 29.5, 29.75, 30.0
    };

    sigmaIG_ = {
        1.0, 0.8, 0.7, 0.6, 0.5, 0.45, 0.4, 0.35, 0.3, 0.27, 0.24, 0.21,
        0.18, 0.15, 0.125, 0.1, 0.075, 0.05
    };

    rhoG_ = { 0.75, 0.50, 0.25, 0.00, -0.25, -0.50, -0.75 };

    nuG_ = { 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8 };

    betaG_ = { 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9 };
}

Real D0Interpolator::operator()() const {

    // we do not need to check the indices here, because this is already
    // done in the NoArbSabr constructor

    Size tauInd = std::upper_bound(tauG_.begin(), tauG_.end(), expiryTime_) -
                                   tauG_.begin();
    if (tauInd == tauG_.size())
        --tauInd; // tau at upper bound
    Real expiryTimeTmp = expiryTime_;
    if (tauInd == 0) {
        ++tauInd;
        expiryTimeTmp = tauG_.front();
    }
    Real tauL = (expiryTimeTmp - tauG_[tauInd - 1]) /
                (tauG_[tauInd] - tauG_[tauInd - 1]);

    Size sigmaIInd =
        sigmaIG_.size() -
        (std::upper_bound(sigmaIG_.rbegin(), sigmaIG_.rend(), sigmaI_) -
         sigmaIG_.rbegin());
    if (sigmaIInd == 0)
        ++sigmaIInd; // sigmaI at upper bound
    Real sigmaIL = (sigmaI_ - sigmaIG_[sigmaIInd - 1]) /
                   (sigmaIG_[sigmaIInd] - sigmaIG_[sigmaIInd - 1]);

    Size rhoInd =
        rhoG_.size() -
        (std::upper_bound(rhoG_.rbegin(), rhoG_.rend(), rho_) - rhoG_.rbegin());
    if (rhoInd == 0) {
        rhoInd++;
    }
    if (rhoInd == rhoG_.size()) {
        rhoInd--;
    }
    Real rhoL =
        (rho_ - rhoG_[rhoInd - 1]) / (rhoG_[rhoInd] - rhoG_[rhoInd - 1]);

    // for nu = 0 we know phi = 0.5*z_F^2
    Size nuInd = std::upper_bound(nuG_.begin(), nuG_.end(), nu_) - nuG_.begin();
    if (nuInd == nuG_.size())
        --nuInd; // nu at upper bound
    Real tmpNuG = nuInd > 0 ? nuG_[nuInd - 1] : 0.0;
    Real nuL = (nu_ - tmpNuG) / (nuG_[nuInd] - tmpNuG);

    // for beta = 1 we know phi = 0.0
    Size betaInd =
        std::upper_bound(betaG_.begin(), betaG_.end(), beta_) - betaG_.begin();
    Real tmpBetaG;
    if (betaInd == betaG_.size())
        tmpBetaG = 1.0;
    else
        tmpBetaG = betaG_[betaInd];
    Real betaL =
        (beta_ - betaG_[betaInd - 1]) / (tmpBetaG - betaG_[betaInd - 1]);

    Real phiRes = 0.0;
    for (int iTau = -1; iTau <= 0; ++iTau) {
        for (int iSigma = -1; iSigma <= 0; ++iSigma) {
            for (int iRho = -1; iRho <= 0; ++iRho) {
                for (int iNu = -1; iNu <= 0; ++iNu) {
                    for (int iBeta = -1; iBeta <= 0; ++iBeta) {
                        Real phiTmp;
                        if (iNu == -1 && nuInd == 0) {
                            phiTmp =
                                0.5 /
                                (sigmaI_ * sigmaI_ * (1.0 - beta_) *
                                 (1.0 - beta_)); // this is 0.5*z_F^2, see above
                        } else {
                            if (iBeta == 0 && betaInd == betaG_.size()) {
                                phiTmp =
                                    phi(detail::NoArbSabrModel::tiny_prob);
                            } else {
                                int ind = (tauInd + iTau +
                                           (sigmaIInd + iSigma +
                                            (rhoInd + iRho +
                                             (nuInd + iNu + ((betaInd + iBeta) *
                                                             nuG_.size())) *
                                                 rhoG_.size()) *
                                                sigmaIG_.size()) *
                                               tauG_.size());
                                QL_REQUIRE(ind >= 0 && ind < 1209600,
                                           "absorption matrix index ("
                                               << ind << ") invalid");
                                phiTmp = phi((Real)sabrabsprob[ind] /
                                             detail::NoArbSabrModel::nsim);
                            }
                        }
                        phiRes += phiTmp * (iTau == -1 ? (1.0 - tauL) : tauL) *
                                  (iSigma == -1 ? (1.0 - sigmaIL) : sigmaIL) *
                                  (iRho == -1 ? (1.0 - rhoL) : rhoL) *
                                  (iNu == -1 ? (1.0 - nuL) : nuL) *
                                  (iBeta == -1 ? (1.0 - betaL) : betaL);
                    }
                }
            }
        }
    }
    return d0(phiRes);
}

Real D0Interpolator::phi(const Real d0) const {
    if (d0 < 1e-14)
        return detail::NoArbSabrModel::phiByTau_cutoff * expiryTime_;
    return boost::math::gamma_q_inv(gamma_, d0) * expiryTime_;
}

Real D0Interpolator::d0(const Real phi) const {
    return boost::math::gamma_q(gamma_, std::max(0.0, phi / expiryTime_));
}

} // namespace detail

} // namespace QuantLib
]]></document_content>
  </document>
  <document index="506">
    <source>volatility/noarbsabr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file noarbsabr.hpp
    \brief No-arbitrage SABR

    Reference: Paul Doust, No-arbitrage SABR,
               The Journal of Computational Finance (331)
               Volume 15/Number 3, Spring 2012

    The parameters are bounded as follows (see also below)

    beta [0.01, 0.99]
    expiryTime (0.0, 30.0]
    sigmaI = alpha*forward^(beta-1) [0.05, 1.0]
    nu [0.0001, 0.8]
    rho [-0.99, 0.99]

    As suggested in the paper, d0 is interpolated (linearly)
    in phi space. For beta > 0.9 phi is extrapolated to a
    value corresponding to d0 = tiny_prob = 1E-5 at beta = 1.
    For tau < 0.25 phi is extrapolated flat.
    For rho outside [-0.75, 0.75] phi is extrapolated linearly.

    There are some parameter sets that are admissable, yet do
    not allow for the adjustment procedure as suggested in the
    paper to force the model implied forward to the correct
    value. In this case, no adjustment is done, leading to a
    model implied forward different from the desired one.
    This situation can be identified by comparing forward()
    and numericalForward().
*/

#ifndef quantlib_noarb_sabr
#define quantlib_noarb_sabr

#include <ql/qldefines.hpp>
#include <ql/types.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>

#include <vector>

namespace QuantLib {

namespace detail {
namespace NoArbSabrModel {
// parameter bounds
const Real beta_min = 0.01;
const Real beta_max = 0.99;
const Real expiryTime_max = 30.0;
const Real sigmaI_min = 0.05;
const Real sigmaI_max = 1.00;
const Real nu_min = 0.01;
const Real nu_max = 0.80;
const Real rho_min = -0.99;
const Real rho_max = 0.99;
// cutoff for phi(d0) / tau
// if beta = 0.99, d0 is below 1E-14 for
// bigger values than this
const Real phiByTau_cutoff = 124.587;
// number of mc simulations in tabulated
// absorption probabilities
const Real nsim = 2500000.0;
// small probability used for extrapolation
// of beta towards 1
const Real tiny_prob = 1E-5;
// minimum strike used for normal case integration
const Real strike_min = 1E-6;
// accuracy and max iterations for
// numerical integration
const Real i_accuracy = 1E-7;
const Size i_max_iterations = 10000;
// accuracy when adjusting the model forward
// to match the given forward
const Real forward_accuracy = 1E-6;
// step for searching the model forward
// in newton algorithm
const Real forward_search_step = 0.0010;
// lower bound for density evaluation
const Real density_lower_bound = 1E-50;
// threshold to identify a zero density
const Real density_threshold = 1E-100;
}
}

class NoArbSabrModel {

  public:
    NoArbSabrModel(Real expiryTime, Real forward, Real alpha, Real beta, Real nu, Real rho);

    Real optionPrice(Real strike) const;
    Real digitalOptionPrice(Real strike) const;
    Real density(const Real strike) const {
        return p(strike) * (1 - absProb_) / numericalIntegralOverP_;
    }

    Real forward() const { return externalForward_; }
    Real numericalForward() const { return numericalForward_; }
    Real expiryTime() const { return expiryTime_; }
    Real alpha() const { return alpha_; }
    Real beta() const { return beta_; }
    Real nu() const { return nu_; }
    Real rho() const { return rho_; }

    Real absorptionProbability() const { return absProb_; }

    private:
      Real p(Real f) const;
      Real forwardError(Real forward) const;
      const Real expiryTime_, externalForward_;
      const Real alpha_, beta_, nu_, rho_;
      Real absProb_, fmin_, fmax_;
      mutable Real forward_, numericalIntegralOverP_;
      mutable Real numericalForward_;
      ext::shared_ptr<GaussLobattoIntegral> integrator_;
      class integrand;
      friend class integrand;
      class p_integrand;
      friend class p_integrand;
};

namespace detail {

extern "C" const unsigned long sabrabsprob[1209600];

class D0Interpolator {
  public:
    D0Interpolator(Real forward, Real expiryTime, Real alpha, Real beta, Real nu, Real rho);
    Real operator()() const;

  private:
    Real phi(Real d0) const;
    Real d0(Real phi) const;
    const Real forward_, expiryTime_, alpha_, beta_, nu_, rho_, gamma_;
    Real sigmaI_;
    std::vector<Real> tauG_, sigmaIG_, rhoG_, nuG_, betaG_;
};

} // namespace detail
} // namespace QuantLib

#endif
]]></document_content>
  </document>
  <document index="507">
    <source>volatility/noarbsabrinterpolatedsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/noarbsabrinterpolatedsmilesection.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    NoArbSabrInterpolatedSmileSection::NoArbSabrInterpolatedSmileSection(
        const Date& optionDate,
        Handle<Quote> forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        Handle<Quote> atmVolatility,
        const std::vector<Handle<Quote> >& volHandles,
        Real alpha,
        Real beta,
        Real nu,
        Real rho,
        bool isAlphaFixed,
        bool isBetaFixed,
        bool isNuFixed,
        bool isRhoFixed,
        bool vegaWeighted,
        ext::shared_ptr<EndCriteria> endCriteria,
        ext::shared_ptr<OptimizationMethod> method,
        const DayCounter& dc)
    : SmileSection(optionDate, dc), forward_(std::move(forward)),
      atmVolatility_(std::move(atmVolatility)), volHandles_(volHandles), strikes_(strikes),
      actualStrikes_(strikes), hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()),
      alpha_(alpha), beta_(beta), nu_(nu), rho_(rho), isAlphaFixed_(isAlphaFixed),
      isBetaFixed_(isBetaFixed), isNuFixed_(isNuFixed), isRhoFixed_(isRhoFixed),
      vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)),
      method_(std::move(method)) {

        LazyObject::registerWith(forward_);
        LazyObject::registerWith(atmVolatility_);
        for (auto& volHandle : volHandles_)
            LazyObject::registerWith(volHandle);
    }

    NoArbSabrInterpolatedSmileSection::NoArbSabrInterpolatedSmileSection(
        const Date& optionDate,
        const Rate& forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        const Volatility& atmVolatility,
        const std::vector<Volatility>& volHandles,
        Real alpha,
        Real beta,
        Real nu,
        Real rho,
        bool isAlphaFixed,
        bool isBetaFixed,
        bool isNuFixed,
        bool isRhoFixed,
        bool vegaWeighted,
        ext::shared_ptr<EndCriteria> endCriteria,
        ext::shared_ptr<OptimizationMethod> method,
        const DayCounter& dc)
    : SmileSection(optionDate, dc),
      forward_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(forward)))),
      atmVolatility_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(atmVolatility)))),
      volHandles_(volHandles.size()), strikes_(strikes), actualStrikes_(strikes),
      hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()), alpha_(alpha), beta_(beta),
      nu_(nu), rho_(rho), isAlphaFixed_(isAlphaFixed), isBetaFixed_(isBetaFixed),
      isNuFixed_(isNuFixed), isRhoFixed_(isRhoFixed), vegaWeighted_(vegaWeighted),
      endCriteria_(std::move(endCriteria)), method_(std::move(method)) {

        for (Size i = 0; i < volHandles_.size(); ++i)
            volHandles_[i] = Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(volHandles[i])));
    }

    void NoArbSabrInterpolatedSmileSection::createInterpolation() const {
         ext::shared_ptr<NoArbSabrInterpolation> tmp(new NoArbSabrInterpolation(
                     actualStrikes_.begin(), actualStrikes_.end(), vols_.begin(),
                     exerciseTime(), forwardValue_,
                     alpha_, beta_, nu_, rho_,
                     isAlphaFixed_, isBetaFixed_, isNuFixed_, isRhoFixed_, vegaWeighted_,
                     endCriteria_, method_));
         swap(tmp, noArbSabrInterpolation_);
    }

    void NoArbSabrInterpolatedSmileSection::performCalculations() const {
        forwardValue_ = forward_->value();
        vols_.clear();
        actualStrikes_.clear();
        // we populate the volatilities, skipping the invalid ones
        for (Size i=0; i<volHandles_.size(); ++i) {
            if (volHandles_[i]->isValid()) {
                if (hasFloatingStrikes_) {
                    actualStrikes_.push_back(forwardValue_ + strikes_[i]);
                    vols_.push_back(atmVolatility_->value() + volHandles_[i]->value());
                } else {
                    actualStrikes_.push_back(strikes_[i]);
                    vols_.push_back(volHandles_[i]->value());
                }
            }
        }
        // we are recreating the sabrinterpolation object unconditionnaly to
        // avoid iterator invalidation
        createInterpolation();
        noArbSabrInterpolation_->update();
    }

    Real NoArbSabrInterpolatedSmileSection::varianceImpl(Real strike) const {
        calculate();
        Real v = (*noArbSabrInterpolation_)(strike, true);
        return v*v*exerciseTime();
    }

}

]]></document_content>
  </document>
  <document index="508">
    <source>volatility/noarbsabrinterpolatedsmilesection.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file noarbsabrinterpolatedsmilesection.hpp
    \brief noarb sabr interpolating smile section
*/

#ifndef quantlib_noarbsabr_interpolated_smile_section_hpp
#define quantlib_noarbsabr_interpolated_smile_section_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/experimental/volatility/noarbsabrinterpolation.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

namespace QuantLib {

    class Quote;
    class NoArbSabrInterpolatedSmileSection : public SmileSection,
                                         public LazyObject {
      public:
        //! \name Constructors
        //@{
        //! all market data are quotes
        NoArbSabrInterpolatedSmileSection(
            const Date& optionDate,
            Handle<Quote> forward,
            const std::vector<Rate>& strikes,
            bool hasFloatingStrikes,
            Handle<Quote> atmVolatility,
            const std::vector<Handle<Quote> >& volHandles,
            Real alpha,
            Real beta,
            Real nu,
            Real rho,
            bool isAlphaFixed = false,
            bool isBetaFixed = false,
            bool isNuFixed = false,
            bool isRhoFixed = false,
            bool vegaWeighted = true,
            ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
            ext::shared_ptr<OptimizationMethod> method = ext::shared_ptr<OptimizationMethod>(),
            const DayCounter& dc = Actual365Fixed());
        //! no quotes
        NoArbSabrInterpolatedSmileSection(
            const Date& optionDate,
            const Rate& forward,
            const std::vector<Rate>& strikes,
            bool hasFloatingStrikes,
            const Volatility& atmVolatility,
            const std::vector<Volatility>& vols,
            Real alpha,
            Real beta,
            Real nu,
            Real rho,
            bool isAlphaFixed = false,
            bool isBetaFixed = false,
            bool isNuFixed = false,
            bool isRhoFixed = false,
            bool vegaWeighted = true,
            ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
            ext::shared_ptr<OptimizationMethod> method = ext::shared_ptr<OptimizationMethod>(),
            const DayCounter& dc = Actual365Fixed());
        //@}
        //! \name LazyObject interface
        //@{
        void performCalculations() const override;
        void update() override;
        //@}
        //! \name SmileSection interface
        //@{
        Real minStrike() const override;
        Real maxStrike() const override;
        Real atmLevel() const override;
        //@}
        Real varianceImpl(Rate strike) const override;
        Volatility volatilityImpl(Rate strike) const override;
        //! \name Inspectors
        //@{
        Real alpha() const;
        Real beta() const;
        Real nu() const;
        Real rho() const;
        Real rmsError() const;
        Real maxError() const;
        EndCriteria::Type endCriteria() const;
        //@}

      protected:

        //! Creates the mutable SABRInterpolation
        void createInterpolation() const;
        mutable ext::shared_ptr<NoArbSabrInterpolation> noArbSabrInterpolation_;

        //! Market data
        const Handle<Quote> forward_;
        const Handle<Quote> atmVolatility_;
        std::vector<Handle<Quote> > volHandles_;
        mutable std::vector<Rate> strikes_;
        //! Only strikes corresponding to valid market data
        mutable std::vector<Rate> actualStrikes_;
        bool hasFloatingStrikes_;

        mutable Real forwardValue_;
        mutable std::vector<Volatility> vols_;
        //! Sabr parameters
        Real alpha_, beta_, nu_, rho_;
        //! Sabr interpolation settings
        bool isAlphaFixed_, isBetaFixed_, isNuFixed_, isRhoFixed_;
        bool vegaWeighted_;
        const ext::shared_ptr<EndCriteria> endCriteria_;
        const ext::shared_ptr<OptimizationMethod> method_;
    };

    inline void NoArbSabrInterpolatedSmileSection::update() {
        LazyObject::update();
        SmileSection::update();
    }

    inline Real NoArbSabrInterpolatedSmileSection::volatilityImpl(Rate strike) const {
        calculate();
        return (*noArbSabrInterpolation_)(strike, true);
    }

    inline Real NoArbSabrInterpolatedSmileSection::alpha() const {
        calculate();
        return noArbSabrInterpolation_->alpha();
    }

    inline Real NoArbSabrInterpolatedSmileSection::beta() const {
        calculate();
        return noArbSabrInterpolation_->beta();
    }

    inline Real NoArbSabrInterpolatedSmileSection::nu() const {
        calculate();
        return noArbSabrInterpolation_->nu();
    }

    inline Real NoArbSabrInterpolatedSmileSection::rho() const {
        calculate();
        return noArbSabrInterpolation_->rho();
    }

    inline Real NoArbSabrInterpolatedSmileSection::rmsError() const {
        calculate();
        return noArbSabrInterpolation_->rmsError();
    }

    inline Real NoArbSabrInterpolatedSmileSection::maxError() const {
        calculate();
        return noArbSabrInterpolation_->maxError();
    }

    inline EndCriteria::Type NoArbSabrInterpolatedSmileSection::endCriteria() const {
        calculate();
        return noArbSabrInterpolation_->endCriteria();
    }

    inline Real NoArbSabrInterpolatedSmileSection::minStrike() const {
        calculate();
        return actualStrikes_.front();

    }

    inline Real NoArbSabrInterpolatedSmileSection::maxStrike() const {
        calculate();
        return actualStrikes_.back();
    }

    inline Real NoArbSabrInterpolatedSmileSection::atmLevel() const {
        calculate();
        return forwardValue_;
    }


}

#endif
]]></document_content>
  </document>
  <document index="509">
    <source>volatility/noarbsabrinterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file noarbsabrinterpolation.hpp
    \brief noabr sabr interpolation between discrete points
*/

#ifndef quantlib_noarbsabr_interpolation_hpp
#define quantlib_noarbsabr_interpolation_hpp

#include <ql/experimental/volatility/noarbsabrsmilesection.hpp>
#include <ql/math/interpolations/sabrinterpolation.hpp>
#include <utility>

namespace QuantLib {

namespace detail {

// we can directly use the smile section as the wrapper
typedef NoArbSabrSmileSection NoArbSabrWrapper;

struct NoArbSabrSpecs {
    Size dimension() { return 4; }
    Real eps() { return 0.000001; }
    void defaultValues(std::vector<Real> &params,
                       std::vector<bool> &paramIsFixed, const Real &forward,
                       const Real expiryTime, const std::vector<Real> &addParams) {
        SABRSpecs().defaultValues(params, paramIsFixed, forward, expiryTime, addParams);
        // check if alpha / beta is admissable, otherwise adjust
        // if possible (i.e. not fixed, otherwise an exception will
        // be thrown from the model constructor anyway)
        Real sigmaI = params[0] * std::pow(forward, params[1] - 1.0);
        if (sigmaI < detail::NoArbSabrModel::sigmaI_min) {
            if (!paramIsFixed[0])
                params[0] = detail::NoArbSabrModel::sigmaI_min * (1.0 + eps()) /
                            std::pow(forward, params[1] - 1.0);
            else {
                if (!paramIsFixed[1])
                    params[1] = 1.0 +
                                std::log(detail::NoArbSabrModel::sigmaI_min *
                                         (1.0 + eps()) / params[0]) /
                                    std::log(forward);
            }
        }
        if (sigmaI > detail::NoArbSabrModel::sigmaI_max) {
            if (!paramIsFixed[0])
                params[0] = detail::NoArbSabrModel::sigmaI_max * (1.0 - eps()) /
                            std::pow(forward, params[1] - 1.0);
            else {
                if (!paramIsFixed[1])
                    params[1] = 1.0 +
                                std::log(detail::NoArbSabrModel::sigmaI_max *
                                         (1.0 - eps()) / params[0]) /
                                    std::log(forward);
            }
        }
    }
    void guess(Array &values, const std::vector<bool> &paramIsFixed,
               const Real &forward, const Real expiryTime,
               const std::vector<Real> &r, const std::vector<Real> &) {
        Size j = 0;
        if (!paramIsFixed[1])
            values[1] = detail::NoArbSabrModel::beta_min +
                        (detail::NoArbSabrModel::beta_max -
                         detail::NoArbSabrModel::beta_min) *
                            r[j++];
        if (!paramIsFixed[0]) {
            Real sigmaI = detail::NoArbSabrModel::sigmaI_min +
                          (detail::NoArbSabrModel::sigmaI_max -
                           detail::NoArbSabrModel::sigmaI_min) *
                              r[j++];
            sigmaI *= (1.0 - eps());
            sigmaI += eps() / 2.0;
            values[0] = sigmaI / std::pow(forward, values[1] - 1.0);
        }
        if (!paramIsFixed[2])
            values[2] = detail::NoArbSabrModel::nu_min +
                        (detail::NoArbSabrModel::nu_max -
                         detail::NoArbSabrModel::nu_min) *
                            r[j++];
        if (!paramIsFixed[3])
            values[3] = detail::NoArbSabrModel::rho_min +
                        (detail::NoArbSabrModel::rho_max -
                         detail::NoArbSabrModel::rho_min) *
                            r[j++];
    }
    Array inverse(const Array &y, const std::vector<bool> &paramIsFixed,
                  const std::vector<Real> &params, const Real forward) {
        Array x(4);
        x[1] = std::tan((y[1] - detail::NoArbSabrModel::beta_min) /
                            (detail::NoArbSabrModel::beta_max -
                             detail::NoArbSabrModel::beta_min) *
                            M_PI +
                        M_PI / 2.0);
        x[0] = std::tan((y[0] * std::pow(forward, y[1] - 1.0) -
                         detail::NoArbSabrModel::sigmaI_min) /
                            (detail::NoArbSabrModel::sigmaI_max -
                             detail::NoArbSabrModel::sigmaI_min) *
                            M_PI -
                        M_PI / 2.0);
        x[2] = std::tan((y[2] - detail::NoArbSabrModel::nu_min) /
                            (detail::NoArbSabrModel::nu_max -
                             detail::NoArbSabrModel::nu_min) *
                            M_PI +
                        M_PI / 2.0);
        x[3] = std::tan((y[3] - detail::NoArbSabrModel::rho_min) /
                            (detail::NoArbSabrModel::rho_max -
                             detail::NoArbSabrModel::rho_min) *
                            M_PI +
                        M_PI / 2.0);
        return x;
    }
    Array direct(const Array &x, const std::vector<bool> &paramIsFixed,
                 const std::vector<Real> &params, const Real forward) {
        Array y(4);
        if (paramIsFixed[1])
            y[1] = params[1];
        else
            y[1] = detail::NoArbSabrModel::beta_min +
                   (detail::NoArbSabrModel::beta_max -
                    detail::NoArbSabrModel::beta_min) *
                       (std::atan(x[1]) + M_PI / 2.0) / M_PI;
        // we compute alpha from sigmaI using beta
        // if alpha is fixed we have to check if beta is admissable
        // and adjust if need be
        if (paramIsFixed[0]) {
            y[0] = params[0];
            Real sigmaI = y[0] * std::pow(forward, y[1] - 1.0);
            if (sigmaI < detail::NoArbSabrModel::sigmaI_min) {
                y[1] = (1.0 +
                        std::log(detail::NoArbSabrModel::sigmaI_min *
                                 (1.0 + eps()) / y[0]) /
                            std::log(forward));
            }
            if (sigmaI > detail::NoArbSabrModel::sigmaI_max) {
                y[1] = (1.0 +
                        std::log(detail::NoArbSabrModel::sigmaI_max *
                                 (1.0 - eps()) / y[0]) /
                            std::log(forward));
            }
        } else {
            Real sigmaI = detail::NoArbSabrModel::sigmaI_min +
                          (detail::NoArbSabrModel::sigmaI_max -
                           detail::NoArbSabrModel::sigmaI_min) *
                              (std::atan(x[0]) + M_PI / 2.0) / M_PI;
            y[0] = sigmaI / std::pow(forward, y[1] - 1.0);
        }
        if (paramIsFixed[2])
            y[2] = params[2];
        else
            y[2] = detail::NoArbSabrModel::nu_min +
                   (detail::NoArbSabrModel::nu_max -
                    detail::NoArbSabrModel::nu_min) *
                       (std::atan(x[2]) + M_PI / 2.0) / M_PI;
        if (paramIsFixed[3])
            y[3] = params[3];
        else
            y[3] = detail::NoArbSabrModel::rho_min +
                   (detail::NoArbSabrModel::rho_max -
                    detail::NoArbSabrModel::rho_min) *
                       (std::atan(x[3]) + M_PI / 2.0) / M_PI;
        return y;
    }
    Real weight(const Real strike, const Real forward, const Real stdDev,
                const std::vector<Real> &addParams) {
        return blackFormulaStdDevDerivative(strike, forward, stdDev, 1.0);
    }
    typedef NoArbSabrWrapper type;
    ext::shared_ptr<type> instance(const Time t, const Real &forward,
                                     const std::vector<Real> &params,
                                     const std::vector<Real> &) {
        return ext::make_shared<type>(t, forward, params);
    }
};
}

//! no arbitrage sabr smile interpolation between discrete volatility points.
class NoArbSabrInterpolation : public Interpolation {
  public:
    template <class I1, class I2>
    NoArbSabrInterpolation(
        const I1 &xBegin, // x = strikes
        const I1 &xEnd,
        const I2 &yBegin, // y = volatilities
        Time t,           // option expiry
        const Real &forward, Real alpha, Real beta, Real nu, Real rho,
        bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed,
        bool vegaWeighted = true,
        const ext::shared_ptr<EndCriteria> &endCriteria =
            ext::shared_ptr<EndCriteria>(),
        const ext::shared_ptr<OptimizationMethod> &optMethod =
            ext::shared_ptr<OptimizationMethod>(),
        const Real errorAccept = 0.0020, const bool useMaxError = false,
        const Size maxGuesses = 50, const Real shift = 0.0) {

        QL_REQUIRE(shift==0.0,"NoArbSabrInterpolation for non zero shift not implemented");
        impl_ = ext::shared_ptr<Interpolation::Impl>(
            new detail::XABRInterpolationImpl<I1, I2, detail::NoArbSabrSpecs>(
                xBegin, xEnd, yBegin, t, forward,
                {alpha, beta, nu, rho},
                {alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed},
                vegaWeighted, endCriteria, optMethod, errorAccept, useMaxError,
                maxGuesses));
        coeffs_ = ext::dynamic_pointer_cast<
            detail::XABRCoeffHolder<detail::NoArbSabrSpecs> >(impl_);
    }
    Real expiry() const { return coeffs_->t_; }
    Real forward() const { return coeffs_->forward_; }
    Real alpha() const { return coeffs_->params_[0]; }
    Real beta() const { return coeffs_->params_[1]; }
    Real nu() const { return coeffs_->params_[2]; }
    Real rho() const { return coeffs_->params_[3]; }
    Real rmsError() const { return coeffs_->error_; }
    Real maxError() const { return coeffs_->maxError_; }
    const std::vector<Real> &interpolationWeights() const {
        return coeffs_->weights_;
    }
    EndCriteria::Type endCriteria() { return coeffs_->XABREndCriteria_; }

  private:
    ext::shared_ptr<detail::XABRCoeffHolder<detail::NoArbSabrSpecs> > coeffs_;
};

//! no arbtrage sabr interpolation factory and traits
class NoArbSabr {
  public:
    NoArbSabr(Time t,
              Real forward,
              Real alpha,
              Real beta,
              Real nu,
              Real rho,
              bool alphaIsFixed,
              bool betaIsFixed,
              bool nuIsFixed,
              bool rhoIsFixed,
              bool vegaWeighted = false,
              ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
              ext::shared_ptr<OptimizationMethod> optMethod = ext::shared_ptr<OptimizationMethod>(),
              const Real errorAccept = 0.0020,
              const bool useMaxError = false,
              const Size maxGuesses = 50)
    : t_(t), forward_(forward), alpha_(alpha), beta_(beta), nu_(nu), rho_(rho),
      alphaIsFixed_(alphaIsFixed), betaIsFixed_(betaIsFixed), nuIsFixed_(nuIsFixed),
      rhoIsFixed_(rhoIsFixed), vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)),
      optMethod_(std::move(optMethod)), errorAccept_(errorAccept), useMaxError_(useMaxError),
      maxGuesses_(maxGuesses) {}
    template <class I1, class I2>
    Interpolation interpolate(const I1 &xBegin, const I1 &xEnd,
                              const I2 &yBegin) const {
        return NoArbSabrInterpolation(
            xBegin, xEnd, yBegin, t_, forward_, alpha_, beta_, nu_, rho_,
            alphaIsFixed_, betaIsFixed_, nuIsFixed_, rhoIsFixed_, vegaWeighted_,
            endCriteria_, optMethod_, errorAccept_, useMaxError_, maxGuesses_);
    }
    static const bool global = true;

  private:
    Time t_;
    Real forward_;
    Real alpha_, beta_, nu_, rho_;
    bool alphaIsFixed_, betaIsFixed_, nuIsFixed_, rhoIsFixed_;
    bool vegaWeighted_;
    const ext::shared_ptr<EndCriteria> endCriteria_;
    const ext::shared_ptr<OptimizationMethod> optMethod_;
    const Real errorAccept_;
    const bool useMaxError_;
    const Size maxGuesses_;
};
}

#endif
]]></document_content>
  </document>
  <document index="510">
    <source>volatility/noarbsabrsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/noarbsabrsmilesection.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/sabr.hpp>
#include <utility>


namespace QuantLib {

    NoArbSabrSmileSection::NoArbSabrSmileSection(Time timeToExpiry,
                                                 Rate forward,
                                                 std::vector<Real> sabrParams,
                                                 Real shift)
    : SmileSection(timeToExpiry, DayCounter()), forward_(forward), params_(std::move(sabrParams)),
      shift_(shift) {
        init();
    }

    NoArbSabrSmileSection::NoArbSabrSmileSection(
        const Date& d, Rate forward, std::vector<Real> sabrParams, const DayCounter& dc, Real shift)
    : SmileSection(d, dc, Date()), forward_(forward), params_(std::move(sabrParams)),
      shift_(shift) {
        init();
    }

void NoArbSabrSmileSection::init() {
    QL_REQUIRE(params_.size() >= 4,
               "sabr expects 4 parameters (alpha,beta,nu,rho) but ("
                   << params_.size() << ") given");
    QL_REQUIRE(forward_ > 0.0, "forward (" << forward_ << ") must be positive");
    QL_REQUIRE(
        shift_ == 0.0,
        "shift (" << shift_
                  << ") must be zero, other shifts are not implemented yet");
    model_ =
        ext::make_shared<NoArbSabrModel>(exerciseTime(), forward_, params_[0],
                                           params_[1], params_[2], params_[3]);
}

Real NoArbSabrSmileSection::optionPrice(Rate strike, Option::Type type,
                                        Real discount) const {
    Real call = model_->optionPrice(strike);
    return discount *
           (type == Option::Call ? call : call - (forward_ - strike));
}

Real NoArbSabrSmileSection::digitalOptionPrice(Rate strike, Option::Type type,
                                               Real discount, Real) const {
    Real call = model_->digitalOptionPrice(strike);
    return discount * (type == Option::Call ? call : 1.0 - call);
}

Real NoArbSabrSmileSection::density(Rate strike, Real discount, Real) const {
    return discount * model_->density(strike);
}

Real NoArbSabrSmileSection::volatilityImpl(Rate strike) const {

    Real impliedVol = 0.0;
    try {
        Option::Type type;
        if (strike >= forward_)
            type = Option::Call;
        else
            type = Option::Put;
        impliedVol =
            blackFormulaImpliedStdDev(type, strike, forward_,
                                      optionPrice(strike, type, 1.0), 1.0) /
            std::sqrt(exerciseTime());
    } catch (...) {
    }
    if (impliedVol == 0.0)
        // fall back on Hagan 2002 expansion
        impliedVol =
            unsafeSabrVolatility(strike, forward_, exerciseTime(), params_[0],
                                 params_[1], params_[2], params_[3]);

    return impliedVol;
}
} // namespace QuantLib
]]></document_content>
  </document>
  <document index="511">
    <source>volatility/noarbsabrsmilesection.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file noarbsabrsmilesection.hpp
    \brief no arbitrage sabr smile section
*/

#ifndef quantlib_noarbsabr_smile_section_hpp
#define quantlib_noarbsabr_smile_section_hpp

#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/experimental/volatility/noarbsabr.hpp>
#include <vector>

namespace QuantLib {

class NoArbSabrSmileSection : public SmileSection {

  public:
    NoArbSabrSmileSection(Time timeToExpiry,
                          Rate forward,
                          std::vector<Real> sabrParameters,
                          Real shift = 0.0);
    NoArbSabrSmileSection(const Date& d,
                          Rate forward,
                          std::vector<Real> sabrParameters,
                          const DayCounter& dc = Actual365Fixed(),
                          Real shift = 0.0);
    Real minStrike() const override { return 0.0; }
    Real maxStrike() const override { return QL_MAX_REAL; }
    Real atmLevel() const override { return forward_; }
    Real
    optionPrice(Rate strike, Option::Type type = Option::Call, Real discount = 1.0) const override;
    Real digitalOptionPrice(Rate strike,
                            Option::Type type = Option::Call,
                            Real discount = 1.0,
                            Real gap = 1.0e-5) const override;
    Real density(Rate strike, Real discount = 1.0, Real gap = 1.0E-4) const override;

    ext::shared_ptr<NoArbSabrModel> model() { return model_; }

  protected:
    Volatility volatilityImpl(Rate strike) const override;

  private:
    void init();
    ext::shared_ptr<NoArbSabrModel> model_;
    Rate forward_;
    std::vector<Real> params_;
    Real shift_;
};
}

#endif
]]></document_content>
  </document>
  <document index="512">
    <source>volatility/sabrvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/sabrvolsurface.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/interpolations/sabrinterpolation.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    SabrVolSurface::SabrVolSurface(const ext::shared_ptr<InterestRateIndex>& index,
                                   Handle<BlackAtmVolCurve> atmCurve,
                                   const std::vector<Period>& optionTenors,
                                   std::vector<Spread> atmRateSpreads,
                                   std::vector<std::vector<Handle<Quote> > > volSpreads)
    : InterestRateVolSurface(index), atmCurve_(std::move(atmCurve)), optionTenors_(optionTenors),
      optionTimes_(optionTenors.size()), optionDates_(optionTenors.size()),
      atmRateSpreads_(std::move(atmRateSpreads)), volSpreads_(std::move(volSpreads)) {

        checkInputs();

        // Creation of reference smile sections

        // Hard coded
        isAlphaFixed_ = false;
        isBetaFixed_ = false;
        isNuFixed_ = false;
        isRhoFixed_ = false;
        vegaWeighted_ = true;

        sabrGuesses_.resize(optionTenors_.size());

        for (Size i=0; i<optionTenors_.size(); ++i) {

            optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
            optionTimes_[i] = timeFromReference(optionDates_[i]);

            // Hard coded
            sabrGuesses_[i][0] = 0.025; // alpha
            sabrGuesses_[i][1] = 0.5;   // beta
            sabrGuesses_[i][2] = 0.3;   // rho
            sabrGuesses_[i][3] = 0.0;   // nu
        }
        registerWithMarketData();
    }

    boost::array<Real, 4> SabrVolSurface::sabrGuesses(const Date& d) const {

        // the guesses for sabr parameters are assumed to be piecewise constant
        if (d<=optionDates_[0]) return sabrGuesses_[0];
        Size i=0;
        while (i<optionDates_.size()-1 && d<optionDates_[i])
            ++i;
        return sabrGuesses_[i];
    }

    void SabrVolSurface::updateSabrGuesses(const Date& d, boost::array<Real, 4> newGuesses) const {

        Size i=0;
        while (i<optionDates_.size() && d<=optionDates_[i])
            ++i;
        sabrGuesses_[i][0] = newGuesses[0];
        sabrGuesses_[i][1] = newGuesses[1];
        sabrGuesses_[i][2] = newGuesses[2];
        sabrGuesses_[i][3] = newGuesses[3];

    }

    std::vector<Volatility> SabrVolSurface::volatilitySpreads(const Date& d) const {

        Size nOptionsTimes = optionTimes_.size();
        Size nAtmRateSpreads = atmRateSpreads_.size();
        std::vector<Volatility> interpolatedVols(nAtmRateSpreads);

        std::vector<Volatility> vols(nOptionsTimes); // the volspread at a given strike
        for (Size i=0; i<nAtmRateSpreads; ++i) {
            for (Size j=0; j<nOptionsTimes; ++j) {
                vols[j] = (**volSpreads_[j][i]).value();
            }
            LinearInterpolation interpolator(optionTimes_.begin(), optionTimes_.end(),
                                             vols.begin());
            interpolatedVols[i] = interpolator(timeFromReference(d),true);
        }
        return interpolatedVols;
    }


    void SabrVolSurface::update() {
        TermStructure::update();
        for (Size i=0; i<optionTenors_.size(); ++i) {
            optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
            optionTimes_[i] = timeFromReference(optionDates_[i]);
        }
        notifyObservers();

    }

    ext::shared_ptr<SmileSection>
    SabrVolSurface::smileSectionImpl(Time t) const {

        auto n = BigInteger(t * 365.0);
        Date d = referenceDate()+n*Days;
        // interpolating on ref smile sections
        std::vector<Volatility> volSpreads = volatilitySpreads(d);

        // calculate sabr fit
        boost::array<Real, 4> sabrParameters1 = sabrGuesses(d);

        ext::shared_ptr<SabrInterpolatedSmileSection> tmp(new
            SabrInterpolatedSmileSection(d,
                                         index_->fixing(d,true), atmRateSpreads_, true,
                                            atmCurve_->atmVol(d), volSpreads,
                                            sabrParameters1[0], sabrParameters1[1],
                                            sabrParameters1[2], sabrParameters1[3],
                                            isAlphaFixed_, isBetaFixed_,
                                            isNuFixed_, isRhoFixed_,
                                            vegaWeighted_/*,
                                            const ext::shared_ptr<EndCriteria>& endCriteria,
                                            const ext::shared_ptr<OptimizationMethod>& method,
                                            const DayCounter& dc*/));

        // update guess

        return tmp;

    }

    void SabrVolSurface::registerWithMarketData() {

        for (Size i=0; i<optionTenors_.size(); ++i) {
            for (Size j=0; j<atmRateSpreads_.size(); ++j) {
                registerWith(volSpreads_[i][j]);
            }
        }
    }

    void SabrVolSurface::checkInputs() const {

        Size nStrikes = atmRateSpreads_.size();
        QL_REQUIRE(nStrikes>1, "too few strikes (" << nStrikes << ")");
        for (Size i=1; i<nStrikes; ++i)
            QL_REQUIRE(atmRateSpreads_[i-1]<atmRateSpreads_[i],
                       "non increasing strike spreads: " <<
                       io::ordinal(i) << " is " << atmRateSpreads_[i-1] << ", " <<
                       io::ordinal(i+1) << " is " << atmRateSpreads_[i]);
        for (Size i=0; i<volSpreads_.size(); i++)
            QL_REQUIRE(atmRateSpreads_.size()==volSpreads_[i].size(),
                       "mismatch between number of strikes (" << atmRateSpreads_.size() <<
                       ") and number of columns (" << volSpreads_[i].size() <<
                       ") in the " << io::ordinal(i+1) << " row");
    }

    void SabrVolSurface::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<SabrVolSurface>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            InterestRateVolSurface::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="513">
    <source>volatility/sabrvolsurface.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sabrvolsurface.hpp
    \brief SABR volatility (smile) surface
*/

#ifndef quantlib_sabr_vol_surface_hpp
#define quantlib_sabr_vol_surface_hpp

#include <ql/experimental/volatility/interestratevolsurface.hpp>
#include <ql/experimental/volatility/blackatmvolcurve.hpp>
#include <ql/quote.hpp>
#include <ql/termstructures/volatility/sabrinterpolatedsmilesection.hpp>
#include <boost/array.hpp>

namespace QuantLib {


    //! SABR volatility (smile) surface
    /*! blah blah
    */
    class SabrVolSurface : public InterestRateVolSurface {
      public:
        SabrVolSurface(const ext::shared_ptr<InterestRateIndex>&,
                       Handle<BlackAtmVolCurve>,
                       const std::vector<Period>& optionTenors,
                       std::vector<Spread> atmRateSpreads,
                       std::vector<std::vector<Handle<Quote> > > volSpreads);
        //@}
        // All virtual methods of base classes must be forwarded
        //! \name TermStructure interface
        //@{
        DayCounter dayCounter() const override;
        Date maxDate() const override;
        Time maxTime() const override;
        const Date& referenceDate() const override;
        Calendar calendar() const override;
        Natural settlementDays() const override;
        //@}
        //! \name VolatilityTermStructure interface
        //@{
        Real minStrike() const override;
        Real maxStrike() const override;
        //@}
        const Handle<BlackAtmVolCurve>& atmCurve() const;
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
        std::vector<Volatility> volatilitySpreads(const Period&) const;
        std::vector<Volatility> volatilitySpreads(const Date&) const;
      protected:
        boost::array<Real, 4> sabrGuesses(const Date&) const;
      public:
        //@}
        //! \name BlackVolSurface interface
        //@{
        ext::shared_ptr<SmileSection> smileSectionImpl(Time) const override;
        //@}
      protected:
        //@}
        //! \name LazyObject interface
        //@{
        void performCalculations () const;
        void update() override;
        //@}
      private:
        void registerWithMarketData();
        void checkInputs() const;
        void updateSabrGuesses(const Date& d, boost::array<Real, 4> newGuesses) const;
        Handle<BlackAtmVolCurve> atmCurve_;
        std::vector<Period> optionTenors_;
        std::vector<Time> optionTimes_;
        std::vector<Date> optionDates_;
        std::vector<Spread> atmRateSpreads_;
        std::vector<std::vector<Handle<Quote> > > volSpreads_;
        //
        bool isAlphaFixed_;
        bool isBetaFixed_;
        bool isNuFixed_;
        bool isRhoFixed_;
        bool vegaWeighted_;
        //
        mutable std::vector<boost::array<Real,4> > sabrGuesses_;
    };

    // inline

    inline DayCounter SabrVolSurface::dayCounter() const {
        return atmCurve_->dayCounter();
    }

    inline Date SabrVolSurface::maxDate() const {
        return atmCurve_->maxDate();
    }

    inline Time SabrVolSurface::maxTime() const {
        return atmCurve_->maxTime();
    }

    inline const Date& SabrVolSurface::referenceDate() const {
        return atmCurve_->referenceDate();
    }

    inline Calendar SabrVolSurface::calendar() const {
        return atmCurve_->calendar();
    }

    inline Natural SabrVolSurface::settlementDays() const {
        return atmCurve_->settlementDays();
    }

    inline Real SabrVolSurface::minStrike() const {
        return QL_MIN_REAL;
    }

    inline Real SabrVolSurface::maxStrike() const {
        return QL_MAX_REAL;
    }

    inline const Handle<BlackAtmVolCurve>& SabrVolSurface::atmCurve() const {
        return atmCurve_;
    }

    inline std::vector<Volatility>
    SabrVolSurface::volatilitySpreads(const Period& p) const {
        return volatilitySpreads(optionDateFromTenor(p));
    }
}

#endif
]]></document_content>
  </document>
  <document index="514">
    <source>volatility/sabrvoltermstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sabrvoltermstructure.hpp
    \brief implied vol surface backed by a SABR model
*/

#ifndef quantlib_sabr_vol_termstructure_hpp
#define quantlib_sabr_vol_termstructure_hpp


#include <ql/termstructures/volatility/sabr.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/time/calendars/nullcalendar.hpp>

namespace QuantLib {
    class SABRVolTermStructure : public BlackVolatilityTermStructure {
      public:
        SABRVolTermStructure(Real alpha,
                             Real beta,
                             Real gamma,
                             Real rho,
                             Real s0,
                             Real r,
                             const Date& referenceDate,
                             const DayCounter& dc)
        : BlackVolatilityTermStructure(referenceDate, NullCalendar(), Following, dc), alpha_(alpha),
          beta_(beta), gamma_(gamma), rho_(rho), s0_(s0), r_(r) {}

        Date maxDate() const override { return Date::maxDate(); }
        Rate minStrike() const override { return 0.0; }
        Rate maxStrike() const override { return QL_MAX_REAL; }

      protected:
        Volatility blackVolImpl(Time t, Real strike) const override {
            const Real fwd = s0_*std::exp(r_*t);
            return sabrVolatility(strike, fwd, t, alpha_, beta_, gamma_, rho_);
        }

      private:
        Real alpha_, beta_, gamma_, rho_, s0_, r_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="515">
    <source>volatility/sviinterpolatedsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/sviinterpolatedsmilesection.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    SviInterpolatedSmileSection::SviInterpolatedSmileSection(
        const Date& optionDate,
        Handle<Quote> forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        Handle<Quote> atmVolatility,
        const std::vector<Handle<Quote> >& volHandles,
        Real a,
        Real b,
        Real sigma,
        Real rho,
        Real m,
        bool isAFixed,
        bool isBFixed,
        bool isSigmaFixed,
        bool isRhoFixed,
        bool isMFixed,
        bool vegaWeighted,
        ext::shared_ptr<EndCriteria> endCriteria,
        ext::shared_ptr<OptimizationMethod> method,
        const DayCounter& dc)
    : SmileSection(optionDate, dc), forward_(std::move(forward)),
      atmVolatility_(std::move(atmVolatility)), volHandles_(volHandles), strikes_(strikes),
      actualStrikes_(strikes), hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()),
      a_(a), b_(b), sigma_(sigma), rho_(rho), m_(m), isAFixed_(isAFixed), isBFixed_(isBFixed),
      isSigmaFixed_(isSigmaFixed), isRhoFixed_(isRhoFixed), isMFixed_(isMFixed),
      vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)),
      method_(std::move(method)) {

        LazyObject::registerWith(forward_);
        LazyObject::registerWith(atmVolatility_);
        for (auto& volHandle : volHandles_)
            LazyObject::registerWith(volHandle);
    }

    SviInterpolatedSmileSection::SviInterpolatedSmileSection(
        const Date& optionDate,
        const Rate& forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        const Volatility& atmVolatility,
        const std::vector<Volatility>& volHandles,
        Real a,
        Real b,
        Real sigma,
        Real rho,
        Real m,
        bool isAFixed,
        bool isBFixed,
        bool isSigmaFixed,
        bool isRhoFixed,
        bool isMFixed,
        bool vegaWeighted,
        ext::shared_ptr<EndCriteria> endCriteria,
        ext::shared_ptr<OptimizationMethod> method,
        const DayCounter& dc)
    : SmileSection(optionDate, dc),
      forward_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(forward)))),
      atmVolatility_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(atmVolatility)))),
      volHandles_(volHandles.size()), strikes_(strikes), actualStrikes_(strikes),
      hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()), a_(a), b_(b),
      sigma_(sigma), rho_(rho), m_(m), isAFixed_(isAFixed), isBFixed_(isBFixed),
      isSigmaFixed_(isSigmaFixed), isRhoFixed_(isRhoFixed), isMFixed_(isMFixed),
      vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)),
      method_(std::move(method)) {

        for (Size i = 0; i < volHandles_.size(); ++i)
            volHandles_[i] = Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(volHandles[i])));
    }

void SviInterpolatedSmileSection::createInterpolation() const {
    ext::shared_ptr<SviInterpolation> tmp(new SviInterpolation(
        actualStrikes_.begin(), actualStrikes_.end(), vols_.begin(),
        exerciseTime(), forwardValue_, a_, b_, sigma_, rho_, m_, isAFixed_,
        isBFixed_, isSigmaFixed_, isRhoFixed_, isMFixed_, vegaWeighted_,
        endCriteria_, method_));
    swap(tmp, sviInterpolation_);
}

void SviInterpolatedSmileSection::performCalculations() const {
    forwardValue_ = forward_->value();
    vols_.clear();
    actualStrikes_.clear();
    // we populate the volatilities, skipping the invalid ones
    for (Size i = 0; i < volHandles_.size(); ++i) {
        if (volHandles_[i]->isValid()) {
            if (hasFloatingStrikes_) {
                actualStrikes_.push_back(forwardValue_ + strikes_[i]);
                vols_.push_back(atmVolatility_->value() +
                                volHandles_[i]->value());
            } else {
                actualStrikes_.push_back(strikes_[i]);
                vols_.push_back(volHandles_[i]->value());
            }
        }
    }
    // we are recreating the sabrinterpolation object unconditionnaly to
    // avoid iterator invalidation
    createInterpolation();
    sviInterpolation_->update();
}

Real SviInterpolatedSmileSection::varianceImpl(Real strike) const {
    calculate();
    Real v = (*sviInterpolation_)(strike, true);
    return v * v * exerciseTime();
}
}
]]></document_content>
  </document>
  <document index="516">
    <source>volatility/sviinterpolatedsmilesection.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sviinterpolatedsmilesection.hpp
    \brief svi interpolating smile section
*/

#ifndef quantlib_svi_interpolated_smile_section_hpp
#define quantlib_svi_interpolated_smile_section_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/experimental/volatility/sviinterpolation.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

namespace QuantLib {

class Quote;
class SviInterpolatedSmileSection : public SmileSection, public LazyObject {
  public:
    //! \name Constructors
    //@{
    //! all market data are quotes
    SviInterpolatedSmileSection(
        const Date& optionDate,
        Handle<Quote> forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        Handle<Quote> atmVolatility,
        const std::vector<Handle<Quote> >& volHandles,
        Real a,
        Real b,
        Real sigma,
        Real rho,
        Real m,
        bool aIsFixed,
        bool bIsFixed,
        bool sigmaIsFixed,
        bool rhoIsFixed,
        bool mIsFixed,
        bool vegaWeighted = true,
        ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
        ext::shared_ptr<OptimizationMethod> method = ext::shared_ptr<OptimizationMethod>(),
        const DayCounter& dc = Actual365Fixed());
    //! no quotes
    SviInterpolatedSmileSection(
        const Date& optionDate,
        const Rate& forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        const Volatility& atmVolatility,
        const std::vector<Volatility>& vols,
        Real a,
        Real b,
        Real sigma,
        Real rho,
        Real m,
        bool isAFixed,
        bool isBFixed,
        bool isSigmaFixed,
        bool isRhoFixed,
        bool isMFixed,
        bool vegaWeighted = true,
        ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
        ext::shared_ptr<OptimizationMethod> method = ext::shared_ptr<OptimizationMethod>(),
        const DayCounter& dc = Actual365Fixed());
    //@}
    //! \name LazyObject interface
    //@{
    void performCalculations() const override;
    void update() override;
    //@}
    //! \name SmileSection interface
    //@{
    Real minStrike() const override;
    Real maxStrike() const override;
    Real atmLevel() const override;
    //@}
    Real varianceImpl(Rate strike) const override;
    Volatility volatilityImpl(Rate strike) const override;
    //! \name Inspectors
    //@{
    Real a() const;
    Real b() const;
    Real sigma() const;
    Real rho() const;
    Real m() const;
    Real rmsError() const;
    Real maxError() const;
    EndCriteria::Type endCriteria() const;
    //@}

  protected:
    //! Creates the mutable SviInterpolation
    void createInterpolation() const;
    mutable ext::shared_ptr<SviInterpolation> sviInterpolation_;

    //! Market data
    const Handle<Quote> forward_;
    const Handle<Quote> atmVolatility_;
    std::vector<Handle<Quote> > volHandles_;
    mutable std::vector<Rate> strikes_;
    //! Only strikes corresponding to valid market data
    mutable std::vector<Rate> actualStrikes_;
    bool hasFloatingStrikes_;

    mutable Real forwardValue_;
    mutable std::vector<Volatility> vols_;
    //! Svi parameters
    Real a_, b_, sigma_, rho_, m_;
    //! Svi interpolation settings
    bool isAFixed_, isBFixed_, isSigmaFixed_, isRhoFixed_, isMFixed_;
    bool vegaWeighted_;
    const ext::shared_ptr<EndCriteria> endCriteria_;
    const ext::shared_ptr<OptimizationMethod> method_;
};

inline void SviInterpolatedSmileSection::update() {
    LazyObject::update();
    SmileSection::update();
}

inline Real SviInterpolatedSmileSection::volatilityImpl(Rate strike) const {
    calculate();
    return (*sviInterpolation_)(strike, true);
}

inline Real SviInterpolatedSmileSection::a() const {
    calculate();
    return sviInterpolation_->a();
}

inline Real SviInterpolatedSmileSection::b() const {
    calculate();
    return sviInterpolation_->b();
}

inline Real SviInterpolatedSmileSection::sigma() const {
    calculate();
    return sviInterpolation_->sigma();
}

inline Real SviInterpolatedSmileSection::rho() const {
    calculate();
    return sviInterpolation_->rho();
}

inline Real SviInterpolatedSmileSection::m() const {
    calculate();
    return sviInterpolation_->m();
}

inline Real SviInterpolatedSmileSection::rmsError() const {
    calculate();
    return sviInterpolation_->rmsError();
}

inline Real SviInterpolatedSmileSection::maxError() const {
    calculate();
    return sviInterpolation_->maxError();
}

inline EndCriteria::Type SviInterpolatedSmileSection::endCriteria() const {
    calculate();
    return sviInterpolation_->endCriteria();
}

inline Real SviInterpolatedSmileSection::minStrike() const {
    calculate();
    return actualStrikes_.front();
}

inline Real SviInterpolatedSmileSection::maxStrike() const {
    calculate();
    return actualStrikes_.back();
}

inline Real SviInterpolatedSmileSection::atmLevel() const {
    calculate();
    return forwardValue_;
}
}

#endif
]]></document_content>
  </document>
  <document index="517">
    <source>volatility/sviinterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sviinterpolation.hpp
    \brief Svi interpolation interpolation between discrete points
*/

#ifndef quantlib_svi_interpolation_hpp
#define quantlib_svi_interpolation_hpp

#include <ql/experimental/volatility/svismilesection.hpp>
#include <ql/math/interpolations/xabrinterpolation.hpp>
#include <utility>

namespace QuantLib {

namespace detail {

inline void checkSviParameters(const Real a, const Real b, const Real sigma,
                               const Real rho, const Real m) {
    QL_REQUIRE(b >= 0.0, "b (" << b << ") must be non negative");
    QL_REQUIRE(std::fabs(rho) < 1.0, "rho (" << rho << ") must be in (-1,1)");
    QL_REQUIRE(sigma > 0.0, "sigma (" << sigma << ") must be positive");
    QL_REQUIRE(a + b * sigma * std::sqrt(1.0 - rho * rho) >= 0.0,
               "a + b sigma sqrt(1-rho^2) (a=" << a << ", b=" << b << ", sigma="
                                               << sigma << ", rho=" << rho
                                               << ") must be non negative");
    QL_REQUIRE(b * (1.0 + std::fabs(rho)) < 4.0,
               "b(1+|rho|) must be less than 4");
}

inline Real sviTotalVariance(const Real a, const Real b, const Real sigma,
                             const Real rho, const Real m, const Real k) {
    return a +
           b * (rho * (k - m) + std::sqrt((k - m) * (k - m) + sigma * sigma));
}

typedef SviSmileSection SviWrapper;

struct SviSpecs {
    Size dimension() { return 5; }
    void defaultValues(std::vector<Real> &params,
                       std::vector<bool> &paramIsFixed, const Real &forward,
                       const Real expiryTime,
                       const std::vector<Real> &addParams) {
        if (params[2] == Null<Real>())
            params[2] = 0.1;
        if (params[3] == Null<Real>())
            params[3] = -0.4;
        if (params[4] == Null<Real>())
            params[4] = 0.0;
        if (params[1] == Null<Real>())
            params[1] = 2.0 / (1.0 + std::fabs(params[3]));
        if (params[0] == Null<Real>()) {
            params[0] = std::max(
                0.20 * 0.20 * expiryTime -
                    params[1] * (params[3] * (-params[4]) +
                                 std::sqrt((-params[4]) * (-params[4]) +
                                           params[2] * params[2])),
                -params[1] * params[2] *
                std::sqrt(1.0 - params[3] * params[3]) + eps1());
        }
    }
    void guess(Array &values, const std::vector<bool> &paramIsFixed,
               const Real &forward, const Real expiryTime,
               const std::vector<Real> &r, const std::vector<Real> &addParams) {
        Size j = 0;
        if (!paramIsFixed[2])
            values[2] = r[j++] + eps1();
        if (!paramIsFixed[3])
            values[3] = (2.0 * r[j++] - 1.0) * eps2();
        if (!paramIsFixed[4])
            values[4] = (2.0 * r[j++] - 1.0);
        if (!paramIsFixed[1])
            values[1] = r[j++] * 4.0 / (1.0 + std::fabs(values[3])) * eps2();
        if (!paramIsFixed[0])
            values[0] = r[j++] * expiryTime -
                        eps2() * (values[1] * values[2] *
                                  std::sqrt(1.0 - values[3] * values[3]));
    }
    Array inverse(const Array &y, const std::vector<bool> &,
                  const std::vector<Real> &, const Real) {
        Array x(5);
        x[2] = std::sqrt(y[2] - eps1());
        x[3] = std::asin(y[3] / eps2());
        x[4] = y[4];
        x[1] = std::tan(y[1] / 4.0 * (1.0 + std::fabs(y[3])) / eps2() * M_PI -
                        M_PI / 2.0);
        x[0] = std::sqrt(y[0] - eps1() +
                         y[1] * y[2] * std::sqrt(1.0 - y[3] * y[3]));
        return x;
    }
    Real eps1() { return 0.000001; }
    Real eps2() { return 0.999999; }
    Array direct(const Array &x, const std::vector<bool> &paramIsFixed,
                 const std::vector<Real> &params, const Real forward) {
        Array y(5);
        y[2] = x[2] * x[2] + eps1();
        y[3] = std::sin(x[3]) * eps2();
        y[4] = x[4];
        if (paramIsFixed[1])
            y[1] = params[1];
        else
            y[1] = (std::atan(x[1]) + M_PI / 2.0) / M_PI * eps2() * 4.0 /
                   (1.0 + std::fabs(y[3]));
        if (paramIsFixed[0])
            y[0] = params[0];
        else
            y[0] = eps1() + x[0] * x[0] -
                   y[1] * y[2] * std::sqrt(1.0 - y[3] * y[3]);
        return y;
    }
    Real weight(const Real strike, const Real forward, const Real stdDev,
                const std::vector<Real> &addParams) {
        return blackFormulaStdDevDerivative(strike, forward, stdDev, 1.0);
    }
    typedef SviWrapper type;
    ext::shared_ptr<type> instance(const Time t, const Real &forward,
                                     const std::vector<Real> &params,
                                     const std::vector<Real> &addParams) {
        return ext::make_shared<type>(t, forward, params);
    }
};
}

//! %Svi smile interpolation between discrete volatility points.
class SviInterpolation : public Interpolation {
  public:
    template <class I1, class I2>
    SviInterpolation(const I1 &xBegin, // x = strikes
                     const I1 &xEnd,
                     const I2 &yBegin, // y = volatilities
                     Time t,           // option expiry
                     const Real &forward, Real a, Real b, Real sigma, Real rho,
                     Real m, bool aIsFixed, bool bIsFixed, bool sigmaIsFixed,
                     bool rhoIsFixed, bool mIsFixed, bool vegaWeighted = true,
                     const ext::shared_ptr<EndCriteria> &endCriteria =
                         ext::shared_ptr<EndCriteria>(),
                     const ext::shared_ptr<OptimizationMethod> &optMethod =
                         ext::shared_ptr<OptimizationMethod>(),
                     const Real errorAccept = 0.0020,
                     const bool useMaxError = false,
                     const Size maxGuesses = 50) {

        impl_ = ext::shared_ptr<Interpolation::Impl>(
            new detail::XABRInterpolationImpl<I1, I2, detail::SviSpecs>(
                xBegin, xEnd, yBegin, t, forward,
                {a, b, sigma, rho, m},
                {aIsFixed, bIsFixed, sigmaIsFixed, rhoIsFixed, mIsFixed},
                vegaWeighted, endCriteria, optMethod, errorAccept, useMaxError,
                maxGuesses));
        coeffs_ = ext::dynamic_pointer_cast<
            detail::XABRCoeffHolder<detail::SviSpecs> >(impl_);
    }
    Real expiry() const { return coeffs_->t_; }
    Real forward() const { return coeffs_->forward_; }
    Real a() const { return coeffs_->params_[0]; }
    Real b() const { return coeffs_->params_[1]; }
    Real sigma() const { return coeffs_->params_[2]; }
    Real rho() const { return coeffs_->params_[3]; }
    Real m() const { return coeffs_->params_[4]; }
    Real rmsError() const { return coeffs_->error_; }
    Real maxError() const { return coeffs_->maxError_; }
    const std::vector<Real> &interpolationWeights() const {
        return coeffs_->weights_;
    }
    EndCriteria::Type endCriteria() { return coeffs_->XABREndCriteria_; }

  private:
    ext::shared_ptr<detail::XABRCoeffHolder<detail::SviSpecs> > coeffs_;
};

//! %Svi interpolation factory and traits
class Svi {
  public:
    Svi(Time t,
        Real forward,
        Real a,
        Real b,
        Real sigma,
        Real rho,
        Real m,
        bool aIsFixed,
        bool bIsFixed,
        bool sigmaIsFixed,
        bool rhoIsFixed,
        bool mIsFixed,
        bool vegaWeighted = false,
        ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
        ext::shared_ptr<OptimizationMethod> optMethod = ext::shared_ptr<OptimizationMethod>(),
        const Real errorAccept = 0.0020,
        const bool useMaxError = false,
        const Size maxGuesses = 50)
    : t_(t), forward_(forward), a_(a), b_(b), sigma_(sigma), rho_(rho), m_(m), aIsFixed_(aIsFixed),
      bIsFixed_(bIsFixed), sigmaIsFixed_(sigmaIsFixed), rhoIsFixed_(rhoIsFixed),
      mIsFixed_(mIsFixed), vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)),
      optMethod_(std::move(optMethod)), errorAccept_(errorAccept), useMaxError_(useMaxError),
      maxGuesses_(maxGuesses) {}
    template <class I1, class I2>
    Interpolation interpolate(const I1 &xBegin, const I1 &xEnd,
                              const I2 &yBegin) const {
        return SviInterpolation(xBegin, xEnd, yBegin, t_, forward_, a_, b_,
                                 sigma_, rho_, m_, aIsFixed_, bIsFixed_,
                                 sigmaIsFixed_, rhoIsFixed_, mIsFixed_,
                                 vegaWeighted_, endCriteria_, optMethod_,
                                 errorAccept_, useMaxError_, maxGuesses_);
    }
    static const bool global = true;

  private:
    Time t_;
    Real forward_;
    Real a_, b_, sigma_, rho_, m_;
    bool aIsFixed_, bIsFixed_, sigmaIsFixed_, rhoIsFixed_, mIsFixed_;
    bool vegaWeighted_;
    const ext::shared_ptr<EndCriteria> endCriteria_;
    const ext::shared_ptr<OptimizationMethod> optMethod_;
    const Real errorAccept_;
    const bool useMaxError_;
    const Size maxGuesses_;
};
}

#endif
]]></document_content>
  </document>
  <document index="518">
    <source>volatility/svismilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/sviinterpolation.hpp>
#include <ql/experimental/volatility/svismilesection.hpp>
#include <utility>

namespace QuantLib {

    SviSmileSection::SviSmileSection(Time timeToExpiry, Rate forward, std::vector<Real> sviParams)
    : SmileSection(timeToExpiry, DayCounter()), forward_(forward), params_(std::move(sviParams)) {
        init();
    }

    SviSmileSection::SviSmileSection(const Date& d,
                                     Rate forward,
                                     std::vector<Real> sviParams,
                                     const DayCounter& dc)
    : SmileSection(d, dc, Date()), forward_(forward), params_(std::move(sviParams)) {
        init();
    }

void SviSmileSection::init() {
    QL_REQUIRE(params_.size() == 5,
               "svi expects 5 parameters (a,b,sigma,rho,s,m) but ("
                   << params_.size() << ") given");
    detail::checkSviParameters(params_[0], params_[1], params_[2], params_[3],
                               params_[4]);
}

Real SviSmileSection::volatilityImpl(Rate strike) const {

    Real k = std::log(std::max(strike, 1E-6) / forward_);
    Real totalVariance = detail::sviTotalVariance(params_[0], params_[1], params_[2],
                                                  params_[3], params_[4],k);
    return std::sqrt(std::max(0.0, totalVariance / exerciseTime()));

}
} // namespace QuantLib
]]></document_content>
  </document>
  <document index="519">
    <source>volatility/svismilesection.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file svismilesection.hpp
    \brief svi smile section
*/

#ifndef quantlib_svi_smile_section_hpp
#define quantlib_svi_smile_section_hpp

#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <vector>

namespace QuantLib {

class SviSmileSection : public SmileSection {

  public:
    SviSmileSection(Time timeToExpiry, Rate forward, std::vector<Real> sviParameters);
    SviSmileSection(const Date& d,
                    Rate forward,
                    std::vector<Real> sviParameters,
                    const DayCounter& dc = Actual365Fixed());
    Real minStrike() const override { return 0.0; }
    Real maxStrike() const override { return QL_MAX_REAL; }
    Real atmLevel() const override { return forward_; }

  protected:
    Volatility volatilityImpl(Rate strike) const override;

  private:
    void init();
    Rate forward_;
    std::vector<Real> params_;
};
}

#endif
]]></document_content>
  </document>
  <document index="520">
    <source>volatility/swaptionvolcube1a.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swaptionvolcube1a.hpp
    \brief Swaption volatility cube, fit-early-interpolate-later approach
           using the No Arbitrage Sabr model (Doust)
*/

#ifndef quantlib_swaption_volcube_1a_hpp
#define quantlib_swaption_volcube_1a_hpp

#include <ql/termstructures/volatility/swaption/swaptionvolcube1.hpp>
#include <ql/experimental/volatility/noarbsabrinterpolation.hpp>

namespace QuantLib {

    struct SwaptionVolCubeNoArbSabrModel {
        typedef NoArbSabrInterpolation Interpolation;
        typedef NoArbSabrSmileSection SmileSection;
    };

    typedef SwaptionVolCube1x<SwaptionVolCubeNoArbSabrModel> SwaptionVolCube1a;

}

#endif

]]></document_content>
  </document>
  <document index="521">
    <source>volatility/volcube.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/abcdatmvolcurve.hpp>
#include <ql/experimental/volatility/interestratevolsurface.hpp>
#include <ql/experimental/volatility/volcube.hpp>
#include <utility>

namespace QuantLib {

    VolatilityCube::VolatilityCube(std::vector<Handle<InterestRateVolSurface> > surfaces,
                                   std::vector<Handle<AbcdAtmVolCurve> > curves)
    : surfaces_(std::move(surfaces)), curves_(std::move(curves)) {
        QL_REQUIRE(surfaces_.size()>1, "at least 2 surfaces are needed");

        Date refDate = surfaces_[0]->referenceDate();
        for (auto& surface : surfaces_) {
            QL_REQUIRE(surface->referenceDate() == refDate, "different reference dates");
            //curves_.push_back(surfaces_[i]);
        }

        for (auto& curve : curves_) {
            QL_REQUIRE(curve->referenceDate() == refDate, "different reference dates");
        }

        // sort increasing index tenor
    }
}
]]></document_content>
  </document>
  <document index="522">
    <source>volatility/volcube.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file volcube.hpp
    \brief Interest rate (optionlet/swaption) volatility cube
*/

#ifndef quantlib_volatility_cube_h
#define quantlib_volatility_cube_h

#include <ql/handle.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    class Period;
    class AbcdAtmVolCurve;
    class InterestRateVolSurface;
    class InterestRateIndex;

    class VolatilityCube {
      public:
        VolatilityCube(std::vector<Handle<InterestRateVolSurface> >,
                       std::vector<Handle<AbcdAtmVolCurve> >);
        const Period& minIndexTenor() const;
        const Period& maxIndexTenor() const;
        const std::vector<Handle<InterestRateVolSurface> >& surfaces() const;
        const std::vector<Handle<AbcdAtmVolCurve> >& curves() const;
      protected:
        std::vector<Handle<InterestRateVolSurface> > surfaces_;
        std::vector<Handle<AbcdAtmVolCurve> > curves_;
    };

    // inline

    inline const std::vector<Handle<InterestRateVolSurface> >&
    VolatilityCube::surfaces() const {
        return surfaces_;
    }

    inline const std::vector<Handle<AbcdAtmVolCurve> >&
    VolatilityCube::curves() const {
        return curves_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="523">
    <source>volatility/zabr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/experimental/volatility/zabr.hpp>
#include <ql/termstructures/volatility/sabr.hpp>
#include <ql/errors.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/ode/adaptiverungekutta.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/experimental/finitedifferences/glued1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmdupire1dop.hpp>
#include <ql/experimental/finitedifferences/fdmzabrop.hpp>

using std::pow;

namespace QuantLib {

ZabrModel::ZabrModel(const Real expiryTime, const Real forward,
                     const Real alpha, const Real beta, const Real nu,
                     const Real rho, const Real gamma)
    : expiryTime_(expiryTime), forward_(forward), alpha_(alpha), beta_(beta),
      nu_(nu * std::pow(alpha_, 1.0 - gamma)), rho_(rho), gamma_(gamma) {

    validateSabrParameters(alpha, beta, nu, rho);
    QL_REQUIRE(gamma >= 0.0 /*&& gamma<=1.0*/,
               "gamma must be non negative: " << gamma << " not allowed");
    QL_REQUIRE(forward >= 0.0,
               "forward must be non negative: " << forward << " not allowed");
    QL_REQUIRE(expiryTime > 0.0, "expiry time must be positive: "
                                     << expiryTime << " not allowed");
}

Real ZabrModel::lognormalVolatilityHelper(const Real strike,
                                          const Real x) const {
    if (close(strike, forward_))
        return std::pow(forward_, beta_ - 1.0) * alpha_;
    else
        return std::log(forward_ / strike) / x;
}

Real ZabrModel::lognormalVolatility(const Real strike) const {
    return lognormalVolatility(std::vector<Real>(1, strike))[0];
}

Disposable<std::vector<Real> >
ZabrModel::lognormalVolatility(const std::vector<Real> &strikes) const {
    std::vector<Real> x_ = x(strikes);
    std::vector<Real> result(strikes.size());
    std::transform(strikes.begin(), strikes.end(), x_.begin(), result.begin(),
                   [&](Real _k, Real _x) { return lognormalVolatilityHelper(_k, _x); });
    return result;
}

Real ZabrModel::normalVolatilityHelper(const Real strike, const Real x) const {
    if (close(strike, forward_))
        return std::pow(forward_, beta_) * alpha_;
    else
        return (forward_ - strike) / x;
}

Real ZabrModel::normalVolatility(const Real strike) const {
    return normalVolatility(std::vector<Real>(1, strike))[0];
}

Disposable<std::vector<Real> >
ZabrModel::normalVolatility(const std::vector<Real> &strikes) const {
    std::vector<Real> x_ = x(strikes);
    std::vector<Real> result(strikes.size());
    std::transform(strikes.begin(), strikes.end(), x_.begin(), result.begin(),
                   [&](Real _k, Real _x) { return normalVolatilityHelper(_k, _x); });
    return result;
}

Real ZabrModel::localVolatilityHelper(const Real f, const Real x) const {
    return alpha_ * std::pow(std::fabs(f), beta_) /
           F(y(f), std::pow(alpha_, gamma_ - 1.0) *
                       x); // TODO optimize this, y is comoputed together
                           // with x already
}

Real ZabrModel::localVolatility(const Real f) const {
    return localVolatility(std::vector<Real>(1, f))[0];
}

Disposable<std::vector<Real> >
ZabrModel::localVolatility(const std::vector<Real> &f) const {
    std::vector<Real> x_ = x(f);
    std::vector<Real> result(f.size());
    std::transform(f.begin(), f.end(), x_.begin(), result.begin(),
                   [&](Real _f, Real _x) { return localVolatilityHelper(_f, _x); });
    return result;
}

Real ZabrModel::fdPrice(const Real strike) const {
    return fdPrice(std::vector<Real>(1, strike))[0];
}

Disposable<std::vector<Real> >
ZabrModel::fdPrice(const std::vector<Real> &strikes) const {

    // TODO check strikes to be increasing
    // TODO put these parameters somewhere
    const Real start =
        std::min(0.00001, strikes.front() * 0.5); // lowest strike for grid
    const Real end =
        std::max(0.10, strikes.back() * 1.5); // highest strike for grid
    const Size size = 500;                    // grid points
    const Real density = 0.1; // density for concentrating mesher
    const Size steps =
        (Size)std::ceil(expiryTime_ * 24); // number of steps in dimension t
    const Size dampingSteps = 5;           // thereof damping steps

    // Layout
    std::vector<Size> dim(1, size);
    const ext::shared_ptr<FdmLinearOpLayout> layout(
        new FdmLinearOpLayout(dim));

    // Mesher
    const ext::shared_ptr<Fdm1dMesher> m1(new Concentrating1dMesher(
        start, end, size, std::pair<Real, Real>(forward_, density), true));
    // const ext::shared_ptr<Fdm1dMesher> m1(new
    // Uniform1dMesher(start,end,size));
    // const ext::shared_ptr<Fdm1dMesher> m1a(new
    // Uniform1dMesher(start,0.03,101));
    // const ext::shared_ptr<Fdm1dMesher> m1b(new
    // Uniform1dMesher(0.03,end,100));
    // const ext::shared_ptr<Fdm1dMesher> m1(new Glued1dMesher(*m1a,*m1b));
    const std::vector<ext::shared_ptr<Fdm1dMesher> > meshers(1, m1);
    const ext::shared_ptr<FdmMesher> mesher(
        new FdmMesherComposite(layout, meshers));

    // Boundary conditions
    FdmBoundaryConditionSet boundaries;

    // initial values
    Array rhs(mesher->layout()->size());
    for (FdmLinearOpIterator iter = layout->begin(); iter != layout->end();
         ++iter) {
        Real k = mesher->location(iter, 0);
        rhs[iter.index()] = std::max(forward_ - k, 0.0);
    }

    // local vols (TODO how can we avoid these Array / vector copying?)
    Array k = mesher->locations(0);
    std::vector<Real> kv(k.size());
    std::copy(k.begin(), k.end(), kv.begin());
    std::vector<Real> locVolv = localVolatility(kv);
    Array locVol(locVolv.size());
    std::copy(locVolv.begin(), locVolv.end(), locVol.begin());

    // solver
    ext::shared_ptr<FdmDupire1dOp> map(new FdmDupire1dOp(mesher, locVol));
    FdmBackwardSolver solver(map, boundaries,
                             ext::shared_ptr<FdmStepConditionComposite>(),
                             FdmSchemeDesc::Douglas());
    solver.rollback(rhs, expiryTime_, 0.0, steps, dampingSteps);

    // interpolate solution
    ext::shared_ptr<Interpolation> solution(new CubicInterpolation(
        k.begin(), k.end(), rhs.begin(), CubicInterpolation::Spline, true,
        CubicInterpolation::SecondDerivative, 0.0,
        CubicInterpolation::SecondDerivative, 0.0));
    // ext::shared_ptr<Interpolation> solution(new
    // LinearInterpolation(k.begin(),k.end(),rhs.begin()));
    solution->disableExtrapolation();
    std::vector<Real> result(strikes.size());
    std::transform(strikes.begin(), strikes.end(), result.begin(), *solution);
    return result;
}

Real ZabrModel::fullFdPrice(const Real strike) const {

    // TODO what are good values here, still experimenting with them
    Real eps = 0.01;
    Real scaleFactor = 1.5;
    Real normInvEps = InverseCumulativeNormal()(1.0 - eps);
    Real alphaI = alpha_ * std::pow(forward_, beta_ - 1.0);
    // nu is already standardized within this class ...
    Real v0 = alpha_ * std::exp(-scaleFactor * normInvEps *
                                std::sqrt(expiryTime_) * nu_);
    Real v1 = alpha_ *
              std::exp(scaleFactor * normInvEps * std::sqrt(expiryTime_) * nu_);
    Real f0 = forward_ * std::exp(-scaleFactor * normInvEps *
                                  std::sqrt(expiryTime_) * alphaI);
    Real f1 = forward_ * std::exp(scaleFactor * normInvEps *
                                  std::sqrt(expiryTime_) * alphaI);
    v1 = std::min(v1, 2.0);
    f0 = std::min(strike / 2.0, f0);
    f1 = std::max(strike * 1.5, std::min(f1, std::max(2.0, strike * 1.5)));

    const Size sizef = 100;
    const Size sizev = 100;
    const Size steps = Size(24 * expiryTime_ + 1);
    const Size dampingSteps = 5;
    const Real densityf = 0.1;
    const Real densityv = 0.1;

    QL_REQUIRE(strike >= f0 && strike <= f1,
               "strike (" << strike << ") must be inside pde grid [" << f0
                          << ";" << f1 << "]");

    // Layout
    std::vector<Size> dim;
    dim.push_back(sizef);
    dim.push_back(sizev);
    const ext::shared_ptr<FdmLinearOpLayout> layout(
        new FdmLinearOpLayout(dim));

    // Mesher
    // two concentrating mesher around f and k to get the mesher for f
    const Real x0 = std::min(forward_, strike);
    const Real x1 = std::max(forward_, strike);
    const Size sizefa = std::max<Size>(
        4, (Size)std::ceil(((x0 + x1) / 2.0 - f0) / (f1 - f0) * (Real)sizef));
    const Size sizefb = sizef - sizefa + 1; // common point, so we can spend
    // one more here
    const ext::shared_ptr<Fdm1dMesher> mfa(
        new Concentrating1dMesher(f0, (x0 + x1) / 2.0, sizefa,
                                  std::pair<Real, Real>(x0, densityf), true));
    const ext::shared_ptr<Fdm1dMesher> mfb(
        new Concentrating1dMesher((x0 + x1) / 2.0, f1, sizefb,
                                  std::pair<Real, Real>(x1, densityf), true));
    const ext::shared_ptr<Fdm1dMesher> mf(new Glued1dMesher(*mfa, *mfb));

    // concentraing mesher around f to get the forward mesher
    // const ext::shared_ptr<Fdm1dMesher> mf(new Concentrating1dMesher(
    //     f0, f1, sizef, std::pair<Real, Real>(forward_, densityf), true));

    // Volatility mesher
    const ext::shared_ptr<Fdm1dMesher> mv(new Concentrating1dMesher(
        v0, v1, sizev, std::pair<Real, Real>(alpha_, densityv), true));

    // uniform meshers
    // const ext::shared_ptr<Fdm1dMesher> mf(new
    // Uniform1dMesher(f0,f1,sizef));
    // const ext::shared_ptr<Fdm1dMesher> mv(new
    // Uniform1dMesher(v0,v1,sizev));

    std::vector<ext::shared_ptr<Fdm1dMesher> > meshers;
    meshers.push_back(mf);
    meshers.push_back(mv);
    const ext::shared_ptr<FdmMesher> mesher(
        new FdmMesherComposite(layout, meshers));

    // initial values
    Array rhs(mesher->layout()->size());
    std::vector<Real> f_;
    std::vector<Real> v_;
    for (FdmLinearOpIterator iter = layout->begin(); iter != layout->end();
         ++iter) {
        Real f = mesher->location(iter, 0);
        // Real v = mesher->location(iter, 0);
        rhs[iter.index()] = std::max(f - strike, 0.0);
        if (iter.coordinates()[1] == 0U)
            f_.push_back(mesher->location(iter, 0));
        if (iter.coordinates()[0] == 0U)
            v_.push_back(mesher->location(iter, 1));
    }

    // Boundary conditions
    FdmBoundaryConditionSet boundaries;

    ext::shared_ptr<FdmZabrOp> map(
        new FdmZabrOp(mesher, beta_, nu_, rho_, gamma_));
    FdmBackwardSolver solver(map, boundaries,
                             ext::shared_ptr<FdmStepConditionComposite>(),
                             FdmSchemeDesc::/*CraigSneyd()*/ Hundsdorfer());

    solver.rollback(rhs, expiryTime_, 0.0, steps, dampingSteps);

    // interpolate solution (this is not necessary when using concentrating
    // meshers with required point)
    Matrix result(f_.size(), v_.size());
    for (Size j = 0; j < v_.size(); ++j)
        std::copy(rhs.begin() + j * f_.size(),
                  rhs.begin() + (j + 1) * f_.size(), result.row_begin(j));
    ext::shared_ptr<BicubicSpline> interpolation =
        ext::make_shared<BicubicSpline>(
            f_.begin(), f_.end(), v_.begin(), v_.end(), result);
    interpolation->disableExtrapolation();
    return (*interpolation)(forward_, alpha_);
}

Real ZabrModel::x(const Real strike) const {
    return x(std::vector<Real>(1, strike))[0];
}

Disposable<std::vector<Real> >
ZabrModel::x(const std::vector<Real> &strikes) const {

    QL_REQUIRE(strikes[0] > 0.0 || beta_ < 1.0,
               "strikes must be positive (" << strikes[0] << ") if beta = 1");
    for (auto i = strikes.begin() + 1; i != strikes.end(); ++i)
        QL_REQUIRE(*i > *(i - 1), "strikes must be strictly ascending ("
                                      << *(i - 1) << "," << *i << ")");

    AdaptiveRungeKutta<Real> rk(1.0E-8, 1.0E-5,
                                0.0); // TODO move the parameters here as
                                      // parameters with default values to
                                      // the constructor
    std::vector<Real> y(strikes.size()), result(strikes.size());
    std::transform(strikes.rbegin(), strikes.rend(), y.begin(),
                   [&](Real _k) { return this->y(_k); });

    if (close(gamma_, 1.0)) {
        for (Size m = 0; m < y.size(); m++) {
            Real J = std::sqrt(1.0 + nu_ * nu_ * y[m] * y[m] -
                               2.0 * rho_ * nu_ * y[m]);
            result[y.size() - 1 - m] =
                std::log((J + nu_ * y[m] - rho_) / (1.0 - rho_)) / nu_;
        }
    } else {
        Size ynz = std::upper_bound(y.begin(), y.end(), 0.0) - y.begin();
        if (ynz > 0)
            if (close(y[ynz - 1], 0.0))
                ynz--;
        if (ynz == y.size())
            ynz--;

        for (int dir = 1; dir >= -1; dir -= 2) {
            Real y0 = 0.0, u0 = 0.0;
            for (int m = ynz + (dir == -1 ? -1 : 0);
                 dir == -1 ? m >= 0 : m < (int)y.size(); m += dir) {
                Real u = rk([&](Real _y, Real _u){ return F(_y, _u); },
                            u0, y0, y[m]);
                result[y.size() - 1 - m] = u * pow(alpha_, 1.0 - gamma_);
                u0 = u;
                y0 = y[m];
            }
        }
    }

    return result;
}

Real ZabrModel::y(const Real strike) const {

    if (close(beta_, 1.0)) {
        return std::log(forward_ / strike) * std::pow(alpha_, gamma_ - 2.0);
    } else {
        return (strike < 0.0
                    ? std::pow(forward_, 1.0 - beta_) +
                          std::pow(-strike, 1.0 - beta_)
                    : std::pow(forward_, 1.0 - beta_) -
                          std::pow(strike, 1.0 - beta_)) *
               std::pow(alpha_, gamma_ - 2.0) / (1.0 - beta_);
    }
}

Real ZabrModel::F(const Real y, const Real u) const {
    Real A = 1.0 + (gamma_ - 2.0) * (gamma_ - 2.0) * nu_ * nu_ * y * y +
             2.0 * rho_ * (gamma_ - 2.0) * nu_ * y;
    Real B = 2.0 * rho_ * (1.0 - gamma_) * nu_ +
             2.0 * (1.0 - gamma_) * (gamma_ - 2.0) * nu_ * nu_ * y;
    Real C = (1.0 - gamma_) * (1.0 - gamma_) * nu_ * nu_;
    return (-B * u + std::sqrt(B * B * u * u - 4.0 * A * (C * u * u - 1.0))) /
           (2.0 * A);
}
}
]]></document_content>
  </document>
  <document index="524">
    <source>volatility/zabr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zabr.hpp
    \brief ZABR functions
    Reference: Andreasen, Huge: ZABR - Expansions for the masses, Preliminary
               Version, December 2011, http://ssrn.com/abstract=1980726
*/

#ifndef quantlib_zabr_hpp
#define quantlib_zabr_hpp

#include <ql/types.hpp>
#include <ql/utilities/disposable.hpp>
#include <ql/math/statistics/incrementalstatistics.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <vector>

namespace QuantLib {

class ZabrModel {

  public:
    ZabrModel(Real expiryTime, Real forward, Real alpha, Real beta, Real nu, Real rho, Real gamma);

    Real localVolatility(Real f) const;
    Disposable<std::vector<Real> >
    localVolatility(const std::vector<Real> &f) const;

    Real fdPrice(Real strike) const;
    Disposable<std::vector<Real> >
    fdPrice(const std::vector<Real> &strikes) const;

    Real fullFdPrice(Real strike) const;

    Real lognormalVolatility(Real strike) const;
    Disposable<std::vector<Real> >
    lognormalVolatility(const std::vector<Real> &strikes) const;

    Real normalVolatility(Real strike) const;
    Disposable<std::vector<Real> >
    normalVolatility(const std::vector<Real> &strikes) const;

    Real forward() const { return forward_; }
    Real expiryTime() const { return expiryTime_; }
    Real alpha() const { return alpha_; }
    Real beta() const { return beta_; }
    Real nu() const { return nu_; }
    Real rho() const { return rho_; }
    Real gamma() const { return gamma_; }

  private:
    const Real expiryTime_, forward_;
    const Real alpha_, beta_, nu_, rho_,
        gamma_; // nu_ here is a tranformed version of the input nu !

    Real x(Real strike) const;
    Disposable<std::vector<Real> > x(const std::vector<Real> &strikes) const;

    Real y(Real strike) const;

    Real F(Real y, Real u) const;

    Real lognormalVolatilityHelper(Real strike, Real x) const;
    Real normalVolatilityHelper(Real strike, Real x) const;
    Real localVolatilityHelper(Real f, Real x) const;
};
}

#endif
]]></document_content>
  </document>
  <document index="525">
    <source>volatility/zabrinterpolatedsmilesection.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zabrinterpolatedsmilesection.hpp
    \brief zabr interpolating smile section
*/

#ifndef quantlib_zabr_interpolated_smile_section_hpp
#define quantlib_zabr_interpolated_smile_section_hpp

#include <ql/experimental/volatility/zabrinterpolation.hpp>
#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <utility>

namespace QuantLib {

template <typename Evaluation>
class ZabrInterpolatedSmileSection : public SmileSection, public LazyObject {
  public:
    //! \name Constructors
    //@{
    //! all market data are quotes
    ZabrInterpolatedSmileSection(
        const Date& optionDate,
        Handle<Quote> forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        Handle<Quote> atmVolatility,
        const std::vector<Handle<Quote> >& volHandles,
        Real alpha,
        Real beta,
        Real nu,
        Real rho,
        Real gamma,
        bool isAlphaFixed = false,
        bool isBetaFixed = false,
        bool isNuFixed = false,
        bool isRhoFixed = false,
        bool isGammaFixed = false,
        bool vegaWeighted = true,
        ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
        ext::shared_ptr<OptimizationMethod> method = ext::shared_ptr<OptimizationMethod>(),
        const DayCounter& dc = Actual365Fixed());
    //! no quotes
    ZabrInterpolatedSmileSection(
        const Date& optionDate,
        const Rate& forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        const Volatility& atmVolatility,
        const std::vector<Volatility>& vols,
        Real alpha,
        Real beta,
        Real nu,
        Real rho,
        Real gamma,
        bool isAlphaFixed = false,
        bool isBetaFixed = false,
        bool isNuFixed = false,
        bool isRhoFixed = false,
        bool isGammaFixed = false,
        bool vegaWeighted = true,
        ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
        ext::shared_ptr<OptimizationMethod> method = ext::shared_ptr<OptimizationMethod>(),
        const DayCounter& dc = Actual365Fixed());
    //@}
    //! \name LazyObject interface
    //@{
    void performCalculations() const override;
    void update() override;
    //@}
    //! \name SmileSection interface
    //@{
    Real minStrike() const override;
    Real maxStrike() const override;
    Real atmLevel() const override;
    //@}
    Real varianceImpl(Rate strike) const override;
    Volatility volatilityImpl(Rate strike) const override;
    //! \name Inspectors
    //@{
    Real alpha() const;
    Real beta() const;
    Real nu() const;
    Real rho() const;
    Real gamma() const;
    Real rmsError() const;
    Real maxError() const;
    EndCriteria::Type endCriteria() const;
    //@}

  protected:
    //! Creates the mutable SABRInterpolation
    void createInterpolation() const;
    mutable ext::shared_ptr<ZabrInterpolation<Evaluation> > zabrInterpolation_;

    //! Market data
    const Handle<Quote> forward_;
    const Handle<Quote> atmVolatility_;
    std::vector<Handle<Quote> > volHandles_;
    mutable std::vector<Rate> strikes_;
    //! Only strikes corresponding to valid market data
    mutable std::vector<Rate> actualStrikes_;
    bool hasFloatingStrikes_;

    mutable Real forwardValue_;
    mutable std::vector<Volatility> vols_;
    //! Sabr parameters
    Real alpha_, beta_, nu_, rho_, gamma_;
    //! Sabr interpolation settings
    bool isAlphaFixed_, isBetaFixed_, isNuFixed_, isRhoFixed_, isGammaFixed_;
    bool vegaWeighted_;
    const ext::shared_ptr<EndCriteria> endCriteria_;
    const ext::shared_ptr<OptimizationMethod> method_;
};

template <typename Evaluation>
inline void ZabrInterpolatedSmileSection<Evaluation>::update() {
    LazyObject::update();
    SmileSection::update();
}

template <typename Evaluation>
inline Real
ZabrInterpolatedSmileSection<Evaluation>::volatilityImpl(Rate strike) const {
    calculate();
    return (*zabrInterpolation_)(strike, true);
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::alpha() const {
    calculate();
    return zabrInterpolation_->alpha();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::beta() const {
    calculate();
    return zabrInterpolation_->beta();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::nu() const {
    calculate();
    return zabrInterpolation_->nu();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::rho() const {
    calculate();
    return zabrInterpolation_->rho();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::rmsError() const {
    calculate();
    return zabrInterpolation_->rmsError();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::maxError() const {
    calculate();
    return zabrInterpolation_->maxError();
}

template <typename Evaluation>
inline EndCriteria::Type
ZabrInterpolatedSmileSection<Evaluation>::endCriteria() const {
    calculate();
    return zabrInterpolation_->endCriteria();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::minStrike() const {
    calculate();
    return actualStrikes_.front();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::maxStrike() const {
    calculate();
    return actualStrikes_.back();
}

template <typename Evaluation>
inline Real ZabrInterpolatedSmileSection<Evaluation>::atmLevel() const {
    calculate();
    return forwardValue_;
}

template <typename Evaluation>
ZabrInterpolatedSmileSection<Evaluation>::ZabrInterpolatedSmileSection(
    const Date& optionDate,
    Handle<Quote> forward,
    const std::vector<Rate>& strikes,
    bool hasFloatingStrikes,
    Handle<Quote> atmVolatility,
    const std::vector<Handle<Quote> >& volHandles,
    Real alpha,
    Real beta,
    Real nu,
    Real rho,
    Real gamma,
    bool isAlphaFixed,
    bool isBetaFixed,
    bool isNuFixed,
    bool isRhoFixed,
    bool isGammaFixed,
    bool vegaWeighted,
    ext::shared_ptr<EndCriteria> endCriteria,
    ext::shared_ptr<OptimizationMethod> method,
    const DayCounter& dc)
: SmileSection(optionDate, dc), forward_(std::move(forward)),
  atmVolatility_(std::move(atmVolatility)), volHandles_(volHandles), strikes_(strikes),
  actualStrikes_(strikes), hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()),
  alpha_(alpha), beta_(beta), nu_(nu), rho_(rho), gamma_(gamma), isAlphaFixed_(isAlphaFixed),
  isBetaFixed_(isBetaFixed), isNuFixed_(isNuFixed), isRhoFixed_(isRhoFixed),
  isGammaFixed_(isGammaFixed), vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)),
  method_(std::move(method)) {

    LazyObject::registerWith(forward_);
    LazyObject::registerWith(atmVolatility_);
    for (auto& volHandle : volHandles_)
        LazyObject::registerWith(volHandle);
}

template <typename Evaluation>
ZabrInterpolatedSmileSection<Evaluation>::ZabrInterpolatedSmileSection(
    const Date& optionDate,
    const Rate& forward,
    const std::vector<Rate>& strikes,
    bool hasFloatingStrikes,
    const Volatility& atmVolatility,
    const std::vector<Volatility>& volHandles,
    Real alpha,
    Real beta,
    Real nu,
    Real rho,
    Real gamma,
    bool isAlphaFixed,
    bool isBetaFixed,
    bool isNuFixed,
    bool isRhoFixed,
    bool isGammaFixed,
    bool vegaWeighted,
    ext::shared_ptr<EndCriteria> endCriteria,
    ext::shared_ptr<OptimizationMethod> method,
    const DayCounter& dc)
: SmileSection(optionDate, dc),
  forward_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(forward)))),
  atmVolatility_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(atmVolatility)))),
  volHandles_(volHandles.size()), strikes_(strikes), actualStrikes_(strikes),
  hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()), alpha_(alpha), beta_(beta),
  nu_(nu), rho_(rho), gamma_(gamma), isAlphaFixed_(isAlphaFixed), isBetaFixed_(isBetaFixed),
  isNuFixed_(isNuFixed), isRhoFixed_(isRhoFixed), isGammaFixed_(isGammaFixed),
  vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)), method_(std::move(method)) {

    for (Size i = 0; i < volHandles_.size(); ++i)
        volHandles_[i] = Handle<Quote>(
            ext::shared_ptr<Quote>(new SimpleQuote(volHandles[i])));
}

template <typename Evaluation>
void ZabrInterpolatedSmileSection<Evaluation>::createInterpolation() const {
    ext::shared_ptr<ZabrInterpolation<Evaluation> > tmp(
        new ZabrInterpolation<Evaluation>(
            actualStrikes_.begin(), actualStrikes_.end(), vols_.begin(),
            exerciseTime(), forwardValue_, alpha_, beta_, nu_, rho_, gamma_,
            isAlphaFixed_, isBetaFixed_, isNuFixed_, isRhoFixed_, isGammaFixed_,
            vegaWeighted_, endCriteria_, method_));
    swap(tmp, zabrInterpolation_);
}

template <typename Evaluation>
void ZabrInterpolatedSmileSection<Evaluation>::performCalculations() const {
    forwardValue_ = forward_->value();
    vols_.clear();
    actualStrikes_.clear();
    // we populate the volatilities, skipping the invalid ones
    for (Size i = 0; i < volHandles_.size(); ++i) {
        if (volHandles_[i]->isValid()) {
            if (hasFloatingStrikes_) {
                actualStrikes_.push_back(forwardValue_ + strikes_[i]);
                vols_.push_back(atmVolatility_->value() +
                                volHandles_[i]->value());
            } else {
                actualStrikes_.push_back(strikes_[i]);
                vols_.push_back(volHandles_[i]->value());
            }
        }
    }
    // we are recreating the sabrinterpolation object unconditionnaly to
    // avoid iterator invalidation
    createInterpolation();
    zabrInterpolation_->update();
}

template <typename Evaluation>
Real ZabrInterpolatedSmileSection<Evaluation>::varianceImpl(Real strike) const {
    calculate();
    Real v = (*zabrInterpolation_)(strike, true);
    return v * v * exerciseTime();
}
}

#endif
]]></document_content>
  </document>
  <document index="526">
    <source>volatility/zabrinterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zabrinterpolation.hpp
    \brief ZABR interpolation interpolation between discrete points
*/

#ifndef quantlib_zabr_interpolation_hpp
#define quantlib_zabr_interpolation_hpp

#include <ql/experimental/volatility/zabrsmilesection.hpp>
#include <ql/math/interpolations/xabrinterpolation.hpp>
#include <utility>

namespace QuantLib {

namespace detail {

template <typename Evaluation> struct ZabrSpecs {
    Size dimension() { return 5; }
    Real eps() { return 0.000001; }
    void defaultValues(std::vector<Real> &params,
                       std::vector<bool> &paramIsFixed, const Real &forward,
                       const Real expiryTime, const std::vector<Real>& addParams) {
        if (params[1] == Null<Real>())
            params[1] = 0.5;
        if (params[0] == Null<Real>())
            // adapt alpha to beta level
            params[0] =
                0.2 *
                (params[1] < 0.9999 ? std::pow(forward, 1.0 - params[1]) : 1.0);
        if (params[2] == Null<Real>())
            params[2] = std::sqrt(0.4);
        if (params[3] == Null<Real>())
            params[3] = 0.0;
        if (params[4] == Null<Real>())
            params[4] = 1.0;
    }
    void guess(Array &values, const std::vector<bool> &paramIsFixed,
               const Real &forward, const Real expiryTime,
               const std::vector<Real> &r, const std::vector<Real>& addParams) {
        Size j = 0;
        if (!paramIsFixed[1])
            values[1] = (1.0 - 2E-6) * r[j++] + 1E-6;
        if (!paramIsFixed[0]) {
            values[0] = (1.0 - 2E-6) * r[j++] + 1E-6; // lognormal vol guess
            // adapt this to beta level
            if (values[1] < 0.999)
                values[0] *= std::pow(forward, 1.0 - values[1]);
        }
        if (!paramIsFixed[2])
            values[2] = 1.5 * r[j++] + 1E-6;
        if (!paramIsFixed[3])
            values[3] = (2.0 * r[j++] - 1.0) * (1.0 - 1E-6);
        if (!paramIsFixed[4])
            values[4] = r[j++] * 2.0;
    }
    Real eps1() { return .0000001; }
    Real eps2() { return .9999; }
    Real dilationFactor() { return 0.001; }
    Array inverse(const Array &y, const std::vector<bool> &,
                  const std::vector<Real> &, const Real) {
        Array x(5);
        x[0] = y[0] < 25.0 + eps1() ? std::sqrt(y[0] - eps1())
                                    : (y[0] - eps1() + 25.0) / 10.0;
        x[1] = std::sqrt(-std::log(y[1]));
        x[2] = std::tan(M_PI*(y[4]/5.0-0.5));
        x[3] = std::asin(y[3] / eps2());
        x[4] = std::tan(M_PI*(y[4]/1.9-0.5));
        return x;
    }
    Array direct(const Array &x, const std::vector<bool> &,
                 const std::vector<Real> &, const Real) {
        Array y(5);
        y[0] = std::fabs(x[0]) < 5.0 ? x[0] * x[0] + eps1()
                                     : (10.0 * std::fabs(x[0]) - 25.0) + eps1();
        y[1] = std::fabs(x[1]) < std::sqrt(-std::log(eps1()))
                   ? std::exp(-(x[1] * x[1]))
                   : eps1();
        // limit nu to 5.00
        y[2] = (std::atan(x[2])/M_PI + 0.5) * 5.0;
        y[3] = std::fabs(x[3]) < 2.5 * M_PI
                   ? eps2() * std::sin(x[3])
                   : eps2() * (x[3] > 0.0 ? 1.0 : (-1.0));
        // limit gamma to 1.9
        y[4] = (std::atan(x[4])/M_PI + 0.5) * 1.9;
        return y;
    }
    Real weight(const Real strike, const Real forward, const Real stdDev,
                const std::vector<Real> &addParams) {
        return blackFormulaStdDevDerivative(strike, forward, stdDev, 1.0);
    }
    typedef ZabrSmileSection<Evaluation> type;
    ext::shared_ptr<type> instance(const Time t, const Real &forward,
                                     const std::vector<Real> &params,
                                     const std::vector<Real> &addParams) {
        return ext::make_shared<type>(t, forward, params);
    }
};
} // end namespace detail


//! zabr smile interpolation between discrete volatility points.
template <class Evaluation> class ZabrInterpolation : public Interpolation {
  public:
    template <class I1, class I2>
    ZabrInterpolation(
        const I1 &xBegin, // x = strikes
        const I1 &xEnd,
        const I2 &yBegin, // y = volatilities
        Time t,           // option expiry
        const Real &forward, Real alpha, Real beta, Real nu, Real rho,
        Real gamma, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed,
        bool rhoIsFixed, bool gammaIsFixed, bool vegaWeighted = true,
        const ext::shared_ptr<EndCriteria> &endCriteria =
            ext::shared_ptr<EndCriteria>(),
        const ext::shared_ptr<OptimizationMethod> &optMethod =
            ext::shared_ptr<OptimizationMethod>(),
        const Real errorAccept = 0.0020, const bool useMaxError = false,
        const Size maxGuesses = 50) {
            impl_ = ext::shared_ptr<
                Interpolation::Impl>(new detail::XABRInterpolationImpl<
                I1, I2,
                detail::ZabrSpecs<Evaluation> >(
                xBegin, xEnd, yBegin, t, forward,
                {alpha, beta, nu, rho, gamma},
                {alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, gammaIsFixed},
                vegaWeighted, endCriteria, optMethod, errorAccept, useMaxError,
                maxGuesses));
            coeffs_ = ext::dynamic_pointer_cast<detail::XABRCoeffHolder<
                detail::ZabrSpecs<Evaluation> > >(impl_);
    }
    Real expiry() const { return coeffs_->t_; }
    Real forward() const { return coeffs_->forward_; }
    Real alpha() const { return coeffs_->params_[0]; }
    Real beta() const { return coeffs_->params_[1]; }
    Real nu() const { return coeffs_->params_[2]; }
    Real rho() const { return coeffs_->params_[3]; }
    Real gamma() const { return coeffs_->params_[4]; }
    Real rmsError() const { return coeffs_->error_; }
    Real maxError() const { return coeffs_->maxError_; }
    const std::vector<Real> &interpolationWeights() const {
        return coeffs_->weights_;
    }
    EndCriteria::Type endCriteria() { return coeffs_->XABREndCriteria_; }

  private:
    ext::shared_ptr<detail::XABRCoeffHolder<detail::ZabrSpecs<Evaluation> > > coeffs_;
};

//! no arbtrage sabr interpolation factory and traits
template<class Evaluation> class Zabr {
  public:
    Zabr(Time t,
         Real forward,
         Real alpha,
         Real beta,
         Real nu,
         Real rho,
         Real gamma,
         bool alphaIsFixed,
         bool betaIsFixed,
         bool nuIsFixed,
         bool rhoIsFixed,
         bool gammaIsFixed,
         bool vegaWeighted = false,
         ext::shared_ptr<EndCriteria> endCriteria = ext::shared_ptr<EndCriteria>(),
         ext::shared_ptr<OptimizationMethod> optMethod = ext::shared_ptr<OptimizationMethod>(),
         const Real errorAccept = 0.0020,
         const bool useMaxError = false,
         const Size maxGuesses = 50)
    : t_(t), forward_(forward), alpha_(alpha), beta_(beta), nu_(nu), rho_(rho),
      alphaIsFixed_(alphaIsFixed), betaIsFixed_(betaIsFixed), nuIsFixed_(nuIsFixed),
      rhoIsFixed_(rhoIsFixed), gammaIsFixed_(gammaIsFixed), vegaWeighted_(vegaWeighted),
      endCriteria_(std::move(endCriteria)), optMethod_(std::move(optMethod)),
      errorAccept_(errorAccept), useMaxError_(useMaxError), maxGuesses_(maxGuesses) {}
    template <class I1, class I2>
    Interpolation interpolate(const I1 &xBegin, const I1 &xEnd,
                              const I2 &yBegin) const {
        return ZabrInterpolation<Evaluation>(
            xBegin, xEnd, yBegin, t_, forward_, alpha_, beta_, nu_, rho_,
            gamma_, alphaIsFixed_, betaIsFixed_, nuIsFixed_, rhoIsFixed_,
            gammaIsFixed_, vegaWeighted_, endCriteria_, optMethod_,
            errorAccept_, useMaxError_, maxGuesses_);
    }
    static const bool global = true;

  private:
    Time t_;
    Real forward_;
    Real alpha_, beta_, nu_, rho_, gamma_;
    bool alphaIsFixed_, betaIsFixed_, nuIsFixed_, rhoIsFixed_, gammaIsFixed_;
    bool vegaWeighted_;
    const ext::shared_ptr<EndCriteria> endCriteria_;
    const ext::shared_ptr<OptimizationMethod> optMethod_;
    const Real errorAccept_;
    const bool useMaxError_;
    const Size maxGuesses_;
};
}

#endif
]]></document_content>
  </document>
  <document index="527">
    <source>volatility/zabrsmilesection.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zabrsmilesection.hpp
    \brief zabr smile section
*/

#ifndef quantlib_zabr_smile_section_hpp
#define quantlib_zabr_smile_section_hpp

#include <ql/experimental/volatility/zabr.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/termstructures/volatility/smilesectionutils.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <utility>
#include <vector>

using std::exp;

namespace QuantLib {

// Evaluation Tags

struct ZabrShortMaturityLognormal {};
struct ZabrShortMaturityNormal {};
struct ZabrLocalVolatility {};
struct ZabrFullFd {};

template <typename Evaluation> class ZabrSmileSection : public SmileSection {
  public:
    ZabrSmileSection(Time timeToExpiry,
                     Rate forward,
                     std::vector<Real> zabrParameters,
                     const std::vector<Real>& moneyness = std::vector<Real>(),
                     Size fdRefinement = 5);
    ZabrSmileSection(const Date& d,
                     Rate forward,
                     std::vector<Real> zabrParameters,
                     const DayCounter& dc = Actual365Fixed(),
                     const std::vector<Real>& moneyness = std::vector<Real>(),
                     Size fdRefinement = 5);

    Real minStrike() const override { return 0.0; }
    Real maxStrike() const override { return QL_MAX_REAL; }
    Real atmLevel() const override { return model_->forward(); }
    Real
    optionPrice(Rate strike, Option::Type type = Option::Call, Real discount = 1.0) const override {
        return optionPrice(strike, type, discount, Evaluation());
    }

    ext::shared_ptr<ZabrModel> model() { return model_; }

  protected:
    Volatility volatilityImpl(Rate strike) const override {
        return volatilityImpl(strike, Evaluation());
    }

  private:
    void init(const std::vector<Real> &moneyness) {
        init(moneyness, Evaluation());
        init2(Evaluation());
        init3(Evaluation());
    }
    void init(const std::vector<Real> &moneyness, ZabrShortMaturityLognormal);
    void init(const std::vector<Real> &moneyness, ZabrShortMaturityNormal);
    void init(const std::vector<Real> &moneyness, ZabrLocalVolatility);
    void init(const std::vector<Real> &moneyness, ZabrFullFd);
    void init2(ZabrShortMaturityLognormal);
    void init2(ZabrShortMaturityNormal);
    void init2(ZabrLocalVolatility);
    void init2(ZabrFullFd);
    void init3(ZabrShortMaturityLognormal);
    void init3(ZabrShortMaturityNormal);
    void init3(ZabrLocalVolatility);
    void init3(ZabrFullFd);
    Real optionPrice(Rate strike, Option::Type type, Real discount,
                     ZabrShortMaturityLognormal) const;
    Real optionPrice(Rate strike, Option::Type type, Real discount,
                     ZabrShortMaturityNormal) const;
    Real optionPrice(Rate strike, Option::Type type, Real discount,
                     ZabrLocalVolatility) const;
    Real optionPrice(Rate strike, Option::Type type, Real discount,
                     ZabrFullFd) const;
    Volatility volatilityImpl(Rate strike, ZabrShortMaturityLognormal) const;
    Volatility volatilityImpl(Rate strike, ZabrShortMaturityNormal) const;
    Volatility volatilityImpl(Rate strike, ZabrLocalVolatility) const;
    Volatility volatilityImpl(Rate strike, ZabrFullFd) const;
    ext::shared_ptr<ZabrModel> model_;
    Evaluation evaluation_;
    Rate forward_;
    std::vector<Real> params_;
    const Size fdRefinement_;
    std::vector<Real> strikes_, callPrices_;
    ext::shared_ptr<Interpolation> callPriceFct_;
    Real a_, b_;
};

template <typename Evaluation>
ZabrSmileSection<Evaluation>::ZabrSmileSection(Time timeToExpiry,
                                               Rate forward,
                                               std::vector<Real> zabrParams,
                                               const std::vector<Real>& moneyness,
                                               const Size fdRefinement)
: SmileSection(timeToExpiry, DayCounter()), forward_(forward), params_(std::move(zabrParams)),
  fdRefinement_(fdRefinement) {
    init(moneyness);
}

template <typename Evaluation>
ZabrSmileSection<Evaluation>::ZabrSmileSection(const Date& d,
                                               Rate forward,
                                               std::vector<Real> zabrParams,
                                               const DayCounter& dc,
                                               const std::vector<Real>& moneyness,
                                               const Size fdRefinement)
: SmileSection(d, dc, Date()), forward_(forward), params_(std::move(zabrParams)),
  fdRefinement_(fdRefinement) {
    init(moneyness);
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init(const std::vector<Real> &,
                                        ZabrShortMaturityLognormal) {

    model_ = ext::make_shared<ZabrModel>(
        exerciseTime(), forward_, params_[0], params_[1],
                      params_[2], params_[3], params_[4]);
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init(const std::vector<Real> &a,
                                        ZabrShortMaturityNormal) {
    init(a, ZabrShortMaturityLognormal());
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init(const std::vector<Real> &moneyness,
                                        ZabrLocalVolatility) {

    QL_REQUIRE(params_.size() >= 5,
               "zabr expects 5 parameters (alpha,beta,nu,rho,gamma) but ("
                   << params_.size() << ") given");

    model_ = ext::make_shared<ZabrModel>(
        exerciseTime(), forward_, params_[0], params_[1],
                      params_[2], params_[3], params_[4]);

    // set up strike grid for local vol or full fd flavour of this section
    // this is shared with SmileSectionUtils - unify later ?
    static const Real defaultMoney[] = {
        0.0, 0.01, 0.05, 0.10, 0.25, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
        1.0, 1.25, 1.5,  1.75, 2.0,  5.0,  7.5,  10.0, 15.0, 20.0};
    std::vector<Real> tmp;
    if (moneyness.empty())
        tmp = std::vector<Real>(defaultMoney, defaultMoney + 21);
    else
        tmp = std::vector<Real>(moneyness);

    strikes_.clear(); // should not be necessary, anyway
    Real lastF = 0.0;
    bool firstStrike = true;
    for (double i : tmp) {
        Real f = i * forward_;
        if (f > 0.0) {
            if (!firstStrike) {
                for (Size j = 1; j <= fdRefinement_; ++j) {
                    strikes_.push_back(lastF +
                                       ((double)j) * (f - lastF) /
                                           (fdRefinement_ + 1));
                }
            }
            firstStrike = false;
            lastF = f;
            strikes_.push_back(f);
        }
    }
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init(const std::vector<Real> &moneyness,
                                        ZabrFullFd) {
    init(moneyness, ZabrLocalVolatility());
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init2(ZabrShortMaturityLognormal) {}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init2(ZabrShortMaturityNormal) {}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init2(ZabrLocalVolatility) {
    callPrices_ = model_->fdPrice(strikes_);
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init2(ZabrFullFd) {
    callPrices_.resize(strikes_.size());
#pragma omp parallel for
    for (long i = 0; i < (long)strikes_.size(); i++) {
        callPrices_[i] = model_->fullFdPrice(strikes_[i]);
    }
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init3(ZabrShortMaturityLognormal) {}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init3(ZabrShortMaturityNormal) {}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init3(ZabrLocalVolatility) {
    strikes_.insert(strikes_.begin(), 0.0);
    callPrices_.insert(callPrices_.begin(), forward_);

    callPriceFct_ = ext::shared_ptr<Interpolation>(new CubicInterpolation(
        strikes_.begin(), strikes_.end(), callPrices_.begin(),
        CubicInterpolation::Spline, true, CubicInterpolation::SecondDerivative,
        0.0, CubicInterpolation::SecondDerivative, 0.0));
    // callPriceFct_ =
    //     ext::shared_ptr<Interpolation>(new LinearInterpolation(
    //         strikes_.begin(), strikes_.end(), callPrices_.begin()));

    callPriceFct_->enableExtrapolation();

    // on the right side we extrapolate exponetially (because spline
    // does not make sense)
    // we precompute the necessary parameters here
    static const Real eps = 1E-5; // gap for first derivative computation

    Real c0 = (*callPriceFct_)(strikes_.back());
    Real c0p = ((*callPriceFct_)(strikes_.back() - eps) - c0) / eps;

    a_ = c0p / c0;
    b_ = std::log(c0) + a_ * strikes_.back();
}

template <typename Evaluation>
void ZabrSmileSection<Evaluation>::init3(ZabrFullFd) {
    init3(ZabrLocalVolatility());
}

template <typename Evaluation>
Real
ZabrSmileSection<Evaluation>::optionPrice(Real strike, Option::Type type,
                                          Real discount,
                                          ZabrShortMaturityLognormal) const {
    return SmileSection::optionPrice(strike, type, discount);
}

template <typename Evaluation>
Real ZabrSmileSection<Evaluation>::optionPrice(Real strike, Option::Type type,
                                               Real discount,
                                               ZabrShortMaturityNormal) const {
    return bachelierBlackFormula(
        type, strike, forward_,
        model_->normalVolatility(strike) * std::sqrt(exerciseTime()), discount);
}

template <typename Evaluation>
Real ZabrSmileSection<Evaluation>::optionPrice(Rate strike, Option::Type type,
                                               Real discount,
                                               ZabrLocalVolatility) const {
    Real call = strike <= strikes_.back() ? (*callPriceFct_)(strike)
                                          : exp(-a_ * strike + b_);
    if (type == Option::Call)
        return call * discount;
    else
        return (call - (forward_ - strike)) * discount;
}

template <typename Evaluation>
Real ZabrSmileSection<Evaluation>::optionPrice(Rate strike, Option::Type type,
                                               Real discount,
                                               ZabrFullFd) const {
    return optionPrice(strike, type, discount, ZabrLocalVolatility());
}

template <typename Evaluation>
Real
ZabrSmileSection<Evaluation>::volatilityImpl(Rate strike,
                                             ZabrShortMaturityLognormal) const {
    strike = std::max(1E-6, strike);
    return model_->lognormalVolatility(strike);
}

template <typename Evaluation>
Real
ZabrSmileSection<Evaluation>::volatilityImpl(Rate strike,
                                             ZabrShortMaturityNormal) const {
    Real impliedVol = 0.0;
    try {
        Option::Type type;
        if (strike >= model_->forward())
            type = Option::Call;
        else
            type = Option::Put;
        impliedVol =
            blackFormulaImpliedStdDev(type, strike, model_->forward(),
                                      optionPrice(strike, type, 1.0), 1.0) /
            std::sqrt(exerciseTime());
    } catch (...) {
    }
    return impliedVol;
}

template <typename Evaluation>
Real ZabrSmileSection<Evaluation>::volatilityImpl(Rate strike,
                                                  ZabrLocalVolatility) const {
    return volatilityImpl(strike, ZabrShortMaturityNormal());
}

template <typename Evaluation>
Real ZabrSmileSection<Evaluation>::volatilityImpl(Rate strike,
                                                  ZabrFullFd) const {
    return volatilityImpl(strike, ZabrShortMaturityNormal());
}
}

#endif
]]></document_content>
  </document>
</documents>