<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>americanoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2005, 2007 StatPro Italia srl
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "americanoption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/baroneadesiwhaleyengine.hpp>
#include <ql/pricingengines/vanilla/bjerksundstenslandengine.hpp>
#include <ql/pricingengines/vanilla/juquadraticengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesshoutengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, \
                       v, expected, calculated, error, tolerance) \
    BOOST_ERROR(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               <<"    spot value:        " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << std::fixed << std::setprecision(4) \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << std::scientific \
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

namespace {

    struct AmericanOptionData {
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // expected result
    };

}


void AmericanOptionTest::testBaroneAdesiWhaleyValues() {

    BOOST_TEST_MESSAGE("Testing Barone-Adesi and Whaley approximation "
                       "for American options...");

    /* The data below are from
       "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
       pag 24

       The following values were replicated only up to the second digit
       by the VB code provided by Haug, which was used as base for the
       C++ implementation

    */
    AmericanOptionData values[] = {
      //        type, strike,   spot,    q,    r,    t,  vol,   value
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.15,  0.0206 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.15,  1.8771 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.15, 10.0089 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.25,  0.3159 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.25,  3.1280 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.25, 10.3919 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.35,  0.9495 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.35,  4.3777 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.35, 11.1679 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.15,  0.8208 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.15,  4.0842 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.15, 10.8087 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.25,  2.7437 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.25,  6.8015 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.25, 13.0170 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.35,  5.0063 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.35,  9.5106 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.35, 15.5689 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.15, 10.0000 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.15,  1.8770 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.15,  0.0410 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.25, 10.2533 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.25,  3.1277 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.25,  0.4562 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.35, 10.8787 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.35,  4.3777 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.35,  1.2402 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.15, 10.5595 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.15,  4.0842 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.15,  1.0822 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.25, 12.4419 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.25,  6.8014 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.25,  3.3226 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.35, 14.6945 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.35,  9.5104 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.35,  5.8823 },
      { Option::Put,  100.00, 100.00, 0.00, 0.00, 0.50, 0.15,  4.2294 }
    };

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 3.0e-3;

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                      new BaroneAdesiWhaleyApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, tolerance);
        }
    }
}


void AmericanOptionTest::testBjerksundStenslandValues() {

    BOOST_TEST_MESSAGE("Testing Bjerksund and Stensland approximation "
                       "for American options...");

    AmericanOptionData values[] = {
        //      type, strike,   spot,    q,    r,    t,  vol,   value, tol
        // from "Option pricing formulas", Haug, McGraw-Hill 1998, pag 27
      { Option::Call,  40.00,  42.00, 0.08, 0.04, 0.75, 0.35,  5.2704 },
        // from "Option pricing formulas", Haug, McGraw-Hill 1998, VBA code
      { Option::Put,   40.00,  36.00, 0.00, 0.06, 1.00, 0.20,  4.4531 },
        // ATM option with very small volatility, reference value taken from R
      { Option::Call, 100, 100, 0.05, 0.05, 1.0, 0.0021, 0.08032314 },
        // ATM option with very small volatility,
        // reference value taken from Barone-Adesi and Whaley Approximation
      { Option::Call, 100, 100, 0.05, 0.05, 1.0, 0.0001, 0.003860656 },
      { Option::Call, 100, 99.99, 0.05, 0.05, 1.0, 0.0001, 0.00081 },
        // ITM option with a very small volatility
      { Option::Call, 100, 110, 0.05, 0.05, 1.0, 0.0001, 10.0 },
      { Option::Put, 110, 100, 0.05, 0.05, 1.0, 0.0001, 10.0 },
        // ATM option with a very large volatility
      { Option::Put, 100, 110, 0.05, 0.05, 1.0, 10, 94.89543 }
    };

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 5.0e-5;

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                     new BjerksundStenslandApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, tolerance);
        }
    }
}

namespace {

    /* The data below are from
       An Approximate Formula for Pricing American Options
       Journal of Derivatives Winter 1999
       Ju, N.
    */
    AmericanOptionData juValues[] = {
        //        type, strike,   spot,    q,    r,    t,     vol,   value, tol
        // These values are from Exhibit 3 - Short dated Put Options
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.0833,  0.2,  0.006 },
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.3333,  0.2,  0.201 },
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.5833,  0.2,  0.433 },

        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.0833,  0.2,  0.851 },
        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.3333,  0.2,  1.576 },
        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.5833,  0.2,  1.984 },

        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.0833,  0.2,  5.000 },
        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.3333,  0.2,  5.084 },
        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.5833,  0.2,  5.260 },

        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.0833,  0.3,  0.078 },
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.3333,  0.3,  0.697 },
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.5833,  0.3,  1.218 },

        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.0833,  0.3,  1.309 },
        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.3333,  0.3,  2.477 },
        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.5833,  0.3,  3.161 },

        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.0833,  0.3,  5.059 },
        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.3333,  0.3,  5.699 },
        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.5833,  0.3,  6.231 },

        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.0833,  0.4,  0.247 },
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.3333,  0.4,  1.344 },
        { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.5833,  0.4,  2.150 },

        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.0833,  0.4,  1.767 },
        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.3333,  0.4,  3.381 },
        { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.5833,  0.4,  4.342 },

        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.0833,  0.4,  5.288 },
        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.3333,  0.4,  6.501 },
        { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.5833,  0.4,  7.367 },

        // Type in Exhibits 4 and 5 if you have some spare time ;-)

        //        type, strike,   spot,    q,    r,    t,     vol,   value, tol
        // values from Exhibit 6 - Long dated Call Options with dividends
        { Option::Call, 100.00,   80.00,  0.07,  0.03, 3.0,  0.2,   2.605 },
        { Option::Call, 100.00,   90.00,  0.07,  0.03, 3.0,  0.2,   5.182 },
        { Option::Call, 100.00,  100.00,  0.07,  0.03, 3.0,  0.2,   9.065 },
        { Option::Call, 100.00,  110.00,  0.07,  0.03, 3.0,  0.2,  14.430 },
        { Option::Call, 100.00,  120.00,  0.07,  0.03, 3.0,  0.2,  21.398 },

        { Option::Call, 100.00,   80.00,  0.07,  0.03, 3.0,  0.4,  11.336 },
        { Option::Call, 100.00,   90.00,  0.07,  0.03, 3.0,  0.4,  15.711 },
        { Option::Call, 100.00,  100.00,  0.07,  0.03, 3.0,  0.4,  20.760 },
        { Option::Call, 100.00,  110.00,  0.07,  0.03, 3.0,  0.4,  26.440 },
        { Option::Call, 100.00,  120.00,  0.07,  0.03, 3.0,  0.4,  32.709 },

        { Option::Call, 100.00,   80.00,  0.07,  0.00001, 3.0,  0.3,   5.552 },
        { Option::Call, 100.00,   90.00,  0.07,  0.00001, 3.0,  0.3,   8.868 },
        { Option::Call, 100.00,  100.00,  0.07,  0.00001, 3.0,  0.3,  13.158 },
        { Option::Call, 100.00,  110.00,  0.07,  0.00001, 3.0,  0.3,  18.458 },
        { Option::Call, 100.00,  120.00,  0.07,  0.00001, 3.0,  0.3,  24.786 },

        { Option::Call, 100.00,   80.00,  0.03,  0.07, 3.0,  0.3,  12.177 },
        { Option::Call, 100.00,   90.00,  0.03,  0.07, 3.0,  0.3,  17.411 },
        { Option::Call, 100.00,  100.00,  0.03,  0.07, 3.0,  0.3,  23.402 },
        { Option::Call, 100.00,  110.00,  0.03,  0.07, 3.0,  0.3,  30.028 },
        { Option::Call, 100.00,  120.00,  0.03,  0.07, 3.0,  0.3,  37.177 }
    };

}


void AmericanOptionTest::testJuValues() {

    BOOST_TEST_MESSAGE("Testing Ju approximation for American options...");

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 1.0e-3;

    for (auto& juValue : juValues) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(juValue.type, juValue.strike));
        Date exDate = today + timeToDays(juValue.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(juValue.s);
        qRate->setValue(juValue.q);
        rRate->setValue(juValue.r);
        vol->setValue(juValue.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                            new JuQuadraticApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - juValue.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, juValue.s, juValue.q, juValue.r, today,
                           juValue.v, juValue.result, calculated, error, tolerance);
        }
    }
}


void AmericanOptionTest::testFdValues() {

    BOOST_TEST_MESSAGE("Testing finite-difference engine "
                       "for American options...");

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 8.0e-2;

    for (auto& juValue : juValues) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(juValue.type, juValue.strike));

        Date exDate = today + timeToDays(juValue.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(juValue.s);
        qRate->setValue(juValue.q);
        rRate->setValue(juValue.r);
        vol->setValue(juValue.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
            ext::make_shared<BlackScholesMertonProcess>(Handle<Quote>(spot),
                                                        Handle<YieldTermStructure>(qTS),
                                                        Handle<YieldTermStructure>(rTS),
                                                        Handle<BlackVolTermStructure>(volTS));

        ext::shared_ptr<PricingEngine> engine =
            ext::make_shared<FdBlackScholesVanillaEngine>(stochProcess, 100, 100);

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - juValue.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, juValue.s, juValue.q, juValue.r, today,
                           juValue.v, juValue.result, calculated, error, tolerance);
        }
    }
}


namespace {

    template <class Engine>
    void testFdGreeks() {

        SavedSettings backup;

        std::map<std::string,Real> calculated, expected, tolerance;
        tolerance["delta"]  = 7.0e-4;
        tolerance["gamma"]  = 2.0e-4;
        //tolerance["theta"]  = 1.0e-4;

        Option::Type types[] = { Option::Call, Option::Put };
        Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
        Real underlyings[] = { 100.0 };
        Rate qRates[] = { 0.04, 0.05, 0.06 };
        Rate rRates[] = { 0.01, 0.05, 0.15 };
        Integer years[] = { 1, 2 };
        Volatility vols[] = { 0.11, 0.50, 1.20 };

        DayCounter dc = Actual360();
        Date today = Date::todaysDate();
        Settings::instance().evaluationDate() = today;

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
        ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
        ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
        ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
        Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

        ext::shared_ptr<StrikedTypePayoff> payoff;

        for (auto& type : types) {
            for (double strike : strikes) {
                for (int year : years) {
                    Date exDate = today + year * Years;
                    ext::shared_ptr<Exercise> exercise(new AmericanExercise(today, exDate));
                    ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));
                    ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                        new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                    ext::shared_ptr<PricingEngine> engine(new Engine(stochProcess, 50));

                    VanillaOption option(payoff, exercise);
                    option.setPricingEngine(engine);

                    for (double u : underlyings) {
                        for (double m : qRates) {
                            for (double n : rRates) {
                                for (double v : vols) {
                                    Rate q = m, r = n;
                                    spot->setValue(u);
                                    qRate->setValue(q);
                                    rRate->setValue(r);
                                    vol->setValue(v);
                                    // FLOATING_POINT_EXCEPTION
                                    Real value = option.NPV();
                                    calculated["delta"] = option.delta();
                                    calculated["gamma"] = option.gamma();
                                    // calculated["theta"]  = option.theta();

                                    if (value > spot->value() * 1.0e-5) {
                                        // perturb spot and get delta and gamma
                                        Real du = u * 1.0e-4;
                                        spot->setValue(u + du);
                                        Real value_p = option.NPV(), delta_p = option.delta();
                                        spot->setValue(u - du);
                                        Real value_m = option.NPV(), delta_m = option.delta();
                                        spot->setValue(u);
                                        expected["delta"] = (value_p - value_m) / (2 * du);
                                        expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                        /*
                                        // perturb date and get theta
                                        Time dT = dc.yearFraction(today-1, today+1);
                                        Settings::instance().setEvaluationDate(today-1);
                                        value_m = option.NPV();
                                        Settings::instance().setEvaluationDate(today+1);
                                        value_p = option.NPV();
                                        Settings::instance().setEvaluationDate(today);
                                        expected["theta"] = (value_p - value_m)/dT;
                                        */

                                        // compare
                                        std::map<std::string, Real>::iterator it;
                                        for (it = calculated.begin(); it != calculated.end();
                                             ++it) {
                                            std::string greek = it->first;
                                            Real expct = expected[greek], calcl = calculated[greek],
                                                 tol = tolerance[greek];
                                            Real error = relativeError(expct, calcl, u);
                                            if (error > tol) {
                                                REPORT_FAILURE(greek, payoff, exercise, u, q, r,
                                                               today, v, expct, calcl, error, tol);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}


void AmericanOptionTest::testFdAmericanGreeks() {
    BOOST_TEST_MESSAGE("Testing finite-differences American option greeks...");
    testFdGreeks<FdBlackScholesVanillaEngine>();
}

void AmericanOptionTest::testFdShoutGreeks() {
    BOOST_TEST_MESSAGE("Testing finite-differences shout option greeks...");
    testFdGreeks<FdBlackScholesShoutEngine>();
}

void AmericanOptionTest::testFDShoutNPV() {
    BOOST_TEST_MESSAGE("Testing finite-differences shout option pricing...");

    SavedSettings backup;

    const auto dc = Actual365Fixed();
    const auto today = Date(4, February, 2021);
    Settings::instance().evaluationDate() = today;

    const auto spot = Handle<Quote>(ext::make_shared<SimpleQuote>(100.0));
    const auto q = Handle<YieldTermStructure>(flatRate(0.03, dc));
    const auto r = Handle<YieldTermStructure>(flatRate(0.06, dc));

    const auto volTS = Handle<BlackVolTermStructure>(flatVol(0.25, dc));
    const auto process = ext::make_shared<BlackScholesMertonProcess>(
            spot, q, r, volTS);

    const auto maturityDate = today + Period(5, Years);

    struct TestDescription { Real strike; Option::Type type; Real expected; };

    const TestDescription testDescriptions[] = {
            {105, Option::Put, 19.136},
            {105, Option::Call, 28.211},
            {120, Option::Put, 28.02},
            {80, Option::Call, 40.785}
    };

    const auto engine = ext::make_shared<FdBlackScholesShoutEngine>(
        process, 400, 200);

    for (const TestDescription& desc: testDescriptions) {
        const Real strike = desc.strike;
        const Option::Type type = desc.type;

        auto option = VanillaOption(
            ext::make_shared<PlainVanillaPayoff>(type, strike),
            ext::make_shared<AmericanExercise>(maturityDate));

        option.setPricingEngine(engine);

        const Real expected = desc.expected;
        const Real tol = 2e-2;
        const Real calculated = option.NPV();
        const Real diff = std::fabs(calculated-expected);

        if (diff > tol) {
            BOOST_FAIL("failed to reproduce known shout option price for "
                    << "\n    strike:     " << strike
                    << "\n    option type:" <<
                        ((type == Option::Call)?"Call" : "Put")
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << "\n    difference: " << diff
                    << "\n    tolerance:  " << tol);
        }
    }
}

void AmericanOptionTest::testZeroVolFDShoutNPV() {
    BOOST_TEST_MESSAGE("Testing zero volatility shout option pricing"
                       " with discrete dividends...");

    SavedSettings backup;

    const auto dc = Actual365Fixed();
    const auto today = Date(14, February, 2021);
    Settings::instance().evaluationDate() = today;

    const auto spot = Handle<Quote>(ext::make_shared<SimpleQuote>(100.0));
    const auto q = Handle<YieldTermStructure>(flatRate(0.03, dc));
    const auto r = Handle<YieldTermStructure>(flatRate(0.07, dc));

    const auto volTS = Handle<BlackVolTermStructure>(flatVol(1e-6, dc));
    const auto process = ext::make_shared<BlackScholesMertonProcess>(
            spot, q, r, volTS);

   const auto maturityDate = today + Period(1, Years);
   const Date dividendDate = today + Period(3, Months);

   DividendVanillaOption option(
       ext::make_shared<PlainVanillaPayoff>(Option::Put, 100.0),
       ext::make_shared<AmericanExercise>(today, maturityDate),
       std::vector<Date>{dividendDate},
       std::vector<Real>{10.0}
   );

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesVanillaEngine>(process, 50, 50));

   const Real americanNPV = option.NPV();

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesShoutEngine>(process, 50, 50));

   const Real shoutNPV = option.NPV();
   const DiscountFactor df = r->discount(maturityDate)/r->discount(dividendDate);

   const Real tol = 1e-3;
   const Real diff = std::fabs(americanNPV - shoutNPV/df);

   if (diff > tol) {
       BOOST_FAIL("failed to reproduce American option NPV with "
               "Shout option pricing engine for "
               << "\n    calculated: " << shoutNPV/df
               << "\n    expected  : " << americanNPV
               << "\n    difference: " << diff
               << "\n    tolerance:  " << tol);
   }
}

void AmericanOptionTest::testLargeDividendShoutNPV() {
    BOOST_TEST_MESSAGE("Testing zero strike shout option pricing"
                       " with discrete dividends...");

    SavedSettings backup;

    const auto dc = Actual365Fixed();
    const auto today = Date(21, February, 2021);
    Settings::instance().evaluationDate() = today;

    const Real s0 = 100.0;
    const Volatility vol = 0.25;

    const auto q = Handle<YieldTermStructure>(flatRate(0.00, dc));
    const auto r = Handle<YieldTermStructure>(flatRate(0.00, dc));
    const auto vTS = Handle<BlackVolTermStructure>(flatVol(vol, dc));

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(s0)), q, r, vTS);

   const auto maturityDate = today + Period(6, Months);
   const Date dividendDate = today + Period(3, Months);
   const Real divAmount = 30.0;

   const Real strike = 80.0;
   DividendVanillaOption divOption(
       ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
       ext::make_shared<AmericanExercise>(today, maturityDate),
       std::vector<Date>{dividendDate},
       std::vector<Real>{divAmount}
   );

   divOption.setPricingEngine(
       ext::make_shared<FdBlackScholesShoutEngine>(process, 100, 400));

   const Real calculated = divOption.NPV();

   VanillaOption option(
       ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
       ext::make_shared<AmericanExercise>(today, dividendDate)
   );

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesShoutEngine>(process, 100, 400));

   const Real expected = option.NPV()
       * r->discount(maturityDate) / r->discount(dividendDate);

   const Real tol = 5e-2;
   const Real diff = std::fabs(expected - calculated);

   if (diff > tol) {
       BOOST_FAIL("failed to reproduce American option NPV with "
               "Shout option pricing engine for "
               << "\n    calculated: " << calculated
               << "\n    expected  : " << expected
               << "\n    difference: " << diff
               << "\n    tolerance:  " << tol);
   }
}

void AmericanOptionTest::testEscrowedVsSpotAmericanOption() {
    BOOST_TEST_MESSAGE("Testing escrowed vs spot dividend model "
            "for American options...");

    SavedSettings backup;

    const auto dc = Actual360();
    const auto today = Date(27, February, 2021);
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.3));

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(100)),
        Handle<YieldTermStructure>(flatRate(0.08, dc)),
        Handle<YieldTermStructure>(flatRate(0.04, dc)),
        Handle<BlackVolTermStructure>(flatVol(vol, dc))
    );

   const auto maturityDate = today + Period(12, Months);
   const Date dividendDate = today + Period(10, Months);
   const Real divAmount = 10.0;

   const Real strike = 100.0;
   DividendVanillaOption option(
       ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
       ext::make_shared<AmericanExercise>(today, maturityDate),
       std::vector<Date>{dividendDate},
       std::vector<Real>{divAmount}
   );

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesVanillaEngine>(process, 100, 400));

   const Real spotNpv = option.NPV();
   const Real spotDelta = option.delta();

   vol->setValue(100/90.*0.3);

   option.setPricingEngine(
       MakeFdBlackScholesVanillaEngine(process)
           .withTGrid(100)
           .withXGrid(400)
           .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed)
    );

   const Real escrowedNpv = option.NPV();
   const Real escrowedDelta = option.delta();

   const Real diffNpv = std::abs(escrowedNpv - spotNpv);
   const Real tol = 1e-2;

   if (diffNpv > tol) {
       BOOST_FAIL("failed to compare American option NPV with "
               "escrowed and spot dividend model "
               << "\n    escrowed div: " << escrowedNpv
               << "\n    spot div    : " << spotNpv
               << "\n    difference: " << diffNpv
               << "\n    tolerance:  " << tol);
   }


   const Real diffDelta = std::abs(escrowedDelta - spotDelta);

   if (diffDelta > tol) {
       BOOST_FAIL("failed to compare American option Delta with "
               "escrowed and spot dividend model "
               << "\n    escrowed div: " << escrowedDelta
               << "\n    spot div    : " << spotDelta
               << "\n    difference: " << diffDelta
               << "\n    tolerance:  " << tol);
   }
}


void AmericanOptionTest::testTodayIsDividendDate() {
    BOOST_TEST_MESSAGE("Testing escrowed vs spot dividend model"
            " on dividend dates for American options...");

    SavedSettings backup;

    const auto dc = Actual360();
    const auto today = Date(27, February, 2021);
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.3));

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(100)),
        Handle<YieldTermStructure>(flatRate(0.05, dc)),
        Handle<YieldTermStructure>(flatRate(0.07, dc)),
        Handle<BlackVolTermStructure>(flatVol(vol, dc))
    );

    const auto maturityDate = today + Period(12, Months);
    const Date divDate1 = today;
    const Date divDate2 = today + Period(11, Months);
    const Real divAmount = 5.0;

    const auto spotEngine =
        ext::make_shared<FdBlackScholesVanillaEngine>(process, 100, 400);

    const auto escrowedEngine =
        MakeFdBlackScholesVanillaEngine(process)
            .withTGrid(100)
            .withXGrid(400)
            .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed);

    const Real strike = 90.0;
    DividendVanillaOption option(
        ext::make_shared<PlainVanillaPayoff>(Option::Put, strike),
        ext::make_shared<AmericanExercise>(today, maturityDate),
        std::vector<Date>{divDate1, divDate2},
        std::vector<Real>{divAmount, divAmount}
    );

    option.setPricingEngine(spotEngine);

    Real spotNpv = option.NPV();
    const Real spotDelta = option.delta();
    BOOST_CHECK_THROW(option.theta(), QuantLib::Error);

    vol->setValue(100/95.*0.3);

    option.setPricingEngine(escrowedEngine);

    Real escrowedNpv = option.NPV();
    const Real escrowedDelta = option.delta();
    BOOST_CHECK_THROW(option.theta(), QuantLib::Error);

    Real diffNpv = std::abs(escrowedNpv - spotNpv);
    Real tol = 5e-2;

    if (diffNpv > tol) {
        BOOST_FAIL("failed to compare American option NPV with "
                "escrowed and spot dividend model "
                << "\n    escrowed div: " << escrowedNpv
                << "\n    spot div    : " << spotNpv
                << "\n    difference: " << diffNpv
                << "\n    tolerance:  " << tol);
    }

    const Real diffDelta = std::abs(escrowedDelta - spotDelta);

    tol = 1e-3;
    if (diffDelta > tol) {
        BOOST_FAIL("failed to compare American option Delta with "
                "escrowed and spot dividend model "
                << "\n    escrowed div: " << escrowedDelta
                << "\n    spot div    : " << spotDelta
                << "\n    difference: " << diffDelta
                << "\n    tolerance:  " << tol);
    }

    DividendVanillaOption optionTomorrow(
        ext::make_shared<PlainVanillaPayoff>(Option::Put, strike),
        ext::make_shared<AmericanExercise>(today, maturityDate),
        std::vector<Date>{today + Period(1, Days), divDate2},
        std::vector<Real>{divAmount, divAmount}
    );

    vol->setValue(0.3);

    optionTomorrow.setPricingEngine(spotEngine);
    spotNpv = optionTomorrow.NPV();

    vol->setValue(100/95.0*0.3);
    optionTomorrow.setPricingEngine(escrowedEngine);

    escrowedNpv = optionTomorrow.NPV();
    BOOST_CHECK_NO_THROW(optionTomorrow.theta());

    diffNpv = std::abs(escrowedNpv - spotNpv);
    tol = 5e-2;

    if (diffNpv > tol) {
        BOOST_FAIL("failed to compare American option NPV with "
                "escrowed and spot dividend model "
                << "\n    escrowed div: " << escrowedNpv
                << "\n    spot div    : " << spotNpv
                << "\n    difference: " << diffNpv
                << "\n    tolerance:  " << tol);
    }
}

test_suite* AmericanOptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("American option tests");

    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testBaroneAdesiWhaleyValues));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testBjerksundStenslandValues));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testJuValues));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testFdValues));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testFdAmericanGreeks));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testFDShoutNPV));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testZeroVolFDShoutNPV));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testLargeDividendShoutNPV));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testEscrowedVsSpotAmericanOption));
    suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testTodayIsDividendDate));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&AmericanOptionTest::testFdShoutGreeks));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="2">
    <source>americanoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2005 Joseph Wang
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_american_option_hpp
#define quantlib_test_american_option_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class AmericanOptionTest {
  public:
    static void testBaroneAdesiWhaleyValues();
    static void testBjerksundStenslandValues();
    static void testJuValues();
    static void testFdValues();
    static void testFdAmericanGreeks();
    static void testFdShoutGreeks();
    static void testFDShoutNPV();
    static void testZeroVolFDShoutNPV();
    static void testLargeDividendShoutNPV();
    static void testEscrowedVsSpotAmericanOption();
    static void testTodayIsDividendDate();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>amortizingbond.cpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2014 Cheng Li

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "amortizingbond.hpp"
#include "utilities.hpp"
#include <ql/experimental/amortizingbonds/amortizingfixedratebond.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/settings.hpp>
#include <ql/time/calendars/brazil.hpp>
#include <ql/time/daycounters/business252.hpp>
#include <iostream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void AmortizingBondTest::testAmortizingFixedRateBond() {
	BOOST_TEST_MESSAGE("Testing amortizing fixed rate bond...");

	/*
	* Following data is generated from Excel using function pmt with Nper = 360, PV = 100.0 
	*/

	Real rates[] = {0.0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12};
	Real amounts[] = {0.277777778, 0.321639520, 0.369619473, 0.421604034,
		              0.477415295, 0.536821623, 0.599550525, 
		              0.665302495, 0.733764574, 0.804622617,
		              0.877571570, 0.952323396, 1.028612597};

	Frequency freq = Monthly;

	Date refDate = Settings::instance().evaluationDate();

	const Real tolerance = 1.0e-6;

	for(Size i=0; i<LENGTH(rates); ++i) {

		AmortizingFixedRateBond
			myBond(0, NullCalendar(), 100.0, refDate, Period(30, Years), freq, rates[i], ActualActual(ActualActual::ISMA));

		Leg cashflows = myBond.cashflows();

		std::vector<Real> notionals = myBond.notionals();

		for(Size k=0; k < cashflows.size() / 2; ++k) {
			Real coupon = cashflows[2*k]->amount();
			Real principal = cashflows[2*k+1]->amount();
			Real totalAmount = coupon + principal;

			// Check the amount is same as pmt returned

			Real error = std::fabs(totalAmount-amounts[i]);
			if (error > tolerance) {
				BOOST_ERROR("\n" <<
					        " Rate: " << rates[i] <<
							" " << k << "th cash flow " 
							" Failed!" <<
							" Expected Amount: " << amounts[i] <<
							" Calculated Amount: " << totalAmount);
			}

			// Check the coupon result
			Real expectedCoupon = notionals[k] * rates[i] / freq;
			error = std::fabs(coupon- expectedCoupon);

			if(error > tolerance) {
				BOOST_ERROR("\n" <<
					" Rate: " << rates[i] <<
					" " << k << "th cash flow " 
					" Failed!" <<
					" Expected Coupon: " << expectedCoupon <<
					" Calculated Coupon: " << coupon);
			}

		}
	}
}

void AmortizingBondTest::testBrazilianAmortizingFixedRateBond() {
	BOOST_TEST_MESSAGE("Testing Brazilian amortizing fixed rate bond...");

	/*
	* Following data is based on the following Brazilian onshore corporate bond code:
	* SND Code - RISF11
	* ISIN Code - BRRISFDBS005
	* Fiduciary Agent URL - https://www.pentagonotrustee.com.br/Site/DetalhesEmissor?ativo=RISF11&aba=tab-5&tipo=undefined
	*/

	static const Real arr[] = {
		1000		, 983.33300000, 966.66648898, 950.00019204,
		933.33338867, 916.66685434, 900.00001759, 883.33291726,
		866.66619177, 849.99933423, 833.33254728, 816.66589633,
		799.99937871, 783.33299165, 766.66601558, 749.99946306,
		733.33297499, 716.66651646, 699.99971995, 683.33272661,
		666.66624140, 649.99958536, 633.33294599, 616.66615618,
		599.99951997, 583.33273330, 566.66633377, 549.99954356,
		533.33290739, 516.66625403, 499.99963400, 483.33314619,
		466.66636930, 449.99984658, 433.33320226, 416.66634063,
		399.99968700, 383.33290004, 366.66635221, 349.99953317,
		333.33290539, 316.66626012, 299.99948151, 283.33271031,
		266.66594695, 249.99932526, 233.33262024, 216.66590450,
		199.99931312, 183.33277035, 166.66617153, 149.99955437,
		133.33295388, 116.66633464,  99.99973207,  83.33307672,
		 66.66646137,  49.99984602,  33.33324734,  16.66662367
	};
	std::vector<Real> notionals (arr, arr + sizeof(arr) / sizeof(arr[0]) );

	Real expected_amortizations[] = {
		16.66700000, 16.66651102, 16.66629694, 16.66680337,
		16.66653432, 16.66683675, 16.66710033, 16.66672548,
		16.66685753, 16.66678695, 16.66665095, 16.66651761,
		16.66638706, 16.66697606, 16.66655251, 16.66648807,
		16.66645852, 16.66679651, 16.66699333, 16.66648520,
		16.66665604, 16.66663937, 16.66678981, 16.66663620,
		16.66678667, 16.66639952, 16.66679021, 16.66663617,
		16.66665336, 16.66662002, 16.66648780, 16.66677688,
		16.66652271, 16.66664432, 16.66686163, 16.66665363,
		16.66678696, 16.66654783, 16.66681904, 16.66662777,
		16.66664527, 16.66677860, 16.66677119, 16.66676335,
		16.66662168, 16.66670502, 16.66671573, 16.66659137,
		16.66654276, 16.66659882, 16.66661715, 16.66660049,
		16.66661924, 16.66660257, 16.66665534, 16.66661534,
		16.66661534, 16.66659867, 16.66662367, 16.66662367
	};

	Real expected_coupons[] = {
		5.97950399, 4.85474255, 5.27619136, 5.18522454,
		5.33753111, 5.24221882, 4.91231709, 4.59116258,
		4.73037674, 4.63940686, 4.54843737, 3.81920094,
		4.78359948, 3.86733691, 4.38439657, 4.09359456,
		4.00262671, 4.28531030, 3.82068947, 3.55165259,
		3.46502778, 3.71720657, 3.62189368, 2.88388676,
		3.58769952, 2.72800044, 3.38838360, 3.00196900,
		2.91100034, 3.08940793, 2.59877059, 2.63809514,
		2.42551945, 2.45615766, 2.59111761, 1.94857222,
		2.28751141, 1.79268582, 2.19248291, 1.81913832,
		1.90625855, 1.89350716, 1.48110584, 1.62031828,
		1.38600825, 1.23425366, 1.39521333, 1.06968563,
		1.03950542, 1.00065409, 0.90968563, 0.81871706,
		0.79726493, 0.63678002, 0.57187676, 0.49829046,
		0.32913418, 0.27290565, 0.19062560, 0.08662552
	};

	Natural settlementDays = 0;
	Date issueDate(2, March, 2020);
	Date maturityDate(2, March, 2025);

	Schedule schedule(issueDate,
						maturityDate,
						Period(Monthly),
						Brazil(Brazil::Settlement),
						Unadjusted,
						Unadjusted,
						DateGeneration::Backward,
						false);

	std::vector<InterestRate> couponRates(1);
	couponRates[0] = InterestRate(0.0675,
						Business252(Brazil()),
						Compounded, Annual);

	AmortizingFixedRateBond risf11(
			settlementDays,
			notionals,
			schedule,
			couponRates,
			Following,
			issueDate,
			Brazil(Brazil::Settlement)
			);

	const Real tolerance = 1.0e-6;
	Real error;
	Leg cashflows = risf11.cashflows();
	for(Size k=0; k < cashflows.size() / 2; ++k) {
		error = std::fabs(expected_coupons[k]- cashflows[2*k]->amount());
		if(error > tolerance) {
			BOOST_ERROR("\n" <<
				" " << k << "th cash flow " 
				" Failed!" <<
				" Expected Coupon: " << expected_coupons[k] <<
				" Calculated Coupon: " << cashflows[2*k]->amount());
		}

		error = std::fabs(expected_amortizations[k]- cashflows[2*k+1]->amount());
		if(error > tolerance) {
			BOOST_ERROR("\n" <<
				" " << k << "th cash flow " 
				" Failed!" <<
				" Expected Amortization: " << expected_amortizations[k] <<
				" Calculated Amortization: " << cashflows[2*k+1]->amount());
		}

	}

}

test_suite* AmortizingBondTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Amortizing Bond tests");
    suite->add(QUANTLIB_TEST_CASE(&AmortizingBondTest::testAmortizingFixedRateBond));
    suite->add(QUANTLIB_TEST_CASE(&AmortizingBondTest::testBrazilianAmortizingFixedRateBond));
    return suite;
}
]]></document_content>
  </document>
  <document index="4">
    <source>amortizingbond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Cheng Li

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_amortizing_bond_hpp
#define quantlib_test_amortizing_bond_hpp

#include <boost/test/unit_test.hpp>

class AmortizingBondTest {
  public:
    static void testAmortizingFixedRateBond();
    static void testBrazilianAmortizingFixedRateBond();
	static boost::unit_test_framework::test_suite* suite();

};

#endif
]]></document_content>
  </document>
  <document index="5">
    <source>andreasenhugevolatilityinterpl.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017, 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "andreasenhugevolatilityinterpl.hpp"
#include "utilities.hpp"
#include <ql/math/comparison.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/interpolations/sabrinterpolation.hpp>
#include <ql/math/optimization/bfgs.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/barrier/fdblackscholesbarrierengine.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/volatility/equityfx/hestonblackvolsurface.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugelocalvoladapter.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugevolatilityinterpl.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugevolatilityadapter.hpp>
#include <cmath>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace andreasen_huge_volatility_interpl_test {

    struct CalibrationData {
        const Handle<Quote> spot;
        Handle<YieldTermStructure> rTS, qTS;
        AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;
    };

    struct CalibrationResults {
        AndreasenHugeVolatilityInterpl::CalibrationType calibrationType;
        AndreasenHugeVolatilityInterpl::InterpolationType interpolationType;

        Real maxError, avgError;
        Real lvMaxError, lvAvgError;
    };

    CalibrationData AndreasenHugeExampleData() {
        // This is the example market data from the original paper
        // Andreasen J., Huge B., 2010. Volatility Interpolation
        // https://ssrn.com/abstract=1694972

        const Handle<Quote> spot(ext::make_shared<SimpleQuote>(2772.7));

        const Time maturityTimes[] = {
                  0.025, 0.101, 0.197, 0.274, 0.523, 0.772,
                  1.769, 2.267, 2.784, 3.781, 4.778, 5.774
            };

        const Real raw[][13] = {
            { 0.5131, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.3366, 0.3291, 0.0000, 0.0000 },
            { 0.5864, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.3178, 0.3129, 0.3008, 0.0000 },
            { 0.6597, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.3019, 0.2976, 0.2975, 0.0000 },
            { 0.7330, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.2863, 0.2848, 0.2848, 0.0000 },
            { 0.7697, 0.0000, 0.0000, 0.0000, 0.3262, 0.3079, 0.3001, 0.2843, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.8063, 0.0000, 0.0000, 0.0000, 0.3058, 0.2936, 0.2876, 0.2753, 0.2713, 0.2711, 0.2711, 0.2722, 0.2809 },
            { 0.8430, 0.0000, 0.0000, 0.0000, 0.2887, 0.2798, 0.2750, 0.2666, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.8613, 0.3365, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.8796, 0.3216, 0.2906, 0.2764, 0.2717, 0.2663, 0.2637, 0.2575, 0.2555, 0.2580, 0.2585, 0.2611, 0.2693 },
            { 0.8979, 0.3043, 0.2797, 0.2672, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.9163, 0.2880, 0.2690, 0.2578, 0.2557, 0.2531, 0.2519, 0.2497, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.9346, 0.2724, 0.2590, 0.2489, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.9529, 0.2586, 0.2488, 0.2405, 0.2407, 0.2404, 0.2411, 0.2418, 0.2410, 0.2448, 0.2469, 0.2501, 0.2584 },
            { 0.9712, 0.2466, 0.2390, 0.2329, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 0.9896, 0.2358, 0.2300, 0.2253, 0.2269, 0.2284, 0.2299, 0.2347, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.0079, 0.2247, 0.2213, 0.2184, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.0262, 0.2159, 0.2140, 0.2123, 0.2142, 0.2173, 0.2198, 0.2283, 0.2275, 0.2322, 0.2384, 0.2392, 0.2486 },
            { 1.0445, 0.2091, 0.2076, 0.2069, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.0629, 0.2056, 0.2024, 0.2025, 0.2039, 0.2074, 0.2104, 0.2213, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.0812, 0.2045, 0.1982, 0.1984, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.0995, 0.2025, 0.1959, 0.1944, 0.1962, 0.1988, 0.2022, 0.2151, 0.2161, 0.2219, 0.2269, 0.2305, 0.2399 },
            { 1.1178, 0.1933, 0.1929, 0.1920, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.1362, 0.0000, 0.0000, 0.0000, 0.1902, 0.1914, 0.1950, 0.2091, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.1728, 0.0000, 0.0000, 0.0000, 0.1885, 0.1854, 0.1888, 0.2039, 0.2058, 0.2122, 0.2186, 0.2223, 0.2321 },
            { 1.2095, 0.0000, 0.0000, 0.0000, 0.1867, 0.1811, 0.1839, 0.1990, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 },
            { 1.2461, 0.0000, 0.0000, 0.0000, 0.1871, 0.1785, 0.1793, 0.1945, 0.0000, 0.2054, 0.2103, 0.2164, 0.2251 },
            { 1.3194, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1988, 0.2054, 0.2105, 0.2190 },
            { 1.3927, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1930, 0.2002, 0.2054, 0.2135 },
            { 1.4660, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1849, 0.1964, 0.2012, 0.0000 }
        };

        const DayCounter dc = Actual365Fixed();
        const Date today = Date(1, March, 2010);

        const Handle<YieldTermStructure> rTS(flatRate(today, 0.0, dc));
        const Handle<YieldTermStructure> qTS(flatRate(today, 0.0, dc));

        const Size nStrikes = LENGTH(raw);
        const Size nMaturities = LENGTH(maturityTimes);

        QL_REQUIRE(nMaturities == LENGTH(raw[1])-1, "check raw data");

        AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;

        calibrationSet.reserve(std::count_if(
            &raw[0][0], &raw[nStrikes-1][nMaturities]+1,
            not_zero<Real>()) - nStrikes);

        for (const auto & i : raw) {
            const Real strike = spot->value()*i[0];

            for (Size j=1; j < LENGTH(i); ++j) {
                if (i[j] > QL_EPSILON) {
                    const Date maturity
                        = today + Period(Size(365*maturityTimes[j-1]), Days);

                    const Volatility impliedVol = i[j];

                    calibrationSet.push_back(std::make_pair(
                        ext::make_shared<VanillaOption>(
                            ext::make_shared<PlainVanillaPayoff>(
                                (strike < spot->value())? Option::Put
                                                        : Option::Call,
                                strike),
                            ext::make_shared<EuropeanExercise>(maturity)),
                        ext::make_shared<SimpleQuote>(impliedVol))
                    );
                }
            }
        }

        return { spot, rTS, qTS, calibrationSet };
    }

    void testAndreasenHugeVolatilityInterpolation(
        const CalibrationData& data, const CalibrationResults& expected) {

        SavedSettings backup;

        const Handle<YieldTermStructure> rTS = data.rTS;
        const Handle<YieldTermStructure> qTS = data.qTS;

        const DayCounter dc = rTS->dayCounter();
        const Date today = rTS->referenceDate();
        Settings::instance().evaluationDate() = today;

        const Handle<Quote> spot = data.spot;

        AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet =
            data.calibrationSet;

        const ext::shared_ptr<AndreasenHugeVolatilityInterpl>
            andreasenHugeVolInterplation(
                ext::make_shared<AndreasenHugeVolatilityInterpl>(
                    calibrationSet, spot, rTS, qTS,
                    expected.interpolationType,
                    expected.calibrationType));

        const ext::tuple<Real, Real, Real> error =
            andreasenHugeVolInterplation->calibrationError();

        const Real maxError = ext::get<1>(error);
        const Real avgError = ext::get<2>(error);

        if (maxError > expected.maxError || avgError > expected.avgError) {
            BOOST_FAIL("Failed to reproduce calibration error"
                       << "\n    max calibration error:     " << maxError
                       << "\n    average calibration error: " << avgError
                       << "\n    expected max error:        " << expected.maxError
                       << "\n    expected average error:    " << expected.avgError);
        }

        const ext::shared_ptr<AndreasenHugeVolatilityAdapter> volatilityAdapter(
            ext::make_shared<AndreasenHugeVolatilityAdapter>(
                andreasenHugeVolInterplation, 1e-12));

        const ext::shared_ptr<AndreasenHugeLocalVolAdapter> localVolAdapter(
            ext::make_shared<AndreasenHugeLocalVolAdapter>(
                andreasenHugeVolInterplation));

        const ext::shared_ptr<GeneralizedBlackScholesProcess> localVolProcess(
            ext::make_shared<GeneralizedBlackScholesProcess>(
                spot, qTS, rTS,
                Handle<BlackVolTermStructure>(volatilityAdapter),
                Handle<LocalVolTermStructure>(localVolAdapter)));

        Real lvAvgError = 0.0, lvMaxError = 0.0;
        for (Size i=0, n=0; i < calibrationSet.size(); ++i) {

            const ext::shared_ptr<VanillaOption> option =
                calibrationSet[i].first;

            const ext::shared_ptr<PlainVanillaPayoff> payoff =
                ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                    option->payoff());
            const Real strike = payoff->strike();
            const Option::Type optionType = payoff->optionType();

            const Time t = dc.yearFraction(today, option->exercise()->lastDate());

            const Volatility expectedVol = calibrationSet[i].second->value();
            const Volatility calculatedVol =
                volatilityAdapter->blackVol(t, strike, true);

            const Real diffVol = std::fabs(expectedVol - calculatedVol);
            const Real tol = std::max(1e-10, 1.01*maxError);

            if (diffVol > tol) {
                BOOST_FAIL("Failed to reproduce calibration option price"
                           << "\n    calculated: " << calculatedVol
                           << "\n    expected:   " << expectedVol
                           << "\n    difference: " << diffVol
                           << "\n    tolerance:  " << tol);
            }

            const ext::shared_ptr<PricingEngine> fdEngine(
                ext::make_shared<FdBlackScholesVanillaEngine>(
                    localVolProcess, std::max<Size>(30, Size(100*t)),
                    200, 0, FdmSchemeDesc::Douglas(), true));

            option->setPricingEngine(fdEngine);

            const DiscountFactor discount = rTS->discount(t);
            const Real fwd = spot->value()*qTS->discount(t)/discount;

            const Volatility lvImpliedVol = blackFormulaImpliedStdDevLiRS(
                optionType, strike, fwd, option->NPV(),
                discount, 0.0, Null<Real>(), 1.0, 1e-12)/std::sqrt(t);

            const Real lvError = std::fabs(lvImpliedVol - expectedVol);

            lvMaxError = std::max(lvError, lvMaxError);

            lvAvgError = (n*lvAvgError + lvError)/(n+1);

            ++n;
        }

        if (lvMaxError > expected.lvMaxError || avgError > expected.lvAvgError) {
            BOOST_FAIL("Failed to reproduce local volatility calibration error"
                       << "\n    max calibration error:     " << lvMaxError
                       << "\n    average calibration error: " << lvAvgError
                       << "\n    expected max error:        " << expected.lvMaxError
                       << "\n    expected average error:    " << expected.lvAvgError);
        }
    }


    CalibrationData BorovkovaExampleData() {
        // see Svetlana Borovkova, Ferry J. Permana
        // Implied volatility in oil markets
        // http://www.researchgate.net/publication/46493859_Implied_volatility_in_oil_markets

        const DayCounter dc = Actual365Fixed();
        const Date today = Date(4, January, 2018);

        const Handle<YieldTermStructure> rTS(flatRate(today, 0.025, dc));
        const Handle<YieldTermStructure> qTS(flatRate(today, 0.085, dc));

        Handle<Quote> spot(ext::make_shared<SimpleQuote>(100));

        const Real b1 = 0.35;
        const Real b2 = 0.03;
        const Real b3 = 0.005;
        const Real b4 = -0.02;
        const Real b5 = -0.005;

        const Real strikes[] = { 35, 50, 75, 100, 125, 150, 200, 300 };
        const Size maturityMonths[] = { 1, 3, 6, 9, 12, 15, 18, 24};

        AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;

        for (double strike : strikes) {
            for (unsigned long maturityMonth : maturityMonths) {
                const Date maturityDate = today + Period(maturityMonth, Months);
                const Time t = dc.yearFraction(today, maturityDate);

                const Real fwd = spot->value()*qTS->discount(t)/rTS->discount(t);
                const Real mn = std::log(fwd/strike)/std::sqrt(t);

                const Volatility vol = b1 + b2*mn + b3*mn*mn + b4*t + b5*mn*t;

                if (std::fabs(mn) < 3.71*vol) {

                    calibrationSet.push_back(std::make_pair(
                        ext::make_shared<VanillaOption>(
                            ext::make_shared<PlainVanillaPayoff>(
                                Option::Call, strike),
                            ext::make_shared<EuropeanExercise>(maturityDate)),
                        ext::make_shared<SimpleQuote>(vol)));
                }
            }
        }

        CalibrationData data = { spot, rTS, qTS, calibrationSet };

        return data;
    }


    CalibrationData arbitrageData() {

        const DayCounter dc = Actual365Fixed();
        const Date today = Date(4, January, 2018);

        const Handle<YieldTermStructure> rTS(flatRate(today, 0.13, dc));
        const Handle<YieldTermStructure> qTS(flatRate(today, 0.03, dc));

        Handle<Quote> spot(ext::make_shared<SimpleQuote>(100));

        const Real strikes[] = { 100, 100, 100, 150 };
        const Size maturities[] = { 1, 3, 6, 6 };
        const Volatility vols[] = { 0.25, 0.35, 0.05, 0.35 };
        AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;

        for (Size i=0; i < LENGTH(strikes); ++i) {
            const Real strike = strikes[i];
            const Date maturityDate = today + Period(maturities[i], Months);
            const Volatility vol = vols[i];

            calibrationSet.push_back(std::make_pair(
                ext::make_shared<VanillaOption>(
                    ext::make_shared<PlainVanillaPayoff>(
                        Option::Call, strike),
                    ext::make_shared<EuropeanExercise>(maturityDate)),
                ext::make_shared<SimpleQuote>(vol)));
        }

        return { spot, rTS, qTS, calibrationSet };
    }
}


void AndreasenHugeVolatilityInterplTest::testAndreasenHugePut() {

    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge example with Put calibration...");

    using namespace andreasen_huge_volatility_interpl_test;

    const CalibrationData data = AndreasenHugeExampleData();

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::Put,
        AndreasenHugeVolatilityInterpl::CubicSpline,
        0.0015, 0.00035,
        0.0020, 0.00035
    };

    testAndreasenHugeVolatilityInterpolation(data, expected);
}

void AndreasenHugeVolatilityInterplTest::testAndreasenHugeCall() {

    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge example with Call calibration...");

    using namespace andreasen_huge_volatility_interpl_test;

    const CalibrationData data = AndreasenHugeExampleData();

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::Call,
        AndreasenHugeVolatilityInterpl::CubicSpline,
        0.0015, 0.00035,
        0.0015, 0.00035
    };

    testAndreasenHugeVolatilityInterpolation(data, expected);
}

void AndreasenHugeVolatilityInterplTest::testAndreasenHugeCallPut() {

    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge example with instantaneous "
         "Call and Put calibration...");

    using namespace andreasen_huge_volatility_interpl_test;

    const CalibrationData data = AndreasenHugeExampleData();

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::CallPut,
        AndreasenHugeVolatilityInterpl::CubicSpline,
        0.0015, 0.00035,
        0.0015, 0.00035
    };

    testAndreasenHugeVolatilityInterpolation(data, expected);
}

void AndreasenHugeVolatilityInterplTest::testLinearInterpolation() {
    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge example with linear interpolation...");

    using namespace andreasen_huge_volatility_interpl_test;

    const CalibrationData data = AndreasenHugeExampleData();

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::CallPut,
        AndreasenHugeVolatilityInterpl::Linear,
        0.0020, 0.00015,
        0.0040, 0.00035
    };

    testAndreasenHugeVolatilityInterpolation(data, expected);
}

void AndreasenHugeVolatilityInterplTest::testPiecewiseConstantInterpolation() {
    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge example with piecewise constant interpolation...");

    using namespace andreasen_huge_volatility_interpl_test;

    const CalibrationData data = AndreasenHugeExampleData();

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::CallPut,
        AndreasenHugeVolatilityInterpl::PiecewiseConstant,
        0.0025, 0.00025,
        0.0040, 0.00035
    };

    testAndreasenHugeVolatilityInterpolation(data, expected);
}

void AndreasenHugeVolatilityInterplTest::testTimeDependentInterestRates() {

    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge volatility interpolation with "
        "time dependent interest rates and dividend yield...");

    using namespace andreasen_huge_volatility_interpl_test;

    SavedSettings backup;

    const CalibrationData data = AndreasenHugeExampleData();

    const DayCounter dc = data.rTS->dayCounter();
    const Date today = data.rTS->referenceDate();
    Settings::instance().evaluationDate() = today;

    std::vector<Real> r = { 0.0167, 0.023, 0.03234, 0.034, 0.038, 0.042, 0.047, 0.053 };
    std::vector<Real> q = { 0.01, 0.011, 0.013, 0.014, 0.02, 0.025, 0.067, 0.072 };

    std::vector<Date> dates = {
        today,
        today + Period(41, Days),
        today + Period(75, Days),
        today + Period(165, Days),
        today + Period(256, Days),
        today + Period(345, Days),
        today + Period(524, Days),
        today + Period(2190, Days)
    };

    const Handle<YieldTermStructure> rTS(
        ext::make_shared<ZeroCurve>(dates, r, dc));
    const Handle<YieldTermStructure> qTS(
        ext::make_shared<ZeroCurve>(dates, q, dc));

    const CalibrationData origData = AndreasenHugeExampleData();
    AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet =
        origData.calibrationSet;

    const Handle<Quote> spot = origData.spot;

    const ext::shared_ptr<HestonModel> hestonModel(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                rTS, qTS, spot, 0.09, 2.0, 0.09, 0.4, -0.75)));

    const ext::shared_ptr<PricingEngine> hestonEngine(
        ext::make_shared<AnalyticHestonEngine>(
            hestonModel,
            AnalyticHestonEngine::AndersenPiterbarg,
            AnalyticHestonEngine::Integration::discreteTrapezoid(128)));

    for (auto& i : calibrationSet) {
        const ext::shared_ptr<VanillaOption> option = i.first;

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(option->payoff());

        const Real strike = payoff->strike();
        const Option::Type optionType = payoff->optionType();

        const Time t = dc.yearFraction(today, option->exercise()->lastDate());

        const DiscountFactor discount = rTS->discount(t);
        const Real fwd = spot->value()*qTS->discount(t)/discount;

        option->setPricingEngine(hestonEngine);
        const Real npv = option->NPV();

        const Volatility impliedVol = blackFormulaImpliedStdDevLiRS(
            optionType, strike, fwd, npv,
            discount, 0.0, Null<Real>(), 1.0, 1e-12)/std::sqrt(t);

        i.second = ext::make_shared<SimpleQuote>(impliedVol);
    }

    CalibrationData irData = { spot, rTS, qTS, calibrationSet };

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::CallPut,
        AndreasenHugeVolatilityInterpl::CubicSpline,
        0.0020, 0.0003,
        0.0020, 0.0004
    };

    testAndreasenHugeVolatilityInterpolation(irData, expected);
}

void AndreasenHugeVolatilityInterplTest::testSingleOptionCalibration() {
    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge volatility interpolation with "
        "a single option...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(4, January, 2018);

    const Handle<YieldTermStructure> rTS(flatRate(today, 0.025, dc));
    const Handle<YieldTermStructure> qTS(flatRate(today, 0.085, dc));

    AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;

    const Real strike = 10.0;
    const Volatility vol = 0.3;
    const Date maturity = today + Period(1, Years);
    Handle<Quote> spot(ext::make_shared<SimpleQuote>(strike));

    calibrationSet.push_back(std::make_pair(
        ext::make_shared<VanillaOption>(
            ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
            ext::make_shared<EuropeanExercise>(maturity)),
        ext::make_shared<SimpleQuote>(vol)));

    const AndreasenHugeVolatilityInterpl::InterpolationType interpl[] = {
        AndreasenHugeVolatilityInterpl::Linear,
        AndreasenHugeVolatilityInterpl::CubicSpline,
        AndreasenHugeVolatilityInterpl::PiecewiseConstant
    };

    const AndreasenHugeVolatilityInterpl::CalibrationType calibrationType[] = {
        AndreasenHugeVolatilityInterpl::Put,
        AndreasenHugeVolatilityInterpl::Call,
        AndreasenHugeVolatilityInterpl::CallPut
    };

    for (auto i : interpl)
        for (auto j : calibrationType) {
            const ext::shared_ptr<AndreasenHugeVolatilityInterpl> andreasenHugeVolInterplation(
                ext::make_shared<AndreasenHugeVolatilityInterpl>(calibrationSet, spot, rTS, qTS, i,
                                                                 j, 50));

            const ext::shared_ptr<AndreasenHugeVolatilityAdapter>
                volatilityAdapter =
                    ext::make_shared<AndreasenHugeVolatilityAdapter>(
                        andreasenHugeVolInterplation);

            const Volatility calculated =
                volatilityAdapter->blackVol(maturity, strike);
            const Volatility expected = vol;

            if (std::fabs(calculated - expected) > 1e-4) {
                BOOST_FAIL("Failed to reproduce single option calibration"
                           << "\n    calculated: " << calculated
                           << "\n    expected:   " << expected);
            }
        }
}

void AndreasenHugeVolatilityInterplTest::testArbitrageFree() {
    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge volatility interpolation gives "
        "arbitrage free prices...");

    using namespace andreasen_huge_volatility_interpl_test;

    SavedSettings backup;

    CalibrationData data[] = { BorovkovaExampleData(), arbitrageData() };;

    for (auto& i : data) {
        const Handle<Quote>& spot = i.spot;
        const AndreasenHugeVolatilityInterpl::CalibrationSet& calibrationSet = i.calibrationSet;

        const Handle<YieldTermStructure>& rTS = i.rTS;
        const Handle<YieldTermStructure>& qTS = i.qTS;

        const DayCounter dc = rTS->dayCounter();
        const Date today = rTS->referenceDate();

        const ext::shared_ptr<AndreasenHugeVolatilityInterpl>
            andreasenHugeVolInterplation(
                ext::make_shared<AndreasenHugeVolatilityInterpl>(
                    calibrationSet, spot, rTS, qTS,
                    AndreasenHugeVolatilityInterpl::CubicSpline,
                    AndreasenHugeVolatilityInterpl::CallPut, 5000));

        const ext::shared_ptr<AndreasenHugeVolatilityAdapter> volatilityAdapter(
            ext::make_shared<AndreasenHugeVolatilityAdapter>(
                andreasenHugeVolInterplation));

        for (Real m = -0.7; m < 0.7; m+=0.05) {

            for (Size weeks=6; weeks < 52; ++weeks) {
                const Date maturityDate = today + Period(weeks, Weeks);

                const Time t = dc.yearFraction(today, maturityDate);

                const Real fwd = spot->value()*qTS->discount(t)/rTS->discount(t);

                // J. Gatheral, Arbitrage-free SVI volatility surfaces
                // http://mfe.baruch.cuny.edu/wp-content/uploads/2013/01/OsakaSVI2012.pdf
                const Real eps = 0.025;
                const Real k  = fwd*std::exp(m);
                const Real km = fwd*std::exp(m - eps);
                const Real kp = fwd*std::exp(m + eps);

                const Real w =
                    volatilityAdapter->blackVariance(t, k, true);
                const Real w_p =
                    volatilityAdapter->blackVariance(t, kp, true);
                const Real w_m =
                    volatilityAdapter->blackVariance(t, km, true);

                const Real w1 = (w_p - w_m)/(2*eps);
                const Real w2 = (w_p + w_m - 2*w)/(eps*eps);

                const Real g_k = square<Real>()(1-m*w1/(2*w))
                    - w1*w1/4*(1/w + 0.25) + 0.5*w2;

                if (g_k < 0) {
                    BOOST_FAIL("No-arbitrage condition g_k >= 0 failed"
                               << "\n    strike:  " << k
                               << "\n    forward: " << fwd
                               << "\n    time:    " << t
                               << "\n    g_k:    " << g_k);
                }

                const Real deltaT = 1.0/365.;
                const Real fwdpt = spot->value()*
                    qTS->discount(t+deltaT)/rTS->discount(t+deltaT);

                const Real kpt = fwdpt*std::exp(m);
                const Real w_pt =
                    volatilityAdapter->blackVariance(t+deltaT, kpt, true);

                const Real w_t = (w_pt - w)/deltaT;
                if (w_t < -1e-8) {
                    BOOST_FAIL("No-arbitrage condition w_t >= 0 failed"
                               << "\n    strike:  " << k
                               << "\n    forward: " << fwd
                               << "\n    time:    " << t
                               << "\n    w        " << w
                               << "\n    w_t:     " << w_t);
                }
            }
        }
    }
}

void AndreasenHugeVolatilityInterplTest::testBarrierOptionPricing() {
    BOOST_TEST_MESSAGE(
        "Testing Barrier option pricing with Andreasen-Huge "
         "local volatility surface...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(4, January, 2018);

    const Handle<YieldTermStructure> rTS(flatRate(today, 0.01, dc));
    const Handle<YieldTermStructure> qTS(flatRate(today, 0.03, dc));

    Handle<Quote> spot(ext::make_shared<SimpleQuote>(100));
    const ext::shared_ptr<HestonModel> hestonModel(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                rTS, qTS, spot, 0.04, 2.0, 0.04, 0.4, -0.75)));

    const ext::shared_ptr<BlackVolTermStructure> hestonVol =
        ext::make_shared<HestonBlackVolSurface>(
            Handle<HestonModel>(hestonModel));

    const ext::shared_ptr<GeneralizedBlackScholesProcess>
        dupireLocalVolProcess =
            ext::make_shared<GeneralizedBlackScholesProcess>(
                spot, qTS, rTS, Handle<BlackVolTermStructure>(hestonVol));

    const Real strikes[] = { 25, 50, 75, 90, 100, 110, 125, 150, 200, 400};
    const Size maturityMonths[] = { 1, 3, 6, 9, 12};

    AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;

    for (double strike : strikes) {
        for (unsigned long maturityMonth : maturityMonths) {
            const Date maturityDate = today + Period(maturityMonth, Months);
            const Time t = dc.yearFraction(today, maturityDate);

            const Volatility vol = hestonVol->blackVol(t, strike);

            const Real mn = std::log(spot->value()/strike)/std::sqrt(t);

            if (std::fabs(mn) < 3.07*vol) {
                calibrationSet.push_back(std::make_pair(
                    ext::make_shared<VanillaOption>(
                        ext::make_shared<PlainVanillaPayoff>(
                            Option::Call, strike),
                        ext::make_shared<EuropeanExercise>(maturityDate)),
                    ext::make_shared<SimpleQuote>(vol)));
            }
        }
    }

    const ext::shared_ptr<AndreasenHugeVolatilityInterpl>
        andreasenHugeVolInterplation(
            ext::make_shared<AndreasenHugeVolatilityInterpl>(
                calibrationSet, spot, rTS, qTS));

    const ext::shared_ptr<AndreasenHugeLocalVolAdapter> localVolAdapter(
        ext::make_shared<AndreasenHugeLocalVolAdapter>(
            andreasenHugeVolInterplation));

    const ext::shared_ptr<GeneralizedBlackScholesProcess>
        andreasenHugeLocalVolProcess =
            ext::make_shared<GeneralizedBlackScholesProcess>(
                spot, qTS, rTS,
                Handle<BlackVolTermStructure>(hestonVol),
                Handle<LocalVolTermStructure>(localVolAdapter));

    const Real strike = 120.0;
    const Real barrier=  80.0;
    const Real rebate =   0.0;
    const Date maturity = today + Period(1, Years);
    const Barrier::Type barrierType = Barrier::DownOut;

    BarrierOption barrierOption(barrierType, barrier, rebate,
        ext::make_shared<PlainVanillaPayoff>(Option::Put, strike),
        ext::make_shared<EuropeanExercise>(maturity));

    barrierOption.setPricingEngine(
        ext::make_shared<FdBlackScholesBarrierEngine>(
            dupireLocalVolProcess, 50, 100, 0,
            FdmSchemeDesc::Douglas(), true, 0.2));

    const Real dupireNPV = barrierOption.NPV();

    barrierOption.setPricingEngine(
        ext::make_shared<FdBlackScholesBarrierEngine>(
            andreasenHugeLocalVolProcess, 200, 400, 0,
            FdmSchemeDesc::Douglas(), true, 0.25));

    const Real andreasenHugeNPV = barrierOption.NPV();

    const Real tol = 0.15;
    const Real diff = std::fabs(andreasenHugeNPV - dupireNPV);

    if (diff > tol) {
        BOOST_FAIL("failed to reproduce barrier prices with Andreasen-Huge "
                "local volatility surface"
                   << "\n    Andreasen-Huge price: " << andreasenHugeNPV
                   << "\n    Dupire formula price: " << dupireNPV
                   << "\n    diff:                 " << diff
                   << "\n    tolerance:            " << tol);
    }
}

namespace andreasen_huge_volatility_interpl_test {
    std::pair<CalibrationData, std::vector<Real> > sabrData() {

        const DayCounter dc = Actual365Fixed();
        const Date today = Date(4, January, 2018);

        const Real alpha = 0.15;
        const Real beta = 0.8;
        const Real nu = 0.5;
        const Real rho = -0.48;
        const Real forward = 0.03;
        const Size maturityInYears = 20;

        const Date maturityDate = today + Period(maturityInYears, Years);
        const Time maturity = dc.yearFraction(today, maturityDate);

        AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;

        const Real strikes[] = { 0.02, 0.025, 0.03, 0.035, 0.04, 0.05, 0.06 };

        for (double strike : strikes) {
            const Volatility vol = sabrVolatility(strike, forward, maturity, alpha, beta, nu, rho);

            calibrationSet.push_back(std::make_pair(
                ext::make_shared<VanillaOption>(
                    ext::make_shared<PlainVanillaPayoff>(
                        Option::Call, strike),
                    ext::make_shared<EuropeanExercise>(maturityDate)),
                ext::make_shared<SimpleQuote>(vol)));
        }

        const Handle<YieldTermStructure> rTS(flatRate(today, forward, dc));
        const Handle<YieldTermStructure> qTS(flatRate(today, forward, dc));

        Handle<Quote> spot(ext::make_shared<SimpleQuote>(forward));

        const CalibrationData data = { spot, rTS, qTS, calibrationSet};

        std::vector<Real> parameter = { alpha, beta, nu, rho, forward, maturity };

        return std::make_pair(data, parameter);
    }
}

void AndreasenHugeVolatilityInterplTest::testPeterAndFabiensExample() {
    BOOST_TEST_MESSAGE(
        "Testing Peter's and Fabien's SABR example...");

    // http://chasethedevil.github.io/post/andreasen-huge-extrapolation/

    using namespace andreasen_huge_volatility_interpl_test;

    SavedSettings backup;

    const std::pair<CalibrationData, std::vector<Real> > sd = sabrData();
    const CalibrationData& data = sd.first;
    const std::vector<Real>& parameter = sd.second;

    const ext::shared_ptr<AndreasenHugeVolatilityInterpl>
        andreasenHugeVolInterplation(
            ext::make_shared<AndreasenHugeVolatilityInterpl>(
                data.calibrationSet, data.spot, data.rTS, data.qTS));

    const ext::shared_ptr<AndreasenHugeVolatilityAdapter> volAdapter(
        ext::make_shared<AndreasenHugeVolatilityAdapter>(
            andreasenHugeVolInterplation));

    const Real alpha    = parameter[0];
    const Real beta     = parameter[1];
    const Real nu       = parameter[2];
    const Real rho      = parameter[3];
    const Real forward  = parameter[4];
    const Time maturity = parameter[5];

    for (Real strike = 0.02; strike < 0.06; strike+=0.001) {
        const Volatility sabrVol = sabrVolatility(
           strike, forward, maturity, alpha, beta, nu, rho);

        const Volatility ahVol = volAdapter->blackVol(maturity, strike, true);

        const Real tol = 0.0005;
        const Real diff = std::fabs(sabrVol - ahVol);

        if (std::isnan(ahVol) || diff > 0.005) {
            BOOST_FAIL("failed to reproduce SABR volatility with "
                    "Andreasen-Huge interpolation"
                   << "\n    Andreasen-Huge vol: " << ahVol
                   << "\n    SABR volatility:    " << sabrVol
                   << "\n    diff:               " << diff
                   << "\n    tolerance:          " << tol);
        }
    }
}

void AndreasenHugeVolatilityInterplTest::testDifferentOptimizers() {
    BOOST_TEST_MESSAGE(
        "Testing different optimizer for Andreasen-Huge "
        "volatility interpolation...");

    using namespace andreasen_huge_volatility_interpl_test;

    const CalibrationData& data = sabrData().first;

    const ext::shared_ptr<OptimizationMethod> optimizationMethods[] = {
        ext::make_shared<LevenbergMarquardt>(),
        ext::make_shared<BFGS>(),
        ext::make_shared<Simplex>(0.2)
    };

    for (const auto& optimizationMethod : optimizationMethods) {
        const Real avgError = ext::get<2>(
            AndreasenHugeVolatilityInterpl(data.calibrationSet, data.spot, data.rTS, data.qTS,
                                           AndreasenHugeVolatilityInterpl::CubicSpline,
                                           AndreasenHugeVolatilityInterpl::Call, 400, Null<Real>(),
                                           Null<Real>(), optimizationMethod)
                .calibrationError());

        if (std::isnan(avgError) || avgError > 0.0001) {
            BOOST_FAIL("failed to calibrate Andreasen-Huge "
                    "volatility interpolation with different optimizera"
                   << "\n    calibration error: " << avgError);
        }
    }
}

void AndreasenHugeVolatilityInterplTest::testMovingReferenceDate() {
    BOOST_TEST_MESSAGE(
        "Testing that reference date of adapter surface moves along with "
        "evaluation date...");

    SavedSettings backup;

    const Date today = Date(4, January, 2018);
    Settings::instance().evaluationDate() = today;

    const DayCounter dc = Actual365Fixed();
    const Date maturity = today + Period(1, Months);

    Handle<YieldTermStructure> ts(flatRate(0.04, dc));

    const Real s0 = 100.0;
    const Volatility impliedVol = 0.2;
    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));

    AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet(
        1,
        std::make_pair(
            ext::make_shared<VanillaOption>(
                ext::make_shared<PlainVanillaPayoff>(Option::Call, s0),
                ext::make_shared<EuropeanExercise>(maturity)),
            ext::make_shared<SimpleQuote>(impliedVol))
    );

    const ext::shared_ptr<AndreasenHugeVolatilityInterpl>
        andreasenHugeVolInterplation(
            ext::make_shared<AndreasenHugeVolatilityInterpl>(
                calibrationSet, spot, ts, ts));


    const Real tol = 1e-8;
    const ext::shared_ptr<AndreasenHugeVolatilityAdapter> volatilityAdapter(
        ext::make_shared<AndreasenHugeVolatilityAdapter>(
            andreasenHugeVolInterplation, tol));

    const ext::shared_ptr<AndreasenHugeLocalVolAdapter> localVolAdapter(
        ext::make_shared<AndreasenHugeLocalVolAdapter>(
            andreasenHugeVolInterplation));

    const Date volRefDate = volatilityAdapter->referenceDate();
    const Date localRefDate = localVolAdapter->referenceDate();

    if (volRefDate != today || localRefDate != today)
        BOOST_FAIL("reference dates should match today's date"
               << "\n    today                     : " << today
               << "\n    local vol reference date  : " << localRefDate
               << "\n    implied vol reference date: " << volRefDate);

    const Date modToday = Date(15, January, 2018);
    Settings::instance().evaluationDate() = modToday;

    const Date modVolRefDate = volatilityAdapter->referenceDate();
    const Date modLocalRefDate = localVolAdapter->referenceDate();

    if (modVolRefDate != modToday || modLocalRefDate != modToday)
        BOOST_FAIL("reference dates should match modified today's date"
               << "\n    today                     : " << modToday
               << "\n    local vol reference date  : " << modLocalRefDate
               << "\n    implied vol reference date: " << modVolRefDate);

    // test update method
    const Volatility modImpliedVol =
        volatilityAdapter->blackVol(maturity, s0, true);

    const Real diff = std::fabs(modImpliedVol - impliedVol);
    if (diff > 10*tol)
        BOOST_FAIL("modified implied vol should match direct calculation"
                << "\n    implied vol         : " << impliedVol
                << "\n    modified implied vol: " << modImpliedVol
                << "\n    difference          : " << diff
                << "\n    tolerance           : " << tol);
}

void AndreasenHugeVolatilityInterplTest::testFlatVolCalibration() {
    BOOST_TEST_MESSAGE(
        "Testing Andreasen-Huge example with flat volatility surface...");

    using namespace andreasen_huge_volatility_interpl_test;

    SavedSettings backup;

    const Date ref(1, November, 2019);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = ref;

    const Date expiries[] = {
        ref + 1 * Months, ref + 3 * Months, ref + 6 * Months,
        ref + 9 * Months, ref + 1 * Years,  ref + 2 * Years,
        ref + 3 * Years,  ref + 4 * Years,  ref + 5 * Years,
        ref + 7 * Years,  ref + 10 * Years
    };

    const Real moneyness[] = {
        0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5
    };

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(100.0));
    const Handle<YieldTermStructure> rTS(flatRate(ref, 0.02, dc));
    const Handle<YieldTermStructure> qTS(flatRate(ref, 0.0, dc));
    const ext::shared_ptr<Quote> vol = ext::make_shared<SimpleQuote>(0.18);

    AndreasenHugeVolatilityInterpl::CalibrationSet calibrationSet;
    for (auto expiry : expiries) {

        const ext::shared_ptr<Exercise> exercise = ext::make_shared<EuropeanExercise>(expiry);

        const Time t = rTS->timeFromReference(expiry);
        const Real fwd = spot->value() / rTS->discount(t) * qTS->discount(t);

        for (double m : moneyness) {
            const Real strike = fwd * m;
            const Real mn = std::log(fwd/strike)/std::sqrt(t);

            if (std::fabs(mn) < 3.72*vol->value()) {
                const ext::shared_ptr<VanillaOption> option
                    = ext::make_shared<VanillaOption>(
                          ext::make_shared<PlainVanillaPayoff>(
                              (strike>fwd)? Option::Call : Option::Put, strike),
                          exercise);

                calibrationSet.push_back(std::make_pair(option, vol));
            }
        }
    }

    CalibrationData flatVolData = { spot, rTS, qTS, calibrationSet };

    const CalibrationResults expected = {
        AndreasenHugeVolatilityInterpl::Put,
        AndreasenHugeVolatilityInterpl::CubicSpline,
        1e-10, 1e-10,
        0.0006, 0.0002
    };

    testAndreasenHugeVolatilityInterpolation(flatVolData, expected);
}


test_suite* AndreasenHugeVolatilityInterplTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Andreasen-Huge volatility interpolation tests");

    suite->add(QUANTLIB_TEST_CASE(
        &AndreasenHugeVolatilityInterplTest::testSingleOptionCalibration));
    suite->add(QUANTLIB_TEST_CASE(
        &AndreasenHugeVolatilityInterplTest::testArbitrageFree));
    suite->add(QUANTLIB_TEST_CASE(
        &AndreasenHugeVolatilityInterplTest::testPeterAndFabiensExample));
    suite->add(QUANTLIB_TEST_CASE(
        &AndreasenHugeVolatilityInterplTest::testDifferentOptimizers));
    suite->add(QUANTLIB_TEST_CASE(
        &AndreasenHugeVolatilityInterplTest::testMovingReferenceDate));
    suite->add(QUANTLIB_TEST_CASE(
        &AndreasenHugeVolatilityInterplTest::testFlatVolCalibration));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testAndreasenHugePut));
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testAndreasenHugeCall));
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testAndreasenHugeCallPut));
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testLinearInterpolation));
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testPiecewiseConstantInterpolation));
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testBarrierOptionPricing));
        suite->add(QUANTLIB_TEST_CASE(
            &AndreasenHugeVolatilityInterplTest::testTimeDependentInterestRates));
    }
    return suite;
}

]]></document_content>
  </document>
  <document index="6">
    <source>andreasenhugevolatilityinterpl.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017, 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_local_volatility_hpp
#define quantlib_test_local_volatility_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class AndreasenHugeVolatilityInterplTest {
  public:
    static void testAndreasenHugePut();
    static void testAndreasenHugeCall();
    static void testAndreasenHugeCallPut();
    static void testLinearInterpolation();
    static void testPiecewiseConstantInterpolation();
    static void testTimeDependentInterestRates();
    static void testSingleOptionCalibration();
    static void testArbitrageFree();
    static void testBarrierOptionPricing();
    static void testPeterAndFabiensExample();
    static void testDifferentOptimizers();
    static void testMovingReferenceDate();
    static void testFlatVolCalibration();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel speed);
};


#endif
]]></document_content>
  </document>
  <document index="7">
    <source>array.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "array.hpp"
#include "utilities.hpp"
#include <ql/math/array.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace array_test {
    class FSquared {
      public:
        Real operator()(Real x) const { return x*x; }
    };
}

void ArrayTest::testConstruction() {

    BOOST_TEST_MESSAGE("Testing array construction...");

    using namespace array_test;

    // empty array
    Array a1;
    if (!a1.empty())
        BOOST_ERROR("default-initialized array is not empty "
                    "(size = " << a1.size() << ")");

    // sized array
    Size size = 5;
    Array a2(size);
    if (a2.size() != size)
        BOOST_ERROR("array not of the required size"
                    << "\n    required:  " << size
                    << "\n    resulting: " << a2.size());

    // sized array, constant values
    Real value = 42.0;
    Array a3(size, value);
    if (a3.size() != size)
        BOOST_ERROR("array not of the required size"
                    << "\n    required:  " << size
                    << "\n    resulting: " << a3.size());
    Size i;
    for (i=0; i<size; ++i) {
        if (a3[i] != value)
            BOOST_ERROR(io::ordinal(i+1) << " element not with required value"
                        << "\n    required:  " << value
                        << "\n    resulting: " << a3[i]);
    }

    // sized array, incremental values
    Real increment = 3.0;
    Array a4(size, value, increment);
    if (a4.size() != size)
        BOOST_ERROR("array not of the required size"
                    << "\n    required:  " << size
                    << "\n    resulting: " << a4.size());
    for (i=0; i<size; i++) {
        if (a4[i] != value + i*increment)
            BOOST_ERROR(io::ordinal(i+1) << " element not with required value"
                        << "\n    required:  " << value + i*increment
                        << "\n    resulting: " << a4[i]);
    }

    // copy constructor
    Array a5(a1);  // NOLINT(performance-unnecessary-copy-initialization)
    if (a5.size() != a1.size())
        BOOST_ERROR("copy not of the same size as original"
                    << "\n    original:  " << a1.size()
                    << "\n    copy:      " << a5.size());

    Array a6(a3);
    if (a6.size() != a3.size())
        BOOST_ERROR("copy not of the same size as original"
                    << "\n    original:  " << a3.size()
                    << "\n    copy:      " << a6.size());
    for (i=0; i<a3.size(); i++) {
        if (a6[i] != a3[i])
            BOOST_ERROR(io::ordinal(i+1) << " element of copy "
                        "not with same value as original"
                        << "\n    original:  " << a3[i]
                        << "\n    copy:      " << a6[i]);
    }

    #ifdef QL_USE_DISPOSABLE

    // creation of disposable array
    Array temp1(size, value);
    Disposable<Array> temp2(temp1);
    if (temp2.size() != size || !temp1.empty())
        BOOST_ERROR("array not correctly moved into disposable array"
                    << "\n    original size of source: " << size
                    << "\n    current size of source:  " << temp1.size()
                    << "\n    current size of target:  " << temp2.size());
    for (i=0; i<size; i++) {
        if (temp2[i] != value)
            BOOST_ERROR(io::ordinal(i+1) << " element of disposable "
                        "not moved correctly"
                        << "\n    required:  " << value
                        << "\n    resulting: " << temp2[i]);
    }

    // copy constructor from disposable
    Array a7(temp2);
    if (a7.size() != size || !temp2.empty())
        BOOST_ERROR("disposable array not correctly moved into array"
                    << "\n    original size of source: " << size
                    << "\n    current size of source:  " << temp2.size()
                    << "\n    current size of target:  " << a7.size());
    for (i=0; i<size; i++) {
        if (a7[i] != value)
            BOOST_ERROR(io::ordinal(i+1) << " element not moved correctly"
                        << "\n    required:  " << value
                        << "\n    resulting: " << a7[i]);
    }

    // assignment
    Array a8;
    a8 = a7;
    if (a8.size() != a7.size())
        BOOST_ERROR("copy not of the same size as original"
                    << "\n    original:  " << a7.size()
                    << "\n    copy:      " << a8.size());
    for (i=0; i<a7.size(); i++) {
        if (a8[i] != a7[i])
            BOOST_ERROR(io::ordinal(i+1) << " element of copy "
                        "not with same value as original"
                        << "\n    original:  " << a7[i]
                        << "\n    copy:      " << a8[i]);
    }

    // assignment from disposable
    Array temp3(size, value);
    Disposable<Array> temp4(temp3);
    Array a9;
    a9 = temp4;
    if (a9.size() != size || !temp4.empty())
        BOOST_ERROR("disposable array not correctly moved into array"
                    << "\n    original size of source: " << size
                    << "\n    current size of source:  " << temp4.size()
                    << "\n    current size of target:  " << a9.size());
    for (i=0; i<size; i++) {
        if (a9[i] != value)
            BOOST_ERROR(io::ordinal(i+1) << " element not moved correctly"
                        << "\n    required:  " << value
                        << "\n    resulting: " << a9[i]);
    }

    #endif

    // transform
    Array a10(5);
    for (i=0; i < a10.size(); i++) {
        a10[i] = static_cast<Real>(i);
    }
    FSquared f2;
    std::transform(a10.begin(), a10.end(), a10.begin(), FSquared());
    for (i=0; i < a10.size(); i++) {
        Real calculated = f2(static_cast<Real>(i));
        if (std::fabs(a10[i] -  calculated) >= 1e-5) {
            BOOST_ERROR("Array transform test failed " << a10[i] << " "
                        << calculated);
        }
    }
}

void ArrayTest::testArrayFunctions() {

    BOOST_TEST_MESSAGE("Testing array functions...");

    Array a(5);
    for (Size i=0; i < a.size(); ++i) {
        a[i] = std::sin(Real(i))+1.1;
    }

    const Real exponential = -2.3;
    const Array p = Pow(a, exponential);
    const Array e = Exp(a);
    const Array l = Log(a);
    const Array s = Sqrt(a);

    const Real tol = 10*QL_EPSILON;
    for (Size i=0; i < a.size(); ++i) {
        if (std::fabs(p[i]-std::pow(a[i], exponential)) > tol) {
            BOOST_FAIL("Array function test Pow failed");
        }
        if (std::fabs(e[i]-std::exp(a[i])) > tol) {
            BOOST_FAIL("Array function test Exp failed");
        }
        if (std::fabs(l[i]-std::log(a[i])) > tol) {
            BOOST_FAIL("Array function test Log failed");
        }
        if (std::fabs(s[i]-std::sqrt(a[i])) > tol) {
            BOOST_FAIL("Array function test Sqrt failed");
        }
    }
}

void ArrayTest::testArrayResize() {
    BOOST_TEST_MESSAGE("Testing array resize...");

    Array a(10,1.0,1.0);

    for (Size i=0; i < 10; ++i)
        BOOST_CHECK_CLOSE(a[i], Real(1+i), 10*QL_EPSILON);

    a.resize(5);
    BOOST_CHECK(a.size() == 5);

    for (Size i=0; i < 5; ++i)
        BOOST_CHECK_CLOSE(a[i], Real(1+i), 10*QL_EPSILON);

    a.resize(15);
    BOOST_CHECK(a.size() == 15);

    for (Size i=0; i < 5; ++i)
        BOOST_CHECK_CLOSE(a[i], Real(1+i), 10*QL_EPSILON);

    const Array::const_iterator iter = a.begin();
    a.resize(a.size());
    BOOST_CHECK(iter == a.begin());

    a.resize(10);
    BOOST_CHECK(a.size() == 10);
    BOOST_CHECK(iter == a.begin());
}


test_suite* ArrayTest::suite() {
    auto* suite = BOOST_TEST_SUITE("array tests");
    suite->add(QUANTLIB_TEST_CASE(&ArrayTest::testConstruction));
    suite->add(QUANTLIB_TEST_CASE(&ArrayTest::testArrayFunctions));
    suite->add(QUANTLIB_TEST_CASE(&ArrayTest::testArrayResize));
    return suite;
}

]]></document_content>
  </document>
  <document index="8">
    <source>array.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_array_hpp
#define quantlib_test_array_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ArrayTest {
  public:
    static void testConstruction();
    static void testArrayFunctions();
    static void testArrayResize();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>asianoptions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2008, 2017 StatPro Italia srl
 Copyright (C) 2009 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_asian_options_hpp
#define quantlib_test_asian_options_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class AsianOptionTest {
  public:
    static void testAnalyticContinuousGeometricAveragePrice();
    static void testAnalyticContinuousGeometricAveragePriceGreeks();
    static void testAnalyticContinuousGeometricAveragePriceHeston();
    static void testAnalyticDiscreteGeometricAveragePrice();
    static void testAnalyticDiscreteGeometricAveragePriceHeston();
    static void testAnalyticDiscreteGeometricAverageStrike();
    static void testDiscreteGeometricAveragePriceHestonPastFixings();
    static void testMCDiscreteGeometricAveragePrice();
    static void testMCDiscreteGeometricAveragePriceHeston();
    static void testMCDiscreteArithmeticAveragePrice();
    static void testMCDiscreteArithmeticAveragePriceHeston();
    static void testMCDiscreteArithmeticAverageStrike();
    static void testAnalyticDiscreteGeometricAveragePriceGreeks();
    static void testPastFixings();
    static void testAllFixingsInThePast();
    static void testLevyEngine();
    static void testVecerEngine();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
    static boost::unit_test_framework::test_suite* experimental(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>assetswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_assetswap_hpp
#define quantlib_test_assetswap_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class AssetSwapTest {
  public:
    static void testConsistency();
    static void testImpliedValue();
    static void testMarketASWSpread();
    static void testZSpread();
    static void testGenericBondImplied();
    static void testMASWWithGenericBond();
    static void testZSpreadWithGenericBond();
    static void testSpecializedBondVsGenericBond();
    static void testSpecializedBondVsGenericBondUsingAsw();
    static  boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="11">
    <source>autocovariances.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "autocovariances.hpp"
#include "utilities.hpp"
#include <ql/math/autocovariance.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using namespace std;

void AutocovariancesTest::testConvolutions() {
    BOOST_TEST_MESSAGE("Testing convolutions...");
    Array x(10, 1, 1);
    Array conv(6);
    convolutions(x.begin(), x.end(), conv.begin(), 5);
    Real expected[] = { 385, 330, 276, 224, 175, 130 };
    Array delta = conv - Array(expected, expected+6);
    if (DotProduct(delta, delta) > 1.0e-6)
        BOOST_ERROR("Convolution: \n"
                    << std::setprecision(4) << std::scientific
                    << "    calculated:   " << conv << "\n"
                    << "    expected:     " << Array(expected, expected+6));
}

void AutocovariancesTest::testAutoCovariances() {
    BOOST_TEST_MESSAGE("Testing auto-covariances...");
    Array x(10, 1, 1);
    Array acovf(6);
    Real mean = autocovariances(x.begin(), x.end(), acovf.begin(), 5, false);
    Real expected[] = { 8.25, 6.416667, 4.25, 1.75, -1.08333, -4.25 };
    if (std::fabs(mean-5.5) > 1.0e-6) {
        BOOST_ERROR("Mean: \n"
                    << "    calculated:   " << mean << "\n"
                    << "    expected:     " << 5.5);
    }
    Array delta = acovf - Array(expected, expected+6);
    if (DotProduct(delta, delta) > 1.0e-6)
        BOOST_ERROR("Autocovariances: \n"
                    << std::setprecision(4) << std::scientific
                    << "    calculated:   " << acovf << "\n"
                    << "    expected:     " << Array(expected, expected+6));
}

void AutocovariancesTest::testAutoCorrelations() {
    BOOST_TEST_MESSAGE("Testing auto-correlations...");
    Array x(10, 1, 1);
    Array acorf(6);
    Real mean = autocorrelations(x.begin(), x.end(), acorf.begin(), 5, true);
    Real expected[] = { 9.166667, 0.77777778, 0.51515152,
                        0.21212121, -0.13131313, -0.51515152 };
    if (std::fabs(mean-5.5) > 1.0e-6) {
        BOOST_ERROR("Mean: \n"
                    << "    calculated:   " << mean << "\n"
                    << "    expected:     " << 5.5);
    }
    Array delta = acorf - Array(expected, expected+6);
    if (DotProduct(delta, delta) > 1.0e-6)
        BOOST_ERROR("Autocovariances: \n"
                    << std::setprecision(4) << std::scientific
                    << "    calculated:   " << acorf << "\n"
                    << "    expected:     " << Array(expected, expected+6));
    delta = x - Array(10, -4.5, 1);
    if (DotProduct(delta, delta) > 1.0e-6)
        BOOST_ERROR("Centering: \n"
                    << std::setprecision(4) << std::scientific
                    << "    calculated:   " << x << "\n"
                    << "    expected:     " << Array(10, -4.5, 1));
}

test_suite* AutocovariancesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("auto-covariance tests");
    suite->add(QUANTLIB_TEST_CASE(&AutocovariancesTest::testConvolutions));
    suite->add(QUANTLIB_TEST_CASE(&AutocovariancesTest::testAutoCovariances));
    suite->add(QUANTLIB_TEST_CASE(&AutocovariancesTest::testAutoCorrelations));
    return suite;
}

]]></document_content>
  </document>
  <document index="12">
    <source>autocovariances.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_autocovariances_hpp
#define quantlib_test_autocovariances_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class AutocovariancesTest {
  public:
    static void testConvolutions();
    static void testAutoCovariances();
    static void testAutoCorrelations();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="13">
    <source>barrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_barrier_option_hpp
#define quantlib_test_barrier_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BarrierOptionTest {
  public:
    static void testParity();
    static void testHaugValues();
    static void testBabsiriValues();
    static void testBeagleholeValues();
    static void testPerturbative();
    static void testLocalVolAndHestonComparison();
    static void testVannaVolgaSimpleBarrierValues();
    static void testVannaVolgaDoubleBarrierValues();
    static void testDividendBarrierOption();

    static boost::unit_test_framework::test_suite* suite();
    static boost::unit_test_framework::test_suite* experimental();
};


#endif
]]></document_content>
  </document>
  <document index="14">
    <source>basismodels.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Sebastian Schlenkrich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "basismodels.hpp"
#include "utilities.hpp"
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/compounding.hpp>
#include <ql/experimental/basismodels/swaptioncfs.hpp>
#include <ql/experimental/basismodels/tenoroptionletvts.hpp>
#include <ql/experimental/basismodels/tenorswaptionvts.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionlet.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionletadapter.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolmatrix.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    // auxiliary data
    Period termsData[] = {
        Period(0, Days),   Period(1, Years), Period(2, Years),  Period(3, Years),
        Period(5, Years),  Period(7, Years), Period(10, Years), Period(15, Years),
        Period(20, Years), Period(61, Years) // avoid extrapolation issues with 30y caplets
    };
    std::vector<Period> terms(termsData, termsData + 10);

    Real discRatesData[] = {-0.00147407, -0.001761684, -0.001736745, -0.00119244, 0.000896055,
                            0.003537077, 0.007213824,  0.011391278,  0.013334611, 0.013982809};
    std::vector<Real> discRates(discRatesData, discRatesData + 10);

    Real proj3mRatesData[] = {-0.000483439, -0.000578569, -0.000383832, 0.000272656, 0.002478699,
                              0.005100113,  0.008750643,  0.012788095,  0.014534052, 0.014942896};
    std::vector<Real> proj3mRates(proj3mRatesData, proj3mRatesData + 10);

    Real proj6mRatesData[] = {0.000233608, 0.000218862, 0.000504018, 0.001240556, 0.003554415,
                              0.006153921, 0.009688264, 0.013521628, 0.015136391, 0.015377704};
    std::vector<Real> proj6mRates(proj6mRatesData, proj6mRatesData + 10);

    Handle<YieldTermStructure> getYTS(const std::vector<Period>& terms,
                                      const std::vector<Real>& rates,
                                      const Real spread = 0.0) {
        Date today = Settings::instance().evaluationDate();
        std::vector<Date> dates;
        dates.reserve(terms.size());
        for (auto term : terms)
            dates.push_back(NullCalendar().advance(today, term, Unadjusted));
        std::vector<Real> ratesPlusSpread(rates);
        for (double& k : ratesPlusSpread)
            k += spread;
        ext::shared_ptr<YieldTermStructure> ts =
            ext::shared_ptr<YieldTermStructure>(new InterpolatedZeroCurve<Cubic>(
                dates, ratesPlusSpread, Actual365Fixed(), NullCalendar()));
        return RelinkableHandle<YieldTermStructure>(ts);
    }

    Period capletTermsData[] = {Period(1, Years),  Period(2, Years),  Period(3, Years),
                                Period(5, Years),  Period(7, Years),  Period(10, Years),
                                Period(15, Years), Period(20, Years), Period(25, Years),
                                Period(30, Years)};
    std::vector<Period> capletTerms(capletTermsData, capletTermsData + 10);

    Real capletStrikesData[] = {-0.0050, 0.0000, 0.0050, 0.0100, 0.0150, 0.0200, 0.0300, 0.0500};
    std::vector<Real> capletStrikes(capletStrikesData, capletStrikesData + 8);


    Handle<OptionletVolatilityStructure> getOptionletTS() {
        Date today = Settings::instance().evaluationDate();
        std::vector<Date> dates;
        dates.reserve(capletTerms.size());
        for (auto& capletTerm : capletTerms)
            dates.push_back(TARGET().advance(today, capletTerm, Following));
        // set up vol data manually
        std::vector<std::vector<Real> > capletVols =
        {
         {0.003010094, 0.002628065, 0.00456118,  0.006731268, 0.008678572, 0.010570881, 0.014149552, 0.021000638},
         {0.004173715, 0.003727039, 0.004180263, 0.005726083, 0.006905876, 0.008263514, 0.010555395, 0.014976523},
         {0.005870143, 0.005334526, 0.005599775, 0.006633987, 0.007773317, 0.009036581, 0.011474391, 0.016277549},
         {0.007458597, 0.007207522, 0.007263995, 0.007308727, 0.007813586, 0.008274858, 0.009743988, 0.012555171},
         {0.007711531, 0.007608826, 0.007572816, 0.007684107, 0.007971932, 0.008283118, 0.009268828, 0.011574083},
         {0.007619605, 0.007639059, 0.007719825, 0.007823373, 0.00800813,  0.008113384, 0.008616374, 0.009785436},
         {0.007312199, 0.007352993, 0.007369116, 0.007468333, 0.007515657, 0.00767695,  0.008020447, 0.009072769},
         {0.006905851, 0.006966315, 0.007056413, 0.007116494, 0.007259661, 0.00733308,  0.007667563, 0.008419696},
         {0.006529553, 0.006630731, 0.006749022, 0.006858027, 0.007001959, 0.007139097, 0.007390404, 0.008036255},
         {0.006225482, 0.006404012, 0.00651594,  0.006642273, 0.006640887, 0.006885713, 0.007093024, 0.00767373}
        };
        // create quotes
        std::vector<std::vector<Handle<Quote> > > capletVolQuotes;
        for (auto& capletVol : capletVols) {
            std::vector<Handle<Quote> > row;
            row.reserve(capletVol.size());
            for (double j : capletVol)
                row.push_back(RelinkableHandle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(j))));
            capletVolQuotes.push_back(row);
        }
        Handle<YieldTermStructure> curve3m = getYTS(terms, proj3mRates);
        ext::shared_ptr<IborIndex> index(new Euribor3M(curve3m));
        ext::shared_ptr<StrippedOptionletBase> tmp1(
            new StrippedOptionlet(2, TARGET(), Following, index, dates, capletStrikes,
                                  capletVolQuotes, Actual365Fixed(), Normal, 0.0));
        ext::shared_ptr<StrippedOptionletAdapter> tmp2(new StrippedOptionletAdapter(tmp1));
        return RelinkableHandle<OptionletVolatilityStructure>(tmp2);
    }

    Period swaptionVTSTermsData[] = {
        Period(1, Years), Period(5, Years), Period(10, Years), Period(20, Years), Period(30, Years),
    };
    std::vector<Period> swaptionVTSTerms(swaptionVTSTermsData, swaptionVTSTermsData + 5);

    Handle<SwaptionVolatilityStructure> getSwaptionVTS() {
        std::vector<std::vector<Real> > swaptionVols =
            {
             {0.002616, 0.00468, 0.0056, 0.005852, 0.005823},
             {0.006213, 0.00643, 0.006622, 0.006124, 0.005958},
             {0.006658, 0.006723, 0.006602, 0.005802, 0.005464},
             {0.005728, 0.005814, 0.005663, 0.004689, 0.004276},
             {0.005041, 0.005059, 0.004746, 0.003927, 0.003608}
            };
        std::vector<std::vector<Handle<Quote> > > swaptionVolQuotes;
        for (auto& swaptionVol : swaptionVols) {
            std::vector<Handle<Quote> > row;
            row.reserve(swaptionVol.size());
            for (double j : swaptionVol)
                row.push_back(RelinkableHandle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(j))));
            swaptionVolQuotes.push_back(row);
        }
        ext::shared_ptr<SwaptionVolatilityStructure> tmp(
            new SwaptionVolatilityMatrix(TARGET(), Following, swaptionVTSTerms, swaptionVTSTerms,
                                         swaptionVolQuotes, Actual365Fixed(), true, Normal));
        return RelinkableHandle<SwaptionVolatilityStructure>(tmp);
    }

    void testSwaptioncfs(bool contTenorSpread) {
        // market data and floating rate index
        Handle<YieldTermStructure> discYTS = getYTS(terms, discRates);
        Handle<YieldTermStructure> proj6mYTS = getYTS(terms, proj6mRates);
        ext::shared_ptr<IborIndex> euribor6m(new Euribor6M(proj6mYTS));
        // Vanilla swap details
        Date today = Settings::instance().evaluationDate();
        Date swapStart = TARGET().advance(today, Period(5, Years), Following);
        Date swapEnd = TARGET().advance(swapStart, Period(10, Years), Following);
        Date exerciseDate = TARGET().advance(swapStart, Period(-2, Days), Preceding);
        Schedule fixedSchedule(swapStart, swapEnd, Period(1, Years), TARGET(), ModifiedFollowing,
                               ModifiedFollowing, DateGeneration::Backward, false);
        Schedule floatSchedule(swapStart, swapEnd, Period(6, Months), TARGET(), ModifiedFollowing,
                               ModifiedFollowing, DateGeneration::Backward, false);
        ext::shared_ptr<VanillaSwap> swap(
            new VanillaSwap(Swap::Payer, 10000.0, fixedSchedule, 0.03, Thirty360(Thirty360::BondBasis),
                            floatSchedule, euribor6m, 0.0, euribor6m->dayCounter()));
        swap->setPricingEngine(ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(discYTS)));
        // European exercise and swaption
        ext::shared_ptr<Exercise> europeanExercise(new EuropeanExercise(exerciseDate));
        ext::shared_ptr<Swaption> swaption(
            new Swaption(swap, europeanExercise, Settlement::Physical));
        // calculate basis model swaption cash flows, discount and conmpare with swap
        SwaptionCashFlows cashFlows(swaption, discYTS, contTenorSpread);
        // model time is always Act365Fixed
        Time exerciseTime = Actual365Fixed().yearFraction(discYTS->referenceDate(),
                                                          swaption->exercise()->dates()[0]);
        if (exerciseTime != cashFlows.exerciseTimes()[0])
            BOOST_ERROR(
                "Swaption cash flow exercise time does not coincide with manual calculation");
        // there might be rounding errors
        Real tol = 1.0e-8;
        // (discounted) fixed leg coupons must match swap fixed leg NPV
        Real fixedLeg = 0.0;
        for (Size k = 0; k < cashFlows.fixedTimes().size(); ++k)
            fixedLeg += cashFlows.fixedWeights()[k] * discYTS->discount(cashFlows.fixedTimes()[k]);
        if (fabs(fixedLeg - (-swap->fixedLegNPV())) > tol) // note, '-1' because payer swap
            BOOST_ERROR("Swaption cash flow fixed leg NPV does not match Vanillaswap fixed leg NPV"
                        << "SwaptionCashFlows: " << fixedLeg << "\n"
                        << "swap->fixedLegNPV: " << swap->fixedLegNPV() << "\n"
                        << "Variance:          " << swap->fixedLegNPV() - fixedLeg << "\n");
        // (discounted) floating leg coupons must match swap floating leg NPV
        Real floatLeg = 0.0;
        for (Size k = 0; k < cashFlows.floatTimes().size(); ++k)
            floatLeg += cashFlows.floatWeights()[k] * discYTS->discount(cashFlows.floatTimes()[k]);
        if (fabs(floatLeg - swap->floatingLegNPV()) > tol)
            BOOST_ERROR(
                "Swaption cash flow floating leg NPV does not match Vanillaswap floating leg NPV.\n"
                << "SwaptionCashFlows:    " << floatLeg << "\n"
                << "swap->floatingLegNPV: " << swap->floatingLegNPV() << "\n"
                << "Variance:             " << swap->floatingLegNPV() - floatLeg << "\n");
        // There should not be spread coupons in a single-curve setting.
        // However, if indexed coupons are used the floating leg is not at par,
        // so we need to relax the tolerance to a level at which it will only
        // catch large errors.
        Real tol2;
        if (!IborCoupon::usingAtParCoupons())
            tol2 = 0.02;
        else
            tol2 = tol;

        SwaptionCashFlows singleCurveCashFlows(swaption, proj6mYTS, contTenorSpread);
        for (Size k = 1; k < singleCurveCashFlows.floatWeights().size() - 1; ++k) {
            if (fabs(singleCurveCashFlows.floatWeights()[k]) > tol2)
                BOOST_ERROR("Swaption cash flow floating leg spread does not vanish in "
                            "single-curve setting.\n"
                            << "Cash flow index k: " << k << ", floatWeights: "
                            << singleCurveCashFlows.floatWeights()[k] << "\n");
        }
    }

}


void BasismodelsTest::testSwaptioncfsContCompSpread() {
    BOOST_TEST_MESSAGE(
        "Testing deterministic tenor basis model with continuous compounded spreads...");
    testSwaptioncfs(true);
}

void BasismodelsTest::testSwaptioncfsSimpleCompSpread() {
    BOOST_TEST_MESSAGE("Testing deterministic tenor basis model with simple compounded spreads...");
    testSwaptioncfs(false);
}

void BasismodelsTest::testTenoroptionletvts() {
    BOOST_TEST_MESSAGE("Testing volatility transformation for caplets/floorlets...");
    // market data and floating rate index
    Real spread = 0.01;
    Handle<YieldTermStructure> discYTS = getYTS(terms, discRates);
    Handle<YieldTermStructure> proj3mYTS = getYTS(terms, proj3mRates);
    Handle<YieldTermStructure> proj6mYTS = getYTS(terms, proj3mRates, spread);
    ext::shared_ptr<IborIndex> euribor3m(new Euribor6M(proj3mYTS));
    ext::shared_ptr<IborIndex> euribor6m(new Euribor6M(proj6mYTS));
    // 3m optionlet VTS
    Handle<OptionletVolatilityStructure> optionletVTS3m = getOptionletTS();
    {
        // we need a correlation structure
        Real corrTimesRaw[] = {0.0, 50.0};
        Real rhoInfDataRaw[] = {0.3, 0.3};
        Real betaDataRaw[] = {0.9, 0.9};
        std::vector<Real> corrTimes(corrTimesRaw, corrTimesRaw + 2);
        std::vector<Real> rhoInfData(rhoInfDataRaw, rhoInfDataRaw + 2);
        std::vector<Real> betaData(betaDataRaw, betaDataRaw + 2);
        ext::shared_ptr<Interpolation> rho(
            new LinearInterpolation(corrTimes.begin(), corrTimes.end(), rhoInfData.begin()));
        ext::shared_ptr<Interpolation> beta(
            new LinearInterpolation(corrTimes.begin(), corrTimes.end(), betaData.begin()));
        ext::shared_ptr<TenorOptionletVTS::CorrelationStructure> corr(
            new TenorOptionletVTS::TwoParameterCorrelation(rho, beta));
        // now we can set up the new volTS and calculate volatilities
        ext::shared_ptr<OptionletVolatilityStructure> optionletVTS6m(
            new TenorOptionletVTS(optionletVTS3m, euribor3m, euribor6m, corr));
        for (auto& capletTerm : capletTerms) {
            for (double& capletStrike : capletStrikes) {
                Real vol3m = optionletVTS3m->volatility(capletTerm, capletStrike, true);
                Real vol6m = optionletVTS6m->volatility(capletTerm, capletStrike, true);
                Real vol6mShifted =
                    optionletVTS6m->volatility(capletTerm, capletStrike + spread, true);
                // De-correlation yields that larger tenor shifted vols are smaller then shorter
                // tenor vols
                if (vol6mShifted - vol3m >
                    0.0001) // we leave 1bp tolerance due to simplified spread calculation
                    BOOST_ERROR("Shifted 6m vol significantly larger then 3m vol at\n"
                                << "expiry term: " << capletTerm << ", strike: " << capletStrike
                                << "\n"
                                << "vol3m: " << vol3m << ", vol6m: " << vol6m
                                << ", vol6mShifted: " << vol6mShifted << "\n");
            }
        }
    }
    {
        // we need a correlation structure
        Real corrTimesRaw[] = {0.0, 50.0};
        Real rhoInfDataRaw[] = {0.0, 0.0};
        Real betaDataRaw[] = {0.0, 0.0};
        std::vector<Real> corrTimes(corrTimesRaw, corrTimesRaw + 2);
        std::vector<Real> rhoInfData(rhoInfDataRaw, rhoInfDataRaw + 2);
        std::vector<Real> betaData(betaDataRaw, betaDataRaw + 2);
        ext::shared_ptr<Interpolation> rho(
            new LinearInterpolation(corrTimes.begin(), corrTimes.end(), rhoInfData.begin()));
        ext::shared_ptr<Interpolation> beta(
            new LinearInterpolation(corrTimes.begin(), corrTimes.end(), betaData.begin()));
        ext::shared_ptr<TenorOptionletVTS::CorrelationStructure> corr(
            new TenorOptionletVTS::TwoParameterCorrelation(rho, beta));
        // now we can set up the new volTS and calculate volatilities
        ext::shared_ptr<OptionletVolatilityStructure> optionletVTS6m(
            new TenorOptionletVTS(optionletVTS3m, euribor3m, euribor6m, corr));
        for (Size i = 0; i < capletTerms.size(); ++i) {
            for (double& capletStrike : capletStrikes) {
                Real vol3m = optionletVTS3m->volatility(capletTerms[i], capletStrike, true);
                Real vol6m = optionletVTS6m->volatility(capletTerms[i], capletStrike, true);
                Real vol6mShifted =
                    optionletVTS6m->volatility(capletTerms[i], capletStrike + spread, true);
                // for perfect correlation shifted 6m vols should coincide with 3m vols
                Real tol =
                    (i < 3) ? (0.001) :
                              (0.0001); // 10bp tol for smaller tenors and 1bp tol for larger tenors
                if (fabs(vol6mShifted - vol3m) > tol)
                    BOOST_ERROR("Shifted 6m vol does not match 3m vol for perfect correlation at\n"
                                << "expiry term: " << capletTerms[i] << ", strike: " << capletStrike
                                << "\n"
                                << "vol3m: " << vol3m << ", vol6m: " << vol6m
                                << ", vol6mShifted: " << vol6mShifted << "\n");
            }
        }
    }
}

void BasismodelsTest::testTenorswaptionvts() {
    BOOST_TEST_MESSAGE("Testing volatility transformation for swaptions...");
    // market data and floating rate index
    Real spread = 0.01;
    Handle<YieldTermStructure> discYTS = getYTS(terms, discRates);
    Handle<YieldTermStructure> proj3mYTS = getYTS(terms, proj3mRates);
    Handle<YieldTermStructure> proj6mYTS = getYTS(terms, proj3mRates, spread);
    ext::shared_ptr<IborIndex> euribor3m(new Euribor6M(proj3mYTS));
    ext::shared_ptr<IborIndex> euribor6m(new Euribor6M(proj6mYTS));
    // Euribor6m ATM vols
    Handle<SwaptionVolatilityStructure> euribor6mSwVTS = getSwaptionVTS();
    {
        ext::shared_ptr<TenorSwaptionVTS> euribor3mSwVTS(
            new TenorSwaptionVTS(euribor6mSwVTS, discYTS, euribor6m, euribor3m, Period(1, Years),
                                 Period(1, Years), Thirty360(Thirty360::BondBasis), Thirty360(Thirty360::BondBasis)));
        // 6m vols should be slightly larger then 3m vols due to basis
        for (Size i = 0; i < swaptionVTSTerms.size(); ++i) {
            for (Size j = 0; j < swaptionVTSTerms.size(); ++j) {
                Real vol6m = euribor6mSwVTS->volatility(swaptionVTSTerms[i], swaptionVTSTerms[j],
                                                        0.01, true);
                Real vol3m = euribor3mSwVTS->volatility(swaptionVTSTerms[i], swaptionVTSTerms[j],
                                                        0.01, true);
                if (vol3m > vol6m)
                    BOOST_ERROR("Euribor 6m must be larger than 3m vol at\n"
                                << "expiry term: " << swaptionVTSTerms[i]
                                << ", swap term: " << swaptionVTSTerms[j] << "\n"
                                << "vol3m: " << vol3m << ", vol6m: " << vol6m << "\n");
            }
        }
    }
    {
        ext::shared_ptr<TenorSwaptionVTS> euribor6mSwVTS2(
            new TenorSwaptionVTS(euribor6mSwVTS, discYTS, euribor6m, euribor6m, Period(1, Years),
                                 Period(1, Years), Thirty360(Thirty360::BondBasis), Thirty360(Thirty360::BondBasis)));
        // 6m vols to 6m vols should yield initiial vols
        for (Size i = 0; i < swaptionVTSTerms.size(); ++i) {
            for (Size j = 0; j < swaptionVTSTerms.size(); ++j) {
                Real vol6m = euribor6mSwVTS->volatility(swaptionVTSTerms[i], swaptionVTSTerms[j],
                                                        0.01, true);
                Real vol6m2 = euribor6mSwVTS2->volatility(swaptionVTSTerms[i], swaptionVTSTerms[j],
                                                          0.01, true);
                Real tol = 1.0e-8;
                if (fabs(vol6m2 - vol6m) > tol)
                    BOOST_ERROR("Euribor 6m to 6m vols should not change at\n"
                                << "expiry term: " << swaptionVTSTerms[i]
                                << ", swap term: " << swaptionVTSTerms[j] << "\n"
                                << "vol6m: " << vol6m << ", vol6m2: " << vol6m2
                                << ", variance: " << (vol6m2 - vol6m) << "\n");
            }
        }
    }
    {
        ext::shared_ptr<TenorSwaptionVTS> euribor3mSwVTS(
            new TenorSwaptionVTS(euribor6mSwVTS, discYTS, euribor6m, euribor3m, Period(1, Years),
                                 Period(1, Years), Thirty360(Thirty360::BondBasis), Thirty360(Thirty360::BondBasis)));
        ext::shared_ptr<TenorSwaptionVTS> euribor6mSwVTS2(new TenorSwaptionVTS(
            RelinkableHandle<SwaptionVolatilityStructure>(euribor3mSwVTS), discYTS, euribor3m,
            euribor6m, Period(1, Years), Period(1, Years), Thirty360(Thirty360::BondBasis), Thirty360(Thirty360::BondBasis)));
        // 6m vols to 6m vols should yield initiial vols
        for (Size i = 0; i < swaptionVTSTerms.size(); ++i) {
            for (Size j = 0; j < swaptionVTSTerms.size(); ++j) {
                Real vol6m = euribor6mSwVTS->volatility(swaptionVTSTerms[i], swaptionVTSTerms[j],
                                                        0.01, true);
                Real vol6m2 = euribor6mSwVTS2->volatility(swaptionVTSTerms[i], swaptionVTSTerms[j],
                                                          0.01, true);
                Real tol = 1.0e-8;
                if (fabs(vol6m2 - vol6m) > tol)
                    BOOST_ERROR("Euribor 6m to 3m to 6m vols should not change at\n"
                                << "expiry term: " << swaptionVTSTerms[i]
                                << ", swap term: " << swaptionVTSTerms[j] << "\n"
                                << "vol6m: " << vol6m << ", vol6m2: " << vol6m2
                                << ", variance: " << (vol6m2 - vol6m) << "\n");
            }
        }
    }
}


test_suite* BasismodelsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Basismodels tests");
    suite->add(QUANTLIB_TEST_CASE(&BasismodelsTest::testSwaptioncfsContCompSpread));
    suite->add(QUANTLIB_TEST_CASE(&BasismodelsTest::testSwaptioncfsSimpleCompSpread));
    suite->add(QUANTLIB_TEST_CASE(&BasismodelsTest::testTenoroptionletvts));
    suite->add(QUANTLIB_TEST_CASE(&BasismodelsTest::testTenorswaptionvts));
    return suite;
}
]]></document_content>
  </document>
  <document index="15">
    <source>basismodels.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Sebastian Schlenkrich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_basismodels_hpp
#define quantlib_test_basismodels_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BasismodelsTest {
  public:
    static void testSwaptioncfsContCompSpread();
	static void testSwaptioncfsSimpleCompSpread();
	static void testTenoroptionletvts();
    static void testTenorswaptionvts();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="16">
    <source>basketoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2005, 2008 StatPro Italia srl
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2004 Neil Firth

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "basketoption.hpp"
#include "utilities.hpp"
#include <ql/quotes/simplequote.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/pricingengines/basket/stulzengine.hpp>
#include <ql/pricingengines/basket/kirkengine.hpp>
#include <ql/pricingengines/basket/mceuropeanbasketengine.hpp>
#include <ql/pricingengines/basket/mcamericanbasketengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/hestonblackvolsurface.hpp>
#include <ql/pricingengines/basket/fd2dblackscholesvanillaengine.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE_2
#define REPORT_FAILURE_2(greekName, basketType, payoff, exercise, \
                         s1, s2, q1, q2, r, today, v1, v2, rho, \
                         expected, calculated, error, tolerance) \
    BOOST_ERROR( \
        exerciseTypeToString(exercise) << " " \
        << payoff->optionType() << " option on " \
        << basketTypeToString(basketType) \
        << " with " << payoffTypeToString(payoff) << " payoff:\n" \
        << "1st underlying value: " << s1 << "\n" \
        << "2nd underlying value: " << s2 << "\n" \
        << "              strike: " << payoff->strike() << "\n" \
        << "  1st dividend yield: " << io::rate(q1) << "\n" \
        << "  2nd dividend yield: " << io::rate(q2) << "\n" \
        << "      risk-free rate: " << io::rate(r) << "\n" \
        << "      reference date: " << today << "\n" \
        << "            maturity: " << exercise->lastDate() << "\n" \
        << "1st asset volatility: " << io::volatility(v1) << "\n" \
        << "2nd asset volatility: " << io::volatility(v2) << "\n" \
        << "         correlation: " << rho << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);

#undef REPORT_FAILURE_3
#define REPORT_FAILURE_3(greekName, basketType, payoff, exercise, \
                         s1, s2, s3, r, today, v1, v2, v3, rho, \
                         expected, calculated, error, tolerance) \
    BOOST_ERROR( \
        exerciseTypeToString(exercise) << " " \
        << payoff->optionType() << " option on " \
        << basketTypeToString(basketType) \
        << " with " << payoffTypeToString(payoff) << " payoff:\n" \
        << "1st underlying value: " << s1 << "\n" \
        << "2nd underlying value: " << s2 << "\n" \
        << "3rd underlying value: " << s3 << "\n" \
        << "              strike: " << payoff->strike() <<"\n" \
        << "      risk-free rate: " << io::rate(r) << "\n" \
        << "      reference date: " << today << "\n" \
        << "            maturity: " << exercise->lastDate() << "\n" \
        << "1st asset volatility: " << io::volatility(v1) << "\n" \
        << "2nd asset volatility: " << io::volatility(v2) << "\n" \
        << "3rd asset volatility: " << io::volatility(v3) << "\n" \
        << "         correlation: " << rho << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);


namespace {

    enum BasketType { MinBasket, MaxBasket, SpreadBasket };

    std::string basketTypeToString(BasketType basketType) {
        switch (basketType) {
          case MinBasket:
            return "MinBasket";
          case MaxBasket:
            return "MaxBasket";
          case SpreadBasket:
            return "Spread";
        }
        QL_FAIL("unknown basket option type");
    }

    ext::shared_ptr<BasketPayoff> basketTypeToPayoff(
                                         BasketType basketType,
                                         const ext::shared_ptr<Payoff> &p) {
        switch (basketType) {
          case MinBasket:
            return ext::shared_ptr<BasketPayoff>(new MinBasketPayoff(p));
          case MaxBasket:
            return ext::shared_ptr<BasketPayoff>(new MaxBasketPayoff(p));
          case SpreadBasket:
            return ext::shared_ptr<BasketPayoff>(new SpreadBasketPayoff(p));
        }
        QL_FAIL("unknown basket option type");
    }

    struct BasketOptionOneData {
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // expected result
        Real tol;      // tolerance
    };

    struct BasketOptionTwoData {
        BasketType basketType;
        Option::Type type;
        Real strike;
        Real s1;
        Real s2;
        Rate q1;
        Rate q2;
        Rate r;
        Time t; // years
        Volatility v1;
        Volatility v2;
        Real rho;
        Real result;
        Real tol;
    };

    struct BasketOptionThreeData {
        BasketType basketType;
        Option::Type type;
        Real strike;
        Real s1;
        Real s2;
        Real s3;
        Rate r;
        Time t; // months
        Volatility v1;
        Volatility v2;
        Volatility v3;
        Real rho;
        Real euroValue;
        Real amValue;
    };

}


void BasketOptionTest::testEuroTwoValues() {

    BOOST_TEST_MESSAGE("Testing two-asset European basket options...");

    /*
        Data from:
        Excel spreadsheet www.maths.ox.ac.uk/~firth/computing/excel.shtml
        and
        "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 pag 56-58
        European two asset max basket options
    */
    BasketOptionTwoData values[] = {
        //      basketType,   optionType, strike,    s1,    s2,   q1,   q2,    r,    t,   v1,   v2,  rho, result, tol
        // data from http://www.maths.ox.ac.uk/~firth/computing/excel.shtml
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.90, 10.898, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.70,  8.483, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.50,  6.844, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30,  5.531, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.10,  4.413, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.50, 0.70, 0.00,  4.981, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.50, 0.30, 0.00,  4.159, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.50, 0.10, 0.00,  2.597, 1.0e-3},
        {MinBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.50, 0.10, 0.50,  4.030, 1.0e-3},

        {MaxBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.90, 17.565, 1.0e-3},
        {MaxBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.70, 19.980, 1.0e-3},
        {MaxBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.50, 21.619, 1.0e-3},
        {MaxBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30, 22.932, 1.0e-3},
        {MaxBasket, Option::Call,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.10, 24.049, 1.1e-3},
        {MaxBasket, Option::Call,  100.0,  80.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30, 16.508, 1.0e-3},
        {MaxBasket, Option::Call,  100.0,  80.0,  80.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30,  8.049, 1.0e-3},
        {MaxBasket, Option::Call,  100.0,  80.0, 120.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30, 30.141, 1.0e-3},
        {MaxBasket, Option::Call,  100.0, 120.0, 120.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30, 42.889, 1.0e-3},

        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.90, 11.369, 1.0e-3},
        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.70, 12.856, 1.0e-3},
        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.50, 13.890, 1.0e-3},
        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30, 14.741, 1.0e-3},
        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.10, 15.485, 1.0e-3},

        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 0.50, 0.30, 0.30, 0.10, 11.893, 1.0e-3},
        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 0.25, 0.30, 0.30, 0.10,  8.881, 1.0e-3},
        {MinBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 2.00, 0.30, 0.30, 0.10, 19.268, 1.0e-3},

        {MaxBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.90,  7.339, 1.0e-3},
        {MaxBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.70,  5.853, 1.0e-3},
        {MaxBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.50,  4.818, 1.0e-3},
        {MaxBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.30,  3.967, 1.1e-3},
        {MaxBasket,  Option::Put,  100.0, 100.0, 100.0, 0.00, 0.00, 0.05, 1.00, 0.30, 0.30, 0.10,  3.223, 1.0e-3},

        //      basketType,   optionType, strike,    s1,    s2,   q1,   q2,    r,    t,   v1,   v2,  rho,  result, tol
        // data from "Option pricing formulas" VB code + spreadsheet
        {MinBasket, Option::Call,   98.0, 100.0, 105.0, 0.00, 0.00, 0.05, 0.50, 0.11, 0.16, 0.63,  4.8177, 1.0e-4},
        {MaxBasket, Option::Call,   98.0, 100.0, 105.0, 0.00, 0.00, 0.05, 0.50, 0.11, 0.16, 0.63, 11.6323, 1.0e-4},
        {MinBasket,  Option::Put,   98.0, 100.0, 105.0, 0.00, 0.00, 0.05, 0.50, 0.11, 0.16, 0.63,  2.0376, 1.0e-4},
        {MaxBasket,  Option::Put,   98.0, 100.0, 105.0, 0.00, 0.00, 0.05, 0.50, 0.11, 0.16, 0.63,  0.5731, 1.0e-4},
        {MinBasket, Option::Call,   98.0, 100.0, 105.0, 0.06, 0.09, 0.05, 0.50, 0.11, 0.16, 0.63,  2.9340, 1.0e-4},
        {MinBasket,  Option::Put,   98.0, 100.0, 105.0, 0.06, 0.09, 0.05, 0.50, 0.11, 0.16, 0.63,  3.5224, 1.0e-4},
        // data from "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 pag 58
        {MaxBasket, Option::Call,   98.0, 100.0, 105.0, 0.06, 0.09, 0.05, 0.50, 0.11, 0.16, 0.63,  8.0701, 1.0e-4},
        {MaxBasket,  Option::Put,   98.0, 100.0, 105.0, 0.06, 0.09, 0.05, 0.50, 0.11, 0.16, 0.63,  1.2181, 1.0e-4},

        /* "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 pag 59-60
            Kirk approx. for a european spread option on two futures*/

        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.20, 0.20, -0.5, 4.7530, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.20, 0.20,  0.0, 3.7970, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.20, 0.20,  0.5, 2.5537, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.25, 0.20, -0.5, 5.4275, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.25, 0.20,  0.0, 4.3712, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.25, 0.20,  0.5, 3.0086, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.20, 0.25, -0.5, 5.4061, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.20, 0.25,  0.0, 4.3451, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.1, 0.20, 0.25,  0.5, 2.9723, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.20, 0.20, -0.5,10.7517, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.20, 0.20,  0.0, 8.7020, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.20, 0.20,  0.5, 6.0257, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.25, 0.20, -0.5,12.1941, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.25, 0.20,  0.0, 9.9340, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.25, 0.20,  0.5, 7.0067, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.20, 0.25, -0.5,12.1483, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.20, 0.25,  0.0, 9.8780, 1.0e-3},
        {SpreadBasket, Option::Call, 3.0,  122.0, 120.0, 0.0, 0.0, 0.10,  0.5, 0.20, 0.25,  0.5, 6.9284, 1.0e-3}
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot2(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate1(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS1 = flatRate(today, qRate1, dc);
    ext::shared_ptr<SimpleQuote> qRate2(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS2 = flatRate(today, qRate2, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(today, vol2, dc);

    const Real mcRelativeErrorTolerance = 0.01;
    const Real fdRelativeErrorTolerance = 0.01;

    for (auto& value : values) {

        ext::shared_ptr<PlainVanillaPayoff> payoff(
            new PlainVanillaPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot1->setValue(value.s1);
        spot2->setValue(value.s2);
        qRate1->setValue(value.q1);
        qRate2->setValue(value.q2);
        rRate->setValue(value.r);
        vol1->setValue(value.v1);
        vol2->setValue(value.v2);


        ext::shared_ptr<PricingEngine> analyticEngine;
        ext::shared_ptr<GeneralizedBlackScholesProcess> p1, p2;
        switch (value.basketType) {
            case MaxBasket:
            case MinBasket:
                p1 = ext::shared_ptr<GeneralizedBlackScholesProcess>(new BlackScholesMertonProcess(
                    Handle<Quote>(spot1), Handle<YieldTermStructure>(qTS1),
                    Handle<YieldTermStructure>(rTS), Handle<BlackVolTermStructure>(volTS1)));
                p2 = ext::shared_ptr<GeneralizedBlackScholesProcess>(new BlackScholesMertonProcess(
                    Handle<Quote>(spot2), Handle<YieldTermStructure>(qTS2),
                    Handle<YieldTermStructure>(rTS), Handle<BlackVolTermStructure>(volTS2)));
                analyticEngine = ext::shared_ptr<PricingEngine>(new StulzEngine(p1, p2, value.rho));
                break;
            case SpreadBasket:
                p1 = ext::shared_ptr<GeneralizedBlackScholesProcess>(
                    new BlackProcess(Handle<Quote>(spot1), Handle<YieldTermStructure>(rTS),
                                     Handle<BlackVolTermStructure>(volTS1)));
                p2 = ext::shared_ptr<GeneralizedBlackScholesProcess>(
                    new BlackProcess(Handle<Quote>(spot2), Handle<YieldTermStructure>(rTS),
                                     Handle<BlackVolTermStructure>(volTS2)));

                analyticEngine = ext::shared_ptr<PricingEngine>(
                    new KirkEngine(ext::dynamic_pointer_cast<BlackProcess>(p1),
                                   ext::dynamic_pointer_cast<BlackProcess>(p2), value.rho));
                break;
            default:
                QL_FAIL("unknown basket type");
        }

        std::vector<ext::shared_ptr<StochasticProcess1D> > procs = { p1, p2 };

        Matrix correlationMatrix(2, 2, value.rho);
        for (Integer j=0; j < 2; j++) {
            correlationMatrix[j][j] = 1.0;
        }

        ext::shared_ptr<StochasticProcessArray> process(
                         new StochasticProcessArray(procs,correlationMatrix));

        ext::shared_ptr<PricingEngine> mcEngine =
            MakeMCEuropeanBasketEngine<PseudoRandom, Statistics>(process)
            .withStepsPerYear(1)
            .withSamples(10000)
            .withSeed(42);

        ext::shared_ptr<PricingEngine> fdEngine(
            new Fd2dBlackScholesVanillaEngine(p1, p2, value.rho, 50, 50, 15));

        BasketOption basketOption(basketTypeToPayoff(value.basketType, payoff), exercise);

        // analytic engine
        basketOption.setPricingEngine(analyticEngine);
        Real calculated = basketOption.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE_2("value", value.basketType, payoff, exercise, value.s1, value.s2,
                             value.q1, value.q2, value.r, today, value.v1, value.v2, value.rho,
                             value.result, calculated, error, value.tol);
        }

        // fd engine
        basketOption.setPricingEngine(fdEngine);
        calculated = basketOption.NPV();
        Real relError = relativeError(calculated, expected, expected);
        if (relError > mcRelativeErrorTolerance ) {
            REPORT_FAILURE_2("FD value", value.basketType, payoff, exercise, value.s1, value.s2,
                             value.q1, value.q2, value.r, today, value.v1, value.v2, value.rho,
                             value.result, calculated, relError, fdRelativeErrorTolerance);
        }

        // mc engine
        basketOption.setPricingEngine(mcEngine);
        calculated = basketOption.NPV();
        relError = relativeError(calculated, expected, value.s1);
        if (relError > mcRelativeErrorTolerance ) {
            REPORT_FAILURE_2("MC value", value.basketType, payoff, exercise, value.s1, value.s2,
                             value.q1, value.q2, value.r, today, value.v1, value.v2, value.rho,
                             value.result, calculated, relError, mcRelativeErrorTolerance);
        }
    }
}

void BasketOptionTest::testBarraquandThreeValues() {

    BOOST_TEST_MESSAGE("Testing three-asset basket options "
                       "against Barraquand's values...");

    /*
        Data from:
        "Numerical Valuation of High Dimensional American Securities"
        Barraquand, J. and Martineau, D.
        Journal of Financial and Quantitative Analysis 1995 3(30) 383-405
    */
    BasketOptionThreeData  values[] = {
        // time in months is with 30 days to the month..
        // basketType, optionType,       strike,    s1,    s2,   s3,    r,    t,   v1,   v2,  v3,  rho, euro, american,
        // Table 2
        // not using 4 month case to speed up test
/*
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.0, 8.59, 8.59},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.0, 3.84, 3.84},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.0, 0.89, 0.89},
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.0, 12.55, 12.55},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.0, 7.87, 7.87},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.0, 4.26, 4.26},
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.0, 15.29, 15.29},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.0, 10.72, 10.72},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.0, 6.96, 6.96},
*/
/*
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.5, 7.78, 7.78},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.5, 3.18, 3.18},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.5, 0.82, 0.82},
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.5, 10.97, 10.97},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.5, 6.69, 6.69},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.5, 3.70, 3.70},
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.5, 13.23, 13.23},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.5, 9.11, 9.11},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.5, 5.98, 5.98},
*/
/*
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 1.0, 6.53, 6.53},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 1.0, 2.38, 2.38},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 1.0, 0.74, 0.74},
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 1.0, 8.51, 8.51},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 1.0, 4.92, 4.92},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 1.0, 2.97, 2.97},
        {MaxBasket, Option::Call,  35.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 1.0, 10.04, 10.04},
        {MaxBasket, Option::Call,  40.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 1.0, 6.64, 6.64},
        {MaxBasket, Option::Call,  45.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 1.0, 4.61, 4.61},
*/
        // Table 3

        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.0, 0.00, 0.00},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.0, 0.13, 0.23},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.0, 2.26, 5.00},
        //{MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.0, 0.01, 0.01},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.0, 0.25, 0.44},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.0, 1.55, 5.00},
        //{MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.0, 0.03, 0.04},
        //{MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.0, 0.31, 0.57},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.0, 1.41, 5.00},

/*
        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.5, 0.00, 0.00},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.5, 0.38, 0.48},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 0.5, 3.00, 5.00},
        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.5, 0.07, 0.09},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.5, 0.72, 0.93},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 0.5, 2.65, 5.00},
        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.5, 0.17, 0.20},
*/
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.5, 0.91, 1.19},
/*
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 0.5, 2.63, 5.00},

        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 1.0, 0.01, 0.01},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 1.0, 0.84, 0.08},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 1.00, 0.20, 0.30, 0.50, 1.0, 4.18, 5.00},
        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 1.0, 0.19, 0.19},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 1.0, 1.51, 1.56},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 4.00, 0.20, 0.30, 0.50, 1.0, 4.49, 5.00},
        {MaxBasket, Option::Put,  35.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 1.0, 0.41, 0.42},
        {MaxBasket, Option::Put,  40.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 1.0, 1.87, 1.96},
        {MaxBasket, Option::Put,  45.0,  40.0,  40.0, 40.0, 0.05, 7.00, 0.20, 0.30, 0.50, 1.0, 4.70, 5.20}
*/
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot2(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot3(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(today, vol2, dc);
    ext::shared_ptr<SimpleQuote> vol3(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS3 = flatVol(today, vol3, dc);

    for (auto& value : values) {

        ext::shared_ptr<PlainVanillaPayoff> payoff(
            new PlainVanillaPayoff(value.type, value.strike));

        Date exDate = today + Integer(value.t) * 30;
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                    exDate));

        spot1->setValue(value.s1);
        spot2->setValue(value.s2);
        spot3->setValue(value.s3);
        rRate->setValue(value.r);
        vol1->setValue(value.v1);
        vol2->setValue(value.v2);
        vol3->setValue(value.v3);

        ext::shared_ptr<StochasticProcess1D> stochProcess1(new
            BlackScholesMertonProcess(Handle<Quote>(spot1),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS1)));

        ext::shared_ptr<StochasticProcess1D> stochProcess2(new
            BlackScholesMertonProcess(Handle<Quote>(spot2),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS2)));

        ext::shared_ptr<StochasticProcess1D> stochProcess3(new
            BlackScholesMertonProcess(Handle<Quote>(spot3),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS3)));

        std::vector<ext::shared_ptr<StochasticProcess1D> > procs
            = {stochProcess1, stochProcess2, stochProcess3 };

        Matrix correlation(3, 3, value.rho);
        for (Integer j=0; j < 3; j++) {
            correlation[j][j] = 1.0;
        }

        // FLOATING_POINT_EXCEPTION
        ext::shared_ptr<StochasticProcessArray> process(
                               new StochasticProcessArray(procs,correlation));

        // use a 3D sobol sequence...
        // Think long and hard before moving to more than 1 timestep....
        ext::shared_ptr<PricingEngine> mcQuasiEngine =
            MakeMCEuropeanBasketEngine<LowDiscrepancy>(process)
            .withStepsPerYear(1)
            .withSamples(8091)
            .withSeed(42);

        BasketOption euroBasketOption(basketTypeToPayoff(value.basketType, payoff), exercise);
        euroBasketOption.setPricingEngine(mcQuasiEngine);

        Real expected = value.euroValue;
        Real calculated = euroBasketOption.NPV();
        Real relError = relativeError(calculated, expected, value.s1);
        Real mcRelativeErrorTolerance = 0.01;
        if (relError > mcRelativeErrorTolerance ) {
            REPORT_FAILURE_3("MC Quasi value", value.basketType, payoff, exercise, value.s1,
                             value.s2, value.s3, value.r, today, value.v1, value.v2, value.v3,
                             value.rho, value.euroValue, calculated, relError,
                             mcRelativeErrorTolerance);
        }


        Size requiredSamples = 1000;
        Size timeSteps = 500;
        BigNatural seed = 1;
        ext::shared_ptr<PricingEngine> mcLSMCEngine =
            MakeMCAmericanBasketEngine<>(process)
            .withSteps(timeSteps)
            .withAntitheticVariate()
            .withSamples(requiredSamples)
            .withCalibrationSamples(requiredSamples/4)
            .withSeed(seed);

        BasketOption amBasketOption(basketTypeToPayoff(value.basketType, payoff), amExercise);
        amBasketOption.setPricingEngine(mcLSMCEngine);

        expected = value.amValue;
        calculated = amBasketOption.NPV();
        relError = relativeError(calculated, expected, value.s1);
        Real mcAmericanRelativeErrorTolerance = 0.01;
        if (relError > mcAmericanRelativeErrorTolerance) {
            REPORT_FAILURE_3("MC LSMC Value", value.basketType, payoff, exercise, value.s1,
                             value.s2, value.s3, value.r, today, value.v1, value.v2, value.v3,
                             value.rho, value.amValue, calculated, relError,
                             mcRelativeErrorTolerance);
        }
    }
}

void BasketOptionTest::testTavellaValues() {

    BOOST_TEST_MESSAGE("Testing three-asset American basket options "
                       "against Tavella's values...");

    /*
        Data from:
        "Quantitative Methods in Derivatives Pricing"
        Tavella, D. A.   -   Wiley (2002)
    */
    BasketOptionThreeData  values[] = {
        // time in months is with 30 days to the month..
        // basketType, optionType,       strike,    s1,    s2,   s3,    r,    t,   v1,   v2,  v3,  rho, euroValue, american Value,
        {MaxBasket, Option::Call,  100,    100,   100, 100,  0.05, 3.00, 0.20, 0.20, 0.20, 0.0, -999, 18.082}
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot2(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot3(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.1));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.05));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(today, vol2, dc);
    ext::shared_ptr<SimpleQuote> vol3(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS3 = flatVol(today, vol3, dc);

    Real mcRelativeErrorTolerance = 0.01;
    Size requiredSamples = 10000;
    Size timeSteps = 20;
    BigNatural seed = 0;


    ext::shared_ptr<PlainVanillaPayoff> payoff(new
        PlainVanillaPayoff(values[0].type, values[0].strike));

    Date exDate = today + timeToDays(values[0].t);
    ext::shared_ptr<Exercise> exercise(new AmericanExercise(today, exDate));

    spot1 ->setValue(values[0].s1);
    spot2 ->setValue(values[0].s2);
    spot3 ->setValue(values[0].s3);
    vol1  ->setValue(values[0].v1);
    vol2  ->setValue(values[0].v2);
    vol3  ->setValue(values[0].v3);

    ext::shared_ptr<StochasticProcess1D> stochProcess1(new
        BlackScholesMertonProcess(Handle<Quote>(spot1),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS1)));

    ext::shared_ptr<StochasticProcess1D> stochProcess2(new
        BlackScholesMertonProcess(Handle<Quote>(spot2),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS2)));

    ext::shared_ptr<StochasticProcess1D> stochProcess3(new
        BlackScholesMertonProcess(Handle<Quote>(spot3),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS3)));

    std::vector<ext::shared_ptr<StochasticProcess1D> > procs = {stochProcess1,
                                                                stochProcess2,
                                                                stochProcess3};

    Matrix correlation(3,3, 0.0);
    for (Integer j=0; j < 3; j++) {
        correlation[j][j] = 1.0;
    }
    correlation[1][0] = -0.25;
    correlation[0][1] = -0.25;
    correlation[2][0] = 0.25;
    correlation[0][2] = 0.25;
    correlation[2][1] = 0.3;
    correlation[1][2] = 0.3;

    ext::shared_ptr<StochasticProcessArray> process(
                               new StochasticProcessArray(procs,correlation));
    ext::shared_ptr<PricingEngine> mcLSMCEngine =
        MakeMCAmericanBasketEngine<>(process)
        .withSteps(timeSteps)
        .withAntitheticVariate()
        .withSamples(requiredSamples)
        .withCalibrationSamples(requiredSamples/4)
        .withSeed(seed);

    BasketOption basketOption(basketTypeToPayoff(values[0].basketType,
                                                 payoff),
                              exercise);
    basketOption.setPricingEngine(mcLSMCEngine);

    Real calculated = basketOption.NPV();
    Real expected = values[0].amValue;
    Real errorEstimate = basketOption.errorEstimate();
    Real relError = relativeError(calculated, expected, values[0].s1);
    if (relError > mcRelativeErrorTolerance ) {
        REPORT_FAILURE_3("MC LSMC Tavella value", values[0].basketType,
                         payoff, exercise, values[0].s1, values[0].s2,
                         values[0].s3, values[0].r, today, values[0].v1,
                         values[0].v2, values[0].v3, values[0].rho,
                         values[0].amValue, calculated, errorEstimate,
                         mcRelativeErrorTolerance);
    }
}

namespace {
    BasketOptionOneData oneDataValues[] = {
        //        type, strike,   spot,    q,    r,    t,  vol,   value, tol
        { Option::Put, 100.00,  80.00,   0.0, 0.06,   0.5, 0.4,  21.6059, 1e-2 },
        { Option::Put, 100.00,  85.00,   0.0, 0.06,   0.5, 0.4,  18.0374, 1e-2 },
        { Option::Put, 100.00,  90.00,   0.0, 0.06,   0.5, 0.4,  14.9187, 1e-2 },
        { Option::Put, 100.00,  95.00,   0.0, 0.06,   0.5, 0.4,  12.2314, 1e-2 },
        { Option::Put, 100.00, 100.00,   0.0, 0.06,   0.5, 0.4,  9.9458, 1e-2 },
        { Option::Put, 100.00, 105.00,   0.0, 0.06,   0.5, 0.4,  8.0281, 1e-2 },
        { Option::Put, 100.00, 110.00,   0.0, 0.06,   0.5, 0.4,  6.4352, 1e-2 },
        { Option::Put, 100.00, 115.00,   0.0, 0.06,   0.5, 0.4,  5.1265, 1e-2 },
        { Option::Put, 100.00, 120.00,   0.0, 0.06,   0.5, 0.4,  4.0611, 1e-2 },

        // Longstaff Schwartz 1D example
        // use constant and three Laguerre polynomials
        // 100,000 paths and 50 timesteps per year
        { Option::Put, 40.00, 36.00,   0.0, 0.06,   1.0, 0.2,  4.478, 1e-2 },
        { Option::Put, 40.00, 36.00,   0.0, 0.06,   2.0, 0.2,  4.840, 1e-2 },
        { Option::Put, 40.00, 36.00,   0.0, 0.06,   1.0, 0.4,  7.101, 1e-2 },
        { Option::Put, 40.00, 36.00,   0.0, 0.06,   2.0, 0.4,  8.508, 1e-2 },

        { Option::Put, 40.00, 38.00,   0.0, 0.06,   1.0, 0.2,  3.250, 1e-2 },
        { Option::Put, 40.00, 38.00,   0.0, 0.06,   2.0, 0.2,  3.745, 1e-2 },
        { Option::Put, 40.00, 38.00,   0.0, 0.06,   1.0, 0.4,  6.148, 1e-2 },
        { Option::Put, 40.00, 38.00,   0.0, 0.06,   2.0, 0.4,  7.670, 1e-2 },

        { Option::Put, 40.00, 40.00,   0.0, 0.06,   1.0, 0.2,  2.314, 1e-2 },
        { Option::Put, 40.00, 40.00,   0.0, 0.06,   2.0, 0.2,  2.885, 1e-2 },
        { Option::Put, 40.00, 40.00,   0.0, 0.06,   1.0, 0.4,  5.312, 1e-2 },
        { Option::Put, 40.00, 40.00,   0.0, 0.06,   2.0, 0.4,  6.920, 1e-2 },

        { Option::Put, 40.00, 42.00,   0.0, 0.06,   1.0, 0.2,  1.617, 1e-2 },
        { Option::Put, 40.00, 42.00,   0.0, 0.06,   2.0, 0.2,  2.212, 1e-2 },
        { Option::Put, 40.00, 42.00,   0.0, 0.06,   1.0, 0.4,  4.582, 1e-2 },
        { Option::Put, 40.00, 42.00,   0.0, 0.06,   2.0, 0.4,  6.248, 1e-2 },

        { Option::Put, 40.00, 44.00,   0.0, 0.06,   1.0, 0.2,  1.110, 1e-2 },
        { Option::Put, 40.00, 44.00,   0.0, 0.06,   2.0, 0.2,  1.690, 1e-2 },
        { Option::Put, 40.00, 44.00,   0.0, 0.06,   1.0, 0.4,  3.948, 1e-2 },
        { Option::Put, 40.00, 44.00,   0.0, 0.06,   2.0, 0.4,  5.647, 1e-2 }
    };
}

void BasketOptionTest::testOneDAmericanValues(std::size_t from, std::size_t to) {

    BOOST_TEST_MESSAGE("Testing basket American options against 1-D case "
                       "from " << from << " to " << to-1 <<  "...");

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.05));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);

    Size requiredSamples = 10000;
    Size timeSteps = 52;
    BigNatural seed = 0;

    ext::shared_ptr<StochasticProcess1D> stochProcess1(new
        BlackScholesMertonProcess(Handle<Quote>(spot1),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS1)));

    std::vector<ext::shared_ptr<StochasticProcess1D> > procs = {stochProcess1};

    Matrix correlation(1, 1, 1.0);

    ext::shared_ptr<StochasticProcessArray> process(
                               new StochasticProcessArray(procs,correlation));

    ext::shared_ptr<PricingEngine> mcLSMCEngine =
        MakeMCAmericanBasketEngine<>(process)
        .withSteps(timeSteps)
        .withAntitheticVariate()
        .withSamples(requiredSamples)
        .withCalibrationSamples(requiredSamples/4)
        .withSeed(seed);

    for (Size i=from; i<to; i++) {
        ext::shared_ptr<PlainVanillaPayoff> payoff(new
            PlainVanillaPayoff(oneDataValues[i].type, oneDataValues[i].strike));

        Date exDate = today + timeToDays(oneDataValues[i].t);
        ext::shared_ptr<Exercise> exercise(new AmericanExercise(today,
                                                                  exDate));

        spot1 ->setValue(oneDataValues[i].s);
        vol1  ->setValue(oneDataValues[i].v);
        rRate ->setValue(oneDataValues[i].r);
        qRate ->setValue(oneDataValues[i].q);

        BasketOption basketOption(// process,
                                  basketTypeToPayoff(MaxBasket, payoff),
                                  exercise);
        basketOption.setPricingEngine(mcLSMCEngine);

        Real calculated = basketOption.NPV();
        Real expected = oneDataValues[i].result;
        // Real errorEstimate = basketOption.errorEstimate();
        Real relError = relativeError(calculated, expected, oneDataValues[i].s);
        // Real error = std::fabs(calculated-expected);

        if (relError > oneDataValues[i].tol) {
            BOOST_FAIL("expected value: " << oneDataValues[i].result << "\n"
                       << "calculated:     " << calculated);
        }

    }
}

/* This unit test is a a regression test to check for a crash in
   monte carlo if the required sample is odd.  The crash occurred
   because the samples array size was off by one when antithetic
   paths were added.
*/
void BasketOptionTest::testOddSamples() {

    BOOST_TEST_MESSAGE("Testing antithetic engine using odd sample number...");

    Size requiredSamples = 10001; // The important line
    Size timeSteps = 53;
    BasketOptionOneData values[] = {
        //        type, strike,   spot,    q,    r,    t,  vol,   value, tol
        { Option::Put, 100.00,  80.00,   0.0, 0.06,   0.5, 0.4,  21.6059, 1e-2 }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.05));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);



    BigNatural seed = 0;

    ext::shared_ptr<StochasticProcess1D> stochProcess1(new
        BlackScholesMertonProcess(Handle<Quote>(spot1),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS1)));

    std::vector<ext::shared_ptr<StochasticProcess1D> > procs = {stochProcess1};

    Matrix correlation(1, 1, 1.0);

    ext::shared_ptr<StochasticProcessArray> process(
                               new StochasticProcessArray(procs,correlation));

    ext::shared_ptr<PricingEngine> mcLSMCEngine =
        MakeMCAmericanBasketEngine<>(process)
        .withSteps(timeSteps)
        .withAntitheticVariate()
        .withSamples(requiredSamples)
        .withCalibrationSamples(requiredSamples/4)
        .withSeed(seed);

    for (auto& value : values) {
        ext::shared_ptr<PlainVanillaPayoff> payoff(
            new PlainVanillaPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new AmericanExercise(today,
                                                                  exDate));

        spot1->setValue(value.s);
        vol1->setValue(value.v);
        rRate->setValue(value.r);
        qRate->setValue(value.q);

        BasketOption basketOption(// process,
                                  basketTypeToPayoff(MaxBasket, payoff),
                                  exercise);
        basketOption.setPricingEngine(mcLSMCEngine);

        Real calculated = basketOption.NPV();
        Real expected = value.result;
        // Real errorEstimate = basketOption.errorEstimate();
        Real relError = relativeError(calculated, expected, value.s);
        // Real error = std::fabs(calculated-expected);

        if (relError > value.tol) {
            BOOST_FAIL("expected value: " << value.result << "\n"
                                          << "calculated:     " << calculated);
        }
    }
}

void BasketOptionTest::testLocalVolatilitySpreadOption() {

    BOOST_TEST_MESSAGE("Testing 2D local-volatility spread-option pricing...");

    const DayCounter dc = Actual360();
    const Date today = Date(21, September, 2017);
    const Date maturity = today + Period(3, Months);

    const Handle<YieldTermStructure> riskFreeRate(flatRate(today, 0.07, dc));
    const Handle<YieldTermStructure> dividendYield(flatRate(today, 0.03, dc));

    const Handle<Quote> s1(ext::make_shared<SimpleQuote>(100));
    const Handle<Quote> s2(ext::make_shared<SimpleQuote>(110));

    const ext::shared_ptr<HestonModel> hm1(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                riskFreeRate, dividendYield,
                s1, 0.09, 1.0, 0.06, 0.6, -0.75)));

    const ext::shared_ptr<HestonModel> hm2(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                riskFreeRate, dividendYield,
                s2, 0.1, 2.0, 0.07, 0.8, 0.85)));

    const Handle<BlackVolTermStructure> vol1(
        ext::make_shared<HestonBlackVolSurface>(Handle<HestonModel>(hm1)));

    const Handle<BlackVolTermStructure> vol2(
        ext::make_shared<HestonBlackVolSurface>(Handle<HestonModel>(hm2)));

    BasketOption basketOption(
        basketTypeToPayoff(
            SpreadBasket,
            ext::make_shared<PlainVanillaPayoff>(
                    Option::Call, s2->value() - s1->value())),
        ext::make_shared<EuropeanExercise>(maturity));

    const Real rho = -0.6;

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bs2(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            s2, dividendYield, riskFreeRate, vol2));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bs1(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            s1, dividendYield, riskFreeRate, vol1));

    basketOption.setPricingEngine(
        ext::shared_ptr<Fd2dBlackScholesVanillaEngine>(
            new Fd2dBlackScholesVanillaEngine(
                bs1, bs2, rho, 11, 11, 6, 0,
                FdmSchemeDesc::Hundsdorfer(), true, 0.25)));

    const Real tolerance = 0.01;
    const Real expected = 2.561;
    const Real calculated = basketOption.NPV();

    if (std::fabs(expected - calculated) > tolerance) {
        BOOST_ERROR("Failed to reproduce expected local volatility price"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << "\n    tolerance:  " << tolerance);
    }
}

void BasketOptionTest::test2DPDEGreeks() {

    BOOST_TEST_MESSAGE("Testing Greeks of two-dimensional PDE engine...");

    const Real s1 = 100;
    const Real s2 = 100;
    const Real r = 0.013;
    const Volatility v = 0.2;
    const Real rho = 0.5;
    const Real strike = s1-s2;
    const Size maturityInDays = 1095;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date::todaysDate();
    const Date maturity = today + maturityInDays;

    const ext::shared_ptr<SimpleQuote> spot1(
        ext::make_shared<SimpleQuote>(s1));
    const ext::shared_ptr<SimpleQuote> spot2(
        ext::make_shared<SimpleQuote>(s2));

    const Handle<YieldTermStructure> rTS(flatRate(today, r, dc));
    const Handle<BlackVolTermStructure> vTS(flatVol(today, v, dc));

    const ext::shared_ptr<BlackProcess> p1(
        ext::make_shared<BlackProcess>(Handle<Quote>(spot1), rTS, vTS));

    const ext::shared_ptr<BlackProcess> p2(
        ext::make_shared<BlackProcess>(Handle<Quote>(spot2), rTS, vTS));

    BasketOption option(
        ext::make_shared<SpreadBasketPayoff>(
            ext::make_shared<PlainVanillaPayoff>(Option::Call, strike)),
        ext::make_shared<EuropeanExercise>(maturity));

    option.setPricingEngine(
        ext::make_shared<Fd2dBlackScholesVanillaEngine>(p1, p2, rho));

    const Real calculatedDelta = option.delta();
    const Real calculatedGamma = option.gamma();

    option.setPricingEngine(ext::make_shared<KirkEngine>(p1, p2, rho));

    const Real eps = 1.0;
    const Real npv = option.NPV();

    spot1->setValue(s1 + eps);
    spot2->setValue(s2 + eps);
    const Real npvUp = option.NPV();

    spot1->setValue(s1 - eps);
    spot2->setValue(s2 - eps);
    const Real npvDown = option.NPV();

    const Real expectedDelta = (npvUp - npvDown)/(2*eps);
    const Real expectedGamma = (npvUp + npvDown - 2*npv)/(eps*eps);

    const Real tol = 0.0005;
    if (std::fabs(expectedDelta - calculatedDelta) > tol) {
        BOOST_FAIL("failed to reproduce delta with 2dim PDE"
                   << std::fixed << std::setprecision(8)
                   << "\n    calculated: " << calculatedDelta
                   << "\n    expected:   " << expectedDelta
                   << "\n    tolerance:  " << tol);
    }

    if (std::fabs(expectedGamma - calculatedGamma) > tol) {
        BOOST_FAIL("failed to reproduce delta with 2dim PDE"
                   << std::fixed << std::setprecision(8)
                   << "\n    calculated: " << calculatedGamma
                   << "\n    expected:   " << expectedGamma
                   << "\n    tolerance:  " << tol);
    }
}

test_suite* BasketOptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Basket option tests");

    suite->add(QUANTLIB_TEST_CASE(&BasketOptionTest::testEuroTwoValues));
    suite->add(QUANTLIB_TEST_CASE(&BasketOptionTest::testTavellaValues));

    suite->add(QUANTLIB_TEST_CASE(&BasketOptionTest::testOddSamples));
    suite->add(QUANTLIB_TEST_CASE(
        &BasketOptionTest::testLocalVolatilitySpreadOption));
    suite->add(QUANTLIB_TEST_CASE(&BasketOptionTest::test2DPDEGreeks));

    if (speed <= Fast) {
        // unrolled to get different test names
        suite->add(QUANTLIB_TEST_CASE([=](){ BasketOptionTest::testOneDAmericanValues( 0,  5); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ BasketOptionTest::testOneDAmericanValues( 5, 11); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ BasketOptionTest::testOneDAmericanValues(11, 17); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ BasketOptionTest::testOneDAmericanValues(17, 23); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ BasketOptionTest::testOneDAmericanValues(23, 29); }));
    }

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
            &BasketOptionTest::testBarraquandThreeValues));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="17">
    <source>basketoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_basket_option_hpp
#define quantlib_test_basket_option_hpp

#include <boost/test/unit_test.hpp>
#include <cstddef>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BasketOptionTest {
  public:
    static void testEuroTwoValues();
    static void testBarraquandThreeValues();
    static void testTavellaValues();
    static void testOneDAmericanValues(std::size_t from, std::size_t to);
    static void testOddSamples();
    static void testLocalVolatilitySpreadOption();
    static void test2DPDEGreeks();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="18">
    <source>batesmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2008 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "batesmodel.hpp"
#include "utilities.hpp"
#include <ql/time/calendars/target.hpp>
#include <ql/processes/batesprocess.hpp>
#include <ql/processes/merton76process.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/pricingengines/vanilla/batesengine.hpp>
#include <ql/pricingengines/vanilla/jumpdiffusionengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/mceuropeanhestonengine.hpp>
#include <ql/pricingengines/vanilla/fdbatesvanillaengine.hpp>
#include <ql/models/equity/batesmodel.hpp>
#include <ql/models/equity/hestonmodelhelper.hpp>
#include <ql/time/period.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace bates_model_test {

    Real getCalibrationError(
               std::vector<ext::shared_ptr<BlackCalibrationHelper> > & options) {
        Real sse = 0;
        for (auto& option : options) {
            const Real diff = option->calibrationError() * 100.0;
            sse += diff*diff;
        }
        return sse;
    }

}


void BatesModelTest::testAnalyticVsBlack() {

    BOOST_TEST_MESSAGE("Testing analytic Bates engine against Black formula...");

    SavedSettings backup;

    Date settlementDate = Date::todaysDate();
    Settings::instance().evaluationDate() = settlementDate;

    DayCounter dayCounter = ActualActual(ActualActual::ISDA);
    Date exerciseDate = settlementDate + 6*Months;

    ext::shared_ptr<StrikedTypePayoff> payoff(
                                     new PlainVanillaPayoff(Option::Put, 30));
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));

    Handle<YieldTermStructure> riskFreeTS(flatRate(0.1, dayCounter));
    Handle<YieldTermStructure> dividendTS(flatRate(0.04, dayCounter));
    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(32.0)));

    Real yearFraction = dayCounter.yearFraction(settlementDate, exerciseDate);
    Real forwardPrice = s0->value()*std::exp((0.1-0.04)*yearFraction);
    Real expected = blackFormula(payoff->optionType(), payoff->strike(),
        forwardPrice, std::sqrt(0.05*yearFraction)) *
                                            std::exp(-0.1*yearFraction);
    const Real v0 = 0.05;
    const Real kappa = 5.0;
    const Real theta = 0.05;
    const Real sigma = 1.0e-4;
    const Real rho = 0.0;
    const Real lambda = 0.0001;
    const Real nu = 0.0; 
    const Real delta = 0.0001;

    VanillaOption option(payoff, exercise);

    ext::shared_ptr<BatesProcess> process(
        new BatesProcess(riskFreeTS, dividendTS, s0, v0, 
                         kappa, theta, sigma, rho, lambda, nu, delta));

    ext::shared_ptr<PricingEngine> engine(new BatesEngine(
        ext::make_shared<BatesModel>(process), 64));

    option.setPricingEngine(engine);
    Real calculated = option.NPV();

    Real tolerance = 2.0e-7;
    Real error = std::fabs(calculated - expected);
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce Black price with BatesEngine"
                    << std::fixed
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << std::scientific
                    << "\n    error:      " << error);
    }

    engine = ext::shared_ptr<PricingEngine>(new BatesDetJumpEngine(
        ext::make_shared<BatesDetJumpModel>(
            process, 1.0, 0.0001), 64));

    option.setPricingEngine(engine);
    calculated = option.NPV();

    error = std::fabs(calculated - expected);
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce Black price with " \
                    "BatesDetJumpEngine"
                    << std::fixed
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << std::scientific
                    << "\n    error:      " << error);
    }

    engine = ext::shared_ptr<PricingEngine>(new BatesDoubleExpEngine(
        ext::make_shared<BatesDoubleExpModel>(
            process, 0.0001, 0.0001, 0.0001), 64));

    option.setPricingEngine(engine);
    calculated = option.NPV();

    error = std::fabs(calculated - expected);
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce Black price with BatesDoubleExpEngine"
                    << std::fixed
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << std::scientific
                    << "\n    error:      " << error);
    }

    engine = ext::shared_ptr<PricingEngine>(new BatesDoubleExpDetJumpEngine(
        ext::make_shared<BatesDoubleExpDetJumpModel>(
            
                process, 0.0001, 0.0001, 0.0001, 0.5, 1.0, 0.0001), 64));

    option.setPricingEngine(engine);
    calculated = option.NPV();

    error = std::fabs(calculated - expected);
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce Black price with " \
                    "BatesDoubleExpDetJumpEngine"
                    << std::fixed
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << std::scientific
                    << "\n    error:      " << error);
    }
}


void BatesModelTest::testAnalyticAndMcVsJumpDiffusion() {

    BOOST_TEST_MESSAGE("Testing analytic Bates engine against Merton-76 engine...");

    SavedSettings backup;

    Date settlementDate = Date::todaysDate();
    Settings::instance().evaluationDate() = settlementDate;

    DayCounter dayCounter = ActualActual(ActualActual::ISDA);

    ext::shared_ptr<StrikedTypePayoff> payoff(
                                     new PlainVanillaPayoff(Option::Put, 95));

    Handle<YieldTermStructure> riskFreeTS(flatRate(0.1, dayCounter));
    Handle<YieldTermStructure> dividendTS(flatRate(0.04, dayCounter));
    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(100)));

    Real v0 = 0.0433;
    // FLOATING_POINT_EXCEPTION
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(std::sqrt(v0)));
    ext::shared_ptr<BlackVolTermStructure> volTS =
        flatVol(settlementDate, vol, dayCounter);

    const Real kappa = 0.5;
    const Real theta = v0;
    const Real sigma = 1.0e-4;
    const Real rho = 0.0;

    ext::shared_ptr<SimpleQuote> jumpIntensity(new SimpleQuote(2));
    ext::shared_ptr<SimpleQuote> meanLogJump(new SimpleQuote(-0.2));
    ext::shared_ptr<SimpleQuote> jumpVol(new SimpleQuote(0.2));

    ext::shared_ptr<BatesProcess> batesProcess(new BatesProcess(
        riskFreeTS, dividendTS, s0, v0, kappa, theta, sigma, rho,
        jumpIntensity->value(), meanLogJump->value(), jumpVol->value()));

    ext::shared_ptr<Merton76Process> mertonProcess(
        new Merton76Process(s0, dividendTS, riskFreeTS,
                            Handle<BlackVolTermStructure>(volTS),
                            Handle<Quote>(jumpIntensity),
                            Handle<Quote>(meanLogJump),
                            Handle<Quote>(jumpVol)));

    ext::shared_ptr<PricingEngine> batesEngine(new BatesEngine(
        ext::make_shared<BatesModel>(batesProcess), 160));

    const Real mcTol = 0.1;
    ext::shared_ptr<PricingEngine> mcBatesEngine =
        MakeMCEuropeanHestonEngine<PseudoRandom>(batesProcess)
            .withStepsPerYear(2)
            .withAntitheticVariate()
            .withAbsoluteTolerance(mcTol)
            .withSeed(1234);

    ext::shared_ptr<PricingEngine> mertonEngine(
        new JumpDiffusionEngine(mertonProcess, 1e-10, 1000));

    for (Integer i=1; i<=5; i+=2) {
        Date exerciseDate = settlementDate + i*Years;
        ext::shared_ptr<Exercise> exercise(
            new EuropeanExercise(exerciseDate));

        VanillaOption batesOption(payoff, exercise);

        batesOption.setPricingEngine(batesEngine);
        Real calculated = batesOption.NPV();

        batesOption.setPricingEngine(mcBatesEngine);
        Real mcCalculated = batesOption.NPV();

        EuropeanOption mertonOption(payoff, exercise);
        mertonOption.setPricingEngine(mertonEngine);
        Real expected = mertonOption.NPV();

        Real tolerance = 2e-8;
        Real relError = std::fabs(calculated - expected)/expected;
        if (relError > tolerance) {
            BOOST_FAIL("failed to reproduce Merton76 price with semi "
                       "analytic BatesEngine"
                       << std::fixed << std::setprecision(8)
                       << "\n    calculated: " << calculated
                       << "\n    expected:   " << expected
                       << "\n    rel. error: " << relError
                       << "\n    tolerance:  " << tolerance);
        }

        Real mcError = std::fabs(expected - mcCalculated);
        if (mcError > 3*mcTol) {
            BOOST_FAIL("failed to reproduce Merton76 price with Monte-Carlo "
                       "BatesEngine"
                       << std::fixed << std::setprecision(8)
                       << "\n    calculated: " << mcCalculated
                       << "\n    expected:   " << expected
                       << "\n    error: "      << mcError
                       << "\n    tolerance:  " << mcTol);
        }
    }
}

namespace bates_model_test {
    struct HestonModelData {
        const char* const name;
        Real v0;
        Real kappa;
        Real theta;
        Real sigma;
        Real rho;
        Real r;
        Real q;
    };
    
    HestonModelData hestonModels[] = {
        // ADI finite difference schemes for option pricing in the 
        // Heston model with correlation, K.J. in t'Hout and S. Foulon,
        {"'t Hout case 1", 0.04, 1.5, 0.04, 0.3, -0.9, 0.025, 0.0},
        // Efficient numerical methods for pricing American options under 
        // stochastic volatility, Samuli Ikonen and Jari Toivanen,
        {"Ikonen-Toivanen", 0.0625, 5, 0.16, 0.9, 0.1, 0.1, 0.0},
        // Not-so-complex logarithms in the Heston model, 
        // Christian Kahl and Peter Jckel
        {"Kahl-Jaeckel", 0.16, 1.0, 0.16, 2.0, -0.8, 0.0, 0.0},
        // self defined test cases
        {"Equity case", 0.07, 2.0, 0.04, 0.55, -0.8, 0.03, 0.035 },
    };
}

void BatesModelTest::testAnalyticVsMCPricing() {
    BOOST_TEST_MESSAGE("Testing analytic Bates engine against Monte-Carlo "
                       "engine...");

    using namespace bates_model_test;

    SavedSettings backup;

    Date settlementDate(30, March, 2007);
    Settings::instance().evaluationDate() = settlementDate;

    DayCounter dayCounter = ActualActual(ActualActual::ISDA);
    Date exerciseDate(30, March, 2012);

    ext::shared_ptr<StrikedTypePayoff> payoff(
                                   new PlainVanillaPayoff(Option::Put, 100));
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));


    for (auto& hestonModel : hestonModels) {
        Handle<YieldTermStructure> riskFreeTS(flatRate(hestonModel.r, dayCounter));
        Handle<YieldTermStructure> dividendTS(flatRate(hestonModel.q, dayCounter));
        Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(100)));

        ext::shared_ptr<BatesProcess> batesProcess(new BatesProcess(
            riskFreeTS, dividendTS, s0, hestonModel.v0, hestonModel.kappa, hestonModel.theta,
            hestonModel.sigma, hestonModel.rho, 2.0, -0.2, 0.1));

        const Real mcTolerance = 0.5;
        ext::shared_ptr<PricingEngine> mcEngine =
                MakeMCEuropeanHestonEngine<PseudoRandom>(batesProcess)
                .withStepsPerYear(20)
                .withAntitheticVariate()
                .withAbsoluteTolerance(mcTolerance)
                .withSeed(1234);
    
        ext::shared_ptr<BatesModel> batesModel(new BatesModel(batesProcess));    
        
        ext::shared_ptr<PricingEngine> fdEngine(
                            new FdBatesVanillaEngine(batesModel, 50, 100, 30));
    
        ext::shared_ptr<PricingEngine> analyticEngine(
                                             new BatesEngine(batesModel, 160));
    
        VanillaOption option(payoff, exercise);
    
        option.setPricingEngine(mcEngine);
        const Real calculated = option.NPV();
    
        option.setPricingEngine(analyticEngine);
        const Real expected = option.NPV();
    
        option.setPricingEngine(fdEngine);
        const Real fdCalculated = option.NPV();
        
        const Real mcError = std::fabs(calculated - expected);
        if (mcError > 3*mcTolerance) {
            BOOST_FAIL("failed to reproduce Monte-Carlo price for BatesEngine"
                       << "\n    parameter:  " << hestonModel.name << std::fixed
                       << std::setprecision(8) << "\n    calculated: " << calculated
                       << "\n    expected:   " << expected << "\n    error: " << mcError
                       << "\n    tolerance:  " << mcTolerance);
        }
        const Real fdTolerance = 0.2;
        const Real fdError = std::fabs(fdCalculated - expected);
        if (fdError > fdTolerance) {
            BOOST_FAIL("failed to reproduce PIDE price for BatesEngine"
                       << "\n    parameter:  " << hestonModel.name << std::fixed
                       << std::setprecision(8) << "\n    calculated: " << fdCalculated
                       << "\n    expected:   " << expected << "\n    error: " << fdError
                       << "\n    tolerance:  " << fdTolerance);
        }
    }
}

void BatesModelTest::testDAXCalibration() {
    /* this example is taken from A. Sepp
       Pricing European-Style Options under Jump Diffusion Processes
       with Stochstic Volatility: Applications of Fourier Transform
       http://math.ut.ee/~spartak/papers/stochjumpvols.pdf
    */

    BOOST_TEST_MESSAGE(
             "Testing Bates model calibration using DAX volatility data...");

    using namespace bates_model_test;

    SavedSettings backup;

    Date settlementDate(5, July, 2002);
    Settings::instance().evaluationDate() = settlementDate;

    DayCounter dayCounter = Actual365Fixed();
    Calendar calendar = TARGET();

    Integer t[] = { 13, 41, 75, 165, 256, 345, 524, 703 };
    Rate r[] = { 0.0357,0.0349,0.0341,0.0355,0.0359,0.0368,0.0386,0.0401 };

    std::vector<Date> dates;
    std::vector<Rate> rates;
    dates.push_back(settlementDate);
    rates.push_back(0.0357);
    for (Size i = 0; i < 8; ++i) {
        dates.push_back(settlementDate + t[i]);
        rates.push_back(r[i]);
    }
     // FLOATING_POINT_EXCEPTION
    Handle<YieldTermStructure> riskFreeTS(
                       ext::shared_ptr<YieldTermStructure>(
                                    new ZeroCurve(dates, rates, dayCounter)));

    Handle<YieldTermStructure> dividendTS(
                                   flatRate(settlementDate, 0.0, dayCounter));

    Volatility v[] =
      { 0.6625,0.4875,0.4204,0.3667,0.3431,0.3267,0.3121,0.3121,
        0.6007,0.4543,0.3967,0.3511,0.3279,0.3154,0.2984,0.2921,
        0.5084,0.4221,0.3718,0.3327,0.3155,0.3027,0.2919,0.2889,
        0.4541,0.3869,0.3492,0.3149,0.2963,0.2926,0.2819,0.2800,
        0.4060,0.3607,0.3330,0.2999,0.2887,0.2811,0.2751,0.2775,
        0.3726,0.3396,0.3108,0.2781,0.2788,0.2722,0.2661,0.2686,
        0.3550,0.3277,0.3012,0.2781,0.2781,0.2661,0.2661,0.2681,
        0.3428,0.3209,0.2958,0.2740,0.2688,0.2627,0.2580,0.2620,
        0.3302,0.3062,0.2799,0.2631,0.2573,0.2533,0.2504,0.2544,
        0.3343,0.2959,0.2705,0.2540,0.2504,0.2464,0.2448,0.2462,
        0.3460,0.2845,0.2624,0.2463,0.2425,0.2385,0.2373,0.2422,
        0.3857,0.2860,0.2578,0.2399,0.2357,0.2327,0.2312,0.2351,
        0.3976,0.2860,0.2607,0.2356,0.2297,0.2268,0.2241,0.2320 };

    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(4468.17)));
    Real strike[] = { 3400,3600,3800,4000,4200,4400,
                      4500,4600,4800,5000,5200,5400,5600 };


    Real v0 = 0.0433;
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(std::sqrt(v0)));

    const Real kappa = 1.0;
    const Real theta = v0;
    const Real sigma = 1.0;
    const Real rho = 0.0;
    const Real lambda = 1.1098;
    const Real nu = -0.1285;
    const Real delta = 0.1702;

    ext::shared_ptr<BatesProcess> process(
        new BatesProcess(riskFreeTS, dividendTS, s0, v0, 
                         kappa, theta, sigma, rho, lambda, nu, delta));

    ext::shared_ptr<BatesModel> batesModel(new BatesModel(process));

    ext::shared_ptr<PricingEngine> batesEngine(
                                            new BatesEngine(batesModel, 64));

    std::vector<ext::shared_ptr<BlackCalibrationHelper> > options;

    for (Size s = 0; s < 13; ++s) {
        for (Size m = 0; m < 8; ++m) {
            Handle<Quote> vol(ext::shared_ptr<Quote>(
                                                  new SimpleQuote(v[s*8+m])));

            Period maturity((int)((t[m]+3)/7.), Weeks); // round to weeks

            // this is the calibration helper for the bates models
            options.push_back(ext::shared_ptr<BlackCalibrationHelper>(
                    new HestonModelHelper(maturity, calendar,
                                          s0->value(), strike[s], vol,
                                          riskFreeTS, dividendTS, 
                                          BlackCalibrationHelper::ImpliedVolError)));
            options.back()->setPricingEngine(batesEngine);
        }
    }

    // check calibration engine
    LevenbergMarquardt om;
    batesModel->calibrate(std::vector<ext::shared_ptr<CalibrationHelper> >(options.begin(), options.end()),
                          om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8));

    Real expected = 36.6;
    Real calculated = getCalibrationError(options);

    if (std::fabs(calculated - expected) > 2.5)
        BOOST_ERROR("failed to calibrate the bates model"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected);

    //check pricing of derived engines
    std::vector<ext::shared_ptr<PricingEngine> > pricingEngines;
    
    process = ext::shared_ptr<BatesProcess>(
        new BatesProcess(riskFreeTS, dividendTS, s0, v0, 
                         kappa, theta, sigma, rho, 1.0, -0.1, 0.1));

    pricingEngines.push_back(ext::shared_ptr<PricingEngine>(
        new BatesDetJumpEngine(
            ext::make_shared<BatesDetJumpModel>(
                             process), 64)) );

    ext::shared_ptr<HestonProcess> hestonProcess(new HestonProcess(
                    riskFreeTS, dividendTS, s0, v0, kappa, theta, sigma, rho));

    pricingEngines.push_back(ext::shared_ptr<PricingEngine>(
        new BatesDoubleExpEngine(
            ext::make_shared<BatesDoubleExpModel>(
                         hestonProcess, 1.0), 64)) );

    pricingEngines.push_back(ext::shared_ptr<PricingEngine>(
        new BatesDoubleExpDetJumpEngine(
            ext::make_shared<BatesDoubleExpDetJumpModel>(
                    hestonProcess, 1.0), 64)) );

    Real expectedValues[] = { 5896.37,
                              5499.29,
                              6497.89};

    Real tolerance=0.1;
    for (Size i = 0; i < pricingEngines.size(); ++i) {
        for (auto& option : options) {
            option->setPricingEngine(pricingEngines[i]);
        }

        Real calculated = std::fabs(getCalibrationError(options));
        if (std::fabs(calculated - expectedValues[i]) > tolerance)
            BOOST_ERROR("failed to calculated prices for derived Bates models"
                        << "\n    calculated: " << calculated
                        << "\n    expected:   " << expectedValues[i]);
    }
}

test_suite* BatesModelTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Bates model tests");
    suite->add(QUANTLIB_TEST_CASE(&BatesModelTest::testAnalyticVsBlack));
    suite->add(QUANTLIB_TEST_CASE(
                        &BatesModelTest::testAnalyticAndMcVsJumpDiffusion));
    suite->add(QUANTLIB_TEST_CASE(&BatesModelTest::testAnalyticVsMCPricing));
    // FLOATING_POINT_EXCEPTION
    suite->add(QUANTLIB_TEST_CASE(&BatesModelTest::testDAXCalibration));
    return suite;
}


]]></document_content>
  </document>
  <document index="19">
    <source>batesmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_bates_model_hpp
#define quantlib_test_bates_model_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BatesModelTest {
  public:
    static void testAnalyticVsBlack();
    static void testAnalyticAndMcVsJumpDiffusion();
    static void testAnalyticVsMCPricing();
    static void testDAXCalibration();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="20">
    <source>bermudanswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2007 StatPro Italia srl
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "bermudanswaption.hpp"
#include "utilities.hpp"
#include <ql/instruments/swaption.hpp>
#include <ql/pricingengines/swaption/treeswaptionengine.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/pricingengines/swaption/fdhullwhiteswaptionengine.hpp>
#include <ql/pricingengines/swaption/fdg2swaptionengine.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <ql/cashflows/coupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/time/schedule.hpp>


using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace bermudan_swaption_test {

    struct CommonVars {
        // global data
        Date today, settlement;
        Calendar calendar;

        // underlying swap parameters
        Integer startYears, length;
        Swap::Type type;
        Real nominal;
        BusinessDayConvention fixedConvention, floatingConvention;
        Frequency fixedFrequency, floatingFrequency;
        DayCounter fixedDayCount;
        ext::shared_ptr<IborIndex> index;
        Natural settlementDays;

        RelinkableHandle<YieldTermStructure> termStructure;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            startYears = 1;
            length = 5;
            type = Swap::Payer;
            nominal = 1000.0;
            settlementDays = 2;
            fixedConvention = Unadjusted;
            floatingConvention = ModifiedFollowing;
            fixedFrequency = Annual;
            floatingFrequency = Semiannual;
            fixedDayCount = Thirty360(Thirty360::BondBasis);
            index = ext::shared_ptr<IborIndex>(new Euribor6M(termStructure));
            calendar = index->fixingCalendar();
            today = calendar.adjust(Date::todaysDate());
            settlement = calendar.advance(today,settlementDays,Days);
        }

        // utilities
        ext::shared_ptr<VanillaSwap> makeSwap(Rate fixedRate) const {
            Date start = calendar.advance(settlement, startYears, Years);
            Date maturity = calendar.advance(start, length, Years);
            Schedule fixedSchedule(start, maturity,
                                   Period(fixedFrequency),
                                   calendar,
                                   fixedConvention,
                                   fixedConvention,
                                   DateGeneration::Forward, false);
            Schedule floatSchedule(start, maturity,
                                   Period(floatingFrequency),
                                   calendar,
                                   floatingConvention,
                                   floatingConvention,
                                   DateGeneration::Forward, false);
            ext::shared_ptr<VanillaSwap> swap(
                      new VanillaSwap(type, nominal,
                                      fixedSchedule, fixedRate, fixedDayCount,
                                      floatSchedule, index, 0.0,
                                      index->dayCounter()));
            swap->setPricingEngine(ext::shared_ptr<PricingEngine>(
                                   new DiscountingSwapEngine(termStructure)));
            return swap;
        }
    };

}


void BermudanSwaptionTest::testCachedValues() {

    BOOST_TEST_MESSAGE(
        "Testing Bermudan swaption with HW model against cached values...");

    using namespace bermudan_swaption_test;

    CommonVars vars;

    vars.today = Date(15, February, 2002);

    Settings::instance().evaluationDate() = vars.today;

    vars.settlement = Date(19, February, 2002);
    // flat yield term structure impling 1x5 swap at 5%
    vars.termStructure.linkTo(flatRate(vars.settlement,
                                          0.04875825,
                                          Actual365Fixed()));

    Rate atmRate = vars.makeSwap(0.0)->fairRate();

    ext::shared_ptr<VanillaSwap> itmSwap = vars.makeSwap(0.8*atmRate);
    ext::shared_ptr<VanillaSwap> atmSwap = vars.makeSwap(atmRate);
    ext::shared_ptr<VanillaSwap> otmSwap = vars.makeSwap(1.2*atmRate);

    Real a = 0.048696, sigma = 0.0058904;
    ext::shared_ptr<HullWhite> model(new HullWhite(vars.termStructure,
                                                     a, sigma));
    std::vector<Date> exerciseDates;
    const Leg& leg = atmSwap->fixedLeg();
    for (const auto& i : leg) {
        ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(i);
        exerciseDates.push_back(coupon->accrualStartDate());
    }
    ext::shared_ptr<Exercise> exercise(new BermudanExercise(exerciseDates));

    ext::shared_ptr<PricingEngine> treeEngine(
                                            new TreeSwaptionEngine(model, 50));
    ext::shared_ptr<PricingEngine> fdmEngine(
                                         new FdHullWhiteSwaptionEngine(model));

    Real itmValue,    atmValue,    otmValue;
    Real itmValueFdm, atmValueFdm, otmValueFdm;
    if (!IborCoupon::usingAtParCoupons()) {
        itmValue    = 42.2413,    atmValue = 12.8789,    otmValue = 2.4759;
        itmValueFdm = 42.2111, atmValueFdm = 12.8879, otmValueFdm = 2.44443;
    } else {
        itmValue    = 42.2470,    atmValue = 12.8826,    otmValue = 2.4769;
        itmValueFdm = 42.2091, atmValueFdm = 12.8864, otmValueFdm = 2.4437;
    }

    Real tolerance = 1.0e-4;

    Swaption swaption(itmSwap, exercise);
    swaption.setPricingEngine(treeEngine);
    if (std::fabs(swaption.NPV()-itmValue) > tolerance)
        BOOST_ERROR("failed to reproduce cached in-the-money swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << itmValue);
    swaption.setPricingEngine(fdmEngine);
    if (std::fabs(swaption.NPV()-itmValueFdm) > tolerance)
        BOOST_ERROR("failed to reproduce cached in-the-money swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << itmValueFdm);

    swaption = Swaption(atmSwap, exercise);
    swaption.setPricingEngine(treeEngine);
    if (std::fabs(swaption.NPV()-atmValue) > tolerance)
        BOOST_ERROR("failed to reproduce cached at-the-money swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << atmValue);

    swaption.setPricingEngine(fdmEngine);
    if (std::fabs(swaption.NPV()-atmValueFdm) > tolerance)
        BOOST_ERROR("failed to reproduce cached at-the-money swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << atmValueFdm);

    swaption = Swaption(otmSwap, exercise);
    swaption.setPricingEngine(treeEngine);
    if (std::fabs(swaption.NPV()-otmValue) > tolerance)
        BOOST_ERROR("failed to reproduce cached out-of-the-money "
                    << "swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << otmValue);

    swaption.setPricingEngine(fdmEngine);
    if (std::fabs(swaption.NPV()-otmValueFdm) > tolerance)
        BOOST_ERROR("failed to reproduce cached out-of-the-money "
                    << "swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << otmValueFdm);


    for (auto& exerciseDate : exerciseDates)
        exerciseDate = vars.calendar.adjust(exerciseDate - 10);
    exercise =
        ext::shared_ptr<Exercise>(new BermudanExercise(exerciseDates));

    if (!IborCoupon::usingAtParCoupons()) {
        itmValue = 42.1917; atmValue = 12.7788; otmValue = 2.4388;
    } else {
        itmValue = 42.1974; atmValue = 12.7825; otmValue = 2.4399;
    }

    swaption = Swaption(itmSwap, exercise);
    swaption.setPricingEngine(treeEngine);
    if (std::fabs(swaption.NPV()-itmValue) > tolerance)
        BOOST_ERROR("failed to reproduce cached in-the-money swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << itmValue);
    swaption = Swaption(atmSwap, exercise);
    swaption.setPricingEngine(treeEngine);
    if (std::fabs(swaption.NPV()-atmValue) > tolerance)
        BOOST_ERROR("failed to reproduce cached at-the-money swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << atmValue);
    swaption = Swaption(otmSwap, exercise);
    swaption.setPricingEngine(treeEngine);
    if (std::fabs(swaption.NPV()-otmValue) > tolerance)
        BOOST_ERROR("failed to reproduce cached out-of-the-money "
                    << "swaption value:\n"
                    << "calculated: " << swaption.NPV() << "\n"
                    << "expected:   " << otmValue);
}

void BermudanSwaptionTest::testCachedG2Values() {
    BOOST_TEST_MESSAGE(
        "Testing Bermudan swaption with G2 model against cached values...");

    using namespace bermudan_swaption_test;

    CommonVars vars;

    vars.today = Date(15, September, 2016);
    Settings::instance().evaluationDate() = vars.today;
    vars.settlement = Date(19, September, 2016);

    // flat yield term structure impling 1x5 swap at 5%
    vars.termStructure.linkTo(flatRate(vars.settlement,
                                          0.04875825,
                                          Actual365Fixed()));

    const Rate atmRate = vars.makeSwap(0.0)->fairRate();
    std::vector<ext::shared_ptr<Swaption> > swaptions;
    for (Real s=0.5; s<1.51; s+=0.25) {
        const ext::shared_ptr<VanillaSwap> swap(vars.makeSwap(s*atmRate));

        std::vector<Date> exerciseDates;
        for (const auto& i : swap->fixedLeg()) {
            exerciseDates.push_back(ext::dynamic_pointer_cast<Coupon>(i)->accrualStartDate());
        }
        swaptions.push_back(ext::make_shared<Swaption>(swap,
            ext::make_shared<BermudanExercise>(exerciseDates)));
    }

    const Real a=0.1, sigma=0.01, b=0.2, eta=0.013, rho=-0.5;

    const ext::shared_ptr<G2> g2Model(ext::make_shared<G2>(
        vars.termStructure, a, sigma, b, eta, rho));
    const ext::shared_ptr<PricingEngine> fdmEngine(
        ext::make_shared<FdG2SwaptionEngine>(g2Model, 50, 75, 75, 0, 1e-3));
    const ext::shared_ptr<PricingEngine> treeEngine(
        ext::make_shared<TreeSwaptionEngine>(g2Model, 50));

    Real expectedFdm[5], expectedTree[5];
    if (!IborCoupon::usingAtParCoupons()) {
        Real tmpExpectedFdm[]  = { 103.231, 54.6519, 20.0475, 5.26941, 1.07097 };
        Real tmpExpectedTree[] = { 103.253, 54.6685, 20.1399, 5.40517, 1.10642 };
        std::copy(tmpExpectedFdm,  tmpExpectedFdm + 5,  expectedFdm);
        std::copy(tmpExpectedTree, tmpExpectedTree + 5, expectedTree);
    } else {
        Real tmpExpectedFdm[]  = { 103.227, 54.6502, 20.0469, 5.26924, 1.07093 };
        Real tmpExpectedTree[] = { 103.256, 54.6726, 20.1429, 5.4064 , 1.10677 };
        std::copy(tmpExpectedFdm,  tmpExpectedFdm + 5,  expectedFdm);
        std::copy(tmpExpectedTree, tmpExpectedTree + 5, expectedTree);
    }

    const Real tol = 0.005;
    for (Size i=0; i < swaptions.size(); ++i) {
        swaptions[i]->setPricingEngine(fdmEngine);
        const Real calculatedFdm = swaptions[i]->NPV();

        if (std::fabs(calculatedFdm - expectedFdm[i]) > tol) {
            BOOST_ERROR("failed to reproduce cached G2 FDM swaption value:\n"
                        << "calculated: " << calculatedFdm << "\n"
                        << "expected:   " << expectedFdm[i]);
        }

        swaptions[i]->setPricingEngine(treeEngine);
        const Real calculatedTree = swaptions[i]->NPV();

        if (std::fabs(calculatedTree - expectedTree[i]) > tol) {
            BOOST_ERROR("failed to reproduce cached G2 Tree swaption value:\n"
                        << "calculated: " << calculatedTree << "\n"
                        << "expected:   " << expectedTree[i]);
        }
    }
}

test_suite* BermudanSwaptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Bermudan swaption tests");

    suite->add(QUANTLIB_TEST_CASE(&BermudanSwaptionTest::testCachedValues));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
            &BermudanSwaptionTest::testCachedG2Values));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="21">
    <source>bermudanswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_bermudan_swaption_hpp
#define quantlib_test_bermudan_swaption_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BermudanSwaptionTest {
  public:
    static void testCachedValues();
    static void testCachedG2Values();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="22">
    <source>binaryoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "binaryoption.hpp"
#include "utilities.hpp"
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/barrier/analyticbinarybarrierengine.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancecurve.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancesurface.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, barrierType, barrier, s, q,\
                        r, today, v, expected, calculated, error, tolerance) \
    BOOST_FAIL(payoff->optionType() << " option with " \
               << barrierTypeToString(barrierType) << " barrier type:\n" \
               << "    barrier:          " << barrier << "\n" \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:       " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance << "\n");

namespace binary_option_test {

    std::string barrierTypeToString(Barrier::Type type) {
        switch(type){
          case Barrier::DownIn:
            return std::string("Down-and-in");
          case Barrier::UpIn:
            return std::string("Up-and-in");
          case Barrier::DownOut:
            return std::string("Down-and-out");
          case Barrier::UpOut:
            return std::string("Up-and-out");
          default:
            QL_FAIL("unknown exercise type");
        }
    }

    struct BinaryOptionData {
        Barrier::Type barrierType;
        Real barrier;
        Real cash;     // cash payoff for cash-or-nothing
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // expected result
        Real tol;      // tolerance
    };
}


void BinaryOptionTest::testCashOrNothingHaugValues() {

    BOOST_TEST_MESSAGE("Testing cash-or-nothing barrier options against Haug's values...");

    using namespace binary_option_test;

    BinaryOptionData values[] = {
        /* The data below are from
          "Option pricing formulas 2nd Ed.", E.G. Haug, McGraw-Hill 2007 pag. 180 - cases 13,14,17,18,21,22,25,26
          Note:
            q is the dividend rate, while the book gives b, the cost of carry (q=r-b)
        */
        //    barrierType, barrier,  cash,         type, strike,   spot,    q,    r,   t,  vol,   value, tol
        { Barrier::DownIn,  100.00, 15.00, Option::Call, 102.00, 105.00, 0.00, 0.10, 0.5, 0.20,  4.9289, 1e-4 },
        { Barrier::DownIn,  100.00, 15.00, Option::Call,  98.00, 105.00, 0.00, 0.10, 0.5, 0.20,  6.2150, 1e-4 },
        // following value is wrong in book. 
        { Barrier::UpIn,    100.00, 15.00, Option::Call, 102.00,  95.00, 0.00, 0.10, 0.5, 0.20,  5.8926, 1e-4 },
        { Barrier::UpIn,    100.00, 15.00, Option::Call,  98.00,  95.00, 0.00, 0.10, 0.5, 0.20,  7.4519, 1e-4 },
        // 17,18
        { Barrier::DownIn,  100.00, 15.00, Option::Put,  102.00, 105.00, 0.00, 0.10, 0.5, 0.20,  4.4314, 1e-4 },
        { Barrier::DownIn,  100.00, 15.00, Option::Put,   98.00, 105.00, 0.00, 0.10, 0.5, 0.20,  3.1454, 1e-4 },
        { Barrier::UpIn,    100.00, 15.00, Option::Put,  102.00,  95.00, 0.00, 0.10, 0.5, 0.20,  5.3297, 1e-4 },
        { Barrier::UpIn,    100.00, 15.00, Option::Put,   98.00,  95.00, 0.00, 0.10, 0.5, 0.20,  3.7704, 1e-4 },
        // 21,22
        { Barrier::DownOut, 100.00, 15.00, Option::Call, 102.00, 105.00, 0.00, 0.10, 0.5, 0.20,  4.8758, 1e-4 },
        { Barrier::DownOut, 100.00, 15.00, Option::Call,  98.00, 105.00, 0.00, 0.10, 0.5, 0.20,  4.9081, 1e-4 },
        { Barrier::UpOut,   100.00, 15.00, Option::Call, 102.00,  95.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        { Barrier::UpOut,   100.00, 15.00, Option::Call,  98.00,  95.00, 0.00, 0.10, 0.5, 0.20,  0.0407, 1e-4 },
        // 25,26
        { Barrier::DownOut, 100.00, 15.00, Option::Put,  102.00, 105.00, 0.00, 0.10, 0.5, 0.20,  0.0323, 1e-4 },
        { Barrier::DownOut, 100.00, 15.00, Option::Put,   98.00, 105.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        { Barrier::UpOut,   100.00, 15.00, Option::Put,  102.00,  95.00, 0.00, 0.10, 0.5, 0.20,  3.0461, 1e-4 },
        { Barrier::UpOut,   100.00, 15.00, Option::Put,   98.00,  95.00, 0.00, 0.10, 0.5, 0.20,  3.0054, 1e-4 },

        // other values calculated with book vba
        { Barrier::UpIn,    100.00, 15.00, Option::Call, 102.00,  95.00,-0.14, 0.10, 0.5, 0.20,  8.6806, 1e-4 },
        { Barrier::UpIn,    100.00, 15.00, Option::Call, 102.00,  95.00, 0.03, 0.10, 0.5, 0.20,  5.3112, 1e-4 },
        // degenerate conditions (barrier touched)
        { Barrier::DownIn,  100.00, 15.00, Option::Call,  98.00,  95.00, 0.00, 0.10, 0.5, 0.20,  7.4926, 1e-4 },
        { Barrier::UpIn,    100.00, 15.00, Option::Call,  98.00, 105.00, 0.00, 0.10, 0.5, 0.20, 11.1231, 1e-4 },
        // 17,18
        { Barrier::DownIn,  100.00, 15.00, Option::Put,  102.00,  98.00, 0.00, 0.10, 0.5, 0.20,  7.1344, 1e-4 },
        { Barrier::UpIn,    100.00, 15.00, Option::Put,  102.00, 101.00, 0.00, 0.10, 0.5, 0.20,  5.9299, 1e-4 },
        // 21,22
        { Barrier::DownOut, 100.00, 15.00, Option::Call,  98.00,  99.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        { Barrier::UpOut,   100.00, 15.00, Option::Call,  98.00, 101.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        // 25,26
        { Barrier::DownOut, 100.00, 15.00, Option::Put,   98.00,  99.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        { Barrier::UpOut,   100.00, 15.00, Option::Put,   98.00, 101.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.25));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new CashOrNothingPayoff(value.type, value.strike, value.cash));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                    exDate,
                                                                    true));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                             new AnalyticBinaryBarrierEngine(stochProcess));

        BarrierOption opt(value.barrierType, value.barrier, 0, payoff, amExercise);

        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.barrierType, value.barrier, value.s,
                           value.q, value.r, today, value.v, value.result, calculated, error,
                           value.tol);
        }
    }
}

void BinaryOptionTest::testAssetOrNothingHaugValues() {

    BOOST_TEST_MESSAGE("Testing asset-or-nothing barrier options against Haug's values...");

    using namespace binary_option_test;

    BinaryOptionData values[] = {
        /* The data below are from
          "Option pricing formulas 2nd Ed.", E.G. Haug, McGraw-Hill 2007 pag. 180 - cases 15,16,19,20,23,24,27,28
          Note:
            q is the dividend rate, while the book gives b, the cost of carry (q=r-b)
        */
        //    barrierType, barrier,  cash,         type, strike,   spot,    q,    r,   t,  vol,   value, tol
        { Barrier::DownIn,  100.00,  0.00, Option::Call, 102.00, 105.00, 0.00, 0.10, 0.5, 0.20, 37.2782, 1e-4 },
        { Barrier::DownIn,  100.00,  0.00, Option::Call,  98.00, 105.00, 0.00, 0.10, 0.5, 0.20, 45.8530, 1e-4 },
        { Barrier::UpIn,    100.00,  0.00, Option::Call, 102.00,  95.00, 0.00, 0.10, 0.5, 0.20, 44.5294, 1e-4 },
        { Barrier::UpIn,    100.00,  0.00, Option::Call,  98.00,  95.00, 0.00, 0.10, 0.5, 0.20, 54.9262, 1e-4 },
        // 19,20
        { Barrier::DownIn,  100.00,  0.00, Option::Put,  102.00, 105.00, 0.00, 0.10, 0.5, 0.20, 27.5644, 1e-4 },
        { Barrier::DownIn,  100.00,  0.00, Option::Put,   98.00, 105.00, 0.00, 0.10, 0.5, 0.20, 18.9896, 1e-4 },
        // following value is wrong in book. 
        { Barrier::UpIn,    100.00,  0.00, Option::Put,  102.00,  95.00, 0.00, 0.10, 0.5, 0.20, 33.1723, 1e-4 },
        { Barrier::UpIn,    100.00,  0.00, Option::Put,   98.00,  95.00, 0.00, 0.10, 0.5, 0.20, 22.7755, 1e-4 },
        // 23,24
        { Barrier::DownOut, 100.00,  0.00, Option::Call, 102.00, 105.00, 0.00, 0.10, 0.5, 0.20, 39.9391, 1e-4 },
        { Barrier::DownOut, 100.00,  0.00, Option::Call,  98.00, 105.00, 0.00, 0.10, 0.5, 0.20, 40.1574, 1e-4 },
        { Barrier::UpOut,   100.00,  0.00, Option::Call, 102.00,  95.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        { Barrier::UpOut,   100.00,  0.00, Option::Call,  98.00,  95.00, 0.00, 0.10, 0.5, 0.20,  0.2676, 1e-4 },
        // 27,28
        { Barrier::DownOut, 100.00,  0.00, Option::Put,  102.00, 105.00, 0.00, 0.10, 0.5, 0.20,  0.2183, 1e-4 },
        { Barrier::DownOut, 100.00,  0.00, Option::Put,   98.00, 105.00, 0.00, 0.10, 0.5, 0.20,  0.0000, 1e-4 },
        { Barrier::UpOut,   100.00,  0.00, Option::Put,  102.00,  95.00, 0.00, 0.10, 0.5, 0.20, 17.2983, 1e-4 },
        { Barrier::UpOut,   100.00,  0.00, Option::Put,   98.00,  95.00, 0.00, 0.10, 0.5, 0.20, 17.0306, 1e-4 },
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.25));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new AssetOrNothingPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today, exDate, true));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                             new AnalyticBinaryBarrierEngine(stochProcess));

        BarrierOption opt(value.barrierType, value.barrier, 0, payoff, amExercise);

        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.barrierType, value.barrier, value.s,
                           value.q, value.r, today, value.v, value.result, calculated, error,
                           value.tol);
        }
    }
}

test_suite* BinaryOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Binary");
    suite->add(QUANTLIB_TEST_CASE(&BinaryOptionTest::testCashOrNothingHaugValues));
    suite->add(QUANTLIB_TEST_CASE(&BinaryOptionTest::testAssetOrNothingHaugValues));
    return suite;
}
]]></document_content>
  </document>
  <document index="23">
    <source>binaryoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_binary_option_hpp
#define quantlib_test_binary_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BinaryOptionTest {
  public:
    static void testCashOrNothingHaugValues();
    static void testAssetOrNothingHaugValues();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="24">
    <source>blackdeltacalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "blackdeltacalculator.hpp"
#include "utilities.hpp"
#include <ql/experimental/fx/blackdeltacalculator.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::sqrt;

namespace black_delta_calculator_test {

    struct DeltaData {
        Option::Type ot;
        DeltaVolQuote::DeltaType dt;
        Real spot;
        DiscountFactor dDf;   // domestic discount
        DiscountFactor fDf;   // foreign  discount
        Real stdDev;
        Real strike;
        Real value;
    };

    struct EuropeanOptionData {
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // expected result
        Real tol;      // tolerance
    };

}


void BlackDeltaCalculatorTest::testDeltaValues(){

    BOOST_TEST_MESSAGE("Testing delta calculator values...");

    using namespace black_delta_calculator_test;

    DeltaData values[] = {
        // Values taken from parallel implementation in R
        {Option::Call, DeltaVolQuote::Spot,     1.421, 0.997306, 0.992266,  0.1180654,  1.608080, 0.15},
        {Option::Call, DeltaVolQuote::PaSpot,   1.421, 0.997306, 0.992266,  0.1180654,  1.600545, 0.15},
        {Option::Call, DeltaVolQuote::Fwd,      1.421, 0.997306, 0.992266,  0.1180654,  1.609029, 0.15},
        {Option::Call, DeltaVolQuote::PaFwd,    1.421, 0.997306, 0.992266,  0.1180654,  1.601550, 0.15},
        {Option::Call, DeltaVolQuote::Spot,     122.121,  0.9695434,0.9872347,  0.0887676,  119.8031, 0.67},
        {Option::Call, DeltaVolQuote::PaSpot,   122.121,  0.9695434,0.9872347,  0.0887676,  117.7096, 0.67},
        {Option::Call, DeltaVolQuote::Fwd,      122.121,  0.9695434,0.9872347,  0.0887676,  120.0592, 0.67},
        {Option::Call, DeltaVolQuote::PaFwd,    122.121,  0.9695434,0.9872347,  0.0887676,  118.0532, 0.67},
        {Option::Put,  DeltaVolQuote::Spot,     3.4582,   0.99979, 0.9250616,   0.3199034,  4.964924, -0.821},
        {Option::Put,  DeltaVolQuote::PaSpot,   3.4582,   0.99979, 0.9250616,   0.3199034,  3.778327, -0.821},
        {Option::Put,  DeltaVolQuote::Fwd,      3.4582,   0.99979, 0.9250616,   0.3199034,  4.51896, -0.821},
        {Option::Put,  DeltaVolQuote::PaFwd,    3.4582,   0.99979, 0.9250616,   0.3199034,  3.65728, -0.821},
        // JPYUSD Data taken from Castagnas "FX Options and Smile Risk" (Wiley 2009)
        {Option::Put,  DeltaVolQuote::Spot,     103.00,   0.99482, 0.98508,     0.07247845, 97.47,  -0.25},
        {Option::Put,  DeltaVolQuote::PaSpot,   103.00,   0.99482, 0.98508,     0.07247845, 97.22,  -0.25}
    };

    Option::Type                currOt;
    DeltaVolQuote::DeltaType    currDt;
    Real currSpot;
    Real currdDf;
    Real currfDf;
    Real currStdDev;
    Real currStrike;
    Real expected;
    Real currDelta;
    Real calculated;
    Real error;
    Real tolerance;

    for (Size i=0; i<LENGTH(values); i++) {

        currOt      =values[i].ot;
        currDt      =values[i].dt;
        currSpot    =values[i].spot;
        currdDf     =values[i].dDf;
        currfDf     =values[i].fDf;
        currStdDev  =values[i].stdDev;
        currStrike  =values[i].strike;
        currDelta   =values[i].value;

        BlackDeltaCalculator myCalc(currOt, currDt, currSpot,
                                    currdDf, currfDf, currStdDev);

        tolerance=1.0e-3;

        expected    =currDelta;
        calculated  =myCalc.deltaFromStrike(currStrike);
        error       =std::fabs(calculated-expected);

        if (error>tolerance) {
            BOOST_ERROR("\n Delta-from-strike calculation failed for delta. \n"
                        << "Iteration: "<< i << "\n"
                        << "Calculated Strike:" << calculated << "\n"
                        << "Expected   Strike:" << expected << "\n"
                        << "Error: " << error);
        }

        tolerance=1.0e-2;
        // tolerance not that small, but sufficient for strikes in
        // particular since they might be results of a numerical
        // procedure

        expected    =currStrike;
        calculated  =myCalc.strikeFromDelta(currDelta);
        error       =std::fabs(calculated-expected);

        if (error>tolerance) {
            BOOST_ERROR("\n Strike-from-delta calculation failed for delta. \n"
                        << "Iteration: "<< i << "\n"
                        << "Calculated Strike:" << calculated << "\n"
                        << "Expected   Strike:" << expected << "\n"
                        << "Error: " << error);
        }
    }
}

void BlackDeltaCalculatorTest::testDeltaPriceConsistency() {

    BOOST_TEST_MESSAGE("Testing premium-adjusted delta price consistency...");

    using namespace black_delta_calculator_test;

    // This function tests for price consistencies with the standard
    // Black Scholes calculator, since premium adjusted deltas can be calculated
    // from spot deltas by adding/subtracting the premium.

    SavedSettings backup;

    // actually, value and tol won't be needed for testing
    EuropeanOptionData values[] = {
      //        type, strike,   spot,    rd,    rf,    t,  vol,   value,    tol
      { Option::Call,  0.9123,  1.2212, 0.0231, 0.0000, 0.25, 0.301,  0.0, 0.0},
      { Option::Call,  0.9234,  1.2212, 0.0231, 0.0000, 0.35, 0.111,  0.0, 0.0},
      { Option::Call,  0.9783,  1.2212, 0.0231, 0.0000, 0.45, 0.071,  0.0, 0.0},
      { Option::Call,  1.0000,  1.2212, 0.0231, 0.0000, 0.55, 0.082,  0.0, 0.0},
      { Option::Call,  1.1230,  1.2212, 0.0231, 0.0000, 0.65, 0.012,  0.0, 0.0},
      { Option::Call,  1.2212,  1.2212, 0.0231, 0.0000, 0.75, 0.129,  0.0, 0.0},
      { Option::Call,  1.3212,  1.2212, 0.0231, 0.0000, 0.85, 0.034,  0.0, 0.0},
      { Option::Call,  1.3923,  1.2212, 0.0131, 0.2344, 0.95, 0.001,  0.0, 0.0},
      { Option::Call,  1.3455,  1.2212, 0.0000, 0.0000, 1.00, 0.127,  0.0, 0.0},
      { Option::Put,   0.9123,  1.2212, 0.0231, 0.0000, 0.25, 0.301,  0.0, 0.0},
      { Option::Put,   0.9234,  1.2212, 0.0231, 0.0000, 0.35, 0.111,  0.0, 0.0},
      { Option::Put,   0.9783,  1.2212, 0.0231, 0.0000, 0.45, 0.071,  0.0, 0.0},
      { Option::Put,   1.0000,  1.2212, 0.0231, 0.0000, 0.55, 0.082,  0.0, 0.0},
      { Option::Put,   1.1230,  1.2212, 0.0231, 0.0000, 0.65, 0.012,  0.0, 0.0},
      { Option::Put,   1.2212,  1.2212, 0.0231, 0.0000, 0.75, 0.129,  0.0, 0.0},
      { Option::Put,   1.3212,  1.2212, 0.0231, 0.0000, 0.85, 0.034,  0.0, 0.0},
      { Option::Put,   1.3923,  1.2212, 0.0131, 0.2344, 0.95, 0.001,  0.0, 0.0},
      { Option::Put,   1.3455,  1.2212, 0.0000, 0.0000, 1.00, 0.127,  0.0, 0.0},
      // extreme case: zero vol
      { Option::Put,   1.3455,  1.2212, 0.0000, 0.0000, 0.50, 0.000,  0.0, 0.0},
      // extreme case: zero strike
      { Option::Put,   0.0000,  1.2212, 0.0000, 0.0000, 1.50, 0.133,  0.0, 0.0},
      // extreme case: zero strike+zero vol
      { Option::Put,   0.0000,  1.2212, 0.0000, 0.0000, 1.00, 0.133,  0.0, 0.0},
    };

    DayCounter dc       = Actual360();
    Calendar calendar   = TARGET();
    Date today          = Date::todaysDate();

    // Start setup of market data

    Real discFor        =0.0;
    Real discDom        =0.0;
    Real implVol        =0.0;
    Real expectedVal    =0.0;
    Real calculatedVal  =0.0;
    Real error          =0.0;

    ext::shared_ptr<SimpleQuote> spotQuote(new SimpleQuote(0.0));
    Handle<Quote> spotHandle(spotQuote);

    ext::shared_ptr<SimpleQuote> qQuote(new SimpleQuote(0.0));
    Handle<Quote> qHandle(qQuote);
    ext::shared_ptr<YieldTermStructure> qTS(
                                         new FlatForward(today, qHandle, dc));

    ext::shared_ptr<SimpleQuote> rQuote(new SimpleQuote(0.0));
    Handle<Quote> rHandle(qQuote);
    ext::shared_ptr<YieldTermStructure> rTS(
                                         new FlatForward(today, rHandle, dc));

    ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote(0.0));
    Handle<Quote> volHandle(volQuote);
    ext::shared_ptr<BlackVolTermStructure> volTS(
                        new BlackConstantVol(today, calendar, volHandle, dc));

    ext::shared_ptr<BlackScholesMertonProcess>    stochProcess;
    ext::shared_ptr<PricingEngine>                engine;
    ext::shared_ptr<StrikedTypePayoff>            payoff;
    Date exDate;
    ext::shared_ptr<Exercise>                     exercise;
    // Setup of market data finished

    Real tolerance=1.0e-10;

    for (auto& value : values) {

        payoff =
            ext::shared_ptr<StrikedTypePayoff>(new PlainVanillaPayoff(value.type, value.strike));
        exDate = today + timeToDays(value.t);
        exercise = ext::shared_ptr<Exercise>(new EuropeanExercise(exDate));

        spotQuote->setValue(value.s);
        volQuote->setValue(value.v);
        rQuote->setValue(value.r);
        qQuote->setValue(value.q);

        discDom =rTS->discount(exDate);
        discFor =qTS->discount(exDate);
        implVol =sqrt(volTS->blackVariance(exDate,0.0));

        BlackDeltaCalculator myCalc(value.type, DeltaVolQuote::PaSpot, spotQuote->value(), discDom,
                                    discFor, implVol);

        stochProcess=ext::make_shared<BlackScholesMertonProcess> (spotHandle,
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS));

        engine = ext::shared_ptr<PricingEngine>(
                                    new AnalyticEuropeanEngine(stochProcess));

        EuropeanOption option(payoff, exercise);
        option.setPricingEngine(engine);

        calculatedVal = myCalc.deltaFromStrike(value.strike);

        Real delta = 0.0;
        if (implVol > 0.0) {
            delta = option.delta();
        }
        else {
            const Real fwd = spotQuote->value()*discFor/discDom;
            if (payoff->optionType() == Option::Call && fwd > payoff->strike())
                delta = 1.0;
            else if (payoff->optionType() == Option::Put && fwd < payoff->strike())
                delta = -1.0;
        }

        expectedVal=delta-option.NPV()/spotQuote->value();

        error=std::fabs(expectedVal-calculatedVal);

        if(error>tolerance){
            BOOST_ERROR("\n Premium-adjusted spot delta test failed. \n" \
                        << "Calculated Delta: " << calculatedVal << "\n"
                        << "Expected Value:   " << expectedVal << "\n"
                        << "Error: "<< error);
        }

        myCalc.setDeltaType(DeltaVolQuote::PaFwd);

        calculatedVal = myCalc.deltaFromStrike(value.strike);
        expectedVal=expectedVal/discFor; // Premium adjusted Fwd Delta is PA spot without discount
        error=std::fabs(expectedVal-calculatedVal);

        if(error>tolerance){
            BOOST_ERROR("\n Premium-adjusted forward delta test failed. \n"
                        << "Calculated Delta: " << calculatedVal << "\n"
                        << "Expected Value:   " << expectedVal << "\n"
                        << "Error: "<< error);
        }


        // Test consistency with BlackScholes Calculator for Spot Delta
        myCalc.setDeltaType(DeltaVolQuote::Spot);

        calculatedVal = myCalc.deltaFromStrike(value.strike);
        expectedVal=delta;
        error=std::fabs(calculatedVal-expectedVal);

        if(error>tolerance){
            BOOST_ERROR("\n spot delta in BlackDeltaCalculator differs "
                        "from delta in BlackScholesCalculator. \n"
                        << "Calculated Value: " << calculatedVal << "\n"
                        << "Expected Value:   " << expectedVal << "\n"
                        << "Error: " << error);
        }
    }
}

void BlackDeltaCalculatorTest::testPutCallParity(){

    BOOST_TEST_MESSAGE("Testing put-call parity for deltas...");

    using namespace black_delta_calculator_test;

    // Test for put call parity between put and call deltas.

    SavedSettings backup;

    /* The data below are from
       "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
       pag 11-16
    */

    EuropeanOptionData values[] = {
      // pag 2-8
      //        type, strike,   spot,    q,    r,    t,  vol,   value,    tol
      { Option::Call,  65.00,  60.00, 0.00, 0.08, 0.25, 0.30,  2.1334, 1.0e-4},
      { Option::Put,   95.00, 100.00, 0.05, 0.10, 0.50, 0.20,  2.4648, 1.0e-4},
      { Option::Put,   19.00,  19.00, 0.10, 0.10, 0.75, 0.28,  1.7011, 1.0e-4},
      { Option::Call,  19.00,  19.00, 0.10, 0.10, 0.75, 0.28,  1.7011, 1.0e-4},
      { Option::Call,   1.60,   1.56, 0.08, 0.06, 0.50, 0.12,  0.0291, 1.0e-4},
      { Option::Put,   70.00,  75.00, 0.05, 0.10, 0.50, 0.35,  4.0870, 1.0e-4},
      // pag 24
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.15,  0.0205, 1.0e-4},
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.15,  1.8734, 1.0e-4},
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.15,  9.9413, 1.0e-4},
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.25,  0.3150, 1.0e-4},
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.25,  3.1217, 1.0e-4},
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.25, 10.3556, 1.0e-4},
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.35,  0.9474, 1.0e-4},
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.35,  4.3693, 1.0e-4},
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.35, 11.1381, 1.0e-4},
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.15,  0.8069, 1.0e-4},
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.15,  4.0232, 1.0e-4},
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.15, 10.5769, 1.0e-4},
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.25,  2.7026, 1.0e-4},
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.25,  6.6997, 1.0e-4},
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.25, 12.7857, 1.0e-4},
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.35,  4.9329, 1.0e-4},
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.35,  9.3679, 1.0e-4},
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.35, 15.3086, 1.0e-4},
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.15,  9.9210, 1.0e-4},
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.15,  1.8734, 1.0e-4},
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.15,  0.0408, 1.0e-4},
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.25, 10.2155, 1.0e-4},
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.25,  3.1217, 1.0e-4},
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.25,  0.4551, 1.0e-4},
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.35, 10.8479, 1.0e-4},
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.35,  4.3693, 1.0e-4},
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.35,  1.2376, 1.0e-4},
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.15, 10.3192, 1.0e-4},
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.15,  4.0232, 1.0e-4},
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.15,  1.0646, 1.0e-4},
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.25, 12.2149, 1.0e-4},
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.25,  6.6997, 1.0e-4},
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.25,  3.2734, 1.0e-4},
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.35, 14.4452, 1.0e-4},
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.35,  9.3679, 1.0e-4},
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.35,  5.7963, 1.0e-4},
      // pag 27
      { Option::Call,  40.00,  42.00, 0.08, 0.04, 0.75, 0.35,  5.0975, 1.0e-4}
    };

    DayCounter dc = Actual360();
    Calendar calendar = TARGET();
    Date today = Date::todaysDate();

    Real discFor        =0.0;
    Real discDom        =0.0;
    Real implVol        =0.0;
    Real deltaCall      =0.0;
    Real deltaPut       =0.0;
    Real expectedDiff   =0.0;
    Real calculatedDiff =0.0;
    Real error          =0.0;
    Real forward        =0.0;

    ext::shared_ptr<SimpleQuote> spotQuote(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qQuote(new SimpleQuote(0.0));
    Handle<Quote> qHandle(qQuote);
    ext::shared_ptr<YieldTermStructure> qTS(
                                         new FlatForward(today, qHandle, dc));

    ext::shared_ptr<SimpleQuote> rQuote(new SimpleQuote(0.0));
    Handle<Quote> rHandle(qQuote);
    ext::shared_ptr<YieldTermStructure> rTS(
                                         new FlatForward(today, rHandle, dc));

    ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote(0.0));
    Handle<Quote> volHandle(volQuote);
    ext::shared_ptr<BlackVolTermStructure> volTS(
                        new BlackConstantVol(today, calendar, volHandle, dc));

    ext::shared_ptr<StrikedTypePayoff> payoff;
    Date exDate;
    ext::shared_ptr<Exercise> exercise;

    Real tolerance=1.0e-10;

    for (auto& value : values) {

        payoff =
            ext::shared_ptr<StrikedTypePayoff>(new PlainVanillaPayoff(Option::Call, value.strike));
        exDate = today + timeToDays(value.t);
        exercise = ext::shared_ptr<Exercise>(new EuropeanExercise(exDate));

        spotQuote->setValue(value.s);
        volQuote->setValue(value.v);
        rQuote->setValue(value.r);
        qQuote->setValue(value.q);
        discDom=rTS->discount(exDate);
        discFor=qTS->discount(exDate);
        implVol=sqrt(volTS->blackVariance(exDate,0.0));
        forward=spotQuote->value()*discFor/discDom;

        BlackDeltaCalculator myCalc(Option::Call, DeltaVolQuote::Spot,
                                    spotQuote->value(),
                                    discDom, discFor, implVol);

        deltaCall = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Put);
        deltaPut = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Call);

        expectedDiff=discFor;
        calculatedDiff=deltaCall-deltaPut;
        error=std::fabs(expectedDiff-calculatedDiff);

        if(error>tolerance){
            BOOST_ERROR("\n Put-call parity failed for spot delta. \n"
                        << "Calculated Call Delta: " << deltaCall << "\n"
                        << "Calculated Put Delta:  " << deltaPut << "\n"
                        << "Expected Difference:   " << expectedDiff << "\n"
                        << "Calculated Difference: " << calculatedDiff);
        }
        myCalc.setDeltaType(DeltaVolQuote::Fwd);

        deltaCall = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Put);
        deltaPut = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Call);

        expectedDiff=1.0;
        calculatedDiff=deltaCall-deltaPut;
        error=std::fabs(expectedDiff-calculatedDiff);

        if(error>tolerance){
            BOOST_ERROR("\n Put-call parity failed for forward delta. \n"
                        << "Calculated Call Delta: " << deltaCall << "\n"
                        << "Calculated Put Delta:  " << deltaPut << "\n"
                        << "Expected Difference:   " << expectedDiff << "\n"
                        << "Calculated Difference: " << calculatedDiff );
        }

        myCalc.setDeltaType(DeltaVolQuote::PaSpot);

        deltaCall = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Put);
        deltaPut = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Call);

        expectedDiff = discFor * value.strike / forward;
        calculatedDiff=deltaCall-deltaPut;
        error=std::fabs(expectedDiff-calculatedDiff);

        if(error>tolerance){
            BOOST_ERROR("\n Put-call parity failed for "
                        "premium-adjusted spot delta. \n"
                        << "Calculated Call Delta: " << deltaCall << "\n"
                        << "Calculated Put Delta:  " << deltaPut << "\n"
                        << "Expected Difference:   " << expectedDiff << "\n"
                        << "Calculated Difference: " << calculatedDiff);
        }

        myCalc.setDeltaType(DeltaVolQuote::PaFwd);

        deltaCall = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Put);
        deltaPut = myCalc.deltaFromStrike(value.strike);
        ;
        myCalc.setOptionType(Option::Call);

        expectedDiff = value.strike / forward;
        calculatedDiff=deltaCall-deltaPut;
        error=std::fabs(expectedDiff-calculatedDiff);

        if(error>tolerance){
            BOOST_ERROR("\n Put-call parity failed for premium-adjusted "
                        "forward delta. \n"
                        << "Calculated Call Delta: " << deltaCall << "\n"
                        << "Calculated Put Delta:  " << deltaPut << "\n"
                        << "Expected Difference:   " << expectedDiff << "\n"
                        << "Calculated Difference: " << calculatedDiff);
        }
    }
}

void BlackDeltaCalculatorTest::testAtmCalcs(){

    BOOST_TEST_MESSAGE("Testing delta-neutral ATM quotations...");

    using namespace black_delta_calculator_test;

    SavedSettings backup;

    DeltaData values[] = {
        {Option::Call, DeltaVolQuote::Spot,     1.421, 0.997306, 0.992266,          0.1180654,  1.608080, 0.15},
        {Option::Call, DeltaVolQuote::PaSpot,   1.421, 0.997306, 0.992266,      0.1180654,  1.600545, 0.15},
        {Option::Call, DeltaVolQuote::Fwd,      1.421, 0.997306, 0.992266,      0.1180654,  1.609029, 0.15},
        {Option::Call, DeltaVolQuote::PaFwd,    1.421, 0.997306, 0.992266,      0.1180654,  1.601550, 0.15},
        {Option::Call, DeltaVolQuote::Spot,     122.121,  0.9695434,0.9872347,  0.0887676,  119.8031, 0.67},
        {Option::Call, DeltaVolQuote::PaSpot,   122.121,  0.9695434,0.9872347,  0.0887676,  117.7096, 0.67},
        {Option::Call, DeltaVolQuote::Fwd,      122.121,  0.9695434,0.9872347,  0.0887676,  120.0592, 0.67},
        {Option::Call, DeltaVolQuote::PaFwd,    122.121,  0.9695434,0.9872347,  0.0887676,  118.0532, 0.67},
        {Option::Put,  DeltaVolQuote::Spot,     3.4582,   0.99979, 0.9250616,   0.3199034,  4.964924, -0.821},
        {Option::Put,  DeltaVolQuote::PaSpot,   3.4582,   0.99979, 0.9250616,   0.3199034,  3.778327, -0.821},
        {Option::Put,  DeltaVolQuote::Fwd,      3.4582,   0.99979, 0.9250616,   0.3199034,  4.51896, -0.821},
        {Option::Put,  DeltaVolQuote::PaFwd,    3.4582,   0.99979, 0.9250616,   0.3199034,  3.65728, -0.821},
        // Data taken from Castagnas "FX Options and Smile Risk" (Wiley 2009)
        {Option::Put,  DeltaVolQuote::Spot,     103.00,   0.99482, 0.98508,     0.07247845, 97.47,  -0.25},
        {Option::Put,  DeltaVolQuote::PaSpot,   103.00,   0.99482, 0.98508,     0.07247845, 97.22,  -0.25},
        // Extreme case: zero vol, ATM Fwd strike
        {Option::Call,  DeltaVolQuote::Fwd, 103.00,     0.99482, 0.98508,       0.0,    101.0013,0.5},
        {Option::Call,  DeltaVolQuote::Spot,    103.00,   0.99482, 0.98508,     0.0,    101.0013,0.99482*0.5}
    };

    DeltaVolQuote::DeltaType    currDt;
    Real currSpot;
    Real currdDf;
    Real currfDf;
    Real currStdDev;
    Real expected;
    Real calculated;
    Real error;
    Real tolerance=1.0e-2; // not that small, but sufficient for strikes
    Real currAtmStrike;
    Real currCallDelta;
    Real currPutDelta;
    Real currFwd;

    for (Size i=0; i<LENGTH(values); i++) {

        currDt      =values[i].dt;
        currSpot    =values[i].spot;
        currdDf     =values[i].dDf;
        currfDf     =values[i].fDf;
        currStdDev  =values[i].stdDev;
        currFwd     =currSpot*currfDf/currdDf;

        BlackDeltaCalculator myCalc(Option::Call, currDt, currSpot, currdDf,
                                    currfDf, currStdDev);

        currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
        currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Put);
        currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Call);

        expected    =0.0;
        calculated  =currCallDelta+currPutDelta;
        error       =std::fabs(calculated-expected);

        if(error>tolerance){
            BOOST_ERROR("\n Delta neutrality failed for spot delta "
                        "in Delta Calculator. \n"
                        << "Iteration: "<< i << "\n"
                        << "Calculated Delta Sum: " << calculated << "\n"
                        << "Expected Delta Sum:   " << expected << "\n"
                        << "Error: "                << error);
        }

        myCalc.setDeltaType(DeltaVolQuote::Fwd);
        currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
        currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Put);
        currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Call);

        expected    =0.0;
        calculated  =currCallDelta+currPutDelta;
        error       =std::fabs(calculated-expected);

        if(error>tolerance){
            BOOST_ERROR("\n Delta neutrality failed for forward delta "
                        "in Delta Calculator. \n"
                        << "Iteration: " << i << "\n"
                        << "Calculated Delta Sum: " << calculated << "\n"
                        << "Expected Delta Sum:   " << expected << "\n"
                        << "Error: "                << error);
        }

        myCalc.setDeltaType(DeltaVolQuote::PaSpot);
        currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
        currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Put);
        currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Call);

        expected    =0.0;
        calculated  =currCallDelta+currPutDelta;
        error       =std::fabs(calculated-expected);

        if(error>tolerance){
            BOOST_ERROR("\n Delta neutrality failed for premium-adjusted "
                        "spot delta in Delta Calculator. \n"
                        << "Iteration: " << i << "\n"
                        << "Calculated Delta Sum: " << calculated << "\n"
                        << "Expected Delta Sum:   " << expected << "\n"
                        << "Error: "                << error);
        }


        myCalc.setDeltaType(DeltaVolQuote::PaFwd);
        currAtmStrike=myCalc.atmStrike(DeltaVolQuote::AtmDeltaNeutral);
        currCallDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Put);
        currPutDelta=myCalc.deltaFromStrike(currAtmStrike);
        myCalc.setOptionType(Option::Call);

        expected    =0.0;
        calculated  =currCallDelta+currPutDelta;
        error       =std::fabs(calculated-expected);

        if(error>tolerance){
            BOOST_ERROR("\n Delta neutrality failed for premium-adjusted "
                        "forward delta in Delta Calculator. \n"
                        << "Iteration: " << i << "\n"
                        << "Calculated Delta Sum: " << calculated << "\n"
                        << "Expected Delta Sum:   " << expected << "\n"
                        << "Error: " << error);
        }

        // Test ATM forward Calculations
        calculated=myCalc.atmStrike(DeltaVolQuote::AtmFwd);
        expected=currFwd;
        error=std::fabs(expected-calculated);

        if(error>tolerance){
            BOOST_ERROR("\n Atm forward test failed. \n"
                        << "Calculated Value: " << calculated << "\n"
                        << "Expected   Value: " << expected << "\n"
                        << "Error: " << error);
        }

        // Test ATM 0.50 delta calculations
        myCalc.setDeltaType(DeltaVolQuote::Fwd);
        Real atmFiftyStrike=myCalc.atmStrike(DeltaVolQuote::AtmPutCall50);
        calculated=std::fabs(myCalc.deltaFromStrike(atmFiftyStrike));
        expected=0.50;
        error=std::fabs(expected-calculated);

        if(error>tolerance){
            BOOST_ERROR("\n Atm 0.50 delta strike test failed. \n"
                        << "Iteration:" << i << "\n"
                        << "Calculated Value: " << calculated << "\n"
                        << "Expected   Value: " << expected << "\n"
                        << "Error: "    << error);
        }
    }
}




test_suite* BlackDeltaCalculatorTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Black delta calculator tests");
    suite->add(QUANTLIB_TEST_CASE(&BlackDeltaCalculatorTest::testDeltaValues));
    suite->add(QUANTLIB_TEST_CASE(
                       &BlackDeltaCalculatorTest::testDeltaPriceConsistency));
    suite->add(QUANTLIB_TEST_CASE(
                       &BlackDeltaCalculatorTest::testPutCallParity));
    suite->add(QUANTLIB_TEST_CASE(&BlackDeltaCalculatorTest::testAtmCalcs));

    return suite;
}
]]></document_content>
  </document>
  <document index="25">
    <source>blackdeltacalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_black_delta_calculator_test_hpp
#define quantlib_black_delta_calculator_test_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BlackDeltaCalculatorTest {
  public:
    static void testDeltaValues();
    static void testDeltaPriceConsistency();
    static void testPutCallParity();
    static void testAtmCalcs();

    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="26">
    <source>blackformula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Gary Kennedy
 Copyright (C) 2015 Peter Caspers
 Copyright (C) 2017 Klaus Spanderen
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include "blackformula.hpp"
#include "utilities.hpp"
#include <ql/pricingengines/blackformula.hpp>
#include <cmath>

using namespace QuantLib;
using namespace boost::unit_test_framework;


void BlackFormulaTest::testBachelierImpliedVol(){


    BOOST_TEST_MESSAGE("Testing Bachelier implied vol...");

    Real forward = 1.0;
    Real bpvol = 0.01;
    Real tte = 10.0;
    Real stdDev = bpvol*std::sqrt(tte);
    Option::Type optionType = Option::Call;
    Real discount = 0.95;

    Real d[] = {-3.0, -2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0, 3.0};
    for (double i : d) {


        Real strike = forward - i * bpvol * std::sqrt(tte);

        Real callPrem = bachelierBlackFormula(optionType, strike, forward, stdDev, discount);

        Real impliedBpVol = bachelierBlackFormulaImpliedVol(optionType,strike, forward, tte, callPrem, discount);

        if (std::fabs(bpvol-impliedBpVol)>1.0e-12){
            BOOST_ERROR("Failed, expected " << bpvol << " realised " << impliedBpVol );
        }
    }
}

void BlackFormulaTest::testChambersImpliedVol() {

    BOOST_TEST_MESSAGE("Testing Chambers-Nawalkha implied vol approximation...");

    Option::Type types[] = {Option::Call, Option::Put};
    Real displacements[] = {0.0000, 0.0010, 0.0050, 0.0100, 0.0200};
    Real forwards[] = {-0.0010, 0.0000, 0.0050, 0.0100, 0.0200, 0.0500};
    Real strikes[] = {-0.0100, -0.0050, -0.0010, 0.0000, 0.0010, 0.0050,
                      0.0100,  0.0200,  0.0500,  0.1000};
    Real stdDevs[] = {0.10, 0.15, 0.20, 0.30, 0.50, 0.60, 0.70,
                      0.80, 1.00, 1.50, 2.00};
    Real discounts[] = {1.00, 0.95, 0.80, 1.10};

    Real tol = 5.0E-4;

    for (auto& type : types) {
        for (double& displacement : displacements) {
            for (double& forward : forwards) {
                for (double& strike : strikes) {
                    for (double& stdDev : stdDevs) {
                        for (double& discount : discounts) {
                            if (forward + displacement > 0.0 && strike + displacement > 0.0) {
                                Real premium = blackFormula(type, strike, forward, stdDev, discount,
                                                            displacement);
                                Real atmPremium = blackFormula(type, forward, forward, stdDev,
                                                               discount, displacement);
                                Real iStdDev = blackFormulaImpliedStdDevChambers(
                                    type, strike, forward, premium, atmPremium, discount,
                                    displacement);
                                Real moneyness = (strike + displacement) / (forward + displacement);
                                if(moneyness > 1.0) moneyness = 1.0 / moneyness;
                                Real error = (iStdDev - stdDev) / stdDev * moneyness;
                                if(error > tol)
                                    BOOST_ERROR("Failed to verify Chambers-Nawalkha "
                                                "approximation for "
                                                << type << " displacement=" << displacement
                                                << " forward=" << forward << " strike=" << strike
                                                << " discount=" << discount << " stddev=" << stdDev
                                                << " result=" << iStdDev
                                                << " exceeds maximum error tolerance");
                            }
                        }
                    }
                }
            }
        }
    }
}

void BlackFormulaTest::testRadoicicStefanicaImpliedVol() {

    BOOST_TEST_MESSAGE(
        "Testing Radoicic-Stefanica implied vol approximation...");

    const Time T = 1.7;
    const Rate r = 0.1;
    const DiscountFactor df = std::exp(-r*T);

    const Real forward = 100;

    const Volatility vol = 0.3;
    const Real stdDev = vol * std::sqrt(T);

    const Option::Type types[] = { Option::Call, Option::Put };
    const Real strikes[] = {
        50, 60, 70, 80, 90, 100, 110, 125, 150, 200, 300 };

    const Real tol = 0.02;

    for (double strike : strikes) {
        for (auto type : types) {
            const ext::shared_ptr<PlainVanillaPayoff> payoff(
                ext::make_shared<PlainVanillaPayoff>(type, strike));

            const Real marketValue = blackFormula(payoff, forward, stdDev, df);

            const Real estVol = blackFormulaImpliedStdDevApproximationRS(
                payoff, forward, marketValue, df) / std::sqrt(T);

            const Real error = std::fabs(estVol - vol);
            if (error > tol) {
                BOOST_ERROR("Failed to verify Radoicic-Stefanica"
                    "approximation for "
                    << type
                    << "\n forward     :" << forward
                    << "\n strike      :" << strike
                    << "\n discount    :" << df
                    << "\n implied vol :" << vol
                    << "\n result      :" << estVol
                    << "\n error       :" << error
                    << "\n tolerance   :" << tol);
            }
        }
    }
}

void BlackFormulaTest::testRadoicicStefanicaLowerBound() {

    BOOST_TEST_MESSAGE("Testing Radoicic-Stefanica lower bound...");

    // testing lower bound plot figure 3.1 from
    // "Tighter Bounds for Implied Volatility",
    // J. Gatheral, I. Matic, R. Radoicic, D. Stefanica
    // https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2922742

    const Real forward = 1.0;
    const Real k = 1.2;

    for (Real s=0.17; s < 2.9; s+=0.01) {
        const Real strike = std::exp(k)*forward;
        const Real c = blackFormula(Option::Call, strike, forward, s);
        const Real estimate = blackFormulaImpliedStdDevApproximationRS(
            Option::Call, strike, forward, c);

        const Real error = s - estimate;
        if (std::isnan(estimate) || std::fabs(error) > 0.05) {
            BOOST_ERROR("Failed to lower bound Radoicic-Stefanica"
                "approximation for "
                << "\n forward     :" << forward
                << "\n strike      :" << k
                << "\n stdDev      :" << s
                << "\n result      :" << estimate
                << "\n error       :" << error);

        }

        if (c > 1e-6 && error < 0.0) {
            BOOST_ERROR("Failed to verify Radoicic-Stefanica is lower bound"
                    << "\n forward     :" << forward
                    << "\n strike      :" << k
                    << "\n stdDev      :" << s
                    << "\n result      :" << estimate
                    << "\n error       :" << error);
        }
    }
}

void BlackFormulaTest::testImpliedVolAdaptiveSuccessiveOverRelaxation() {
    BOOST_TEST_MESSAGE("Testing implied volatility calculation via "
        "adaptive successive over-relaxation...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(12, July, 2017);
    Settings::instance().evaluationDate() = today;

    const Date exerciseDate = today + Period(15, Months);
    const Time exerciseTime = dc.yearFraction(today, exerciseDate);

    const ext::shared_ptr<YieldTermStructure> rTS = flatRate(0.10, dc);
    const ext::shared_ptr<YieldTermStructure> qTS = flatRate(0.06, dc);

    const DiscountFactor df = rTS->discount(exerciseDate);

    const Volatility vol = 0.20;
    const Real stdDev = vol * std::sqrt(exerciseTime);

    const Real s0     = 100;
    const Real forward= s0 * qTS->discount(exerciseDate)/df;

    const Option::Type types[] = { Option::Call, Option::Put };
    const Real strikes[] = { 50, 60, 70, 80, 90, 100, 110, 125, 150, 200 };
    const Real displacements[] = { 0, 25, 50, 100};

    const Real tol = 1e-8;

    for (double strike : strikes) {
        for (auto type : types) {
            const ext::shared_ptr<PlainVanillaPayoff> payoff(
                ext::make_shared<PlainVanillaPayoff>(type, strike));

            for (double displacement : displacements) {

                const Real marketValue = blackFormula(payoff, forward, stdDev, df, displacement);

                const Real impliedStdDev = blackFormulaImpliedStdDevLiRS(
                    payoff, forward, marketValue, df, displacement,
                    Null<Real>(), 1.0, tol, 100);

                const Real error = std::fabs(impliedStdDev - stdDev);
                if (error > 10*tol) {
                    BOOST_ERROR("Failed to calculated implied volatility"
                                " with adaptive successive over-relaxation"
                            << "\n forward     :" << forward
                            << "\n strike      :" << strike
                            << "\n stdDev      :" << stdDev
                            << "\n displacement:" << displacement
                            << "\n result      :" << impliedStdDev
                            << "\n error       :" << error
                            << "\n tolerance   :" << tol);
                }
            }
        }
    }
}

void assertBlackFormulaForwardDerivative(
    Option::Type optionType,
    const std::vector<Real> &strikes,
    Real bpvol)
{
    Real forward = 1.0;
    Real tte = 10.0;
    Real stdDev = bpvol * std::sqrt(tte);
    Real discount = 0.95;
    Real displacement = 0.01;
    Real bump = 0.0001;
    Real epsilon = 1.e-10;
    std::string type = optionType == Option::Call ? "Call" : "Put";

    for (double strike : strikes) {
        Real delta = blackFormulaForwardDerivative(optionType, strike, forward, stdDev, discount,
                                                   displacement);
        Real bumpedDelta = blackFormulaForwardDerivative(
            optionType, strike, forward + bump, stdDev, discount, displacement);

        Real basePremium = blackFormula(
            optionType, strike, forward, stdDev, discount, displacement);
        Real bumpedPremium = blackFormula(
            optionType, strike, forward + bump, stdDev, discount, displacement);
        Real deltaApprox = (bumpedPremium - basePremium) / bump;

        /*! Based on the Mean Value Theorem, the below inequality
            should hold for any function that is monotonic in the
            area of the bump.
         */
        bool success =
            (std::max(delta, bumpedDelta) + epsilon > deltaApprox)
            &&  (deltaApprox > std::min(delta, bumpedDelta) - epsilon);

        if (!success)
        {
            BOOST_ERROR("Failed to calculate the derivative of the"
                        " Black formula w.r.t. forward"
                        << "\n option type       :" << type
                        << "\n forward           :" << forward
                        << "\n strike            :" << strike
                        << "\n stdDev            :" << stdDev
                        << "\n displacement      :" << displacement
                        << "\n analytical delta  :" << delta
                        << "\n approximated delta:" << deltaApprox);
        }
    }
}

void BlackFormulaTest::testBlackFormulaForwardDerivative() {

    BOOST_TEST_MESSAGE("Testing forward derivative of the Black formula...");

    std::vector<Real> strikes;
    strikes.push_back(0.1);
    strikes.push_back(0.5);
    strikes.push_back(1.0);
    strikes.push_back(2.0);
    strikes.push_back(3.0);
    const Real vol = 0.1;
    assertBlackFormulaForwardDerivative(Option::Call, strikes, vol);
    assertBlackFormulaForwardDerivative(Option::Put, strikes, vol);
}

void BlackFormulaTest::testBlackFormulaForwardDerivativeWithZeroStrike() {

    BOOST_TEST_MESSAGE("Testing forward derivative of the Black formula "
        "with zero strike...");

    std::vector<Real> strikes;
    strikes.push_back(0.0);
    const Real vol = 0.1;
    assertBlackFormulaForwardDerivative(Option::Call, strikes, vol);
    assertBlackFormulaForwardDerivative(Option::Put, strikes, vol);
}

void BlackFormulaTest::testBlackFormulaForwardDerivativeWithZeroVolatility() {

    BOOST_TEST_MESSAGE("Testing forward derivative of the Black formula "
        "with zero volatility...");

    std::vector<Real> strikes;
    strikes.push_back(0.1);
    strikes.push_back(0.5);
    strikes.push_back(1.0);
    strikes.push_back(2.0);
    strikes.push_back(3.0);
    const Real vol = 0.0;
    assertBlackFormulaForwardDerivative(Option::Call, strikes, vol);
    assertBlackFormulaForwardDerivative(Option::Put, strikes, vol);
}

void assertBachelierBlackFormulaForwardDerivative(
    Option::Type optionType,
    const std::vector<Real> &strikes,
    Real bpvol)
{
    Real forward = 1.0;
    Real tte = 10.0;
    Real stdDev = bpvol * std::sqrt(tte);
    Real discount = 0.95;
    Real bump = 0.0001;
    Real epsilon = 1.e-10;
    std::string type = optionType == Option::Call ? "Call" : "Put";

    for (double strike : strikes) {
        Real delta =
            bachelierBlackFormulaForwardDerivative(optionType, strike, forward, stdDev, discount);
        Real bumpedDelta = bachelierBlackFormulaForwardDerivative(
            optionType, strike, forward + bump, stdDev, discount);

        Real basePremium = bachelierBlackFormula(
            optionType, strike, forward, stdDev, discount);
        Real bumpedPremium = bachelierBlackFormula(
            optionType, strike, forward + bump, stdDev, discount);
        Real deltaApprox = (bumpedPremium - basePremium) / bump;

        /*! Based on the Mean Value Theorem, the below inequality
            should hold for any function that is monotonic in the
            area of the bump.
         */
        bool success =
            (std::max(delta, bumpedDelta) + epsilon > deltaApprox)
            &&  (deltaApprox > std::min(delta, bumpedDelta) - epsilon);

        if (!success)
        {
            BOOST_ERROR("Failed to calculate the derivative of the"
                        " Bachelier Black formula w.r.t. forward"
                        << "\n option type       :" << type
                        << "\n forward           :" << forward
                        << "\n strike            :" << strike
                        << "\n stdDev            :" << stdDev
                        << "\n analytical delta  :" << delta
                        << "\n approximated delta:" << deltaApprox);
        }
    }
}

void BlackFormulaTest::testBachelierBlackFormulaForwardDerivative() {

    BOOST_TEST_MESSAGE("Testing forward derivative of the "
        "Bachelier Black formula...");

    std::vector<Real> strikes;
    strikes.push_back(-3.0);
    strikes.push_back(-2.0);
    strikes.push_back(-1.0);
    strikes.push_back(-0.5);
    strikes.push_back(0.0);
    strikes.push_back(0.5);
    strikes.push_back(1.0);
    strikes.push_back(2.0);
    strikes.push_back(3.0);
    const Real vol = 0.001;
    assertBachelierBlackFormulaForwardDerivative(Option::Call, strikes, vol);
    assertBachelierBlackFormulaForwardDerivative(Option::Put, strikes, vol);
}

void BlackFormulaTest::testBachelierBlackFormulaForwardDerivativeWithZeroVolatility() {

    BOOST_TEST_MESSAGE("Testing forward derivative of the Bachelier Black formula "
        "with zero volatility...");

    std::vector<Real> strikes;
    strikes.push_back(-3.0);
    strikes.push_back(-2.0);
    strikes.push_back(-1.0);
    strikes.push_back(-0.5);
    strikes.push_back(0.0);
    strikes.push_back(0.5);
    strikes.push_back(1.0);
    strikes.push_back(2.0);
    strikes.push_back(3.0);
    const Real vol = 0.0;
    assertBachelierBlackFormulaForwardDerivative(Option::Call, strikes, vol);
    assertBachelierBlackFormulaForwardDerivative(Option::Put, strikes, vol);
}

test_suite* BlackFormulaTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Black formula tests");

    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testBachelierImpliedVol));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testChambersImpliedVol));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testRadoicicStefanicaImpliedVol));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testRadoicicStefanicaLowerBound));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testImpliedVolAdaptiveSuccessiveOverRelaxation));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testBlackFormulaForwardDerivative));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testBlackFormulaForwardDerivativeWithZeroStrike));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testBlackFormulaForwardDerivativeWithZeroVolatility));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testBachelierBlackFormulaForwardDerivative));
    suite->add(QUANTLIB_TEST_CASE(
        &BlackFormulaTest::testBachelierBlackFormulaForwardDerivativeWithZeroVolatility));

    return suite;
}
]]></document_content>
  </document>
  <document index="27">
    <source>blackformula.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Gary Kennedy
 Copyright (C) 2015 Peter Caspers
 Copyright (C) 2017 Klaus Spanderen
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_blackformula_hpp
#define quantlib_test_blackformula_hpp

#include <boost/test/unit_test.hpp>


class BlackFormulaTest {
  public:
    static void testBachelierImpliedVol();
    static void testChambersImpliedVol();
    static void testRadoicicStefanicaImpliedVol();
    static void testRadoicicStefanicaLowerBound();
    static void testImpliedVolAdaptiveSuccessiveOverRelaxation();
    static void testBlackFormulaForwardDerivative();
    static void testBlackFormulaForwardDerivativeWithZeroStrike();
    static void testBlackFormulaForwardDerivativeWithZeroVolatility();
    static void testBachelierBlackFormulaForwardDerivative();
    static void testBachelierBlackFormulaForwardDerivativeWithZeroVolatility();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="28">
    <source>bonds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_bonds_hpp
#define quantlib_test_bonds_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BondTest {
  public:
    static void testYield();
    static void testAtmRate();
    static void testZspread();
    static void testTheoretical();
    static void testCached();
    static void testCachedZero();
    static void testCachedFixed();
    static void testCachedFloating();
    static void testBrazilianCached();
    static void testFixedBondWithGivenDates();
    static void testExCouponGilt();
    static void testExCouponAustralianBond();
    static void testBondFromScheduleWithDateVector();
    static void testFixedRateBondWithArbitrarySchedule();
    static void testThirty360BondWithSettlementOn31st();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="29">
    <source>brownianbridge.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "brownianbridge.hpp"
#include "utilities.hpp"
#include <ql/methods/montecarlo/brownianbridge.hpp>
#include <ql/methods/montecarlo/pathgenerator.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <ql/math/randomnumbers/inversecumulativersg.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/calendars/nullcalendar.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    template <class ForwardIterator1, class ForwardIterator2>
    Real maxDiff(ForwardIterator1 begin1, ForwardIterator1 end1,
                 ForwardIterator2 begin2) {
        Real diff = 0.0;
        while (begin1 != end1) {
            diff = std::max(diff, std::fabs(*begin1 - *begin2));
            ++begin1; ++begin2;
        }
        return diff;
    }

    template <class ForwardIterator1, class ForwardIterator2>
    Real maxRelDiff(ForwardIterator1 begin1, ForwardIterator1 end1,
                    ForwardIterator2 begin2) {
        Real diff = 0.0;
        while (begin1 != end1) {
            diff = std::max(diff, std::fabs((*begin1 - *begin2)/(*begin2)));
            ++begin1; ++begin2;
        }
        return diff;
    }

}


void BrownianBridgeTest::testVariates() {
    BOOST_TEST_MESSAGE("Testing Brownian-bridge variates...");

    std::vector<Time> times = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0, 5.0};

    Size N = times.size();

    Size samples = 262143;
    unsigned long seed = 42;
    SobolRsg sobol(N, seed);
    InverseCumulativeRsg<SobolRsg,InverseCumulativeNormal> generator(sobol);

    BrownianBridge bridge(times);

    SequenceStatistics stats1(N);
    SequenceStatistics stats2(N);

    std::vector<Real> temp(N);

    for (Size i=0; i<samples; ++i) {
        const std::vector<Real>& sample = generator.nextSequence().value;

        bridge.transform(sample.begin(), sample.end(), temp.begin());
        stats1.add(temp.begin(), temp.end());

        temp[0] = temp[0]*std::sqrt(times[0]);
        for (Size j=1; j<N; ++j)
            temp[j] = temp[j-1] + temp[j]*std::sqrt(times[j]-times[j-1]);
        stats2.add(temp.begin(), temp.end());
    }

    // normalized single variates
    std::vector<Real> expectedMean(N, 0.0);
    Matrix expectedCovariance(N, N, 0.0);
    for (Size i=0; i<N; i++)
        expectedCovariance[i][i] = 1.0;

#ifndef __FAST_MATH__
    Real meanTolerance = 1.0e-16;
#else
    Real meanTolerance = 1.0e-14;
#endif
    Real covTolerance = 2.5e-4;

    std::vector<Real> mean = stats1.mean();
    Matrix covariance = stats1.covariance();

    Real maxMeanError = maxDiff(mean.begin(), mean.end(),
                                expectedMean.begin());
    Real maxCovError = maxDiff(covariance.begin(), covariance.end(),
                               expectedCovariance.begin());

    if (maxMeanError > meanTolerance) {
        Array calculated(N), expected(N);
        std::copy(mean.begin(), mean.end(), calculated.begin());
        std::copy(expectedMean.begin(), expectedMean.end(), expected.begin());
        BOOST_ERROR("failed to reproduce expected mean values"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << "\n    max error:  " << maxMeanError);
    }

    if (maxCovError > covTolerance) {
        BOOST_ERROR("failed to reproduce expected covariance\n"
                    << "    calculated:\n" << covariance
                    << "    expected:\n" << expectedCovariance
                    << "    max error:  " << maxCovError);
    }

    // denormalized sums along the path
    expectedMean = std::vector<Real>(N, 0.0);
    expectedCovariance = Matrix(N, N);
    for (Size i=0; i<N; ++i)
        for (Size j=i; j<N; ++j)
            expectedCovariance[i][j] = expectedCovariance[j][i] = times[i];

    covTolerance = 6.0e-4;

    mean = stats2.mean();
    covariance = stats2.covariance();

    maxMeanError = maxDiff(mean.begin(), mean.end(),
                           expectedMean.begin());
    maxCovError = maxDiff(covariance.begin(), covariance.end(),
                          expectedCovariance.begin());

    if (maxMeanError > meanTolerance) {
        Array calculated(N), expected(N);
        std::copy(mean.begin(), mean.end(), calculated.begin());
        std::copy(expectedMean.begin(), expectedMean.end(), expected.begin());
        BOOST_ERROR("failed to reproduce expected mean values"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << "\n    max error:  " << maxMeanError);
    }

    if (maxCovError > covTolerance) {
        BOOST_ERROR("failed to reproduce expected covariance\n"
                    << "    calculated:\n" << covariance
                    << "    expected:\n" << expectedCovariance
                    << "    max error:  " << maxCovError);
    }
}


void BrownianBridgeTest::testPathGeneration() {
    BOOST_TEST_MESSAGE("Testing Brownian-bridge path generation...");

    std::vector<Time> times = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0, 5.0, 7.0, 9.0, 10.0};

    TimeGrid grid(times.begin(), times.end());

    Size N = times.size();

    Size samples = 131071;
    unsigned long seed = 42;
    SobolRsg sobol(N, seed);
    InverseCumulativeRsg<SobolRsg,InverseCumulativeNormal> gsg(sobol);

    Date today = Settings::instance().evaluationDate();
    Handle<Quote> x0(ext::shared_ptr<Quote>(new SimpleQuote(100.0)));
    Handle<YieldTermStructure> r(ext::shared_ptr<YieldTermStructure>(
                               new FlatForward(today,0.06,Actual365Fixed())));
    Handle<YieldTermStructure> q(ext::shared_ptr<YieldTermStructure>(
                               new FlatForward(today,0.03,Actual365Fixed())));
    Handle<BlackVolTermStructure> sigma(
                   ext::shared_ptr<BlackVolTermStructure>(
                          new BlackConstantVol(today, NullCalendar(), 0.20,Actual365Fixed())));

    ext::shared_ptr<StochasticProcess1D> process(
                              new BlackScholesMertonProcess(x0, q, r, sigma));


    PathGenerator<InverseCumulativeRsg<SobolRsg,InverseCumulativeNormal> >
    generator1(process, grid, gsg, false);
    PathGenerator<InverseCumulativeRsg<SobolRsg,InverseCumulativeNormal> >
    generator2(process, grid, gsg, true);

    SequenceStatistics stats1(N);
    SequenceStatistics stats2(N);

    std::vector<Real> temp(N);

    for (Size i=0; i<samples; ++i) {
        const Path& path1 = generator1.next().value;
        std::copy(path1.begin()+1, path1.end(), temp.begin());
        stats1.add(temp.begin(), temp.end());

        const Path& path2 = generator2.next().value;
        std::copy(path2.begin()+1, path2.end(), temp.begin());
        stats2.add(temp.begin(), temp.end());
    }

    std::vector<Real> expectedMean = stats1.mean();
    Matrix expectedCovariance = stats1.covariance();

    std::vector<Real> mean = stats2.mean();
    Matrix covariance = stats2.covariance();

    Real meanTolerance = 3.0e-5;
    Real covTolerance = 3.0e-3;

    Real maxMeanError = maxRelDiff(mean.begin(), mean.end(),
                                   expectedMean.begin());
    Real maxCovError = maxRelDiff(covariance.begin(), covariance.end(),
                                  expectedCovariance.begin());

    if (maxMeanError > meanTolerance) {
        Array calculated(N), expected(N);
        std::copy(mean.begin(), mean.end(), calculated.begin());
        std::copy(expectedMean.begin(), expectedMean.end(), expected.begin());
        BOOST_ERROR("failed to reproduce expected mean values"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << "\n    max error:  " << maxMeanError);
    }

    if (maxCovError > covTolerance) {
        BOOST_ERROR("failed to reproduce expected covariance\n"
                    << "    calculated:\n" << covariance
                    << "    expected:\n" << expectedCovariance
                    << "    max error:  " << maxCovError);
    }
}

test_suite* BrownianBridgeTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Brownian bridge tests");
    suite->add(QUANTLIB_TEST_CASE(&BrownianBridgeTest::testVariates));
    suite->add(QUANTLIB_TEST_CASE(&BrownianBridgeTest::testPathGeneration));
    return suite;
}

]]></document_content>
  </document>
  <document index="30">
    <source>brownianbridge.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_brownian_bridge_hpp
#define quantlib_test_brownian_bridge_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BrownianBridgeTest {
  public:
    static void testVariates();
    static void testPathGeneration();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="31">
    <source>businessdayconventions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "businessdayconventions.hpp"
#include "utilities.hpp"
#include <ql/time/businessdayconvention.hpp>
#include <ql/time/calendars/southafrica.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/period.hpp>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace business_day_conventions_test {
    struct SingleCase {
        SingleCase(Calendar calendar,
                   const BusinessDayConvention& convention,
                   const Date& start,
                   const Period& period,
                   const bool endOfMonth,
                   Date result)
        : calendar(std::move(calendar)), convention(convention), start(start), period(period),
          endOfMonth(endOfMonth), result(result) {}
        Calendar calendar;
        BusinessDayConvention convention;
        Date start;
        Period period;
        bool endOfMonth;
        Date result;
    };

}

void BusinessDayConventionTest::testConventions() {

    BOOST_TEST_MESSAGE("Testing business day conventions...");

    using namespace business_day_conventions_test;

    SingleCase testCases[] = {
        // Following
        SingleCase(SouthAfrica(), Following, Date(3,February,2015), Period(1,Months), false, Date(3,March,2015)),
        SingleCase(SouthAfrica(), Following, Date(3,February,2015), Period(4,Days), false, Date(9,February,2015)),
        SingleCase(SouthAfrica(), Following, Date(31,January,2015), Period(1,Months), true, Date(27,February,2015)),
        SingleCase(SouthAfrica(), Following, Date(31,January,2015), Period(1,Months), false, Date(2,March,2015)),

        //ModifiedFollowing
        SingleCase(SouthAfrica(), ModifiedFollowing, Date(3,February,2015), Period(1,Months), false, Date(3,March,2015)),
        SingleCase(SouthAfrica(), ModifiedFollowing, Date(3,February,2015), Period(4,Days), false, Date(9,February,2015)),
        SingleCase(SouthAfrica(), ModifiedFollowing, Date(31,January,2015), Period(1,Months), true, Date(27,February,2015)),
        SingleCase(SouthAfrica(), ModifiedFollowing, Date(31,January,2015), Period(1,Months), false, Date(27,February,2015)),
        SingleCase(SouthAfrica(), ModifiedFollowing, Date(25,March,2015), Period(1,Months), false, Date(28,April,2015)),
        SingleCase(SouthAfrica(), ModifiedFollowing, Date(7,February,2015), Period(1,Months), false, Date(9,March,2015)),

        //Preceding
        SingleCase(SouthAfrica(), Preceding, Date(3,March,2015), Period(-1,Months), false, Date(3,February,2015)),
        SingleCase(SouthAfrica(), Preceding, Date(3,February,2015), Period(-2,Days), false, Date(30,January,2015)),
        SingleCase(SouthAfrica(), Preceding, Date(1,March,2015), Period(-1,Months), true, Date(30,January,2015)),
        SingleCase(SouthAfrica(), Preceding, Date(1,March,2015), Period(-1,Months), false, Date(30,January,2015)),

        //ModifiedPreceding
        SingleCase(SouthAfrica(), ModifiedPreceding, Date(3,March,2015), Period(-1,Months), false, Date(3,February,2015)),
        SingleCase(SouthAfrica(), ModifiedPreceding, Date(3,February,2015), Period(-2,Days), false, Date(30,January,2015)),
        SingleCase(SouthAfrica(), ModifiedPreceding, Date(1,March,2015), Period(-1,Months), true, Date(2,February,2015)),
        SingleCase(SouthAfrica(), ModifiedPreceding, Date(1,March,2015), Period(-1,Months), false, Date(2,February,2015)),

        //Unadjusted
        SingleCase(SouthAfrica(), Unadjusted, Date(3,February,2015), Period(1,Months), false, Date(3,March,2015)),
        SingleCase(SouthAfrica(), Unadjusted, Date(3,February,2015), Period(4,Days), false, Date(9,February,2015)),
        SingleCase(SouthAfrica(), Unadjusted, Date(31,January,2015), Period(1,Months), true, Date(27,February,2015)),
        SingleCase(SouthAfrica(), Unadjusted, Date(31,January,2015), Period(1,Months), false, Date(28,February,2015)),

        //HalfMonthModifiedFollowing
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(3,February,2015), Period(1,Months), false, Date(3,March,2015)),
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(3,February,2015), Period(4,Days), false, Date(9,February,2015)),
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(31,January,2015), Period(1,Months), true, Date(27,February,2015)),
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(31,January,2015), Period(1,Months), false, Date(27,February,2015)),
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(3,January,2015), Period(1,Weeks), false, Date(12,January,2015)),
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(21,March,2015), Period(1,Weeks), false, Date(30,March,2015)),
        SingleCase(SouthAfrica(), HalfMonthModifiedFollowing, Date(7,February,2015), Period(1,Months), false, Date(9,March,2015)),

        //Nearest
        SingleCase(SouthAfrica(), Nearest, Date(3,February,2015), Period(1,Months), false, Date(3,March,2015)),
        SingleCase(SouthAfrica(), Nearest, Date(3,February,2015), Period(4,Days), false, Date(9,February,2015)),
        SingleCase(SouthAfrica(), Nearest, Date(16,April,2015), Period(1,Months), false, Date(15,May,2015)),
        SingleCase(SouthAfrica(), Nearest, Date(17,April,2015), Period(1,Months), false, Date(18,May,2015)),
        SingleCase(SouthAfrica(), Nearest, Date(4,March,2015), Period(1,Months), false, Date(2,April,2015)),
        SingleCase(SouthAfrica(), Nearest, Date(2,April,2015), Period(1,Months), false, Date(4,May,2015))
    };

    Size n = sizeof(testCases)/sizeof(SingleCase);
    for (Size i=0; i<n; i++) {
        Calendar calendar(testCases[i].calendar);
        Date result = calendar.advance(
            testCases[i].start,
            testCases[i].period,
            testCases[i].convention,
            testCases[i].endOfMonth);

        BOOST_CHECK_MESSAGE(result == testCases[i].result,
                            "\ncase " << i << ":\n" //<< j << " ("<< desc << "): "
                            << "start date: " << testCases[i].start << "\n"
                            << "calendar: " << calendar << "\n"
                            << "period: " << testCases[i].period << ", end of month: " << testCases[i].endOfMonth << "\n"
                            << "convention: " << testCases[i].convention << "\n"
                            << "expected: " << testCases[i].result << " vs. actual: " << result);
    }
}

test_suite* BusinessDayConventionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Business day convention tests");
    suite->add(QUANTLIB_TEST_CASE(&BusinessDayConventionTest::testConventions));
    return suite;
}



]]></document_content>
  </document>
  <document index="32">
    <source>businessdayconventions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_business_day_convention_hpp
#define quantlib_test_business_day_convention_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class BusinessDayConventionTest {
   public:
    static void testConventions();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="33">
    <source>calendars.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2008 StatPro Italia srl
 Copyright (C) 2008 Charles Chongseok Hyun

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_calendars_hpp
#define quantlib_test_calendars_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CalendarTest {
  public:
    static void testRussia();
    static void testBrazil();
//    static void testItalySettlement();
    static void testItalyExchange();

    static void testUKSettlement();
    static void testUKExchange();
    static void testUKMetals();

//    static void testGermanySettlement();
    static void testGermanyFrankfurt();
    static void testGermanyXetra();
    static void testGermanyEurex();

    static void testTARGET();

    static void testUSSettlement();
    static void testUSGovernmentBondMarket();
    static void testUSNewYorkStockExchange();

    static void testSouthKoreanSettlement();
    static void testKoreaStockExchange();

    static void testChinaSSE();
    static void testChinaIB();

    static void testModifiedCalendars();
    static void testJointCalendars();
    static void testBespokeCalendars();

    static void testEndOfMonth();
    static void testBusinessDaysBetween();

    static void testIntradayAddHolidays();
    static void testDayLists();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="34">
    <source>callablebonds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "callablebonds.hpp"
#include "utilities.hpp"
#include <ql/experimental/callablebonds/callablebond.hpp>
#include <ql/experimental/callablebonds/treecallablebondengine.hpp>
#include <ql/instruments/bonds/zerocouponbond.hpp>
#include <ql/instruments/bonds/fixedratebond.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/schedule.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <boost/make_shared.hpp>
#include <iomanip>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    struct Globals {
        // global data
        Date today, settlement;
        Calendar calendar;
        DayCounter dayCounter;
        BusinessDayConvention rollingConvention;

        RelinkableHandle<YieldTermStructure> termStructure;
        RelinkableHandle<ShortRateModel> model;

        SavedSettings backup;

        Date issueDate() const {
            // ensure that we're in mid-coupon
            return calendar.adjust(today - 100*Days);
        }

        Date maturityDate() const {
            // ensure that we're in mid-coupon
            return calendar.advance(issueDate(),10,Years);
        }

        std::vector<Date> evenYears() const {
            std::vector<Date> dates;
            for (Size i=2; i<10; i+=2)
                dates.push_back(calendar.advance(issueDate(),i,Years));
            return dates;
        }

        std::vector<Date> oddYears() const {
            std::vector<Date> dates;
            for (Size i=1; i<10; i+=2)
                dates.push_back(calendar.advance(issueDate(),i,Years));
            return dates;
        }

        template <class R>
        ext::shared_ptr<YieldTermStructure> makeFlatCurve(const R& r) const {
            return ext::shared_ptr<YieldTermStructure>(
                                  new FlatForward(settlement, r, dayCounter));
        }

        Globals() {
            calendar = TARGET();
            dayCounter = Actual365Fixed();
            rollingConvention = ModifiedFollowing;

            today = Date::todaysDate();
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today,2,Days);
        }
    };

}

void CallableBondTest::testInterplay() {

    BOOST_TEST_MESSAGE("Testing interplay of callability and puttability for callable bonds...");

    Globals vars;

    vars.termStructure.linkTo(vars.makeFlatCurve(0.03));
    vars.model.linkTo(ext::make_shared<HullWhite>(vars.termStructure));

    Size timeSteps = 240;

    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<TreeCallableZeroCouponBondEngine>(
                                *(vars.model), timeSteps, vars.termStructure);

    /* case 1: an earlier out-of-the-money callability must prevent
               a later in-the-money puttability
    */

    CallabilitySchedule callabilities;

    callabilities.push_back(ext::make_shared<Callability>(
                         Bond::Price(100.0, Bond::Price::Clean),
                         Callability::Call,
                         vars.calendar.advance(vars.issueDate(),4,Years)));

    callabilities.push_back(ext::make_shared<Callability>(
                         Bond::Price(1000.0, Bond::Price::Clean),
                         Callability::Put,
                         vars.calendar.advance(vars.issueDate(),6,Years)));

    CallableZeroCouponBond bond(3, 100.0, vars.calendar,
                                vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                vars.rollingConvention, 100.0,
                                vars.issueDate(), callabilities);
    bond.setPricingEngine(engine);

    double expected = callabilities[0]->price().amount() *
                      vars.termStructure->discount(callabilities[0]->date()) /
                      vars.termStructure->discount(bond.settlementDate());

    if (std::fabs(bond.settlementValue() - expected) > 1.0e-2)
        BOOST_ERROR(
            "callability not exercised correctly:\n"
            << std::setprecision(5)
            << "    calculated NPV: " << bond.settlementValue() << "\n"
            << "    expected:       " << expected << "\n"
            << "    difference:     " << bond.settlementValue()-expected);

    /* case 2: same as case 1, with an added callability later on */

    callabilities.push_back(ext::make_shared<Callability>(
                         Bond::Price(100.0, Bond::Price::Clean),
                         Callability::Call,
                         vars.calendar.advance(vars.issueDate(),8,Years)));

    bond = CallableZeroCouponBond(3, 100.0, vars.calendar,
                                  vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                  vars.rollingConvention, 100.0,
                                  vars.issueDate(), callabilities);
    bond.setPricingEngine(engine);

    if (std::fabs(bond.settlementValue() - expected) > 1.0e-2)
        BOOST_ERROR(
            "callability not exercised correctly:\n"
            << std::setprecision(5)
            << "    calculated NPV: " << bond.settlementValue() << "\n"
            << "    expected:       " << expected << "\n"
            << "    difference:     " << bond.settlementValue()-expected);

    /* case 3: an earlier in-the-money puttability must prevent
               a later in-the-money callability
    */

    callabilities.clear();

    callabilities.push_back(ext::make_shared<Callability>(
                         Bond::Price(100.0, Bond::Price::Clean),
                         Callability::Put,
                         vars.calendar.advance(vars.issueDate(),4,Years)));

    callabilities.push_back(ext::make_shared<Callability>(
                         Bond::Price(10.0, Bond::Price::Clean),
                         Callability::Call,
                         vars.calendar.advance(vars.issueDate(),6,Years)));

    bond = CallableZeroCouponBond(3, 100.0, vars.calendar,
                                  vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                  vars.rollingConvention, 100.0,
                                  vars.issueDate(), callabilities);
    bond.setPricingEngine(engine);

    expected = callabilities[0]->price().amount() *
               vars.termStructure->discount(callabilities[0]->date()) /
               vars.termStructure->discount(bond.settlementDate());

    if (std::fabs(bond.settlementValue() - expected) > 1.0e-2)
        BOOST_ERROR(
            "puttability not exercised correctly:\n"
            << std::setprecision(5)
            << "    calculated NPV: " << bond.settlementValue() << "\n"
            << "    expected:       " << expected << "\n"
            << "    difference:     " << bond.settlementValue()-expected);

    /* case 4: same as case 3, with an added puttability later on */

    callabilities.push_back(ext::make_shared<Callability>(
                         Bond::Price(100.0, Bond::Price::Clean),
                         Callability::Put,
                         vars.calendar.advance(vars.issueDate(),8,Years)));

    bond = CallableZeroCouponBond(3, 100.0, vars.calendar,
                                  vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                  vars.rollingConvention, 100.0,
                                  vars.issueDate(), callabilities);
    bond.setPricingEngine(engine);

    if (std::fabs(bond.settlementValue() - expected) > 1.0e-2)
        BOOST_ERROR(
            "puttability not exercised correctly:\n"
            << std::setprecision(5)
            << "    calculated NPV: " << bond.settlementValue() << "\n"
            << "    expected:       " << expected << "\n"
            << "    difference:     " << bond.settlementValue()-expected);
}


void CallableBondTest::testConsistency() {

    BOOST_TEST_MESSAGE("Testing consistency of callable bonds...");

    Globals vars;

    vars.termStructure.linkTo(vars.makeFlatCurve(0.032));
    vars.model.linkTo(ext::make_shared<HullWhite>(vars.termStructure));

    Schedule schedule =
        MakeSchedule()
        .from(vars.issueDate())
        .to(vars.maturityDate())
        .withCalendar(vars.calendar)
        .withFrequency(Semiannual)
        .withConvention(vars.rollingConvention)
        .withRule(DateGeneration::Backward);

    std::vector<Rate> coupons(1, 0.05);

    FixedRateBond bond(3, 100.0, schedule,
                       coupons, Thirty360(Thirty360::BondBasis));
    bond.setPricingEngine(
               ext::make_shared<DiscountingBondEngine>(vars.termStructure));

    CallabilitySchedule callabilities;
    std::vector<Date> callabilityDates = vars.evenYears();
    for (auto& callabilityDate : callabilityDates) {
        callabilities.push_back(ext::make_shared<Callability>(
            Bond::Price(110.0, Bond::Price::Clean), Callability::Call, callabilityDate));
    }

    CallabilitySchedule puttabilities;
    std::vector<Date> puttabilityDates = vars.oddYears();
    for (auto& puttabilityDate : puttabilityDates) {
        puttabilities.push_back(ext::make_shared<Callability>(Bond::Price(90.0, Bond::Price::Clean),
                                                              Callability::Put, puttabilityDate));
    }

    Size timeSteps = 240;

    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<TreeCallableFixedRateBondEngine>(
                                *(vars.model), timeSteps, vars.termStructure);

    CallableFixedRateBond callable(3, 100.0, schedule,
                                   coupons, Thirty360(Thirty360::BondBasis),
                                   vars.rollingConvention,
                                   100.0, vars.issueDate(),
                                   callabilities);
    callable.setPricingEngine(engine);

    CallableFixedRateBond puttable(3, 100.0, schedule,
                                   coupons, Thirty360(Thirty360::BondBasis),
                                   vars.rollingConvention,
                                   100.0, vars.issueDate(),
                                   puttabilities);
    puttable.setPricingEngine(engine);

    if (bond.cleanPrice() <= callable.cleanPrice())
        BOOST_ERROR(
            "inconsistent prices:\n"
            << std::setprecision(8)
            << "    plain bond: " << bond.cleanPrice() << "\n"
            << "    callable:   " << callable.cleanPrice() << "\n"
            << " (should be lower)");

    if (bond.cleanPrice() >= puttable.cleanPrice())
        BOOST_ERROR(
            "inconsistent prices:\n"
            << std::setprecision(8)
            << "    plain bond: " << bond.cleanPrice() << "\n"
            << "    puttable:   " << puttable.cleanPrice() << "\n"
            << " (should be higher)");
}


void CallableBondTest::testObservability() {

    BOOST_TEST_MESSAGE("Testing observability of callable bonds...");

    Globals vars;

    ext::shared_ptr<SimpleQuote> observable(new SimpleQuote(0.03));
    Handle<Quote> h(observable);
    vars.termStructure.linkTo(vars.makeFlatCurve(h));
    vars.model.linkTo(ext::make_shared<HullWhite>(vars.termStructure));

    Schedule schedule =
        MakeSchedule()
        .from(vars.issueDate())
        .to(vars.maturityDate())
        .withCalendar(vars.calendar)
        .withFrequency(Semiannual)
        .withConvention(vars.rollingConvention)
        .withRule(DateGeneration::Backward);

    std::vector<Rate> coupons(1, 0.05);

    CallabilitySchedule callabilities;

    std::vector<Date> callabilityDates = vars.evenYears();
    for (auto& callabilityDate : callabilityDates) {
        callabilities.push_back(ext::make_shared<Callability>(
            Bond::Price(110.0, Bond::Price::Clean), Callability::Call, callabilityDate));
    }
    std::vector<Date> puttabilityDates = vars.oddYears();
    for (auto& puttabilityDate : puttabilityDates) {
        callabilities.push_back(ext::make_shared<Callability>(Bond::Price(90.0, Bond::Price::Clean),
                                                              Callability::Put, puttabilityDate));
    }

    CallableZeroCouponBond bond(3, 100.0, vars.calendar,
                                vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                vars.rollingConvention, 100.0,
                                vars.issueDate(), callabilities);

    Size timeSteps = 240;

    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<TreeCallableFixedRateBondEngine>(
                                *(vars.model), timeSteps, vars.termStructure);

    bond.setPricingEngine(engine);

    double originalValue = bond.NPV();

    observable->setValue(0.04);

    if (bond.NPV() == originalValue)
        BOOST_ERROR(
            "callable coupon bond was not notified of observable change");


}

void CallableBondTest::testDegenerate() {

    BOOST_TEST_MESSAGE("Repricing bonds using degenerate callable bonds...");

    Globals vars;

    vars.termStructure.linkTo(vars.makeFlatCurve(0.034));
    vars.model.linkTo(ext::make_shared<HullWhite>(vars.termStructure));

    Schedule schedule =
        MakeSchedule()
        .from(vars.issueDate())
        .to(vars.maturityDate())
        .withCalendar(vars.calendar)
        .withFrequency(Semiannual)
        .withConvention(vars.rollingConvention)
        .withRule(DateGeneration::Backward);

    std::vector<Rate> coupons(1, 0.05);

    ZeroCouponBond zeroCouponBond(3, vars.calendar, 100.0,
                                  vars.maturityDate(),
                                  vars.rollingConvention);
    FixedRateBond couponBond(3, 100.0, schedule,
                             coupons, Thirty360(Thirty360::BondBasis));

    // no callability
    CallabilitySchedule callabilities;

    CallableZeroCouponBond bond1(3, 100.0, vars.calendar,
                                 vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                 vars.rollingConvention, 100.0,
                                 vars.issueDate(), callabilities);

    CallableFixedRateBond bond2(3, 100.0, schedule,
                                coupons, Thirty360(Thirty360::BondBasis),
                                vars.rollingConvention,
                                100.0, vars.issueDate(),
                                callabilities);

    ext::shared_ptr<PricingEngine> discountingEngine =
        ext::make_shared<DiscountingBondEngine>(vars.termStructure);
    
    zeroCouponBond.setPricingEngine(discountingEngine);
    couponBond.setPricingEngine(discountingEngine);

    Size timeSteps = 240;

    ext::shared_ptr<PricingEngine> treeEngine =
        ext::make_shared<TreeCallableFixedRateBondEngine>(
                                *(vars.model), timeSteps, vars.termStructure);

    bond1.setPricingEngine(treeEngine);
    bond2.setPricingEngine(treeEngine);

    double tolerance = 1.0e-4;

    if (std::fabs(bond1.cleanPrice() - zeroCouponBond.cleanPrice()) > tolerance)
        BOOST_ERROR(
            "failed to reproduce zero-coupon bond price:\n"
            << std::setprecision(7)
            << "    calculated: " << bond1.cleanPrice() << "\n"
            << "    expected:   " << zeroCouponBond.cleanPrice());

    if (std::fabs(bond2.cleanPrice() - couponBond.cleanPrice()) > tolerance)
        BOOST_ERROR(
            "failed to reproduce fixed-rate bond price:\n"
            << std::setprecision(7)
            << "    calculated: " << bond2.cleanPrice() << "\n"
            << "    expected:   " << couponBond.cleanPrice());

    // out-of-the-money callability

    std::vector<Date> callabilityDates = vars.evenYears();
    for (auto& callabilityDate : callabilityDates) {
        callabilities.push_back(ext::make_shared<Callability>(
            Bond::Price(10000.0, Bond::Price::Clean), Callability::Call, callabilityDate));
    }
    std::vector<Date> puttabilityDates = vars.oddYears();
    for (auto& puttabilityDate : puttabilityDates) {
        callabilities.push_back(ext::make_shared<Callability>(Bond::Price(0.0, Bond::Price::Clean),
                                                              Callability::Put, puttabilityDate));
    }

    bond1 = CallableZeroCouponBond(3, 100.0, vars.calendar,
                                   vars.maturityDate(), Thirty360(Thirty360::BondBasis),
                                   vars.rollingConvention, 100.0,
                                   vars.issueDate(), callabilities);

    bond2 = CallableFixedRateBond(3, 100.0, schedule,
                                  coupons, Thirty360(Thirty360::BondBasis),
                                  vars.rollingConvention,
                                  100.0, vars.issueDate(),
                                  callabilities);

    bond1.setPricingEngine(treeEngine);
    bond2.setPricingEngine(treeEngine);

    if (std::fabs(bond1.cleanPrice() - zeroCouponBond.cleanPrice()) > tolerance)
        BOOST_ERROR(
            "failed to reproduce zero-coupon bond price:\n"
            << std::setprecision(7)
            << "    calculated: " << bond1.cleanPrice() << "\n"
            << "    expected:   " << zeroCouponBond.cleanPrice());

    if (std::fabs(bond2.cleanPrice() - couponBond.cleanPrice()) > tolerance)
        BOOST_ERROR(
            "failed to reproduce fixed-rate bond price:\n"
            << std::setprecision(7)
            << "    calculated: " << bond2.cleanPrice() << "\n"
            << "    expected:   " << couponBond.cleanPrice());
}

void CallableBondTest::testCached() {

    BOOST_TEST_MESSAGE("Testing callable-bond value against cached values...");

    Globals vars;

    vars.today = Date(3,June,2004);
    Settings::instance().evaluationDate() = vars.today;
    vars.settlement = vars.calendar.advance(vars.today,3,Days);

    vars.termStructure.linkTo(vars.makeFlatCurve(0.032));
    vars.model.linkTo(ext::make_shared<HullWhite>(vars.termStructure));

    Schedule schedule =
        MakeSchedule()
        .from(vars.issueDate())
        .to(vars.maturityDate())
        .withCalendar(vars.calendar)
        .withFrequency(Semiannual)
        .withConvention(vars.rollingConvention)
        .withRule(DateGeneration::Backward);

    std::vector<Rate> coupons(1, 0.05);

    CallabilitySchedule callabilities;
    CallabilitySchedule puttabilities;
    CallabilitySchedule all_exercises;

    std::vector<Date> callabilityDates = vars.evenYears();
    for (auto& callabilityDate : callabilityDates) {
        ext::shared_ptr<Callability> exercise = ext::make_shared<Callability>(
            Bond::Price(110.0, Bond::Price::Clean), Callability::Call, callabilityDate);
        callabilities.push_back(exercise);
        all_exercises.push_back(exercise);
    }
    std::vector<Date> puttabilityDates = vars.oddYears();
    for (auto& puttabilityDate : puttabilityDates) {
        ext::shared_ptr<Callability> exercise = ext::make_shared<Callability>(
            Bond::Price(100.0, Bond::Price::Clean), Callability::Put, puttabilityDate);
        puttabilities.push_back(exercise);
        all_exercises.push_back(exercise);
    }

    Size timeSteps = 240;

    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<TreeCallableFixedRateBondEngine>(
                                *(vars.model), timeSteps, vars.termStructure);

    double tolerance = 1.0e-8;

    double storedPrice1 = 110.60975477;
    CallableFixedRateBond bond1(3, 100.0, schedule,
                                coupons, Thirty360(Thirty360::BondBasis),
                                vars.rollingConvention,
                                100.0, vars.issueDate(),
                                callabilities);
    bond1.setPricingEngine(engine);

    if (std::fabs(bond1.cleanPrice() - storedPrice1) > tolerance)
        BOOST_ERROR(
            "failed to reproduce cached callable-bond price:\n"
            << std::setprecision(12)
            << "    calculated: " << bond1.cleanPrice() << "\n"
            << "    expected:   " << storedPrice1);

    double storedPrice2 = 115.16559362;
    CallableFixedRateBond bond2(3, 100.0, schedule,
                                coupons, Thirty360(Thirty360::BondBasis),
                                vars.rollingConvention,
                                100.0, vars.issueDate(),
                                puttabilities);
    bond2.setPricingEngine(engine);

    if (std::fabs(bond2.cleanPrice() - storedPrice2) > tolerance)
        BOOST_ERROR(
            "failed to reproduce cached puttable-bond price:\n"
            << std::setprecision(12)
            << "    calculated: " << bond2.cleanPrice() << "\n"
            << "    expected:   " << storedPrice2);

    double storedPrice3 = 110.97509625;
    CallableFixedRateBond bond3(3, 100.0, schedule,
                                coupons, Thirty360(Thirty360::BondBasis),
                                vars.rollingConvention,
                                100.0, vars.issueDate(),
                                all_exercises);
    bond3.setPricingEngine(engine);

    if (std::fabs(bond3.cleanPrice() - storedPrice3) > tolerance)
        BOOST_ERROR(
            "failed to reproduce cached callable/puttable-bond price:\n"
            << std::setprecision(12)
            << "    calculated: " << bond3.cleanPrice() << "\n"
            << "    expected:   " << storedPrice3);


}

test_suite* CallableBondTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Convertible-bond tests");
    suite->add(QUANTLIB_TEST_CASE(&CallableBondTest::testConsistency));
    suite->add(QUANTLIB_TEST_CASE(&CallableBondTest::testInterplay));
    suite->add(QUANTLIB_TEST_CASE(&CallableBondTest::testObservability));
    suite->add(QUANTLIB_TEST_CASE(&CallableBondTest::testDegenerate));
    suite->add(QUANTLIB_TEST_CASE(&CallableBondTest::testCached));
    return suite;
}

]]></document_content>
  </document>
  <document index="35">
    <source>callablebonds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_callable_bonds_hpp
#define quantlib_test_callable_bonds_hpp

#include <boost/test/unit_test.hpp>

class CallableBondTest {
  public:
    static void testConsistency();
    static void testInterplay();
    static void testObservability();
    static void testDegenerate();
    static void testCached();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="36">
    <source>capfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2004, 2005, 2006, 2007, 2008 StatPro Italia srl
 Copyright (C) 2019 Wojciech lusarski

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "capfloor.hpp"
#include "utilities.hpp"
#include <ql/instruments/capfloor.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/zerospreadedtermstructure.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/math/matrix.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace capfloor_test {

    struct CommonVars {
        // common data
        Date settlement;
        std::vector<Real> nominals;
        BusinessDayConvention convention;
        Frequency frequency;
        ext::shared_ptr<IborIndex> index;
        Calendar calendar;
        Natural fixingDays;
        RelinkableHandle<YieldTermStructure> termStructure;

        // cleanup

        SavedSettings backup;

        // setup
        CommonVars()
        : nominals(1,100) {
            frequency = Semiannual;
            index = ext::shared_ptr<IborIndex>(new Euribor6M(termStructure));
            calendar = index->fixingCalendar();
            convention = ModifiedFollowing;
            Date today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;
            Natural settlementDays = 2;
            fixingDays = 2;
            settlement = calendar.advance(today,settlementDays,Days);
            termStructure.linkTo(flatRate(settlement,0.05,
                                          ActualActual(ActualActual::ISDA)));
        }

        // utilities
        Leg makeLeg(const Date& startDate, Integer length) const {
            Date endDate = calendar.advance(startDate,length*Years,convention);
            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              convention, convention,
                              DateGeneration::Forward, false);
            return IborLeg(schedule, index)
                .withNotionals(nominals)
                .withPaymentDayCounter(index->dayCounter())
                .withPaymentAdjustment(convention)
                .withFixingDays(fixingDays);
        }

        ext::shared_ptr<PricingEngine> makeEngine(Volatility volatility) const {
            Handle<Quote> vol(ext::shared_ptr<Quote>(
                                                new SimpleQuote(volatility)));
            return ext::shared_ptr<PricingEngine>(
                                new BlackCapFloorEngine(termStructure, vol));
        }

        ext::shared_ptr<PricingEngine> makeBachelierEngine(Volatility volatility) const {
            Handle<Quote> vol(ext::shared_ptr<Quote>(
                                                new SimpleQuote(volatility)));
            return ext::shared_ptr<PricingEngine>(
                                new BachelierCapFloorEngine(termStructure, vol));
        }

        ext::shared_ptr<CapFloor> makeCapFloor(CapFloor::Type type,
                                               const Leg& leg,
                                               Rate strike,
                                               Volatility volatility,
                                               bool isLogNormal = true) const {
            ext::shared_ptr<CapFloor> result;
            switch (type) {
              case CapFloor::Cap:
                result = ext::shared_ptr<CapFloor>(
                                  new Cap(leg, std::vector<Rate>(1, strike)));
                break;
              case CapFloor::Floor:
                result = ext::shared_ptr<CapFloor>(
                                new Floor(leg, std::vector<Rate>(1, strike)));
                break;
              default:
                QL_FAIL("unknown cap/floor type");
            }
            if(isLogNormal){
                result->setPricingEngine(makeEngine(volatility));
            } else {
                result->setPricingEngine(makeBachelierEngine(volatility));
            }
            return result;
        }
    };

    bool checkAbsError(Real x1, Real x2, Real tolerance){
        return std::fabs(x1 - x2) < tolerance;
    }

    std::string typeToString(CapFloor::Type type) {
        switch (type) {
          case CapFloor::Cap:
            return "cap";
          case CapFloor::Floor:
            return "floor";
          case CapFloor::Collar:
            return "collar";
          default:
            QL_FAIL("unknown cap/floor type");
        }
    }

}


void CapFloorTest::testVega() {

    BOOST_TEST_MESSAGE("Testing cap/floor vega...");

    using namespace capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 4, 5, 6, 7, 10, 15, 20, 30 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.15, 0.20 };
    Rate strikes[] = { 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09 };
    CapFloor::Type types[] = { CapFloor::Cap, CapFloor::Floor};

    Date startDate = vars.termStructure->referenceDate();
    static const Real shift = 1e-8;
    static const Real tolerance = 0.005;

    for (int length : lengths) {
        for (double vol : vols) {
            for (double strike : strikes) {
                for (auto& type : types) {
                    Leg leg = vars.makeLeg(startDate, length);
                    ext::shared_ptr<CapFloor> capFloor = vars.makeCapFloor(type, leg, strike, vol);
                    ext::shared_ptr<CapFloor> shiftedCapFloor2 =
                        vars.makeCapFloor(type, leg, strike, vol + shift);
                    ext::shared_ptr<CapFloor> shiftedCapFloor1 =
                        vars.makeCapFloor(type, leg, strike, vol - shift);
                    Real value1 = shiftedCapFloor1->NPV();
                    Real value2 = shiftedCapFloor2->NPV();
                    Real numericalVega = (value2 - value1) / (2*shift);
                    if (numericalVega>1.0e-4) {
                        Real analyticalVega = capFloor->result<Real>("vega");
                        Real discrepancy =
                            std::fabs(numericalVega - analyticalVega);
                        discrepancy /= numericalVega;
                        if (discrepancy > tolerance)
                            BOOST_FAIL("failed to compute cap/floor vega:"
                                       << "\n   lengths:     " << length * Years
                                       << "\n   strike:      " << io::rate(strike) <<
                                       //"\n   types:       " << types[h] <<
                                       std::fixed << std::setprecision(12) << "\n   calculated:  "
                                       << analyticalVega << "\n   expected:    " << numericalVega
                                       << "\n   discrepancy: " << io::rate(discrepancy)
                                       << "\n   tolerance:   " << io::rate(tolerance));
                     }
                }
            }
        }
    }
}

void CapFloorTest::testStrikeDependency() {

    BOOST_TEST_MESSAGE("Testing cap/floor dependency on strike...");

    using namespace capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.15, 0.20 };
    Rate strikes[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };

    Date startDate = vars.termStructure->referenceDate();

    for (int& length : lengths) {
        for (double vol : vols) {
            // store the results for different strikes...
            std::vector<Real> cap_values, floor_values;
            for (double strike : strikes) {
                Leg leg = vars.makeLeg(startDate, length);
                ext::shared_ptr<Instrument> cap =
                    vars.makeCapFloor(CapFloor::Cap, leg, strike, vol);
                cap_values.push_back(cap->NPV());
                ext::shared_ptr<Instrument> floor =
                    vars.makeCapFloor(CapFloor::Floor, leg, strike, vol);
                floor_values.push_back(floor->NPV());
            }
            // and check that they go the right way
            auto it = std::adjacent_find(cap_values.begin(), cap_values.end(), std::less<Real>());
            if (it != cap_values.end()) {
                Size n = it - cap_values.begin();
                BOOST_FAIL("NPV is increasing with the strike in a cap: \n"
                           << std::setprecision(2) << "    length:     " << length << " years\n"
                           << "    volatility: " << io::volatility(vol) << "\n"
                           << "    value:      " << cap_values[n]
                           << " at strike: " << io::rate(strikes[n]) << "\n"
                           << "    value:      " << cap_values[n + 1]
                           << " at strike: " << io::rate(strikes[n + 1]));
            }
            // same for floors
            it = std::adjacent_find(floor_values.begin(),floor_values.end(),
                                    std::greater<Real>());
            if (it != floor_values.end()) {
                Size n = it - floor_values.begin();
                BOOST_FAIL("NPV is decreasing with the strike in a floor: \n"
                           << std::setprecision(2) << "    length:     " << length << " years\n"
                           << "    volatility: " << io::volatility(vol) << "\n"
                           << "    value:      " << floor_values[n]
                           << " at strike: " << io::rate(strikes[n]) << "\n"
                           << "    value:      " << floor_values[n + 1]
                           << " at strike: " << io::rate(strikes[n + 1]));
            }
        }
    }
}

void CapFloorTest::testConsistency() {

    BOOST_TEST_MESSAGE("Testing consistency between cap, floor and collar...");

    using namespace capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    Rate cap_rates[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };
    Rate floor_rates[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.15, 0.20 };

    Date startDate = vars.termStructure->referenceDate();

    for (int& length : lengths) {
        for (double& cap_rate : cap_rates) {
            for (double& floor_rate : floor_rates) {
                for (double vol : vols) {

                    Leg leg = vars.makeLeg(startDate, length);
                    ext::shared_ptr<CapFloor> cap =
                        vars.makeCapFloor(CapFloor::Cap, leg, cap_rate, vol);
                    ext::shared_ptr<CapFloor> floor =
                        vars.makeCapFloor(CapFloor::Floor, leg, floor_rate, vol);
                    Collar collar(leg, std::vector<Rate>(1, cap_rate),
                                  std::vector<Rate>(1, floor_rate));
                    collar.setPricingEngine(vars.makeEngine(vol));

                    if (std::fabs((cap->NPV() - floor->NPV()) - collar.NPV()) > 1e-10) {
                        BOOST_FAIL("inconsistency between cap, floor and collar:\n"
                                   << "    length:       " << length << " years\n"
                                   << "    volatility:   " << io::volatility(vol) << "\n"
                                   << "    cap value:    " << cap->NPV()
                                   << " at strike: " << io::rate(cap_rate) << "\n"
                                   << "    floor value:  " << floor->NPV()
                                   << " at strike: " << io::rate(floor_rate) << "\n"
                                   << "    collar value: " << collar.NPV());


                        // test re-composition by optionlets, N.B. two per year
                        Real capletsNPV = 0.0;
                        std::vector<ext::shared_ptr<CapFloor> > caplets;
                        for (Integer m = 0; m < length * 2; m++) {
                            caplets.push_back(cap->optionlet(m));
                            caplets[m]->setPricingEngine(vars.makeEngine(vol));
                            capletsNPV += caplets[m]->NPV();
                        }

                        if (std::fabs(cap->NPV() - capletsNPV) > 1e-10) {
                            BOOST_FAIL("sum of caplet NPVs does not equal cap NPV:\n"
                                       << "    length:       " << length << " years\n"
                                       << "    volatility:   " << io::volatility(vol) << "\n"
                                       << "    cap value:    " << cap->NPV()
                                       << " at strike: " << io::rate(cap_rate) << "\n"
                                       << "    sum of caplets value:  " << capletsNPV
                                       << " at strike (first): "
                                       << io::rate(caplets[0]->capRates()[0]) << "\n");
                        }

                        Real floorletsNPV = 0.0;
                        std::vector<ext::shared_ptr<CapFloor> > floorlets;
                        for (Integer m = 0; m < length * 2; m++) {
                            floorlets.push_back(floor->optionlet(m));
                            floorlets[m]->setPricingEngine(vars.makeEngine(vol));
                            floorletsNPV += floorlets[m]->NPV();
                        }

                        if (std::fabs(floor->NPV() - floorletsNPV) > 1e-10) {
                            BOOST_FAIL("sum of floorlet NPVs does not equal floor NPV:\n"
                                       << "    length:       " << length << " years\n"
                                       << "    volatility:   " << io::volatility(vol) << "\n"
                                       << "    cap value:    " << floor->NPV()
                                       << " at strike: " << io::rate(floor_rate) << "\n"
                                       << "    sum of floorlets value:  " << floorletsNPV
                                       << " at strike (first): "
                                       << io::rate(floorlets[0]->floorRates()[0]) << "\n");
                        }

                        Real collarletsNPV = 0.0;
                        std::vector<ext::shared_ptr<CapFloor> > collarlets;
                        for (Integer m = 0; m < length * 2; m++) {
                            collarlets.push_back(collar.optionlet(m));
                            collarlets[m]->setPricingEngine(vars.makeEngine(vol));
                            collarletsNPV += collarlets[m]->NPV();
                        }

                        if (std::fabs(collar.NPV() - collarletsNPV) > 1e-10) {
                            BOOST_FAIL("sum of collarlet NPVs does not equal floor NPV:\n"
                                       << "    length:       " << length << " years\n"
                                       << "    volatility:   " << io::volatility(vol) << "\n"
                                       << "    cap value:    " << collar.NPV()
                                       << " at strike floor: " << io::rate(floor_rate)
                                       << " at strike cap: " << io::rate(cap_rate) << "\n"
                                       << "    sum of collarlets value:  " << collarletsNPV
                                       << " at strike floor (first): "
                                       << io::rate(collarlets[0]->floorRates()[0])
                                       << " at strike cap (first): "
                                       << io::rate(collarlets[0]->capRates()[0]) << "\n");
                        }
                    }
                }
            }
        }
    }
}

void CapFloorTest::testParity() {

    BOOST_TEST_MESSAGE("Testing cap/floor parity...");

    using namespace capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    Rate strikes[] = { 0., 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.15, 0.20 };

    Date startDate = vars.termStructure->referenceDate();

    for (int& length : lengths) {
        for (double strike : strikes) {
            for (double vol : vols) {

                Leg leg = vars.makeLeg(startDate, length);
                ext::shared_ptr<Instrument> cap =
                    vars.makeCapFloor(CapFloor::Cap, leg, strike, vol);
                ext::shared_ptr<Instrument> floor =
                    vars.makeCapFloor(CapFloor::Floor, leg, strike, vol);
                Date maturity = vars.calendar.advance(startDate, length, Years, vars.convention);
                Schedule schedule(startDate, maturity, Period(vars.frequency), vars.calendar,
                                  vars.convention, vars.convention, DateGeneration::Forward, false);
                VanillaSwap swap(Swap::Payer, vars.nominals[0], schedule, strike,
                                 vars.index->dayCounter(), schedule, vars.index, 0.0,
                                 vars.index->dayCounter());
                swap.setPricingEngine(
                    ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(vars.termStructure)));
                // FLOATING_POINT_EXCEPTION
                if (std::fabs((cap->NPV() - floor->NPV()) - swap.NPV()) > 1.0e-10) {
                    BOOST_FAIL("put/call parity violated:\n"
                               << "    length:      " << length << " years\n"
                               << "    volatility:  " << io::volatility(vol) << "\n"
                               << "    strike:      " << io::rate(strike) << "\n"
                               << "    cap value:   " << cap->NPV() << "\n"
                               << "    floor value: " << floor->NPV() << "\n"
                               << "    swap value:  " << swap.NPV());
                }
            }
        }
    }
}

void CapFloorTest::testATMRate() {

    BOOST_TEST_MESSAGE("Testing cap/floor ATM rate...");

    using namespace capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    Rate strikes[] = { 0., 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.15, 0.20 };

    Date startDate = vars.termStructure->referenceDate();

    for (int& length : lengths) {
        Leg leg = vars.makeLeg(startDate, length);
        Date maturity = vars.calendar.advance(startDate, length, Years, vars.convention);
        Schedule schedule(startDate,maturity,
                          Period(vars.frequency),vars.calendar,
                          vars.convention,vars.convention,
                          DateGeneration::Forward,false);

        for (double strike : strikes) {
            for (double vol : vols) {
                ext::shared_ptr<CapFloor> cap = vars.makeCapFloor(CapFloor::Cap, leg, strike, vol);
                ext::shared_ptr<CapFloor> floor =
                    vars.makeCapFloor(CapFloor::Floor, leg, strike, vol);
                Rate capATMRate = cap->atmRate(**vars.termStructure);
                Rate floorATMRate = floor->atmRate(**vars.termStructure);
                if (!checkAbsError(floorATMRate, capATMRate, 1.0e-10))
                    BOOST_FAIL("Cap ATM Rate and floor ATM Rate should be equal :\n"
                               << "   length:        " << length << " years\n"
                               << "   volatility:    " << io::volatility(vol) << "\n"
                               << "   strike:        " << io::rate(strike) << "\n"
                               << "   cap ATM rate:  " << capATMRate << "\n"
                               << "   floor ATM rate:" << floorATMRate << "\n"
                               << "   relative Error:"
                               << relativeError(capATMRate, floorATMRate, capATMRate) * 100 << "%");
                VanillaSwap swap(Swap::Payer, vars.nominals[0],
                                 schedule, floorATMRate,
                                 vars.index->dayCounter(),
                                 schedule, vars.index, 0.0,
                                 vars.index->dayCounter());
                swap.setPricingEngine(ext::shared_ptr<PricingEngine>(
                              new DiscountingSwapEngine(vars.termStructure)));
                Real swapNPV = swap.NPV();
                if (!checkAbsError(swapNPV, 0, 1.0e-10))
                    BOOST_FAIL("the NPV of a Swap struck at ATM rate "
                               "should be equal to 0:\n"
                               << "   length:        " << length << " years\n"
                               << "   volatility:    " << io::volatility(vol) << "\n"
                               << "   ATM rate:      " << io::rate(floorATMRate) << "\n"
                               << "   swap NPV:      " << swapNPV);
            }
        }
    }
}


void CapFloorTest::testImpliedVolatility() {

    BOOST_TEST_MESSAGE("Testing implied term volatility for cap and floor...");

    using namespace capfloor_test;

    CommonVars vars;

    Size maxEvaluations = 100;
    Real tolerance = 1.0e-8;

    CapFloor::Type types[] = { CapFloor::Cap, CapFloor::Floor };
    Rate strikes[] = { 0.02, 0.03, 0.04 };
    Integer lengths[] = { 1, 5, 10 };

    // test data
    Rate rRates[] = { 0.02, 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.20, 0.30, 0.70, 0.90 };

    for (int& length : lengths) {
        Leg leg = vars.makeLeg(vars.settlement, length);

        for (auto& type : types) {
            for (double strike : strikes) {

                ext::shared_ptr<CapFloor> capfloor = vars.makeCapFloor(type, leg, strike, 0.0);

                for (double r : rRates) {
                    for (double v : vols) {

                        vars.termStructure.linkTo(flatRate(vars.settlement, r, Actual360()));
                        capfloor->setPricingEngine(vars.makeEngine(v));

                        Real value = capfloor->NPV();
                        Volatility implVol = 0.0;
                        try {
                            implVol =
                                capfloor->impliedVolatility(value,
                                                            vars.termStructure,
                                                            0.10,
                                                            tolerance,
                                                            maxEvaluations,
                                                            10.0e-7, 4.0,
                                                            ShiftedLognormal, 0.0);
                        } catch (std::exception& e) {
                            // couldn't bracket?
                            capfloor->setPricingEngine(vars.makeEngine(0.0));
                            Real value2 = capfloor->NPV();
                            if (std::fabs(value-value2) < tolerance) {
                                // ok, just skip:
                                continue;
                            }
                            // otherwise, report error
                            BOOST_ERROR("implied vol failure: "
                                        << typeToString(type) << "\n  strike:     "
                                        << io::rate(strike) << "\n  risk-free:  " << io::rate(r)
                                        << "\n  length:     " << length << "Y"
                                        << "\n  volatility: " << io::volatility(v)
                                        << "\n  price:      " << value << "\n"
                                        << e.what());
                        }
                        if (std::fabs(implVol-v) > tolerance) {
                            // the difference might not matter
                            capfloor->setPricingEngine(
                                                    vars.makeEngine(implVol));
                            Real value2 = capfloor->NPV();
                            if (std::fabs(value-value2) > tolerance) {
                                BOOST_FAIL("implied vol failure: "
                                           << typeToString(type)
                                           << "\n  strike:        " << io::rate(strike)
                                           << "\n  risk-free:     " << io::rate(r)
                                           << "\n  length:        " << length << "Y"
                                           << "\n  volatility:    " << io::volatility(v)
                                           << "\n  price:         " << value
                                           << "\n  implied vol:   " << io::volatility(implVol)
                                           << "\n  implied price: " << value2);
                            }
                        }
                    }
                }
            }
        }
    }
}

void CapFloorTest::testCachedValue() {

    BOOST_TEST_MESSAGE("Testing Black cap/floor price against cached values...");

    using namespace capfloor_test;

    CommonVars vars;

    Date cachedToday(14,March,2002),
         cachedSettlement(18,March,2002);
    Settings::instance().evaluationDate() = cachedToday;
    vars.termStructure.linkTo(flatRate(cachedSettlement, 0.05, Actual360()));
    Date startDate = vars.termStructure->referenceDate();
    Leg leg = vars.makeLeg(startDate,20);
    ext::shared_ptr<Instrument> cap = vars.makeCapFloor(CapFloor::Cap,leg,
                                                          0.07,0.20);
    ext::shared_ptr<Instrument> floor = vars.makeCapFloor(CapFloor::Floor,leg,
                                                            0.03,0.20);

    Real cachedCapNPV, cachedFloorNPV ;
    if (!IborCoupon::usingAtParCoupons()) {
        // index fixing price
        cachedCapNPV   = 6.87630307745,
        cachedFloorNPV = 2.65796764715;
    } else {
        // par coupon price
        cachedCapNPV   = 6.87570026732;
        cachedFloorNPV = 2.65812927959;
    }

    // test Black cap price against cached value
    if (std::fabs(cap->NPV()-cachedCapNPV) > 1.0e-11)
        BOOST_ERROR(
            "failed to reproduce cached cap value:\n"
            << std::setprecision(12)
            << "    calculated: " << cap->NPV() << "\n"
            << "    expected:   " << cachedCapNPV);
    // test Black floor price against cached value
    if (std::fabs(floor->NPV()-cachedFloorNPV) > 1.0e-11)
        BOOST_ERROR(
            "failed to reproduce cached floor value:\n"
            << std::setprecision(12)
            << "    calculated: " << floor->NPV() << "\n"
            << "    expected:   " << cachedFloorNPV);
}

void CapFloorTest::testCachedValueFromOptionLets() {

    BOOST_TEST_MESSAGE("Testing Black cap/floor price as a sum of optionlets prices against cached values...");

    using namespace capfloor_test;

    CommonVars vars;

    Date cachedToday(14,March,2002),
         cachedSettlement(18,March,2002);
    Settings::instance().evaluationDate() = cachedToday;
    ext::shared_ptr<YieldTermStructure> baseCurve = flatRate(cachedSettlement, 
                                                             0.05, Actual360());                                              
    vars.termStructure.linkTo(baseCurve);
    Date startDate = vars.termStructure->referenceDate();
    Leg leg = vars.makeLeg(startDate,20);  

    ext::shared_ptr<Instrument> cap = vars.makeCapFloor(CapFloor::Cap,leg,
                                                          0.07,0.20);
    ext::shared_ptr<Instrument> floor = vars.makeCapFloor(CapFloor::Floor,leg,
                                                            0.03,0.20);
    Real calculatedCapletsNPV = 0.0,
         calculatedFloorletsNPV = 0.0;

    Real cachedCapNPV, cachedFloorNPV;
    if (IborCoupon::usingAtParCoupons()) {
        cachedCapNPV = 6.87570026732;
        cachedFloorNPV = 2.65812927959;
    } else {
        cachedCapNPV = 6.87630307745;
        cachedFloorNPV = 2.65796764715;
    }

    // test Black floor price against cached value
    std::vector<Real> capletPrices;
    std::vector<Real> floorletPrices;
    
    capletPrices = cap->result<std::vector<Real> >("optionletsPrice");
    floorletPrices = floor->result<std::vector<Real> >("optionletsPrice");
    
    if (capletPrices.size() != 40)
        BOOST_ERROR(
            "failed to produce prices for all caplets:\n"
            << "    calculated: " << capletPrices.size() << " caplet prices\n"
            << "    expected:   " << 40);

    for (double capletPrice : capletPrices) {
        calculatedCapletsNPV += capletPrice;
    }

    for (double floorletPrice : floorletPrices) {
        calculatedFloorletsNPV += floorletPrice;
    }

    if (std::fabs(calculatedCapletsNPV-cachedCapNPV) > 1.0e-11)
        BOOST_ERROR(
            "failed to reproduce cached cap value from its caplets' values:\n"
            << std::setprecision(12)
            << "    calculated: " << calculatedCapletsNPV << "\n"
            << "    expected:   " << cachedCapNPV);
    // test Black floor price against cached value
    if (std::fabs(calculatedFloorletsNPV-cachedFloorNPV) > 1.0e-11)
        BOOST_ERROR(
            "failed to reproduce cached floor value from its floorlets' values:\n"
            << std::setprecision(12)
            << "    calculated: " << calculatedFloorletsNPV << "\n"
            << "    expected:   " << cachedFloorNPV);
}

void CapFloorTest::testOptionLetsDelta() {

    BOOST_TEST_MESSAGE("Testing Black caplet/floorlet delta coefficients against finite difference values...");

    using namespace capfloor_test;

    CommonVars vars;

    Date cachedToday(14,March,2002),
         cachedSettlement(18,March,2002);
    Settings::instance().evaluationDate() = cachedToday;
    ext::shared_ptr<YieldTermStructure> baseCurve = flatRate(cachedSettlement, 
                                                             0.05, Actual360());
    RelinkableHandle<YieldTermStructure> baseCurveHandle(baseCurve);

    // Define spreaded curve with eps as spread used for FD sensitivities
    Real eps = 1.0e-6;
    ext::shared_ptr<SimpleQuote> spread(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> spreadCurve(new ZeroSpreadedTermStructure(
                                                            baseCurveHandle,
                                                            Handle<Quote>(spread),
                                                            Continuous,
                                                            Annual,
                                                            Actual360()));                                               
    vars.termStructure.linkTo(spreadCurve);
    Date startDate = vars.termStructure->referenceDate();
    Leg leg = vars.makeLeg(startDate,20);  

    ext::shared_ptr<CapFloor> cap = vars.makeCapFloor(CapFloor::Cap,leg,
                                                          0.05,0.20);
    ext::shared_ptr<CapFloor> floor = vars.makeCapFloor(CapFloor::Floor,leg,
                                                            0.05,0.20);

    
    //so far tests pass, now try to get additional results and it will fail
    Size capletsNum = cap->capRates().size();
    std::vector<Real> capletUpPrices, 
                      capletDownPrices,
                      capletAnalyticDelta,
                      capletDiscountFactorsUp,
                      capletDiscountFactorsDown,
                      capletForwardsUp,
                      capletForwardsDown,
                      capletFDDelta(capletsNum, 0.0); 
    Size floorletNum = floor->floorRates().size();
    std::vector<Real> floorletUpPrices, 
                      floorletDownPrices,
                      floorletAnalyticDelta,
                      floorletDiscountFactorsUp,
                      floorletDiscountFactorsDown,
                      floorletForwardsUp,
                      floorletForwardsDown,
                      floorletFDDelta(floorletNum, 0.0);
    
    capletAnalyticDelta = cap->result<std::vector<Real> >("optionletsDelta");
    floorletAnalyticDelta = floor->result<std::vector<Real> >("optionletsDelta");
    
    spread->setValue(eps);
    capletUpPrices = cap->result<std::vector<Real> >("optionletsPrice");
    floorletUpPrices = floor->result<std::vector<Real> >("optionletsPrice");
    capletDiscountFactorsUp = cap->result<std::vector<Real> >("optionletsDiscountFactor");
    floorletDiscountFactorsUp = floor->result<std::vector<Real> >("optionletsDiscountFactor");
    capletForwardsUp = cap->result<std::vector<Real> >("optionletsAtmForward");
    floorletForwardsUp = floor->result<std::vector<Real> >("optionletsAtmForward");
    
    spread->setValue(-eps);
    capletDownPrices = cap->result<std::vector<Real> >("optionletsPrice");
    floorletDownPrices = floor->result<std::vector<Real> >("optionletsPrice");
    capletDiscountFactorsDown = cap->result<std::vector<Real> >("optionletsDiscountFactor");
    floorletDiscountFactorsDown = floor->result<std::vector<Real> >("optionletsDiscountFactor");
    capletForwardsDown = cap->result<std::vector<Real> >("optionletsAtmForward");
    floorletForwardsDown = floor->result<std::vector<Real> >("optionletsAtmForward");

    Real accrualFactor;
    Leg capLeg = cap->floatingLeg();
    Leg floorLeg = floor->floatingLeg();
    
    for (Size n=1; n < capletUpPrices.size(); n++){
        // calculating only caplet's FD sensitivity w.r.t. forward rate
        // without the effect of sensitivity related to changed discount factor
        ext::shared_ptr<FloatingRateCoupon> c = ext::dynamic_pointer_cast<FloatingRateCoupon>(capLeg[n]);
        accrualFactor = c->nominal() * c->accrualPeriod() * c->gearing();
        capletFDDelta[n] = (capletUpPrices[n] / capletDiscountFactorsUp[n]
                           - capletDownPrices[n] / capletDiscountFactorsDown[n]) 
                           / (capletForwardsUp[n] - capletForwardsDown[n])
                           / accrualFactor;
    }

    for (Size n=0; n<floorletUpPrices.size(); n++){
        // calculating only caplet's FD sensitivity w.r.t. forward rate
        // without the effect of sensitivity related to changed discount factor
        ext::shared_ptr<FloatingRateCoupon> c = ext::dynamic_pointer_cast<FloatingRateCoupon>(floorLeg[n]);
        accrualFactor = c->nominal() * c->accrualPeriod() * c->gearing();
        floorletFDDelta[n] = (floorletUpPrices[n] / floorletDiscountFactorsUp[n] 
                             - floorletDownPrices[n] / floorletDiscountFactorsDown[n]) 
                             / (floorletForwardsUp[n] - floorletForwardsDown[n])
                             / accrualFactor;        
    }

    for (Size n=0; n<capletAnalyticDelta.size(); n++){
        if (std::fabs(capletAnalyticDelta[n]-capletFDDelta[n]) > 1.0e-6)
            BOOST_ERROR(
                "failed to compare analytical and finite difference caplet delta:\n"
                << "caplet number:\t" << n << "\n"
                << std::setprecision(12)
                << "    finite difference: " << capletFDDelta[n]<< "\n"
                << "    analytical value:   " << capletAnalyticDelta[n] << "\n"
                << "    resulting ratio: " << capletFDDelta[n] / capletAnalyticDelta[n]);    
    }

    for (Size n=0; n<floorletAnalyticDelta.size(); n++){
        if (std::fabs(floorletAnalyticDelta[n]-floorletFDDelta[n]) > 1.0e-6)
            BOOST_ERROR(
                "failed to compare analytical and finite difference floorlet delta:\n"
                << "floorlet number:\t" << n << "\n"
                << std::setprecision(12)
                << "    finite difference: " << floorletFDDelta[n]<< "\n"
                << "    analytical value:   " << floorletAnalyticDelta[n] << "\n"
                << "    resulting ratio: " << floorletFDDelta[n] / floorletAnalyticDelta[n]);    
    }

}

void CapFloorTest::testBachelierOptionLetsDelta() {

    BOOST_TEST_MESSAGE("Testing Bachelier caplet/floorlet delta coefficients against finite difference values...");

    using namespace capfloor_test;

    CommonVars vars;

    Date cachedToday(14,March,2002),
         cachedSettlement(18,March,2002);
    Settings::instance().evaluationDate() = cachedToday;
    ext::shared_ptr<YieldTermStructure> baseCurve = flatRate(cachedSettlement, 
                                                             0.05, Actual360());
    RelinkableHandle<YieldTermStructure> baseCurveHandle(baseCurve);

    // Define spreaded curve with eps as spread used for FD sensitivities
    Real eps = 1.0e-6;
    ext::shared_ptr<SimpleQuote> spread(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> spreadCurve(new ZeroSpreadedTermStructure(
                                                            baseCurveHandle,
                                                            Handle<Quote>(spread),
                                                            Continuous,
                                                            Annual,
                                                            Actual360()));                                               
    vars.termStructure.linkTo(spreadCurve);
    Date startDate = vars.termStructure->referenceDate();
    Leg leg = vars.makeLeg(startDate,20);  

    // Use normal model (BachelierCapFloorEngine)
    bool isLogNormal = false;

    ext::shared_ptr<CapFloor> cap = vars.makeCapFloor(CapFloor::Cap,leg,
                                                      0.05, 0.01, isLogNormal);
    ext::shared_ptr<CapFloor> floor = vars.makeCapFloor(CapFloor::Floor,leg,
                                                        0.05, 0.01, isLogNormal);

    
    //so far tests pass, now try to get additional results and it will fail
    Size capletsNum = cap->capRates().size();
    std::vector<Real> capletUpPrices, 
                      capletDownPrices,
                      capletAnalyticDelta,
                      capletDiscountFactorsUp,
                      capletDiscountFactorsDown,
                      capletForwardsUp,
                      capletForwardsDown,
                      capletFDDelta(capletsNum, 0.0); 
    Size floorletNum = floor->floorRates().size();
    std::vector<Real> floorletUpPrices, 
                      floorletDownPrices,
                      floorletAnalyticDelta,
                      floorletDiscountFactorsUp,
                      floorletDiscountFactorsDown,
                      floorletForwardsUp,
                      floorletForwardsDown,
                      floorletFDDelta(floorletNum, 0.0);
    
    capletAnalyticDelta = cap->result<std::vector<Real> >("optionletsDelta");
    floorletAnalyticDelta = floor->result<std::vector<Real> >("optionletsDelta");
    
    spread->setValue(eps);
    capletUpPrices = cap->result<std::vector<Real> >("optionletsPrice");
    floorletUpPrices = floor->result<std::vector<Real> >("optionletsPrice");
    capletDiscountFactorsUp = cap->result<std::vector<Real> >("optionletsDiscountFactor");
    floorletDiscountFactorsUp = floor->result<std::vector<Real> >("optionletsDiscountFactor");
    capletForwardsUp = cap->result<std::vector<Real> >("optionletsAtmForward");
    floorletForwardsUp = floor->result<std::vector<Real> >("optionletsAtmForward");
    
    spread->setValue(-eps);
    capletDownPrices = cap->result<std::vector<Real> >("optionletsPrice");
    floorletDownPrices = floor->result<std::vector<Real> >("optionletsPrice");
    capletDiscountFactorsDown = cap->result<std::vector<Real> >("optionletsDiscountFactor");
    floorletDiscountFactorsDown = floor->result<std::vector<Real> >("optionletsDiscountFactor");
    capletForwardsDown = cap->result<std::vector<Real> >("optionletsAtmForward");
    floorletForwardsDown = floor->result<std::vector<Real> >("optionletsAtmForward");

    Real accrualFactor;
    Leg capLeg = cap->floatingLeg();
    Leg floorLeg = floor->floatingLeg();
    
    for (Size n=1; n < capletUpPrices.size(); n++){
        // calculating only caplet's FD sensitivity w.r.t. forward rate
        // without the effect of sensitivity related to changed discount factor
        ext::shared_ptr<FloatingRateCoupon> c = ext::dynamic_pointer_cast<FloatingRateCoupon>(capLeg[n]);
        accrualFactor = c->nominal() * c->accrualPeriod() * c->gearing();
        capletFDDelta[n] = (capletUpPrices[n] / capletDiscountFactorsUp[n]
                           - capletDownPrices[n] / capletDiscountFactorsDown[n]) 
                           / (capletForwardsUp[n] - capletForwardsDown[n])
                           / accrualFactor;
    }

    for (Size n=0; n<floorletUpPrices.size(); n++){
        // calculating only caplet's FD sensitivity w.r.t. forward rate
        // without the effect of sensitivity related to changed discount factor
        ext::shared_ptr<FloatingRateCoupon> c = ext::dynamic_pointer_cast<FloatingRateCoupon>(floorLeg[n]);
        accrualFactor = c->nominal() * c->accrualPeriod() * c->gearing();
        floorletFDDelta[n] = (floorletUpPrices[n] / floorletDiscountFactorsUp[n] 
                             - floorletDownPrices[n] / floorletDiscountFactorsDown[n]) 
                             / (floorletForwardsUp[n] - floorletForwardsDown[n])
                             / accrualFactor;        
    }

    for (Size n=0; n<capletAnalyticDelta.size(); n++){
        if (std::fabs(capletAnalyticDelta[n]-capletFDDelta[n]) > 1.0e-6)
            BOOST_ERROR(
                "failed to compare analytical and finite difference caplet delta:\n"
                << "caplet number:\t" << n << "\n"
                << std::setprecision(12)
                << "    finite difference: " << capletFDDelta[n]<< "\n"
                << "    analytical value:   " << capletAnalyticDelta[n] << "\n"
                << "    resulting ratio: " << capletFDDelta[n] / capletAnalyticDelta[n]);    
    }

    for (Size n=0; n<floorletAnalyticDelta.size(); n++){
        if (std::fabs(floorletAnalyticDelta[n]-floorletFDDelta[n]) > 1.0e-6)
            BOOST_ERROR(
                "failed to compare analytical and finite difference floorlet delta:\n"
                << "floorlet number:\t" << n << "\n"
                << std::setprecision(12)
                << "    finite difference: " << floorletFDDelta[n]<< "\n"
                << "    analytical value:   " << floorletAnalyticDelta[n] << "\n"
                << "    resulting ratio: " << floorletFDDelta[n] / floorletAnalyticDelta[n]);    
    }

}

test_suite* CapFloorTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Cap and floor tests");
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testStrikeDependency));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testConsistency));
    // FLOATING_POINT_EXCEPTION
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testParity));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testVega));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testATMRate));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testImpliedVolatility));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testCachedValue));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testCachedValueFromOptionLets));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testOptionLetsDelta));
    suite->add(QUANTLIB_TEST_CASE(&CapFloorTest::testBachelierOptionLetsDelta));
    return suite;
}

]]></document_content>
  </document>
  <document index="37">
    <source>capfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2019 Wojciech lusarski

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cap_floor_hpp
#define quantlib_test_cap_floor_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CapFloorTest {
  public:
    static void testStrikeDependency();
    static void testConsistency();
    static void testParity();
    static void testVega();
    static void testATMRate();
    static void testImpliedVolatility();
    static void testCachedValue();
    static void testCachedValueFromOptionLets();
    static void testOptionLetsDelta();
    static void testBachelierOptionLetsDelta();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="38">
    <source>capflooredcoupon.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "capflooredcoupon.hpp"
#include "utilities.hpp"
#include <ql/instruments/capfloor.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/math/matrix.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace capfloored_coupon_test {

    struct CommonVars {
        // global data
        Date today, settlement, startDate;
        Calendar calendar;
        Real nominal;
        std::vector<Real> nominals;
        BusinessDayConvention convention;
        Frequency frequency;
        ext::shared_ptr<IborIndex> index;
        Natural settlementDays, fixingDays;
        RelinkableHandle<YieldTermStructure> termStructure;
        std::vector<Rate> caps;
        std::vector<Rate> floors;
        Integer length;
        Volatility volatility;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            length = 20;           //years
            volatility = 0.20;
            nominal = 100.;
            nominals = std::vector<Real>(length,nominal);
            frequency = Annual;
            index = ext::shared_ptr<IborIndex>(new Euribor1Y(termStructure));
            calendar = index->fixingCalendar();
            convention = ModifiedFollowing;
            today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;
            settlementDays = 2;
            fixingDays = 2;
            settlement = calendar.advance(today,settlementDays,Days);
            startDate = settlement;
            termStructure.linkTo(flatRate(settlement,0.05,
                                          ActualActual(ActualActual::ISDA)));
        }

        // utilities
        Leg makeFixedLeg(const Date& startDate, Integer length) const {

            Date endDate = calendar.advance(startDate, length, Years,
                                            convention);
            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              convention, convention,
                              DateGeneration::Forward, false);
            std::vector<Rate> coupons(length, 0.0);
            return FixedRateLeg(schedule)
                .withNotionals(nominals)
                .withCouponRates(coupons, Thirty360(Thirty360::BondBasis));
        }

        Leg makeFloatingLeg(const Date& startDate,
                            Integer length,
                            const Rate gearing = 1.0,
                            const Rate spread = 0.0) const {

            Date endDate = calendar.advance(startDate,length,Years,convention);
            Schedule schedule(startDate,endDate,Period(frequency),calendar,
                              convention,convention,
                              DateGeneration::Forward,false);
            std::vector<Real> gearingVector(length, gearing);
            std::vector<Spread> spreadVector(length, spread);
            return IborLeg(schedule, index)
                .withNotionals(nominals)
                .withPaymentDayCounter(index->dayCounter())
                .withPaymentAdjustment(convention)
                .withFixingDays(fixingDays)
                .withGearings(gearingVector)
                .withSpreads(spreadVector);
        }

        Leg makeCapFlooredLeg(const Date& startDate,
                              Integer length,
                              const std::vector<Rate>& caps,
                              const std::vector<Rate>& floors,
                              Volatility volatility,
                              const Rate gearing = 1.0,
                              const Rate spread = 0.0) const {

            Date endDate = calendar.advance(startDate,length,Years,convention);
            Schedule schedule(startDate,endDate,Period(frequency),calendar,
                              convention,convention,
                              DateGeneration::Forward,false);
            Handle<OptionletVolatilityStructure> vol(
                ext::shared_ptr<OptionletVolatilityStructure>(new
                    ConstantOptionletVolatility(0, calendar, Following,
                                                volatility,Actual365Fixed())));

            ext::shared_ptr<IborCouponPricer> pricer(new
                BlackIborCouponPricer(vol));
            std::vector<Rate> gearingVector(length, gearing);
            std::vector<Spread> spreadVector(length, spread);

            Leg iborLeg = IborLeg(schedule, index)
                .withNotionals(nominals)
                .withPaymentDayCounter(index->dayCounter())
                .withPaymentAdjustment(convention)
                .withFixingDays(fixingDays)
                .withGearings(gearingVector)
                .withSpreads(spreadVector)
                .withCaps(caps)
                .withFloors(floors);
            setCouponPricer(iborLeg, pricer);
            return iborLeg;
        }

        ext::shared_ptr<PricingEngine> makeEngine(Volatility volatility) const {
            Handle<Quote> vol(ext::shared_ptr<Quote>(
                                                new SimpleQuote(volatility)));
            return ext::shared_ptr<PricingEngine>(
                                 new BlackCapFloorEngine(termStructure, vol));
        }

        ext::shared_ptr<CapFloor> makeCapFloor(CapFloor::Type type,
                                               const Leg& leg,
                                               Rate capStrike,
                                               Rate floorStrike,
                                               Volatility volatility) const {
            ext::shared_ptr<CapFloor> result;
            switch (type) {
              case CapFloor::Cap:
                result = ext::shared_ptr<CapFloor>(
                               new Cap(leg, std::vector<Rate>(1, capStrike)));
                break;
              case CapFloor::Floor:
                result = ext::shared_ptr<CapFloor>(
                           new Floor(leg, std::vector<Rate>(1, floorStrike)));
                break;
              case CapFloor::Collar:
                result = ext::shared_ptr<CapFloor>(
                               new Collar(leg,
                                          std::vector<Rate>(1, capStrike),
                                          std::vector<Rate>(1, floorStrike)));
                break;
              default:
                QL_FAIL("unknown cap/floor type");
            }
            result->setPricingEngine(makeEngine(volatility));
            return result;
        }
    };

}


void CapFlooredCouponTest::testLargeRates() {

    BOOST_TEST_MESSAGE("Testing degenerate collared coupon...");

    using namespace capfloored_coupon_test;

    CommonVars vars;

    /* A vanilla floating leg and a capped floating leg with strike
       equal to 100 and floor equal to 0 must have (about) the same NPV
       (depending on variance: option expiry and volatility)
    */

    std::vector<Rate> caps(vars.length,100.0);
    std::vector<Rate> floors(vars.length,0.0);
    Real tolerance = 1e-10;

    // fixed leg with zero rate
    Leg fixedLeg =
        vars.makeFixedLeg(vars.startDate,vars.length);
    Leg floatLeg =
        vars.makeFloatingLeg(vars.startDate,vars.length);
    Leg collaredLeg =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,
                               caps,floors,vars.volatility);

    ext::shared_ptr<PricingEngine> engine(
                               new DiscountingSwapEngine(vars.termStructure));
    Swap vanillaLeg(fixedLeg,floatLeg);
    Swap collarLeg(fixedLeg,collaredLeg);
    vanillaLeg.setPricingEngine(engine);
    collarLeg.setPricingEngine(engine);

    if (std::abs(vanillaLeg.NPV()-collarLeg.NPV())>tolerance) {
        BOOST_ERROR("Length: " << vars.length << " y" << "\n" <<
                    "Volatility: " << vars.volatility*100 << "%\n" <<
                    "Notional: " << vars.nominal << "\n" <<
                    "Vanilla floating leg NPV: " << vanillaLeg.NPV()
                    << "\n" <<
                    "Collared floating leg NPV (strikes 0 and 100): "
                    << collarLeg.NPV()
                    << "\n" <<
                    "Diff: " << std::abs(vanillaLeg.NPV()-collarLeg.NPV()));
   }
}

void CapFlooredCouponTest::testDecomposition() {

    BOOST_TEST_MESSAGE("Testing collared coupon against its decomposition...");

    using namespace capfloored_coupon_test;

    CommonVars vars;

    Real tolerance = 1e-12;
    Real npvVanilla,npvCappedLeg,npvFlooredLeg,npvCollaredLeg,npvCap,npvFloor,npvCollar;
    Real error;
    Rate floorstrike = 0.05;
    Rate capstrike = 0.10;
    std::vector<Rate> caps(vars.length,capstrike);
    std::vector<Rate> caps0 = std::vector<Rate>();
    std::vector<Rate> floors(vars.length,floorstrike);
    std::vector<Rate> floors0 = std::vector<Rate>();
    Rate gearing_p = Rate(0.5);
    auto spread_p = Spread(0.002);
    Rate gearing_n = Rate(-1.5);
    auto spread_n = Spread(0.12);
    // fixed leg with zero rate
    Leg fixedLeg  =
        vars.makeFixedLeg(vars.startDate,vars.length);
    // floating leg with gearing=1 and spread=0
    Leg floatLeg  =
        vars.makeFloatingLeg(vars.startDate,vars.length);
    // floating leg with positive gearing (gearing_p) and spread<>0
    Leg floatLeg_p =
        vars.makeFloatingLeg(vars.startDate,vars.length,gearing_p,spread_p);
    // floating leg with negative gearing (gearing_n) and spread<>0
    Leg floatLeg_n =
        vars.makeFloatingLeg(vars.startDate,vars.length,gearing_n,spread_n);
    // Swap with null fixed leg and floating leg with gearing=1 and spread=0
    Swap vanillaLeg(fixedLeg,floatLeg);
    // Swap with null fixed leg and floating leg with positive gearing and spread<>0
    Swap vanillaLeg_p(fixedLeg,floatLeg_p);
    // Swap with null fixed leg and floating leg with negative gearing and spread<>0
    Swap vanillaLeg_n(fixedLeg,floatLeg_n);

    ext::shared_ptr<PricingEngine> engine(
                               new DiscountingSwapEngine(vars.termStructure));
    vanillaLeg.setPricingEngine(engine);
    vanillaLeg_p.setPricingEngine(engine);
    vanillaLeg_n.setPricingEngine(engine);

    /* CAPPED coupon - Decomposition of payoff
       Payoff = Nom * Min(rate,strike) * accrualperiod =
              = Nom * [rate + Min(0,strike-rate)] * accrualperiod =
              = Nom * rate * accrualperiod - Nom * Max(rate-strike,0) * accrualperiod =
              = VanillaFloatingLeg - Call
    */

    // Case gearing = 1 and spread = 0
    Leg cappedLeg =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,
                               caps,floors0,vars.volatility);
    Swap capLeg(fixedLeg,cappedLeg);
    capLeg.setPricingEngine(engine);
    Cap cap(floatLeg, std::vector<Rate>(1, capstrike));
    cap.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg.NPV();
    npvCappedLeg = capLeg.NPV();
    npvCap = cap.NPV();
    error = std::abs(npvCappedLeg - (npvVanilla-npvCap));
    if (error>tolerance) {
        BOOST_ERROR("\nCapped Leg: gearing=1, spread=0%, strike=" << capstrike*100 <<
                    "%\n" <<
                    "  Capped Floating Leg NPV: " << npvCappedLeg << "\n" <<
                    "  Floating Leg NPV - Cap NPV: " << npvVanilla - npvCap << "\n" <<
                    "  Diff: " << error );
    }

    /* gearing = 1 and spread = 0
       FLOORED coupon - Decomposition of payoff
       Payoff = Nom * Max(rate,strike) * accrualperiod =
              = Nom * [rate + Max(0,strike-rate)] * accrualperiod =
              = Nom * rate * accrualperiod + Nom * Max(strike-rate,0) * accrualperiod =
              = VanillaFloatingLeg + Put
    */

    Leg flooredLeg =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,
                               caps0,floors,vars.volatility);
    Swap floorLeg(fixedLeg,flooredLeg);
    floorLeg.setPricingEngine(engine);
    Floor floor(floatLeg, std::vector<Rate>(1, floorstrike));
    floor.setPricingEngine(vars.makeEngine(vars.volatility));
    npvFlooredLeg = floorLeg.NPV();
    npvFloor = floor.NPV();
    error = std::abs(npvFlooredLeg-(npvVanilla + npvFloor));
    if (error>tolerance) {
        BOOST_ERROR("Floored Leg: gearing=1, spread=0%, strike=" << floorstrike *100 <<
                    "%\n" <<
                    "  Floored Floating Leg NPV: " << npvFlooredLeg << "\n" <<
                    "  Floating Leg NPV + Floor NPV: " << npvVanilla + npvFloor << "\n" <<
                    "  Diff: " << error );
    }

    /* gearing = 1 and spread = 0
       COLLARED coupon - Decomposition of payoff
       Payoff = Nom * Min(strikem,Max(rate,strikeM)) * accrualperiod =
              = VanillaFloatingLeg - Collar
    */

    Leg collaredLeg =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,
                               caps,floors,vars.volatility);
    Swap collarLeg(fixedLeg,collaredLeg);
    collarLeg.setPricingEngine(engine);
    Collar collar(floatLeg,
                  std::vector<Rate>(1, capstrike),
                  std::vector<Rate>(1, floorstrike));
    collar.setPricingEngine(vars.makeEngine(vars.volatility));
    npvCollaredLeg = collarLeg.NPV();
    npvCollar = collar.NPV();
    error = std::abs(npvCollaredLeg -(npvVanilla - npvCollar));
    if (error>tolerance) {
        BOOST_ERROR("\nCollared Leg: gearing=1, spread=0%, strike=" <<
                    floorstrike*100 << "% and " << capstrike*100 << "%\n" <<
                    "  Collared Floating Leg NPV: " << npvCollaredLeg << "\n" <<
                    "  Floating Leg NPV - Collar NPV: " << npvVanilla - npvCollar << "\n" <<
                    "  Diff: " << error );
    }

    /* gearing = a and spread = b
       CAPPED coupon - Decomposition of payoff
       Payoff
       = Nom * Min(a*rate+b,strike) * accrualperiod =
       = Nom * [a*rate+b + Min(0,strike-a*rate-b)] * accrualperiod =
       = Nom * a*rate+b * accrualperiod + Nom * Min(strike-b-a*rate,0) * accrualperiod
       --> If a>0 (assuming positive effective strike):
           Payoff = VanillaFloatingLeg - Call(a*rate+b,strike)
       --> If a<0 (assuming positive effective strike):
           Payoff = VanillaFloatingLeg + Nom * Min(strike-b+|a|*rate+,0) * accrualperiod =
                  = VanillaFloatingLeg + Put(|a|*rate+b,strike)
    */

    // Positive gearing
    Leg cappedLeg_p =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,caps,floors0,
                               vars.volatility,gearing_p,spread_p);
    Swap capLeg_p(fixedLeg,cappedLeg_p);
    capLeg_p.setPricingEngine(engine);
    Cap cap_p(floatLeg_p,std::vector<Rate>(1,capstrike));
    cap_p.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg_p.NPV();
    npvCappedLeg = capLeg_p.NPV();
    npvCap = cap_p.NPV();
    error = std::abs(npvCappedLeg - (npvVanilla-npvCap));
    if (error>tolerance) {
        BOOST_ERROR("\nCapped Leg: gearing=" << gearing_p << ", " <<
                    "spread= " << spread_p *100 <<
                    "%, strike=" << capstrike*100  << "%, " <<
                    "effective strike= " << (capstrike-spread_p)/gearing_p*100 <<
                     "%\n" <<
                     "  Capped Floating Leg NPV: " << npvCappedLeg << "\n" <<
                     "  Vanilla Leg NPV: " << npvVanilla << "\n" <<
                     "  Cap NPV: " << npvCap << "\n" <<
                     "  Floating Leg NPV - Cap NPV: " << npvVanilla - npvCap << "\n" <<
                     "  Diff: " << error );
    }

    // Negative gearing
    Leg cappedLeg_n =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,caps,floors0,
                               vars.volatility,gearing_n,spread_n);
    Swap capLeg_n(fixedLeg,cappedLeg_n);
    capLeg_n.setPricingEngine(engine);
    Floor floor_n(floatLeg,std::vector<Rate>(1,(capstrike-spread_n)/gearing_n));
    floor_n.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg_n.NPV();
    npvCappedLeg = capLeg_n.NPV();
    npvFloor = floor_n.NPV();
    error = std::abs(npvCappedLeg - (npvVanilla+ gearing_n*npvFloor));
    if (error>tolerance) {
        BOOST_ERROR("\nCapped Leg: gearing=" << gearing_n << ", " <<
                    "spread= " << spread_n *100 <<
                    "%, strike=" << capstrike*100  << "%, " <<
                    "effective strike= " << (capstrike-spread_n)/gearing_n*100 <<
                     "%\n" <<
                     "  Capped Floating Leg NPV: " << npvCappedLeg << "\n" <<
                     "  npv Vanilla: " << npvVanilla << "\n" <<
                     "  npvFloor: " << npvFloor << "\n" <<
                     "  Floating Leg NPV - Cap NPV: " << npvVanilla + gearing_n*npvFloor << "\n" <<
                     "  Diff: " << error );
    }

    /* gearing = a and spread = b
       FLOORED coupon - Decomposition of payoff
       Payoff
       = Nom * Max(a*rate+b,strike) * accrualperiod =
       = Nom * [a*rate+b + Max(0,strike-a*rate-b)] * accrualperiod =
       = Nom * a*rate+b * accrualperiod + Nom * Max(strike-b-a*rate,0) * accrualperiod
       --> If a>0 (assuming positive effective strike):
           Payoff = VanillaFloatingLeg + Put(a*rate+b,strike)
       --> If a<0 (assuming positive effective strike):
           Payoff = VanillaFloatingLeg + Nom * Max(strike-b+|a|*rate+,0) * accrualperiod =
                  = VanillaFloatingLeg - Call(|a|*rate+b,strike)
    */

    // Positive gearing
    Leg flooredLeg_p1 =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,caps0,floors,
                               vars.volatility,gearing_p,spread_p);
    Swap floorLeg_p1(fixedLeg,flooredLeg_p1);
    floorLeg_p1.setPricingEngine(engine);
    Floor floor_p1(floatLeg_p,std::vector<Rate>(1,floorstrike));
    floor_p1.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg_p.NPV();
    npvFlooredLeg = floorLeg_p1.NPV();
    npvFloor = floor_p1.NPV();
    error = std::abs(npvFlooredLeg - (npvVanilla+npvFloor));
    if (error>tolerance) {
        BOOST_ERROR("\nFloored Leg: gearing=" << gearing_p << ", "
                      << "spread= " << spread_p *100<< "%, strike=" << floorstrike *100 << "%, "
                      << "effective strike= " << (floorstrike-spread_p)/gearing_p*100
                      << "%\n" <<
                      "  Floored Floating Leg NPV: "    << npvFlooredLeg
                      << "\n" <<
                      "  Floating Leg NPV + Floor NPV: " << npvVanilla + npvFloor
                      << "\n" <<
                      "  Diff: " << error );
    }
    // Negative gearing
    Leg flooredLeg_n =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,caps0,floors,
                               vars.volatility,gearing_n,spread_n);
    Swap floorLeg_n(fixedLeg,flooredLeg_n);
    floorLeg_n.setPricingEngine(engine);
    Cap cap_n(floatLeg,std::vector<Rate>(1,(floorstrike-spread_n)/gearing_n));
    cap_n.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg_n.NPV();
    npvFlooredLeg = floorLeg_n.NPV();
    npvCap = cap_n.NPV();
    error = std::abs(npvFlooredLeg - (npvVanilla - gearing_n*npvCap));
    if (error>tolerance) {
        BOOST_ERROR("\nCapped Leg: gearing=" << gearing_n << ", " <<
                    "spread= " << spread_n *100 <<
                    "%, strike=" << floorstrike*100  << "%, " <<
                    "effective strike= " << (floorstrike-spread_n)/gearing_n*100 <<
                     "%\n" <<
                     "  Capped Floating Leg NPV: " << npvFlooredLeg << "\n" <<
                     "  Floating Leg NPV - Cap NPV: " << npvVanilla - gearing_n*npvCap << "\n" <<
                     "  Diff: " << error );
    }
    /* gearing = a and spread = b
       COLLARED coupon - Decomposition of payoff
       Payoff = Nom * Min(caprate,Max(a*rate+b,floorrate)) * accrualperiod
       --> If a>0 (assuming positive effective strike):
           Payoff = VanillaFloatingLeg - Collar(a*rate+b, floorrate, caprate)
       --> If a<0 (assuming positive effective strike):
           Payoff = VanillaFloatingLeg + Collar(|a|*rate+b, caprate, floorrate)
    */
    // Positive gearing
    Leg collaredLeg_p =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,caps,floors,
                               vars.volatility,gearing_p,spread_p);
    Swap collarLeg_p1(fixedLeg,collaredLeg_p);
    collarLeg_p1.setPricingEngine(engine);
    Collar collar_p(floatLeg_p,
                    std::vector<Rate>(1,capstrike),
                    std::vector<Rate>(1,floorstrike));
    collar_p.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg_p.NPV();
    npvCollaredLeg = collarLeg_p1.NPV();
    npvCollar = collar_p.NPV();
    error = std::abs(npvCollaredLeg - (npvVanilla - npvCollar));
    if (error>tolerance) {
        BOOST_ERROR("\nCollared Leg: gearing=" << gearing_p << ", "
                      << "spread= " << spread_p*100 << "%, strike="
                      << floorstrike*100 << "% and " << capstrike*100
                      << "%, "
                      << "effective strike=" << (floorstrike-spread_p)/gearing_p*100
                      <<  "% and " << (capstrike-spread_p)/gearing_p*100
                      << "%\n" <<
                      "  Collared Floating Leg NPV: "    << npvCollaredLeg
                      << "\n" <<
                      "  Floating Leg NPV - Collar NPV: " << npvVanilla - npvCollar
                      << "\n" <<
                      "  Diff: " << error );
    }
    // Negative gearing
    Leg collaredLeg_n =
        vars.makeCapFlooredLeg(vars.startDate,vars.length,caps,floors,
                               vars.volatility,gearing_n,spread_n);
    Swap collarLeg_n1(fixedLeg,collaredLeg_n);
    collarLeg_n1.setPricingEngine(engine);
    Collar collar_n(floatLeg,
                    std::vector<Rate>(1,(floorstrike-spread_n)/gearing_n),
                    std::vector<Rate>(1,(capstrike-spread_n)/gearing_n));
    collar_n.setPricingEngine(vars.makeEngine(vars.volatility));
    npvVanilla = vanillaLeg_n.NPV();
    npvCollaredLeg = collarLeg_n1.NPV();
    npvCollar = collar_n.NPV();
    error = std::abs(npvCollaredLeg - (npvVanilla - gearing_n*npvCollar));
    if (error>tolerance) {
        BOOST_ERROR("\nCollared Leg: gearing=" << gearing_n << ", "
                      << "spread= " << spread_n*100 << "%, strike="
                      << floorstrike*100 << "% and " << capstrike*100
                      << "%, "
                      << "effective strike=" << (floorstrike-spread_n)/gearing_n*100
                      <<  "% and " << (capstrike-spread_n)/gearing_n*100
                      << "%\n" <<
                      "  Collared Floating Leg NPV: "    << npvCollaredLeg
                      << "\n" <<
                      "  Floating Leg NPV - Collar NPV: " << npvVanilla - gearing_n*npvCollar
                      << "\n" <<
                      "  Diff: " << error );
    }
}

test_suite* CapFlooredCouponTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Capped and floored coupon tests");
    suite->add(QUANTLIB_TEST_CASE(&CapFlooredCouponTest::testLargeRates));
    suite->add(QUANTLIB_TEST_CASE(&CapFlooredCouponTest::testDecomposition));
    return suite;
}

]]></document_content>
  </document>
  <document index="39">
    <source>capflooredcoupon.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cap_floored_coupon_hpp
#define quantlib_test_cap_floored_coupon_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CapFlooredCouponTest {
  public:
    static void testLargeRates();
    static void testDecomposition();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="40">
    <source>cashflows.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "cashflows.hpp"
#include "utilities.hpp"
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/settings.hpp>


using namespace QuantLib;
using namespace boost::unit_test_framework;
using boost::none;

void CashFlowsTest::testSettings() {

    BOOST_TEST_MESSAGE("Testing cash-flow settings...");

    SavedSettings backup;

    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    // cash flows at T+0, T+1, T+2
    std::vector<ext::shared_ptr<CashFlow> > leg;
    leg.reserve(3);
    for (Integer i = 0; i < 3; ++i)
        leg.push_back(ext::shared_ptr<CashFlow>(new SimpleCashFlow(1.0, today+i)));


    #define CHECK_INCLUSION(n, days, expected) \
    if ((!leg[n]->hasOccurred(today+days)) != expected) { \
        BOOST_ERROR("cashflow at T+" << n << " " \
                    << (expected ? "not" : "") << "included" \
                    << " at T+" << days); \
    }

    // case 1: don't include reference-date payments, no override at
    //         today's date

    Settings::instance().includeReferenceDateEvents() = false;
    Settings::instance().includeTodaysCashFlows() = none;

    CHECK_INCLUSION(0, 0, false);
    CHECK_INCLUSION(0, 1, false);

    CHECK_INCLUSION(1, 0, true);
    CHECK_INCLUSION(1, 1, false);
    CHECK_INCLUSION(1, 2, false);

    CHECK_INCLUSION(2, 1, true);
    CHECK_INCLUSION(2, 2, false);
    CHECK_INCLUSION(2, 3, false);

    // case 2: same, but with explicit setting at today's date

    Settings::instance().includeReferenceDateEvents() = false;
    Settings::instance().includeTodaysCashFlows() = false;

    CHECK_INCLUSION(0, 0, false);
    CHECK_INCLUSION(0, 1, false);

    CHECK_INCLUSION(1, 0, true);
    CHECK_INCLUSION(1, 1, false);
    CHECK_INCLUSION(1, 2, false);

    CHECK_INCLUSION(2, 1, true);
    CHECK_INCLUSION(2, 2, false);
    CHECK_INCLUSION(2, 3, false);

    // case 3: do include reference-date payments, no override at
    //         today's date

    Settings::instance().includeReferenceDateEvents() = true;
    Settings::instance().includeTodaysCashFlows() = none;

    CHECK_INCLUSION(0, 0, true);
    CHECK_INCLUSION(0, 1, false);

    CHECK_INCLUSION(1, 0, true);
    CHECK_INCLUSION(1, 1, true);
    CHECK_INCLUSION(1, 2, false);

    CHECK_INCLUSION(2, 1, true);
    CHECK_INCLUSION(2, 2, true);
    CHECK_INCLUSION(2, 3, false);

    // case 4: do include reference-date payments, explicit (and same)
    //         setting at today's date

    Settings::instance().includeReferenceDateEvents() = true;
    Settings::instance().includeTodaysCashFlows() = true;

    CHECK_INCLUSION(0, 0, true);
    CHECK_INCLUSION(0, 1, false);

    CHECK_INCLUSION(1, 0, true);
    CHECK_INCLUSION(1, 1, true);
    CHECK_INCLUSION(1, 2, false);

    CHECK_INCLUSION(2, 1, true);
    CHECK_INCLUSION(2, 2, true);
    CHECK_INCLUSION(2, 3, false);

    // case 5: do include reference-date payments, override at
    //         today's date

    Settings::instance().includeReferenceDateEvents() = true;
    Settings::instance().includeTodaysCashFlows() = false;

    CHECK_INCLUSION(0, 0, false);
    CHECK_INCLUSION(0, 1, false);

    CHECK_INCLUSION(1, 0, true);
    CHECK_INCLUSION(1, 1, true);
    CHECK_INCLUSION(1, 2, false);

    CHECK_INCLUSION(2, 1, true);
    CHECK_INCLUSION(2, 2, true);
    CHECK_INCLUSION(2, 3, false);


    // no discount to make calculations easier
    InterestRate no_discount(0.0, Actual365Fixed(), Continuous, Annual);

    #define CHECK_NPV(includeRef, expected)                             \
    do {                                                            \
        Real NPV = CashFlows::npv(leg, no_discount, includeRef, today); \
        if (std::fabs(NPV - expected) > 1e-6) {                         \
            BOOST_ERROR("NPV mismatch:\n"                               \
                        << "    calculated: " << NPV << "\n"            \
                        << "    expected: " << expected);               \
        }                                                               \
    } while (false);

    // no override
    Settings::instance().includeTodaysCashFlows() = none;

    CHECK_NPV(false, 2.0);
    CHECK_NPV(true, 3.0);
    
    // override
    Settings::instance().includeTodaysCashFlows() = false;
    
    CHECK_NPV(false, 2.0);
    CHECK_NPV(true, 2.0);

}

void CashFlowsTest::testAccessViolation() {
    BOOST_TEST_MESSAGE("Testing dynamic cast of coupon in Black pricer...");

    SavedSettings backup;

    Date todaysDate(7, April, 2010);
    Date settlementDate(9, April, 2010);
    Settings::instance().evaluationDate() = todaysDate;
    Calendar calendar = TARGET();

    Handle<YieldTermStructure> rhTermStructure(
        flatRate(settlementDate, 0.04875825, Actual365Fixed()));

    Volatility volatility = 0.10;
    Handle<OptionletVolatilityStructure> vol;
    vol = Handle<OptionletVolatilityStructure>(
             ext::shared_ptr<OptionletVolatilityStructure>(
                 new ConstantOptionletVolatility(
                             2,
                             calendar,
                             ModifiedFollowing,
                             volatility,
                             Actual365Fixed())));

    ext::shared_ptr<IborIndex> index3m (new USDLibor(3*Months,
                                                       rhTermStructure));

    Date payDate(20, December, 2013);
    Date startDate(20, September, 2013);
    Date endDate(20, December, 2013);
    Rate spread = 0.0115;
    ext::shared_ptr<IborCouponPricer> pricer(new BlackIborCouponPricer(vol));
    ext::shared_ptr<FloatingRateCoupon> coupon(
        new FloatingRateCoupon(payDate,100, startDate, endDate, 2,
                               index3m, 1.0 , spread / 100));
    coupon->setPricer(pricer);

    try {
        // this caused an access violation in version 1.0
        coupon->amount();
    } catch (Error&) {
        // ok; proper exception thrown
    }
}

void CashFlowsTest::testDefaultSettlementDate() {
    BOOST_TEST_MESSAGE("Testing default evaluation date in cashflows methods...");
    Date today = Settings::instance().evaluationDate();
    Schedule schedule =
        MakeSchedule()
        .from(today-2*Months).to(today+4*Months)
        .withFrequency(Semiannual)
        .withCalendar(TARGET())
        .withConvention(Unadjusted)
        .backwards();

    Leg leg = FixedRateLeg(schedule)
              .withNotionals(100.0)
              .withCouponRates(0.03, Actual360())
              .withPaymentCalendar(TARGET())
              .withPaymentAdjustment(Following);

    Time accruedPeriod = CashFlows::accruedPeriod(leg, false);
    if (accruedPeriod == 0.0)
        BOOST_ERROR("null accrued period with default settlement date");

    Date::serial_type accruedDays = CashFlows::accruedDays(leg, false);
    if (accruedDays == 0)
        BOOST_ERROR("no accrued days with default settlement date");

    Real accruedAmount = CashFlows::accruedAmount(leg, false);
    if (accruedAmount == 0.0)
        BOOST_ERROR("null accrued amount with default settlement date");
}

void CashFlowsTest::testNullFixingDays() {
    BOOST_TEST_MESSAGE("Testing ibor leg construction with null fixing days...");
    Date today = Settings::instance().evaluationDate();
    Schedule schedule =
        MakeSchedule()
        .from(today-2*Months).to(today+4*Months)
        .withFrequency(Semiannual)
        .withCalendar(TARGET())
        .withConvention(Following)
        .backwards();

    ext::shared_ptr<IborIndex> index(new USDLibor(6*Months));
    Leg leg = IborLeg(schedule, index)
        .withNotionals(100.0)
        // this can happen with default values, and caused an
        // exception when the null was not managed properly
        .withFixingDays(Null<Natural>());
}

void CashFlowsTest::testExCouponDates() {
    BOOST_TEST_MESSAGE("Testing ex-coupon date calculation...");

    Date today = Date::todaysDate();
    Schedule schedule = MakeSchedule()
                            .from(today)
                            .to(today + 5 * Years)
                            .withFrequency(Monthly)
                            .withCalendar(TARGET())
                            .withConvention(Following);

    // no ex-coupon dates
    Leg l1 = FixedRateLeg(schedule).withNotionals(100.0).withCouponRates(0.03, Actual360());
    for (auto& i : l1) {
        ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(i);
        if (c->exCouponDate() != Date()) {
            BOOST_ERROR("ex-coupon date found (none expected)");
        }
    }

    // same for floating legs
    ext::shared_ptr<IborIndex> index(new Euribor3M);
    Leg l2 = IborLeg(schedule, index).withNotionals(100.0);
    for (auto& i : l2) {
        ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(i);
        if (c->exCouponDate() != Date()) {
            BOOST_ERROR("ex-coupon date found (none expected)");
        }
    }

    // calendar days
    Leg l5 = FixedRateLeg(schedule)
                 .withNotionals(100.0)
                 .withCouponRates(0.03, Actual360())
                 .withExCouponPeriod(Period(2, Days), NullCalendar(), Unadjusted, false);
    for (auto& i : l5) {
        ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(i);
        Date expected = c->accrualEndDate() - 2;
        if (c->exCouponDate() != expected) {
            BOOST_ERROR("ex-coupon date = " << c->exCouponDate() << " (" << expected
                                            << " expected)");
        }
    }

    Leg l6 = IborLeg(schedule, index)
                 .withNotionals(100.0)
                 .withExCouponPeriod(Period(2, Days), NullCalendar(), Unadjusted, false);
    for (auto& i : l6) {
        ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(i);
        Date expected = c->accrualEndDate() - 2;
        if (c->exCouponDate() != expected) {
            BOOST_ERROR("ex-coupon date = " << c->exCouponDate() << " (" << expected
                                            << " expected)");
        }
    }

    // business days
    Leg l7 = FixedRateLeg(schedule)
                 .withNotionals(100.0)
                 .withCouponRates(0.03, Actual360())
                 .withExCouponPeriod(Period(2, Days), TARGET(), Preceding, false);
    for (auto& i : l7) {
        ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(i);
        Date expected = TARGET().advance(c->accrualEndDate(), -2, Days);
        if (c->exCouponDate() != expected) {
            BOOST_ERROR("ex-coupon date = " << c->exCouponDate() << " (" << expected
                                            << " expected)");
        }
    }

    Leg l8 = IborLeg(schedule, index)
                 .withNotionals(100.0)
                 .withExCouponPeriod(Period(2, Days), TARGET(), Preceding, false);
    for (auto& i : l8) {
        ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(i);
        Date expected = TARGET().advance(c->accrualEndDate(), -2, Days);
        if (c->exCouponDate() != expected) {
            BOOST_ERROR("ex-coupon date = " << c->exCouponDate() << " (" << expected
                                            << " expected)");
        }
    }
}

void CashFlowsTest::testIrregularFirstCouponReferenceDatesAtEndOfMonth() {
    BOOST_TEST_MESSAGE("Testing irregular first coupon reference dates with end of month enabled...");
    Schedule schedule =
        MakeSchedule()
        .from(Date(17, January, 2017)).to(Date(28, February, 2018))
        .withFrequency(Semiannual)
        .withConvention(Unadjusted)
        .endOfMonth()
        .backwards();

    Leg leg = FixedRateLeg(schedule)
        .withNotionals(100.0)
        .withCouponRates(0.01, Actual360());

    ext::shared_ptr<Coupon> firstCoupon =
        ext::dynamic_pointer_cast<Coupon>(leg.front());

    if (firstCoupon->referencePeriodStart() != Date(31, August, 2016))
        BOOST_ERROR("Expected reference start date at end of month, "
                    "got " << firstCoupon->referencePeriodStart());
}

void CashFlowsTest::testIrregularLastCouponReferenceDatesAtEndOfMonth() {
    BOOST_TEST_MESSAGE("Testing irregular last coupon reference dates with end of month enabled...");
    Schedule schedule =
            MakeSchedule()
                    .from(Date(17, January, 2017)).to(Date(15, September, 2018))
                    .withNextToLastDate(Date(28, February, 2018))
                    .withFrequency(Semiannual)
                    .withConvention(Unadjusted)
                    .endOfMonth()
                    .backwards();

    Leg leg = FixedRateLeg(schedule)
            .withNotionals(100.0)
            .withCouponRates(0.01, Actual360());

    ext::shared_ptr<Coupon> lastCoupon =
            ext::dynamic_pointer_cast<Coupon>(leg.back());

    if (lastCoupon->referencePeriodEnd() != Date(31, August, 2018))
        BOOST_ERROR("Expected reference end date at end of month, "
                            "got " << lastCoupon->referencePeriodEnd());
}

void CashFlowsTest::testPartialScheduleLegConstruction() {
    BOOST_TEST_MESSAGE("Testing leg construction with partial schedule...");
    // schedule with irregular first and last period
    Schedule schedule = MakeSchedule()
                            .from(Date(15, September, 2017))
                            .to(Date(30, September, 2020))
                            .withNextToLastDate(Date(25, September, 2020))
                            .withFrequency(Semiannual)
                            .backwards();
    // same schedule, date based, with metadata
    Schedule schedule2(schedule.dates(), NullCalendar(), Unadjusted, Unadjusted,
                       6 * Months, boost::none, schedule.endOfMonth(),
                       schedule.isRegular());
    // same schedule, date based, without metadata
    Schedule schedule3(schedule.dates());

    // fixed rate legs based on the three schedule
    Leg leg = FixedRateLeg(schedule).withNotionals(100.0).withCouponRates(
        0.01, ActualActual(ActualActual::ISMA));
    Leg leg2 = FixedRateLeg(schedule2).withNotionals(100.0).withCouponRates(
        0.01, ActualActual(ActualActual::ISMA));
    Leg leg3 = FixedRateLeg(schedule3).withNotionals(100.0).withCouponRates(
        0.01, ActualActual(ActualActual::ISMA));

    // check reference period of first and last coupon in all variants
    // for the first two we expect a 6M reference period, for the
    // third it can not be constructed, so should be equal to the
    // respective schedule period
    ext::shared_ptr<FixedRateCoupon> firstCpn =
        ext::dynamic_pointer_cast<FixedRateCoupon>(leg.front());
    ext::shared_ptr<FixedRateCoupon> lastCpn =
        ext::dynamic_pointer_cast<FixedRateCoupon>(leg.back());
    BOOST_REQUIRE(firstCpn != nullptr);
    BOOST_REQUIRE(lastCpn != nullptr);
    BOOST_CHECK_EQUAL(firstCpn->referencePeriodStart(), Date(25, Mar, 2017));
    BOOST_CHECK_EQUAL(firstCpn->referencePeriodEnd(), Date(25, Sep, 2017));
    BOOST_CHECK_EQUAL(lastCpn->referencePeriodStart(), Date(25, Sep, 2020));
    BOOST_CHECK_EQUAL(lastCpn->referencePeriodEnd(), Date(25, Mar, 2021));

    ext::shared_ptr<FixedRateCoupon> firstCpn2 =
        ext::dynamic_pointer_cast<FixedRateCoupon>(leg2.front());
    ext::shared_ptr<FixedRateCoupon> lastCpn2 =
        ext::dynamic_pointer_cast<FixedRateCoupon>(leg2.back());
    BOOST_REQUIRE(firstCpn2 != nullptr);
    BOOST_REQUIRE(lastCpn2 != nullptr);
    BOOST_CHECK_EQUAL(firstCpn2->referencePeriodStart(), Date(25, Mar, 2017));
    BOOST_CHECK_EQUAL(firstCpn2->referencePeriodEnd(), Date(25, Sep, 2017));
    BOOST_CHECK_EQUAL(lastCpn2->referencePeriodStart(), Date(25, Sep, 2020));
    BOOST_CHECK_EQUAL(lastCpn2->referencePeriodEnd(), Date(25, Mar, 2021));

    ext::shared_ptr<FixedRateCoupon> firstCpn3 =
        ext::dynamic_pointer_cast<FixedRateCoupon>(leg3.front());
    ext::shared_ptr<FixedRateCoupon> lastCpn3 =
        ext::dynamic_pointer_cast<FixedRateCoupon>(leg3.back());
    BOOST_REQUIRE(firstCpn3 != nullptr);
    BOOST_REQUIRE(lastCpn3 != nullptr);
    BOOST_CHECK_EQUAL(firstCpn3->referencePeriodStart(), Date(15, Sep, 2017));
    BOOST_CHECK_EQUAL(firstCpn3->referencePeriodEnd(), Date(25, Sep, 2017));
    BOOST_CHECK_EQUAL(lastCpn3->referencePeriodStart(), Date(25, Sep, 2020));
    BOOST_CHECK_EQUAL(lastCpn3->referencePeriodEnd(), Date(30, Sep, 2020));

    // same check as above for a floating leg
    ext::shared_ptr<IborIndex> iborIndex =
        ext::make_shared<USDLibor>(3 * Months);
    Leg legf = IborLeg(schedule, iborIndex)
                   .withNotionals(100.0)
                   .withPaymentDayCounter(ActualActual(ActualActual::ISMA));
    Leg legf2 = IborLeg(schedule2, iborIndex)
                    .withNotionals(100.0)
                    .withPaymentDayCounter(ActualActual(ActualActual::ISMA));
    Leg legf3 = IborLeg(schedule3, iborIndex)
                    .withNotionals(100.0)
                    .withPaymentDayCounter(ActualActual(ActualActual::ISMA));

    ext::shared_ptr<FloatingRateCoupon> firstCpnF =
        ext::dynamic_pointer_cast<FloatingRateCoupon>(legf.front());
    ext::shared_ptr<FloatingRateCoupon> lastCpnF =
        ext::dynamic_pointer_cast<FloatingRateCoupon>(legf.back());
    BOOST_REQUIRE(firstCpnF != nullptr);
    BOOST_REQUIRE(lastCpnF != nullptr);
    BOOST_CHECK_EQUAL(firstCpnF->referencePeriodStart(), Date(25, Mar, 2017));
    BOOST_CHECK_EQUAL(firstCpnF->referencePeriodEnd(), Date(25, Sep, 2017));
    BOOST_CHECK_EQUAL(lastCpnF->referencePeriodStart(), Date(25, Sep, 2020));
    BOOST_CHECK_EQUAL(lastCpnF->referencePeriodEnd(), Date(25, Mar, 2021));

    ext::shared_ptr<FloatingRateCoupon> firstCpnF2 =
        ext::dynamic_pointer_cast<FloatingRateCoupon>(legf2.front());
    ext::shared_ptr<FloatingRateCoupon> lastCpnF2 =
        ext::dynamic_pointer_cast<FloatingRateCoupon>(legf2.back());
    BOOST_REQUIRE(firstCpnF2 != nullptr);
    BOOST_REQUIRE(lastCpnF2 != nullptr);
    BOOST_CHECK_EQUAL(firstCpnF2->referencePeriodStart(), Date(25, Mar, 2017));
    BOOST_CHECK_EQUAL(firstCpnF2->referencePeriodEnd(), Date(25, Sep, 2017));
    BOOST_CHECK_EQUAL(lastCpnF2->referencePeriodStart(), Date(25, Sep, 2020));
    BOOST_CHECK_EQUAL(lastCpnF2->referencePeriodEnd(), Date(25, Mar, 2021));

    ext::shared_ptr<FloatingRateCoupon> firstCpnF3 =
        ext::dynamic_pointer_cast<FloatingRateCoupon>(legf3.front());
    ext::shared_ptr<FloatingRateCoupon> lastCpnF3 =
        ext::dynamic_pointer_cast<FloatingRateCoupon>(legf3.back());
    BOOST_REQUIRE(firstCpnF3 != nullptr);
    BOOST_REQUIRE(lastCpnF3 != nullptr);
    BOOST_CHECK_EQUAL(firstCpnF3->referencePeriodStart(), Date(15, Sep, 2017));
    BOOST_CHECK_EQUAL(firstCpnF3->referencePeriodEnd(), Date(25, Sep, 2017));
    BOOST_CHECK_EQUAL(lastCpnF3->referencePeriodStart(), Date(25, Sep, 2020));
    BOOST_CHECK_EQUAL(lastCpnF3->referencePeriodEnd(), Date(30, Sep, 2020));
}

test_suite* CashFlowsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Cash flows tests");
    suite->add(QUANTLIB_TEST_CASE(&CashFlowsTest::testSettings));
    suite->add(QUANTLIB_TEST_CASE(&CashFlowsTest::testAccessViolation));
    suite->add(QUANTLIB_TEST_CASE(&CashFlowsTest::testDefaultSettlementDate));
    suite->add(QUANTLIB_TEST_CASE(&CashFlowsTest::testExCouponDates));
    if (IborCoupon::usingAtParCoupons())
        suite->add(QUANTLIB_TEST_CASE(&CashFlowsTest::testNullFixingDays));

    suite->add(QUANTLIB_TEST_CASE(
                             &CashFlowsTest::testIrregularFirstCouponReferenceDatesAtEndOfMonth));
    suite->add(QUANTLIB_TEST_CASE(
                             &CashFlowsTest::testIrregularLastCouponReferenceDatesAtEndOfMonth));
    suite->add(QUANTLIB_TEST_CASE(
                             &CashFlowsTest::testPartialScheduleLegConstruction));
    return suite;
}
]]></document_content>
  </document>
  <document index="41">
    <source>cashflows.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cashflows_hpp
#define quantlib_test_cashflows_hpp

#include <boost/test/unit_test.hpp>

class CashFlowsTest {
  public:
    static void testSettings();
    static void testAccessViolation();
    static void testDefaultSettlementDate();
    static void testExCouponDates();
    static void testNullFixingDays();
    static void testIrregularFirstCouponReferenceDatesAtEndOfMonth();
    static void testIrregularLastCouponReferenceDatesAtEndOfMonth();
    static void testPartialScheduleLegConstruction();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="42">
    <source>catbonds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "catbonds.hpp"
#include "utilities.hpp"
#include <ql/types.hpp>
#include <ql/experimental/catbonds/catbond.hpp>
#include <ql/experimental/catbonds/catrisk.hpp>
#include <ql/experimental/catbonds/montecarlocatbondengine.hpp>
#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/calendars/brazil.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/business252.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/time/schedule.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/termstructures/yield/flatforward.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace catbonds_test {
    std::pair<Date, Real> data[] = {std::pair<Date, Real>(Date(1, February, 2012), 100), std::pair<Date, Real>(Date(1, July, 2013), 150), std::pair<Date, Real>(Date(5, January, 2014), 50)};
    ext::shared_ptr<std::vector<std::pair<Date, Real> > > sampleEvents(new std::vector<std::pair<Date, Real> >(data, data+3));

    Date eventsStart(1, January, 2011);
    Date eventsEnd(31, December, 2014);
}

void CatBondTest::testEventSetForWholeYears() {
    BOOST_TEST_MESSAGE("Testing that catastrophe events are split correctly for periods of whole years...");

    using namespace catbonds_test;

    EventSet catRisk(sampleEvents, eventsStart, eventsEnd);
    ext::shared_ptr<CatSimulation> simulation = catRisk.newSimulation(Date(1, January, 2015), Date(31, December, 2015));

    BOOST_REQUIRE(simulation);

    std::vector<std::pair<Date, Real> > path;

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(0), path.size());

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(1), path.size());
    BOOST_CHECK_EQUAL(Date(1, February, 2015), path.at(0).first);
    BOOST_CHECK_EQUAL(100, path.at(0).second);

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(1), path.size());
    BOOST_CHECK_EQUAL(Date(1, July, 2015), path.at(0).first);
    BOOST_CHECK_EQUAL(150, path.at(0).second);

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(1), path.size());
    BOOST_CHECK_EQUAL(Date(5, January, 2015), path.at(0).first);
    BOOST_CHECK_EQUAL(50, path.at(0).second);

    BOOST_REQUIRE(!simulation->nextPath(path));
}


void CatBondTest::testEventSetForIrregularPeriods() {
    BOOST_TEST_MESSAGE("Testing that catastrophe events are split correctly for irregular periods...");

    using namespace catbonds_test;
    
    EventSet catRisk(sampleEvents, eventsStart, eventsEnd);
    ext::shared_ptr<CatSimulation> simulation = catRisk.newSimulation(Date(2, January, 2015), Date(5, January, 2016));

    BOOST_REQUIRE(simulation);

    std::vector<std::pair<Date, Real> > path;

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(0), path.size());

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(2), path.size());
    BOOST_CHECK_EQUAL(Date(1, July, 2015), path.at(0).first);
    BOOST_CHECK_EQUAL(150, path.at(0).second);
    BOOST_CHECK_EQUAL(Date(5, January, 2016), path.at(1).first);
    BOOST_CHECK_EQUAL(50, path.at(1).second);

    BOOST_REQUIRE(!simulation->nextPath(path));
}


void CatBondTest::testEventSetForNoEvents () {
    BOOST_TEST_MESSAGE("Testing that catastrophe events are split correctly when there are no simulated events...");

    using namespace catbonds_test;

    ext::shared_ptr<std::vector<std::pair<Date, Real> > > emptyEvents(new std::vector<std::pair<Date, Real> >());
    EventSet catRisk(emptyEvents, eventsStart, eventsEnd);
    ext::shared_ptr<CatSimulation> simulation = catRisk.newSimulation(Date(2, January, 2015), Date(5, January, 2016));

    BOOST_REQUIRE(simulation);

    std::vector<std::pair<Date, Real> > path;

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(0), path.size());

    BOOST_REQUIRE(simulation->nextPath(path));
    BOOST_CHECK_EQUAL(Size(0), path.size());

    BOOST_REQUIRE(!simulation->nextPath(path));
}

void CatBondTest::testBetaRisk() {
    BOOST_TEST_MESSAGE("Testing that beta risk gives correct terminal distribution...");

    const size_t PATHS = 1000000;
    BetaRisk catRisk(100.0, 100.0, 10.0, 15.0);
    ext::shared_ptr<CatSimulation> simulation = catRisk.newSimulation(Date(2, January, 2015), Date(2, January, 2018));
    BOOST_REQUIRE(simulation);

    std::vector<std::pair<Date, Real> > path;
    Real sum = 0.0;
    Real sumSquares = 0.0;
    Real poissonSum = 0.0;
    Real poissonSumSquares = 0.0;
    
    
    for(size_t i=0; i<PATHS; ++i)
    {
        BOOST_REQUIRE(simulation->nextPath(path));
        Real processValue = 0.0;
        for (auto& j : path)
            processValue += j.second;
        sum+=processValue;
        sumSquares+=processValue*processValue;
        poissonSum+=path.size();
        poissonSumSquares+=path.size()*path.size();
    }
    Real poissonMean = poissonSum/PATHS;
    BOOST_CHECK_CLOSE(Real(3.0/100.0), poissonMean, 2);
    Real poissonVar = poissonSumSquares/PATHS - poissonMean*poissonMean;
    BOOST_CHECK_CLOSE(Real(3.0/100.0), poissonVar, 5);
    
    Real expectedMean = 3.0*10.0/100.0;
    Real actualMean = sum/PATHS;
    BOOST_CHECK_CLOSE(expectedMean, actualMean, 1);
    
    Real expectedVar = 3.0*(15.0*15.0+10*10)/100.0;
    Real actualVar = sumSquares/PATHS - actualMean*actualMean;
    #if BOOST_VERSION > 106300
    // changes in Boost.Random after 1.64 increased numerical error
    BOOST_CHECK_CLOSE(expectedVar, actualVar, 1.5);
    #else
    BOOST_CHECK_CLOSE(expectedVar, actualVar, 1);
    #endif
}

namespace catbonds_test {

    struct CommonVars {
        // common data
        Calendar calendar;
        Date today;
        Real faceAmount;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            calendar = TARGET();
            today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;
            faceAmount = 1000000.0;
        }
    };
}

void CatBondTest::testRiskFreeAgainstFloatingRateBond() {
    BOOST_TEST_MESSAGE("Testing floating-rate cat bond against risk-free floating-rate bond...");

    using namespace catbonds_test;

    CommonVars vars;

    Date today(22,November,2004);
    Settings::instance().evaluationDate() = today;

    Natural settlementDays = 1;

    Handle<YieldTermStructure> riskFreeRate(flatRate(today,0.025,Actual360()));
    Handle<YieldTermStructure> discountCurve(flatRate(today,0.03,Actual360()));

    ext::shared_ptr<IborIndex> index(new USDLibor(6*Months, riskFreeRate));
    Natural fixingDays = 1;

    Real tolerance = 1.0e-6;

    ext::shared_ptr<IborCouponPricer> pricer(new
        BlackIborCouponPricer(Handle<OptionletVolatilityStructure>()));

    // plain

    Schedule sch(Date(30,November,2004),
                 Date(30,November,2008),
                 Period(Semiannual),
                 UnitedStates(UnitedStates::GovernmentBond),
                 ModifiedFollowing, ModifiedFollowing,
                 DateGeneration::Backward, false);

    ext::shared_ptr<CatRisk> noCatRisk(new EventSet(
        ext::make_shared<std::vector<std::pair<Date, Real> > >(), 
        Date(1, Jan, 2000), Date(31, Dec, 2010)));

    ext::shared_ptr<EventPaymentOffset> paymentOffset(new NoOffset());
    ext::shared_ptr<NotionalRisk> notionalRisk(new DigitalNotionalRisk(paymentOffset, 100));

    FloatingRateBond bond1(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           ModifiedFollowing, fixingDays,
                           std::vector<Real>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    FloatingCatBond catBond1(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk, 
                           ModifiedFollowing, fixingDays,
                           std::vector<Real>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    ext::shared_ptr<PricingEngine> bondEngine(
                                     new DiscountingBondEngine(riskFreeRate));
    bond1.setPricingEngine(bondEngine);
    setCouponPricer(bond1.cashflows(),pricer);

    ext::shared_ptr<PricingEngine> catBondEngine(new MonteCarloCatBondEngine(noCatRisk, riskFreeRate));
    catBond1.setPricingEngine(catBondEngine);
    setCouponPricer(catBond1.cashflows(),pricer);

    Real cachedPrice1;
    if (!IborCoupon::usingAtParCoupons())
        cachedPrice1 = 99.874645;
    else
        cachedPrice1 = 99.874646;

    Real price = bond1.cleanPrice();
    Real catPrice = catBond1.cleanPrice();
    if (std::fabs(price-cachedPrice1) > tolerance || std::fabs(catPrice-price) > tolerance) {
        BOOST_FAIL("failed to reproduce floating rate bond price:\n"
                   << std::fixed
                   << "    floating bond: " << price << "\n"
                   << "    catBond bond: " << catPrice << "\n"
                   << "    expected:   " << cachedPrice1 << "\n"
                   << "    error:      " << catPrice-price);
    }

    

    // different risk-free and discount curve

    FloatingRateBond bond2(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           ModifiedFollowing, fixingDays,
                           std::vector<Rate>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    FloatingCatBond catBond2(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk,
                           ModifiedFollowing, fixingDays,
                           std::vector<Rate>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    ext::shared_ptr<PricingEngine> bondEngine2(
                                    new DiscountingBondEngine(discountCurve));
    bond2.setPricingEngine(bondEngine2);
    setCouponPricer(bond2.cashflows(),pricer);

    ext::shared_ptr<PricingEngine> catBondEngine2(new MonteCarloCatBondEngine(noCatRisk, discountCurve));
    catBond2.setPricingEngine(catBondEngine2);
    setCouponPricer(catBond2.cashflows(),pricer);

    Real cachedPrice2; 
    if (!IborCoupon::usingAtParCoupons())
        cachedPrice2 = 97.955904;
    else
        cachedPrice2 = 97.955904;

    price = bond2.cleanPrice();
    catPrice = catBond2.cleanPrice();
    if (std::fabs(price-cachedPrice2) > tolerance || std::fabs(catPrice-price) > tolerance) {
        BOOST_FAIL("failed to reproduce floating rate bond price:\n"
                   << std::fixed
                   << "    floating bond: " << price << "\n"
                   << "    catBond bond: " << catPrice << "\n"
                   << "    expected:   " << cachedPrice2 << "\n"
                   << "    error:      " << catPrice-price);
    }

    // varying spread

    std::vector<Rate> spreads(4);
    spreads[0] = 0.001;
    spreads[1] = 0.0012;
    spreads[2] = 0.0014;
    spreads[3] = 0.0016;

    FloatingRateBond bond3(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           ModifiedFollowing, fixingDays,
                           std::vector<Real>(), spreads,
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    FloatingCatBond catBond3(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk,
                           ModifiedFollowing, fixingDays,
                           std::vector<Real>(), spreads,
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    bond3.setPricingEngine(bondEngine2);
    setCouponPricer(bond3.cashflows(),pricer);

    catBond3.setPricingEngine(catBondEngine2);
    setCouponPricer(catBond3.cashflows(),pricer);

    Real cachedPrice3;
    if (!IborCoupon::usingAtParCoupons())
        cachedPrice3 = 98.495458;
    else
        cachedPrice3 = 98.495459;

    price = bond3.cleanPrice();
    catPrice = catBond3.cleanPrice();
    if (std::fabs(price-cachedPrice3) > tolerance || std::fabs(catPrice-price) > tolerance) {
        BOOST_FAIL("failed to reproduce floating rate bond price:\n"
                   << std::fixed
                   << "    floating bond: " << price << "\n"
                   << "    catBond bond: " << catPrice << "\n"
                   << "    expected:   " << cachedPrice2 << "\n"
                   << "    error:      " << catPrice-price);
    }
}



void CatBondTest::testCatBondInDoomScenario() {
    BOOST_TEST_MESSAGE("Testing floating-rate cat bond in a doom scenario (certain default)...");

    using namespace catbonds_test;

    CommonVars vars;

    Date today(22,November,2004);
    Settings::instance().evaluationDate() = today;

    Natural settlementDays = 1;

    Handle<YieldTermStructure> riskFreeRate(flatRate(today,0.025,Actual360()));
    Handle<YieldTermStructure> discountCurve(flatRate(today,0.03,Actual360()));

    ext::shared_ptr<IborIndex> index(new USDLibor(6*Months, riskFreeRate));
    Natural fixingDays = 1;

    Real tolerance = 1.0e-6;

    ext::shared_ptr<IborCouponPricer> pricer(new
        BlackIborCouponPricer(Handle<OptionletVolatilityStructure>()));

    Schedule sch(Date(30,November,2004),
                 Date(30,November,2008),
                 Period(Semiannual),
                 UnitedStates(UnitedStates::GovernmentBond),
                 ModifiedFollowing, ModifiedFollowing,
                 DateGeneration::Backward, false);

    ext::shared_ptr<std::vector<std::pair<Date, Real> > > events(new std::vector<std::pair<Date, Real> >());
    events->push_back(std::pair<Date, Real>(Date(30,November,2004), 1000));
    ext::shared_ptr<CatRisk> doomCatRisk(new EventSet(
        events, 
        Date(30,November,2004), Date(30,November,2008)));

    ext::shared_ptr<EventPaymentOffset> paymentOffset(new NoOffset());
    ext::shared_ptr<NotionalRisk> notionalRisk(new DigitalNotionalRisk(paymentOffset, 100));

    FloatingCatBond catBond(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk,
                           ModifiedFollowing, fixingDays,
                           std::vector<Rate>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    ext::shared_ptr<PricingEngine> catBondEngine(new MonteCarloCatBondEngine(doomCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngine);
    setCouponPricer(catBond.cashflows(),pricer);

    Real price = catBond.cleanPrice();
    BOOST_CHECK_EQUAL(0, price);

    Real lossProbability = catBond.lossProbability();
    Real exhaustionProbability = catBond.exhaustionProbability();
    Real expectedLoss = catBond.expectedLoss();

    BOOST_CHECK_CLOSE(Real(1.0), lossProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(1.0), exhaustionProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(1.0), expectedLoss, tolerance);
}


void CatBondTest::testCatBondWithDoomOnceInTenYears() {
    BOOST_TEST_MESSAGE("Testing floating-rate cat bond in a doom once in 10 years scenario...");

    using namespace catbonds_test;

    CommonVars vars;

    Date today(22,November,2004);
    Settings::instance().evaluationDate() = today;

    Natural settlementDays = 1;

    Handle<YieldTermStructure> riskFreeRate(flatRate(today,0.025,Actual360()));
    Handle<YieldTermStructure> discountCurve(flatRate(today,0.03,Actual360()));

    ext::shared_ptr<IborIndex> index(new USDLibor(6*Months, riskFreeRate));
    Natural fixingDays = 1;

    Real tolerance = 1.0e-6;

    ext::shared_ptr<IborCouponPricer> pricer(new
        BlackIborCouponPricer(Handle<OptionletVolatilityStructure>()));

    Schedule sch(Date(30,November,2004),
                 Date(30,November,2008),
                 Period(Semiannual),
                 UnitedStates(UnitedStates::GovernmentBond),
                 ModifiedFollowing, ModifiedFollowing,
                 DateGeneration::Backward, false);

    ext::shared_ptr<std::vector<std::pair<Date, Real> > > events(new std::vector<std::pair<Date, Real> >());
    events->push_back(std::pair<Date, Real>(Date(30,November,2008), 1000));
    ext::shared_ptr<CatRisk> doomCatRisk(new EventSet(
        events, 
        Date(30,November,2004), Date(30,November,2044)));

    ext::shared_ptr<CatRisk> noCatRisk(new EventSet(
        ext::make_shared<std::vector<std::pair<Date, Real> > >(), 
        Date(1, Jan, 2000), Date(31, Dec, 2010)));

    ext::shared_ptr<EventPaymentOffset> paymentOffset(new NoOffset());
    ext::shared_ptr<NotionalRisk> notionalRisk(new DigitalNotionalRisk(paymentOffset, 100));

    FloatingCatBond catBond(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk,
                           ModifiedFollowing, fixingDays,
                           std::vector<Rate>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    ext::shared_ptr<PricingEngine> catBondEngine(new MonteCarloCatBondEngine(doomCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngine);
    setCouponPricer(catBond.cashflows(),pricer);

    Real price = catBond.cleanPrice();
    Real yield = catBond.yield(ActualActual(ActualActual::ISMA), Simple, Annual);
    Real lossProbability = catBond.lossProbability();
    Real exhaustionProbability = catBond.exhaustionProbability();
    Real expectedLoss = catBond.expectedLoss();

    BOOST_CHECK_CLOSE(Real(0.1), lossProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(0.1), exhaustionProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(0.1), expectedLoss, tolerance);

    ext::shared_ptr<PricingEngine> catBondEngineRF(new MonteCarloCatBondEngine(noCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngineRF);

    Real riskFreePrice = catBond.cleanPrice();
    Real riskFreeYield = catBond.yield(ActualActual(ActualActual::ISMA), Simple, Annual);
    Real riskFreeLossProbability = catBond.lossProbability();
    Real riskFreeExhaustionProbability = catBond.exhaustionProbability();
    Real riskFreeExpectedLoss = catBond.expectedLoss();
    
    BOOST_CHECK_CLOSE(Real(0.0), riskFreeLossProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(0.0), riskFreeExhaustionProbability, tolerance);
    BOOST_CHECK(std::abs(riskFreeExpectedLoss) < tolerance);
    
    BOOST_CHECK_CLOSE(riskFreePrice*0.9, price, tolerance);
    BOOST_CHECK_LT(riskFreeYield, yield);
}

void CatBondTest::testCatBondWithDoomOnceInTenYearsProportional() {
    BOOST_TEST_MESSAGE("Testing floating-rate cat bond in a doom once in 10 years scenario with proportional notional reduction...");

    using namespace catbonds_test;

    CommonVars vars;

    Date today(22,November,2004);
    Settings::instance().evaluationDate() = today;

    Natural settlementDays = 1;

    Handle<YieldTermStructure> riskFreeRate(flatRate(today,0.025,Actual360()));
    Handle<YieldTermStructure> discountCurve(flatRate(today,0.03,Actual360()));

    ext::shared_ptr<IborIndex> index(new USDLibor(6*Months, riskFreeRate));
    Natural fixingDays = 1;

    Real tolerance = 1.0e-6;

    ext::shared_ptr<IborCouponPricer> pricer(new
        BlackIborCouponPricer(Handle<OptionletVolatilityStructure>()));

    Schedule sch(Date(30,November,2004),
                 Date(30,November,2008),
                 Period(Semiannual),
                 UnitedStates(UnitedStates::GovernmentBond),
                 ModifiedFollowing, ModifiedFollowing,
                 DateGeneration::Backward, false);

    ext::shared_ptr<std::vector<std::pair<Date, Real> > > events(new std::vector<std::pair<Date, Real> >());
    events->push_back(std::pair<Date, Real>(Date(30,November,2008), 1000));
    ext::shared_ptr<CatRisk> doomCatRisk(new EventSet(
        events, 
        Date(30,November,2004), Date(30,November,2044)));

    ext::shared_ptr<CatRisk> noCatRisk(new EventSet(
        ext::make_shared<std::vector<std::pair<Date, Real> > >(), 
        Date(1, Jan, 2000), Date(31, Dec, 2010)));

    ext::shared_ptr<EventPaymentOffset> paymentOffset(new NoOffset());
    ext::shared_ptr<NotionalRisk> notionalRisk(new ProportionalNotionalRisk(paymentOffset, 500, 1500));

    FloatingCatBond catBond(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk,
                           ModifiedFollowing, fixingDays,
                           std::vector<Rate>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    ext::shared_ptr<PricingEngine> catBondEngine(new MonteCarloCatBondEngine(doomCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngine);
    setCouponPricer(catBond.cashflows(),pricer);

    Real price = catBond.cleanPrice();
    Real yield = catBond.yield(ActualActual(ActualActual::ISMA), Simple, Annual);
    Real lossProbability = catBond.lossProbability();
    Real exhaustionProbability = catBond.exhaustionProbability();
    Real expectedLoss = catBond.expectedLoss();

    BOOST_CHECK_CLOSE(Real(0.1), lossProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(0.0), exhaustionProbability, tolerance);
    BOOST_CHECK_CLOSE(Real(0.05), expectedLoss, tolerance);

    ext::shared_ptr<PricingEngine> catBondEngineRF(new MonteCarloCatBondEngine(noCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngineRF);

    Real riskFreePrice = catBond.cleanPrice();
    Real riskFreeYield = catBond.yield(ActualActual(ActualActual::ISMA), Simple, Annual);
    Real riskFreeLossProbability = catBond.lossProbability();
    Real riskFreeExpectedLoss = catBond.expectedLoss();
    
    BOOST_CHECK_CLOSE(Real(0.0), riskFreeLossProbability, tolerance);
    BOOST_CHECK(std::abs(riskFreeExpectedLoss) < tolerance);
    
    BOOST_CHECK_CLOSE(riskFreePrice*0.95, price, tolerance);
    BOOST_CHECK_LT(riskFreeYield, yield);
}


void CatBondTest::testCatBondWithGeneratedEventsProportional() {
    BOOST_TEST_MESSAGE("Testing floating-rate cat bond in a generated scenario with proportional notional reduction...");

    using namespace catbonds_test;

    CommonVars vars;

    Date today(22,November,2004);
    Settings::instance().evaluationDate() = today;

    Natural settlementDays = 1;

    Handle<YieldTermStructure> riskFreeRate(flatRate(today,0.025,Actual360()));
    Handle<YieldTermStructure> discountCurve(flatRate(today,0.03,Actual360()));

    ext::shared_ptr<IborIndex> index(new USDLibor(6*Months, riskFreeRate));
    Natural fixingDays = 1;

    Real tolerance = 1.0e-6;

    ext::shared_ptr<IborCouponPricer> pricer(new
        BlackIborCouponPricer(Handle<OptionletVolatilityStructure>()));

    Schedule sch(Date(30,November,2004),
                 Date(30,November,2008),
                 Period(Semiannual),
                 UnitedStates(UnitedStates::GovernmentBond),
                 ModifiedFollowing, ModifiedFollowing,
                 DateGeneration::Backward, false);

    ext::shared_ptr<CatRisk> betaCatRisk(new BetaRisk(5000, 50, 500, 500));

    ext::shared_ptr<CatRisk> noCatRisk(new EventSet(
        ext::make_shared<std::vector<std::pair<Date, Real> > >(), 
        Date(1, Jan, 2000), Date(31, Dec, 2010)));

    ext::shared_ptr<EventPaymentOffset> paymentOffset(new NoOffset());
    ext::shared_ptr<NotionalRisk> notionalRisk(new ProportionalNotionalRisk(paymentOffset, 500, 1500));

    FloatingCatBond catBond(settlementDays, vars.faceAmount, sch,
                           index, ActualActual(ActualActual::ISMA),
                           notionalRisk,
                           ModifiedFollowing, fixingDays,
                           std::vector<Rate>(), std::vector<Spread>(),
                           std::vector<Rate>(), std::vector<Rate>(),
                           false,
                           100.0, Date(30,November,2004));

    ext::shared_ptr<PricingEngine> catBondEngine(new MonteCarloCatBondEngine(betaCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngine);
    setCouponPricer(catBond.cashflows(),pricer);

    Real price = catBond.cleanPrice();
    Real yield = catBond.yield(ActualActual(ActualActual::ISMA), Simple, Annual);
    Real lossProbability = catBond.lossProbability();
    Real exhaustionProbability = catBond.exhaustionProbability();
    Real expectedLoss = catBond.expectedLoss();

    BOOST_CHECK(lossProbability<1.0 && lossProbability>0.0);
    BOOST_CHECK(exhaustionProbability<1.0 && exhaustionProbability>0.0);
    BOOST_CHECK(expectedLoss>0.0);

    ext::shared_ptr<PricingEngine> catBondEngineRF(new MonteCarloCatBondEngine(noCatRisk, discountCurve));
    catBond.setPricingEngine(catBondEngineRF);

    Real riskFreePrice = catBond.cleanPrice();
    Real riskFreeYield = catBond.yield(ActualActual(ActualActual::ISMA), Simple, Annual);
    Real riskFreeLossProbability = catBond.lossProbability();
    Real riskFreeExpectedLoss = catBond.expectedLoss();
    
    BOOST_CHECK_CLOSE(Real(0.0), riskFreeLossProbability, tolerance);
    BOOST_CHECK(std::abs(riskFreeExpectedLoss) < tolerance);
    
    BOOST_CHECK_GT(riskFreePrice, price);
    BOOST_CHECK_LT(riskFreeYield, yield);
}

test_suite* CatBondTest::suite() {
    auto* suite = BOOST_TEST_SUITE("CatBond tests");

    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testEventSetForWholeYears));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testEventSetForIrregularPeriods));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testEventSetForNoEvents));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testBetaRisk));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testRiskFreeAgainstFloatingRateBond));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testCatBondInDoomScenario));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testCatBondWithDoomOnceInTenYears));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testCatBondWithDoomOnceInTenYearsProportional));
    suite->add(QUANTLIB_TEST_CASE(&CatBondTest::testCatBondWithGeneratedEventsProportional));
    return suite;
}
]]></document_content>
  </document>
  <document index="43">
    <source>catbonds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012, 2013 Grzegorz Andruszkiewicz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_catbond_hpp
#define quantlib_test_catbond_hpp

#include <boost/test/unit_test.hpp>

class CatBondTest {
  public:
    static void testEventSetForWholeYears();
    static void testEventSetForIrregularPeriods();
    static void testEventSetForNoEvents();
    static void testBetaRisk();
    static void testRiskFreeAgainstFloatingRateBond();
    static void testCatBondInDoomScenario();
    static void testCatBondWithDoomOnceInTenYears();
    static void testCatBondWithDoomOnceInTenYearsProportional();
    static void testCatBondWithGeneratedEventsProportional();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="44">
    <source>cdo.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "cdo.hpp"
#include "utilities.hpp"
#include <ql/experimental/credit/cdo.hpp>
#include <ql/experimental/credit/pool.hpp>
#include <ql/experimental/credit/integralcdoengine.hpp>
#include <ql/experimental/credit/midpointcdoengine.hpp>
#include <ql/experimental/credit/randomdefaultlatentmodel.hpp>
#include <ql/experimental/credit/inhomogeneouspooldef.hpp>
#include <ql/experimental/credit/homogeneouspooldef.hpp>
#include <ql/experimental/credit/gaussianlhplossmodel.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/currencies/europe.hpp>
#include <iomanip>
#include <iostream>

using namespace QuantLib;
using namespace std;
using namespace boost::unit_test_framework;

#ifndef QL_PATCH_SOLARIS

namespace cdo_test {

    Real hwAttachment[] = { 0.00, 0.03, 0.06, 0.10 };
    Real hwDetachment[] = { 0.03, 0.06, 0.10, 1.00 };

    struct hwDatum {
        Real correlation;
        Integer nm;
        Integer nz;
        Real trancheSpread[4];
    };

    // HW Table 7
    // corr, Nm, Nz, 0-3, 3-6, 6-10, 10-100
    hwDatum hwData7[] = {
        { 0.1, -1, -1, { 2279, 450,  89,  1 } },
        { 0.3, -1, -1, { 1487, 472, 203,  7 } },
        // Opening the T, T&G tests too. The convolution is analytical
        //   now so it runs it a time comparable to the gaussian tests and
        //   has enough precission to pass the tests.
        // Below the T models are integrated with a quadrature, even if this
        //   is incorrect the test pass good enough, the quadrature gets to
        //   be worst as the kernel deviates from a normal, this is low 
        //   orders of the T; here 5 is enough, 3 would not be.
        { 0.3, -1,  5, { 1766, 420, 161,  6 } },
        { 0.3,  5, -1, { 1444, 408, 171, 10 } },
        { 0.3,  5,  5, { 1713, 359, 136,  9 } }
    };

    void check(int i, int j, const string& desc, Real found, Real expected,
               Real bpTolerance, Real relativeTolerance) 
    {
        /* Uncomment to display the full show if your debugging:
        std::cout<< "Case: "<< i << " " << j << " " << found << " :: " 
            << expected  <<  " ("<< desc << ") " << std::endl;
        */
        Real absDiff = found - expected;
        Real relDiff = absDiff / expected;
        BOOST_CHECK_MESSAGE (fabs(relDiff) < relativeTolerance ||
                             fabs(absDiff) < bpTolerance,
                             "case " << i << " " << j << " ("<< desc << "): "
                             << found << " vs. " << expected);
    }

}

#endif


void CdoTest::testHW(unsigned dataSet) {
    #ifndef QL_PATCH_SOLARIS

    BOOST_TEST_MESSAGE ("Testing CDO premiums against Hull-White values"
                        " for data set " << dataSet << "...");

    using namespace cdo_test;

    SavedSettings backup;

    Size poolSize = 100;
    Real lambda = 0.01;

    // nBuckets and period determine the computation time
    Size nBuckets = 200;
    // Period period = 1*Months;
    // for MC engines
    Size numSims = 5000;

    Real rate = 0.05;
    DayCounter daycount = Actual360();
    Compounding cmp = Continuous; // Simple;

    Real recovery = 0.4;
    vector<Real> nominals(poolSize, 100.0);
    Real premium = 0.02;
    Period maxTerm (5, Years);
    Schedule schedule = MakeSchedule().from(Date (1, September, 2006))
                                      .to(Date (1, September, 2011))
                                      .withTenor(Period (3, Months))
                                      .withCalendar(TARGET());

    Date asofDate = Date(31, August, 2006);

    Settings::instance().evaluationDate() = asofDate;

    ext::shared_ptr<YieldTermStructure> yieldPtr(
                                              new FlatForward (asofDate, rate,
                                                               daycount, cmp));
    Handle<YieldTermStructure> yieldHandle (yieldPtr);

    Handle<Quote> hazardRate(ext::shared_ptr<Quote>(new SimpleQuote(lambda)));
    vector<Handle<DefaultProbabilityTermStructure> > basket;
    ext::shared_ptr<DefaultProbabilityTermStructure> ptr (
               new FlatHazardRate (asofDate,
                                   hazardRate,
                                   ActualActual(ActualActual::ISDA)));
    ext::shared_ptr<Pool> pool (new Pool());
    vector<string> names;
    // probability key items
    vector<Issuer> issuers;
    vector<pair<DefaultProbKey,
           Handle<DefaultProbabilityTermStructure> > > probabilities;
    probabilities.emplace_back(
        NorthAmericaCorpDefaultKey(EURCurrency(), SeniorSec, Period(0, Weeks), 10.),
        Handle<DefaultProbabilityTermStructure>(ptr));

    for (Size i=0; i<poolSize; ++i) {
        ostringstream o;
        o << "issuer-" << i;
        names.push_back(o.str());
        basket.emplace_back(ptr);
        issuers.emplace_back(probabilities);
        pool->add(names.back(), issuers.back(), NorthAmericaCorpDefaultKey(
                EURCurrency(), QuantLib::SeniorSec, Period(), 1.));
    }

    ext::shared_ptr<SimpleQuote> correlation (new SimpleQuote(0.0));
    Handle<Quote> hCorrelation (correlation);
    QL_REQUIRE (LENGTH(hwAttachment) == LENGTH(hwDetachment),
                "data length does not match");

    ext::shared_ptr<PricingEngine> midPCDOEngine( new MidPointCDOEngine(
        yieldHandle));
    ext::shared_ptr<PricingEngine> integralCDOEngine( new IntegralCDOEngine(
        yieldHandle));

    const Size i = dataSet;
    correlation->setValue (hwData7[i].correlation);
    QL_REQUIRE (LENGTH(hwAttachment) == LENGTH(hwData7[i].trancheSpread),
                "data length does not match");
    std::vector<ext::shared_ptr<DefaultLossModel> > basketModels;
    std::vector<std::string> modelNames;
    std::vector<Real> relativeToleranceMidp, relativeTolerancePeriod,
        absoluteTolerance;

    if (hwData7[i].nm == -1 && hwData7[i].nz == -1){
        ext::shared_ptr<GaussianConstantLossLM> gaussKtLossLM(new
            GaussianConstantLossLM(hCorrelation,
            std::vector<Real>(poolSize, recovery),
            LatentModelIntegrationType::GaussianQuadrature, poolSize,
            GaussianCopulaPolicy::initTraits()));

        // 1.-Inhomogeneous gaussian
        modelNames.emplace_back("Inhomogeneous gaussian");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            IHGaussPoolLossModel(gaussKtLossLM, nBuckets, 5., -5, 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 2.-homogeneous gaussian
        modelNames.emplace_back("Homogeneous gaussian");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            HomogGaussPoolLossModel(gaussKtLossLM, nBuckets, 5., -5, 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 3.-random default gaussian
        modelNames.emplace_back("Random default gaussian");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>(new
            RandomDefaultLM<GaussianCopulaPolicy>(gaussKtLossLM, numSims)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.07);
        relativeTolerancePeriod.push_back(0.07);
        // SECOND MC
        // gaussian LHP
        modelNames.emplace_back("Gaussian LHP");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>(new
            GaussianLHPLossModel(hCorrelation,
                std::vector<Real>(poolSize, recovery))));
        absoluteTolerance.push_back(10.);
        relativeToleranceMidp.push_back(0.5);
        relativeTolerancePeriod.push_back(0.5);
        // Binomial...
        // Saddle point...
        // Recursive ...
    }
    else if (hwData7[i].nm > 0 && hwData7[i].nz > 0) {
        TCopulaPolicy::initTraits initTG;
        initTG.tOrders.push_back(hwData7[i].nm);
        initTG.tOrders.push_back(hwData7[i].nz);
        ext::shared_ptr<TConstantLossLM> TKtLossLM(new TConstantLossLM(
            hCorrelation, std::vector<Real>(poolSize, recovery),
            LatentModelIntegrationType::GaussianQuadrature,
            poolSize,
            initTG));
        // 1.-inhomogeneous studentT
        modelNames.emplace_back("Inhomogeneous student");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            IHStudentPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 2.-homogeneous student T
        modelNames.emplace_back("Homogeneous student");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            HomogTPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 3.-random default student T
        modelNames.emplace_back("Random default studentT");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>(new
            RandomDefaultLM<TCopulaPolicy>(TKtLossLM, numSims)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.07);
        relativeTolerancePeriod.push_back(0.07);
        // SECOND MC
        // Binomial...
        // Saddle point...
        // Recursive ...
    }
    else if (hwData7[i].nm > 0 && hwData7[i].nz == -1) {
        TCopulaPolicy::initTraits initTG;
        initTG.tOrders.push_back(hwData7[i].nm);
        initTG.tOrders.push_back(45);
        /* T_{55} is pretty close to a gaussian. Probably theres no need to
        be this conservative as the polynomial convolution gets shorter and
        faster as the order decreases.
        */
        ext::shared_ptr<TConstantLossLM> TKtLossLM(new TConstantLossLM(
            hCorrelation,
            std::vector<Real>(poolSize, recovery),
            LatentModelIntegrationType::GaussianQuadrature,
            poolSize,
            initTG));
        // 1.-inhomogeneous
        modelNames.emplace_back("Inhomogeneous student-gaussian");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            IHStudentPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 2.-homogeneous
        modelNames.emplace_back("Homogeneous student-gaussian");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            HomogTPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 3.-random default
        modelNames.emplace_back("Random default student-gaussian");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>(new
            RandomDefaultLM<TCopulaPolicy>(TKtLossLM, numSims)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.07);
        relativeTolerancePeriod.push_back(0.07);
        // SECOND MC
        // Binomial...
        // Saddle point...
        // Recursive ...
    }
    else if (hwData7[i].nm == -1 && hwData7[i].nz > 0) {
        TCopulaPolicy::initTraits initTG;
        initTG.tOrders.push_back(45);// pretty close to gaussian
        initTG.tOrders.push_back(hwData7[i].nz);
        ext::shared_ptr<TConstantLossLM> TKtLossLM(new TConstantLossLM(
            hCorrelation,
            std::vector<Real>(poolSize, recovery),
            LatentModelIntegrationType::GaussianQuadrature,
            poolSize,
            initTG));
        // 1.-inhomogeneous gaussian
        modelNames.emplace_back("Inhomogeneous gaussian-student");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            IHStudentPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 2.-homogeneous gaussian
        modelNames.emplace_back("Homogeneous gaussian-student");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>( new
            HomogTPoolLossModel(TKtLossLM, nBuckets, 5., -5., 15)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.04);
        relativeTolerancePeriod.push_back(0.04);
        // 3.-random default gaussian
        modelNames.emplace_back("Random default gaussian-student");
        basketModels.push_back(ext::shared_ptr<DefaultLossModel>(new
            RandomDefaultLM<TCopulaPolicy>(TKtLossLM, numSims)));
        absoluteTolerance.push_back(1.);
        relativeToleranceMidp.push_back(0.07);
        relativeTolerancePeriod.push_back(0.07);
        // SECOND MC
        // Binomial...
        // Saddle point...
        // Recursive ...
    }
    else {
        return;
    }

    for (Size j = 0; j < LENGTH(hwAttachment); j ++) {
        ext::shared_ptr<Basket> basketPtr (
            new Basket(asofDate, names, nominals, pool,
                hwAttachment[j], hwDetachment[j]));
        ostringstream trancheId;
        trancheId << "[" << hwAttachment[j] << " , " << hwDetachment[j]
            << "]";
        SyntheticCDO cdoe(basketPtr, Protection::Seller,
                          schedule, 0.0, premium, daycount, Following);

        for(Size im=0; im<basketModels.size(); im++) {

            basketPtr->setLossModel(basketModels[im]);

            cdoe.setPricingEngine(midPCDOEngine);
            check(i, j, modelNames[im]
                +std::string(" with midp integration on ")+trancheId.str(),
                cdoe.fairPremium() * 1e4, hwData7[i].trancheSpread[j],
                absoluteTolerance[im], relativeToleranceMidp[im]);

            cdoe.setPricingEngine(integralCDOEngine);
            check(i, j, modelNames[im]
                +std::string(" with step integration on ")+trancheId.str(),
                cdoe.fairPremium() * 1e4, hwData7[i].trancheSpread[j],
                absoluteTolerance[im], relativeTolerancePeriod[im]);
        }
    }
    #endif
}


test_suite* CdoTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("CDO tests");

    #ifndef QL_PATCH_SOLARIS
    if (speed == Slow) {
        // unrolled to get different test names
        suite->add(QUANTLIB_TEST_CASE([=](){ CdoTest::testHW(0); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ CdoTest::testHW(1); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ CdoTest::testHW(2); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ CdoTest::testHW(3); }));
        suite->add(QUANTLIB_TEST_CASE([=](){ CdoTest::testHW(4); }));
    }
    #endif
    return suite;
}
]]></document_content>
  </document>
  <document index="45">
    <source>cdo.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cdo_hpp
#define quantlib_test_cdo_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CdoTest {
  public:
    static void testHW(unsigned dataSet);
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="46">
    <source>cdsoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "cdsoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/credit/cdsoption.hpp>
#include <ql/experimental/credit/blackcdsoptionengine.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/quotes/simplequote.hpp>

#include <iomanip>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void CdsOptionTest::testCached() {

    BOOST_TEST_MESSAGE("Testing CDS-option value against cached values...");

    SavedSettings backup;

    Date cachedToday = Date(10,December,2007);
    Settings::instance().evaluationDate() = cachedToday;

    Calendar calendar = TARGET();

    RelinkableHandle<YieldTermStructure> riskFree;
    riskFree.linkTo(ext::shared_ptr<YieldTermStructure>(
                              new FlatForward(cachedToday,0.02,Actual360())));

    Date expiry = calendar.advance(cachedToday,9,Months);
    Date startDate = calendar.advance(expiry,1,Months);
    Date maturity = calendar.advance(startDate,7,Years);

    DayCounter dayCounter = Actual360();
    BusinessDayConvention convention = ModifiedFollowing;
    Real notional = 1000000.0;

    Handle<Quote> hazardRate(ext::shared_ptr<Quote>(new SimpleQuote(0.001)));

    Schedule schedule(startDate,maturity, Period(Quarterly),
                      calendar, convention, convention,
                      DateGeneration::Forward, false);

    Real recoveryRate = 0.4;
    Handle<DefaultProbabilityTermStructure> defaultProbability(
        ext::shared_ptr<DefaultProbabilityTermStructure>(
                    new FlatHazardRate(0, calendar, hazardRate, dayCounter)));

    ext::shared_ptr<PricingEngine> swapEngine(
           new MidPointCdsEngine(defaultProbability, recoveryRate, riskFree));

    CreditDefaultSwap swap(Protection::Seller, notional, 0.001, schedule,
                           convention, dayCounter);
    swap.setPricingEngine(swapEngine);
    Rate strike = swap.fairSpread();

    Handle<Quote> cdsVol(ext::shared_ptr<Quote>(new SimpleQuote(0.20)));

    ext::shared_ptr<CreditDefaultSwap> underlying(
         new CreditDefaultSwap(Protection::Seller, notional, strike, schedule,
                               convention, dayCounter));
    underlying->setPricingEngine(swapEngine);

    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(expiry));
    CdsOption option1(underlying, exercise);
    option1.setPricingEngine(ext::shared_ptr<PricingEngine>(
                    new BlackCdsOptionEngine(defaultProbability, recoveryRate,
                                             riskFree, cdsVol)));

    Real cachedValue = 270.976348;
    if (std::fabs(option1.NPV() - cachedValue) > 1.0e-5)
        BOOST_ERROR("failed to reproduce cached value:\n"
                    << std::fixed << std::setprecision(6)
                    << "    calculated: " << option1.NPV() << "\n"
                    << "    expected:   " << cachedValue);

    underlying = ext::make_shared<CreditDefaultSwap>(
         Protection::Buyer, notional, strike, schedule,
                               convention, dayCounter);
    underlying->setPricingEngine(swapEngine);

    CdsOption option2(underlying, exercise);
    option2.setPricingEngine(ext::shared_ptr<PricingEngine>(
                    new BlackCdsOptionEngine(defaultProbability, recoveryRate,
                                             riskFree, cdsVol)));

    cachedValue = 270.976348;
    if (std::fabs(option2.NPV() - cachedValue) > 1.0e-5)
        BOOST_ERROR("failed to reproduce cached value:\n"
                    << std::fixed << std::setprecision(6)
                    << "    calculated: " << option2.NPV() << "\n"
                    << "    expected:   " << cachedValue);
}


test_suite* CdsOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("range-accrual-swap tests");
    suite->add(QUANTLIB_TEST_CASE(&CdsOptionTest::testCached));
    return suite;
}
]]></document_content>
  </document>
  <document index="47">
    <source>cdsoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cds_option_hpp
#define quantlib_test_cds_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CdsOptionTest {
  public:
    static void testCached();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="48">
    <source>chooseroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "chooseroption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/experimental/exoticoptions/simplechooseroption.hpp>
#include <ql/experimental/exoticoptions/complexchooseroption.hpp>
#include <ql/experimental/exoticoptions/analyticsimplechooserengine.hpp>
#include <ql/experimental/exoticoptions/analyticcomplexchooserengine.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, choosingDate, \
                       exercise, s, q, r, today, v, \
                       expected, calculated, tolerance) \
    BOOST_ERROR( \
        exerciseTypeToString(exercise) \
        << " Chooser option with " \
        << "    spot value: " << s << "\n" \
        << "    dividend yield:   " << io::rate(q) << "\n" \
        << "    risk-free rate:   " << io::rate(r) << "\n" \
        << "    reference date:   " << today << "\n" \
        << "    maturity:         " << exercise->lastDate() << "\n" \
        << "    volatility:       " << io::volatility(v) << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << std::fabs(expected-calculated) \
        << "\n" \
        << "    tolerance:        " << tolerance);


void ChooserOptionTest::testAnalyticSimpleChooserEngine(){

    BOOST_TEST_MESSAGE("Testing analytic simple chooser option...");

    /* The data below are from
       "Complete Guide to Option Pricing Formulas", Espen Gaarder Haug
       pages 39-40
    */
    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();

    ext::shared_ptr<SimpleQuote> spot = ext::make_shared<SimpleQuote>(50.0);
    ext::shared_ptr<SimpleQuote> qRate = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate = ext::make_shared<SimpleQuote>(0.08);
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol = ext::make_shared<SimpleQuote>(0.25);
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
        ext::make_shared<BlackScholesMertonProcess>(
                                  Handle<Quote>(spot),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS));

    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<AnalyticSimpleChooserEngine>(stochProcess);

    Real strike = 50.0;

    Date exerciseDate = today + 180;
    ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(exerciseDate);

    Date choosingDate = today + 90;
    SimpleChooserOption option(choosingDate,strike,exercise);
    option.setPricingEngine(engine);

    Real calculated = option.NPV();
    Real expected = 6.1071;
    Real tolerance = 3e-5;
    if (std::fabs(calculated-expected) > tolerance) {
        REPORT_FAILURE("value", choosingDate,
                       exercise, spot->value(),
                       qRate->value(), rRate->value(), today,
                       vol->value(), expected, calculated, tolerance);
    }

}


void ChooserOptionTest::testAnalyticComplexChooserEngine(){
    BOOST_TEST_MESSAGE("Testing analytic complex chooser option...");

    /* The example below is from
       "Complete Guide to Option Pricing Formulas", Espen Gaarder Haug
    */
    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot = ext::make_shared<SimpleQuote>(50.0);
    ext::shared_ptr<SimpleQuote> qRate = ext::make_shared<SimpleQuote>(0.05);
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate = ext::make_shared<SimpleQuote>(0.10);
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol = ext::make_shared<SimpleQuote>(0.35);
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
        ext::make_shared<BlackScholesMertonProcess>(
                                  Handle<Quote>(spot),
                                  Handle<YieldTermStructure>(qTS),
                                  Handle<YieldTermStructure>(rTS),
                                  Handle<BlackVolTermStructure>(volTS));

    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<AnalyticComplexChooserEngine>(stochProcess);

    Real callStrike = 55.0;
    Real putStrike = 48.0;

    Date choosingDate = today + 90;
    Date callExerciseDate = choosingDate + 180;
    Date putExerciseDate = choosingDate + 210;
    ext::shared_ptr<Exercise> callExercise =
        ext::make_shared<EuropeanExercise>(callExerciseDate);
    ext::shared_ptr<Exercise> putExercise =
        ext::make_shared<EuropeanExercise>(putExerciseDate);

    ComplexChooserOption option(choosingDate,callStrike,putStrike,
                                callExercise,putExercise);
    option.setPricingEngine(engine);

    Real calculated = option.NPV();
    Real expected = 6.0508;
    Real error = std::fabs(calculated-expected);
    Real tolerance = 1e-4;
    if (error > tolerance) {
        BOOST_ERROR("Failed to reproduce complex chooser option value"
                    << "\n    expected:   " << expected
                    << "\n    calculated: " << calculated
                    << "\n    error:      " << error);
    }
}

test_suite* ChooserOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Chooser option tests");

    suite->add(QUANTLIB_TEST_CASE(
        &ChooserOptionTest::testAnalyticSimpleChooserEngine));
    suite->add(QUANTLIB_TEST_CASE(
        &ChooserOptionTest::testAnalyticComplexChooserEngine));

    return suite;
}
]]></document_content>
  </document>
  <document index="49">
    <source>chooseroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_chooser_option_hpp
#define quantlib_test_chooser_option_hpp

#include <boost/test/unit_test.hpp>

class ChooserOptionTest{
  public:
      static void testAnalyticSimpleChooserEngine();
      static void testAnalyticComplexChooserEngine();
      static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="50">
    <source>cliquetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "cliquetoption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/cliquetoption.hpp>
#include <ql/pricingengines/cliquet/analyticcliquetengine.hpp>
#include <ql/pricingengines/cliquet/analyticperformanceengine.hpp>
#include <ql/pricingengines/cliquet/mcperformanceengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/time/period.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, v, \
                       expected, calculated, error, tolerance) \
    BOOST_ERROR(payoff->optionType() << " option:\n" \
               << "    spot value:       " << s << "\n" \
               << "    moneyness:        " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);


void CliquetOptionTest::testValues() {

    BOOST_TEST_MESSAGE("Testing Cliquet option values...");

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(60.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.08));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.30));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    ext::shared_ptr<BlackScholesMertonProcess> process(
         new BlackScholesMertonProcess(Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));
    ext::shared_ptr<PricingEngine> engine(new AnalyticCliquetEngine(process));

    std::vector<Date> reset;
    reset.push_back(today + 90);
    Date maturity = today + 360;
    Option::Type type = Option::Call;
    Real moneyness = 1.1;

    ext::shared_ptr<PercentageStrikePayoff> payoff(
                                 new PercentageStrikePayoff(type, moneyness));
    ext::shared_ptr<EuropeanExercise> exercise(
                                              new EuropeanExercise(maturity));

    CliquetOption option(payoff, exercise, reset);
    option.setPricingEngine(engine);

    Real calculated = option.NPV();
    Real expected = 4.4064; // Haug, p.37
    Real error = std::fabs(calculated-expected);
    Real tolerance = 1e-4;
    if (error > tolerance) {
        REPORT_FAILURE("value", payoff, exercise, spot->value(),
                       qRate->value(), rRate->value(), today,
                       vol->value(), expected, calculated,
                       error, tolerance);
    }
}


namespace {

    template <class T>
    void testOptionGreeks() {

        SavedSettings backup;

        std::map<std::string,Real> calculated, expected, tolerance;
        tolerance["delta"]  = 1.0e-5;
        tolerance["gamma"]  = 1.0e-5;
        tolerance["theta"]  = 1.0e-5;
        tolerance["rho"]    = 1.0e-5;
        tolerance["divRho"] = 1.0e-5;
        tolerance["vega"]   = 1.0e-5;

        Option::Type types[] = { Option::Call, Option::Put };
        Real moneyness[] = { 0.9, 1.0, 1.1 };
        Real underlyings[] = { 100.0 };
        Rate qRates[] = { 0.04, 0.05, 0.06 };
        Rate rRates[] = { 0.01, 0.05, 0.15 };
        Integer lengths[] = { 1, 2 };
        Frequency frequencies[] = { Semiannual, Quarterly };
        Volatility vols[] = { 0.11, 0.50, 1.20 };

        DayCounter dc = Actual360();
        Date today = Date::todaysDate();
        Settings::instance().evaluationDate() = today;

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
        ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
        ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
        ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
        Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

        ext::shared_ptr<BlackScholesMertonProcess> process(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          qTS, rTS, volTS));

        for (auto& type : types) {
            for (double moneynes : moneyness) {
                for (int length : lengths) {
                    for (auto& frequencie : frequencies) {

                        ext::shared_ptr<EuropeanExercise> maturity(
                            new EuropeanExercise(today + length * Years));

                        ext::shared_ptr<PercentageStrikePayoff> payoff(
                            new PercentageStrikePayoff(type, moneynes));

                        std::vector<Date> reset;
                        for (Date d = today + Period(frequencie); d < maturity->lastDate();
                             d += Period(frequencie))
                            reset.push_back(d);

                        ext::shared_ptr<PricingEngine> engine(new T(process));

                        CliquetOption option(payoff, maturity, reset);
                        option.setPricingEngine(engine);

                        for (double u : underlyings) {
                            for (double m : qRates) {
                                for (double n : rRates) {
                                    for (double v : vols) {

                                        Rate q = m, r = n;
                                        spot->setValue(u);
                                        qRate->setValue(q);
                                        rRate->setValue(r);
                                        vol->setValue(v);

                                        Real value = option.NPV();
                                        calculated["delta"] = option.delta();
                                        calculated["gamma"] = option.gamma();
                                        calculated["theta"] = option.theta();
                                        calculated["rho"] = option.rho();
                                        calculated["divRho"] = option.dividendRho();
                                        calculated["vega"] = option.vega();

                                        if (value > spot->value() * 1.0e-5) {
                                            // perturb spot and get delta and gamma
                                            Real du = u * 1.0e-4;
                                            spot->setValue(u + du);
                                            Real value_p = option.NPV(), delta_p = option.delta();
                                            spot->setValue(u - du);
                                            Real value_m = option.NPV(), delta_m = option.delta();
                                            spot->setValue(u);
                                            expected["delta"] = (value_p - value_m) / (2 * du);
                                            expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                            // perturb rates and get rho and dividend rho
                                            Spread dr = r * 1.0e-4;
                                            rRate->setValue(r + dr);
                                            value_p = option.NPV();
                                            rRate->setValue(r - dr);
                                            value_m = option.NPV();
                                            rRate->setValue(r);
                                            expected["rho"] = (value_p - value_m) / (2 * dr);

                                            Spread dq = q * 1.0e-4;
                                            qRate->setValue(q + dq);
                                            value_p = option.NPV();
                                            qRate->setValue(q - dq);
                                            value_m = option.NPV();
                                            qRate->setValue(q);
                                            expected["divRho"] = (value_p - value_m) / (2 * dq);

                                            // perturb volatility and get vega
                                            Volatility dv = v * 1.0e-4;
                                            vol->setValue(v + dv);
                                            value_p = option.NPV();
                                            vol->setValue(v - dv);
                                            value_m = option.NPV();
                                            vol->setValue(v);
                                            expected["vega"] = (value_p - value_m) / (2 * dv);

                                            // perturb date and get theta
                                            Time dT = dc.yearFraction(today - 1, today + 1);
                                            Settings::instance().evaluationDate() = today - 1;
                                            value_m = option.NPV();
                                            Settings::instance().evaluationDate() = today + 1;
                                            value_p = option.NPV();
                                            Settings::instance().evaluationDate() = today;
                                            expected["theta"] = (value_p - value_m) / dT;

                                            // compare
                                            std::map<std::string, Real>::iterator it;
                                            for (it = calculated.begin(); it != calculated.end();
                                                 ++it) {
                                                std::string greek = it->first;
                                                Real expct = expected[greek],
                                                     calcl = calculated[greek],
                                                     tol = tolerance[greek];
                                                Real error = relativeError(expct, calcl, u);
                                                if (error > tol) {
                                                    REPORT_FAILURE(greek, payoff, maturity, u, q, r,
                                                                   today, v, expct, calcl, error,
                                                                   tol);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}


void CliquetOptionTest::testGreeks() {
    BOOST_TEST_MESSAGE("Testing Cliquet option greeks...");
    testOptionGreeks<AnalyticCliquetEngine>();
}


void CliquetOptionTest::testPerformanceGreeks() {
    BOOST_TEST_MESSAGE("Testing performance option greeks...");
    testOptionGreeks<AnalyticPerformanceEngine>();
}


void CliquetOptionTest::testMcPerformance() {
    BOOST_TEST_MESSAGE(
        "Testing Monte Carlo performance engine against analytic results...");

    SavedSettings backup;

    Option::Type types[] = { Option::Call, Option::Put };
    Real moneyness[] = { 0.9, 1.1 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.04, 0.06 };
    Rate rRates[] = { 0.01, 0.10 };
    Integer lengths[] = { 2, 4 };
    Frequency frequencies[] = { Semiannual, Quarterly };
    Volatility vols[] = { 0.10, 0.90 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    ext::shared_ptr<BlackScholesMertonProcess> process(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          qTS, rTS, volTS));

    for (auto& type : types) {
        for (double moneynes : moneyness) {
            for (int length : lengths) {
                for (auto& frequencie : frequencies) {

                    Period tenor = Period(frequencie);
                    ext::shared_ptr<EuropeanExercise> maturity(
                        new EuropeanExercise(today + length * tenor));

                    ext::shared_ptr<PercentageStrikePayoff> payoff(
                        new PercentageStrikePayoff(type, moneynes));

                    std::vector<Date> reset;
                    for (Date d = today + tenor; d < maturity->lastDate(); d += tenor)
                        reset.push_back(d);

                    CliquetOption option(payoff, maturity, reset);

                    ext::shared_ptr<PricingEngine> refEngine(
                        new AnalyticPerformanceEngine(process));

                    ext::shared_ptr<PricingEngine> mcEngine =
                        MakeMCPerformanceEngine<PseudoRandom>(process)
                            .withBrownianBridge()
                            .withAbsoluteTolerance(5.0e-3)
                            .withSeed(42);

                    for (double u : underlyings) {
                        for (double m : qRates) {
                            for (double n : rRates) {
                                for (double v : vols) {

                                    Rate q = m, r = n;
                                    spot->setValue(u);
                                    qRate->setValue(q);
                                    rRate->setValue(r);
                                    vol->setValue(v);

                                    option.setPricingEngine(refEngine);
                                    Real refValue = option.NPV();

                                    option.setPricingEngine(mcEngine);
                                    Real value = option.NPV();

                                    Real error = std::fabs(refValue - value);
                                    Real tolerance = 1.5e-2;
                                    if (error > tolerance) {
                                        REPORT_FAILURE("value", payoff, maturity, u, q, r, today, v,
                                                       refValue, value, error, tolerance);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


test_suite* CliquetOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Cliquet option tests");
    suite->add(QUANTLIB_TEST_CASE(&CliquetOptionTest::testValues));
    suite->add(QUANTLIB_TEST_CASE(&CliquetOptionTest::testGreeks));
    suite->add(QUANTLIB_TEST_CASE(&CliquetOptionTest::testPerformanceGreeks));
    suite->add(QUANTLIB_TEST_CASE(&CliquetOptionTest::testMcPerformance));
    return suite;
}

]]></document_content>
  </document>
  <document index="51">
    <source>cliquetoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cliquet_option_hpp
#define quantlib_test_cliquet_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CliquetOptionTest {
  public:
    static void testValues();
    static void testGreeks();
    static void testPerformanceGreeks();
    static void testMcPerformance();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="52">
    <source>cms.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006 Giorgio Facchinetti
 Copyright (C) 2006 Mario Pucci
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "cms.hpp"
#include "utilities.hpp"
#include <ql/instruments/swap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/conundrumpricer.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/lineartsrpricer.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolmatrix.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube2.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube1.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/instruments/makecms.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace cms_test {

    struct CommonVars {
        // global data
        RelinkableHandle<YieldTermStructure> termStructure;

        ext::shared_ptr<IborIndex> iborIndex;

        Handle<SwaptionVolatilityStructure> atmVol;
        Handle<SwaptionVolatilityStructure> SabrVolCube1;
        Handle<SwaptionVolatilityStructure> SabrVolCube2;

        std::vector<GFunctionFactory::YieldCurveModel> yieldCurveModels;
        std::vector<ext::shared_ptr<CmsCouponPricer> > numericalPricers;
        std::vector<ext::shared_ptr<CmsCouponPricer> > analyticPricers;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {

            Calendar calendar = TARGET();

            Date referenceDate = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = referenceDate;

            termStructure.linkTo(flatRate(referenceDate, 0.05,
                                          Actual365Fixed()));

            // ATM Volatility structure
            std::vector<Period> atmOptionTenors = {1 * Months, 6 * Months, 1 * Years,
                                                   5 * Years,  10 * Years, 30 * Years};

            std::vector<Period> atmSwapTenors = {1 * Years, 5 * Years, 10 * Years, 30 * Years};

            Matrix m(atmOptionTenors.size(), atmSwapTenors.size());
            m[0][0]=0.1300; m[0][1]=0.1560; m[0][2]=0.1390; m[0][3]=0.1220;
            m[1][0]=0.1440; m[1][1]=0.1580; m[1][2]=0.1460; m[1][3]=0.1260;
            m[2][0]=0.1600; m[2][1]=0.1590; m[2][2]=0.1470; m[2][3]=0.1290;
            m[3][0]=0.1640; m[3][1]=0.1470; m[3][2]=0.1370; m[3][3]=0.1220;
            m[4][0]=0.1400; m[4][1]=0.1300; m[4][2]=0.1250; m[4][3]=0.1100;
            m[5][0]=0.1130; m[5][1]=0.1090; m[5][2]=0.1070; m[5][3]=0.0930;

            atmVol = Handle<SwaptionVolatilityStructure>(
                ext::shared_ptr<SwaptionVolatilityStructure>(new
                    SwaptionVolatilityMatrix(calendar,
                                             Following,
                                             atmOptionTenors,
                                             atmSwapTenors,
                                             m,
                                             Actual365Fixed())));

            // Vol cubes
            std::vector<Period> optionTenors = {{1, Years}, {10, Years}, {30, Years}};
            std::vector<Period> swapTenors = {{2, Years}, {10, Years}, {30, Years}};
            std::vector<Spread> strikeSpreads = {-0.020, -0.005, 0.000, 0.005, 0.020};

            Size nRows = optionTenors.size()*swapTenors.size();
            Size nCols = strikeSpreads.size();
            Matrix volSpreadsMatrix(nRows, nCols);
            volSpreadsMatrix[0][0] =  0.0599;
            volSpreadsMatrix[0][1] =  0.0049;
            volSpreadsMatrix[0][2] =  0.0000;
            volSpreadsMatrix[0][3] = -0.0001;
            volSpreadsMatrix[0][4] =  0.0127;

            volSpreadsMatrix[1][0] =  0.0729;
            volSpreadsMatrix[1][1] =  0.0086;
            volSpreadsMatrix[1][2] =  0.0000;
            volSpreadsMatrix[1][3] = -0.0024;
            volSpreadsMatrix[1][4] =  0.0098;

            volSpreadsMatrix[2][0] =  0.0738;
            volSpreadsMatrix[2][1] =  0.0102;
            volSpreadsMatrix[2][2] =  0.0000;
            volSpreadsMatrix[2][3] = -0.0039;
            volSpreadsMatrix[2][4] =  0.0065;

            volSpreadsMatrix[3][0] =  0.0465;
            volSpreadsMatrix[3][1] =  0.0063;
            volSpreadsMatrix[3][2] =  0.0000;
            volSpreadsMatrix[3][3] = -0.0032;
            volSpreadsMatrix[3][4] = -0.0010;

            volSpreadsMatrix[4][0] =  0.0558;
            volSpreadsMatrix[4][1] =  0.0084;
            volSpreadsMatrix[4][2] =  0.0000;
            volSpreadsMatrix[4][3] = -0.0050;
            volSpreadsMatrix[4][4] = -0.0057;

            volSpreadsMatrix[5][0] =  0.0576;
            volSpreadsMatrix[5][1] =  0.0083;
            volSpreadsMatrix[5][2] =  0.0000;
            volSpreadsMatrix[5][3] = -0.0043;
            volSpreadsMatrix[5][4] = -0.0014;

            volSpreadsMatrix[6][0] =  0.0437;
            volSpreadsMatrix[6][1] =  0.0059;
            volSpreadsMatrix[6][2] =  0.0000;
            volSpreadsMatrix[6][3] = -0.0030;
            volSpreadsMatrix[6][4] = -0.0006;

            volSpreadsMatrix[7][0] =  0.0533;
            volSpreadsMatrix[7][1] =  0.0078;
            volSpreadsMatrix[7][2] =  0.0000;
            volSpreadsMatrix[7][3] = -0.0045;
            volSpreadsMatrix[7][4] = -0.0046;

            volSpreadsMatrix[8][0] =  0.0545;
            volSpreadsMatrix[8][1] =  0.0079;
            volSpreadsMatrix[8][2] =  0.0000;
            volSpreadsMatrix[8][3] = -0.0042;
            volSpreadsMatrix[8][4] = -0.0020;

            std::vector<std::vector<Handle<Quote> > > volSpreads(nRows);
            for (Size i=0; i<nRows; ++i){
                volSpreads[i] = std::vector<Handle<Quote> >(nCols);
                for (Size j=0; j<nCols; ++j) {
                    volSpreads[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(
                                    new SimpleQuote(volSpreadsMatrix[i][j])));
                }
            }

            iborIndex = ext::shared_ptr<IborIndex>(new Euribor6M(termStructure));
            ext::shared_ptr<SwapIndex> swapIndexBase(new
                EuriborSwapIsdaFixA(10*Years, termStructure));
            ext::shared_ptr<SwapIndex> shortSwapIndexBase(new
                EuriborSwapIsdaFixA(2*Years, termStructure));

            bool vegaWeightedSmileFit = false;

            SabrVolCube2 = Handle<SwaptionVolatilityStructure>(
                ext::make_shared<SwaptionVolCube2>(atmVol,
                                     optionTenors,
                                     swapTenors,
                                     strikeSpreads,
                                     volSpreads,
                                     swapIndexBase,
                                     shortSwapIndexBase,
                                     vegaWeightedSmileFit));
            SabrVolCube2->enableExtrapolation();

            std::vector<std::vector<Handle<Quote> > > guess(nRows);
            for (Size i=0; i<nRows; ++i) {
                guess[i] = std::vector<Handle<Quote> >(4);
                guess[i][0] =
                    Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.2)));
                guess[i][1] =
                    Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.5)));
                guess[i][2] =
                    Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.4)));
                guess[i][3] =
                    Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.0)));
            }
            std::vector<bool> isParameterFixed(4, false);
            isParameterFixed[1] = true;

            // FIXME
            bool isAtmCalibrated = false;

            SabrVolCube1 = Handle<SwaptionVolatilityStructure>(
                ext::shared_ptr<SwaptionVolCube1>(new
                    SwaptionVolCube1(atmVol,
                                     optionTenors,
                                     swapTenors,
                                     strikeSpreads,
                                     volSpreads,
                                     swapIndexBase,
                                     shortSwapIndexBase,
                                     vegaWeightedSmileFit,
                                     guess,
                                     isParameterFixed,
                                     isAtmCalibrated)));
            SabrVolCube1->enableExtrapolation();

            yieldCurveModels = {GFunctionFactory::Standard,
                                GFunctionFactory::ExactYield,
                                GFunctionFactory::ParallelShifts,
                                GFunctionFactory::NonParallelShifts,
                                GFunctionFactory::NonParallelShifts};

            Handle<Quote> zeroMeanRev(ext::make_shared<SimpleQuote>(0.0));

            numericalPricers.clear();
            analyticPricers.clear();
            for (Size j = 0; j < yieldCurveModels.size(); ++j) {
                if (j < yieldCurveModels.size() - 1)
                    numericalPricers.push_back(
                        ext::shared_ptr<CmsCouponPricer>(new NumericHaganPricer(
                            atmVol, yieldCurveModels[j], zeroMeanRev)));
                else
                    numericalPricers.push_back(ext::shared_ptr<CmsCouponPricer>(
                        new LinearTsrPricer(atmVol, zeroMeanRev)));

                analyticPricers.push_back(ext::shared_ptr<CmsCouponPricer>(new
                    AnalyticHaganPricer(atmVol, yieldCurveModels[j],
                                        zeroMeanRev)));
            }
        }
    };

}


void CmsTest::testFairRate()  {

    BOOST_TEST_MESSAGE("Testing Hagan-pricer flat-vol equivalence for coupons...");

    using namespace cms_test;

    CommonVars vars;

    ext::shared_ptr<SwapIndex> swapIndex(new SwapIndex("EuriborSwapIsdaFixA",
                                                       10*Years,
                                                       vars.iborIndex->fixingDays(),
                                                       vars.iborIndex->currency(),
                                                       vars.iborIndex->fixingCalendar(),
                                                       1*Years,
                                                       Unadjusted,
                                                       vars.iborIndex->dayCounter(),//??
                                                       vars.iborIndex));
    // FIXME
    //ext::shared_ptr<SwapIndex> swapIndex(new
    //    EuriborSwapIsdaFixA(10*Years, vars.iborIndex->termStructure()));
    Date startDate = vars.termStructure->referenceDate() + 20*Years;
    Date paymentDate = startDate + 1*Years;
    Date endDate = paymentDate;
    Real nominal = 1.0;
    Rate infiniteCap = Null<Real>();
    Rate infiniteFloor = Null<Real>();
    Real gearing = 1.0;
    Spread spread = 0.0;
    CappedFlooredCmsCoupon coupon(paymentDate, nominal,
                                  startDate, endDate,
                                  swapIndex->fixingDays(), swapIndex,
                                  gearing, spread,
                                  infiniteCap, infiniteFloor,
                                  startDate, endDate,
                                  vars.iborIndex->dayCounter());
    for (Size j=0; j<vars.yieldCurveModels.size(); ++j) {
        vars.numericalPricers[j]->setSwaptionVolatility(vars.atmVol);
        coupon.setPricer(vars.numericalPricers[j]);
        Rate rate0 = coupon.rate();

        vars.analyticPricers[j]->setSwaptionVolatility(vars.atmVol);
        coupon.setPricer(vars.analyticPricers[j]);
        Rate rate1 = coupon.rate();

        Spread difference =  std::fabs(rate1-rate0);
        Spread tol = 2.0e-4;
        bool linearTsr = j==vars.yieldCurveModels.size()-1;

        if (difference > tol)
            BOOST_FAIL("\nCoupon payment date: " << paymentDate <<
                       "\nCoupon start date:   " << startDate <<
                       "\nCoupon floor:        " << io::rate(infiniteFloor) <<
                       "\nCoupon gearing:      " << io::rate(gearing) <<
                       "\nCoupon swap index:   " << swapIndex->name() <<
                       "\nCoupon spread:       " << io::rate(spread) <<
                       "\nCoupon cap:          " << io::rate(infiniteCap) <<
                       "\nCoupon DayCounter:   " << vars.iborIndex->dayCounter()<<
                       "\nYieldCurve Model:    " << vars.yieldCurveModels[j] <<
                       "\nNumerical Pricer:    " << io::rate(rate0) <<
                                   (linearTsr ? " (Linear TSR Model)" : "") <<
                       "\nAnalytic Pricer:     " << io::rate(rate1) <<
                       "\ndifference:          " << io::rate(difference) <<
                       "\ntolerance:           " << io::rate(tol));
    }
}

void CmsTest::testCmsSwap() {

    BOOST_TEST_MESSAGE("Testing Hagan-pricer flat-vol equivalence for swaps...");

    using namespace cms_test;

    CommonVars vars;

    ext::shared_ptr<SwapIndex> swapIndex(new SwapIndex("EuriborSwapIsdaFixA",
                                                       10*Years,
                                                       vars.iborIndex->fixingDays(),
                                                       vars.iborIndex->currency(),
                                                       vars.iborIndex->fixingCalendar(),
                                                       1*Years,
                                                       Unadjusted,
                                                       vars.iborIndex->dayCounter(),//??
                                                       vars.iborIndex));
    // FIXME
    //ext::shared_ptr<SwapIndex> swapIndex(new
    //    EuriborSwapIsdaFixA(10*Years, vars.iborIndex->termStructure()));
    Spread spread = 0.0;
    std::vector<Size> swapLengths = {1, 5, 6, 10};
    Size n = swapLengths.size();
    std::vector<ext::shared_ptr<Swap> > cms(n);
    for (Size i=0; i<n; ++i)
        // no cap, floor
        // no gearing, spread
        cms[i] = MakeCms(Period(swapLengths[i], Years),
                         swapIndex,
                         vars.iborIndex, spread,
                         10*Days);

    for (Size j=0; j<vars.yieldCurveModels.size(); ++j) {
        vars.numericalPricers[j]->setSwaptionVolatility(vars.atmVol);
        vars.analyticPricers[j]->setSwaptionVolatility(vars.atmVol);
        for (Size sl=0; sl<n; ++sl) {
            setCouponPricer(cms[sl]->leg(0), vars.numericalPricers[j]);
            Real priceNum = cms[sl]->NPV();
            setCouponPricer(cms[sl]->leg(0), vars.analyticPricers[j]);
            Real priceAn = cms[sl]->NPV();

            Real difference =  std::fabs(priceNum-priceAn);
            Real tol = 2.0e-4;
            bool linearTsr = j==vars.yieldCurveModels.size()-1;
            if (difference > tol)
                BOOST_FAIL("\nLength in Years:  " << swapLengths[sl] <<
                           //"\nfloor:            " << io::rate(infiniteFloor) <<
                           //"\ngearing:          " << io::rate(gearing) <<
                           "\nswap index:       " << swapIndex->name() <<
                           "\nibor index:       " << vars.iborIndex->name() <<
                           "\nspread:           " << io::rate(spread) <<
                           //"\ncap:              " << io::rate(infiniteCap) <<
                           "\nYieldCurve Model: " << vars.yieldCurveModels[j] <<
                           "\nNumerical Pricer: " << io::rate(priceNum) <<
                                   (linearTsr ? " (Linear TSR Model)" : "") <<
                           "\nAnalytic Pricer:  " << io::rate(priceAn) <<
                           "\ndifference:       " << io::rate(difference) <<
                           "\ntolerance:        " << io::rate(tol));
        }
    }

}

void CmsTest::testParity() {

    BOOST_TEST_MESSAGE("Testing put-call parity for capped-floored CMS coupons...");

    using namespace cms_test;

    CommonVars vars;

    std::vector<Handle<SwaptionVolatilityStructure> > swaptionVols = {
                           vars.atmVol, vars.SabrVolCube1, vars.SabrVolCube2};

    ext::shared_ptr<SwapIndex> swapIndex(new
        EuriborSwapIsdaFixA(10*Years,
                            vars.iborIndex->forwardingTermStructure()));
    Date startDate = vars.termStructure->referenceDate() + 20*Years;
    Date paymentDate = startDate + 1*Years;
    Date endDate = paymentDate;
    Real nominal = 1.0;
    Rate infiniteCap = Null<Real>();
    Rate infiniteFloor = Null<Real>();
    Real gearing = 1.0;
    Spread spread = 0.0;
    DiscountFactor discount = vars.termStructure->discount(paymentDate);
    CappedFlooredCmsCoupon swaplet(paymentDate, nominal,
                                   startDate, endDate,
                                   swapIndex->fixingDays(),
                                   swapIndex,
                                   gearing, spread,
                                   infiniteCap, infiniteFloor,
                                   startDate, endDate,
                                   vars.iborIndex->dayCounter());
    for (Rate strike = .02; strike<.12; strike+=0.05) {
        CappedFlooredCmsCoupon   caplet(paymentDate, nominal,
                                        startDate, endDate,
                                        swapIndex->fixingDays(),
                                        swapIndex,
                                        gearing, spread,
                                        strike, infiniteFloor,
                                        startDate, endDate,
                                        vars.iborIndex->dayCounter());
        CappedFlooredCmsCoupon floorlet(paymentDate, nominal,
                                        startDate, endDate,
                                        swapIndex->fixingDays(),
                                        swapIndex,
                                        gearing, spread,
                                        infiniteCap, strike,
                                        startDate, endDate,
                                        vars.iborIndex->dayCounter());

        for (auto& swaptionVol : swaptionVols) {
            for (Size j=0; j<vars.yieldCurveModels.size(); ++j) {
                vars.numericalPricers[j]->setSwaptionVolatility(swaptionVol);
                vars.analyticPricers[j]->setSwaptionVolatility(swaptionVol);
                std::vector<ext::shared_ptr<CmsCouponPricer> > pricers(2);
                pricers[0] = vars.numericalPricers[j];
                pricers[1] = vars.analyticPricers[j];
                for (Size k=0; k<pricers.size(); ++k) {
                    swaplet.setPricer(pricers[k]);
                    caplet.setPricer(pricers[k]);
                    floorlet.setPricer(pricers[k]);
                    Real swapletPrice = swaplet.price(vars.termStructure) +
                                  nominal * swaplet.accrualPeriod() * strike * discount;
                    Real capletPrice = caplet.price(vars.termStructure);
                    Real floorletPrice = floorlet.price(vars.termStructure);
                    Real difference = std::fabs(capletPrice + floorletPrice -
                                                swapletPrice);
                    Real tol = 2.0e-5;
                    bool linearTsr = k==0 && j==vars.yieldCurveModels.size()-1;
                    if(linearTsr)
                        tol = 1.0e-7;
                    if (difference > tol)
                        BOOST_FAIL("\nCoupon payment date: " << paymentDate <<
                                   "\nCoupon start date:   " << startDate <<
                                   "\nCoupon gearing:      " << io::rate(gearing) <<
                                   "\nCoupon swap index:   " << swapIndex->name() <<
                                   "\nCoupon spread:       " << io::rate(spread) <<
                                   "\nstrike:              " << io::rate(strike) <<
                                   "\nCoupon DayCounter:   " << vars.iborIndex->dayCounter() <<
                                   "\nYieldCurve Model:    " << vars.yieldCurveModels[j] <<
                                   (k==0 ? "\nNumerical Pricer" : "\nAnalytic Pricer") <<
                                   (linearTsr ? " (Linear TSR Model)" : "") <<
                                   "\nSwaplet price:       " << io::rate(swapletPrice) <<
                                   "\nCaplet price:        " << io::rate(capletPrice) <<
                                   "\nFloorlet price:      " << io::rate(floorletPrice) <<
                                   "\ndifference:          " << difference <<
                                   "\ntolerance:           " << io::rate(tol));
                }
            }
        }
    }
}

test_suite* CmsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Cms tests");
    suite->add(QUANTLIB_TEST_CASE(&CmsTest::testFairRate));
    suite->add(QUANTLIB_TEST_CASE(&CmsTest::testCmsSwap));
    suite->add(QUANTLIB_TEST_CASE(&CmsTest::testParity));
    return suite;
}
]]></document_content>
  </document>
  <document index="53">
    <source>cms.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mario Pucci

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cms_hpp
#define quantlib_test_cms_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CmsTest {
  public:
    static void testFairRate();
    static void testParity();
    static void testCmsSwap();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="54">
    <source>cmsspread.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "cmsspread.hpp"
#include "utilities.hpp"

#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/lineartsrpricer.hpp>
#include <ql/experimental/coupons/cmsspreadcoupon.hpp>
#include <ql/experimental/coupons/lognormalcmsspreadpricer.hpp>
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/math/array.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/swaption/swaptionconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>

#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/mean.hpp>
#include <boost/accumulators/statistics/stats.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using namespace boost::accumulators;

namespace {
struct TestData {
    TestData() {
        refDate = Date(23, February, 2018);
        Settings::instance().evaluationDate() = refDate;

        yts2 = Handle<YieldTermStructure>(
            ext::make_shared<FlatForward>(refDate, 0.02, Actual365Fixed()));

        swLn = Handle<SwaptionVolatilityStructure>(
            ext::make_shared<ConstantSwaptionVolatility>(
                refDate, TARGET(), Following, 0.20, Actual365Fixed(),
                ShiftedLognormal, 0.0));
        swSln = Handle<SwaptionVolatilityStructure>(
            ext::make_shared<ConstantSwaptionVolatility>(
                refDate, TARGET(), Following, 0.10, Actual365Fixed(),
                ShiftedLognormal, 0.01));
        swN = Handle<SwaptionVolatilityStructure>(
            ext::make_shared<ConstantSwaptionVolatility>(
                refDate, TARGET(), Following, 0.0075, Actual365Fixed(), Normal,
                0.01));

        reversion = Handle<Quote>(ext::make_shared<SimpleQuote>(0.01));
        cmsPricerLn =
            ext::make_shared<LinearTsrPricer>(swLn, reversion, yts2);
        cmsPricerSln =
            ext::make_shared<LinearTsrPricer>(swSln, reversion, yts2);
        cmsPricerN = ext::make_shared<LinearTsrPricer>(swN, reversion, yts2);

        correlation = Handle<Quote>(ext::make_shared<SimpleQuote>(0.6));
        cmsspPricerLn = ext::make_shared<LognormalCmsSpreadPricer>(
            cmsPricerLn, correlation, yts2, 32);
        cmsspPricerSln = ext::make_shared<LognormalCmsSpreadPricer>(
            cmsPricerSln, correlation, yts2, 32);
        cmsspPricerN = ext::make_shared<LognormalCmsSpreadPricer>(
            cmsPricerN, correlation, yts2, 32);
    }

    SavedSettings backup;
    Date refDate;
    Handle<YieldTermStructure> yts2;
    Handle<SwaptionVolatilityStructure> swLn, swSln, swN;
    Handle<Quote> reversion, correlation;
    ext::shared_ptr<CmsCouponPricer> cmsPricerLn, cmsPricerSln, cmsPricerN;
    ext::shared_ptr<CmsSpreadCouponPricer> cmsspPricerLn, cmsspPricerSln,
        cmsspPricerN;
};
} // namespace

void CmsSpreadTest::testFixings() {
    BOOST_TEST_MESSAGE("Testing fixings of cms spread indices...");

    TestData d;

    ext::shared_ptr<SwapIndex> cms10y =
        ext::make_shared<EuriborSwapIsdaFixA>(10 * Years, d.yts2, d.yts2);
    ext::shared_ptr<SwapIndex> cms2y =
        ext::make_shared<EuriborSwapIsdaFixA>(2 * Years, d.yts2, d.yts2);
    ext::shared_ptr<SwapSpreadIndex> cms10y2y =
        ext::make_shared<SwapSpreadIndex>("cms10y2y", cms10y, cms2y);

    Settings::instance().enforcesTodaysHistoricFixings() = false;

    BOOST_CHECK_THROW(cms10y2y->fixing(d.refDate - 1), QuantLib::Error);
    BOOST_REQUIRE_NO_THROW(cms10y2y->fixing(d.refDate));
    BOOST_CHECK_EQUAL(cms10y2y->fixing(d.refDate),
                      cms10y->fixing(d.refDate) - cms2y->fixing(d.refDate));
    cms10y->addFixing(d.refDate, 0.05);
    BOOST_CHECK_EQUAL(cms10y2y->fixing(d.refDate),
                      cms10y->fixing(d.refDate) - cms2y->fixing(d.refDate));
    cms2y->addFixing(d.refDate, 0.04);
    BOOST_CHECK_EQUAL(cms10y2y->fixing(d.refDate),
                      cms10y->fixing(d.refDate) - cms2y->fixing(d.refDate));
    Date futureFixingDate = TARGET().adjust(d.refDate + 1 * Years);
    BOOST_CHECK_EQUAL(cms10y2y->fixing(futureFixingDate),
                      cms10y->fixing(futureFixingDate) -
                          cms2y->fixing(futureFixingDate));
    IndexManager::instance().clearHistories();

    Settings::instance().enforcesTodaysHistoricFixings() = true;
    BOOST_CHECK_THROW(cms10y2y->fixing(d.refDate), QuantLib::Error);
    cms10y->addFixing(d.refDate, 0.05);
    BOOST_CHECK_THROW(cms10y2y->fixing(d.refDate), QuantLib::Error);
    cms2y->addFixing(d.refDate, 0.04);
    BOOST_CHECK_EQUAL(cms10y2y->fixing(d.refDate),
                      cms10y->fixing(d.refDate) - cms2y->fixing(d.refDate));
    IndexManager::instance().clearHistories();
}

namespace {
Real mcReferenceValue(const ext::shared_ptr<CmsCoupon>& cpn1,
                      const ext::shared_ptr<CmsCoupon>& cpn2, const Real cap,
                      const Real floor,
                      const Handle<SwaptionVolatilityStructure>& vol,
                      const Real correlation) {
    Size samples = 1000000;
    accumulator_set<double, stats<tag::mean> > acc;
    Matrix Cov(2, 2);
    Cov(0, 0) = vol->blackVariance(cpn1->fixingDate(), cpn1->index()->tenor(),
                                   cpn1->indexFixing());
    Cov(1, 1) = vol->blackVariance(cpn2->fixingDate(), cpn2->index()->tenor(),
                                   cpn2->indexFixing());
    Cov(0, 1) = Cov(1, 0) = std::sqrt(Cov(0, 0) * Cov(1, 1)) * correlation;
    Matrix C = pseudoSqrt(Cov);

    Array atmRate(2), adjRate(2), avg(2), volShift(2);
    atmRate[0] = cpn1->indexFixing();
    atmRate[1] = cpn2->indexFixing();
    adjRate[0] = cpn1->adjustedFixing();
    adjRate[1] = cpn2->adjustedFixing();
    if (vol->volatilityType() == ShiftedLognormal) {
        volShift[0] = vol->shift(cpn1->fixingDate(), cpn1->index()->tenor());
        volShift[1] = vol->shift(cpn2->fixingDate(), cpn2->index()->tenor());
        avg[0] =
            std::log((adjRate[0] + volShift[0]) / (atmRate[0] + volShift[0])) -
            0.5 * Cov(0, 0);
        avg[1] =
            std::log((adjRate[1] + volShift[1]) / (atmRate[1] + volShift[1])) -
            0.5 * Cov(1, 1);
    } else {
        avg[0] = adjRate[0];
        avg[1] = adjRate[1];
    }

    InverseCumulativeNormal icn;
    SobolRsg sb_(2, 42);
    Array w(2), z(2);
    for (Size i = 0; i < samples; ++i) {
        std::vector<Real> seq = sb_.nextSequence().value;
        std::transform(seq.begin(), seq.end(), w.begin(), icn);
        z = C * w + avg;
        for (Size i = 0; i < 2; ++i) {
            if (vol->volatilityType() == ShiftedLognormal) {
                z[i] =
                    (atmRate[i] + volShift[i]) * std::exp(z[i]) - volShift[i];
            }
        }
        acc(std::min(std::max(z[0] - z[1], floor), cap));
    }
    return mean(acc);
} // mcReferenceValue
} // namespace

void CmsSpreadTest::testCouponPricing() {
    BOOST_TEST_MESSAGE("Testing pricing of cms spread coupons...");

    TestData d;
    Real tol = 1E-6; // abs tolerance coupon rate

    ext::shared_ptr<SwapIndex> cms10y =
        ext::make_shared<EuriborSwapIsdaFixA>(10 * Years, d.yts2, d.yts2);
    ext::shared_ptr<SwapIndex> cms2y =
        ext::make_shared<EuriborSwapIsdaFixA>(2 * Years, d.yts2, d.yts2);
    ext::shared_ptr<SwapSpreadIndex> cms10y2y =
        ext::make_shared<SwapSpreadIndex>("cms10y2y", cms10y, cms2y);

    Date valueDate = cms10y2y->valueDate(d.refDate);
    Date payDate = valueDate + 1 * Years;
    ext::shared_ptr<CmsCoupon> cpn1a =
        ext::shared_ptr<CmsCoupon>(new CmsCoupon(
            payDate, 10000.0, valueDate, payDate, cms10y->fixingDays(), cms10y,
            1.0, 0.0, Date(), Date(), Actual360(), false));
    ext::shared_ptr<CmsCoupon> cpn1b = ext::shared_ptr<CmsCoupon>(
        new CmsCoupon(payDate, 10000.0, valueDate, payDate, cms2y->fixingDays(),
                      cms2y, 1.0, 0.0, Date(), Date(), Actual360(), false));
    ext::shared_ptr<CmsSpreadCoupon> cpn1 =
        ext::shared_ptr<CmsSpreadCoupon>(new CmsSpreadCoupon(
            payDate, 10000.0, valueDate, payDate, cms10y2y->fixingDays(),
            cms10y2y, 1.0, 0.0, Date(), Date(), Actual360(), false));
    BOOST_CHECK(cpn1->fixingDate() == d.refDate);
    cpn1a->setPricer(d.cmsPricerLn);
    cpn1b->setPricer(d.cmsPricerLn);
    cpn1->setPricer(d.cmsspPricerLn);

#ifndef __FAST_MATH__
    const Real eqTol = 100*QL_EPSILON;
#else
    const Real eqTol = 1e-13;
#endif
    BOOST_CHECK_CLOSE(cpn1->rate(), cpn1a->rate() - cpn1b->rate(), eqTol);
    cms10y->addFixing(d.refDate, 0.05);
    BOOST_CHECK_CLOSE(cpn1->rate(), cpn1a->rate() - cpn1b->rate(), eqTol);
    cms2y->addFixing(d.refDate, 0.03);
    BOOST_CHECK_CLOSE(cpn1->rate(), cpn1a->rate() - cpn1b->rate(), eqTol);
    IndexManager::instance().clearHistories();

    ext::shared_ptr<CmsCoupon> cpn2a = ext::shared_ptr<CmsCoupon>(
        new CmsCoupon(Date(23, February, 2029), 10000.0,
                      Date(23, February, 2028), Date(23, February, 2029), 2,
                      cms10y, 1.0, 0.0, Date(), Date(), Actual360(), false));
    ext::shared_ptr<CmsCoupon> cpn2b = ext::shared_ptr<CmsCoupon>(
        new CmsCoupon(Date(23, February, 2029), 10000.0,
                      Date(23, February, 2028), Date(23, February, 2029), 2,
                      cms2y, 1.0, 0.0, Date(), Date(), Actual360(), false));

    ext::shared_ptr<CappedFlooredCmsSpreadCoupon> plainCpn =
        ext::shared_ptr<CappedFlooredCmsSpreadCoupon>(
            new CappedFlooredCmsSpreadCoupon(
                Date(23, February, 2029), 10000.0, Date(23, February, 2028),
                Date(23, February, 2029), 2, cms10y2y, 1.0, 0.0, Null<Rate>(),
                Null<Rate>(), Date(), Date(), Actual360(), false));
    ext::shared_ptr<CappedFlooredCmsSpreadCoupon> cappedCpn =
        ext::shared_ptr<CappedFlooredCmsSpreadCoupon>(
            new CappedFlooredCmsSpreadCoupon(
                Date(23, February, 2029), 10000.0, Date(23, February, 2028),
                Date(23, February, 2029), 2, cms10y2y, 1.0, 0.0, 0.03,
                Null<Rate>(), Date(), Date(), Actual360(), false));
    ext::shared_ptr<CappedFlooredCmsSpreadCoupon> flooredCpn =
        ext::shared_ptr<CappedFlooredCmsSpreadCoupon>(
            new CappedFlooredCmsSpreadCoupon(
                Date(23, February, 2029), 10000.0, Date(23, February, 2028),
                Date(23, February, 2029), 2, cms10y2y, 1.0, 0.0, Null<Rate>(),
                0.01, Date(), Date(), Actual360(), false));
    ext::shared_ptr<CappedFlooredCmsSpreadCoupon> collaredCpn =
        ext::shared_ptr<CappedFlooredCmsSpreadCoupon>(
            new CappedFlooredCmsSpreadCoupon(
                Date(23, February, 2029), 10000.0, Date(23, February, 2028),
                Date(23, February, 2029), 2, cms10y2y, 1.0, 0.0, 0.03, 0.01,
                Date(), Date(), Actual360(), false));

    cpn2a->setPricer(d.cmsPricerLn);
    cpn2b->setPricer(d.cmsPricerLn);
    plainCpn->setPricer(d.cmsspPricerLn);
    cappedCpn->setPricer(d.cmsspPricerLn);
    flooredCpn->setPricer(d.cmsspPricerLn);
    collaredCpn->setPricer(d.cmsspPricerLn);

    BOOST_CHECK_SMALL(
        std::abs(plainCpn->rate() - mcReferenceValue(cpn2a, cpn2b, QL_MAX_REAL,
                                                     -QL_MAX_REAL, d.swLn,
                                                     d.correlation->value())),
        tol);
    BOOST_CHECK_SMALL(
        std::abs(cappedCpn->rate() - mcReferenceValue(cpn2a, cpn2b, 0.03,
                                                      -QL_MAX_REAL, d.swLn,
                                                      d.correlation->value())),
        tol);
    BOOST_CHECK_SMALL(
        std::abs(flooredCpn->rate() -
                 mcReferenceValue(cpn2a, cpn2b, QL_MAX_REAL, 0.01, d.swLn,
                                  d.correlation->value())),

        tol);
    BOOST_CHECK_SMALL(
        std::abs(collaredCpn->rate() -
                 mcReferenceValue(cpn2a, cpn2b, 0.03, 0.01, d.swLn,
                                  d.correlation->value())),
        tol);

    cpn2a->setPricer(d.cmsPricerSln);
    cpn2b->setPricer(d.cmsPricerSln);
    plainCpn->setPricer(d.cmsspPricerSln);
    cappedCpn->setPricer(d.cmsspPricerSln);
    flooredCpn->setPricer(d.cmsspPricerSln);
    collaredCpn->setPricer(d.cmsspPricerSln);

    BOOST_CHECK_SMALL(
        std::abs(plainCpn->rate() - mcReferenceValue(cpn2a, cpn2b, QL_MAX_REAL,
                                                     -QL_MAX_REAL, d.swSln,
                                                     d.correlation->value())),
        tol);
    BOOST_CHECK_SMALL(
        std::abs(cappedCpn->rate() - mcReferenceValue(cpn2a, cpn2b, 0.03,
                                                      -QL_MAX_REAL, d.swSln,
                                                      d.correlation->value())),
        tol);
    BOOST_CHECK_SMALL(
        std::abs(flooredCpn->rate() -
                 mcReferenceValue(cpn2a, cpn2b, QL_MAX_REAL, 0.01, d.swSln,
                                  d.correlation->value())),

        tol);
    BOOST_CHECK_SMALL(
        std::abs(collaredCpn->rate() -
                 mcReferenceValue(cpn2a, cpn2b, 0.03, 0.01, d.swSln,
                                  d.correlation->value())),
        tol);

    cpn2a->setPricer(d.cmsPricerN);
    cpn2b->setPricer(d.cmsPricerN);
    plainCpn->setPricer(d.cmsspPricerN);
    cappedCpn->setPricer(d.cmsspPricerN);
    flooredCpn->setPricer(d.cmsspPricerN);
    collaredCpn->setPricer(d.cmsspPricerN);

    BOOST_CHECK_SMALL(
        std::abs(plainCpn->rate() - mcReferenceValue(cpn2a, cpn2b, QL_MAX_REAL,
                                                     -QL_MAX_REAL, d.swN,
                                                     d.correlation->value())),
        tol);
    BOOST_CHECK_SMALL(
        std::abs(cappedCpn->rate() - mcReferenceValue(cpn2a, cpn2b, 0.03,
                                                      -QL_MAX_REAL, d.swN,
                                                      d.correlation->value())),
        tol);
    BOOST_CHECK_SMALL(std::abs(flooredCpn->rate() -
                               mcReferenceValue(cpn2a, cpn2b, QL_MAX_REAL, 0.01,
                                                d.swN, d.correlation->value())),

                      tol);
    BOOST_CHECK_SMALL(std::abs(collaredCpn->rate() -
                               mcReferenceValue(cpn2a, cpn2b, 0.03, 0.01, d.swN,
                                                d.correlation->value())),
                      tol);
}

test_suite* CmsSpreadTest::suite() {
    auto* suite = BOOST_TEST_SUITE("CmsSpreadTest");
    suite->add(QUANTLIB_TEST_CASE(&CmsSpreadTest::testFixings));
    suite->add(QUANTLIB_TEST_CASE(&CmsSpreadTest::testCouponPricing));
    return suite;
}
]]></document_content>
  </document>
  <document index="55">
    <source>cmsspread.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_cmsspread_hpp
#define quantlib_test_cmsspread_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CmsSpreadTest {
public:
    static void testFixings();
    static void testCouponPricing();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="56">
    <source>commodityunitofmeasure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Manas Bhatt

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "commodityunitofmeasure.hpp"
#include "utilities.hpp"
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>
#include <ql/experimental/commodities/petroleumunitsofmeasure.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void CommodityUnitOfMeasureTest::testDirect() {

    BOOST_TEST_MESSAGE("Testing direct commodity unit of measure conversions...");

    UnitOfMeasureConversionManager& UOMManager =
        UnitOfMeasureConversionManager::instance();

    //MB to BBL
    Quantity actual =
        UnitOfMeasureConversion(NullCommodityType(), MBUnitOfMeasure(),
                                BarrelUnitOfMeasure(), 1000)
        .convert(Quantity(NullCommodityType(), MBUnitOfMeasure(), 1000));
    Quantity calc =
        UOMManager.lookup(NullCommodityType(), BarrelUnitOfMeasure(),
                          MBUnitOfMeasure(), UnitOfMeasureConversion::Direct)
        .convert(Quantity(NullCommodityType(), MBUnitOfMeasure(), 1000));

     if (!close(calc,actual)) {
        BOOST_FAIL("Wrong result for MB to BBL Conversion: \n"
                   << "    actual:     " << actual << "\n"
                   << "    calculated: " << calc);
    }

     //BBL to Gallon 
     actual =
         UnitOfMeasureConversion(NullCommodityType(), BarrelUnitOfMeasure(),
                                 GallonUnitOfMeasure(), 42)
         .convert(Quantity(NullCommodityType(), GallonUnitOfMeasure(), 1000));
     calc =
         UOMManager.lookup(NullCommodityType(), BarrelUnitOfMeasure(),
                           GallonUnitOfMeasure(),
                           UnitOfMeasureConversion::Direct)
         .convert(Quantity(NullCommodityType(), GallonUnitOfMeasure(), 1000));

     if (!close(calc,actual)) {
        BOOST_FAIL("Wrong result for BBL to Gallon Conversion: \n"
                   << "    actual:     " << actual << "\n"
                   << "    calculated: " << calc);
     }

     //BBL to Litre 
     actual =
         UnitOfMeasureConversion(NullCommodityType(), BarrelUnitOfMeasure(),
                                 LitreUnitOfMeasure(), 158.987)
         .convert(Quantity(NullCommodityType(), LitreUnitOfMeasure(), 1000));
     calc =
         UOMManager.lookup(NullCommodityType(),BarrelUnitOfMeasure(),
                           LitreUnitOfMeasure(),
                           UnitOfMeasureConversion::Direct)
         .convert(Quantity(NullCommodityType(), LitreUnitOfMeasure(), 1000));

     if (!close(calc,actual)) {
        BOOST_FAIL("Wrong result for BBL to Litre Conversion: \n"
                   << "    actual:     " << actual << "\n"
                   << "    calculated: " << calc);
     }

     //BBL to KL 
     actual =
         UnitOfMeasureConversion(NullCommodityType(), KilolitreUnitOfMeasure(),
                                 BarrelUnitOfMeasure(), 6.28981)
         .convert(Quantity(NullCommodityType(),KilolitreUnitOfMeasure(),1000));
     calc =
         UOMManager.lookup(NullCommodityType(),BarrelUnitOfMeasure(),
                           KilolitreUnitOfMeasure(),
                           UnitOfMeasureConversion::Direct)
         .convert(Quantity(NullCommodityType(),KilolitreUnitOfMeasure(),1000));

     if (!close(calc,actual)) {
        BOOST_FAIL("Wrong result for BBL to KiloLitre Conversion: \n"
                   << "    actual:     " << actual << "\n"
                   << "    calculated: " << calc);
     }

     //MB to Gallon 
     actual =
         UnitOfMeasureConversion(NullCommodityType(), GallonUnitOfMeasure(),
                                 MBUnitOfMeasure(), 42000)
         .convert(Quantity(NullCommodityType(),MBUnitOfMeasure(),1000));
     calc =
         UOMManager.lookup(NullCommodityType(),GallonUnitOfMeasure(),
                           MBUnitOfMeasure(), UnitOfMeasureConversion::Direct)
         .convert(Quantity(NullCommodityType(),MBUnitOfMeasure(),1000));

     if (!close(calc,actual)) {
        BOOST_FAIL("Wrong result for MB to Gallon Conversion: \n"
                   << "    actual:     " << actual << "\n"
                   << "    calculated: " << calc);
     }

     //Gallon to Litre 
     actual =
         UnitOfMeasureConversion(NullCommodityType(), LitreUnitOfMeasure(),
                                 GallonUnitOfMeasure(), 3.78541)
         .convert(Quantity(NullCommodityType(),LitreUnitOfMeasure(),1000));
     calc =
         UOMManager.lookup(NullCommodityType(),GallonUnitOfMeasure(),
                           LitreUnitOfMeasure(),
                           UnitOfMeasureConversion::Direct)
         .convert(Quantity(NullCommodityType(),LitreUnitOfMeasure(),1000));

     if (!close(calc,actual)) {
        BOOST_FAIL("Wrong result for Gallon to Litre Conversion: \n"
                   << "    actual:     " << actual << "\n"
                   << "    calculated: " << calc);
     }
}

test_suite* CommodityUnitOfMeasureTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Commodity Unit Of Measure tests");
    suite->add(QUANTLIB_TEST_CASE(&CommodityUnitOfMeasureTest::testDirect));
    return suite;
}

]]></document_content>
  </document>
  <document index="57">
    <source>commodityunitofmeasure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Manas Bhatt

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_commodity_unit_of_measure_hpp
#define quantlib_test_commodity_unit_of_measure_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CommodityUnitOfMeasureTest {
  public:
    static void testDirect();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="58">
    <source>compiledboostversion.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Aprexo Limited

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "compiledboostversion.hpp"
#include "utilities.hpp"

#include <ql/version.hpp>

#include <boost/version.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void CompiledBoostVersionTest::test() {

    BOOST_TEST_MESSAGE("Testing compiled boost version...");

    // this will fail if the test suite is being built with a different boost version than the library was
    BOOST_CHECK(QuantLib::compiledBoostVersion() == BOOST_VERSION);
}


test_suite* CompiledBoostVersionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Compiled boost version test");
    suite->add(QUANTLIB_TEST_CASE(&CompiledBoostVersionTest::test));
    return suite;
}

]]></document_content>
  </document>
  <document index="59">
    <source>compiledboostversion.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Aprexo Limited

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_compiledboostversion_test_hpp
#define quantlib_compiledboostversion_test_hpp

#include <boost/test/unit_test.hpp>


/* Simply ensures that compiledBoostVersion() returns BOOST_VERSION */
class CompiledBoostVersionTest {
  public:
    static void test();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="60">
    <source>compoundoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "compoundoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/compoundoption.hpp>
#include <ql/experimental/exoticoptions/analyticcompoundoptionengine.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoffM, payoffD, exerciseM,    \
                       exerciseD, s, q, r, today,                 \
                       v, expected, calculated, error, tolerance) \
            BOOST_FAIL(\
               "\nmother option type:   " << payoffM->optionType() << \
               "\ndaughter option type: " << payoffD->optionType() << \
               "\nspot value:           " << s << \
               "\nstrike mother:        " << payoffM->strike() << \
               "\nstrike daughter:      " << payoffD->strike() << \
               "\ndividend yield:       " << io::rate(q) << \
               "\nrisk-free rate:       " << io::rate(r) << \
               "\nreference date:       " << today << \
               "\nmaturity mother:      " << exerciseM->lastDate() << \
               "\nmaturity daughter:    " << exerciseD->lastDate() << \
               "\nvolatility:           " << io::volatility(v) << \
               "\n  expected " << greekName << ": " << expected << \
               "\ncalculated " << greekName << ": " << calculated << \
               "\nerror:                " << error << \
               "\ntolerance:            " << tolerance);

namespace compound_option_test {

    struct CompoundOptionData {
        Option::Type typeMother;
        Option::Type typeDaughter;
        Real strikeMother;
        Real strikeDaughter;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time tMother;  // time to maturity
        Time tDaughter;// time to maturity
        Volatility v;  // volatility
        Real npv;   // expected result
        Real tol;      // tolerance
        Real delta;
        Real gamma;
        Real vega;
        Real theta;
    };

}


void CompoundOptionTest::testPutCallParity(){

    BOOST_TEST_MESSAGE("Testing compound-option put-call parity...");

    using namespace compound_option_test;

    // Test Put Call Parity for compound options.
    // Formula taken from: "Foreign Exchange Risk", Wystup, Risk 2002
    // Page 81, Equation 9.5


    CompoundOptionData values[] = {
        // type Mother, typeDaughter, strike Mother, strike Daughter,  spot,    q,    r,    t Mother, t Daughter,  vol
        { Option::Put, Option::Call,  50.0,            520.0   ,      500.0,   0.03, 0.08,  0.25,     0.5,        0.35},
        { Option::Call, Option::Call,  50.0,           520.0   ,      500.0,   0.03, 0.08,  0.25,     0.5,        0.35},
        { Option::Call, Option::Put,  50.0,            520.0   ,      500.0,   0.03, 0.08,  0.25,     0.5,        0.35},
        { Option::Call, Option::Call,  0.05,           1.14   ,      1.20,  0.0, 0.01,  0.5,     2.0,         0.11},
        { Option::Call, Option::Put ,  0.05,           1.14   ,      1.20,  0.0, 0.01,  0.5,     2.0,         0.11},
        { Option::Call, Option::Call,  10.0,           122.0   ,      120.0,    0.06, 0.02,  0.1,     0.7,        0.22},
        { Option::Call, Option::Put,  10.0,           122.0   ,      120.0,     0.06, 0.02,  0.1,     0.7,        0.22},
        { Option::Call, Option::Call,  0.4,           8.2   ,      8.0,     0.05, 0.00,  2.0,     3.0,        0.08},
        { Option::Call, Option::Put,  0.4,           8.2   ,      8.0,  0.05, 0.00,  2.0,     3.0,        0.08},
        { Option::Call, Option::Call,  0.02,           1.6   ,      1.6,    0.013, 0.022,  0.45,     0.5,        0.17},
        { Option::Call, Option::Put,  0.02,           1.6   ,      1.6,     0.013, 0.022,  0.45,     0.5,         0.17},
    };

    SavedSettings backup;

    Calendar calendar = TARGET();

    DayCounter dc = Actual360();
    Date todaysDate = Settings::instance().evaluationDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));

    ext::shared_ptr<YieldTermStructure> rTS(
              new FlatForward(0, NullCalendar(), Handle<Quote>(rRate), dc));

    ext::shared_ptr<YieldTermStructure> qTS(
              new FlatForward(0, NullCalendar(), Handle<Quote>(qRate), dc));

    ext::shared_ptr<BlackVolTermStructure> volTS(
                              new BlackConstantVol(todaysDate, NullCalendar(),
                                                   Handle<Quote>(vol), dc));

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoffMotherCall(
            new PlainVanillaPayoff(Option::Call, value.strikeMother));

        ext::shared_ptr<StrikedTypePayoff> payoffMotherPut(
            new PlainVanillaPayoff(Option::Put, value.strikeMother));

        ext::shared_ptr<StrikedTypePayoff> payoffDaughter(
            new PlainVanillaPayoff(value.typeDaughter, value.strikeDaughter));

        Date matDateMom = todaysDate + timeToDays(value.tMother);
        Date matDateDaughter = todaysDate + timeToDays(value.tDaughter);

        ext::shared_ptr<Exercise> exerciseCompound(
                                            new EuropeanExercise(matDateMom));
        ext::shared_ptr<Exercise> exerciseDaughter(
                                       new EuropeanExercise(matDateDaughter));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        CompoundOption compoundOptionCall(payoffMotherCall,exerciseCompound,
                                          payoffDaughter, exerciseDaughter);

        CompoundOption compoundOptionPut(payoffMotherPut,exerciseCompound,
                                         payoffDaughter, exerciseDaughter);

        VanillaOption vanillaOption(EuropeanOption(payoffDaughter,
                                                   exerciseDaughter));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
            new BlackScholesMertonProcess(
                      Handle<Quote>(spot),
                      Handle<YieldTermStructure>(qTS),
                      Handle<YieldTermStructure>(rTS),
                      Handle<BlackVolTermStructure>(volTS)));


        ext::shared_ptr<PricingEngine> engineCompound(
                              new AnalyticCompoundOptionEngine(stochProcess));

        ext::shared_ptr<PricingEngine> engineEuropean(
                                     new AnalyticEuropeanEngine(stochProcess));

        compoundOptionCall.setPricingEngine(engineCompound);
        compoundOptionPut.setPricingEngine(engineCompound);
        vanillaOption.setPricingEngine(engineEuropean);

        Real discFact=rTS->discount(matDateMom);
        Real discStrike = value.strikeMother * discFact;

        Real calculated =
            compoundOptionCall.NPV() + discStrike - compoundOptionPut.NPV()
            - vanillaOption.NPV();

        Real expected=0.0;
        Real error=std::abs(calculated-expected);
        Real tolerance=1.0e-8;

        if(error>tolerance){
            REPORT_FAILURE("put call parity", payoffMotherCall, payoffDaughter, exerciseCompound,
                           exerciseDaughter, value.s, value.q, value.r, todaysDate, value.v,
                           value.delta, calculated, error, tolerance);
        }
    }
}

void CompoundOptionTest::testValues(){

    BOOST_TEST_MESSAGE("Testing compound-option values and greeks...");

    using namespace compound_option_test;

    CompoundOptionData values[] = {
        // type Mother, typeDaughter, strike Mother, strike Daughter,  spot,    q,    r,    t Mother, t Daughter,  vol,   value,    tol, delta, gamma, vega, theta
        // Tolerance is taken to be pretty high with 1.0e-3, since the price/theta is very sensitive with respect to
        // the implementation of the bivariate normal - which differs in the various implementations.
        // Option Value Taken from Haug 2007, Greeks from www.sitmo.com
        { Option::Put, Option::Call,  50.0,            520.0   ,      500.0,   0.03, 0.08,  0.25,     0.5,        0.35,  21.1965,   1.0e-3, -0.1966,0.0007, -32.1241, -3.3837},
        //*********************************************************
        // Option Values and Greeks taken from www.sitmo.com
        { Option::Call, Option::Call,  50.0,           520.0   ,      500.0,   0.03, 0.08,  0.25,     0.5,        0.35,  17.5945,   1.0e-3,  0.3219,0.0038, 106.5185, -65.1614},
        { Option::Call, Option::Put,  50.0,            520.0   ,      500.0,   0.03, 0.08,  0.25,     0.5,        0.35,  18.7128,   1.0e-3,  -0.2906,0.0036, 103.3856, -46.6982},
        { Option::Put, Option::Put,  50.0,            520.0   ,      500.0,    0.03, 0.08,  0.25,     0.5,        0.35,  15.2601,   1.0e-3,  0.1760,0.0005, -35.2570, -10.1126},
        // type Mother, typeDaughter, strike Mother, strike Daughter,  spot,    q,    r,    t Mother, t Daughter,  vol,   value,    tol, delta, gamma, vega, theta
        { Option::Call, Option::Call,  0.05,           1.14   ,      1.20,  0.0, 0.01,  0.5,     2.0,         0.11,  0.0729,   1.0e-3,  0.6614,2.5762, 0.5812, -0.0297},
        { Option::Call, Option::Put ,  0.05,           1.14   ,      1.20,  0.0, 0.01,  0.5,     2.0,         0.11,  0.0074,   1.0e-3,  -0.1334,1.9681, 0.2933, -0.0155},
        { Option::Put  ,Option::Call,  0.05,           1.14   ,      1.20,  0.0, 0.01,  0.5,     2.0,         0.11,  0.0021,   1.0e-3,  -0.0426,0.7252, -0.0052, -0.0058},
        { Option::Put, Option::Put ,  0.05,           1.14   ,      1.20,   0.0, 0.01,  0.5,     2.0,         0.11,  0.0192,   1.0e-3,  0.1626,0.1171, -0.2931, -0.0028},
        // type Mother, typeDaughter, strike Mother, strike Daughter,  spot,    q,    r,    t Mother, t Daughter,  vol,   value,    tol, delta, gamma, vega, theta
        { Option::Call, Option::Call,  10.0,           122.0   ,      120.0,    0.06, 0.02,  0.1,     0.7,        0.22,  0.4419,   1.0e-3,  0.1049,0.0195, 11.3368, -6.2871},
        { Option::Call, Option::Put,  10.0,           122.0   ,      120.0,     0.06, 0.02,  0.1,     0.7,        0.22,  2.6112,   1.0e-3,  -0.3618,0.0337, 28.4843, -13.4124},
        { Option::Put, Option::Call,  10.0,           122.0   ,      120.0,     0.06, 0.02,  0.1,     0.7,        0.22,  4.1616,   1.0e-3,  -0.3174,0.0024, -26.6403, -2.2720},
        { Option::Put, Option::Put,  10.0,           122.0   ,      120.0,  0.06, 0.02,  0.1,     0.7,        0.22,  1.0914,   1.0e-3,  0.1748,0.0165, -9.4928, -4.8995},
        //*********************************************************
        //*********************************************************
        // Option Values and Greeks taken from mathfinance VBA implementation
        // type Mother, typeDaughter, strike Mother, strike Daughter,  spot,    q,    r,    t Mother, t Daughter,  vol,   value,    tol, delta, gamma, vega, theta
        { Option::Call, Option::Call,  0.4,           8.2   ,      8.0,  0.05, 0.00,  2.0,     3.0,        0.08,  0.0099,   1.0e-3,  0.0285,0.0688, 0.7764, -0.0027},
        { Option::Call, Option::Put,  0.4,           8.2   ,      8.0,   0.05, 0.00,  2.0,     3.0,        0.08,  0.9826,   1.0e-3,  -0.7224,0.2158, 2.7279, -0.3332},
        { Option::Put, Option::Call,  0.4,           8.2   ,      8.0,   0.05, 0.00,  2.0,     3.0,        0.08,  0.3585,   1.0e-3,  -0.0720,-0.0835, -1.5633, -0.0117},
        { Option::Put, Option::Put,  0.4,           8.2   ,      8.0,    0.05, 0.00,  2.0,     3.0,        0.08,  0.0168,   1.0e-3,  0.0378, 0.0635, 0.3882, 0.0021},
        // type Mother, typeDaughter, strike Mother, strike Daughter,  spot,    q,    r,    t Mother, t Daughter,  vol,   value,    tol, delta, gamma, vega, theta
        { Option::Call, Option::Call,  0.02,           1.6   ,      1.6,     0.013, 0.022,  0.45,     0.5,         0.17,  0.0680,   1.0e-3,  0.4937,2.1271, 0.4418, -0.0843},
        { Option::Call, Option::Put,  0.02,           1.6   ,      1.6,  0.013, 0.022,  0.45,     0.5,         0.17,  0.0605,   1.0e-3,  -0.4169,2.0836, 0.4330, -0.0697},
        { Option::Put, Option::Call,  0.02,           1.6   ,      1.6,  0.013, 0.022,  0.45,     0.5,         0.17,  0.0081,   1.0e-3,  -0.0417,0.0761, -0.0045, -0.0020},
        { Option::Put, Option::Put,  0.02,           1.6   ,      1.6,   0.013, 0.022,  0.45,     0.5,         0.17,  0.0078,   1.0e-3,   0.0413,0.0326, -0.0133, -0.0016}
    };

    SavedSettings backup;

    Calendar calendar = TARGET();

    DayCounter dc = Actual360();
    Date todaysDate = Settings::instance().evaluationDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));

    ext::shared_ptr<YieldTermStructure> rTS(
              new FlatForward(0, NullCalendar(), Handle<Quote>(rRate), dc));

    ext::shared_ptr<YieldTermStructure> qTS(
              new FlatForward(0, NullCalendar(), Handle<Quote>(qRate), dc));

    ext::shared_ptr<BlackVolTermStructure> volTS(
                              new BlackConstantVol(todaysDate, NullCalendar(),
                                                   Handle<Quote>(vol), dc));

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoffMother(
            new PlainVanillaPayoff(value.typeMother, value.strikeMother));

        ext::shared_ptr<StrikedTypePayoff> payoffDaughter(
            new PlainVanillaPayoff(value.typeDaughter, value.strikeDaughter));

        Date matDateMom = todaysDate + timeToDays(value.tMother);
        Date matDateDaughter = todaysDate + timeToDays(value.tDaughter);

        ext::shared_ptr<Exercise> exerciseMother(
                                            new EuropeanExercise(matDateMom));
        ext::shared_ptr<Exercise> exerciseDaughter(
                                       new EuropeanExercise(matDateDaughter));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        CompoundOption compoundOption(payoffMother,exerciseMother,
                                      payoffDaughter, exerciseDaughter);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
            new BlackScholesMertonProcess(
                      Handle<Quote>(spot),
                      Handle<YieldTermStructure>(qTS),
                      Handle<YieldTermStructure>(rTS),
                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engineCompound(
                              new AnalyticCompoundOptionEngine(stochProcess));

        compoundOption.setPricingEngine(engineCompound);

        Real calculated = compoundOption.NPV();
        Real error = std::fabs(calculated - value.npv); //-values[i].npv
        Real tolerance = value.tol;

        if (error>tolerance) {
            REPORT_FAILURE("value", payoffMother, payoffDaughter, exerciseMother, exerciseDaughter,
                           value.s, value.q, value.r, todaysDate, value.v, value.npv, calculated,
                           error, tolerance);
        }

        calculated = compoundOption.delta();
        error = std::fabs(calculated - value.delta);
        tolerance = value.tol;

        if (error>tolerance) {
            REPORT_FAILURE("delta", payoffMother, payoffDaughter, exerciseMother, exerciseDaughter,
                           value.s, value.q, value.r, todaysDate, value.v, value.delta, calculated,
                           error, tolerance);
        }

        calculated = compoundOption.gamma();
        error = std::fabs(calculated - value.gamma);
        tolerance = value.tol;

        if (error>tolerance) {
            REPORT_FAILURE("gamma", payoffMother, payoffDaughter, exerciseMother, exerciseDaughter,
                           value.s, value.q, value.r, todaysDate, value.v, value.gamma, calculated,
                           error, tolerance);
        }

        calculated = compoundOption.vega();
        error = std::fabs(calculated - value.vega);
        tolerance = value.tol;

        if (error>tolerance) {
            REPORT_FAILURE("vega", payoffMother, payoffDaughter, exerciseMother, exerciseDaughter,
                           value.s, value.q, value.r, todaysDate, value.v, value.vega, calculated,
                           error, tolerance);
        }

        calculated = compoundOption.theta();
        error = std::fabs(calculated - value.theta);
        tolerance = value.tol;

        if (error>tolerance) {
            REPORT_FAILURE("theta", payoffMother, payoffDaughter, exerciseMother, exerciseDaughter,
                           value.s, value.q, value.r, todaysDate, value.v, value.theta, calculated,
                           error, tolerance);
        }
    }
}


test_suite* CompoundOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Compound option tests");

    suite->add(QUANTLIB_TEST_CASE(&CompoundOptionTest::testValues));
    suite->add(QUANTLIB_TEST_CASE(&CompoundOptionTest::testPutCallParity));

    return suite;
}


]]></document_content>
  </document>
  <document index="61">
    <source>compoundoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_compound_option_test_hpp
#define quantlib_compound_option_test_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CompoundOptionTest {
  public:
    static void testValues();
    static void testPutCallParity();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="62">
    <source>convertiblebonds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2008, 2009 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "convertiblebonds.hpp"
#include "utilities.hpp"
#include <ql/experimental/convertiblebonds/convertiblebond.hpp>
#include <ql/experimental/convertiblebonds/binomialconvertibleengine.hpp>
#include <ql/instruments/bonds/zerocouponbond.hpp>
#include <ql/instruments/bonds/fixedratebond.hpp>
#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/binomialengine.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/forwardcurve.hpp>
#include <ql/termstructures/yield/forwardspreadedtermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace convertible_bonds_test {

    struct CommonVars {
        // global data
        Date today, issueDate, maturityDate;
        Calendar calendar;
        DayCounter dayCounter;
        Frequency frequency;
        Natural settlementDays;

        RelinkableHandle<Quote> underlying;
        RelinkableHandle<YieldTermStructure> dividendYield, riskFreeRate;
        RelinkableHandle<BlackVolTermStructure> volatility;
        ext::shared_ptr<BlackScholesMertonProcess> process;

        RelinkableHandle<Quote> creditSpread;

        CallabilitySchedule no_callability;
        DividendSchedule no_dividends;

        Real faceAmount, redemption, conversionRatio;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            calendar = TARGET();

            today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;

            dayCounter = Actual360();
            frequency = Annual;
            settlementDays = 3;

            issueDate = calendar.advance(today,2,Days);
            maturityDate = calendar.advance(issueDate, 10, Years);
            // reset to avoid inconsistencies as the schedule is backwards
            issueDate = calendar.advance(maturityDate, -10, Years);

            underlying.linkTo(ext::make_shared<SimpleQuote>(50.0));
            dividendYield.linkTo(flatRate(today, 0.02, dayCounter));
            riskFreeRate.linkTo(flatRate(today, 0.05, dayCounter));
            volatility.linkTo(flatVol(today, 0.15, dayCounter));

            process = ext::make_shared<BlackScholesMertonProcess>(
                    underlying, dividendYield, riskFreeRate, volatility);

            creditSpread.linkTo(ext::make_shared<SimpleQuote>(0.005));

            // it fails with 1000000
            // faceAmount = 1000000.0;
            faceAmount = 100.0;
            redemption = 100.0;
            conversionRatio = redemption/underlying->value();
        }
    };

}


void ConvertibleBondTest::testBond() {

    /* when deeply out-of-the-money, the value of the convertible bond
       should equal that of the underlying plain-vanilla bond. */

    BOOST_TEST_MESSAGE(
       "Testing out-of-the-money convertible bonds against vanilla bonds...");

    using namespace convertible_bonds_test;

    CommonVars vars;

    vars.conversionRatio = 1.0e-16;

    ext::shared_ptr<Exercise> euExercise =
        ext::make_shared<EuropeanExercise>(vars.maturityDate);
    ext::shared_ptr<Exercise> amExercise =
        ext::make_shared<AmericanExercise>(vars.issueDate,
                                             vars.maturityDate);

    Size timeSteps = 1001;
    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<BinomialConvertibleEngine<CoxRossRubinstein> >(
            vars.process, timeSteps);

    Handle<YieldTermStructure> discountCurve(
         ext::make_shared<ForwardSpreadedTermStructure>(vars.riskFreeRate,
                                                          vars.creditSpread));

    // zero-coupon

    Schedule schedule =
        MakeSchedule().from(vars.issueDate)
                      .to(vars.maturityDate)
                      .withFrequency(Once)
                      .withCalendar(vars.calendar)
                      .backwards();

    ConvertibleZeroCouponBond euZero(euExercise, vars.conversionRatio,
                                     vars.no_dividends, vars.no_callability,
                                     vars.creditSpread,
                                     vars.issueDate, vars.settlementDays,
                                     vars.dayCounter, schedule,
                                     vars.redemption);
    euZero.setPricingEngine(engine);

    ConvertibleZeroCouponBond amZero(amExercise, vars.conversionRatio,
                                     vars.no_dividends, vars.no_callability,
                                     vars.creditSpread,
                                     vars.issueDate, vars.settlementDays,
                                     vars.dayCounter, schedule,
                                     vars.redemption);
    amZero.setPricingEngine(engine);

    ZeroCouponBond zero(vars.settlementDays, vars.calendar,
                        100.0, vars.maturityDate,
                        Following, vars.redemption, vars.issueDate);

    ext::shared_ptr<PricingEngine> bondEngine =
        ext::make_shared<DiscountingBondEngine>(discountCurve);
    zero.setPricingEngine(bondEngine);

    Real tolerance = 1.0e-2 * (vars.faceAmount/100.0);

    Real error = std::fabs(euZero.NPV()-zero.settlementValue());
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce zero-coupon bond price:"
                    << "\n    calculated: " << euZero.NPV()
                    << "\n    expected:   " << zero.settlementValue()
                    << "\n    error:      " << error);
    }

    error = std::fabs(amZero.NPV()-zero.settlementValue());
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce zero-coupon bond price:"
                    << "\n    calculated: " << amZero.NPV()
                    << "\n    expected:   " << zero.settlementValue()
                    << "\n    error:      " << error);
    }

    // coupon

    std::vector<Rate> coupons(1, 0.05);

    schedule = MakeSchedule().from(vars.issueDate)
                             .to(vars.maturityDate)
                             .withFrequency(vars.frequency)
                             .withCalendar(vars.calendar)
                             .backwards();

    ConvertibleFixedCouponBond euFixed(euExercise, vars.conversionRatio,
                                       vars.no_dividends, vars.no_callability,
                                       vars.creditSpread,
                                       vars.issueDate, vars.settlementDays,
                                       coupons, vars.dayCounter,
                                       schedule, vars.redemption);
    euFixed.setPricingEngine(engine);

    ConvertibleFixedCouponBond amFixed(amExercise, vars.conversionRatio,
                                       vars.no_dividends, vars.no_callability,
                                       vars.creditSpread,
                                       vars.issueDate, vars.settlementDays,
                                       coupons, vars.dayCounter,
                                       schedule, vars.redemption);
    amFixed.setPricingEngine(engine);

    FixedRateBond fixed(vars.settlementDays, vars.faceAmount, schedule,
                        coupons, vars.dayCounter, Following,
                        vars.redemption, vars.issueDate);

    fixed.setPricingEngine(bondEngine);

    tolerance = 2.0e-2 * (vars.faceAmount/100.0);

    error = std::fabs(euFixed.NPV()-fixed.settlementValue());
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce fixed-coupon bond price:"
                    << "\n    calculated: " << euFixed.NPV()
                    << "\n    expected:   " << fixed.settlementValue()
                    << "\n    error:      " << error);
    }

    error = std::fabs(amFixed.NPV()-fixed.settlementValue());
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce fixed-coupon bond price:"
                    << "\n    calculated: " << amFixed.NPV()
                    << "\n    expected:   " << fixed.settlementValue()
                    << "\n    error:      " << error);
    }

    // floating-rate

    ext::shared_ptr<IborIndex> index =
        ext::make_shared<Euribor1Y>(discountCurve);
    Natural fixingDays = 2;
    std::vector<Real> gearings(1, 1.0);
    std::vector<Rate> spreads;

    ConvertibleFloatingRateBond euFloating(euExercise, vars.conversionRatio,
                                           vars.no_dividends, vars.no_callability,
                                           vars.creditSpread,
                                           vars.issueDate, vars.settlementDays,
                                           index, fixingDays, spreads,
                                           vars.dayCounter, schedule,
                                           vars.redemption);
    euFloating.setPricingEngine(engine);

    ConvertibleFloatingRateBond amFloating(amExercise, vars.conversionRatio,
                                           vars.no_dividends, vars.no_callability,
                                           vars.creditSpread,
                                           vars.issueDate, vars.settlementDays,
                                           index, fixingDays, spreads,
                                           vars.dayCounter, schedule,
                                           vars.redemption);
    amFloating.setPricingEngine(engine);

    ext::shared_ptr<IborCouponPricer> pricer =
        ext::make_shared<BlackIborCouponPricer>(
            Handle<OptionletVolatilityStructure>());

    Schedule floatSchedule(vars.issueDate, vars.maturityDate,
                           Period(vars.frequency),
                           vars.calendar, Following, Following,
                           DateGeneration::Backward, false);

    FloatingRateBond floating(vars.settlementDays, vars.faceAmount, floatSchedule,
                              index, vars.dayCounter, Following, fixingDays,
                              gearings, spreads,
                              std::vector<Rate>(), std::vector<Rate>(),
                              false,
                              vars.redemption, vars.issueDate);

    floating.setPricingEngine(bondEngine);
    setCouponPricer(floating.cashflows(),pricer);

    tolerance = 2.0e-2 * (vars.faceAmount/100.0);

    error = std::fabs(euFloating.NPV()-floating.settlementValue());
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce floating-rate bond price:"
                    << "\n    calculated: " << euFloating.NPV()
                    << "\n    expected:   " << floating.settlementValue()
                    << "\n    error:      " << error);
    }

    error = std::fabs(amFloating.NPV()-floating.settlementValue());
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce floating-rate bond price:"
                    << "\n    calculated: " << amFloating.NPV()
                    << "\n    expected:   " << floating.settlementValue()
                    << "\n    error:      " << error);
    }
}

void ConvertibleBondTest::testOption() {

    /* a zero-coupon convertible bond with no credit spread is
       equivalent to a call option. */

    BOOST_TEST_MESSAGE(
       "Testing zero-coupon convertible bonds against vanilla option...");

    using namespace convertible_bonds_test;

    CommonVars vars;

    ext::shared_ptr<Exercise> euExercise =
        ext::make_shared<EuropeanExercise>(vars.maturityDate);

    vars.settlementDays = 0;

    Size timeSteps = 2001;
    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<BinomialConvertibleEngine<CoxRossRubinstein> >(
                                                     vars.process, timeSteps);
    ext::shared_ptr<PricingEngine> vanillaEngine =
        ext::make_shared<BinomialVanillaEngine<CoxRossRubinstein> >(
                                                     vars.process, timeSteps);

    vars.creditSpread.linkTo(ext::make_shared<SimpleQuote>(0.0));

    Real conversionStrike = vars.redemption/vars.conversionRatio;
    ext::shared_ptr<StrikedTypePayoff> payoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Call, conversionStrike);

    Schedule schedule = MakeSchedule().from(vars.issueDate)
                                      .to(vars.maturityDate)
                                      .withFrequency(Once)
                                      .withCalendar(vars.calendar)
                                      .backwards();

    ConvertibleZeroCouponBond euZero(euExercise, vars.conversionRatio,
                                     vars.no_dividends, vars.no_callability,
                                     vars.creditSpread,
                                     vars.issueDate, vars.settlementDays,
                                     vars.dayCounter, schedule,
                                     vars.redemption);
    euZero.setPricingEngine(engine);

    VanillaOption euOption(payoff, euExercise);
    euOption.setPricingEngine(vanillaEngine);

    Real tolerance = 5.0e-2 * (vars.faceAmount/100.0);

    Real expected = vars.faceAmount/100.0 *
        (vars.redemption * vars.riskFreeRate->discount(vars.maturityDate)
         + vars.conversionRatio* euOption.NPV());
    Real error = std::fabs(euZero.NPV()-expected);
    if (error > tolerance) {
        BOOST_ERROR("failed to reproduce plain-option price:"
                    << "\n    calculated: " << euZero.NPV()
                    << "\n    expected:   " << expected
                    << "\n    error:      " << error
                    << "\n    tolerance:      " << tolerance);
    }
}

void ConvertibleBondTest::testRegression() {

    BOOST_TEST_MESSAGE(
       "Testing fixed-coupon convertible bond in known regression case...");

    SavedSettings backup;

    Date today = Date(23, December, 2008);
    Date tomorrow = today + 1;

    Settings::instance().evaluationDate() = tomorrow;

    Handle<Quote> u(ext::make_shared<SimpleQuote>(2.9084382818797443));

    std::vector<Date> dates(25);
    std::vector<Rate> forwards(25);
    dates[0] = Date(29,December,2008);   forwards[0] = 0.0025999342800;
    dates[1] = Date(5,January,2009);     forwards[1] = 0.0025999342800;
    dates[2] = Date(29,January,2009);    forwards[2] = 0.0053123275500;
    dates[3] = Date(27,February,2009);   forwards[3] = 0.0197049598721;
    dates[4] = Date(30,March,2009);      forwards[4] = 0.0220524845296;
    dates[5] = Date(29,June,2009);       forwards[5] = 0.0217076395643;
    dates[6] = Date(29,December,2009);   forwards[6] = 0.0230349627478;
    dates[7] = Date(29,December,2010);   forwards[7] = 0.0087631647476;
    dates[8] = Date(29,December,2011);   forwards[8] = 0.0219084299499;
    dates[9] = Date(31,December,2012);   forwards[9] = 0.0244798766219;
    dates[10] = Date(30,December,2013);  forwards[10] = 0.0267885498456;
    dates[11] = Date(29,December,2014);  forwards[11] = 0.0266922867562;
    dates[12] = Date(29,December,2015);  forwards[12] = 0.0271052126386;
    dates[13] = Date(29,December,2016);  forwards[13] = 0.0268829891648;
    dates[14] = Date(29,December,2017);  forwards[14] = 0.0264594744498;
    dates[15] = Date(31,December,2018);  forwards[15] = 0.0273450367424;
    dates[16] = Date(30,December,2019);  forwards[16] = 0.0294852614749;
    dates[17] = Date(29,December,2020);  forwards[17] = 0.0285556119719;
    dates[18] = Date(29,December,2021);  forwards[18] = 0.0305557764659;
    dates[19] = Date(29,December,2022);  forwards[19] = 0.0292244738422;
    dates[20] = Date(29,December,2023);  forwards[20] = 0.0263917004194;
    dates[21] = Date(29,December,2028);  forwards[21] = 0.0239626970243;
    dates[22] = Date(29,December,2033);  forwards[22] = 0.0216417108090;
    dates[23] = Date(29,December,2038);  forwards[23] = 0.0228343838422;
    dates[24] = Date(31,December,2199);  forwards[24] = 0.0228343838422;

    Handle<YieldTermStructure> r(
              ext::make_shared<ForwardCurve>(dates, forwards, Actual360()));

    Handle<BlackVolTermStructure> sigma(ext::make_shared<BlackConstantVol>(
                                 tomorrow, NullCalendar(), 21.685235548092248,
                                 Thirty360(Thirty360::BondBasis)));

    ext::shared_ptr<BlackProcess> process =
        ext::make_shared<BlackProcess>(u,r,sigma);

    Handle<Quote> spread(ext::make_shared<SimpleQuote>(0.11498700678012874));

    Date issueDate(23, July, 2008);
    Date maturityDate(1, August, 2013);
    Calendar calendar = UnitedStates();
    Schedule schedule = MakeSchedule().from(issueDate)
                                      .to(maturityDate)
                                      .withTenor(6*Months)
                                      .withCalendar(calendar)
                                      .withConvention(Unadjusted);
    Natural settlementDays = 3;
    ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturityDate);
    Real conversionRatio = 100.0/20.3175;
    std::vector<Rate> coupons(schedule.size()-1, 0.05);
    DayCounter dayCounter = Thirty360(Thirty360::BondBasis);
    CallabilitySchedule no_callability;
    DividendSchedule no_dividends;
    Real redemption = 100.0;

    ConvertibleFixedCouponBond bond(exercise, conversionRatio,
                                    no_dividends, no_callability,
                                    spread, issueDate, settlementDays,
                                    coupons, dayCounter,
                                    schedule, redemption);
    bond.setPricingEngine(
        ext::make_shared<BinomialConvertibleEngine<CoxRossRubinstein> >(
                                                              process, 600));

    try {
        Real x = bond.NPV();  // should throw; if not, an INF was not detected.
        BOOST_FAIL("INF result was not detected: " << x << " returned");
    } catch (Error&) {
        // as expected. Do nothing.

        // Note: we're expecting an Error we threw, not just any
        // exception.  If something else is thrown, then there's
        // another problem and the test must fail.
    }
}


test_suite* ConvertibleBondTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Convertible bond tests");

    suite->add(QUANTLIB_TEST_CASE(&ConvertibleBondTest::testBond));
    suite->add(QUANTLIB_TEST_CASE(&ConvertibleBondTest::testOption));
    suite->add(QUANTLIB_TEST_CASE(&ConvertibleBondTest::testRegression));

    return suite;
}
]]></document_content>
  </document>
  <document index="63">
    <source>convertiblebonds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_convertible_bonds_hpp
#define quantlib_test_convertible_bonds_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ConvertibleBondTest {
  public:
    static void testBond();
    static void testOption();
    static void testRegression();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="64">
    <source>covariance.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "covariance.hpp"
#include "utilities.hpp"
#include <ql/math/matrixutilities/getcovariance.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace covariance_test {

    Real norm(const Matrix& m) {
        Real sum = 0.0;
        for (Size i=0; i<m.rows(); i++)
            for (Size j=0; j<m.columns(); j++)
                sum += m[i][j]*m[i][j];
        return std::sqrt(sum);
    }

}


void CovarianceTest::testRankReduction() {

    BOOST_TEST_MESSAGE("Testing matrix rank reduction salvaging algorithms...");

    using namespace covariance_test;

    Real expected, calculated;

    Size n = 3;

    Matrix badCorr(n, n);
    badCorr[0][0] = 1.0; badCorr[0][1] = 0.9; badCorr[0][2] = 0.7;
    badCorr[1][0] = 0.9; badCorr[1][1] = 1.0; badCorr[1][2] = 0.3;
    badCorr[2][0] = 0.7; badCorr[2][1] = 0.3; badCorr[2][2] = 1.0;

    Matrix goodCorr(n, n);
    goodCorr[0][0] = goodCorr[1][1] = goodCorr[2][2] = 1.00000000000;
    goodCorr[0][1] = goodCorr[1][0] = 0.894024408508599;
    goodCorr[0][2] = goodCorr[2][0] = 0.696319066114392;
    goodCorr[1][2] = goodCorr[2][1] = 0.300969036104592;

    Matrix b = rankReducedSqrt(badCorr, 3, 1.0, SalvagingAlgorithm::Spectral);
    Matrix calcCorr = b * transpose(b);

    for (Size i=0; i<n; i++) {
        for (Size j=0; j<n; j++) {
            expected   = goodCorr[i][j];
            calculated = calcCorr[i][j];
            if (std::fabs(calculated-expected) > 1.0e-10)
                BOOST_ERROR("Salvaging correlation with spectral alg "
                            "through rankReducedSqrt "
                            << "cor[" << i << "][" << j << "]:\n"
                            << std::setprecision(10)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected);
        }
    }

    Matrix badCov(n, n);
    badCov[0][0] = 0.04000; badCov[0][1] = 0.03240; badCov[0][2] = 0.02240;
    badCov[1][0] = 0.03240; badCov[1][1] = 0.03240; badCov[1][2] = 0.00864;
    badCov[2][0] = 0.02240; badCov[2][1] = 0.00864; badCov[2][2] = 0.02560;

    b = pseudoSqrt(badCov, SalvagingAlgorithm::Spectral);
    b = rankReducedSqrt(badCov, 3, 1.0, SalvagingAlgorithm::Spectral);
    Matrix goodCov = b * transpose(b);

    Real error = norm(goodCov-badCov);
    if (error > 4.0e-4)
        BOOST_ERROR(
            std::scientific << error
            << " error while salvaging covariance matrix with spectral alg "
            "through rankReducedSqrt\n"
            << std::fixed
            << "input matrix:\n" << badCov
            << "salvaged matrix:\n" << goodCov);
}

void CovarianceTest::testSalvagingMatrix() {

    BOOST_TEST_MESSAGE("Testing positive semi-definiteness salvaging "
                       "algorithms...");

    using namespace covariance_test;

    Real expected, calculated;

    Size n = 3;

    Matrix badCorr(n, n);
    badCorr[0][0] = 1.0; badCorr[0][1] = 0.9; badCorr[0][2] = 0.7;
    badCorr[1][0] = 0.9; badCorr[1][1] = 1.0; badCorr[1][2] = 0.3;
    badCorr[2][0] = 0.7; badCorr[2][1] = 0.3; badCorr[2][2] = 1.0;

    Matrix goodCorr(n, n);
    goodCorr[0][0] = goodCorr[1][1] = goodCorr[2][2] = 1.00000000000;
    goodCorr[0][1] = goodCorr[1][0] = 0.894024408508599;
    goodCorr[0][2] = goodCorr[2][0] = 0.696319066114392;
    goodCorr[1][2] = goodCorr[2][1] = 0.300969036104592;

    Matrix b = pseudoSqrt(badCorr, SalvagingAlgorithm::Spectral);
//    Matrix b = pseudoSqrt(badCorr, Hypersphere);
    Matrix calcCorr = b * transpose(b);

    for (Size i=0; i<n; i++) {
        for (Size j=0; j<n; j++) {
            expected   = goodCorr[i][j];
            calculated = calcCorr[i][j];
            if (std::fabs(calculated-expected) > 1.0e-10)
                BOOST_ERROR("SalvagingCorrelation with spectral alg "
                            << "cor[" << i << "][" << j << "]:\n"
                            << std::setprecision(10)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected);
        }
    }

    Matrix badCov(n, n);
    badCov[0][0] = 0.04000; badCov[0][1] = 0.03240; badCov[0][2] = 0.02240;
    badCov[1][0] = 0.03240; badCov[1][1] = 0.03240; badCov[1][2] = 0.00864;
    badCov[2][0] = 0.02240; badCov[2][1] = 0.00864; badCov[2][2] = 0.02560;

    b = pseudoSqrt(badCov, SalvagingAlgorithm::Spectral);
    Matrix goodCov = b * transpose(b);

    Real error = norm(goodCov-badCov);
    if (error > 4.0e-4)
        BOOST_ERROR(
            std::scientific << error
            << " error while salvaging covariance matrix with spectral alg\n"
            << std::fixed
            << "input matrix:\n" << badCov
            << "salvaged matrix:\n" << goodCov);
}

void CovarianceTest::testCovariance() {

    BOOST_TEST_MESSAGE("Testing covariance and correlation calculations...");

    std::vector<std::vector<Real>> data = {
        { 3.0,  9.0 },
        { 2.0,  7.0 },
        { 4.0, 12.0 },
        { 5.0, 15.0 },
        { 6.0, 17.0 }
    };
    std::vector<Real> weights(data.size(), 1.0);

    Size i, j, n = data[0].size();

    Matrix expCor(n, n);
    expCor[0][0] = 1.0000000000000000; expCor[0][1] = 0.9970544855015813;
    expCor[1][0] = 0.9970544855015813; expCor[1][1] = 1.0000000000000000;

    SequenceStatistics s(n);
    std::vector<Real> temp(n);

    for (i = 0; i<data.size(); i++) {
        for (j=0; j<n; j++) {
            temp[j]= data[i][j];
        }
        s.add(temp, weights[i]);
    }

    std::vector<Real> std = s.standardDeviation();
    Matrix calcCov  =  s.covariance();
    Matrix calcCor  =  s.correlation();

    Matrix expCov(n, n);
    for (i=0; i<n; i++) {
        expCov[i][i] = std[i]*std[i];
        for (j=0; j<i; j++) {
            expCov[i][j] = expCov[j][i] = expCor[i][j]*std[i]*std[j];
        }
    }

    Real expected, calculated;
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            expected   =  expCor[i][j];
            calculated = calcCor[i][j];
            if (std::fabs(calculated-expected) > 1.0e-10)
                BOOST_ERROR("SequenceStatistics "
                            << "cor[" << i << "][" << j << "]:\n"
                            << std::setprecision(10)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected);

            expected   =  expCov[i][j];
            calculated = calcCov[i][j];
            if (std::fabs(calculated-expected) > 1.0e-10)
                BOOST_ERROR("SequenceStatistics "
                            << "cov[" << i << "][" << j << "]:\n"
                            << std::setprecision(10)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected);
        }
    }

    calcCov = getCovariance(std.begin(), std.end(), expCor);

    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            Real calculated = calcCov[i][j],
                 expected   = expCov[i][j];
            if (std::fabs(calculated-expected) > 1.0e-10) {
                BOOST_ERROR("getCovariance "
                            << "cov[" << i << "][" << j << "]:\n"
                            << std::setprecision(10)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected);
            }
        }
    }




    CovarianceDecomposition covDecomposition(expCov);
    calcCor = covDecomposition.correlationMatrix();
    Array calcStd = covDecomposition.standardDeviations();

    for (i=0; i<n; i++) {
        calculated = calcStd[i];
        expected   = std[i];
        if (std::fabs(calculated-expected) > 1.0e-16) {
            BOOST_ERROR("CovarianceDecomposition "
                        << "standardDev[" << i << "]:\n"
                        << std::setprecision(16) << std::scientific
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << expected);
        }
        for (j=0; j<n; j++) {
            calculated = calcCor[i][j];
            expected   = expCor[i][j];
            if (std::fabs(calculated-expected) > 1.0e-14) {
                BOOST_ERROR("\nCovarianceDecomposition "
                            << "corr[" << i << "][" << j << "]:\n"
                            << std::setprecision(14) << std::scientific
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected);
            }
        }
    }



}


test_suite* CovarianceTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Covariance and correlation tests");
    suite->add(QUANTLIB_TEST_CASE(&CovarianceTest::testCovariance));
    suite->add(QUANTLIB_TEST_CASE(&CovarianceTest::testSalvagingMatrix));
    suite->add(QUANTLIB_TEST_CASE(&CovarianceTest::testRankReduction));
    return suite;
}

]]></document_content>
  </document>
  <document index="65">
    <source>covariance.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_covariance_hpp
#define quantlib_test_covariance_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CovarianceTest {
  public:
    static void testCovariance();
    static void testSalvagingMatrix();
    static void testRankReduction();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="66">
    <source>creditdefaultswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "creditdefaultswap.hpp"
#include "utilities.hpp"
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/instruments/makecds.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/pricingengines/credit/integralcdsengine.hpp>
#include <ql/pricingengines/credit/isdacdsengine.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/termstructures/credit/interpolatedhazardratecurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/discountcurve.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/calendars/weekendsonly.hpp>
#include <ql/currencies/america.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <map>
#include <iomanip>
#include <iostream>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using std::map;

void CreditDefaultSwapTest::testCachedValue() {

    BOOST_TEST_MESSAGE("Testing credit-default swap against cached values...");

    SavedSettings backup;

    // Initialize curves
    Settings::instance().evaluationDate() = Date(9,June,2006);
    Date today = Settings::instance().evaluationDate();
    Calendar calendar = TARGET();

    Handle<Quote> hazardRate = Handle<Quote>(
                ext::shared_ptr<Quote>(new SimpleQuote(0.01234)));
    RelinkableHandle<DefaultProbabilityTermStructure> probabilityCurve;
    probabilityCurve.linkTo(
        ext::shared_ptr<DefaultProbabilityTermStructure>(
                   new FlatHazardRate(0, calendar, hazardRate, Actual360())));

    RelinkableHandle<YieldTermStructure> discountCurve;

    discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                            new FlatForward(today,0.06,Actual360())));

    // Build the schedule
    Date issueDate = calendar.advance(today, -1, Years);
    Date maturity = calendar.advance(issueDate, 10, Years);
    Frequency frequency = Semiannual;
    BusinessDayConvention convention = ModifiedFollowing;

    Schedule schedule(issueDate, maturity, Period(frequency), calendar,
                      convention, convention, DateGeneration::Forward, false);

    // Build the CDS
    Rate fixedRate = 0.0120;
    DayCounter dayCount = Actual360();
    Real notional = 10000.0;
    Real recoveryRate = 0.4;

    CreditDefaultSwap cds(Protection::Seller, notional, fixedRate,
                          schedule, convention, dayCount, true, true);
    cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
         new MidPointCdsEngine(probabilityCurve,recoveryRate,discountCurve)));

    Real npv = 295.0153398;
    Rate fairRate = 0.007517539081;

    Real calculatedNpv = cds.NPV();
    Rate calculatedFairRate = cds.fairSpread();
    Real tolerance = 1.0e-7;

    if (std::fabs(calculatedNpv - npv) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce NPV with mid-point engine\n"
            << std::setprecision(10)
            << "    calculated NPV: " << calculatedNpv << "\n"
            << "    expected NPV:   " << npv);

    if (std::fabs(calculatedFairRate - fairRate) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce fair rate with mid-point engine\n"
            << std::setprecision(10)
            << "    calculated fair rate: " << calculatedFairRate << "\n"
            << "    expected fair rate:   " << fairRate);

    cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
                          new IntegralCdsEngine(1*Days,probabilityCurve,
                                                recoveryRate,discountCurve)));

    calculatedNpv = cds.NPV();
    calculatedFairRate = cds.fairSpread();
    tolerance = 1.0e-5;

    if (std::fabs(calculatedNpv - npv) > notional*tolerance*10)
        BOOST_ERROR(
            "Failed to reproduce NPV with integral engine "
            "(step = 1 day)\n"
            << std::setprecision(10)
            << "    calculated NPV: " << calculatedNpv << "\n"
            << "    expected NPV:   " << npv);

    if (std::fabs(calculatedFairRate - fairRate) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce fair rate with integral engine "
            "(step = 1 day)\n"
            << std::setprecision(10)
            << "    calculated fair rate: " << calculatedFairRate << "\n"
            << "    expected fair rate:   " << fairRate);

    cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
                          new IntegralCdsEngine(1*Weeks,probabilityCurve,
                                                recoveryRate,discountCurve)));

    calculatedNpv = cds.NPV();
    calculatedFairRate = cds.fairSpread();
    tolerance = 1.0e-5;

    if (std::fabs(calculatedNpv - npv) > notional*tolerance*10)
        BOOST_ERROR(
            "Failed to reproduce NPV with integral engine "
            "(step = 1 week)\n"
            << std::setprecision(10)
            << "    calculated NPV: " << calculatedNpv << "\n"
            << "    expected NPV:   " << npv);

    if (std::fabs(calculatedFairRate - fairRate) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce fair rate with integral engine "
            "(step = 1 week)\n"
            << std::setprecision(10)
            << "    calculated fair rate: " << calculatedFairRate << "\n"
            << "    expected fair rate:   " << fairRate);
}


void CreditDefaultSwapTest::testCachedMarketValue() {

    BOOST_TEST_MESSAGE(
        "Testing credit-default swap against cached market values...");

    SavedSettings backup;

    Settings::instance().evaluationDate() = Date(9,June,2006);
    Date evalDate = Settings::instance().evaluationDate();
    Calendar calendar = UnitedStates();

    std::vector<Date> discountDates = {
        evalDate,
        calendar.advance(evalDate, 1, Weeks,  ModifiedFollowing),
        calendar.advance(evalDate, 1, Months, ModifiedFollowing),
        calendar.advance(evalDate, 2, Months, ModifiedFollowing),
        calendar.advance(evalDate, 3, Months, ModifiedFollowing),
        calendar.advance(evalDate, 6, Months, ModifiedFollowing),
        calendar.advance(evalDate,12, Months, ModifiedFollowing),
        calendar.advance(evalDate, 2, Years, ModifiedFollowing),
        calendar.advance(evalDate, 3, Years, ModifiedFollowing),
        calendar.advance(evalDate, 4, Years, ModifiedFollowing),
        calendar.advance(evalDate, 5, Years, ModifiedFollowing),
        calendar.advance(evalDate, 6, Years, ModifiedFollowing),
        calendar.advance(evalDate, 7, Years, ModifiedFollowing),
        calendar.advance(evalDate, 8, Years, ModifiedFollowing),
        calendar.advance(evalDate, 9, Years, ModifiedFollowing),
        calendar.advance(evalDate,10, Years, ModifiedFollowing),
        calendar.advance(evalDate,15, Years, ModifiedFollowing)
    };
    
    std::vector<DiscountFactor> dfs = {
        1.0,
        0.9990151375768731,
        0.99570502636871183,
        0.99118260474528685,
        0.98661167950906203,
        0.9732592953359388,
        0.94724424481038083,
        0.89844996737120875,
        0.85216647839921411,
        0.80775477692556874,
        0.76517289234200347,
        0.72401019553182933,
        0.68503909569219212,
        0.64797499814013748,
        0.61263171936255534,
        0.5791942350748791,
        0.43518868769953606
    };

    const DayCounter& curveDayCounter=Actual360();

    RelinkableHandle<YieldTermStructure> discountCurve;
    discountCurve.linkTo(
        ext::shared_ptr<YieldTermStructure>(
            new DiscountCurve(discountDates, dfs, curveDayCounter)));

    DayCounter dayCounter = Thirty360(Thirty360::BondBasis);
    std::vector<Date> dates = {
        evalDate,
        calendar.advance(evalDate, 6, Months, ModifiedFollowing),
        calendar.advance(evalDate, 1, Years, ModifiedFollowing),
        calendar.advance(evalDate, 2, Years, ModifiedFollowing),
        calendar.advance(evalDate, 3, Years, ModifiedFollowing),
        calendar.advance(evalDate, 4, Years, ModifiedFollowing),
        calendar.advance(evalDate, 5, Years, ModifiedFollowing),
        calendar.advance(evalDate, 7, Years, ModifiedFollowing),
        calendar.advance(evalDate,10, Years, ModifiedFollowing)
    };

    std::vector<Probability> defaultProbabilities = {
        0.0000,
        0.0047,
        0.0093,
        0.0286,
        0.0619,
        0.0953,
        0.1508,
        0.2288,
        0.3666
    };

    std::vector<Real> hazardRates;
    hazardRates.push_back(0.0);
    for (Size i=1; i<dates.size(); ++i) {
        Time t1 = dayCounter.yearFraction(dates[0], dates[i-1]);
        Time t2 = dayCounter.yearFraction(dates[0], dates[i]);
        Probability S1 = 1.0 - defaultProbabilities[i-1];
        Probability S2 = 1.0 - defaultProbabilities[i];
        hazardRates.push_back(std::log(S1/S2)/(t2-t1));
    }

    RelinkableHandle<DefaultProbabilityTermStructure> piecewiseFlatHazardRate;
    piecewiseFlatHazardRate.linkTo(
        ext::shared_ptr<DefaultProbabilityTermStructure>(
               new InterpolatedHazardRateCurve<BackwardFlat>(dates,
                                                             hazardRates,
                                                             Thirty360(Thirty360::BondBasis))));

    // Testing credit default swap

    // Build the schedule
    Date issueDate(20, March, 2006);
    Date maturity(20, June, 2013);
    Frequency cdsFrequency = Semiannual;
    BusinessDayConvention cdsConvention = ModifiedFollowing;

    Schedule schedule(issueDate, maturity, Period(cdsFrequency), calendar,
                      cdsConvention, cdsConvention,
                      DateGeneration::Forward, false);

    // Build the CDS
    Real recoveryRate = 0.25;
    Rate fixedRate=0.0224;
    DayCounter dayCount=Actual360();
    Real cdsNotional=100.0;

    CreditDefaultSwap cds(Protection::Seller, cdsNotional, fixedRate,
                          schedule, cdsConvention, dayCount, true, true);
    cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
                          new MidPointCdsEngine(piecewiseFlatHazardRate,
                                                recoveryRate,discountCurve)));

    Real calculatedNpv = cds.NPV();
    Real calculatedFairRate = cds.fairSpread();

    double npv = -1.364048777;        // from Bloomberg we have 98.15598868 - 100.00;
    double fairRate =  0.0248429452; // from Bloomberg we have 0.0258378;

    Real tolerance = 1e-9;

    if (std::fabs(npv - calculatedNpv) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce the npv for the given credit-default swap\n"
            << std::setprecision(10)
            << "    computed NPV:  " << calculatedNpv << "\n"
            << "    Given NPV:     " << npv);

    if (std::fabs(fairRate - calculatedFairRate) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce the fair rate for the given credit-default swap\n"
            << std::setprecision(10)
            << "    computed fair rate:  " << calculatedFairRate << "\n"
            << "    Given fair rate:     " << fairRate);
}


void CreditDefaultSwapTest::testImpliedHazardRate() {

    BOOST_TEST_MESSAGE("Testing implied hazard-rate for credit-default swaps...");

    SavedSettings backup;

    // Initialize curves
    Calendar calendar = TARGET();
    Date today = calendar.adjust(Date::todaysDate());
    Settings::instance().evaluationDate() = today;

    Rate h1 = 0.30, h2 = 0.40;
    DayCounter dayCounter = Actual365Fixed();

    std::vector<Date> dates(3);
    std::vector<Real> hazardRates(3);
    dates[0] = today;
    hazardRates[0] = h1;

    dates[1] = today + 5*Years;
    hazardRates[1] = h1;

    dates[2] = today + 10*Years;
    hazardRates[2] = h2;

    RelinkableHandle<DefaultProbabilityTermStructure> probabilityCurve;
    probabilityCurve.linkTo(ext::shared_ptr<DefaultProbabilityTermStructure>(
                    new InterpolatedHazardRateCurve<BackwardFlat>(dates,
                                                                  hazardRates,
                                                                  dayCounter)));

    RelinkableHandle<YieldTermStructure> discountCurve;
    discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                            new FlatForward(today,0.03,Actual360())));


    Frequency frequency = Semiannual;
    BusinessDayConvention convention = ModifiedFollowing;

    Date issueDate = calendar.advance(today, -6, Months);
    Rate fixedRate = 0.0120;
    DayCounter cdsDayCount = Actual360();
    Real notional = 10000.0;
    Real recoveryRate = 0.4;

    Rate latestRate = Null<Rate>();
    for (Integer n=6; n<=10; ++n) {

        Date maturity = calendar.advance(issueDate, n, Years);
        Schedule schedule(issueDate, maturity, Period(frequency), calendar,
                          convention, convention,
                          DateGeneration::Forward, false);

        CreditDefaultSwap cds(Protection::Seller, notional, fixedRate,
                              schedule, convention, cdsDayCount,
                              true, true);
        cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
                         new MidPointCdsEngine(probabilityCurve,
                                               recoveryRate, discountCurve)));

        Real NPV = cds.NPV();
        Rate flatRate = cds.impliedHazardRate(NPV, discountCurve,
                                              dayCounter,
                                              recoveryRate);

        if (flatRate < h1 || flatRate > h2) {
            BOOST_ERROR("implied hazard rate outside expected range\n"
                        << "    maturity: " << n << " years\n"
                        << "    expected minimum: " << h1 << "\n"
                        << "    expected maximum: " << h2 << "\n"
                        << "    implied rate:     " << flatRate);
        }

        if (n > 6 && flatRate < latestRate) {
            BOOST_ERROR("implied hazard rate decreasing with swap maturity\n"
                        << "    maturity: " << n << " years\n"
                        << "    previous rate: " << latestRate << "\n"
                        << "    implied rate:  " << flatRate);
        }

        latestRate = flatRate;

        RelinkableHandle<DefaultProbabilityTermStructure> probability;
        probability.linkTo(ext::shared_ptr<DefaultProbabilityTermStructure>(
         new FlatHazardRate(
           today,
           Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(flatRate))),
           dayCounter)));

        CreditDefaultSwap cds2(Protection::Seller, notional, fixedRate,
                               schedule, convention, cdsDayCount,
                               true, true);
        cds2.setPricingEngine(ext::shared_ptr<PricingEngine>(
                               new MidPointCdsEngine(probability,recoveryRate,
                                                     discountCurve)));

        Real NPV2 = cds2.NPV();
        Real tolerance = 1.0;
        if (std::fabs(NPV-NPV2) > tolerance) {
            BOOST_ERROR("failed to reproduce NPV with implied rate\n"
                        << "    expected:   " << NPV << "\n"
                        << "    calculated: " << NPV2);
        }
    }
}


void CreditDefaultSwapTest::testFairSpread() {

    BOOST_TEST_MESSAGE(
        "Testing fair-spread calculation for credit-default swaps...");

    SavedSettings backup;

    // Initialize curves
    Calendar calendar = TARGET();
    Date today = calendar.adjust(Date::todaysDate());
    Settings::instance().evaluationDate() = today;

    Handle<Quote> hazardRate = Handle<Quote>(
                ext::shared_ptr<Quote>(new SimpleQuote(0.01234)));
    RelinkableHandle<DefaultProbabilityTermStructure> probabilityCurve;
    probabilityCurve.linkTo(
        ext::shared_ptr<DefaultProbabilityTermStructure>(
                   new FlatHazardRate(0, calendar, hazardRate, Actual360())));

    RelinkableHandle<YieldTermStructure> discountCurve;
    discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                            new FlatForward(today,0.06,Actual360())));

    // Build the schedule
    Date issueDate = calendar.advance(today, -1, Years);
    Date maturity = calendar.advance(issueDate, 10, Years);
    BusinessDayConvention convention = Following;

    Schedule schedule =
        MakeSchedule().from(issueDate)
                      .to(maturity)
                      .withFrequency(Quarterly)
                      .withCalendar(calendar)
                      .withTerminationDateConvention(convention)
                      .withRule(DateGeneration::TwentiethIMM);

    // Build the CDS
    Rate fixedRate = 0.001;
    DayCounter dayCount = Actual360();
    Real notional = 10000.0;
    Real recoveryRate = 0.4;

    ext::shared_ptr<PricingEngine> engine(
          new MidPointCdsEngine(probabilityCurve,recoveryRate,discountCurve));

    CreditDefaultSwap cds(Protection::Seller, notional, fixedRate,
                          schedule, convention, dayCount, true, true);
    cds.setPricingEngine(engine);

    Rate fairRate = cds.fairSpread();

    CreditDefaultSwap fairCds(Protection::Seller, notional, fairRate,
                              schedule, convention, dayCount, true, true);
    fairCds.setPricingEngine(engine);

    Real fairNPV = fairCds.NPV();
    Real tolerance = 1e-9;

    if (std::fabs(fairNPV) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce null NPV with calculated fair spread\n"
            << "    calculated spread: " << io::rate(fairRate) << "\n"
            << "    calculated NPV:    " << fairNPV);
}

void CreditDefaultSwapTest::testFairUpfront() {

    BOOST_TEST_MESSAGE(
        "Testing fair-upfront calculation for credit-default swaps...");

    SavedSettings backup;

    // Initialize curves
    Calendar calendar = TARGET();
    Date today = calendar.adjust(Date::todaysDate());
    Settings::instance().evaluationDate() = today;

    Handle<Quote> hazardRate = Handle<Quote>(
                ext::shared_ptr<Quote>(new SimpleQuote(0.01234)));
    RelinkableHandle<DefaultProbabilityTermStructure> probabilityCurve;
    probabilityCurve.linkTo(
        ext::shared_ptr<DefaultProbabilityTermStructure>(
                   new FlatHazardRate(0, calendar, hazardRate, Actual360())));

    RelinkableHandle<YieldTermStructure> discountCurve;
    discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                            new FlatForward(today,0.06,Actual360())));

    // Build the schedule
    Date issueDate = today;
    Date maturity = calendar.advance(issueDate, 10, Years);
    BusinessDayConvention convention = Following;

    Schedule schedule =
        MakeSchedule().from(issueDate)
                      .to(maturity)
                      .withFrequency(Quarterly)
                      .withCalendar(calendar)
                      .withTerminationDateConvention(convention)
                      .withRule(DateGeneration::TwentiethIMM);

    // Build the CDS
    Rate fixedRate = 0.05;
    Rate upfront = 0.001;
    DayCounter dayCount = Actual360();
    Real notional = 10000.0;
    Real recoveryRate = 0.4;

    ext::shared_ptr<PricingEngine> engine(
          new MidPointCdsEngine(probabilityCurve, recoveryRate,
                                discountCurve, true));

    CreditDefaultSwap cds(Protection::Seller, notional, upfront, fixedRate,
                          schedule, convention, dayCount, true, true);
    cds.setPricingEngine(engine);

    Rate fairUpfront = cds.fairUpfront();

    CreditDefaultSwap fairCds(Protection::Seller, notional,
                              fairUpfront, fixedRate,
                              schedule, convention, dayCount, true, true);
    fairCds.setPricingEngine(engine);

    Real fairNPV = fairCds.NPV();
    Real tolerance = 1e-9;

    if (std::fabs(fairNPV) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce null NPV with calculated fair upfront\n"
            << "    calculated upfront: " << io::rate(fairUpfront) << "\n"
            << "    calculated NPV:     " << fairNPV);

    // same with null upfront to begin with
    upfront = 0.0;
    CreditDefaultSwap cds2(Protection::Seller, notional, upfront, fixedRate,
                           schedule, convention, dayCount, true, true);
    cds2.setPricingEngine(engine);

    fairUpfront = cds2.fairUpfront();

    CreditDefaultSwap fairCds2(Protection::Seller, notional,
                               fairUpfront, fixedRate,
                               schedule, convention, dayCount, true, true);
    fairCds2.setPricingEngine(engine);

    fairNPV = fairCds2.NPV();

    if (std::fabs(fairNPV) > tolerance)
        BOOST_ERROR(
            "Failed to reproduce null NPV with calculated fair upfront\n"
            << "    calculated upfront: " << io::rate(fairUpfront) << "\n"
            << "    calculated NPV:     " << fairNPV);
}

void CreditDefaultSwapTest::testIsdaEngine() {

    BOOST_TEST_MESSAGE(
        "Testing ISDA engine calculations for credit-default swaps...");

    SavedSettings backup;

    Date tradeDate(21, May, 2009);
    Settings::instance().evaluationDate() = tradeDate;


    //build an ISDA compliant yield curve
    //data comes from Markit published rates
    std::vector<ext::shared_ptr<RateHelper> > isdaRateHelpers;
    int dep_tenors[] = {1, 2, 3, 6, 9, 12};
    double dep_quotes[] = {0.003081,
                           0.005525,
                           0.007163,
                           0.012413,
                           0.014,
                           0.015488};

    for(size_t i = 0; i < sizeof(dep_tenors) / sizeof(int); i++) {
        isdaRateHelpers.push_back(ext::make_shared<DepositRateHelper>(
                                     dep_quotes[i], dep_tenors[i] * Months, 2,
                                     WeekendsOnly(), ModifiedFollowing,
                                     false, Actual360()
                                     )
            );
    }
    int swap_tenors[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 20, 25, 30};
    double swap_quotes[] = {0.011907,
                            0.01699,
                            0.021198,
                            0.02444,
                            0.026937,
                            0.028967,
                            0.030504,
                            0.031719,
                            0.03279,
                            0.034535,
                            0.036217,
                            0.036981,
                            0.037246,
                            0.037605};

    ext::shared_ptr<IborIndex> isda_ibor = ext::make_shared<IborIndex>(
        "IsdaIbor", 3 * Months, 2, USDCurrency(), WeekendsOnly(),
        ModifiedFollowing, false, Actual360());
    for(size_t i = 0; i < sizeof(swap_tenors) / sizeof(int); i++) {
        isdaRateHelpers.push_back(ext::make_shared<SwapRateHelper>(
                                      swap_quotes[i], swap_tenors[i] * Years,
                                      WeekendsOnly(),
                                      Semiannual,
                                      ModifiedFollowing, Thirty360(Thirty360::BondBasis), isda_ibor
                                      )
            );
    }

    RelinkableHandle<YieldTermStructure> discountCurve;
    discountCurve.linkTo(
            ext::make_shared<PiecewiseYieldCurve<Discount, LogLinear> >(
                0, WeekendsOnly(), isdaRateHelpers, Actual365Fixed())
        );


    RelinkableHandle<DefaultProbabilityTermStructure> probabilityCurve;
    Date termDates[] = {Date(20, June, 2010),
                        Date(20, June, 2011),
                        Date(20, June, 2012),
                        Date(20, June, 2016),
                        Date(20, June, 2019)};
    Rate spreads[] = {0.001, 0.1};
    Rate recoveries[] = {0.2, 0.4};

    double markitValues[] = {97798.29358, //0.001
                             97776.11889, //0.001
                             -914971.5977, //0.1
                             -894985.6298, //0.1
                             186921.3594, //0.001
                             186839.8148, //0.001
                             -1646623.672, //0.1
                             -1579803.626, //0.1
                             274298.9203,
                             274122.4725,
                             -2279730.93,
                             -2147972.527,
                             592420.2297,
                             591571.2294,
                             -3993550.206,
                             -3545843.418,
                             797501.1422,
                             795915.9787,
                             -4702034.688,
                             -4042340.999};
    Real tolerance;
    if (IborCoupon::usingAtParCoupons()) {
        tolerance = 1.0e-6;
    } else {
        /* The risk-free curve is a bit off. We might skip the tests
           altogether and rely on running them with indexed coupons
           disabled, but leaving them can be useful anyway. */
        tolerance = 1.0e-3;
    }

    size_t l = 0;

    for (auto termDate : termDates) {
        for (double spread : spreads) {
            for (double& recoverie : recoveries) {

                ext::shared_ptr<CreditDefaultSwap> quotedTrade =
                    MakeCreditDefaultSwap(termDate, spread).withNominal(10000000.);

                Rate h = quotedTrade->impliedHazardRate(0., discountCurve, Actual365Fixed(),
                                                        recoverie, 1e-10, CreditDefaultSwap::ISDA);

                probabilityCurve.linkTo(
                    ext::make_shared<FlatHazardRate>(0, WeekendsOnly(), h, Actual365Fixed()));

                ext::shared_ptr<IsdaCdsEngine> engine = ext::make_shared<IsdaCdsEngine>(
                    probabilityCurve, recoverie, discountCurve, boost::none, IsdaCdsEngine::Taylor,
                    IsdaCdsEngine::HalfDayBias, IsdaCdsEngine::Piecewise);

                ext::shared_ptr<CreditDefaultSwap> conventionalTrade =
                    MakeCreditDefaultSwap(termDate, 0.01)
                        .withNominal(10000000.)
                        .withPricingEngine(engine);

                BOOST_CHECK_CLOSE(conventionalTrade->notional() * conventionalTrade->fairUpfront(),
                                  markitValues[l], tolerance);

                l++;
            }
        }
    }
}

void CreditDefaultSwapTest::testAccrualRebateAmounts() {

    BOOST_TEST_MESSAGE("Testing accrual rebate amounts on credit default swaps...");

    SavedSettings backup;

    // The accrual values are taken from various test results on the ISDA CDS model website
    // https://www.cdsmodel.com/cdsmodel/documentation.html.

    // Inputs
    Real notional = 10000000;
    Real spread = 0.0100;
    Date maturity(20, Jun, 2014);

    // key is trade date and value is expected accrual
    typedef map<Date, Real> InputData;
    InputData inputs = {
        {Date(18, Mar, 2009), 24166.67},
        {Date(19, Mar, 2009), 0.00},
        {Date(20, Mar, 2009), 277.78},
        {Date(23, Mar, 2009), 1111.11},
        {Date(19, Jun, 2009), 25555.56},
        {Date(20, Jun, 2009), 25833.33},
        {Date(21, Jun, 2009), 0.00},
        {Date(22, Jun, 2009), 277.78},
        {Date(18, Jun, 2014), 25277.78},
        {Date(19, Jun, 2014), 25555.56}
    };

    for (auto& input: inputs) {
        Settings::instance().evaluationDate() = input.first;
        CreditDefaultSwap cds = MakeCreditDefaultSwap(maturity, spread)
            .withNominal(notional);
        BOOST_CHECK_SMALL(input.second - cds.accrualRebate()->amount(), 0.01);
    }
}

test_suite* CreditDefaultSwapTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Credit-default swap tests");
    suite->add(QUANTLIB_TEST_CASE(&CreditDefaultSwapTest::testCachedValue));
    suite->add(QUANTLIB_TEST_CASE(
                              &CreditDefaultSwapTest::testCachedMarketValue));
    suite->add(QUANTLIB_TEST_CASE(
                              &CreditDefaultSwapTest::testImpliedHazardRate));
    suite->add(QUANTLIB_TEST_CASE(&CreditDefaultSwapTest::testFairSpread));
    suite->add(QUANTLIB_TEST_CASE(&CreditDefaultSwapTest::testFairUpfront));
    suite->add(QUANTLIB_TEST_CASE(&CreditDefaultSwapTest::testIsdaEngine));
    suite->add(QUANTLIB_TEST_CASE(&CreditDefaultSwapTest::testAccrualRebateAmounts));
    return suite;
}
]]></document_content>
  </document>
  <document index="67">
    <source>creditdefaultswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_credit_default_swaps_hpp
#define quantlib_test_credit_default_swaps_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CreditDefaultSwapTest {
  public:
    static void testCachedValue();
    static void testCachedMarketValue();
    static void testImpliedHazardRate();
    static void testFairSpread();
    static void testFairUpfront();
    static void testIsdaEngine();
    static void testAccrualRebateAmounts();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="68">
    <source>creditriskplus.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "creditriskplus.hpp"
#include "utilities.hpp"
#include <ql/experimental/risk/creditriskplus.hpp>
#include <ql/math/comparison.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void CreditRiskPlusTest::testReferenceValues() {

    BOOST_TEST_MESSAGE(
        "Testing extended credit risk plus model against reference values...");

    static const Real tol = 1E-8; 

    /* Reference Values are taken from [1] Integrating Correlations, Risk,
       July 1999, table A, table B and figure 1 */

    std::vector<Real> sector1Exposure(1000, 1.0);
    std::vector<Real> sector1Pd(1000, 0.04);
    std::vector<Size> sector1Sector(1000, 0);

    std::vector<Real> sector2Exposure(1000, 2.0);
    std::vector<Real> sector2Pd(1000, 0.02);
    std::vector<Size> sector2Sector(1000, 1);

    std::vector<Real> exposure;
    exposure.insert(exposure.end(), sector1Exposure.begin(),
                    sector1Exposure.end());
    exposure.insert(exposure.end(), sector2Exposure.begin(),
                    sector2Exposure.end());

    std::vector<Real> pd;
    pd.insert(pd.end(), sector1Pd.begin(), sector1Pd.end());
    pd.insert(pd.end(), sector2Pd.begin(), sector2Pd.end());

    std::vector<Size> sector;
    sector.insert(sector.end(), sector1Sector.begin(), sector1Sector.end());
    sector.insert(sector.end(), sector2Sector.begin(), sector2Sector.end());

    std::vector<Real> relativeDefaultVariance;
    relativeDefaultVariance.push_back(0.75 * 0.75);
    relativeDefaultVariance.push_back(0.75 * 0.75);

    Matrix rho(2, 2);
    rho[0][0] = rho[1][1] = 1.0;
    rho[0][1] = rho[1][0] = 0.50;

    Real unit = 0.1;

    CreditRiskPlus cr(exposure, pd, sector, relativeDefaultVariance, rho, unit);

    if ( std::fabs(cr.sectorExposures()[0] - 1000.0) > tol )
        BOOST_FAIL("failed to reproduce sector 1 exposure ("
                   << cr.sectorExposures()[0] << ", should be 1000)");

    if ( std::fabs(cr.sectorExposures()[1] - 2000.0) > tol )
        BOOST_FAIL("failed to reproduce sector 2 exposure ("
                   << cr.sectorExposures()[1] << ", should be 2000)");

    if ( std::fabs(cr.sectorExpectedLoss()[0] - 40.0) > tol )
        BOOST_FAIL("failed to reproduce sector 1 expected loss ("
                   << cr.sectorExpectedLoss()[0] << ", should be 40)");

    if ( std::fabs(cr.sectorExpectedLoss()[1] - 40.0) > tol )
        BOOST_FAIL("failed to reproduce sector 2 expected loss ("
                   << cr.sectorExpectedLoss()[1] << ", should be 40)");

    if ( std::fabs(cr.sectorUnexpectedLoss()[0] - 30.7) > 0.05 )
        BOOST_FAIL("failed to reproduce sector 1 unexpected loss ("
                   << cr.sectorUnexpectedLoss()[0] << ", should be 30.7)");

    if ( std::fabs(cr.sectorUnexpectedLoss()[1] - 31.3) > 0.05 )
        BOOST_FAIL("failed to reproduce sector 2 unexpected loss ("
                   << cr.sectorUnexpectedLoss()[1] << ", should be 31.3)");

    if ( std::fabs(cr.exposure() - 3000.0) > tol )
        BOOST_FAIL("failed to reproduce overall exposure ("
                   << cr.exposure() << ", should be 3000)");

    if ( std::fabs(cr.expectedLoss() - 80.0) > tol )
        BOOST_FAIL("failed to reproduce overall expected loss ("
                   << cr.expectedLoss() << ", should be 80)");

    if ( std::fabs(cr.unexpectedLoss() - 53.1) > 0.01 )
        BOOST_FAIL("failed to reproduce overall unexpected loss ("
                   << cr.unexpectedLoss() << ", should be 53.1)");

    // the overall relative default variance in the paper seems generously rounded,
    // but since EL and UL is matching closely and the former is retrieved
    // as a simple expression in the latter, we do not suspect a problem in our
    // calculation

    if ( std::fabs(cr.relativeDefaultVariance() - 0.65 * 0.65) > 0.001 )
        BOOST_FAIL("failed to reproduce overall relative default variance ("
                   << cr.relativeDefaultVariance() << ", should be 0.4225)");

    if ( std::fabs(cr.lossQuantile(0.99) - 250) > 0.5 )
        BOOST_FAIL("failed to reproduce overall 99 percentile ("
                   << cr.lossQuantile(0.99) << ", should be 250)");
}

test_suite *CreditRiskPlusTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Credit risk plus tests");
    suite->add(QUANTLIB_TEST_CASE(&CreditRiskPlusTest::testReferenceValues));
    return suite;
}
]]></document_content>
  </document>
  <document index="69">
    <source>creditriskplus.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_creditriskplus_hpp
#define quantlib_test_creditriskplus_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CreditRiskPlusTest {
  public:
    static void testReferenceValues();
    static boost::unit_test_framework::test_suite *suite();
};

#endif
]]></document_content>
  </document>
  <document index="70">
    <source>crosscurrencyratehelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "crosscurrencyratehelpers.hpp"
#include "utilities.hpp"
#include <ql/experimental/termstructures/crosscurrencyratehelpers.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/math/interpolations/loginterpolation.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/unitedstates.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace crosscurrencyratehelpers_test {

    struct XccyTestDatum {
        Integer n;
        TimeUnit units;
        Spread basis;

        XccyTestDatum(Integer n, TimeUnit units, Spread basis) : n(n), units(units), basis(basis) {}
    };

    struct CommonVars {
        Real basisPoint;
        Real fxSpot;

        Date today, settlement;
        Calendar calendar;
        Natural settlementDays;
        Currency ccy;
        BusinessDayConvention businessConvention;
        DayCounter dayCount;
        bool endOfMonth;

        ext::shared_ptr<IborIndex> baseCcyIdx;
        ext::shared_ptr<IborIndex> quoteCcyIdx;

        RelinkableHandle<YieldTermStructure> baseCcyIdxHandle;
        RelinkableHandle<YieldTermStructure> quoteCcyIdxHandle;

        std::vector<XccyTestDatum> basisData;

        // cleanup
        SavedSettings backup;
        // utilities

        ext::shared_ptr<RateHelper>
        constantNotionalXccyRateHelper(const XccyTestDatum& q,
                                       const Handle<YieldTermStructure>& collateralHandle,
                                       bool isFxBaseCurrencyCollateralCurrency,
                                       bool isBasisOnFxBaseCurrencyLeg) const {
            Handle<Quote> quoteHandle(ext::make_shared<SimpleQuote>(q.basis * basisPoint));
            Period tenor(q.n, q.units);
            return ext::shared_ptr<CrossCurrencyBasisSwapRateHelper>(
                new CrossCurrencyBasisSwapRateHelper(
                    quoteHandle, tenor, settlementDays, calendar, businessConvention, endOfMonth,
                    baseCcyIdx, quoteCcyIdx, collateralHandle, isFxBaseCurrencyCollateralCurrency,
                    isBasisOnFxBaseCurrencyLeg));
        }

        std::vector<ext::shared_ptr<RateHelper> >
        buildConstantNotionalXccyRateHelpers(const std::vector<XccyTestDatum>& xccyData,
                                             const Handle<YieldTermStructure>& collateralHandle,
                                             bool isFxBaseCurrencyCollateralCurrency,
                                             bool isBasisOnFxBaseCurrencyLeg) const {
            std::vector<ext::shared_ptr<RateHelper> > instruments;
            instruments.reserve(xccyData.size());
            for (const auto& i : xccyData) {
                instruments.push_back(constantNotionalXccyRateHelper(
                    i, collateralHandle, isFxBaseCurrencyCollateralCurrency,
                    isBasisOnFxBaseCurrencyLeg));
            }

            return instruments;
        }

        std::vector<ext::shared_ptr<Swap> >
        buildXccyBasisSwap(const Date& start,
                           const XccyTestDatum& q,
                           Real fxSpot,
                           bool isFxBaseCurrencyCollateralCurrency,
                           bool isBasisOnFxBaseCurrencyLeg) const {
            const Real baseCcyLegNotional = 1.0;
            Real quoteCcyLegNotional = baseCcyLegNotional * fxSpot;

            Spread baseCcyLegBasis = isBasisOnFxBaseCurrencyLeg ? q.basis * basisPoint : 0.0;
            Spread quoteCcyLegBasis = isBasisOnFxBaseCurrencyLeg ? 0.0 : q.basis * basisPoint;

            std::vector<ext::shared_ptr<Swap> > legs;
            ext::shared_ptr<Swap> baseCcyLeg =
                CrossCurrencyBasisSwapRateHelper::buildCrossCurrencyLeg(
                    start, Period(q.n, q.units), settlementDays, calendar, businessConvention,
                    endOfMonth, baseCcyIdx, Swap::Receiver, baseCcyLegNotional,
                    baseCcyLegBasis);
            legs.push_back(baseCcyLeg);

            ext::shared_ptr<Swap> quoteCcyLeg =
                CrossCurrencyBasisSwapRateHelper::buildCrossCurrencyLeg(
                    start, Period(q.n, q.units), settlementDays, calendar, businessConvention,
                    endOfMonth, quoteCcyIdx, Swap::Payer, quoteCcyLegNotional,
                    quoteCcyLegBasis);
            legs.push_back(quoteCcyLeg);

            return legs;
        }

        CommonVars() {
            settlementDays = 2;
            businessConvention = Following;
            calendar = TARGET();
            dayCount = Actual365Fixed();
            endOfMonth = false;

            basisPoint = 1.0e-4;
            fxSpot = 1.25;

            baseCcyIdx = ext::shared_ptr<IborIndex>(new Euribor3M(baseCcyIdxHandle));
            quoteCcyIdx = ext::shared_ptr<IborIndex>(new USDLibor(3 * Months, quoteCcyIdxHandle));

            /* Data source:
               N. Moreni, A. Pallavicini (2015)
               FX Modelling in Collateralized Markets: foreign measures, basis curves
               and pricing formulae.

               section 4.2.1, Table 2.
            */
            basisData.emplace_back(1, Years, -14.5);
            basisData.emplace_back(18, Months, -18.5);
            basisData.emplace_back(2, Years, -20.5);
            basisData.emplace_back(3, Years, -23.75);
            basisData.emplace_back(4, Years, -25.5);
            basisData.emplace_back(5, Years, -26.5);
            basisData.emplace_back(7, Years, -26.75);
            basisData.emplace_back(10, Years, -26.25);
            basisData.emplace_back(15, Years, -24.75);
            basisData.emplace_back(20, Years, -23.25);
            basisData.emplace_back(30, Years, -20.50);

            today = calendar.adjust(Date(6, September, 2013));
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today, settlementDays, Days);

            baseCcyIdxHandle.linkTo(flatRate(settlement, 0.007, dayCount));
            quoteCcyIdxHandle.linkTo(flatRate(settlement, 0.015, dayCount));
        }
    };
}

void testConstantNotionalCrossCurrencySwapsNPV(bool isFxBaseCurrencyCollateralCurrency,
                                               bool isBasisOnFxBaseCurrencyLeg) {

    using namespace crosscurrencyratehelpers_test;

    CommonVars vars;

    Handle<YieldTermStructure> collateralHandle =
        isFxBaseCurrencyCollateralCurrency ? vars.baseCcyIdxHandle : vars.quoteCcyIdxHandle;

    ext::shared_ptr<DiscountingSwapEngine> collateralCcyLegEngine(
        new DiscountingSwapEngine(collateralHandle));

    std::vector<ext::shared_ptr<RateHelper> > instruments =
        vars.buildConstantNotionalXccyRateHelpers(vars.basisData, collateralHandle,
                                                  isFxBaseCurrencyCollateralCurrency,
                                                  isBasisOnFxBaseCurrencyLeg);
    ext::shared_ptr<YieldTermStructure> foreignCcyCurve(
        new PiecewiseYieldCurve<Discount, LogLinear>(vars.settlement, instruments, vars.dayCount));
    foreignCcyCurve->enableExtrapolation();
    Handle<YieldTermStructure> foreignCcyHandle(foreignCcyCurve);
    ext::shared_ptr<DiscountingSwapEngine> foreignCcyLegEngine(
        new DiscountingSwapEngine(foreignCcyHandle));

    Real tolerance = 1.0e-12;

    for (Size i = 0; i < vars.basisData.size(); ++i) {

        XccyTestDatum quote = vars.basisData[i];
        std::vector<ext::shared_ptr<Swap> > xccySwapProxy =
            vars.buildXccyBasisSwap(vars.today, quote, vars.fxSpot,
                                    isFxBaseCurrencyCollateralCurrency, isBasisOnFxBaseCurrencyLeg);

        if (isFxBaseCurrencyCollateralCurrency) {
            xccySwapProxy[0]->setPricingEngine(collateralCcyLegEngine);
            xccySwapProxy[1]->setPricingEngine(foreignCcyLegEngine);
        } else {
            xccySwapProxy[0]->setPricingEngine(foreignCcyLegEngine);
            xccySwapProxy[1]->setPricingEngine(collateralCcyLegEngine);
        }

        Period p = quote.n * quote.units;

        Real baseCcyLegNpv = vars.fxSpot * xccySwapProxy[0]->NPV();
        Real quoteCcyLegNpv = xccySwapProxy[1]->NPV();
        Real npv = baseCcyLegNpv + quoteCcyLegNpv;

        if (std::fabs(npv) > tolerance)
            BOOST_ERROR("unable to price the cross currency basis swap to par\n"
                        << std::setprecision(5) << "    calculated NPV:    " << npv << "\n"
                        << "    expected:    " << 0.0 << "\n"
                        << "    implied basis:    " << quote.basis << "\n"
                        << "    tenor:    " << p << "\n");
    }
}


void CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralInQuoteAndBasisInBaseCcy() {
    BOOST_TEST_MESSAGE("Testing basis swaps instruments with collateral in quote ccy and basis in base ccy...");

    bool isFxBaseCurrencyCollateralCurrency = false;
    bool isBasisOnFxBaseCurrencyLeg = true;

    testConstantNotionalCrossCurrencySwapsNPV(isFxBaseCurrencyCollateralCurrency,
                                              isBasisOnFxBaseCurrencyLeg);
}

void CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralInBaseAndBasisInQuoteCcy() {
    BOOST_TEST_MESSAGE(
        "Testing basis swaps instruments with collateral in base ccy and basis in quote ccy...");

    bool isFxBaseCurrencyCollateralCurrency = true;
    bool isBasisOnFxBaseCurrencyLeg = false;

    testConstantNotionalCrossCurrencySwapsNPV(isFxBaseCurrencyCollateralCurrency,
                                              isBasisOnFxBaseCurrencyLeg);
}

void CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralAndBasisInBaseCcy() {
    BOOST_TEST_MESSAGE(
        "Testing basis swaps instruments with collateral and basis in base ccy...");

    bool isFxBaseCurrencyCollateralCurrency = true;
    bool isBasisOnFxBaseCurrencyLeg = true;

    testConstantNotionalCrossCurrencySwapsNPV(isFxBaseCurrencyCollateralCurrency,
                                              isBasisOnFxBaseCurrencyLeg);
}

void CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralAndBasisInQuoteCcy() {
    BOOST_TEST_MESSAGE("Testing basis swaps instruments with collateral and basis in quote ccy...");

    bool isFxBaseCurrencyCollateralCurrency = false;
    bool isBasisOnFxBaseCurrencyLeg = false;

    testConstantNotionalCrossCurrencySwapsNPV(isFxBaseCurrencyCollateralCurrency,
                                              isBasisOnFxBaseCurrencyLeg);
}

test_suite* CrossCurrencyRateHelpersTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Cross currency rate helpers tests");

    suite->add(QUANTLIB_TEST_CASE(
        &CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralInQuoteAndBasisInBaseCcy));
    suite->add(QUANTLIB_TEST_CASE(
        &CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralInBaseAndBasisInQuoteCcy));
    suite->add(QUANTLIB_TEST_CASE(
        &CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralAndBasisInBaseCcy));
    suite->add(QUANTLIB_TEST_CASE(
        &CrossCurrencyRateHelpersTest::testBasisSwapsWithCollateralAndBasisInQuoteCcy));
    return suite;
}
]]></document_content>
  </document>
  <document index="71">
    <source>crosscurrencyratehelpers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_crosscurrencyratehelpers_hpp
#define quantlib_test_crosscurrencyratehelpers_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CrossCurrencyRateHelpersTest {
  public:
    static void testBasisSwapsWithCollateralInQuoteAndBasisInBaseCcy();
    static void testBasisSwapsWithCollateralInBaseAndBasisInQuoteCcy();
    static void testBasisSwapsWithCollateralAndBasisInBaseCcy();
    static void testBasisSwapsWithCollateralAndBasisInQuoteCcy();

    static boost::unit_test_framework::test_suite* suite();
};

#endif]]></document_content>
  </document>
  <document index="72">
    <source>currency.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "currency.hpp"
#include "utilities.hpp"
#include <ql/currency.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void CurrencyTest::testBespokeConstructor() {
    BOOST_TEST_MESSAGE("Testing bespoke currency constructor...");

    std::string name("Some Currency");
    std::string code("CCY");
    std::string symbol("#");

    Currency customCcy(name, code, 100, symbol, "", 100, Rounding(), "");

    if (customCcy.empty())
        BOOST_ERROR("Failed to create bespoke currency.");

    if (customCcy.name() != name)
        BOOST_ERROR("incorrect currency name\n"
                    << "    actual:    " << customCcy.name() << "\n"
                    << "    expected:    " << name << "\n");

    if (customCcy.code() != code)
        BOOST_ERROR("incorrect currency code\n"
                    << "    actual:    " << customCcy.code() << "\n"
                    << "    expected:    " << code << "\n");

    if (customCcy.symbol() != symbol)
        BOOST_ERROR("incorrect currency symbol\n"
                    << "    actual:    " << customCcy.symbol() << "\n"
                    << "    expected:    " << symbol << "\n");
}

test_suite* CurrencyTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Currency tests");

    suite->add(QUANTLIB_TEST_CASE(&CurrencyTest::testBespokeConstructor));

    return suite;
}
]]></document_content>
  </document>
  <document index="73">
    <source>currency.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_currency_hpp
#define quantlib_test_currency_hpp

#include <boost/test/unit_test.hpp>

class CurrencyTest {
  public:
    static void testBespokeConstructor();

    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="74">
    <source>curvestates.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "curvestates.hpp"
#include "utilities.hpp"
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/models/marketmodels/curvestates/cmswapcurvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/matrix.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <sstream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace curve_states_test {

    struct CommonVars {
        // global data
        Date todaysDate, startDate, endDate;
        std::vector<Time> rateTimes, paymentTimes;
        std::vector<Real> accruals;
        Calendar calendar;
        DayCounter dayCounter;
        std::vector<Rate> todaysForwards, todaysCoterminalSwapRates;
        std::vector<Real> coterminalAnnuity;
        Spread displacement;
        std::vector<DiscountFactor> todaysDiscounts;

        // cleanup
        SavedSettings backup;

        CommonVars() {
            // Times
            calendar = NullCalendar();
            todaysDate = Settings::instance().evaluationDate();
            //startDate = todaysDate + 5*Years;
            endDate = todaysDate + 10*Years;
            Schedule dates(todaysDate, endDate, Period(Semiannual),
                           calendar, Following, Following,
                           DateGeneration::Backward, false);
            rateTimes = std::vector<Time>(dates.size()-1);
            paymentTimes = std::vector<Time>(rateTimes.size()-1);
            accruals = std::vector<Real>(rateTimes.size()-1);
            dayCounter = SimpleDayCounter();
            for (Size i=1; i<dates.size(); ++i)
                rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);
            std::copy(rateTimes.begin()+1, rateTimes.end(),
                      paymentTimes.begin());
            for (Size i=1; i<rateTimes.size(); ++i)
                accruals[i-1] = rateTimes[i] - rateTimes[i-1];

            // Rates & displacement
            todaysForwards = std::vector<Rate>(paymentTimes.size());
            displacement = 0.0;
            for (Size i=0; i<todaysForwards.size(); ++i)
                todaysForwards[i] = 0.03 + 0.0010*i;

            // Discounts
            todaysDiscounts = std::vector<DiscountFactor>(rateTimes.size());
            todaysDiscounts[0] = 0.95;
            for (Size i=1; i<rateTimes.size(); ++i)
                todaysDiscounts[i] = todaysDiscounts[i-1] /
                    (1.0+todaysForwards[i-1]*accruals[i-1]);

            // Coterminal swap rates & annuities
            Size N = todaysForwards.size();
            todaysCoterminalSwapRates = std::vector<Rate>(N);
            coterminalAnnuity = std::vector<Real>(N);
            Real floatingLeg = 0.0;
            for (Size i=1; i<=N; ++i) {
                if (i==1) {
                    coterminalAnnuity[N-1] = accruals[N-1]*todaysDiscounts[N];
                } else {
                    coterminalAnnuity[N-i] = coterminalAnnuity[N-i+1] +
                        accruals[N-i]*todaysDiscounts[N-i+1];
                }
                floatingLeg = todaysDiscounts[N-i]-todaysDiscounts[N];
                todaysCoterminalSwapRates[N-i] =
                    floatingLeg/coterminalAnnuity[N-i];
            }

            std::vector<Time> evolutionTimes(rateTimes.size()-1);
            std::copy(rateTimes.begin(), rateTimes.end()-1,
                      evolutionTimes.begin());
            EvolutionDescription evolution(rateTimes,evolutionTimes);
            evolution.rateTaus();
            evolution.firstAliveRate();
        }
    };

}


void CurveStatesTest::testLMMCurveState() {

    BOOST_TEST_MESSAGE("Testing Libor-market-model curve state...");

    using namespace curve_states_test;

    CommonVars vars;
}

void CurveStatesTest::testCoterminalSwapCurveState() {

    BOOST_TEST_MESSAGE("Testing coterminal-swap-market-model curve state...");

    using namespace curve_states_test;

    CommonVars vars;
}


void CurveStatesTest::testCMSwapCurveState() {

    BOOST_TEST_MESSAGE("Testing constant-maturity-swap-market-model curve state...");

    using namespace curve_states_test;

    CommonVars vars;

    Size nbRates = vars.todaysForwards.size();
    Size factors = nbRates;
    Matrix pseudo(nbRates, factors, 0.1);
    std::vector<Spread> displacements(nbRates, .0);
    std::vector<Time> rateTimes(nbRates+1);
    std::vector<Time> taus(nbRates, .5);
    std::vector<Rate> forwards(nbRates, 0.0);

    //std::cout << "rate value:"<< std::endl;

    for (Size i = 0; i < forwards.size(); ++i)
        forwards[i] = static_cast<Rate>(i)*.001+.04;

    for (Size i = 0; i < rateTimes.size(); ++i)
        rateTimes[i] = static_cast<Time>(i+1)*.5;

    //BOOST_TEST_MESSAGE( << "Rates\nTime\tValue:"<< std::endl;)
    //for (Size i = 0; i < rateTimes.size()-1; ++i){
    //    std::cout << rateTimes[i+1] << "\t"<<io::rate(forwards[i]) << std::endl;
    //}

    Size numeraire = nbRates;
    Size alive = 0;

    Size spanningFwds = 1;

    CMSMMDriftCalculator cmsDriftcalculator(pseudo, displacements, taus,
                                            numeraire, alive, spanningFwds);

    CMSwapCurveState cmsCs(rateTimes, spanningFwds);
    cmsCs.setOnCMSwapRates(forwards);
    std::vector<Real> cmsDrifts(nbRates);
    cmsDriftcalculator.compute(cmsCs,cmsDrifts);

    LMMDriftCalculator lmmDriftcalculator(pseudo, displacements, taus,
                                          numeraire, alive);
    LMMCurveState lmmCs(rateTimes);
    lmmCs.setOnForwardRates(forwards);
    /*
    std::vector<Real> lmmDrifts(nbRates);

    std::cout << "drifts:"<< std::endl;
    std::cout << "LMM\t\tCMS"<< std::endl;
    for (Size i = 0; i<nbRates; ++i){
         std::cout << lmmDrifts[i] << "\t\t"<< cmsDrifts[i] << std::endl;
    }*/

//    const std::vector<Rate>& dfs = cs.discountRatios();
    //std::cout << "discounts ratios:"<< std::endl;
    //std::cout << "LMM\tCMS"<< std::endl;
    /*for (Size i = 0; i <nbRates; ++i){
        std::cout << lmmCs.discountRatio(i, nbRates) << "\t"<< cmsCs.discountRatio(i, nbRates) << std::endl;
    }*/
}

// --- Call the desired tests
test_suite* CurveStatesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Curve States tests");
    //suite->add(QUANTLIB_TEST_CASE(&CurveStatesTest::testLMMCurveState));
    //suite->add(QUANTLIB_TEST_CASE(&CurveStatesTest::testCoterminalSwapCurveState));
    suite->add(QUANTLIB_TEST_CASE(&CurveStatesTest::testCMSwapCurveState));
    return suite;
}
]]></document_content>
  </document>
  <document index="75">
    <source>curvestates.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_curve_states_hpp
#define quantlib_test_curve_states_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class CurveStatesTest {
  public:
    static void testLMMCurveState();
    static void testCMSwapCurveState();
    static void testCoterminalSwapCurveState();

    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="76">
    <source>dates.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2009 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2015 Maddalena Zanzi
 Copyright (c) 2015 Klaus Spanderen
 Copyright (C) 2020 Leonardo Arcari
 Copyright (C) 2020 Kline s.r.l.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "dates.hpp"
#include "utilities.hpp"
#include <ql/time/date.hpp>
#include <ql/time/timeunit.hpp>
#include <ql/time/imm.hpp>
#include <ql/time/ecb.hpp>
#include <ql/time/asx.hpp>
#include <ql/utilities/dataparsers.hpp>

#include <boost/unordered_set.hpp>
#include <boost/functional/hash.hpp>
#include <sstream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void DateTest::ecbDates() {
    BOOST_TEST_MESSAGE("Testing ECB dates...");

    std::set<Date> knownDates = ECB::knownDates();
    if (knownDates.empty())
        BOOST_FAIL("empty EBC date vector");

    Size n = ECB::nextDates(Date::minDate()).size();
    if (n != knownDates.size())
        BOOST_FAIL("nextDates(minDate) returns "  << n <<
                   " instead of " << knownDates.size() << " dates");

    std::set<Date>::const_iterator i;
    Date previousEcbDate = Date::minDate(),
         currentEcbDate, ecbDateMinusOne;
    for (i=knownDates.begin(); i!=knownDates.end(); ++i) {

        currentEcbDate = *i;
        if (!ECB::isECBdate(currentEcbDate))
            BOOST_FAIL(currentEcbDate << " fails isECBdate check");

        ecbDateMinusOne = currentEcbDate-1;
        if (ECB::isECBdate(ecbDateMinusOne))
            BOOST_FAIL(ecbDateMinusOne << " fails isECBdate check");

        if (ECB::nextDate(ecbDateMinusOne)!=currentEcbDate)
            BOOST_FAIL("next EBC date following " << ecbDateMinusOne <<
                       " must be " << currentEcbDate);

        if (ECB::nextDate(previousEcbDate)!=currentEcbDate)
            BOOST_FAIL("next EBC date following " << previousEcbDate <<
                       " must be " << currentEcbDate);

        previousEcbDate = currentEcbDate;
    }

    Date knownDate = *knownDates.begin();
    ECB::removeDate(knownDate);
    if (ECB::isECBdate(knownDate))
        BOOST_FAIL("unable to remove an EBC date");
    ECB::addDate(knownDate);
    if (!ECB::isECBdate(knownDate))
        BOOST_FAIL("unable to add an EBC date");
}

void DateTest::immDates() {
    BOOST_TEST_MESSAGE("Testing IMM dates...");

    const std::string IMMcodes[] = {
        "F0", "G0", "H0", "J0", "K0", "M0", "N0", "Q0", "U0", "V0", "X0", "Z0",
        "F1", "G1", "H1", "J1", "K1", "M1", "N1", "Q1", "U1", "V1", "X1", "Z1",
        "F2", "G2", "H2", "J2", "K2", "M2", "N2", "Q2", "U2", "V2", "X2", "Z2",
        "F3", "G3", "H3", "J3", "K3", "M3", "N3", "Q3", "U3", "V3", "X3", "Z3",
        "F4", "G4", "H4", "J4", "K4", "M4", "N4", "Q4", "U4", "V4", "X4", "Z4",
        "F5", "G5", "H5", "J5", "K5", "M5", "N5", "Q5", "U5", "V5", "X5", "Z5",
        "F6", "G6", "H6", "J6", "K6", "M6", "N6", "Q6", "U6", "V6", "X6", "Z6",
        "F7", "G7", "H7", "J7", "K7", "M7", "N7", "Q7", "U7", "V7", "X7", "Z7",
        "F8", "G8", "H8", "J8", "K8", "M8", "N8", "Q8", "U8", "V8", "X8", "Z8",
        "F9", "G9", "H9", "J9", "K9", "M9", "N9", "Q9", "U9", "V9", "X9", "Z9"
    };

    Date counter = { 1, January, 2000 };
    Date last = { 1, January, 2040 };
    Date imm;

    while (counter<=last) {
        imm = IMM::nextDate(counter, false);

        // check that imm is greater than counter
        if (imm<=counter)
            BOOST_FAIL(imm.weekday() << " " << imm
                       << " is not greater than "
                       << counter.weekday() << " " << counter);

        // check that imm is an IMM date
        if (!IMM::isIMMdate(imm, false))
            BOOST_FAIL(imm.weekday() << " " << imm
                       << " is not an IMM date (calculated from "
                       << counter.weekday() << " " << counter << ")");

        // check that imm is <= to the next IMM date in the main cycle
        if (imm>IMM::nextDate(counter, true))
            BOOST_FAIL(imm.weekday() << " " << imm
                       << " is not less than or equal to the next future in the main cycle "
                       << IMM::nextDate(counter, true));

        // check that for every date IMMdate is the inverse of IMMcode
        if (IMM::date(IMM::code(imm), counter) != imm)
            BOOST_FAIL(IMM::code(imm)
                       << " at calendar day " << counter
                       << " is not the IMM code matching " << imm);

        // check that for every date the 120 IMM codes refer to future dates
        for (int i=0; i<40; ++i) {
            if (IMM::date(IMMcodes[i], counter)<counter)
                BOOST_FAIL(IMM::date(IMMcodes[i], counter)
                           << " is wrong for " << IMMcodes[i]
                           << " at reference date " << counter);
        }

        counter = counter + 1;
    }
}

void DateTest::asxDates() {
    BOOST_TEST_MESSAGE("Testing ASX dates...");

    const std::string ASXcodes[] = {
        "F0", "G0", "H0", "J0", "K0", "M0", "N0", "Q0", "U0", "V0", "X0", "Z0",
        "F1", "G1", "H1", "J1", "K1", "M1", "N1", "Q1", "U1", "V1", "X1", "Z1",
        "F2", "G2", "H2", "J2", "K2", "M2", "N2", "Q2", "U2", "V2", "X2", "Z2",
        "F3", "G3", "H3", "J3", "K3", "M3", "N3", "Q3", "U3", "V3", "X3", "Z3",
        "F4", "G4", "H4", "J4", "K4", "M4", "N4", "Q4", "U4", "V4", "X4", "Z4",
        "F5", "G5", "H5", "J5", "K5", "M5", "N5", "Q5", "U5", "V5", "X5", "Z5",
        "F6", "G6", "H6", "J6", "K6", "M6", "N6", "Q6", "U6", "V6", "X6", "Z6",
        "F7", "G7", "H7", "J7", "K7", "M7", "N7", "Q7", "U7", "V7", "X7", "Z7",
        "F8", "G8", "H8", "J8", "K8", "M8", "N8", "Q8", "U8", "V8", "X8", "Z8",
        "F9", "G9", "H9", "J9", "K9", "M9", "N9", "Q9", "U9", "V9", "X9", "Z9"
    };

    Date counter = { 1, January, 2000 };
    Date last = { 1, January, 2040 };
    Date asx;

    while (counter <= last) {
        asx = ASX::nextDate(counter, false);

        // check that asx is greater than counter
        if (asx <= counter)
            BOOST_FAIL(asx.weekday() << " " << asx
                       << " is not greater than "
                       << counter.weekday() << " " << counter);

        // check that asx is an ASX date
        if (!ASX::isASXdate(asx, false))
            BOOST_FAIL(asx.weekday() << " " << asx
                       << " is not an ASX date (calculated from "
                       << counter.weekday() << " " << counter << ")");

        // check that asx is <= to the next ASX date in the main cycle
        if (asx>ASX::nextDate(counter, true))
            BOOST_FAIL(asx.weekday() << " " << asx
                       << " is not less than or equal to the next future in the main cycle "
                       << ASX::nextDate(counter, true));

        // check that for every date ASXdate is the inverse of ASXcode
        if (ASX::date(ASX::code(asx), counter) != asx)
            BOOST_FAIL(ASX::code(asx)
                       << " at calendar day " << counter
                       << " is not the ASX code matching " << asx);

        // check that for every date the 120 ASX codes refer to future dates
        for (const auto& ASXcode : ASXcodes) {
            if (ASX::date(ASXcode, counter) < counter)
                BOOST_FAIL(ASX::date(ASXcode, counter) << " is wrong for " << ASXcode
                           << " at reference date " << counter);
        }

        counter = counter + 1;
    }
}

void DateTest::testConsistency() {

    BOOST_TEST_MESSAGE("Testing dates...");

    Date::serial_type minDate = Date::minDate().serialNumber()+1,
                      maxDate = Date::maxDate().serialNumber();

    Date::serial_type dyold = Date(minDate-1).dayOfYear(),
                      dold  = Date(minDate-1).dayOfMonth(),
                      mold  = Date(minDate-1).month(),
                      yold  = Date(minDate-1).year(),
                      wdold = Date(minDate-1).weekday();

    for (Date::serial_type i=minDate; i<=maxDate; i++) {
        Date t(i);
        Date::serial_type serial = t.serialNumber();

        // check serial number consistency
        if (serial != i)
            BOOST_FAIL("inconsistent serial number:\n"
                       << "    original:      " << i << "\n"
                       << "    date:          " << t << "\n"
                       << "    serial number: " << serial);

        Integer dy = t.dayOfYear(),
                d  = t.dayOfMonth(),
                m  = t.month(),
                y  = t.year(),
                wd = t.weekday();

        // check if skipping any date
        if (!((dy == dyold+1) ||
              (dy == 1 && dyold == 365 && !Date::isLeap(yold)) ||
              (dy == 1 && dyold == 366 && Date::isLeap(yold))))
            BOOST_FAIL("wrong day of year increment: \n"
                       << "    date: " << t << "\n"
                       << "    day of year: " << dy << "\n"
                       << "    previous:    " << dyold);
        dyold = dy;

        if (!((d == dold+1 && m == mold   && y == yold) ||
              (d == 1      && m == mold+1 && y == yold) ||
              (d == 1      && m == 1      && y == yold+1)))
            BOOST_FAIL("wrong day,month,year increment: \n"
                       << "    date: " << t << "\n"
                       << "    day,month,year: "
                       << d << "," << Integer(m) << "," << y << "\n"
                       << "    previous:       "
                       << dold<< "," << Integer(mold) << "," << yold);
        dold = d; mold = m; yold = y;

        // check month definition
        if (m < 1 || m > 12)
            BOOST_FAIL("invalid month: \n"
                       << "    date:  " << t << "\n"
                       << "    month: " << Integer(m));

        // check day definition
        if (d < 1)
            BOOST_FAIL("invalid day of month: \n"
                       << "    date:  " << t << "\n"
                       << "    day: " << d);
        if (!((m == 1  && d <= 31) ||
              (m == 2  && d <= 28) ||
              (m == 2  && d == 29 && Date::isLeap(y)) ||
              (m == 3  && d <= 31) ||
              (m == 4  && d <= 30) ||
              (m == 5  && d <= 31) ||
              (m == 6  && d <= 30) ||
              (m == 7  && d <= 31) ||
              (m == 8  && d <= 31) ||
              (m == 9  && d <= 30) ||
              (m == 10 && d <= 31) ||
              (m == 11 && d <= 30) ||
              (m == 12 && d <= 31)))
            BOOST_FAIL("invalid day of month: \n"
                       << "    date:  " << t << "\n"
                       << "    day: " << d);

        // check weekday definition
        if (!((Integer(wd) == Integer(wdold+1)) ||
              (Integer(wd) == 1 && Integer(wdold) == 7)))
            BOOST_FAIL("invalid weekday: \n"
                       << "    date:  " << t << "\n"
                       << "    weekday:  " << Integer(wd) << "\n"
                       << "    previous: " << Integer(wdold));
        wdold = wd;

        // create the same date with a different constructor
        Date s(d,Month(m),y);
        // check serial number consistency
        serial = s.serialNumber();
        if (serial != i)
            BOOST_FAIL("inconsistent serial number:\n"
                       << "    date:          " << t << "\n"
                       << "    serial number: " << i << "\n"
                       << "    cloned date:   " <<  s << "\n"
                       << "    serial number: " << serial);
    }

}

void DateTest::isoDates() {
    BOOST_TEST_MESSAGE("Testing ISO dates...");
    std::string input_date("2006-01-15");
    Date d = DateParser::parseISO(input_date);
    if (d.dayOfMonth() != 15 ||
        d.month() != January ||
        d.year() != 2006) {
        BOOST_FAIL("Iso date failed\n"
                   << " input date:    " << input_date << "\n"
                   << " day of month:  " << d.dayOfMonth() << "\n"
                   << " month:         " << d.month() << "\n"
                   << " year:          " << d.year());
    }
}

void DateTest::parseDates() {
    BOOST_TEST_MESSAGE("Testing parsing of dates...");

    std::string input_date("2006-01-15");
    Date d = DateParser::parseFormatted(input_date, "%Y-%m-%d");
    if (d != Date(15, January, 2006)) {
        BOOST_FAIL("date parsing failed\n"
                   << " input date:  " << input_date << "\n"
                   << " parsed date: " << d);
    }

    input_date = "12/02/2012";
    d = DateParser::parseFormatted(input_date, "%m/%d/%Y");
    if (d != Date(2, December, 2012)) {
        BOOST_FAIL("date parsing failed\n"
                   << " input date:  " << input_date << "\n"
                   << " parsed date: " << d);
    }
    d = DateParser::parseFormatted(input_date, "%d/%m/%Y");
    if (d != Date(12, February, 2012)) {
        BOOST_FAIL("date parsing failed\n"
                   << " input date:  " << input_date << "\n"
                   << " parsed date: " << d);
    }

    input_date = "20011002";
    d = DateParser::parseFormatted(input_date, "%Y%m%d");
    if (d != Date(2, October, 2001)) {
        BOOST_FAIL("date parsing failed\n"
                   << " input date:  " << input_date << "\n"
                   << " parsed date: " << d);
    }
}

void DateTest::intraday() {
#ifdef QL_HIGH_RESOLUTION_DATE

    BOOST_TEST_MESSAGE("Testing intraday information of dates...");

    const Date d1 = Date(12, February, 2015, 10, 45, 12, 1234, 76253);

    BOOST_CHECK_MESSAGE(d1.year() == 2015, "failed to reproduce year");
    BOOST_CHECK_MESSAGE(d1.month() == February, "failed to reproduce month");
    BOOST_CHECK_MESSAGE(d1.dayOfMonth() == 12, "failed to reproduce day");
    BOOST_CHECK_MESSAGE(d1.hours() == 10, "failed to reproduce hour of day");
    BOOST_CHECK_MESSAGE(d1.minutes() == 45,
        "failed to reproduce minute of hour");
    BOOST_CHECK_MESSAGE(d1.seconds() == 13,
        "failed to reproduce second of minute");

    if (Date::ticksPerSecond() == 1000)
        BOOST_CHECK_MESSAGE(d1.fractionOfSecond() == 0.234,
            "failed to reproduce fraction of second");
    else if (Date::ticksPerSecond() >= 1000000)
        BOOST_CHECK_MESSAGE(d1.fractionOfSecond() == (234000 + 76253)/1000000.0,
        "failed to reproduce fraction of second");

    if (Date::ticksPerSecond() >= 1000)
        BOOST_CHECK_MESSAGE(d1.milliseconds() == 234 + 76,
            "failed to reproduce number of milliseconds");

    if (Date::ticksPerSecond() >= 1000000)
        BOOST_CHECK_MESSAGE(d1.microseconds() == 253,
            "failed to reproduce number of microseconds");

    const Date d2 = Date(28, February, 2015, 50, 165, 476, 1234, 253);
    BOOST_CHECK_MESSAGE(d2.year() == 2015, "failed to reproduce year");
    BOOST_CHECK_MESSAGE(d2.month() == March, "failed to reproduce month");
    BOOST_CHECK_MESSAGE(d2.dayOfMonth() == 2, "failed to reproduce day");
    BOOST_CHECK_MESSAGE(d2.hours() == 4, "failed to reproduce hour of day");
    BOOST_CHECK_MESSAGE(d2.minutes() == 52,
        "failed to reproduce minute of hour");
    BOOST_CHECK_MESSAGE(d2.seconds() == 57,
        "failed to reproduce second of minute");

    if (Date::ticksPerSecond() >= 1000)
        BOOST_CHECK_MESSAGE(d2.milliseconds() == 234,
            "failed to reproduce number of milliseconds");
    if (Date::ticksPerSecond() >= 1000000)
        BOOST_CHECK_MESSAGE(d2.microseconds() == 253,
            "failed to reproduce number of microseconds");

    std::ostringstream s;
    s << io::iso_datetime(Date(7, February, 2015, 1, 4, 2, 3, 4));

    BOOST_CHECK_MESSAGE(s.str() == std::string("2015-02-07T01:04:02,003004"),
        "datetime to string failed to reproduce expected result");

#endif
}

void DateTest::canHash() {
    BOOST_TEST_MESSAGE("Testing hashing of dates...");

    Date start_date = Date(1, Jan, 2020);
    int nb_tests = 500;

    boost::hash<Date> hasher;

    // Check hash values
    for (int i = 0; i < nb_tests; ++i) {
        for (int j = 0; j < nb_tests; ++j) {
            Date lhs = start_date + i;
            Date rhs = start_date + j;

            if (lhs == rhs && hasher(lhs) != hasher(rhs)) {
                BOOST_FAIL("Equal dates are expected to have same hash value\n"
                           << "rhs = " << lhs << '\n'
                           << "lhs = " << rhs << '\n'
                           << "hash(lhs) = " << hasher(lhs) << '\n'
                           << "hash(rhs) = " << hasher(rhs) << '\n');
            }

            if (lhs != rhs && hasher(lhs) == hasher(rhs)) {
                BOOST_FAIL("Different dates are expected to have different hash value\n"
                           << "rhs = " << lhs << '\n'
                           << "lhs = " << rhs << '\n'
                           << "hash(lhs) = " << hasher(lhs) << '\n'
                           << "hash(rhs) = " << hasher(rhs) << '\n');
            }
        }
    }

    // Check if Date can be used as unordered_set key
    boost::unordered_set<Date> set;
    set.insert(start_date);

    if (set.count(start_date) == 0) {
        BOOST_FAIL("Expected to find date " << start_date << " in unordered_set\n");
    }
}

test_suite* DateTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Date tests");

    suite->add(QUANTLIB_TEST_CASE(&DateTest::testConsistency));
    suite->add(QUANTLIB_TEST_CASE(&DateTest::ecbDates));
    suite->add(QUANTLIB_TEST_CASE(&DateTest::immDates));
    suite->add(QUANTLIB_TEST_CASE(&DateTest::asxDates));
    suite->add(QUANTLIB_TEST_CASE(&DateTest::isoDates));
    #ifndef QL_PATCH_SOLARIS
    suite->add(QUANTLIB_TEST_CASE(&DateTest::parseDates));
    #endif
    suite->add(QUANTLIB_TEST_CASE(&DateTest::intraday));
    suite->add(QUANTLIB_TEST_CASE(&DateTest::canHash));

    return suite;
}
]]></document_content>
  </document>
  <document index="77">
    <source>dates.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2020 Leonardo Arcari
 Copyright (C) 2020 Kline s.r.l.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_dates_hpp
#define quantlib_test_dates_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DateTest {
  public:
    static void testConsistency();
    static void ecbDates();
    static void immDates();
    static void asxDates();
    static void isoDates();
    static void parseDates();
    static void intraday();
    static void canHash();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="78">
    <source>daycounters.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2006 Piter Dias
 Copyright (C) 2012 Simon Shakeshaft
 Copyright (c) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include "daycounters.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/daycounters/one.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/time/daycounters/business252.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/thirty365.hpp>
#include <ql/time/calendars/brazil.hpp>
#include <ql/time/calendars/canada.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/schedule.hpp>
#include <cmath>
#include <iomanip>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace day_counters_test {

    struct SingleCase {
        SingleCase(ActualActual::Convention convention,
            const Date& start,
            const Date& end,
            const Date& refStart,
            const Date& refEnd,
            Time result)
            : convention(convention), start(start), end(end),
            refStart(refStart), refEnd(refEnd), result(result) {}
        SingleCase(ActualActual::Convention convention,
            const Date& start,
            const Date& end,
            Time result)
            : convention(convention), start(start), end(end),
            refStart(Date()), refEnd(Date()), result(result) {}
        ActualActual::Convention convention;
        Date start;
        Date end;
        Date refStart;
        Date refEnd;
        Time result;
    };

    struct Thirty360Case {
        Date start;
        Date end;
        Date::serial_type expected;
    };

    Time ISMAYearFractionWithReferenceDates(
        const DayCounter& dayCounter, Date start, Date end, Date refStart, Date refEnd) {
        Real referenceDayCount = Real(dayCounter.dayCount(refStart, refEnd));
        // guess how many coupon periods per year:
        auto couponsPerYear = (Integer)std::lround(365.0 / referenceDayCount);
        // the above is good enough for annual or semi annual payments.
        return Real(dayCounter.dayCount(start, end))
            / (referenceDayCount*couponsPerYear);
    }

    Time actualActualDaycountComputation(const Schedule& schedule, Date start, Date end) {

        DayCounter daycounter = ActualActual(ActualActual::ISMA, schedule);
        Time yearFraction = 0.0;

        for (Size i = 1; i < schedule.size() - 1; i++) {
            Date referenceStart = schedule.date(i);
            Date referenceEnd = schedule.date(i+1);
            if (start < referenceEnd && end > referenceStart) {
                yearFraction += ISMAYearFractionWithReferenceDates(
                    daycounter,
                    (start > referenceStart) ? start : referenceStart,
                    (end < referenceEnd) ? end : referenceEnd,
                    referenceStart,
                    referenceEnd
                );
            };
        }
        return yearFraction;
    }

}


void DayCounterTest::testActualActual() {

    BOOST_TEST_MESSAGE("Testing actual/actual day counters...");

    using namespace day_counters_test;

    SingleCase testCases[] = {
        // first example
        SingleCase(ActualActual::ISDA,
                   Date(1,November,2003), Date(1,May,2004),
                   0.497724380567),
        SingleCase(ActualActual::ISMA,
                   Date(1,November,2003), Date(1,May,2004),
                   Date(1,November,2003), Date(1,May,2004),
                   0.500000000000),
        SingleCase(ActualActual::AFB,
                   Date(1,November,2003), Date(1,May,2004),
                   0.497267759563),
        // short first calculation period (first period)
        SingleCase(ActualActual::ISDA,
                   Date(1,February,1999), Date(1,July,1999),
                   0.410958904110),
        SingleCase(ActualActual::ISMA,
                   Date(1,February,1999), Date(1,July,1999),
                   Date(1,July,1998), Date(1,July,1999),
                   0.410958904110),
        SingleCase(ActualActual::AFB,
                   Date(1,February,1999), Date(1,July,1999),
                   0.410958904110),
        // short first calculation period (second period)
        SingleCase(ActualActual::ISDA,
                   Date(1,July,1999), Date(1,July,2000),
                   1.001377348600),
        SingleCase(ActualActual::ISMA,
                   Date(1,July,1999), Date(1,July,2000),
                   Date(1,July,1999), Date(1,July,2000),
                   1.000000000000),
        SingleCase(ActualActual::AFB,
                   Date(1,July,1999), Date(1,July,2000),
                   1.000000000000),
        // long first calculation period (first period)
        SingleCase(ActualActual::ISDA,
                   Date(15,August,2002), Date(15,July,2003),
                   0.915068493151),
        SingleCase(ActualActual::ISMA,
                   Date(15,August,2002), Date(15,July,2003),
                   Date(15,January,2003), Date(15,July,2003),
                   0.915760869565),
        SingleCase(ActualActual::AFB,
                   Date(15,August,2002), Date(15,July,2003),
                   0.915068493151),
        // long first calculation period (second period)
        /* Warning: the ISDA case is in disagreement with mktc1198.pdf */
        SingleCase(ActualActual::ISDA,
                   Date(15,July,2003), Date(15,January,2004),
                   0.504004790778),
        SingleCase(ActualActual::ISMA,
                   Date(15,July,2003), Date(15,January,2004),
                   Date(15,July,2003), Date(15,January,2004),
                   0.500000000000),
        SingleCase(ActualActual::AFB,
                   Date(15,July,2003), Date(15,January,2004),
                   0.504109589041),
        // short final calculation period (penultimate period)
        SingleCase(ActualActual::ISDA,
                   Date(30,July,1999), Date(30,January,2000),
                   0.503892506924),
        SingleCase(ActualActual::ISMA,
                   Date(30,July,1999), Date(30,January,2000),
                   Date(30,July,1999), Date(30,January,2000),
                   0.500000000000),
        SingleCase(ActualActual::AFB,
                   Date(30,July,1999), Date(30,January,2000),
                   0.504109589041),
        // short final calculation period (final period)
        SingleCase(ActualActual::ISDA,
                   Date(30,January,2000), Date(30,June,2000),
                   0.415300546448),
        SingleCase(ActualActual::ISMA,
                   Date(30,January,2000), Date(30,June,2000),
                   Date(30,January,2000), Date(30,July,2000),
                   0.417582417582),
        SingleCase(ActualActual::AFB,
                   Date(30,January,2000), Date(30,June,2000),
                   0.41530054644)
    };

    Size n = sizeof(testCases)/sizeof(SingleCase);
    for (Size i=0; i<n; i++) {
        ActualActual dayCounter(testCases[i].convention);
        Date d1 = testCases[i].start,
            d2 = testCases[i].end,
            rd1 = testCases[i].refStart,
            rd2 = testCases[i].refEnd;
        Time calculated = dayCounter.yearFraction(d1,d2,rd1,rd2);

        if (std::fabs(calculated-testCases[i].result) > 1.0e-10) {
            std::ostringstream period, refPeriod;
            period << "period: " << d1 << " to " << d2;
            if (testCases[i].convention == ActualActual::ISMA)
                refPeriod << "referencePeriod: " << rd1 << " to " << rd2;
            BOOST_ERROR(dayCounter.name() << ":\n"
                       << period.str() << "\n" << refPeriod.str() << "\n"
                       << std::setprecision(10)
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << testCases[i].result);
        }
    }
}

void DayCounterTest::testActualActualIsma()
{
    BOOST_TEST_MESSAGE("Testing actual/actual (ISMA) with odd last period...");

    bool isEndOfMonth(false);
    Frequency frequency(Semiannual);
    Date interestAccrualDate(30, Jan, 1999);
    Date maturityDate(30, Jun, 2000);
    Date firstCouponDate(30, Jul, 1999);
    Date penultimateCouponDate(30, Jan, 2000);
    Date d1(30, Jan, 2000);
    Date d2(30, Jun, 2000);

    double expected(152. / (182. * 2));

    Schedule schedule = MakeSchedule()
        .from(interestAccrualDate)
        .to(maturityDate)
        .withFrequency(frequency)
        .withFirstDate(firstCouponDate)
        .withNextToLastDate(penultimateCouponDate)
        .endOfMonth(isEndOfMonth);

    DayCounter dayCounter = ActualActual(ActualActual::ISMA, schedule);

    double calculated(dayCounter.yearFraction(d1, d2));

    if (std::fabs(calculated - expected) > 1.0e-10) {
        std::ostringstream period;
        period << "period:                " << d1 << " to " << d2 << "\n"
               << "firstCouponDate:       " << firstCouponDate << "\n"
               << "penultimateCouponDate: " << penultimateCouponDate << "\n";
        BOOST_ERROR(dayCounter.name() << ":\n"
            << period.str()
            << std::setprecision(10)
            << "    calculated: " << calculated << "\n"
            << "    expected:   " << expected);
    }

    //////////////////////////////////

    isEndOfMonth = true;
    frequency = Quarterly;
    interestAccrualDate = Date(31, May, 1999);
    maturityDate = Date(30, Apr, 2000);
    firstCouponDate = Date(31, Aug, 1999);
    penultimateCouponDate = Date(30, Nov, 1999);
    d1 = Date(30, Nov, 1999);
    d2 = Date(30, Apr, 2000);

    expected = 91.0 / (91.0 * 4) + 61.0 / (92.0 * 4);

    schedule = MakeSchedule()
        .from(interestAccrualDate)
        .to(maturityDate)
        .withFrequency(frequency)
        .withFirstDate(firstCouponDate)
        .withNextToLastDate(penultimateCouponDate)
        .endOfMonth(isEndOfMonth);

    dayCounter = ActualActual(ActualActual::ISMA, schedule);

    calculated = dayCounter.yearFraction(d1, d2);

    if (std::fabs(calculated - expected) > 1.0e-10) {
        std::ostringstream period;
        period << "period:                " << d1 << " to " << d2 << "\n"
               << "firstCouponDate:       " << firstCouponDate << "\n"
               << "penultimateCouponDate: " << penultimateCouponDate << "\n";
        BOOST_ERROR(dayCounter.name() << ":\n"
            << period.str()
            << std::setprecision(10)
            << "    calculated: " << calculated << "\n"
            << "    expected:   " << expected);
    }


    //////////////////////////////////

    isEndOfMonth = false;
    frequency = Quarterly;
    interestAccrualDate = Date(31, May, 1999);
    maturityDate = Date(30, Apr, 2000);
    firstCouponDate = Date(31, Aug, 1999);
    penultimateCouponDate = Date(30, Nov, 1999);
    d1 = Date(30, Nov, 1999);
    d2 = Date(30, Apr, 2000);

    expected = 91.0 / (91.0 * 4) + 61.0 / (90.0 * 4);

    schedule = MakeSchedule()
        .from(interestAccrualDate)
        .to(maturityDate)
        .withFrequency(frequency)
        .withFirstDate(firstCouponDate)
        .withNextToLastDate(penultimateCouponDate)
        .endOfMonth(isEndOfMonth);

    dayCounter = ActualActual(ActualActual::ISMA, schedule);

    calculated = dayCounter.yearFraction(d1, d2);

    if (std::fabs(calculated - expected) > 1.0e-10) {
        std::ostringstream period;
        period << "period:                " << d1 << " to " << d2 << "\n"
               << "firstCouponDate:       " << firstCouponDate << "\n"
               << "penultimateCouponDate: " << penultimateCouponDate << "\n";
        BOOST_ERROR(dayCounter.name() << ":\n"
            << period.str()
            << std::setprecision(10)
            << "    calculated: " << calculated << "\n"
            << "    expected:   " << expected);
    }
}

void DayCounterTest::testActualActualWithSemiannualSchedule() {

    BOOST_TEST_MESSAGE("Testing actual/actual with schedule "
                       "for undefined semiannual reference periods...");

    using namespace day_counters_test;

    Calendar calendar = UnitedStates();
    Date fromDate = Date(10, January, 2017);
    Date firstCoupon = Date(31, August, 2017);
    Date quasiCoupon = Date(28, February, 2017);
    Date quasiCoupon2 = Date(31, August, 2016);

    Schedule schedule = MakeSchedule()
        .from(fromDate)
        .withFirstDate(firstCoupon)
        .to(Date(28, February, 2026))
        .withFrequency(Semiannual)
        .withCalendar(calendar)
        .withConvention(Unadjusted)
        .backwards().endOfMonth(true);

    Date testDate = schedule.date(1);
    DayCounter dayCounter = ActualActual(ActualActual::ISMA, schedule);
    DayCounter dayCounterNoSchedule = ActualActual(ActualActual::ISMA);

    Date referencePeriodStart = schedule.date(1);
    Date referencePeriodEnd = schedule.date(2);

    //Test
    QL_ASSERT(dayCounter.yearFraction(referencePeriodStart,
                                      referencePeriodStart) == 0.0,
              "This should be zero."
    );
    QL_ASSERT(dayCounterNoSchedule.yearFraction(referencePeriodStart,
                                                referencePeriodStart) == 0.0,
              "This should be zero"
    );
    QL_ASSERT(dayCounterNoSchedule.yearFraction(referencePeriodStart,
                                                referencePeriodStart,
                                                referencePeriodStart,
                                                referencePeriodStart) == 0.0,
              "This should be zero"
    );
    QL_ASSERT(dayCounter.yearFraction(referencePeriodStart,
                                      referencePeriodEnd) == 0.5,
              "This should be exact using schedule; "
              << referencePeriodStart << " to " << referencePeriodEnd
              << "Should be 0.5"
    );
    QL_ASSERT(dayCounterNoSchedule.yearFraction(referencePeriodStart,
                                                referencePeriodEnd,
                                                referencePeriodStart,
                                                referencePeriodEnd) == 0.5,
              "This should be exact for explicit reference "
              "periods with no schedule");


    while (testDate < referencePeriodEnd) {
        Time difference =
            dayCounter.yearFraction(testDate, referencePeriodEnd,
                                    referencePeriodStart, referencePeriodEnd) -
            dayCounter.yearFraction(testDate, referencePeriodEnd);
        if (std::fabs(difference) > 1.0e-10) {
            BOOST_ERROR("Failed to correctly use the schedule "
                        "to find the reference period for Act/Act");
        };
        testDate = calendar.advance(testDate, 1, Days);
    }

    //Test long first coupon
    Real calculatedYearFraction =
        dayCounter.yearFraction(fromDate, firstCoupon);
    Real expectedYearFraction =
        0.5 + ((Real) dayCounter.dayCount(fromDate, quasiCoupon))
          /(2*dayCounter.dayCount(quasiCoupon2, quasiCoupon));

    QL_ASSERT(std::fabs(calculatedYearFraction-expectedYearFraction) < 1.0e-10,
              "Failed to compute the expected year fraction "
              "\n expected:   " << expectedYearFraction <<
              "\n calculated: " << calculatedYearFraction);

    // test multiple periods

    schedule = MakeSchedule()
        .from(Date(10, January, 2017))
        .withFirstDate(Date(31, August, 2017))
        .to(Date(28, February, 2026))
        .withFrequency(Semiannual)
        .withCalendar(calendar)
        .withConvention(Unadjusted)
        .backwards().endOfMonth(false);

    Date periodStartDate = schedule.date(1);
    Date periodEndDate = schedule.date(2);

    dayCounter = ActualActual(ActualActual::ISMA, schedule);

    while (periodEndDate < schedule.date(schedule.size()-2)) {
        Time expected =
            actualActualDaycountComputation(schedule,
                                            periodStartDate,
                                            periodEndDate);
        Time calculated = dayCounter.yearFraction(periodStartDate,
                                                  periodEndDate);

        if (std::fabs(expected - calculated) > 1e-8) {
            BOOST_ERROR("Failed to compute the correct year fraction "
                        "given a schedule: " << periodStartDate <<
                        " to " << periodEndDate <<
                        "\n expected: " << expected <<
                        " calculated: " << calculated);
        }
        periodEndDate = calendar.advance(periodEndDate, 1, Days);
    }
}


void DayCounterTest::testActualActualWithAnnualSchedule(){

    BOOST_TEST_MESSAGE("Testing actual/actual with schedule "
                       "for undefined annual reference periods...");

    using namespace day_counters_test;

    // Now do an annual schedule
    Calendar calendar = UnitedStates();
    Schedule schedule = MakeSchedule()
        .from(Date(10, January, 2017))
        .withFirstDate(Date(31, August, 2017))
        .to(Date(28, February, 2026))
        .withFrequency(Annual)
        .withCalendar(calendar)
        .withConvention(Unadjusted)
        .backwards().endOfMonth(false);

    Date referencePeriodStart = schedule.date(1);
    Date referencePeriodEnd = schedule.date(2);

    Date testDate = schedule.date(1);
    DayCounter dayCounter = ActualActual(ActualActual::ISMA, schedule);

    while (testDate < referencePeriodEnd) {
        Time difference =
            ISMAYearFractionWithReferenceDates(dayCounter,
                                               testDate, referencePeriodEnd,
                                               referencePeriodStart, referencePeriodEnd) -
            dayCounter.yearFraction(testDate, referencePeriodEnd);
        if (std::fabs(difference) > 1.0e-10) {
            BOOST_ERROR("Failed to correctly use the schedule "
                        "to find the reference period for Act/Act:\n"
                        << testDate << " to " << referencePeriodEnd
                        << "\n Ref: " << referencePeriodStart
                        << " to " << referencePeriodEnd);
        }

        testDate = calendar.advance(testDate, 1, Days);
    }
}

void DayCounterTest::testActualActualWithSchedule() {

    BOOST_TEST_MESSAGE("Testing actual/actual day counter with schedule...");

    using namespace day_counters_test;

    // long first coupon
    Date issueDateExpected = Date(17, January, 2017);
    Date firstCouponDateExpected = Date(31, August, 2017);

    Schedule schedule =
        MakeSchedule()
        .from(issueDateExpected)
        .withFirstDate(firstCouponDateExpected)
        .to(Date(28, February, 2026))
        .withFrequency(Semiannual)
        .withCalendar(Canada())
        .withConvention(Unadjusted)
        .backwards()
        .endOfMonth();

    Date issueDate = schedule.date(0);
    QL_REQUIRE(issueDate == issueDateExpected,
               "This is not the expected issue date " << issueDate
               << " expected " << issueDateExpected);
    Date firstCouponDate = schedule.date(1);
    QL_REQUIRE(firstCouponDate == firstCouponDateExpected,
               "This is not the expected first coupon date " << firstCouponDate
               << " expected: " << firstCouponDateExpected);

    //Make thw quasi coupon dates:
    Date quasiCouponDate2 = schedule.calendar().advance(firstCouponDate,
        -schedule.tenor(),
        schedule.businessDayConvention(),
        schedule.endOfMonth());
    Date quasiCouponDate1 = schedule.calendar().advance(quasiCouponDate2,
        -schedule.tenor(),
        schedule.businessDayConvention(),
        schedule.endOfMonth());

    Date quasiCouponDate1Expected = Date(31, August, 2016);
    Date quasiCouponDate2Expected = Date(28, February, 2017);

    QL_REQUIRE(quasiCouponDate2 == quasiCouponDate2Expected,
               "Expected " << quasiCouponDate2Expected
               << " as the later quasi coupon date but received "
               << quasiCouponDate2);
    QL_REQUIRE(quasiCouponDate1 == quasiCouponDate1Expected,
               "Expected " << quasiCouponDate1Expected
               << " as the earlier quasi coupon date but received "
               << quasiCouponDate1);

    DayCounter dayCounter = ActualActual(ActualActual::ISMA, schedule);

    // full coupon
    Time t_with_reference = dayCounter.yearFraction(
        issueDate, firstCouponDate,
        quasiCouponDate2, firstCouponDate
    );
    Time t_no_reference = dayCounter.yearFraction(
        issueDate,
        firstCouponDate
    );
    Time t_total =
        ISMAYearFractionWithReferenceDates(dayCounter,
                                           issueDate, quasiCouponDate2,
                                           quasiCouponDate1, quasiCouponDate2)
        + 0.5;
    Time expected = 0.6160220994;


    if (std::fabs(t_total - expected) > 1.0e-10) {
        BOOST_ERROR("Failed to reproduce expected time:\n"
            << std::setprecision(10)
            << "    calculated: " << t_total << "\n"
            << "    expected:   " << expected);
    }
    if (std::fabs(t_with_reference -expected) > 1.0e-10) {
        BOOST_ERROR("Failed to reproduce expected time:\n"
                   << std::setprecision(10)
                   << "    calculated: " << t_with_reference << "\n"
                   << "    expected:   " << expected);
    }
    if (std::fabs(t_no_reference - t_with_reference) > 1.0e-10) {
        BOOST_ERROR("Should produce the same time "
                    "whether or not references are present");
    }

    // settlement date in the first quasi-period
    Date settlementDate = Date(29, January, 2017);

    t_with_reference = ISMAYearFractionWithReferenceDates(
        dayCounter,
        issueDate, settlementDate,
        quasiCouponDate1, quasiCouponDate2
    );
    t_no_reference = dayCounter.yearFraction(issueDate, settlementDate);
    Time t_expected_first_qp = 0.03314917127071823; //12.0/362
    if (std::fabs(t_with_reference - t_expected_first_qp) > 1.0e-10) {
        BOOST_ERROR("Failed to reproduce expected time:\n"
                   << std::setprecision(10)
                   << "    calculated: " << t_no_reference << "\n"
                   << "    expected:   " << t_expected_first_qp);
    }
    if (std::fabs(t_no_reference - t_with_reference) > 1.0e-10) {
        BOOST_ERROR("Should produce the same time "
                    "whether or not references are present");
    }
    Time t2 = dayCounter.yearFraction(settlementDate, firstCouponDate);
    if (std::fabs(t_expected_first_qp + t2 - expected) > 1.0e-10) {
        BOOST_ERROR("Sum of quasiperiod2 split is not consistent");
    }

    // settlement date in the second quasi-period
    settlementDate = Date(29, July, 2017);

    /*T = dayCounter.yearFraction(issueDate,
                                settlementDate,
                                quasiCouponDate2,
                                firstCouponDate);
    t1 = dayCounter.yearFraction(issueDate,
                                 quasiCouponDate2,
                                 quasiCouponDate1,
                                 quasiCouponDate2);
    Time t2 = dayCounter.yearFraction(quasiCouponDate2,
                                      settlementDate,
                                      quasiCouponDate2,
                                      firstCouponDate);*/
    t_no_reference = dayCounter.yearFraction(issueDate, settlementDate);
    t_with_reference = ISMAYearFractionWithReferenceDates(
        dayCounter,
        issueDate, quasiCouponDate2,
        quasiCouponDate1, quasiCouponDate2
    ) + ISMAYearFractionWithReferenceDates(
        dayCounter,
        quasiCouponDate2, settlementDate,
        quasiCouponDate2, firstCouponDate
    );
    if (std::fabs(t_no_reference - t_with_reference) > 1.0e-10) {
        BOOST_ERROR("These two cases should be identical");
    };
    t2 = dayCounter.yearFraction(settlementDate, firstCouponDate);


    if (std::fabs(t_total-(t_no_reference+t2)) > 1.0e-10) {
        BOOST_ERROR("Failed to reproduce expected time:\n"
                   << std::setprecision(10)
                   << "    calculated: " << t_total << "\n"
                   << "    expected:   " << t_no_reference+t2);
    }
}

void DayCounterTest::testSimple() {

    BOOST_TEST_MESSAGE("Testing simple day counter...");

    Period p[] = { Period(3,Months), Period(6,Months), Period(1,Years) };
    Time expected[] = { 0.25, 0.5, 1.0 };
    Size n = sizeof(p)/sizeof(Period);

    // 4 years should be enough
    Date first(1,January,2002), last(31,December,2005);
    DayCounter dayCounter = SimpleDayCounter();

    for (Date start = first; start <= last; start++) {
        for (Size i=0; i<n; i++) {
            Date end = start + p[i];
            Time calculated = dayCounter.yearFraction(start,end);
            if (std::fabs(calculated-expected[i]) > 1.0e-12) {
                BOOST_ERROR("from " << start << " to " << end << ":\n"
                           << std::setprecision(12)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected[i]);
            }
        }
    }
}

void DayCounterTest::testOne() {

    BOOST_TEST_MESSAGE("Testing 1/1 day counter...");

    Period p[] = { Period(3,Months), Period(6,Months), Period(1,Years) };
    Time expected[] = { 1.0, 1.0, 1.0 };
    Size n = sizeof(p)/sizeof(Period);

    // 1 years should be enough
    Date first(1,January,2004), last(31,December,2004);
    DayCounter dayCounter = OneDayCounter();

    for (Date start = first; start <= last; start++) {
        for (Size i=0; i<n; i++) {
            Date end = start + p[i];
            Time calculated = dayCounter.yearFraction(start,end);
            if (std::fabs(calculated-expected[i]) > 1.0e-12) {
                BOOST_ERROR("from " << start << " to " << end << ":\n"
                           << std::setprecision(12)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected[i]);
            }
        }
    }
}

void DayCounterTest::testBusiness252() {

    BOOST_TEST_MESSAGE("Testing business/252 day counter...");

    std::vector<Date> testDates = {
        Date(1, February, 2002),
        Date(4, February, 2002),
        Date(16, May, 2003),
        Date(17, December, 2003),
        Date(17, December, 2004),
        Date(19, December, 2005),
        Date(2, January, 2006),
        Date(13, March, 2006),
        Date(15, May, 2006),
        Date(17, March, 2006),
        Date(15, May, 2006),
        Date(26, July, 2006),
        Date(28, June, 2007),
        Date(16, September, 2009),
        Date(26, July, 2016)
    };

    Time expected[] = {
        0.0039682539683,
        1.2738095238095,
        0.6031746031746,
        0.9960317460317,
        1.0000000000000,
        0.0396825396825,
        0.1904761904762,
        0.1666666666667,
        -0.1507936507937,
        0.1507936507937,
        0.2023809523810,
        0.912698412698,
        2.214285714286,
        6.84126984127
        };

    DayCounter dayCounter1 = Business252(Brazil());

    Time calculated;

    for (Size i=1; i<testDates.size(); i++) {
        calculated = dayCounter1.yearFraction(testDates[i-1],testDates[i]);
        if (std::fabs(calculated-expected[i-1]) > 1.0e-12) {
                BOOST_ERROR("from " << testDates[i-1]
                            << " to " << testDates[i] << ":\n"
                            << std::setprecision(14)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected[i-1]);
        }
    }

    DayCounter dayCounter2 = Business252();

    for (Size i=1; i<testDates.size(); i++) {
        calculated = dayCounter2.yearFraction(testDates[i-1],testDates[i]);
        if (std::fabs(calculated-expected[i-1]) > 1.0e-12) {
                BOOST_ERROR("from " << testDates[i-1]
                            << " to " << testDates[i] << ":\n"
                            << std::setprecision(14)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected[i-1]);
        }
    }
}

void DayCounterTest::testThirty365() {

    BOOST_TEST_MESSAGE("Testing 30/365 day counter...");

    Date d1(17,June,2011), d2(30,December,2012);
    DayCounter dayCounter = Thirty365();

    BigInteger days = dayCounter.dayCount(d1,d2);
    if (days != 553) {
        BOOST_FAIL("from " << d1 << " to " << d2 << ":\n"
                   << "    calculated: " << days << "\n"
                   << "    expected:   " << 553);
    }

    Time t = dayCounter.yearFraction(d1,d2);
    Time expected = 553/365.0;
    if (std::fabs(t-expected) > 1.0e-12) {
        BOOST_FAIL("from " << d1 << " to " << d2 << ":\n"
                   << std::setprecision(12)
                   << "    calculated: " << t << "\n"
                   << "    expected:   " << expected);
    }
}

void DayCounterTest::testThirty360_BondBasis() {

    BOOST_TEST_MESSAGE("Testing 30/360 day counter (Bond Basis)...");

    // See https://www.isda.org/2008/12/22/30-360-day-count-conventions/

    DayCounter dayCounter = Thirty360(Thirty360::BondBasis);

    day_counters_test::Thirty360Case data[] = {
        // Example 1: End dates do not involve the last day of February
        {Date(20, August, 2006),    Date(20, February, 2007), 180},
        {Date(20, February, 2007),  Date(20, August, 2007),   180},
        {Date(20, August, 2007),    Date(20, February, 2008), 180},
        {Date(20, February, 2008),  Date(20, August, 2008),   180},
        {Date(20, August, 2008),    Date(20, February, 2009), 180},
        {Date(20, February, 2009),  Date(20, August, 2009),   180}, 

        // Example 2: End dates include some end-February dates
        {Date(31, August, 2006),    Date(28, February, 2007), 178},
        {Date(28, February, 2007),  Date(31, August, 2007),   183},
        {Date(31, August, 2007),    Date(29, February, 2008), 179},
        {Date(29, February, 2008),  Date(31, August, 2008),   182},
        {Date(31, August, 2008),    Date(28, February, 2009), 178},
        {Date(28, February, 2009),  Date(31, August, 2009),   183},

        // Example 3: Miscellaneous calculations
        {Date(31, January, 2006),   Date(28, February, 2006),  28},
        {Date(30, January, 2006),   Date(28, February, 2006),  28},
        {Date(28, February, 2006),  Date(3, March, 2006),       5},
        {Date(14, February, 2006),  Date(28, February, 2006),  14},
        {Date(30, September, 2006), Date(31, October, 2006),   30},
        {Date(31, October, 2006),   Date(28, November, 2006),  28},
        {Date(31, August, 2007),    Date(28, February, 2008), 178},
        {Date(28, February, 2008),  Date(28, August, 2008),   180},
        {Date(28, February, 2008),  Date(30, August, 2008),   182},
        {Date(28, February, 2008),  Date(31, August, 2008),   183},
        {Date(26, February, 2007),  Date(28, February, 2008), 362},
        {Date(26, February, 2007),  Date(29, February, 2008), 363},
        {Date(29, February, 2008),  Date(28, February, 2009), 359},
        {Date(28, February, 2008),  Date(30, March, 2008),     32},
        {Date(28, February, 2008),  Date(31, March, 2008),     33}
    };

    for (auto x : data) {
        Date::serial_type calculated = dayCounter.dayCount(x.start, x.end);
        if (calculated != x.expected) {
                BOOST_ERROR("from " << x.start
                            << " to " << x.end << ":\n"
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << x.expected);
        }
    }
}

void DayCounterTest::testThirty360_EurobondBasis() {

    BOOST_TEST_MESSAGE("Testing 30/360 day counter (Eurobond Basis)...");

    // See https://www.isda.org/2008/12/22/30-360-day-count-conventions/

    DayCounter dayCounter = Thirty360(Thirty360::EurobondBasis);

    day_counters_test::Thirty360Case data[] = {
        // Example 1: End dates do not involve the last day of February
        {Date(20, August, 2006),    Date(20, February, 2007), 180},
        {Date(20, February, 2007),  Date(20, August, 2007),   180},
        {Date(20, August, 2007),    Date(20, February, 2008), 180},
        {Date(20, February, 2008),  Date(20, August, 2008),   180},
        {Date(20, August, 2008),    Date(20, February, 2009), 180},
        {Date(20, February, 2009),  Date(20, August, 2009),   180},

        // Example 2: End dates include some end-February dates
        {Date(28, February, 2006),  Date(31, August, 2006),   182},
        {Date(31, August, 2006),    Date(28, February, 2007), 178},
        {Date(28, February, 2007),  Date(31, August, 2007),   182},
        {Date(31, August, 2007),    Date(29, February, 2008), 179},
        {Date(29, February, 2008),  Date(31, August, 2008),   181},
        {Date(31, August, 2008),    Date(28, Feb, 2009),      178},
        {Date(28, February, 2009),  Date(31, August, 2009),   182},
        {Date(31, August, 2009),    Date(28, Feb, 2010),      178},
        {Date(28, February, 2010),  Date(31, August, 2010),   182},
        {Date(31, August, 2010),    Date(28, Feb, 2011),      178},
        {Date(28, February, 2011),  Date(31, August, 2011),   182},
        {Date(31, August, 2011),    Date(29, Feb, 2012),      179},

        // Example 3: Miscellaneous calculations
        {Date(31, January, 2006),   Date(28, February, 2006),  28},
        {Date(30, January, 2006),   Date(28, February, 2006),  28},
        {Date(28, February, 2006),  Date(3, March, 2006),       5},
        {Date(14, February, 2006),  Date(28, February, 2006),  14},
        {Date(30, September, 2006), Date(31, October, 2006),   30},
        {Date(31, October, 2006),   Date(28, November, 2006),  28},
        {Date(31, August, 2007),    Date(28, February, 2008), 178},
        {Date(28, February, 2008),  Date(28, August, 2008),   180},
        {Date(28, February, 2008),  Date(30, August, 2008),   182},
        {Date(28, February, 2008),  Date(31, August, 2008),   182},
        {Date(26, February, 2007),  Date(28, February, 2008), 362},
        {Date(26, February, 2007),  Date(29, February, 2008), 363},
        {Date(29, February, 2008),  Date(28, February, 2009), 359},
        {Date(28, February, 2008),  Date(30, March, 2008),     32},
        {Date(28, February, 2008),  Date(31, March, 2008),     32}
    };

    for (auto x : data) {
        Date::serial_type calculated = dayCounter.dayCount(x.start, x.end);
        if (calculated != x.expected) {
                BOOST_ERROR("from " << x.start
                            << " to " << x.end << ":\n"
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << x.expected);
        }
    }
}


void DayCounterTest::testThirty360_ISDA() {

    BOOST_TEST_MESSAGE("Testing 30/360 day counter (ISDA)...");

    // See https://www.isda.org/2008/12/22/30-360-day-count-conventions/

    day_counters_test::Thirty360Case data1[] = {
        // Example 1: End dates do not involve the last day of February
        {Date(20, August, 2006),    Date(20, February, 2007), 180},
        {Date(20, February, 2007),  Date(20, August, 2007),   180},
        {Date(20, August, 2007),    Date(20, February, 2008), 180},
        {Date(20, February, 2008),  Date(20, August, 2008),   180},
        {Date(20, August, 2008),    Date(20, February, 2009), 180},
        {Date(20, February, 2009),  Date(20, August, 2009),   180},
    };

    Date terminationDate = Date(20, August, 2009);
    Thirty360 dayCounter(Thirty360::ISDA, terminationDate);

    for (auto x : data1) {
        Date::serial_type calculated = dayCounter.dayCount(x.start, x.end);
        if (calculated != x.expected) {
                BOOST_ERROR("from " << x.start
                            << " to " << x.end << ":\n"
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << x.expected);
        }
    }

    day_counters_test::Thirty360Case data2[] = {
        // Example 2: End dates include some end-February dates
        {Date(28, February, 2006),  Date(31, August, 2006),   180},
        {Date(31, August, 2006),    Date(28, February, 2007), 180},
        {Date(28, February, 2007),  Date(31, August, 2007),   180},
        {Date(31, August, 2007),    Date(29, February, 2008), 180},
        {Date(29, February, 2008),  Date(31, August, 2008),   180},
        {Date(31, August, 2008),    Date(28, February, 2009), 180},
        {Date(28, February, 2009),  Date(31, August, 2009),   180},
        {Date(31, August, 2009),    Date(28, February, 2010), 180},
        {Date(28, February, 2010),  Date(31, August, 2010),   180},
        {Date(31, August, 2010),    Date(28, February, 2011), 180},
        {Date(28, February, 2011),  Date(31, August, 2011),   180},
        {Date(31, August, 2011),    Date(29, February, 2012), 179},
    };

    terminationDate = Date(29, February, 2012);
    dayCounter = Thirty360(Thirty360::ISDA, terminationDate);

    for (auto x : data2) {
        Date::serial_type calculated = dayCounter.dayCount(x.start, x.end);
        if (calculated != x.expected) {
                BOOST_ERROR("from " << x.start
                            << " to " << x.end << ":\n"
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << x.expected);
        }
    }

    day_counters_test::Thirty360Case data3[] = {
        // Example 3: Miscellaneous calculations
        {Date(31, January, 2006),   Date(28, February, 2006),  30},
        {Date(30, January, 2006),   Date(28, February, 2006),  30},
        {Date(28, February, 2006),  Date(3, March, 2006),       3},
        {Date(14, February, 2006),  Date(28, February, 2006),  16},
        {Date(30, September, 2006), Date(31, October, 2006),   30},
        {Date(31, October, 2006),   Date(28, November, 2006),  28},
        {Date(31, August, 2007),    Date(28, February, 2008), 178},
        {Date(28, February, 2008),  Date(28, August, 2008),   180},
        {Date(28, February, 2008),  Date(30, August, 2008),   182},
        {Date(28, February, 2008),  Date(31, August, 2008),   182},
        {Date(28, February, 2007),  Date(28, February, 2008), 358},
        {Date(28, February, 2007),  Date(29, February, 2008), 359},
        {Date(29, February, 2008),  Date(28, February, 2009), 360},
        {Date(29, February, 2008),  Date(30, March, 2008),     30},
        {Date(29, February, 2008),  Date(31, March, 2008),     30}
    };

    terminationDate = Date(29, February, 2008);
    dayCounter = Thirty360(Thirty360::ISDA, terminationDate);

    for (auto x : data3) {
        Date::serial_type calculated = dayCounter.dayCount(x.start, x.end);
        if (calculated != x.expected) {
                BOOST_ERROR("from " << x.start
                            << " to " << x.end << ":\n"
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << x.expected);
        }
    }
}


void DayCounterTest::testActual365_Canadian() {

    BOOST_TEST_MESSAGE("Testing that Actual/365 (Canadian) throws when needed...");

    Actual365Fixed dayCounter(Actual365Fixed::Canadian);

    try {
        // no reference period
        dayCounter.yearFraction(Date(10, September, 2018),
                                Date(10, September, 2019));
        BOOST_ERROR("Invalid call to yearFraction failed to throw");
    } catch (Error&) {
        ;  // expected
    }

    try {
        // reference period shorter than a month
        dayCounter.yearFraction(Date(10, September, 2018),
                                Date(12, September, 2018),
                                Date(10, September, 2018),
                                Date(15, September, 2018));
        BOOST_ERROR("Invalid call to yearFraction failed to throw");
    } catch (Error&) {
        ;  // expected
    }
}


void DayCounterTest::testIntraday() {
#ifdef QL_HIGH_RESOLUTION_DATE

    BOOST_TEST_MESSAGE("Testing intraday behavior of day counter ...");

    const Date d1(12, February, 2015);
    const Date d2(14, February, 2015, 12, 34, 17, 1, 230298);

    const Time tol = 100*QL_EPSILON;

    const DayCounter dayCounters[]
        = { ActualActual(ActualActual::ISDA), Actual365Fixed(), Actual360() };

    for (DayCounter dc : dayCounters) {
        const Time expected = ((12*60 + 34)*60 + 17 + 0.231298)
                             * dc.yearFraction(d1, d1+1)/86400
                             + dc.yearFraction(d1, d1+2);

        BOOST_CHECK_MESSAGE(
            std::fabs(dc.yearFraction(d1, d2) - expected) < tol,
            "can not reproduce result for day counter " << dc.name());

        BOOST_CHECK_MESSAGE(
            std::fabs(dc.yearFraction(d2, d1) + expected) < tol,
            "can not reproduce result for day counter " << dc.name());
    }
#endif
}


test_suite* DayCounterTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Day counter tests");
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testActualActual));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testActualActualIsma));
    suite->add(QUANTLIB_TEST_CASE(
                    &DayCounterTest::testActualActualWithSemiannualSchedule));
    suite->add(QUANTLIB_TEST_CASE(
                        &DayCounterTest::testActualActualWithAnnualSchedule));
    suite->add(QUANTLIB_TEST_CASE(
                              &DayCounterTest::testActualActualWithSchedule));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testSimple));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testOne));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testBusiness252));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testThirty365));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testThirty360_BondBasis));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testThirty360_EurobondBasis));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testThirty360_ISDA));
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testActual365_Canadian));

#ifdef QL_HIGH_RESOLUTION_DATE
    suite->add(QUANTLIB_TEST_CASE(&DayCounterTest::testIntraday));
#endif

    return suite;
}
]]></document_content>
  </document>
  <document index="79">
    <source>daycounters.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_day_counters_hpp
#define quantlib_test_day_counters_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DayCounterTest {
   public:
    static void testActualActual();
    static void testActualActualIsma();
    static void testActualActualWithSchedule();
    static void testActualActualWithAnnualSchedule();
    static void testActualActualWithSemiannualSchedule();
    static void testSimple();
    static void testOne();
    static void testBusiness252();
    static void testThirty365();
    static void testThirty360_BondBasis();
    static void testThirty360_EurobondBasis();
    static void testThirty360_ISDA();
    static void testActual365_Canadian();
    static void testIntraday();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="80">
    <source>defaultprobabilitycurves.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "defaultprobabilitycurves.hpp"
#include "utilities.hpp"
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/interpolations/loginterpolation.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/credit/defaultprobabilityhelpers.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/termstructures/credit/piecewisedefaultcurve.hpp>
#include <ql/termstructures/yield/discountcurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/weekendsonly.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <iomanip>
#include <map>
#include <string>
#include <utility>
#include <vector>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using std::map;
using std::vector;
using std::string;

void DefaultProbabilityCurveTest::testDefaultProbability() {

    BOOST_TEST_MESSAGE("Testing default-probability structure...");

    Real hazardRate = 0.0100;
    Handle<Quote> hazardRateQuote = Handle<Quote>(
                ext::shared_ptr<Quote>(new SimpleQuote(hazardRate)));
    DayCounter dayCounter = Actual360();
    Calendar calendar = TARGET();
    Size n = 20;

    double tolerance = 1.0e-10;
    Date today = Settings::instance().evaluationDate();
    Date startDate = today;
    Date endDate = startDate;

    FlatHazardRate flatHazardRate(startDate, hazardRateQuote, dayCounter);

    for(Size i=0; i<n; i++){
        startDate = endDate;
        endDate = calendar.advance(endDate, 1, Years);

        Probability pStart = flatHazardRate.defaultProbability(startDate);
        Probability pEnd = flatHazardRate.defaultProbability(endDate);

        Probability pBetweenComputed =
            flatHazardRate.defaultProbability(startDate, endDate);

        Probability pBetween = pEnd - pStart;

        if (std::fabs(pBetween - pBetweenComputed) > tolerance)
            BOOST_ERROR(
                "Failed to reproduce probability(d1, d2) "
                << "for default probability structure\n"
                << std::setprecision(12)
                << "    calculated probability: " << pBetweenComputed << "\n"
                << "    expected probability:   " << pBetween);

        Time t2 = dayCounter.yearFraction(today, endDate);
        Probability timeProbability = flatHazardRate.defaultProbability(t2);
        Probability dateProbability =
            flatHazardRate.defaultProbability(endDate);

        if (std::fabs(timeProbability - dateProbability) > tolerance)
            BOOST_ERROR(
                "single-time probability and single-date probability do not match\n"
                << std::setprecision(10)
                << "    time probability: " << timeProbability << "\n"
                << "    date probability: " << dateProbability);

        Time t1 = dayCounter.yearFraction(today, startDate);
        timeProbability = flatHazardRate.defaultProbability(t1, t2);
        dateProbability = flatHazardRate.defaultProbability(startDate, endDate);

        if (std::fabs(timeProbability - dateProbability) > tolerance)
            BOOST_ERROR(
                "double-time probability and double-date probability do not match\n"
                << std::setprecision(10)
                << "    time probability: " << timeProbability << "\n"
                << "    date probability: " << dateProbability);
    }
}


void DefaultProbabilityCurveTest::testFlatHazardRate() {

    BOOST_TEST_MESSAGE("Testing flat hazard rate...");

    Real hazardRate = 0.0100;
    Handle<Quote> hazardRateQuote = Handle<Quote>(
                ext::shared_ptr<Quote>(new SimpleQuote(hazardRate)));
    DayCounter dayCounter = Actual360();
    Calendar calendar = TARGET();
    Size n = 20;

    double tolerance = 1.0e-10;
    Date today = Settings::instance().evaluationDate();
    Date startDate = today;
    Date endDate = startDate;

    FlatHazardRate flatHazardRate(today, hazardRateQuote, dayCounter);

    for(Size i=0; i<n; i++){
        endDate = calendar.advance(endDate, 1, Years);
        Time t = dayCounter.yearFraction(startDate, endDate);
        Probability probability = 1.0 - std::exp(-hazardRate * t);
        Probability computedProbability = flatHazardRate.defaultProbability(t);

        if (std::fabs(probability - computedProbability) > tolerance)
            BOOST_ERROR(
                "Failed to reproduce probability for flat hazard rate\n"
                << std::setprecision(10)
                << "    calculated probability: " << computedProbability << "\n"
                << "    expected probability:   " << probability);
    }
}


namespace {

    template <class T, class I>
    void testBootstrapFromSpread() {

        Calendar calendar = TARGET();

        Date today = Settings::instance().evaluationDate();

        Integer settlementDays = 1;

        std::vector<Real> quote = {0.005, 0.006, 0.007, 0.009};
        std::vector<Integer> n = {1, 2, 3, 5};

        Frequency frequency = Quarterly;
        BusinessDayConvention convention = Following;
        DateGeneration::Rule rule = DateGeneration::TwentiethIMM;
        DayCounter dayCounter = Thirty360(Thirty360::BondBasis);
        Real recoveryRate = 0.4;

        RelinkableHandle<YieldTermStructure> discountCurve;
        discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                                    new FlatForward(today,0.06,Actual360())));

        std::vector<ext::shared_ptr<DefaultProbabilityHelper> > helpers;

        for(Size i=0; i<n.size(); i++)
            helpers.push_back(
                ext::shared_ptr<DefaultProbabilityHelper>(
                    new SpreadCdsHelper(quote[i], Period(n[i], Years),
                                        settlementDays, calendar,
                                        frequency, convention, rule,
                                        dayCounter, recoveryRate,
                                        discountCurve)));

        RelinkableHandle<DefaultProbabilityTermStructure> piecewiseCurve;
        piecewiseCurve.linkTo(
            ext::shared_ptr<DefaultProbabilityTermStructure>(
                new PiecewiseDefaultCurve<T,I>(today, helpers,
                                               Thirty360(Thirty360::BondBasis))));

        Real notional = 1.0;
        double tolerance = 1.0e-6;

        // ensure apple-to-apple comparison
        SavedSettings backup;
        Settings::instance().includeTodaysCashFlows() = true;

        for (Size i=0; i<n.size(); i++) {
            Date protectionStart = today + settlementDays;
            Date startDate = calendar.adjust(protectionStart, convention);
            Date endDate = today + n[i]*Years;

            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              convention, Unadjusted, rule, false);

            CreditDefaultSwap cds(Protection::Buyer, notional, quote[i],
                                  schedule, convention, dayCounter,
                                  true, true, protectionStart);
            cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
                           new MidPointCdsEngine(piecewiseCurve, recoveryRate,
                                                 discountCurve)));

            // test
            Rate inputRate = quote[i];
            Rate computedRate = cds.fairSpread();
            if (std::fabs(inputRate - computedRate) > tolerance)
                BOOST_ERROR(
                    "\nFailed to reproduce fair spread for " << n[i] <<
                    "Y credit-default swaps\n"
                    << std::setprecision(10)
                    << "    computed rate: " << io::rate(computedRate) << "\n"
                    << "    input rate:    " << io::rate(inputRate));
        }
    }


    template <class T, class I>
    void testBootstrapFromUpfront() {

        Calendar calendar = TARGET();

        Date today = Settings::instance().evaluationDate();

        Integer settlementDays = 1;

        std::vector<Real> quote = {0.01, 0.02, 0.04, 0.06};
        std::vector<Integer> n = {2, 3, 5, 7};

        Rate fixedRate = 0.05;
        Frequency frequency = Quarterly;
        BusinessDayConvention convention = ModifiedFollowing;
        DateGeneration::Rule rule = DateGeneration::CDS;
        DayCounter dayCounter = Actual360();
        Real recoveryRate = 0.4;
        Integer upfrontSettlementDays = 3;

        RelinkableHandle<YieldTermStructure> discountCurve;
        discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                                    new FlatForward(today,0.06,Actual360())));

        std::vector<ext::shared_ptr<DefaultProbabilityHelper> > helpers;

        for(Size i=0; i<n.size(); i++)
            helpers.push_back(
                ext::shared_ptr<DefaultProbabilityHelper>(
                    new UpfrontCdsHelper(quote[i], fixedRate,
                                         Period(n[i], Years),
                                         settlementDays, calendar,
                                         frequency, convention, rule,
                                         dayCounter, recoveryRate,
                                         discountCurve,
                                         upfrontSettlementDays, 
                                         true, true, Date(), Actual360(true))));

        RelinkableHandle<DefaultProbabilityTermStructure> piecewiseCurve;
        piecewiseCurve.linkTo(
            ext::shared_ptr<DefaultProbabilityTermStructure>(
                new PiecewiseDefaultCurve<T,I>(today, helpers,
                                               Thirty360(Thirty360::BondBasis))));

        Real notional = 1.0;
        double tolerance = 1.0e-6;

        SavedSettings backup;
        // ensure apple-to-apple comparison
        Settings::instance().includeTodaysCashFlows() = true;

        for (Size i=0; i<n.size(); i++) {
            Date protectionStart = today + settlementDays;
            Date startDate = protectionStart;
            Date endDate = cdsMaturity(today, n[i] * Years, rule);
            Date upfrontDate = calendar.advance(today,
                                         upfrontSettlementDays,
                                         Days,
                                         convention);

            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              convention, Unadjusted, rule, false);

            CreditDefaultSwap cds(Protection::Buyer, notional,
                                  quote[i], fixedRate,
                                  schedule, convention, dayCounter,
                                  true, true, protectionStart,
                                  upfrontDate,
                                  ext::shared_ptr<Claim>(),
                                  Actual360(true),
                                  true, today);
            cds.setPricingEngine(ext::shared_ptr<PricingEngine>(
                           new MidPointCdsEngine(piecewiseCurve, recoveryRate,
                                                 discountCurve, true)));

            // test
            Rate inputUpfront = quote[i];
            Rate computedUpfront = cds.fairUpfront();
            if (std::fabs(inputUpfront - computedUpfront) > tolerance)
                BOOST_ERROR(
                    "\nFailed to reproduce fair upfront for " << n[i] <<
                    "Y credit-default swaps\n"
                    << std::setprecision(10)
                    << "    computed: " << io::rate(computedUpfront) << "\n"
                    << "    expected: " << io::rate(inputUpfront));
        }
    }

    // Used to check that the exception message contains the expected message string, expMsg.
    struct ExpErrorPred {

        explicit ExpErrorPred(string msg) : expMsg(std::move(msg)) {}

        bool operator()(const Error& ex) const {
            string errMsg(ex.what());
            if (errMsg.find(expMsg) == string::npos) {
                BOOST_TEST_MESSAGE("Error expected to contain: '" << expMsg << "'.");
                BOOST_TEST_MESSAGE("Actual error is: '" << errMsg << "'.");
                return false;
            } else {
                return true;
            }
        }

        string expMsg;
    };

}

void DefaultProbabilityCurveTest::testFlatHazardConsistency() {
    BOOST_TEST_MESSAGE("Testing piecewise-flat hazard-rate consistency...");
    testBootstrapFromSpread<HazardRate,BackwardFlat>();
    testBootstrapFromUpfront<HazardRate,BackwardFlat>();
}

void DefaultProbabilityCurveTest::testFlatDensityConsistency() {
    BOOST_TEST_MESSAGE("Testing piecewise-flat default-density consistency...");
    testBootstrapFromSpread<DefaultDensity,BackwardFlat>();
    testBootstrapFromUpfront<DefaultDensity,BackwardFlat>();
}

void DefaultProbabilityCurveTest::testLinearDensityConsistency() {
    BOOST_TEST_MESSAGE("Testing piecewise-linear default-density consistency...");
    testBootstrapFromSpread<DefaultDensity,Linear>();
    testBootstrapFromUpfront<DefaultDensity,Linear>();
}

void DefaultProbabilityCurveTest::testLogLinearSurvivalConsistency() {
    BOOST_TEST_MESSAGE("Testing log-linear survival-probability consistency...");
    testBootstrapFromSpread<SurvivalProbability,LogLinear>();
    testBootstrapFromUpfront<SurvivalProbability,LogLinear>();
}

void DefaultProbabilityCurveTest::testSingleInstrumentBootstrap() {
    BOOST_TEST_MESSAGE("Testing single-instrument curve bootstrap...");

    Calendar calendar = TARGET();

    Date today = Settings::instance().evaluationDate();

    Integer settlementDays = 0;

    Real quote = 0.005;
    Period tenor = 2*Years;

    Frequency frequency = Quarterly;
    BusinessDayConvention convention = Following;
    DateGeneration::Rule rule = DateGeneration::TwentiethIMM;
    DayCounter dayCounter = Thirty360(Thirty360::BondBasis);
    Real recoveryRate = 0.4;

    RelinkableHandle<YieldTermStructure> discountCurve;
    discountCurve.linkTo(ext::shared_ptr<YieldTermStructure>(
                                    new FlatForward(today,0.06,Actual360())));

    std::vector<ext::shared_ptr<DefaultProbabilityHelper> > helpers(1);

    helpers[0] = ext::shared_ptr<DefaultProbabilityHelper>(
                        new SpreadCdsHelper(quote, tenor,
                                            settlementDays, calendar,
                                            frequency, convention, rule,
                                            dayCounter, recoveryRate,
                                            discountCurve));

    PiecewiseDefaultCurve<HazardRate,BackwardFlat> defaultCurve(today, helpers,
                                                                dayCounter);
    defaultCurve.recalculate();
}

void DefaultProbabilityCurveTest::testUpfrontBootstrap() {
    BOOST_TEST_MESSAGE("Testing bootstrap on upfront quotes...");

    SavedSettings backup;
    // not taken into account, this would prevent the upfront from being used
    Settings::instance().includeTodaysCashFlows() = false;

    testBootstrapFromUpfront<HazardRate,BackwardFlat>();

    // also ensure that we didn't override the flag permanently
    boost::optional<bool> flag = Settings::instance().includeTodaysCashFlows();
    if (flag != false)
        BOOST_ERROR("Cash-flow settings improperly modified");
}

/* This test attempts to build a default curve from CDS spreads as of 1 Apr 2020. The spreads are real and from a 
   distressed reference entity with an inverted CDS spread curve. Using the default IterativeBootstrap with no 
   retries, the default curve building fails. Allowing retries, it expands the min survival probability bounds but 
   still fails. We set dontThrow to true in IterativeBootstrap to use a fall back curve.
*/
void DefaultProbabilityCurveTest::testIterativeBootstrapRetries() {

    BOOST_TEST_MESSAGE("Testing iterative bootstrap with retries...");

    SavedSettings backup;

    Date asof(1, Apr, 2020);
    Settings::instance().evaluationDate() = asof;
    Actual365Fixed tsDayCounter;

    // USD discount curve built out of FedFunds OIS swaps.
    vector<Date> usdCurveDates = {
        Date(1, Apr, 2020),
        Date(2, Apr, 2020),
        Date(14, Apr, 2020),
        Date(21, Apr, 2020),
        Date(28, Apr, 2020),
        Date(6, May, 2020),
        Date(5, Jun, 2020),
        Date(7, Jul, 2020),
        Date(5, Aug, 2020),
        Date(8, Sep, 2020),
        Date(7, Oct, 2020),
        Date(5, Nov, 2020),
        Date(7, Dec, 2020),
        Date(6, Jan, 2021),
        Date(5, Feb, 2021),
        Date(5, Mar, 2021),
        Date(7, Apr, 2021),
        Date(4, Apr, 2022),
        Date(3, Apr, 2023),
        Date(3, Apr, 2024),
        Date(3, Apr, 2025),
        Date(5, Apr, 2027),
        Date(3, Apr, 2030),
        Date(3, Apr, 2035),
        Date(3, Apr, 2040),
        Date(4, Apr, 2050)
    };

    vector<DiscountFactor> usdCurveDfs = {
        1.000000000,
        0.999955835,
        0.999931070,
        0.999914629,
        0.999902799,
        0.999887990,
        0.999825782,
        0.999764392,
        0.999709076,
        0.999647785,
        0.999594638,
        0.999536198,
        0.999483093,
        0.999419291,
        0.999379417,
        0.999324981,
        0.999262356,
        0.999575101,
        0.996135441,
        0.995228348,
        0.989366687,
        0.979271200,
        0.961150726,
        0.926265361,
        0.891640651,
        0.839314063
    };

    Handle<YieldTermStructure> usdYts(ext::make_shared<InterpolatedDiscountCurve<LogLinear> >(
        usdCurveDates, usdCurveDfs, tsDayCounter));

    // CDS spreads
    map<Period, Rate> cdsSpreads = {
        {6 * Months, 2.957980250},
        {1 * Years, 3.076933100},
        {2 * Years, 2.944524520},
        {3 * Years, 2.844498960},
        {4 * Years, 2.769234420},
        {5 * Years, 2.713474100}
    };
    Real recoveryRate = 0.035;

    // Conventions
    Integer settlementDays = 1;
    WeekendsOnly calendar;
    Frequency frequency = Quarterly;
    BusinessDayConvention paymentConvention = Following;
    DateGeneration::Rule rule = DateGeneration::CDS2015;
    Actual360 dayCounter;
    Actual360 lastPeriodDayCounter(true);

    // Create the CDS spread helpers.
    vector<ext::shared_ptr<DefaultProbabilityHelper> > instruments;
    for (map<Period, Rate>::const_iterator it = cdsSpreads.begin(); it != cdsSpreads.end(); ++it) {
        instruments.push_back(ext::shared_ptr<SpreadCdsHelper>(
            new SpreadCdsHelper(it->second, it->first, settlementDays, calendar,
                                frequency, paymentConvention, rule, dayCounter, recoveryRate, usdYts, true, true, Date(),
                                lastPeriodDayCounter)));
    }

    // Create the default curve with the default IterativeBootstrap.
    typedef PiecewiseDefaultCurve<SurvivalProbability, LogLinear, IterativeBootstrap> SPCurve;
    ext::shared_ptr<DefaultProbabilityTermStructure> dpts = ext::make_shared<SPCurve>(asof, instruments, tsDayCounter);

    // Check that the default curve throws by requesting a default probability.
    Date testDate(21, Dec, 2020);
    BOOST_CHECK_EXCEPTION(dpts->survivalProbability(testDate), Error,
        ExpErrorPred("1st iteration: failed at 1st alive instrument"));

    // Create the default curve with an IterativeBootstrap allowing for 4 retries.
    // Use a maxFactor value of 1.0 so that we still use the previous survival probability at each pillar. In other
    // words, the survival probability cannot increase with time so best max at current pillar is the previous 
    // pillar's value - there is no point increasing it on a retry.
    IterativeBootstrap<SPCurve> ib(Null<Real>(), Null<Real>(), Null<Real>(), 5, 1.0, 10.0);
    dpts = ext::make_shared<SPCurve>(asof, instruments, tsDayCounter, ib);

    // Check that the default curve still throws. It throws at the third pillar because the survival probability is 
    // too low at the second pillar.
    BOOST_CHECK_EXCEPTION(dpts->survivalProbability(testDate), Error,
        ExpErrorPred("1st iteration: failed at 3rd alive instrument"));

    // Create the default curve with an IterativeBootstrap that allows for 4 retries and does not throw.
    IterativeBootstrap<SPCurve> ibNoThrow(Null<Real>(), Null<Real>(), Null<Real>(), 5, 1.0, 10.0, true, 2);
    dpts = ext::make_shared<SPCurve>(asof, instruments, tsDayCounter, ibNoThrow);
    BOOST_CHECK_NO_THROW(dpts->survivalProbability(testDate));
}


test_suite* DefaultProbabilityCurveTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Default-probability curve tests");
    suite->add(QUANTLIB_TEST_CASE(
                       &DefaultProbabilityCurveTest::testDefaultProbability));
    suite->add(QUANTLIB_TEST_CASE(
                           &DefaultProbabilityCurveTest::testFlatHazardRate));
    suite->add(QUANTLIB_TEST_CASE(
                    &DefaultProbabilityCurveTest::testFlatHazardConsistency));
    suite->add(QUANTLIB_TEST_CASE(
                   &DefaultProbabilityCurveTest::testFlatDensityConsistency));
    suite->add(QUANTLIB_TEST_CASE(
                 &DefaultProbabilityCurveTest::testLinearDensityConsistency));
    suite->add(QUANTLIB_TEST_CASE(
             &DefaultProbabilityCurveTest::testLogLinearSurvivalConsistency));
    suite->add(QUANTLIB_TEST_CASE(
                &DefaultProbabilityCurveTest::testSingleInstrumentBootstrap));
    suite->add(QUANTLIB_TEST_CASE(
                         &DefaultProbabilityCurveTest::testUpfrontBootstrap));
    suite->add(QUANTLIB_TEST_CASE(
                &DefaultProbabilityCurveTest::testIterativeBootstrapRetries));
    return suite;
}
]]></document_content>
  </document>
  <document index="81">
    <source>defaultprobabilitycurves.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_default_curves_hpp
#define quantlib_test_default_curves_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DefaultProbabilityCurveTest {
  public:
    static void testDefaultProbability();
    static void testFlatHazardRate();
    static void testFlatHazardConsistency();
    static void testFlatDensityConsistency();
    static void testLinearDensityConsistency();
    static void testLogLinearSurvivalConsistency();
    static void testSingleInstrumentBootstrap();
    static void testUpfrontBootstrap();
    static void testIterativeBootstrapRetries();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="82">
    <source>digitalcoupon.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_digitalcoupon_hpp
#define quantlib_test_digitalcoupon_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DigitalCouponTest {
  public:
    static void testAssetOrNothing();
    static void testAssetOrNothingDeepInTheMoney();
    static void testAssetOrNothingDeepOutTheMoney();
    static void testCashOrNothing();
    static void testCashOrNothingDeepInTheMoney();
    static void testCashOrNothingDeepOutTheMoney();
    static void testCallPutParity();
    static void testReplicationType();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="83">
    <source>digitaloption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "digitaloption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticdigitalamericanengine.hpp>
#include <ql/pricingengines/vanilla/mcdigitalengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, \
                       v, expected, calculated, error, tolerance, knockin) \
    BOOST_FAIL(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:       " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance << "\n" \
               << "    knock_in:         " << knockin);

namespace {

    struct DigitalOptionData {
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // expected result
        Real tol;      // tolerance
        bool knockin;  // true if knock-in
    };

}


void DigitalOptionTest::testCashOrNothingEuropeanValues() {

    BOOST_TEST_MESSAGE("Testing European cash-or-nothing digital option...");

    DigitalOptionData values[] = {
        // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 88
        //        type, strike,  spot,    q,    r,    t,  vol,  value, tol
        { Option::Put,   80.00, 100.0, 0.06, 0.06, 0.75, 0.35, 2.6710, 1e-4, true }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new CashOrNothingPayoff(value.type, value.strike, 10.0));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                                    new AnalyticEuropeanEngine(stochProcess));

        VanillaOption opt(payoff, exercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testAssetOrNothingEuropeanValues() {

    BOOST_TEST_MESSAGE("Testing European asset-or-nothing digital option...");

    // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 90
    DigitalOptionData values[] = {
        //        type, strike, spot,    q,    r,    t,  vol,   value, tol
        { Option::Put,   65.00, 70.0, 0.05, 0.07, 0.50, 0.27, 20.2069, 1e-4, true }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new AssetOrNothingPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                                    new AnalyticEuropeanEngine(stochProcess));

        VanillaOption opt(payoff, exercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testGapEuropeanValues() {

    BOOST_TEST_MESSAGE("Testing European gap digital option...");

    // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 88
    DigitalOptionData values[] = {
        //        type, strike, spot,    q,    r,    t,  vol,   value, tol
        { Option::Call,  50.00, 50.0, 0.00, 0.09, 0.50, 0.20, -0.0053, 1e-4, true }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new GapPayoff(value.type, value.strike, 57.00));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                                    new AnalyticEuropeanEngine(stochProcess));

        VanillaOption opt(payoff, exercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testCashAtHitOrNothingAmericanValues() {

    BOOST_TEST_MESSAGE("Testing American cash-(at-hit)-or-nothing "
                       "digital option...");

    DigitalOptionData values[] = {
        //        type, strike,   spot,    q,    r,   t,  vol,   value, tol
        // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 95, case 1,2
        { Option::Put,  100.00, 105.00, 0.00, 0.10, 0.5, 0.20,  9.7264, 1e-4,  true},
        { Option::Call, 100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 11.6553, 1e-4,  true},

        // the following cases are not taken from a reference paper or book
        // in the money options (guaranteed immediate payoff)
        { Option::Call, 100.00, 105.00, 0.00, 0.10, 0.5, 0.20, 15.0000, 1e-16, true},
        { Option::Put,  100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 15.0000, 1e-16, true},
        // non null dividend (cross-tested with MC simulation)
        { Option::Put,  100.00, 105.00, 0.20, 0.10, 0.5, 0.20, 12.2715, 1e-4,  true},
        { Option::Call, 100.00,  95.00, 0.20, 0.10, 0.5, 0.20,  8.9109, 1e-4,  true},
        { Option::Call, 100.00, 105.00, 0.20, 0.10, 0.5, 0.20, 15.0000, 1e-16, true},
        { Option::Put,  100.00,  95.00, 0.20, 0.10, 0.5, 0.20, 15.0000, 1e-16, true}
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new CashOrNothingPayoff(value.type, value.strike, 15.00));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                    exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                             new AnalyticDigitalAmericanEngine(stochProcess));

        VanillaOption opt(payoff, amExercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testAssetAtHitOrNothingAmericanValues() {

    BOOST_TEST_MESSAGE("Testing American asset-(at-hit)-or-nothing "
                       "digital option...");

    DigitalOptionData values[] = {
        //        type, strike,   spot,    q,    r,   t,  vol,   value, tol
        // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 95, case 3,4
        { Option::Put,  100.00, 105.00, 0.00, 0.10, 0.5, 0.20, 64.8426, 1e-04, true }, // Haug value is wrong here, Haug VBA code is right
        { Option::Call, 100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 77.7017, 1e-04, true }, // Haug value is wrong here, Haug VBA code is right
        // data from Haug VBA code results
        { Option::Put,  100.00, 105.00, 0.01, 0.10, 0.5, 0.20, 65.7811, 1e-04, true },
        { Option::Call, 100.00,  95.00, 0.01, 0.10, 0.5, 0.20, 76.8858, 1e-04, true },
        // in the money options  (guaranteed immediate payoff = spot)
        { Option::Call, 100.00, 105.00, 0.00, 0.10, 0.5, 0.20,105.0000, 1e-16, true },
        { Option::Put,  100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 95.0000, 1e-16, true },
        { Option::Call, 100.00, 105.00, 0.01, 0.10, 0.5, 0.20,105.0000, 1e-16, true },
        { Option::Put,  100.00,  95.00, 0.01, 0.10, 0.5, 0.20, 95.0000, 1e-16, true }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.25));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new AssetOrNothingPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                    exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine(
                             new AnalyticDigitalAmericanEngine(stochProcess));

        VanillaOption opt(payoff, amExercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testCashAtExpiryOrNothingAmericanValues() {

    BOOST_TEST_MESSAGE("Testing American cash-(at-expiry)-or-nothing "
                       "digital option...");

    DigitalOptionData values[] = {
        //        type, strike,   spot,    q,    r,   t,  vol,   value, tol
        // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 95, case 5,6,9,10
        { Option::Put,  100.00, 105.00, 0.00, 0.10, 0.5, 0.20,  9.3604, 1e-4, true },
        { Option::Call, 100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 11.2223, 1e-4, true },
        { Option::Put,  100.00, 105.00, 0.00, 0.10, 0.5, 0.20,  4.9081, 1e-4, false },
        { Option::Call, 100.00,  95.00, 0.00, 0.10, 0.5, 0.20,  3.0461, 1e-4, false },
        // in the money options (guaranteed discounted payoff)
        { Option::Call, 100.00, 105.00, 0.00, 0.10, 0.5, 0.20, 15.0000*std::exp(-0.05), 1e-12, true },
        { Option::Put,  100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 15.0000*std::exp(-0.05), 1e-12, true },
        // out of bonds case
        { Option::Call,   2.37,   2.33, 0.07, 0.43,0.19,0.005,  0.0000, 1e-4, false },
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.25));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new CashOrNothingPayoff(value.type, value.strike, 15.0));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                    exDate,
                                                                    true));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine;
        if (value.knockin)
            engine.reset(new AnalyticDigitalAmericanEngine(stochProcess));
        else
           engine.reset(new AnalyticDigitalAmericanKOEngine(stochProcess));

        VanillaOption opt(payoff, amExercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testAssetAtExpiryOrNothingAmericanValues() {

    BOOST_TEST_MESSAGE("Testing American asset-(at-expiry)-or-nothing "
                       "digital option...");

    DigitalOptionData values[] = {
        //        type, strike,   spot,    q,    r,   t,  vol,   value, tol
        // "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 - pag 95, case 7,8,11,12
        { Option::Put,  100.00, 105.00, 0.00, 0.10, 0.5, 0.20, 64.8426, 1e-04, true },
        { Option::Call, 100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 77.7017, 1e-04, true },
        { Option::Put,  100.00, 105.00, 0.00, 0.10, 0.5, 0.20, 40.1574, 1e-04, false },
        { Option::Call, 100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 17.2983, 1e-04, false },
        // data from Haug VBA code results
        { Option::Put,  100.00, 105.00, 0.01, 0.10, 0.5, 0.20, 65.5291, 1e-04, true },
        { Option::Call, 100.00,  95.00, 0.01, 0.10, 0.5, 0.20, 76.5951, 1e-04, true },
        // in the money options (guaranteed discounted payoff = forward * riskFreeDiscount
        //                                                    = spot * dividendDiscount)
        { Option::Call, 100.00, 105.00, 0.00, 0.10, 0.5, 0.20,105.0000, 1e-12, true },
        { Option::Put,  100.00,  95.00, 0.00, 0.10, 0.5, 0.20, 95.0000, 1e-12, true },
        { Option::Call, 100.00, 105.00, 0.01, 0.10, 0.5, 0.20,105.0000*std::exp(-0.005), 1e-12, true },
        { Option::Put,  100.00,  95.00, 0.01, 0.10, 0.5, 0.20, 95.0000*std::exp(-0.005), 1e-12, true }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.25));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new AssetOrNothingPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                    exDate,
                                                                    true));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
        ext::shared_ptr<PricingEngine> engine;
        if (value.knockin)
            engine.reset(new AnalyticDigitalAmericanEngine(stochProcess));
        else
           engine.reset(new AnalyticDigitalAmericanKOEngine(stochProcess));

        VanillaOption opt(payoff, amExercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}

void DigitalOptionTest::testCashAtHitOrNothingAmericanGreeks() {

    BOOST_TEST_MESSAGE("Testing American cash-(at-hit)-or-nothing "
                       "digital option greeks...");

    SavedSettings backup;

    std::map<std::string,Real> calculated, expected, tolerance;
    tolerance["delta"]  = 5.0e-5;
    tolerance["gamma"]  = 5.0e-5;
    // tolerance["theta"]  = 5.0e-5;
    tolerance["rho"]    = 5.0e-5;
    // tolerance["divRho"] = 5.0e-5;
    // tolerance["vega"]   = 5.0e-5;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.5, 150.0 };
    Real cashPayoff = 100.0;
    Real underlyings[] = { 100 };
    Rate qRates[] = { 0.04, 0.05, 0.06 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Volatility vols[] = { 0.11, 0.5, 1.2 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    // there is no cycling on different residual times
    Date exDate = today + 360;
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
    ext::shared_ptr<Exercise> amExercise(new AmericanExercise(today,
                                                                exDate,
                                                                false));
    ext::shared_ptr<Exercise> exercises[] = { exercise, amExercise };

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          qTS, rTS, volTS));

    ext::shared_ptr<PricingEngine> euroEngine(
                                    new AnalyticEuropeanEngine(stochProcess));

    ext::shared_ptr<PricingEngine> amEngine(
                             new AnalyticDigitalAmericanEngine(stochProcess));

    ext::shared_ptr<PricingEngine> engines[] = { euroEngine, amEngine };

    bool knockin=true;
    for (Size j=0; j<LENGTH(engines); j++) {
        for (auto& type : types) {
            for (double strike : strikes) {
                ext::shared_ptr<StrikedTypePayoff> payoff(
                    new CashOrNothingPayoff(type, strike, cashPayoff));

                VanillaOption opt(payoff, exercises[j]);
                opt.setPricingEngine(engines[j]);

                for (double u : underlyings) {
                    for (double q : qRates) {
                        for (double r : rRates) {
                            for (double v : vols) {
                                // test data
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);

                                // theta, dividend rho and vega are not available for
                                // digital option with american exercise. Greeks of
                                // digital options with european payoff are tested
                                // in the europeanoption.cpp test
                                Real value = opt.NPV();
                                calculated["delta"] = opt.delta();
                                calculated["gamma"] = opt.gamma();
                                // calculated["theta"]  = opt.theta();
                                calculated["rho"] = opt.rho();
                                // calculated["divRho"] = opt.dividendRho();
                                // calculated["vega"]   = opt.vega();

                                if (value > 1.0e-6) {
                                    // perturb spot and get delta and gamma
                                    Real du = u * 1.0e-4;
                                    spot->setValue(u + du);
                                    Real value_p = opt.NPV(), delta_p = opt.delta();
                                    spot->setValue(u - du);
                                    Real value_m = opt.NPV(), delta_m = opt.delta();
                                    spot->setValue(u);
                                    expected["delta"] = (value_p - value_m) / (2 * du);
                                    expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                    // perturb rates and get rho and dividend rho
                                    Spread dr = r * 1.0e-4;
                                    rRate->setValue(r + dr);
                                    value_p = opt.NPV();
                                    rRate->setValue(r - dr);
                                    value_m = opt.NPV();
                                    rRate->setValue(r);
                                    expected["rho"] = (value_p - value_m) / (2 * dr);

                                    /*
                                    Spread dq = q*1.0e-4;
                                    qRate->setValue(q+dq);
                                    value_p = opt.NPV();
                                    qRate->setValue(q-dq);
                                    value_m = opt.NPV();
                                    qRate->setValue(q);
                                    expected["divRho"] = (value_p - value_m)/(2*dq);

                                    // perturb volatility and get vega
                                    Volatility dv = v*1.0e-4;
                                    vol->setValue(v+dv);
                                    value_p = opt.NPV();
                                    vol->setValue(v-dv);
                                    value_m = opt.NPV();
                                    vol->setValue(v);
                                    expected["vega"] = (value_p - value_m)/(2*dv);

                                    // perturb date and get theta
                                    Time dT = dc.yearFraction(today-1, today+1);
                                    Settings::instance().setEvaluationDate(today-1);
                                    value_m = opt.NPV();
                                    Settings::instance().setEvaluationDate(today+1);
                                    value_p = opt.NPV();
                                    Settings::instance().setEvaluationDate(today);
                                    expected["theta"] = (value_p - value_m)/dT;
                                    */

                                    // check
                                    std::map<std::string, Real>::iterator it;
                                    for (it = calculated.begin(); it != calculated.end(); ++it) {
                                        std::string greek = it->first;
                                        Real expct = expected[greek], calcl = calculated[greek],
                                             tol = tolerance[greek];
                                        Real error = relativeError(expct, calcl, value);
                                        if (error > tol) {
                                            REPORT_FAILURE(greek, payoff, exercise, u, q, r, today,
                                                           v, expct, calcl, error, tol, knockin);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


void DigitalOptionTest::testMCCashAtHit() {

    BOOST_TEST_MESSAGE("Testing Monte Carlo cash-(at-hit)-or-nothing "
                       "American engine...");

    SavedSettings backup;

    DigitalOptionData values[] = {
        //        type, strike,   spot,    q,    r,   t,  vol,   value, tol
        { Option::Put,  100.00, 105.00, 0.20, 0.10, 0.5, 0.20, 12.2715, 1e-2, true },
        { Option::Call, 100.00,  95.00, 0.20, 0.10, 0.5, 0.20,  8.9109, 1e-2, true }
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Size timeStepsPerYear = 90;
    Size maxSamples = 1000000;
    BigNatural seed = 1;

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new CashOrNothingPayoff(value.type, value.strike, 15.0));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> amExercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        Size requiredSamples = Size(std::pow(2.0, 14)-1);
        ext::shared_ptr<PricingEngine> mcldEngine =
            MakeMCDigitalEngine<LowDiscrepancy>(stochProcess)
            .withStepsPerYear(timeStepsPerYear)
            .withBrownianBridge()
            .withSamples(requiredSamples)
            .withMaxSamples(maxSamples)
            .withSeed(seed);

        VanillaOption opt(payoff, amExercise);
        opt.setPricingEngine(mcldEngine);

        Real calculated = opt.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, amExercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol, value.knockin);
        }
    }
}


test_suite* DigitalOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Digital option tests");
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testCashOrNothingEuropeanValues));
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testAssetOrNothingEuropeanValues));
    suite->add(QUANTLIB_TEST_CASE(&DigitalOptionTest::testGapEuropeanValues));
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testCashAtHitOrNothingAmericanValues));
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testCashAtHitOrNothingAmericanGreeks));
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testAssetAtHitOrNothingAmericanValues));
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testCashAtExpiryOrNothingAmericanValues));
    suite->add(QUANTLIB_TEST_CASE(
               &DigitalOptionTest::testAssetAtExpiryOrNothingAmericanValues));
    //FLOATING_POINT_EXCEPTION
    suite->add(QUANTLIB_TEST_CASE(&DigitalOptionTest::testMCCashAtHit));
    return suite;
}

]]></document_content>
  </document>
  <document index="84">
    <source>digitaloption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003 Neil Firth

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_digital_option_hpp
#define quantlib_test_digital_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DigitalOptionTest {
  public:
    static void testCashOrNothingEuropeanValues();
    static void testAssetOrNothingEuropeanValues();
    static void testGapEuropeanValues();
    static void testCashAtHitOrNothingAmericanValues();
    static void testAssetAtHitOrNothingAmericanValues();
    static void testCashAtExpiryOrNothingAmericanValues();
    static void testAssetAtExpiryOrNothingAmericanValues();
    static void testCashAtHitOrNothingAmericanGreeks();
    static void testMCCashAtHit();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="85">
    <source>distributions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003 StatPro Italia srl
 Copyright (C) 2005 Gary Kennedy
 Copyright (C) 2013 Fabien Le Floc'h
 Copyright (C) 2016 Klaus Spanderen


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "distributions.hpp"
#include "utilities.hpp"
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/math/distributions/bivariatestudenttdistribution.hpp>
#include <ql/math/distributions/chisquaredistribution.hpp>
#include <ql/math/distributions/poissondistribution.hpp>
#include <ql/math/randomnumbers/stochasticcollocationinvcdf.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/functional.hpp>

#if defined(__GNUC__) && !defined(__clang__) && BOOST_VERSION > 106300
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#endif
#include <boost/math/distributions/non_central_chi_squared.hpp>
#if defined(__GNUC__) && !defined(__clang__) && BOOST_VERSION > 106300
#pragma GCC diagnostic pop
#endif

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace distributions_test {

    Real average = 1.0, sigma = 2.0;

    Real gaussian(Real x) {
        Real normFact = sigma*std::sqrt(2*M_PI);
        Real dx = x-average;
        return std::exp(-dx*dx/(2.0*sigma*sigma))/normFact;
    }

    Real gaussianDerivative(Real x) {
        Real normFact = sigma*sigma*sigma*std::sqrt(2*M_PI);
        Real dx = x-average;
        return -dx*std::exp(-dx*dx/(2.0*sigma*sigma))/normFact;
    }

    struct BivariateTestData {
        Real a;
        Real b;
        Real rho;
        Real result;
    };

    template <class Bivariate>
    void checkBivariate(const char* tag) {

        BivariateTestData values[] = {
            /* The data below are from
               "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
               pag 193
            */
            {  0.0,  0.0,  0.0, 0.250000 },
            {  0.0,  0.0, -0.5, 0.166667 },
            {  0.0,  0.0,  0.5, 1.0/3    },
            {  0.0, -0.5,  0.0, 0.154269 },
            {  0.0, -0.5, -0.5, 0.081660 },
            {  0.0, -0.5,  0.5, 0.226878 },
            {  0.0,  0.5,  0.0, 0.345731 },
            {  0.0,  0.5, -0.5, 0.273122 },
            {  0.0,  0.5,  0.5, 0.418340 },

            { -0.5,  0.0,  0.0, 0.154269 },
            { -0.5,  0.0, -0.5, 0.081660 },
            { -0.5,  0.0,  0.5, 0.226878 },
            { -0.5, -0.5,  0.0, 0.095195 },
            { -0.5, -0.5, -0.5, 0.036298 },
            { -0.5, -0.5,  0.5, 0.163319 },
            { -0.5,  0.5,  0.0, 0.213342 },
            { -0.5,  0.5, -0.5, 0.145218 },
            { -0.5,  0.5,  0.5, 0.272239 },

            {  0.5,  0.0,  0.0, 0.345731 },
            {  0.5,  0.0, -0.5, 0.273122 },
            {  0.5,  0.0,  0.5, 0.418340 },
            {  0.5, -0.5,  0.0, 0.213342 },
            {  0.5, -0.5, -0.5, 0.145218 },
            {  0.5, -0.5,  0.5, 0.272239 },
            {  0.5,  0.5,  0.0, 0.478120 },
            {  0.5,  0.5, -0.5, 0.419223 },
            {  0.5,  0.5,  0.5, 0.546244 },

            // known analytical values
            {  0.0, 0.0, std::sqrt(1/2.0), 3.0/8},

            // {  0.0,  big,  any, 0.500000 },
            {  0.0,   30, -1.0, 0.500000 },
            {  0.0,   30,  0.0, 0.500000 },
            {  0.0,   30,  1.0, 0.500000 },

            // { big,  big,   any, 1.000000 },
            {  30,   30,  -1.0, 1.000000 },
            {  30,   30,   0.0, 1.000000 },
            {  30,   30,   1.0, 1.000000 },

            // {-big,  any,   any, 0.000000 }
            { -30, -1.0,  -1.0, 0.000000 },
            { -30,  0.0,  -1.0, 0.000000 },
            { -30,  1.0,  -1.0, 0.000000 },
            { -30, -1.0,   0.0, 0.000000 },
            { -30,  0.0,   0.0, 0.000000 },
            { -30,  1.0,   0.0, 0.000000 },
            { -30, -1.0,   1.0, 0.000000 },
            { -30,  0.0,   1.0, 0.000000 },
            { -30,  1.0,   1.0, 0.000000 }
        };

        for (Size i=0; i<LENGTH(values); i++) {
            Bivariate bcd(values[i].rho);
            Real value = bcd(values[i].a, values[i].b);

            Real tolerance = 1.0e-6;
            if (std::fabs(value-values[i].result) >= tolerance) {
                BOOST_ERROR(tag << " bivariate cumulative distribution\n"
                            << "    case: " << i+1 << "\n"
                            << std::fixed
                            << "    a:    " << values[i].a << "\n"
                            << "    b:    " << values[i].b << "\n"
                            << "    rho:  " << values[i].rho <<"\n"
                            << std::scientific
                            << "    tabulated value:  "
                            << values[i].result << "\n"
                            << "    result:           " << value);
            }
        }
    }

    template <class Bivariate>
    void checkBivariateAtZero(const char* tag, Real tolerance) {

        /*
          BVN(0.0,0.0,rho) = 1/4 + arcsin(rho)/(2*M_PI)
          "Handbook of the Normal Distribution",
          J.K. Patel & C.B.Read, 2nd Ed, 1996
        */
        const Real rho[] = { 0.0, 0.1, 0.2, 0.3, 0.4, 0.5,
                             0.6, 0.7, 0.8, 0.9, 0.99999 };
        const Real x(0.0);
        const Real y(0.0);

        for (double i : rho) {
            for (Integer sgn=-1; sgn < 2; sgn+=2) {
                Bivariate bvn(sgn * i);
                Real expected = 0.25 + std::asin(sgn * i) / (2 * M_PI);
                Real realised = bvn(x,y);

                if (std::fabs(realised-expected)>=tolerance) {
                    BOOST_ERROR(tag << " bivariate cumulative distribution\n"
                                    << std::scientific << "    rho: " << sgn * i << "\n"
                                    << "    expected:  " << expected << "\n"
                                    << "    realised:  " << realised << "\n"
                                    << "    tolerance: " << tolerance);
                }
            }
        }
    }

    template <class Bivariate>
    void checkBivariateTail(const char* tag, Real tolerance) {

        /* make sure numerical greeks are sensible, numerical error in
         * the tails can make garbage greeks for partial time barrier
         * option */
        Real x = -6.9;
        Real y = 6.9;
        Real corr = -0.999;
        Bivariate bvn(corr);
        for (int i = 0; i<10;i++) {
            Real cdf0 = bvn(x,y);
            y = y + tolerance;
            Real cdf1 = bvn(x,y);
            if (cdf0 > cdf1) {
                BOOST_ERROR(tag << " cdf must be decreasing in the tails\n"
                            << std::scientific
                            << "    cdf0: " << cdf0 << "\n"
                            << "    cdf1: " << cdf1 << "\n"
                            << "    x: " << x << "\n"
                            << "    y: " << y << "\n"
                            << "    rho: " << corr);
            }
        }
    }

    struct BivariateStudentTestData {
        Natural n;
        Real rho;
        Real x;
        Real y;
        Real result;
    };

}

void DistributionTest::testNormal() {

    BOOST_TEST_MESSAGE("Testing normal distributions...");

    using namespace distributions_test;

    InverseCumulativeNormal invCumStandardNormal;
    Real check = invCumStandardNormal(0.5);
    if (check != 0.0e0) {
        BOOST_ERROR("C++ inverse cumulative of the standard normal at 0.5 is "
                    << std::scientific << check
                    << "\n instead of zero: something is wrong!");
    }

    NormalDistribution normal(average,sigma);
    CumulativeNormalDistribution cum(average,sigma);
    InverseCumulativeNormal invCum(average,sigma);

    Size numberOfStandardDeviation = 6;
    Real xMin = average - numberOfStandardDeviation*sigma,
         xMax = average + numberOfStandardDeviation*sigma;
    Size N = 100001;
    Real h = (xMax-xMin)/(N-1);

    std::vector<Real> x(N), y(N), yd(N), temp(N), diff(N);

    Size i;
    for (i=0; i<N; i++)
        x[i] = xMin+h*i;
    std::transform(x.begin(), x.end(), y.begin(), gaussian);
    std::transform(x.begin(), x.end(), yd.begin(), gaussianDerivative);

    // check that normal = Gaussian
    std::transform(x.begin(),x.end(),temp.begin(),normal);
    std::transform(y.begin(),y.end(),temp.begin(),diff.begin(),
                   std::minus<Real>());
    Real e = norm(diff.begin(),diff.end(),h);
    if (e > 1.0e-16) {
        BOOST_ERROR("norm of C++ NormalDistribution minus analytic Gaussian: "
                    << std::scientific << e << "\n"
                    << "tolerance exceeded");
    }

    // check that invCum . cum = identity
    std::transform(x.begin(),x.end(),temp.begin(),cum);
    std::transform(temp.begin(),temp.end(),temp.begin(),invCum);
    std::transform(x.begin(),x.end(),temp.begin(),diff.begin(),
                   std::minus<Real>());
    e = norm(diff.begin(),diff.end(),h);
    if (e > 1.0e-7) {
        BOOST_ERROR("norm of invCum . cum minus identity: "
                    << std::scientific << e << "\n"
                    << "tolerance exceeded");
    }

    MaddockInverseCumulativeNormal mInvCum(average, sigma);
    std::transform(x.begin(),x.end(), x.begin(), diff.begin(),
    			   compose3(std::minus<Real>(),
    				  identity<Real>(), compose(mInvCum, cum)));

    e = norm(diff.begin(), diff.end(), h);
    if (e > 1.0e-7) {
        BOOST_ERROR("norm of MaddokInvCum . cum minus identity: "
                    << std::scientific << e << "\n"
                    << "tolerance exceeded");
    }

    // check that cum.derivative = Gaussian
    for (i=0; i<x.size(); i++)
        temp[i] = cum.derivative(x[i]);
    std::transform(y.begin(),y.end(),temp.begin(),diff.begin(),
                   std::minus<Real>());
    e = norm(diff.begin(),diff.end(),h);
    if (e > 1.0e-16) {
        BOOST_ERROR(
            "norm of C++ Cumulative.derivative minus analytic Gaussian: "
            << std::scientific << e << "\n"
            << "tolerance exceeded");
    }

    // check that normal.derivative = gaussianDerivative
    for (i=0; i<x.size(); i++)
        temp[i] = normal.derivative(x[i]);
    std::transform(yd.begin(),yd.end(),temp.begin(),diff.begin(),
                   std::minus<Real>());
    e = norm(diff.begin(),diff.end(),h);
    if (e > 1.0e-16) {
        BOOST_ERROR("norm of C++ Normal.derivative minus analytic derivative: "
                    << std::scientific << e << "\n"
                    << "tolerance exceeded");
    }
}

void DistributionTest::testBivariate() {

    BOOST_TEST_MESSAGE("Testing bivariate cumulative normal distribution...");

    using namespace distributions_test;

    checkBivariateAtZero<BivariateCumulativeNormalDistributionDr78>(
                                                      "Drezner 1978", 1.0e-6);
    checkBivariate<BivariateCumulativeNormalDistributionDr78>("Drezner 1978");

    // due to relative low accuracy of Dr78, it does not pass with a
    // smaller perturbation
    checkBivariateTail<BivariateCumulativeNormalDistributionDr78>(
                                                        "Drezner 1978", 1.0e-5);

    checkBivariateAtZero<BivariateCumulativeNormalDistributionWe04DP>(
                                                        "West 2004", 1.0e-15);
    checkBivariate<BivariateCumulativeNormalDistributionWe04DP>("West 2004");

    checkBivariateTail<BivariateCumulativeNormalDistributionWe04DP>(
                                                        "West 2004", 1.0e-6);
    checkBivariateTail<BivariateCumulativeNormalDistributionWe04DP>(
                                                        "West 2004", 1.0e-8);
}


void DistributionTest::testPoisson() {

    BOOST_TEST_MESSAGE("Testing Poisson distribution...");

    for (Real mean=0.0; mean<=10.0; mean+=0.5) {
        BigNatural i = 0;
        PoissonDistribution pdf(mean);
        Real calculated = pdf(i);
        Real logHelper = -mean;
        Real expected = std::exp(logHelper);
        Real error = std::fabs(calculated-expected);
        if (error > 1.0e-16)
            BOOST_ERROR("Poisson pdf(" << mean << ")(" << i << ")\n"
                        << std::setprecision(16)
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << expected << "\n"
                        << "    error:      " << error);

        for (i=1; i<25; i++) {
            calculated = pdf(i);
            if (mean == 0.0) {
                expected = 0.0;
            } else {
                logHelper = logHelper+std::log(mean)-std::log(Real(i));
                expected = std::exp(logHelper);
            }
            error = std::fabs(calculated-expected);
            if (error>1.0e-13)
                BOOST_ERROR("Poisson pdf(" << mean << ")(" << i << ")\n"
                            << std::setprecision(13)
                            << "    calculated: " << calculated << "\n"
                            << "    expected:   " << expected << "\n"
                            << "    error:      " << error);
        }
    }
}

void DistributionTest::testCumulativePoisson() {

    BOOST_TEST_MESSAGE("Testing cumulative Poisson distribution...");

    for (Real mean=0.0; mean<=10.0; mean+=0.5) {
        BigNatural i = 0;
        CumulativePoissonDistribution cdf(mean);
        Real cumCalculated = cdf(i);
        Real logHelper = -mean;
        Real cumExpected = std::exp(logHelper);
        Real error = std::fabs(cumCalculated-cumExpected);
        if (error>1.0e-13)
            BOOST_ERROR("Poisson cdf(" << mean << ")(" << i << ")\n"
                        << std::setprecision(13)
                        << "    calculated: " << cumCalculated << "\n"
                        << "    expected:   " << cumExpected << "\n"
                        << "    error:      " << error);
        for (i=1; i<25; i++) {
            cumCalculated = cdf(i);
            if (mean == 0.0) {
                cumExpected = 1.0;
            } else {
                logHelper = logHelper+std::log(mean)-std::log(Real(i));
                cumExpected += std::exp(logHelper);
            }
            error = std::fabs(cumCalculated-cumExpected);
            if (error>1.0e-12)
                BOOST_ERROR("Poisson cdf(" << mean << ")(" << i << ")\n"
                            << std::setprecision(12)
                            << "    calculated: " << cumCalculated << "\n"
                            << "    expected:   " << cumExpected << "\n"
                            << "    error:      " << error);
        }
    }
}

void DistributionTest::testInverseCumulativePoisson() {

    BOOST_TEST_MESSAGE("Testing inverse cumulative Poisson distribution...");

    InverseCumulativePoisson icp(1.0);

    Real data[] = { 0.2,
                    0.5,
                    0.9,
                    0.98,
                    0.99,
                    0.999,
                    0.9999,
                    0.99995,
                    0.99999,
                    0.999999,
                    0.9999999,
                    0.99999999
    };

    for (Size i=0; i<LENGTH(data); i++) {
        if (!close(icp(data[i]), static_cast<Real>(i))) {
            BOOST_ERROR(std::setprecision(8)
                        << "failed to reproduce known value for x = "
                        << data[i] << "\n"
                        << "    calculated: " << icp(data[i]) << "\n"
                        << "    expected:   " << Real(i));
        }
    }
}


void DistributionTest::testBivariateCumulativeStudent() {
    BOOST_TEST_MESSAGE(
        "Testing bivariate cumulative Student t distribution...");

    using namespace distributions_test;

    Real xs[14] = { 0.00,  0.50,  1.00,  1.50,  2.00,  2.50, 3.00, 4.00,  5.00,  6.00,  7.00,  8.00, 9.00, 10.00 };
    Natural ns[20] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 60, 90, 120, 150, 300, 600 };
    // Part of table 1 from the reference paper
    Real expected1[280] = {
        0.33333,  0.50000,  0.63497,  0.72338,  0.78063,  0.81943,  0.84704,  0.88332,  0.90590,  0.92124,  0.93231,  0.94066,  0.94719,  0.95243,
        0.33333,  0.52017,  0.68114,  0.78925,  0.85607,  0.89754,  0.92417,  0.95433,  0.96978,  0.97862,  0.98411,  0.98774,  0.99026,  0.99208,
        0.33333,  0.52818,  0.70018,  0.81702,  0.88720,  0.92812,  0.95238,  0.97667,  0.98712,  0.99222,  0.99497,  0.99657,  0.99756,  0.99821,
        0.33333,  0.53245,  0.71052,  0.83231,  0.90402,  0.94394,  0.96612,  0.98616,  0.99353,  0.99664,  0.99810,  0.99885,  0.99927,  0.99951,
        0.33333,  0.53510,  0.71701,  0.84196,  0.91449,  0.95344,  0.97397,  0.99095,  0.99637,  0.99836,  0.99918,  0.99956,  0.99975,  0.99985,
        0.33333,  0.53689,  0.72146,  0.84862,  0.92163,  0.95972,  0.97893,  0.99365,  0.99779,  0.99913,  0.99962,  0.99982,  0.99990,  0.99995,
        0.33333,  0.53819,  0.72470,  0.85348,  0.92679,  0.96415,  0.98230,  0.99531,  0.99857,  0.99950,  0.99981,  0.99992,  0.99996,  0.99998,
        0.33333,  0.53917,  0.72716,  0.85719,  0.93070,  0.96743,  0.98470,  0.99639,  0.99903,  0.99970,  0.99990,  0.99996,  0.99998,  0.99999,
        0.33333,  0.53994,  0.72909,  0.86011,  0.93375,  0.96995,  0.98650,  0.99713,  0.99931,  0.99981,  0.99994,  0.99998,  0.99999,  1.00000,
        0.33333,  0.54056,  0.73065,  0.86247,  0.93621,  0.97194,  0.98788,  0.99766,  0.99950,  0.99988,  0.99996,  0.99999,  1.00000,  1.00000,
        0.33333,  0.54243,  0.73540,  0.86968,  0.94362,  0.97774,  0.99168,  0.99890,  0.99985,  0.99998,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54338,  0.73781,  0.87336,  0.94735,  0.98053,  0.99337,  0.99932,  0.99993,  0.99999,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54395,  0.73927,  0.87560,  0.94959,  0.98216,  0.99430,  0.99952,  0.99996,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54433,  0.74025,  0.87709,  0.95108,  0.98322,  0.99489,  0.99963,  0.99998,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54528,  0.74271,  0.88087,  0.95482,  0.98580,  0.99623,  0.99983,  0.99999,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54560,  0.74354,  0.88215,  0.95607,  0.98663,  0.99664,  0.99987,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54576,  0.74396,  0.88279,  0.95669,  0.98704,  0.99683,  0.99989,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54586,  0.74420,  0.88317,  0.95706,  0.98729,  0.99695,  0.99990,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54605,  0.74470,  0.88394,  0.95781,  0.98777,  0.99717,  0.99992,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.33333,  0.54615,  0.74495,  0.88432,  0.95818,  0.98801,  0.99728,  0.99993,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000
    };
    // Part of table 2 from the reference paper
    Real expected2[280] = {
        0.16667,  0.36554,  0.54022,  0.65333,  0.72582,  0.77465,  0.80928,  0.85466,  0.88284,  0.90196,  0.91575,  0.92616,  0.93429,  0.94081,
        0.16667,  0.38889,  0.59968,  0.73892,  0.82320,  0.87479,  0.90763,  0.94458,  0.96339,  0.97412,  0.98078,  0.98518,  0.98823,  0.99044,
        0.16667,  0.39817,  0.62478,  0.77566,  0.86365,  0.91391,  0.94330,  0.97241,  0.98483,  0.99086,  0.99410,  0.99598,  0.99714,  0.99790,
        0.16667,  0.40313,  0.63863,  0.79605,  0.88547,  0.93396,  0.96043,  0.98400,  0.99256,  0.99614,  0.99782,  0.99868,  0.99916,  0.99944,
        0.16667,  0.40620,  0.64740,  0.80900,  0.89902,  0.94588,  0.97007,  0.98972,  0.99591,  0.99816,  0.99909,  0.99951,  0.99972,  0.99983,
        0.16667,  0.40829,  0.65345,  0.81794,  0.90820,  0.95368,  0.97607,  0.99290,  0.99755,  0.99904,  0.99958,  0.99980,  0.99989,  0.99994,
        0.16667,  0.40980,  0.65788,  0.82449,  0.91482,  0.95914,  0.98010,  0.99482,  0.99844,  0.99946,  0.99979,  0.99991,  0.99996,  0.99998,
        0.16667,  0.41095,  0.66126,  0.82948,  0.91981,  0.96314,  0.98295,  0.99605,  0.99895,  0.99968,  0.99989,  0.99996,  0.99998,  0.99999,
        0.16667,  0.41185,  0.66393,  0.83342,  0.92369,  0.96619,  0.98506,  0.99689,  0.99926,  0.99980,  0.99994,  0.99998,  0.99999,  1.00000,
        0.16667,  0.41257,  0.66608,  0.83661,  0.92681,  0.96859,  0.98667,  0.99748,  0.99946,  0.99987,  0.99996,  0.99999,  1.00000,  1.00000,
        0.16667,  0.41476,  0.67268,  0.84633,  0.93614,  0.97550,  0.99103,  0.99884,  0.99984,  0.99998,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41586,  0.67605,  0.85129,  0.94078,  0.97877,  0.99292,  0.99930,  0.99993,  0.99999,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41653,  0.67810,  0.85430,  0.94356,  0.98066,  0.99396,  0.99950,  0.99996,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41698,  0.67947,  0.85632,  0.94540,  0.98189,  0.99461,  0.99962,  0.99998,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41810,  0.68294,  0.86141,  0.94998,  0.98483,  0.99607,  0.99982,  0.99999,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41847,  0.68411,  0.86312,  0.95149,  0.98577,  0.99651,  0.99987,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41866,  0.68470,  0.86398,  0.95225,  0.98623,  0.99672,  0.99989,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41877,  0.68505,  0.86449,  0.95270,  0.98650,  0.99684,  0.99990,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41900,  0.68576,  0.86552,  0.95360,  0.98705,  0.99707,  0.99992,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,
        0.16667,  0.41911,  0.68612,  0.86604,  0.95405,  0.98731,  0.99719,  0.99993,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000,  1.00000
    };

    Real tolerance = 1.0e-5;
    for (Size i=0; i < LENGTH(ns); ++i) {
		BivariateCumulativeStudentDistribution f1(ns[i],  0.5);
		BivariateCumulativeStudentDistribution f2(ns[i], -0.5);
        for (Size j=0; j < LENGTH(xs); ++j) {
			Real calculated1 = f1(xs[j], xs[j]);
            Real reference1 = expected1[i*LENGTH(xs)+j];
			Real calculated2 = f2(xs[j], xs[j]);
            Real reference2 = expected2[i*LENGTH(xs)+j];
            if (std::fabs(calculated1 - reference1) > tolerance)
                BOOST_ERROR("Failed to reproduce CDF value at " << xs[j] <<
                            "\n    calculated: " << calculated1 <<
                            "\n    expected:   " << reference1);
            if (std::fabs(calculated2 - reference2) > tolerance)
                BOOST_ERROR("Failed to reproduce CDF value at " << xs[j] <<
                            "\n    calculated: " << calculated2 <<
                            "\n    expected:   " << reference1);
		}
	}

    // a few more random cases
    BivariateStudentTestData cases[] = {
        {2,    -1.0,   5.0,   8.0,   0.973491},
        {2,     1.0,  -2.0,   8.0,   0.091752},
        {2,     1.0,   5.25, -9.5,   0.005450},
        {3,    -0.5,  -5.0,  -5.0,   0.000220},
        {4,    -1.0,  -8.0,   7.5,   0.0},
        {4,     0.5,  -5.5,  10.0,   0.002655},
        {4,     1.0,  -5.0,   6.0,   0.003745},
        {4,     1.0,   6.0,   5.5,   0.997336},
        {5,    -0.5,  -7.0,  -6.25,  0.000004},
        {5,    -0.5,   3.75, -7.25,  0.000166},
        {5,    -0.5,   7.75, -1.25,  0.133073},
        {6,     0.0,   7.5,   3.25,  0.991149},
        {7,    -0.5,  -1.0,  -8.5,   0.000001},
        {7,    -1.0,  -4.25, -4.0,   0.0},
        {7,     0.0,   0.5,  -2.25,  0.018819},
        {8,    -1.0,   8.25,  1.75,  0.940866},
        {8,     0.0,   2.25,  4.75,  0.972105},
        {9,    -0.5,  -4.0,   8.25,  0.001550},
        {9,    -1.0,  -1.25, -8.75,  0.0},
        {9,    -1.0,   5.75, -6.0,   0.0},
        {9,     0.5,  -6.5,  -9.5,   0.000001},
        {9,     1.0,  -2.0,   9.25,  0.038276},
        {10,   -1.0,  -0.5,   6.0,   0.313881},
        {10,    0.5,   0.0,   9.25,  0.5},
        {10,    0.5,   6.75, -2.25,  0.024090},
        {10,    1.0,  -1.75, -1.0,   0.055341},
        {15,    0.0,  -1.25, -4.75,  0.000029},
        {15,    0.0,  -2.0,  -1.5,   0.003411},
        {15,    0.5,   3.0,  -3.25,  0.002691},
        {20,   -0.5,   2.0,  -1.25,  0.098333},
        {20,   -1.0,   3.0,   8.0,   0.996462},
        {20,    0.0,  -7.5,   1.5,   0.0},
        {20,    0.5,   1.25,  9.75,  0.887136},
        {25,   -1.0,  -4.25,  5.0,   0.000111},
        {25,    0.5,   9.5,  -1.5,   0.073069},
        {25,    1.0,  -6.5,  -3.25,  0.0},
        {30,   -1.0,  -7.75, 10.0,   0.0},
        {30,    1.0,   0.5,   9.5,   0.689638},
        {60,   -1.0,  -3.5,  -8.25,  0.0},
        {60,   -1.0,   4.25,  0.75,  0.771869},
        {60,   -1.0,   5.75,  3.75,  0.9998},
        {60,    0.5,  -4.5,   8.25,  0.000016},
        {60,    1.0,   6.5,  -4.0,   0.000088},
        {90,   -0.5,  -3.75, -2.75,  0.0},
        {90,    0.5,   8.75, -7.0,   0.0},
        {120,   0.0,  -3.5,  -9.25,  0.0},
        {120,   0.0,  -8.25,  5.0,   0.0},
        {120,   1.0,  -0.75,  3.75,  0.227361},
        {120,   1.0,  -3.5,  -8.0,   0.0},
        {150,   0.0,  10.0,  -1.75,  0.041082},
        {300,  -0.5,  -6.0,   3.75,  0.0},
        {300,  -0.5,   3.5,  -4.5,   0.000004},
        {300,   0.0,   6.5,  -5.0,   0.0},
        {600,  -0.5,   9.25,  1.5,   0.93293},
        {600,  -1.0,  -9.25,  1.5,   0.0},
        {600,   0.5,  -5.0,   8.0,   0.0},
        {600,   1.0,  -2.75, -9.0,   0.0},
        {1000, -0.5,  -2.5,   0.25,  0.000589},
        {1000, -0.5,   3.0,   1.0,   0.839842},
        {2000, -1.0,   9.0,  -4.75,  0.000001},
        {2000,  0.5,   9.75,  7.25,  1.0},
        {2000,  1.0,   0.75, -9.0,   0.0},
        {5000, -0.5,   9.75,  5.5,   1.0},
        {5000, -1.0,   6.0,   1.0,   0.841321},
        {5000,  1.0,   4.0,  -7.75,  0.0},
        {10000, 0.5,   1.5,   6.0,   0.933177}
    };

    tolerance = 1.0e-6;
    for (auto& i : cases) {
        BivariateCumulativeStudentDistribution f(i.n, i.rho);
        Real calculated = f(i.x, i.y);
        Real expected = i.result;
        if (std::fabs(calculated - expected) > tolerance)
            BOOST_ERROR("Failed to reproduce CDF value:"
                        << "\n    n:   " << i.n << "\n    rho: " << i.rho << "\n    x:   " << i.x
                        << "\n    y:   " << i.y << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected);
    }
}

void DistributionTest::testBivariateCumulativeStudentVsBivariate() {
    BOOST_TEST_MESSAGE(
        "Testing bivariate cumulative Student t distribution for large N...");

    Natural n = 10000;  // for this value, the distribution should be
                        // close to a bivariate normal distribution.

	for (Real rho = -1.0; rho < 1.01; rho += 0.25) {
		BivariateCumulativeStudentDistribution T(n, rho);
		BivariateCumulativeNormalDistribution N(rho);

        Real avgDiff = 0.0;
        Size m = 0;
		Real tolerance = 4.0e-5;
		for (Real x = -10; x < 10.1; x += 0.25) {
			for (Real y = -10; y < 10.1; y += 0.25) {
                Real calculated = T(x, y);
                Real expected = N(x, y);
				Real diff = std::fabs(calculated - expected);
                if (diff > tolerance)
                    BOOST_ERROR("Failed to reproduce limit value:" <<
                                "\n    rho: " << rho <<
                                "\n    x:   " << x <<
                                "\n    y:   " << y <<
                                "\n    calculated: " << calculated <<
                                "\n    expected:   " << expected);
                
				avgDiff += diff;
				++m;
			}
		}
		avgDiff /= m;
        if (avgDiff > 3.0e-6)
            BOOST_ERROR("Failed to reproduce average limit value:" <<
                        "\n    rho: " << rho <<
                        "\n    average error: " << avgDiff);
    }
}
    

namespace distributions_test {
    class InverseNonCentralChiSquared {
      public:
        InverseNonCentralChiSquared(Real df, Real ncp)
        : dist_(df, ncp) {}

        Real operator()(Real x) const {
            return boost::math::quantile(dist_, x);
        }
      private:
        const boost::math::non_central_chi_squared_distribution<Real> dist_;
    };
}

void DistributionTest::testInvCDFviaStochasticCollocation() {
    BOOST_TEST_MESSAGE(
        "Testing inverse CDF based on stochastic collocation...");

    using namespace distributions_test;

    const Real k = 3.0;
    const Real lambda = 1.0;

    const InverseCumulativeNormal invNormalCDF;
    const CumulativeNormalDistribution normalCDF;
    const InverseNonCentralChiSquared invCDF(k, lambda);

    const StochasticCollocationInvCDF scInvCDF10(invCDF, 10);

    // low precision
    for (Real x=-3.0; x < 3.0; x+=0.1) {
        const Real u = normalCDF(x);

        const Real calculated1 = scInvCDF10(u);
        const Real calculated2 = scInvCDF10.value(x);
        const Real expected = invCDF(u);

        if (std::fabs(calculated1 - calculated2) > 1e-6) {
            BOOST_FAIL("Failed to reproduce equal stochastic collocation "
                       "inverse CDF" <<
                       "\n    x: " << x <<
                       "\n    calculated via normal distribution : "
                           << calculated2 <<
                       "\n    calculated via uniform distribution: "
                           << calculated1 <<
                       "\n    diff: " << calculated1 - calculated2);
        }

        const Real tol = 1e-2;
        if (std::fabs(calculated2 - expected) > tol) {
            BOOST_FAIL("Failed to reproduce invCDF with "
                       "stochastic collocation method" <<
                       "\n    x: " << x <<
                       "\n    invCDF  :" << expected <<
                       "\n    scInvCDF: " << calculated2 <<
                       "\n    diff    : " << std::fabs(expected-calculated2) <<
                       "\n    tol     : " << tol);
        }
    }

    // high precision
    const StochasticCollocationInvCDF scInvCDF30(invCDF, 30, 0.9999999);
    for (Real x=-4.0; x < 4.0; x+=0.1) {
        const Real u = normalCDF(x);

        const Real expected = invCDF(u);
        const Real calculated = scInvCDF30(u);

        const Real tol = 1e-6;
        if (std::fabs(calculated - expected) > tol) {
            BOOST_FAIL("Failed to reproduce invCDF with "
                       "stochastic collocation method" <<
                       "\n    x: " << x <<
                       "\n    invCDF  :" << expected <<
                       "\n    scInvCDF: " << calculated <<
                       "\n    diff    : " << std::fabs(expected-calculated) <<
                       "\n    tol     : " << tol);
        }
    }
}

void DistributionTest::testSankaranApproximation() {
    BOOST_TEST_MESSAGE("Testing Sankaran approximation for the "
                       "non-central cumulative chi-square distribution...");

    const Real dfs[] = {2,2,2,4,4};
    const Real ncps[] = {1,2,3,1,2,3};

    const Real tol = 0.01;
    for (double df : dfs) {
        for (double ncp : ncps) {
            const NonCentralCumulativeChiSquareDistribution d(df, ncp);
            const NonCentralCumulativeChiSquareSankaranApprox sankaran(df, ncp);

            for (Real x=0.25; x < 10; x+=0.1) {
                const Real expected = d(x);
                const Real calculated = sankaran(x);
                const Real diff = std::fabs(expected - calculated);

                if (diff > tol) {
                    BOOST_ERROR("Failed to match accuracy of Sankaran approximation"""
                           "\n    df        : " << df <<
                           "\n    ncp       : " << ncp <<
                           "\n    x         : " << x <<
                           "\n    expected  : " << expected <<
                           "\n    calculated: " << calculated <<
                           "\n    diff      : " << diff <<
                           "\n    tol       : " << tol);
                }
            }
        }
    }
}

test_suite* DistributionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Distribution tests");

    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testNormal));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testBivariate));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testPoisson));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testCumulativePoisson));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testInverseCumulativePoisson));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testBivariateCumulativeStudent));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testInvCDFviaStochasticCollocation));
    suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testSankaranApproximation));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&DistributionTest::testBivariateCumulativeStudentVsBivariate));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="86">
    <source>distributions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_distributions_hpp
#define quantlib_test_distributions_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DistributionTest {
  public:
    static void testNormal();
    static void testBivariate();
    static void testPoisson();
    static void testCumulativePoisson();
    static void testInverseCumulativePoisson();
    static void testBivariateCumulativeStudent();
    static void testBivariateCumulativeStudentVsBivariate();
    static void testInvCDFviaStochasticCollocation();
    static void testSankaranApproximation();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="87">
    <source>dividendoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

// TODO: Figure out why tests for options with both continuous and discrete
// dividends fail.

// TODO: Make the known value test work.  It is slightly off from the
// answer in Hull probably due to date conventions.

#include "dividendoption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/dividendvanillaoption.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/fddividendshoutengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/analyticdividendeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, \
                       v, expected, calculated, error, tolerance) \
    BOOST_ERROR(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:       " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

// tests

void DividendOptionTest::testEuropeanValues() {

    BOOST_TEST_MESSAGE(
              "Testing dividend European option values with no dividends...");

    SavedSettings backup;

    Real tolerance = 1.0e-5;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.00, 0.10, 0.30 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Integer lengths[] = { 1, 2 };
    Volatility vols[] = { 0.05, 0.20, 0.70 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    for (auto& type : types) {
        for (double strike : strikes) {
            for (int length : lengths) {
                Date exDate = today + length * Years;
                ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

                std::vector<Date> dividendDates;
                std::vector<Real> dividends;
                for (Date d = today + 3 * Months; d < exercise->lastDate(); d += 6 * Months) {
                    dividendDates.push_back(d);
                    dividends.push_back(0.0);
                }

                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));

                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> ref_engine(new AnalyticEuropeanEngine(stochProcess));

                ext::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

                DividendVanillaOption option(payoff, exercise, dividendDates, dividends);
                option.setPricingEngine(engine);

                VanillaOption ref_option(payoff, exercise);
                ref_option.setPricingEngine(ref_engine);

                for (double u : underlyings) {
                    for (double m : qRates) {
                        for (double n : rRates) {
                            for (double v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);

                                Real calculated = option.NPV();
                                Real expected = ref_option.NPV();
                                Real error = std::fabs(calculated - expected);
                                if (error > tolerance) {
                                    REPORT_FAILURE("value start limit", payoff, exercise, u, q, r,
                                                   today, v, expected, calculated, error,
                                                   tolerance);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Reference pg. 253 - Hull - Options, Futures, and Other Derivatives 5th ed
// Exercise 12.8

void DividendOptionTest::testEuropeanKnownValue() {

    BOOST_TEST_MESSAGE(
              "Testing dividend European option values with known value...");

    SavedSettings backup;

    Real tolerance = 1.0e-2;
    Real expected = 3.67;

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    Date exDate = today + 6*Months;
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

    std::vector<Date> dividendDates = {today + 2*Months, today + 5*Months};
    std::vector<Real> dividends = {0.50, 0.50};

    ext::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(Option::Call, 40.0));

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          qTS, rTS, volTS));

    ext::shared_ptr<PricingEngine> engine(
                            new AnalyticDividendEuropeanEngine(stochProcess));

    DividendVanillaOption option(payoff, exercise,
                                 dividendDates, dividends);
    option.setPricingEngine(engine);

    Real u = 40.0;
    Rate q = 0.0, r = 0.09;
    Volatility v = 0.30;
    spot->setValue(u);
    qRate->setValue(q);
    rRate->setValue(r);
    vol->setValue(v);

    Real calculated = option.NPV();
    Real error = std::fabs(calculated-expected);
    if (error > tolerance) {
        REPORT_FAILURE("value start limit",
                       payoff, exercise,
                       u, q, r, today, v,
                       expected, calculated,
                       error, tolerance);
    }
}


void DividendOptionTest::testEuropeanStartLimit() {

    BOOST_TEST_MESSAGE(
       "Testing dividend European option with a dividend on today's date...");

    SavedSettings backup;

    Real tolerance = 1.0e-5;
    Real dividendValue = 10.0;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.00, 0.10, 0.30 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Integer lengths[] = { 1, 2 };
    Volatility vols[] = { 0.05, 0.20, 0.70 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    for (auto& type : types) {
        for (double strike : strikes) {
            for (int length : lengths) {
                Date exDate = today + length * Years;
                ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

                std::vector<Date> dividendDates = {today};
                std::vector<Real> dividends = {dividendValue};

                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));

                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

                ext::shared_ptr<PricingEngine> ref_engine(new AnalyticEuropeanEngine(stochProcess));

                DividendVanillaOption option(payoff, exercise, dividendDates, dividends);
                option.setPricingEngine(engine);

                VanillaOption ref_option(payoff, exercise);
                ref_option.setPricingEngine(ref_engine);

                for (double u : underlyings) {
                    for (double m : qRates) {
                        for (double n : rRates) {
                            for (double v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);

                                Real calculated = option.NPV();
                                spot->setValue(u - dividendValue);
                                Real expected = ref_option.NPV();
                                Real error = std::fabs(calculated - expected);
                                if (error > tolerance) {
                                    REPORT_FAILURE("value", payoff, exercise, u, q, r, today, v,
                                                   expected, calculated, error, tolerance);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void DividendOptionTest::testEuropeanEndLimit() {

    BOOST_TEST_MESSAGE(
              "Testing dividend European option values with end limits...");

    SavedSettings backup;

    Real tolerance = 1.0e-5;
    Real dividendValue = 10.0;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.00, 0.10, 0.30 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Integer lengths[] = { 1, 2 };
    Volatility vols[] = { 0.05, 0.20, 0.70 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    for (auto& type : types) {
        for (double strike : strikes) {
            for (int length : lengths) {
                Date exDate = today + length * Years;
                ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

                std::vector<Date> dividendDates = {exercise->lastDate()};
                std::vector<Real> dividends = {dividendValue};

                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));


                ext::shared_ptr<StrikedTypePayoff> refPayoff(
                    new PlainVanillaPayoff(type, strike + dividendValue));

                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

                ext::shared_ptr<PricingEngine> ref_engine(new AnalyticEuropeanEngine(stochProcess));

                DividendVanillaOption option(payoff, exercise, dividendDates, dividends);
                option.setPricingEngine(engine);

                VanillaOption ref_option(refPayoff, exercise);
                ref_option.setPricingEngine(ref_engine);

                for (double u : underlyings) {
                    for (double m : qRates) {
                        for (double n : rRates) {
                            for (double v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);

                                Real calculated = option.NPV();
                                Real expected = ref_option.NPV();
                                Real error = std::fabs(calculated - expected);
                                if (error > tolerance) {
                                    REPORT_FAILURE("value", payoff, exercise, u, q, r, today, v,
                                                   expected, calculated, error, tolerance);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


void DividendOptionTest::testEuropeanGreeks() {

    BOOST_TEST_MESSAGE("Testing dividend European option greeks...");

    SavedSettings backup;

    std::map<std::string,Real> calculated, expected, tolerance;
    tolerance["delta"] = 1.0e-5;
    tolerance["gamma"] = 1.0e-5;
    tolerance["theta"] = 1.0e-5;
    tolerance["rho"]   = 1.0e-5;
    tolerance["vega"]  = 1.0e-5;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.00, 0.10, 0.30 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Integer lengths[] = { 1, 2 };
    Volatility vols[] = { 0.05, 0.20, 0.40 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    for (auto& type : types) {
        for (double strike : strikes) {
            for (int length : lengths) {
                Date exDate = today + length * Years;
                ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

                std::vector<Date> dividendDates;
                std::vector<Real> dividends;
                for (Date d = today + 3 * Months; d < exercise->lastDate(); d += 6 * Months) {
                    dividendDates.push_back(d);
                    dividends.push_back(5.0);
                }

                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));

                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

                DividendVanillaOption option(payoff, exercise, dividendDates, dividends);
                option.setPricingEngine(engine);

                for (double u : underlyings) {
                    for (double m : qRates) {
                        for (double n : rRates) {
                            for (double v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);

                                Real value = option.NPV();
                                calculated["delta"] = option.delta();
                                calculated["gamma"] = option.gamma();
                                calculated["theta"] = option.theta();
                                calculated["rho"] = option.rho();
                                calculated["vega"] = option.vega();

                                if (value > spot->value() * 1.0e-5) {
                                    // perturb spot and get delta and gamma
                                    Real du = u * 1.0e-4;
                                    spot->setValue(u + du);
                                    Real value_p = option.NPV(), delta_p = option.delta();
                                    spot->setValue(u - du);
                                    Real value_m = option.NPV(), delta_m = option.delta();
                                    spot->setValue(u);
                                    expected["delta"] = (value_p - value_m) / (2 * du);
                                    expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                    // perturb risk-free rate and get rho
                                    Spread dr = r * 1.0e-4;
                                    rRate->setValue(r + dr);
                                    value_p = option.NPV();
                                    rRate->setValue(r - dr);
                                    value_m = option.NPV();
                                    rRate->setValue(r);
                                    expected["rho"] = (value_p - value_m) / (2 * dr);

                                    // perturb volatility and get vega
                                    Spread dv = v * 1.0e-4;
                                    vol->setValue(v + dv);
                                    value_p = option.NPV();
                                    vol->setValue(v - dv);
                                    value_m = option.NPV();
                                    vol->setValue(v);
                                    expected["vega"] = (value_p - value_m) / (2 * dv);

                                    // perturb date and get theta
                                    Time dT = dc.yearFraction(today - 1, today + 1);
                                    Settings::instance().evaluationDate() = today - 1;
                                    value_m = option.NPV();
                                    Settings::instance().evaluationDate() = today + 1;
                                    value_p = option.NPV();
                                    Settings::instance().evaluationDate() = today;
                                    expected["theta"] = (value_p - value_m) / dT;

                                    // compare
                                    std::map<std::string, Real>::iterator it;
                                    for (it = calculated.begin(); it != calculated.end(); ++it) {
                                        std::string greek = it->first;
                                        Real expct = expected[greek], calcl = calculated[greek],
                                             tol = tolerance[greek];
                                        Real error = relativeError(expct, calcl, u);
                                        if (error > tol) {
                                            REPORT_FAILURE(greek, payoff, exercise, u, q, r, today,
                                                           v, expct, calcl, error, tol);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


void DividendOptionTest::testFdEuropeanValues() {

    BOOST_TEST_MESSAGE(
              "Testing finite-difference dividend European option values...");

    SavedSettings backup;

    Real tolerance = 1.0e-2;
    Size gridPoints = 400;
    Size timeSteps = 40;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.00, 0.10, 0.30 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Integer lengths[] = { 1, 2 };
    Volatility vols[] = { 0.05, 0.20, 0.40 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    for (auto& type : types) {
        for (double strike : strikes) {
            for (int length : lengths) {
                Date exDate = today + length * Years;
                ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

                std::vector<Date> dividendDates;
                std::vector<Real> dividends;
                for (Date d = today + 3 * Months; d < exercise->lastDate(); d += 6 * Months) {
                    dividendDates.push_back(d);
                    dividends.push_back(5.0);
                }

                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));

                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> engine =
                    MakeFdBlackScholesVanillaEngine(stochProcess)
                        .withTGrid(timeSteps)
                        .withXGrid(gridPoints)
                        .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed);

                ext::shared_ptr<PricingEngine> ref_engine(
                    new AnalyticDividendEuropeanEngine(stochProcess));

                DividendVanillaOption option(payoff, exercise, dividendDates, dividends);
                option.setPricingEngine(engine);

                DividendVanillaOption ref_option(payoff, exercise, dividendDates, dividends);
                ref_option.setPricingEngine(ref_engine);

                for (double u : underlyings) {
                    for (double m : qRates) {
                        for (double n : rRates) {
                            for (double v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);
                                // FLOATING_POINT_EXCEPTION
                                Real calculated = option.NPV();
                                if (calculated > spot->value() * 1.0e-5) {
                                    Real expected = ref_option.NPV();
                                    Real error = std::fabs(calculated - expected);
                                    if (error > tolerance) {
                                        REPORT_FAILURE("value", payoff, exercise, u, q, r, today, v,
                                                       expected, calculated, error, tolerance);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


namespace {

    void testFdGreeks(const Date& today,
                      const ext::shared_ptr<Exercise>& exercise,
                      FdBlackScholesVanillaEngine::CashDividendModel model) {

        std::map<std::string,Real> calculated, expected, tolerance;
        tolerance["delta"] = 5.0e-3;
        tolerance["gamma"] = 7.0e-3;
        // tolerance["theta"] = 1.0e-2;

        Option::Type types[] = { Option::Call, Option::Put };
        Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
        Real underlyings[] = { 100.0 };
        Rate qRates[] = { 0.00, 0.10, 0.20 };
        Rate rRates[] = { 0.01, 0.05, 0.15 };
        Volatility vols[] = { 0.05, 0.20, 0.50 };

        DayCounter dc = Actual365Fixed();

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
        ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
        ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
        ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
        Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

        for (auto& type : types) {
            for (double strike : strikes) {

                std::vector<Date> dividendDates;
                std::vector<Real> dividends;
                for (Date d = today + 3*Months;
                     d < exercise->lastDate();
                     d += 6*Months) {
                    dividendDates.push_back(d);
                    dividends.push_back(5.0);
                }

                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));

                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> engine =
                    MakeFdBlackScholesVanillaEngine(stochProcess)
                    .withCashDividendModel(model);

                DividendVanillaOption option(payoff, exercise,
                                             dividendDates, dividends);
                option.setPricingEngine(engine);

                for (double u : underlyings) {
                    for (double m : qRates) {
                        for (double n : rRates) {
                            for (double v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);

                                // FLOATING_POINT_EXCEPTION
                                Real value = option.NPV();
                                calculated["delta"] = option.delta();
                                calculated["gamma"] = option.gamma();

                                if (value > spot->value() * 1.0e-5) {
                                    // perturb spot and get delta and gamma
                                    Real du = u * 1.0e-4;
                                    spot->setValue(u + du);
                                    Real value_p = option.NPV(), delta_p = option.delta();
                                    spot->setValue(u - du);
                                    Real value_m = option.NPV(), delta_m = option.delta();
                                    spot->setValue(u);
                                    expected["delta"] = (value_p - value_m) / (2 * du);
                                    expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                    // perturb date and get theta
                                    /*
                                      Time dT = dc.yearFraction(today-1, today+1);
                                      Settings::instance().evaluationDate() = today-1;
                                      value_m = option.NPV();
                                      Settings::instance().evaluationDate() = today+1;
                                      value_p = option.NPV();
                                      Settings::instance().evaluationDate() = today;
                                      expected["theta"] = (value_p - value_m)/dT;
                                    */

                                    // compare
                                    std::map<std::string, Real>::iterator it;
                                    for (it = calculated.begin(); it != calculated.end(); ++it) {
                                        std::string greek = it->first;
                                        Real expct = expected[greek], calcl = calculated[greek],
                                             tol = tolerance[greek];
                                        Real error = relativeError(expct, calcl, u);
                                        if (error > tol) {
                                            REPORT_FAILURE(greek, payoff, exercise, u, q, r, today,
                                                           v, expct, calcl, error, tol);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}


void DividendOptionTest::testFdEuropeanGreeks() {

    BOOST_TEST_MESSAGE(
             "Testing finite-differences dividend European option greeks...");

    SavedSettings backup;

    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;
    Integer lengths[] = { 1, 2 };

    for (int length : lengths) {
        Date exDate = today + length * Years;
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
        testFdGreeks(today,exercise,FdBlackScholesVanillaEngine::Spot);
        testFdGreeks(today,exercise,FdBlackScholesVanillaEngine::Escrowed);
    }
}

void DividendOptionTest::testFdAmericanGreeks() {
    BOOST_TEST_MESSAGE(
             "Testing finite-differences dividend American option greeks...");

    SavedSettings backup;

    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;
    Integer lengths[] = { 1, 2 };

    for (int length : lengths) {
        Date exDate = today + length * Years;
        ext::shared_ptr<Exercise> exercise(new AmericanExercise(today,exDate));
        testFdGreeks(today,exercise,FdBlackScholesVanillaEngine::Spot);
    }
}


namespace {

    void testFdDegenerate(const Date& today,
                          const ext::shared_ptr<Exercise>& exercise,
                          FdBlackScholesVanillaEngine::CashDividendModel model) {

        DayCounter dc = Actual360();
        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(54.625));
        Handle<YieldTermStructure> rTS(flatRate(0.052706, dc));
        Handle<YieldTermStructure> qTS(flatRate(0.0, dc));
        Handle<BlackVolTermStructure> volTS(flatVol(0.282922, dc));

        ext::shared_ptr<BlackScholesMertonProcess> process(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          qTS, rTS, volTS));

        Size timeSteps = 100;
        Size gridPoints = 300;

        ext::shared_ptr<PricingEngine> engine =
              MakeFdBlackScholesVanillaEngine(process)
              .withTGrid(timeSteps)
              .withXGrid(gridPoints)
              .withCashDividendModel(model);

        ext::shared_ptr<StrikedTypePayoff> payoff(
                                  new PlainVanillaPayoff(Option::Call, 55.0));

        Real tolerance = 3.0e-3;

        std::vector<Rate> dividends;
        std::vector<Date> dividendDates;

        DividendVanillaOption option1(payoff, exercise,
                                      dividendDates, dividends);
        option1.setPricingEngine(engine);

        Real refValue = option1.NPV();

        for (Size i=1; i<=6; i++) {

            dividends.push_back(0.0);
            dividendDates.push_back(today+i);

            DividendVanillaOption option(payoff, exercise,
                                         dividendDates, dividends);
            option.setPricingEngine(engine);
            Real value = option.NPV();

            if (std::fabs(refValue-value) > tolerance)
                BOOST_FAIL("NPV changed by null dividend :\n"
                           << "    previous value: " << value << "\n"
                           << "    current value:  " << refValue << "\n"
                           << "    change:         " << value-refValue);
        }
    }

}


void DividendOptionTest::testFdEuropeanDegenerate() {

    BOOST_TEST_MESSAGE(
         "Testing degenerate finite-differences dividend European option...");

    SavedSettings backup;

    Date today = Date(27,February,2005);
    Settings::instance().evaluationDate() = today;
    Date exDate(13,April,2005);

    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

    testFdDegenerate(today,exercise,FdBlackScholesVanillaEngine::Spot);
    testFdDegenerate(today,exercise,FdBlackScholesVanillaEngine::Escrowed);
}

void DividendOptionTest::testFdAmericanDegenerate() {

    BOOST_TEST_MESSAGE(
         "Testing degenerate finite-differences dividend American option...");

    SavedSettings backup;

    Date today = Date(27,February,2005);
    Settings::instance().evaluationDate() = today;
    Date exDate(13,April,2005);

    ext::shared_ptr<Exercise> exercise(new AmericanExercise(today,exDate));

    testFdDegenerate(today,exercise,FdBlackScholesVanillaEngine::Spot);
    testFdDegenerate(today,exercise,FdBlackScholesVanillaEngine::Escrowed);
}


namespace {

    void testFdDividendAtTZero(const Date& today,
                               const ext::shared_ptr<Exercise>& exercise,
                               FdBlackScholesVanillaEngine::CashDividendModel model) {

        DayCounter dc = Actual360();
        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(54.625));
        Handle<YieldTermStructure> rTS(flatRate(0.0, dc));
        Handle<BlackVolTermStructure> volTS(flatVol(0.282922, dc));

        ext::shared_ptr<BlackScholesMertonProcess> process(
                            new BlackScholesMertonProcess(Handle<Quote>(spot),
                                                          rTS, rTS, volTS));

        Size timeSteps = 50;
        Size gridPoints = 400;

        ext::shared_ptr<PricingEngine> engine =
              MakeFdBlackScholesVanillaEngine(process)
              .withTGrid(timeSteps)
              .withXGrid(gridPoints)
              .withCashDividendModel(model);

        ext::shared_ptr<StrikedTypePayoff> payoff(
                                  new PlainVanillaPayoff(Option::Call, 55.0));

        // today's dividend must by taken into account
        std::vector<Rate> dividends(1, 1.0);
        std::vector<Date> dividendDates(1, today);

        DividendVanillaOption option(payoff, exercise,
                                     dividendDates, dividends);
        option.setPricingEngine(engine);
        Real calculated = option.NPV();

        switch(model) {
          case FdBlackScholesVanillaEngine::Spot:
            BOOST_CHECK_THROW(option.theta(), QuantLib::Error);
            break;
          case FdBlackScholesVanillaEngine::Escrowed:
            BOOST_CHECK_NO_THROW(option.theta());
            break;
          default:
            QL_FAIL("unknown dividend model type");
        }

        ext::shared_ptr<Exercise> europeanExercise =
            ext::make_shared<EuropeanExercise>(exercise->lastDate());
        DividendVanillaOption europeanOption(
            payoff, europeanExercise, dividendDates, dividends);

        europeanOption.setPricingEngine(
            ext::make_shared<AnalyticDividendEuropeanEngine>(process));

        Real expected = europeanOption.NPV();

        const Real tol = 1e-4;

        if (std::fabs(calculated-expected) > tol) {
            BOOST_ERROR("Can not reproduce reference values "
                        "from analytic dividend engine :\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected  : " << expected << "\n"
                       << "    diff:       " << tol);
        }
    }
}


void DividendOptionTest::testFdEuropeanWithDividendToday() {

    BOOST_TEST_MESSAGE(
         "Testing finite-differences dividend European option with dividend on today's date...");

    SavedSettings backup;

    Date today = Date(27,February,2005);
    Settings::instance().evaluationDate() = today;
    Date exDate(13,April,2005);

    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

    testFdDividendAtTZero(today,exercise,FdBlackScholesVanillaEngine::Spot);
    testFdDividendAtTZero(today,exercise,FdBlackScholesVanillaEngine::Escrowed);
}

void DividendOptionTest::testFdAmericanWithDividendToday() {

    BOOST_TEST_MESSAGE(
         "Testing finite-differences dividend American option with dividend on today's date...");

    SavedSettings backup;

    Date today = Date(27,February,2005);
    Settings::instance().evaluationDate() = today;
    Date exDate(13,April,2005);

    ext::shared_ptr<Exercise> exercise(new AmericanExercise(today,exDate));

    testFdDividendAtTZero(today,exercise,FdBlackScholesVanillaEngine::Spot);
}


void DividendOptionTest::testEscrowedDividendModel() {
    BOOST_TEST_MESSAGE("Testing finite-difference European engine "
                       "with the escrowed dividend model...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(12, October, 2019);

    Settings::instance().evaluationDate() = today;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(100.0));
    const Handle<YieldTermStructure> qTS(flatRate(today, 0.063, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, 0.094, dc));
    const Handle<BlackVolTermStructure> volTS(flatVol(today, 0.3, dc));

    const Date maturity = today + Period(1, Years);

    const ext::shared_ptr<BlackScholesMertonProcess> process =
        ext::make_shared<BlackScholesMertonProcess>(
            spot, qTS, rTS, volTS);

    const ext::shared_ptr<PlainVanillaPayoff> payoff(
        ext::make_shared<PlainVanillaPayoff>(Option::Put, spot->value()));

    const ext::shared_ptr<Exercise> exercise(
        ext::make_shared<EuropeanExercise>(maturity));

    std::vector<Date> dividendDates = {today + Period(3, Months), today + Period(9, Months)};
    std::vector<Real> dividendAmounts = {8.3, 6.8};

    DividendVanillaOption option(
        payoff, exercise, dividendDates, dividendAmounts);

    option.setPricingEngine(
        ext::make_shared<AnalyticDividendEuropeanEngine>(process));

    const Real analyticNPV = option.NPV();
    const Real analyticDelta = option.delta();

    option.setPricingEngine(
        MakeFdBlackScholesVanillaEngine(process)
            .withTGrid(50)
            .withXGrid(200)
            .withDampingSteps(1)
            .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed)
        );

    const Real pdeNPV = option.NPV();
    const Real pdeDelta = option.delta();

    const Real tol = 0.0025;
    if (std::fabs(pdeNPV - analyticNPV) > tol) {
        BOOST_FAIL("Failed to reproduce European option values "
                "with the escrowed dividend model and the "
                "FdBlackScholesVanillaEngine engine"
                   << "\n    calculated: " << pdeNPV
                   << "\n    expected:   " << analyticNPV
                   << "\n    difference: " << std::fabs(pdeNPV - analyticNPV)
                   << "\n    tolerance:  " << tol);
    }

    if (std::fabs(pdeDelta - analyticDelta) > tol) {
        BOOST_FAIL("Failed to reproduce European option deltas "
                "with the escrowed dividend model and the "
                "FdBlackScholesVanillaEngine engine"
                   << "\n    calculated: " << pdeNPV
                   << "\n    expected:   " << analyticNPV
                   << "\n    difference: " << std::fabs(pdeNPV - analyticNPV)
                   << "\n    tolerance:  " << tol);
    }
}

test_suite* DividendOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Dividend European option tests");
    suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testEuropeanValues));
    // Doesn't quite work.  Need to deal with date conventions
    //  suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testEuropeanKnownValue));
    suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testEuropeanStartLimit));
    // Doesn't quite work.  Need to use discounted values
    //suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testEuropeanEndLimit));
    suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testEuropeanGreeks));
    suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testFdEuropeanValues));
    suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testFdEuropeanGreeks));
    suite->add(QUANTLIB_TEST_CASE(&DividendOptionTest::testFdAmericanGreeks));
    suite->add(QUANTLIB_TEST_CASE(
                              &DividendOptionTest::testFdEuropeanDegenerate));
    suite->add(QUANTLIB_TEST_CASE(
                              &DividendOptionTest::testFdAmericanDegenerate));
    suite->add(QUANTLIB_TEST_CASE(
                              &DividendOptionTest::testFdEuropeanWithDividendToday));
    suite->add(QUANTLIB_TEST_CASE(
                              &DividendOptionTest::testFdAmericanWithDividendToday));
    suite->add(QUANTLIB_TEST_CASE(
                 &DividendOptionTest::testEscrowedDividendModel));

    return suite;
}

]]></document_content>
  </document>
  <document index="88">
    <source>dividendoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_dividend_option_hpp
#define quantlib_test_dividend_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DividendOptionTest {
  public:
    static void testEuropeanValues();
    static void testEuropeanKnownValue();
    static void testEuropeanStartLimit();
    static void testEuropeanEndLimit();
    static void testEuropeanGreeks();
    static void testFdEuropeanValues();
    static void testFdEuropeanGreeks();
    static void testFdAmericanGreeks();
    static void testFdEuropeanDegenerate();
    static void testFdAmericanDegenerate();
    static void testFdEuropeanWithDividendToday();
    static void testFdAmericanWithDividendToday();
    static void testEscrowedDividendModel();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="89">
    <source>doublebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "doublebarrieroption.hpp"
#include "utilities.hpp"
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/binomialdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/wulinyongdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/vannavolgadoublebarrierengine.hpp>
#include <ql/experimental/finitedifferences/fdhestondoublebarrierengine.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancecurve.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancesurface.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/experimental/barrieroption/mcdoublebarrierengine.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, barrierType, barrierlo, barrierhi, \
                       payoff, exercise, s, q, r, today, v, expected, \
                       calculated, error, tolerance) \
    BOOST_ERROR("\n" << barrierType << " " \
               << exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    underlying value: " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    barrier low:      " << barrierlo << "\n" \
               << "    barrier high:     " << barrierhi << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

#undef REPORT_FAILURE_VANNAVOLGA
#define REPORT_FAILURE_VANNAVOLGA(greekName, barrierType, \
                                  barrier1, barrier2, rebate, payoff, \
                                  exercise, s, q, r, today, \
                                  vol25Put, atmVol, vol25Call, v, \
                                  expected, calculated, error, tolerance) \
    BOOST_ERROR("\n" <<"Double Barrier Option " \
               << barrierType << " " \
               << exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    underlying value: " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    barrier1:         " << barrier1 << "\n" \
               << "    barrier2:         " << barrier2 << "\n" \
               << "    rebate:           " << rebate << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    25PutVol:         " << io::volatility(vol25Put) << "\n" \
               << "    atmVol:           " << io::volatility(atmVol) << "\n" \
               << "    25CallVol:        " << io::volatility(vol25Call) << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

#undef REPORT_FAILURE_DOUBLE_BARRIER_MC
#define REPORT_FAILURE_DOUBLE_BARRIER_MC(analytical, monteCarlo, diff) \
    BOOST_ERROR("\n" <<"Double Barrier Option " \
                << "Threshold exceeded: " << diff << "\n" \
                << "Analytical: " << analytical << "\n" \
                << "Monte Carlo: " << monteCarlo << "\n");

namespace double_barrier_option_test {

    struct NewBarrierOptionData {
        DoubleBarrier::Type barrierType;
        Real barrierlo;
        Real barrierhi;
        Option::Type type;
        Exercise::Type exType;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // result
        Real tol;      // tolerance
    };

    struct DoubleBarrierFxOptionData {
        DoubleBarrier::Type barrierType;
        Real barrier1;
        Real barrier2;
        Real rebate;
        Option::Type type;
        Real strike;
        Real s;                 // spot
        Rate q;                 // dividend
        Rate r;                 // risk-free rate
        Time t;                 // time to maturity
        Volatility vol25Put;    // 25 delta put vol
        Volatility volAtm;      // atm vol
        Volatility vol25Call;   // 25 delta call vol
        Volatility v;           // volatility at strike
        Real result;            // result
        Real tol;               // tolerance
    };

}


void DoubleBarrierOptionTest::testEuropeanHaugValues() {

    BOOST_TEST_MESSAGE("Testing double barrier european options against Haug's values...");

    using namespace double_barrier_option_test;

    Exercise::Type european = Exercise::European;
    NewBarrierOptionData values[] = {
        /* The data below are from
          "The complete guide to option pricing formulas 2nd Ed",E.G. Haug, McGraw-Hill, p.156 and following. 

          Note:
          The book uses b instead of q (q=r-b)
        */
        //           BarrierType, barr.lo,  barr.hi,         type, exercise,strk,     s,   q,   r,    t,    v,  result, tol
        { DoubleBarrier::KnockOut,   50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  4.3515, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  6.1644, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  7.0373, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  6.9853, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  7.9336, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  6.5088, 1.0e-4},

        { DoubleBarrier::KnockOut,   60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  4.3505, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  5.8500, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  5.7726, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  6.8082, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  6.3383, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  4.3841, 1.0e-4},

        { DoubleBarrier::KnockOut,   70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  4.3139, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  4.8293, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  3.7765, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  5.9697, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  4.0004, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  2.2563, 1.0e-4},

        { DoubleBarrier::KnockOut,   80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  3.7516, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  2.6387, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  1.4903, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  3.5805, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  1.5098, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  0.5635, 1.0e-4},

        { DoubleBarrier::KnockOut,   90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  1.2055, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  0.3098, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  0.0477, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  0.5537, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  0.0441, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  0.0011, 1.0e-4},

        //           BarrierType, barr.lo,  barr.hi,         type, exercise,strk,     s,   q,   r,    t,    v,  result, tol
        { DoubleBarrier::KnockOut,   50.0,    150.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  1.8825, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  3.7855, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  5.7191, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  2.1374, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  4.7033, 1.0e-4},
        { DoubleBarrier::KnockOut,   50.0,    150.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  7.1683, 1.0e-4},

        { DoubleBarrier::KnockOut,   60.0,    140.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  1.8825, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  3.7845, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  5.6060, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  2.1374, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  4.6236, 1.0e-4},
        { DoubleBarrier::KnockOut,   60.0,    140.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  6.1062, 1.0e-4},

        { DoubleBarrier::KnockOut,   70.0,    130.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  1.8825, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  3.7014, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  4.6472, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  2.1325, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  3.8944, 1.0e-4},
        { DoubleBarrier::KnockOut,   70.0,    130.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  3.5868, 1.0e-4},

        { DoubleBarrier::KnockOut,   80.0,    120.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  1.8600, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  2.6866, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  2.0719, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  1.8883, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  1.7851, 1.0e-4},
        { DoubleBarrier::KnockOut,   80.0,    120.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  0.8244, 1.0e-4},

        { DoubleBarrier::KnockOut,   90.0,    110.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  0.9473, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  0.3449, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  0.0578, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  0.4555, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  0.0491, 1.0e-4},
        { DoubleBarrier::KnockOut,   90.0,    110.0,  Option::Put, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  0.0013, 1.0e-4},

        //           BarrierType, barr.lo,  barr.hi,         type,  strk,     s,   q,   r,    t,    v,  result, tol
        { DoubleBarrier::KnockIn,    50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  0.0000, 1.0e-4},
        { DoubleBarrier::KnockIn,    50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  0.0900, 1.0e-4},
        { DoubleBarrier::KnockIn,    50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  1.1537, 1.0e-4},
        { DoubleBarrier::KnockIn,    50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  0.0292, 1.0e-4},
        { DoubleBarrier::KnockIn,    50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  1.6487, 1.0e-4},
        { DoubleBarrier::KnockIn,    50.0,    150.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  5.7321, 1.0e-4},
                             
        { DoubleBarrier::KnockIn,    60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  0.0010, 1.0e-4},
        { DoubleBarrier::KnockIn,    60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  0.4045, 1.0e-4},
        { DoubleBarrier::KnockIn,    60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  2.4184, 1.0e-4},
        { DoubleBarrier::KnockIn,    60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  0.2062, 1.0e-4},
        { DoubleBarrier::KnockIn,    60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  3.2439, 1.0e-4},
        { DoubleBarrier::KnockIn,    60.0,    140.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  7.8569, 1.0e-4},
                             
        { DoubleBarrier::KnockIn,    70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  0.0376, 1.0e-4},
        { DoubleBarrier::KnockIn,    70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  1.4252, 1.0e-4},
        { DoubleBarrier::KnockIn,    70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  4.4145, 1.0e-4},
        { DoubleBarrier::KnockIn,    70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  1.0447, 1.0e-4},
        { DoubleBarrier::KnockIn,    70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  5.5818, 1.0e-4},
        { DoubleBarrier::KnockIn,    70.0,    130.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35,  9.9846, 1.0e-4},
                             
        { DoubleBarrier::KnockIn,    80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  0.5999, 1.0e-4},
        { DoubleBarrier::KnockIn,    80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  3.6158, 1.0e-4},
        { DoubleBarrier::KnockIn,    80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  6.7007, 1.0e-4},
        { DoubleBarrier::KnockIn,    80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  3.4340, 1.0e-4},
        { DoubleBarrier::KnockIn,    80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  8.0724, 1.0e-4},
        { DoubleBarrier::KnockIn,    80.0,    120.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35, 11.6774, 1.0e-4},
                             
        { DoubleBarrier::KnockIn,    90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.15,  3.1460, 1.0e-4},
        { DoubleBarrier::KnockIn,    90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.25,  5.9447, 1.0e-4},
        { DoubleBarrier::KnockIn,    90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.25, 0.35,  8.1432, 1.0e-4},
        { DoubleBarrier::KnockIn,    90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.15,  6.4608, 1.0e-4},
        { DoubleBarrier::KnockIn,    90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.25,  9.5382, 1.0e-4},
        { DoubleBarrier::KnockIn,    90.0,    110.0, Option::Call, european, 100, 100.0, 0.0, 0.1, 0.50, 0.35, 12.2398, 1.0e-4},
                             
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        DoubleBarrierOption opt(value.barrierType, value.barrierlo, value.barrierhi,
                                0, // no rebate
                                payoff, exercise);

        // Ikeda/Kunitomo engine
        ext::shared_ptr<PricingEngine> engine(
                                     new AnalyticDoubleBarrierEngine(stochProcess));
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE("Ikeda/Kunitomo value", value.barrierType, value.barrierlo,
                           value.barrierhi, payoff, exercise, value.s, value.q, value.r, today,
                           value.v, expected, calculated, error, value.tol);
        }

        // Wulin Suo/Yong Wang engine
        engine = ext::shared_ptr<PricingEngine>(
                                     new WulinYongDoubleBarrierEngine(stochProcess));
        opt.setPricingEngine(engine);

        calculated = opt.NPV();
        expected = value.result;
        error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE("Wulin/Yong value", value.barrierType, value.barrierlo, value.barrierhi,
                           payoff, exercise, value.s, value.q, value.r, today, value.v, expected,
                           calculated, error, value.tol);
        }

        engine = ext::shared_ptr<PricingEngine>(
              new BinomialDoubleBarrierEngine<CoxRossRubinstein,
                              DiscretizedDoubleBarrierOption>(stochProcess, 
                                                                 300));
        opt.setPricingEngine(engine);
        calculated = opt.NPV();
        expected = value.result;
        error = std::fabs(calculated-expected);
        double tol = 0.28;
        if (error>tol) {
            REPORT_FAILURE("Binomial value", value.barrierType, value.barrierlo, value.barrierhi,
                           payoff, exercise, value.s, value.q, value.r, today, value.v, expected,
                           calculated, error, tol);
        }

        engine = ext::shared_ptr<PricingEngine>(
              new BinomialDoubleBarrierEngine<CoxRossRubinstein,
                           DiscretizedDermanKaniDoubleBarrierOption>(
                                                stochProcess, 300));
        opt.setPricingEngine(engine);
        calculated = opt.NPV();
        expected = value.result;
        error = std::fabs(calculated-expected);
        tol = 0.033; // error one order of magnitude lower than plain binomial
        if (error>tol) {
            REPORT_FAILURE("Binomial (Derman) value", value.barrierType, value.barrierlo,
                           value.barrierhi, payoff, exercise, value.s, value.q, value.r, today,
                           value.v, expected, calculated, error, tol);
        }

        if (value.barrierType == DoubleBarrier::KnockOut) {
            engine = ext::make_shared<FdHestonDoubleBarrierEngine>(
                ext::make_shared<HestonModel>(
                    ext::make_shared<HestonProcess>(
                        Handle<YieldTermStructure>(rTS),
                        Handle<YieldTermStructure>(qTS),
                        Handle<Quote>(spot),
                        square<Real>()(vol->value()), 1.0,
                        square<Real>()(vol->value()), 0.001, 0.0)), 251, 76, 3);

            opt.setPricingEngine(engine);
            calculated = opt.NPV();
            expected = value.result;
            error = std::fabs(calculated-expected);

            tol = 0.025; // error one order of magnitude lower than plain binomial
            if (error>tol) {
                REPORT_FAILURE("Heston value", value.barrierType, value.barrierlo, value.barrierhi,
                               payoff, exercise, value.s, value.q, value.r, today, value.v,
                               expected, calculated, error, tol);
            }
        }
    }
}

void DoubleBarrierOptionTest::testVannaVolgaDoubleBarrierValues() {
    BOOST_TEST_MESSAGE(
         "Testing double-barrier FX options against Vanna/Volga values...");

    using namespace double_barrier_option_test;

    SavedSettings backup;

    DoubleBarrierFxOptionData values[] = {

        //            BarrierType, barr.1, barr.2, rebate,         type,    strike,          s,         q,         r,  t, vol25Put,    volAtm,vol25Call,      vol,    result,   tol

        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Call,   1.13321,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.11638,   0.14413, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Call,   1.22687,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.10088,   0.07456, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Call,   1.31179,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.08925,   0.02710, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Call,   1.38843,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.08463,   0.00569, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Call,   1.46047,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.08412,   0.00013, 1.0e-4},

        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Put,   1.13321,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.11638,    0.00017, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Put,   1.22687,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.10088,    0.00353, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Put,   1.31179,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.08925,    0.02221, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Put,   1.38843,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.08463,    0.06049, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.1,    1.5,    0.0, Option::Put,   1.46047,    1.30265, 0.0003541, 0.0033871, 1.0, 0.10087,   0.08925, 0.08463,   0.08412,    0.11103, 1.0e-4},

        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Call,   1.06145,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.12511,   0.19981, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Call,   1.19545,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.10890,   0.10389, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Call,   1.32238,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.09444,   0.03555, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Call,   1.44298,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.09197,   0.00634, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Call,   1.56345,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.09261,   0.00000, 1.0e-4},

        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Put,   1.06145,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.12511,    0.00000, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Put,   1.19545,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.10890,    0.00436, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Put,   1.32238,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.09444,    0.03173, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Put,   1.44298,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.09197,    0.09346, 1.0e-4},
        { DoubleBarrier::KnockOut,    1.0,    1.6,    0.0, Option::Put,   1.56345,    1.30265, 0.0009418, 0.0039788, 2.0, 0.10891,   0.09525, 0.09197,   0.09261,    0.17704, 1.0e-4}

    };

    DayCounter dc = Actual360();
    Date today(05, Mar, 2013);
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<SimpleQuote> qRate = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol25Put = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<SimpleQuote> volAtm = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<SimpleQuote> vol25Call = ext::make_shared<SimpleQuote>(0.0);

    for (auto& value : values) {

        for (Size j=0; j<=1; j++) {

            auto barrierType = static_cast<DoubleBarrier::Type>(j);

            spot->setValue(value.s);
            qRate->setValue(value.q);
            rRate->setValue(value.r);
            vol25Put->setValue(value.vol25Put);
            volAtm->setValue(value.volAtm);
            vol25Call->setValue(value.vol25Call);

            ext::shared_ptr<StrikedTypePayoff> payoff =
                ext::make_shared<PlainVanillaPayoff>(value.type, value.strike);

            Date exDate = today + timeToDays(value.t, 365);
            ext::shared_ptr<Exercise> exercise =
                ext::make_shared<EuropeanExercise>(exDate);

            Handle<DeltaVolQuote> volAtmQuote = Handle<DeltaVolQuote>(
                ext::make_shared<DeltaVolQuote>(Handle<Quote>(volAtm), DeltaVolQuote::Fwd, value.t,
                                                DeltaVolQuote::AtmDeltaNeutral));

            // always delta neutral atm
            Handle<DeltaVolQuote> vol25PutQuote(
                Handle<DeltaVolQuote>(ext::make_shared<DeltaVolQuote>(
                    -0.25, Handle<Quote>(vol25Put), value.t, DeltaVolQuote::Fwd)));

            Handle<DeltaVolQuote> vol25CallQuote(
                Handle<DeltaVolQuote>(ext::make_shared<DeltaVolQuote>(
                    0.25, Handle<Quote>(vol25Call), value.t, DeltaVolQuote::Fwd)));

            DoubleBarrierOption doubleBarrierOption(barrierType, value.barrier1, value.barrier2,
                                                    value.rebate, payoff, exercise);

            Real bsVanillaPrice =
                blackFormula(value.type, value.strike,
                             spot->value() * qTS->discount(value.t) / rTS->discount(value.t),
                             value.v * sqrt(value.t), rTS->discount(value.t));
            ext::shared_ptr<PricingEngine> vannaVolgaEngine =
                ext::make_shared<VannaVolgaDoubleBarrierEngine<WulinYongDoubleBarrierEngine> >(
                                volAtmQuote,
                                vol25PutQuote,
                                vol25CallQuote,
                                Handle<Quote> (spot),
                                Handle<YieldTermStructure> (rTS),
                                Handle<YieldTermStructure> (qTS),
                                true,
                                bsVanillaPrice);
            doubleBarrierOption.setPricingEngine(vannaVolgaEngine);

            // Expected result for KO is given in array, for KI is evaluated as vanilla - KO
            Real expected = 0;
            if (barrierType == DoubleBarrier::KnockOut)
                expected = value.result;
            else if (barrierType == DoubleBarrier::KnockIn)
                expected = (bsVanillaPrice - value.result);

            Real calculated = doubleBarrierOption.NPV();
            Real error = std::fabs(calculated-expected);
            if (error > value.tol) {
                REPORT_FAILURE_VANNAVOLGA("value", barrierType, value.barrier1, value.barrier2,
                                          value.rebate, payoff, exercise, value.s, value.q, value.r,
                                          today, value.vol25Put, value.volAtm, value.vol25Call,
                                          value.v, expected, calculated, error, value.tol);
            }

            vannaVolgaEngine =
                ext::make_shared<VannaVolgaDoubleBarrierEngine<AnalyticDoubleBarrierEngine> >(
                                volAtmQuote,
                                vol25PutQuote,
                                vol25CallQuote,
                                Handle<Quote> (spot),
                                Handle<YieldTermStructure> (rTS),
                                Handle<YieldTermStructure> (qTS),
                                true,
                                bsVanillaPrice);
            doubleBarrierOption.setPricingEngine(vannaVolgaEngine);

            calculated = doubleBarrierOption.NPV();
            error = std::fabs(calculated-expected);
            Real maxtol = 5.0e-3; // different engines have somewhat different results
            if (error>maxtol) {
                REPORT_FAILURE_VANNAVOLGA("value", barrierType, value.barrier1, value.barrier2,
                                          value.rebate, payoff, exercise, value.s, value.q, value.r,
                                          today, value.vol25Put, value.volAtm, value.vol25Call,
                                          value.v, expected, calculated, error, value.tol);
            }
        }
    }
}

void DoubleBarrierOptionTest::testMonteCarloDoubleBarrierWithAnalytical() {
    BOOST_TEST_MESSAGE("Testing MC double-barrier options against analytical values...");

    using namespace double_barrier_option_test;

    SavedSettings backup;

    Real tolerance = 0.01; //percentage difference between analytical and monte carlo values to be tolerated

    // set up dates
    Calendar calendar = TARGET();
    Date todaysDate(15, May, 1998);
    Date settlementDate(17, May, 1998);
    Settings::instance().evaluationDate() = todaysDate;

    // our options
    Option::Type type(Option::Put);
    Real underlying = 36;
    Real strike = 40;
    Spread dividendYield = 0.00;
    Rate riskFreeRate = 0.06;
    Volatility volatility = 0.20;
    Date maturity(17, May, 1999);
    DayCounter dayCounter = Actual365Fixed();

    std::vector<Date> exerciseDates;
    for (Integer i=1; i<=4; i++)
        exerciseDates.push_back(settlementDate + 3*i*Months);

    ext::shared_ptr<Exercise> europeanExercise(
        new EuropeanExercise(maturity));

    Handle<Quote> underlyingH(
        ext::shared_ptr<Quote>(new SimpleQuote(underlying)));

    // bootstrap the yield/dividend/vol curves
    Handle<YieldTermStructure> flatTermStructure(
        ext::shared_ptr<YieldTermStructure>(
            new FlatForward(settlementDate, riskFreeRate, dayCounter)));
    Handle<YieldTermStructure> flatDividendTS(
        ext::shared_ptr<YieldTermStructure>(
            new FlatForward(settlementDate, dividendYield, dayCounter)));
    Handle<BlackVolTermStructure> flatVolTS(
        ext::shared_ptr<BlackVolTermStructure>(
            new BlackConstantVol(settlementDate, calendar, volatility,
                                 dayCounter)));
    ext::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(type, strike));
    ext::shared_ptr<BlackScholesMertonProcess> bsmProcess(
        new BlackScholesMertonProcess(underlyingH, flatDividendTS,
                                      flatTermStructure, flatVolTS));

    Real barrierLow = underlying * 0.9;
    Real barrierHigh = underlying * 1.1;

    DoubleBarrierOption knockIndoubleBarrierOption(DoubleBarrier::KnockIn,
                                                   barrierLow,
                                                   barrierHigh,
                                                   0,
                                                   payoff,
                                                   europeanExercise);

    ext::shared_ptr<PricingEngine> analyticdoublebarrierengine(new AnalyticDoubleBarrierEngine(bsmProcess));
    knockIndoubleBarrierOption.setPricingEngine(analyticdoublebarrierengine);
    Real analytical = knockIndoubleBarrierOption.NPV();

    ext::shared_ptr<PricingEngine> mcdoublebarrierengine;
    mcdoublebarrierengine = MakeMCDoubleBarrierEngine<PseudoRandom>(bsmProcess)
        .withSteps(5000)
        .withAntitheticVariate()
        .withAbsoluteTolerance(0.5)
        .withSeed(1);
    knockIndoubleBarrierOption.setPricingEngine(mcdoublebarrierengine);
    Real monteCarlo = knockIndoubleBarrierOption.NPV();

    Real percentageDiff = std::abs(analytical - monteCarlo) / analytical;

    if (percentageDiff > tolerance){
        REPORT_FAILURE_DOUBLE_BARRIER_MC(analytical, monteCarlo, percentageDiff);
    }

    DoubleBarrierOption knockOutDoubleBarrierOption(DoubleBarrier::KnockOut,
                                                    barrierLow,
                                                    barrierHigh,
                                                    0,
                                                    payoff,
                                                    europeanExercise);

    knockOutDoubleBarrierOption.setPricingEngine(analyticdoublebarrierengine);
    analytical = knockOutDoubleBarrierOption.NPV();

    tolerance = 0.01;

    mcdoublebarrierengine = MakeMCDoubleBarrierEngine<PseudoRandom>(bsmProcess)
        .withSteps(10000)
        .withAntitheticVariate()
        .withAbsoluteTolerance(tolerance)
        .withSeed(10);
    knockOutDoubleBarrierOption.setPricingEngine(mcdoublebarrierengine);
    monteCarlo = knockOutDoubleBarrierOption.NPV();

    Real diff = std::abs(analytical - monteCarlo);

    if (diff > tolerance){
        REPORT_FAILURE_DOUBLE_BARRIER_MC(analytical, monteCarlo, diff);
    }

}

test_suite* DoubleBarrierOptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("DoubleBarrier");

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&DoubleBarrierOptionTest::testEuropeanHaugValues));
    }

    return suite;
}

test_suite* DoubleBarrierOptionTest::experimental(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("DoubleBarrier_experimental");
    suite->add(QUANTLIB_TEST_CASE(&DoubleBarrierOptionTest::testVannaVolgaDoubleBarrierValues));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&DoubleBarrierOptionTest::testMonteCarloDoubleBarrierWithAnalytical));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="90">
    <source>doublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_double_barrier_option_hpp
#define quantlib_test_double_barrier_option_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DoubleBarrierOptionTest {
  public:
    static void testEuropeanHaugValues();
    static void testVannaVolgaDoubleBarrierValues();
    static void testMonteCarloDoubleBarrierWithAnalytical();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
    static boost::unit_test_framework::test_suite* experimental(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="91">
    <source>doublebinaryoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "doublebinaryoption.hpp"
#include "utilities.hpp"
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.hpp>
#include <ql/experimental/barrieroption/binomialdoublebarrierengine.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, barrierType, barrier_lo, \
                        barrier_hi, s, q, r, today, v, expected, calculated, \
                        error, tolerance) \
    BOOST_ERROR(payoff->optionType() << " option with " \
               << barrierType << " barrier type:\n" \
               << "    barrier_lo:       " << barrier_lo << "\n" \
               << "    barrier_hi:       " << barrier_hi << "\n" \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:       " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance << "\n");

namespace {

    struct DoubleBinaryOptionData {
        DoubleBarrier::Type barrierType;
        Real barrier_lo;
        Real barrier_hi;
        Real cash;     // cash payoff for cash-or-nothing
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real result;   // expected result
        Real tol;      // tolerance
    };
}


void DoubleBinaryOptionTest::testHaugValues() {

    BOOST_TEST_MESSAGE("Testing cash-or-nothing double barrier options against Haug's values...");

    DoubleBinaryOptionData values[] = {
        /* The data below are from
          "Option pricing formulas 2nd Ed.", E.G. Haug, McGraw-Hill 2007 pag. 181
          Note: book uses cost of carry b, instead of dividend rate q
        */
        //    barrierType,          bar_lo, bar_hi,  cash,   spot,    q,    r,    t,  vol,   value, tol
        { DoubleBarrier::KnockOut,   80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  9.8716, 1e-4 },
        { DoubleBarrier::KnockOut,   80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  8.9307, 1e-4 },
        { DoubleBarrier::KnockOut,   80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  6.3272, 1e-4 },
        { DoubleBarrier::KnockOut,   80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  1.9094, 1e-4 },

        { DoubleBarrier::KnockOut,   85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  9.7961, 1e-4 },
        { DoubleBarrier::KnockOut,   85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  7.2300, 1e-4 },
        { DoubleBarrier::KnockOut,   85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  3.7100, 1e-4 },
        { DoubleBarrier::KnockOut,   85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  0.4271, 1e-4 },

        { DoubleBarrier::KnockOut,   90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  8.9054, 1e-4 },
        { DoubleBarrier::KnockOut,   90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  3.6752, 1e-4 },
        { DoubleBarrier::KnockOut,   90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  0.7960, 1e-4 },
        { DoubleBarrier::KnockOut,   90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  0.0059, 1e-4 },

        { DoubleBarrier::KnockOut,   95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  3.6323, 1e-4 },
        { DoubleBarrier::KnockOut,   95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  0.0911, 1e-4 },
        { DoubleBarrier::KnockOut,   95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  0.0002, 1e-4 },
        { DoubleBarrier::KnockOut,   95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  0.0000, 1e-4 },

        { DoubleBarrier::KIKO,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.0000, 1e-4 },
        { DoubleBarrier::KIKO,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  0.2402, 1e-4 },
        { DoubleBarrier::KIKO,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  1.4076, 1e-4 },
        { DoubleBarrier::KIKO,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  3.8160, 1e-4 },

        { DoubleBarrier::KIKO,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.0075, 1e-4 },
        { DoubleBarrier::KIKO,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  0.9910, 1e-4 },
        { DoubleBarrier::KIKO,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  2.8098, 1e-4 },
        { DoubleBarrier::KIKO,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  4.6612, 1e-4 },

        { DoubleBarrier::KIKO,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.2656, 1e-4 },
        { DoubleBarrier::KIKO,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  2.7954, 1e-4 },
        { DoubleBarrier::KIKO,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  4.4024, 1e-4 },
        { DoubleBarrier::KIKO,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  4.9266, 1e-4 },

        { DoubleBarrier::KIKO,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  2.6285, 1e-4 },
        { DoubleBarrier::KIKO,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  4.7523, 1e-4 },
        { DoubleBarrier::KIKO,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  4.9096, 1e-4 },
        { DoubleBarrier::KIKO,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  4.9675, 1e-4 },

        // following values calculated with haug's VBA code
        { DoubleBarrier::KnockIn,    80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.0042, 1e-4 },
        { DoubleBarrier::KnockIn,    80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  0.9450, 1e-4 },
        { DoubleBarrier::KnockIn,    80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  3.5486, 1e-4 },
        { DoubleBarrier::KnockIn,    80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  7.9663, 1e-4 },

        { DoubleBarrier::KnockIn,    85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.0797, 1e-4 },
        { DoubleBarrier::KnockIn,    85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  2.6458, 1e-4 },
        { DoubleBarrier::KnockIn,    85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  6.1658, 1e-4 },
        { DoubleBarrier::KnockIn,    85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  9.4486, 1e-4 },

        { DoubleBarrier::KnockIn,    90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.9704, 1e-4 },
        { DoubleBarrier::KnockIn,    90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  6.2006, 1e-4 },
        { DoubleBarrier::KnockIn,    90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  9.0798, 1e-4 },
        { DoubleBarrier::KnockIn,    90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  9.8699, 1e-4 },

        { DoubleBarrier::KnockIn,    95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  6.2434, 1e-4 },
        { DoubleBarrier::KnockIn,    95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  9.7847, 1e-4 },
        { DoubleBarrier::KnockIn,    95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  9.8756, 1e-4 },
        { DoubleBarrier::KnockIn,    95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  9.8758, 1e-4 },

        { DoubleBarrier::KOKI,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.0041, 1e-4 },
        { DoubleBarrier::KOKI,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  0.7080, 1e-4 },
        { DoubleBarrier::KOKI,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  2.1581, 1e-4 },
        { DoubleBarrier::KOKI,       80.00, 120.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  4.2061, 1e-4 },

        { DoubleBarrier::KOKI,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.0723, 1e-4 },
        { DoubleBarrier::KOKI,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  1.6663, 1e-4 },
        { DoubleBarrier::KOKI,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  3.3930, 1e-4 },
        { DoubleBarrier::KOKI,       85.00, 115.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  4.8679, 1e-4 },

        { DoubleBarrier::KOKI,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  0.7080, 1e-4 },
        { DoubleBarrier::KOKI,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  3.4424, 1e-4 },
        { DoubleBarrier::KOKI,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  4.7496, 1e-4 },
        { DoubleBarrier::KOKI,       90.00, 110.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  5.0475, 1e-4 },

        { DoubleBarrier::KOKI,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.10,  3.6524, 1e-4 },
        { DoubleBarrier::KOKI,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.20,  5.1256, 1e-4 },
        { DoubleBarrier::KOKI,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.30,  5.0763, 1e-4 },
        { DoubleBarrier::KOKI,       95.00, 105.00, 10.00, 100.00, 0.02, 0.05, 0.25, 0.50,  5.0275, 1e-4 },

        // degenerate cases
        { DoubleBarrier::KnockOut,   95.00, 105.00, 10.00,  80.00, 0.02, 0.05, 0.25, 0.10,  0.0000, 1e-4 },
        { DoubleBarrier::KnockOut,   95.00, 105.00, 10.00, 110.00, 0.02, 0.05, 0.25, 0.10,  0.0000, 1e-4 },
        { DoubleBarrier::KnockIn,    95.00, 105.00, 10.00,  80.00, 0.02, 0.05, 0.25, 0.10, 10.0000, 1e-4 },
        { DoubleBarrier::KnockIn,    95.00, 105.00, 10.00, 110.00, 0.02, 0.05, 0.25, 0.10, 10.0000, 1e-4 },
        { DoubleBarrier::KIKO,       95.00, 105.00, 10.00,  80.00, 0.02, 0.05, 0.25, 0.10, 10.0000, 1e-4 },
        { DoubleBarrier::KIKO,       95.00, 105.00, 10.00, 110.00, 0.02, 0.05, 0.25, 0.10,  0.0000, 1e-4 },
        { DoubleBarrier::KOKI,       95.00, 105.00, 10.00,  80.00, 0.02, 0.05, 0.25, 0.10,  0.0000, 1e-4 },
        { DoubleBarrier::KOKI,       95.00, 105.00, 10.00, 110.00, 0.02, 0.05, 0.25, 0.10, 10.0000, 1e-4 },
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.25));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new CashOrNothingPayoff(Option::Call, 0, value.cash));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise;
        if (value.barrierType == DoubleBarrier::KIKO || value.barrierType == DoubleBarrier::KOKI)
            exercise.reset(new AmericanExercise(today, exDate));
        else
            exercise.reset(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        // checking with analytic engine
        ext::shared_ptr<PricingEngine> engine(
                             new AnalyticDoubleBarrierBinaryEngine(stochProcess));
        DoubleBarrierOption opt(value.barrierType, value.barrier_lo, value.barrier_hi, 0, payoff,
                                exercise);
        opt.setPricingEngine(engine);

        Real calculated = opt.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE("value", payoff, exercise, value.barrierType, value.barrier_lo,
                           value.barrier_hi, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, value.tol);
        }

        Size steps = 500;
        // checking with binomial engine
        engine = ext::shared_ptr<PricingEngine>(
              new BinomialDoubleBarrierEngine<CoxRossRubinstein,
                              DiscretizedDoubleBarrierOption>(stochProcess, 
                                                                 steps));
        opt.setPricingEngine(engine);
        calculated = opt.NPV();
        expected = value.result;
        error = std::fabs(calculated-expected);
        double tol = 0.22;
        if (error>tol) {
            REPORT_FAILURE("Binomial value", payoff, exercise, value.barrierType, value.barrier_lo,
                           value.barrier_hi, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, tol);
        }
    }
} 


test_suite* DoubleBinaryOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("DoubleBinary");
    suite->add(QUANTLIB_TEST_CASE(&DoubleBinaryOptionTest::testHaugValues));
    return suite;
}
]]></document_content>
  </document>
  <document index="92">
    <source>doublebinaryoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_double_binary_option_hpp
#define quantlib_test_double_binary_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class DoubleBinaryOptionTest {
  public:
    static void testHaugValues();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="93">
    <source>europeanoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2003 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_european_option_hpp
#define quantlib_test_european_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class EuropeanOptionTest {
  public:
    static void testValues();
    static void testGreekValues();
    static void testGreeks();
    static void testImpliedVol();
    static void testImpliedVolContainment();
    static void testJRBinomialEngines();
    static void testCRRBinomialEngines();
    static void testEQPBinomialEngines();
    static void testTGEOBinomialEngines();
    static void testTIANBinomialEngines();
    static void testLRBinomialEngines();
    static void testJOSHIBinomialEngines();
    static void testFdEngines();
    static void testIntegralEngines();
    static void testQmcEngines();
    static void testMcEngines();
    static void testFFTEngines();
    static void testLocalVolatility();
    static void testAnalyticEngineDiscountCurve();
    static void testPDESchemes();
    static void testDouglasVsCrankNicolson();
    static void testFdEngineWithNonConstantParameters();

    static boost::unit_test_framework::test_suite* suite();
    static boost::unit_test_framework::test_suite* experimental();
};


#endif
]]></document_content>
  </document>
  <document index="94">
    <source>everestoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "everestoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/everestoption.hpp>
#include <ql/experimental/exoticoptions/mceverestengine.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void EverestOptionTest::testCached() {

    BOOST_TEST_MESSAGE("Testing Everest option against cached values...");

    Date today = Settings::instance().evaluationDate();

    DayCounter dc = Actual360();
    Date exerciseDate = today+360;
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));

    Real notional = 1.0;
    Rate guarantee = 0.0;
    EverestOption option(notional, guarantee, exercise);

    Handle<YieldTermStructure> riskFreeRate(flatRate(today, 0.05, dc));

    std::vector<ext::shared_ptr<StochasticProcess1D> > processes(4);
    Handle<Quote> dummyUnderlying(ext::shared_ptr<Quote>(
                                                       new SimpleQuote(1.0)));
    processes[0] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
                    dummyUnderlying,
                    Handle<YieldTermStructure>(flatRate(today, 0.01, dc)),
                    riskFreeRate,
                    Handle<BlackVolTermStructure>(flatVol(today, 0.30, dc))));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
                    dummyUnderlying,
                    Handle<YieldTermStructure>(flatRate(today, 0.05, dc)),
                    riskFreeRate,
                    Handle<BlackVolTermStructure>(flatVol(today, 0.35, dc))));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
                    dummyUnderlying,
                    Handle<YieldTermStructure>(flatRate(today, 0.04, dc)),
                    riskFreeRate,
                    Handle<BlackVolTermStructure>(flatVol(today, 0.25, dc))));
    processes[3] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
                    dummyUnderlying,
                    Handle<YieldTermStructure>(flatRate(today, 0.03, dc)),
                    riskFreeRate,
                    Handle<BlackVolTermStructure>(flatVol(today, 0.20, dc))));

    Matrix correlation(4,4);
    correlation[0][0] = 1.00;
                    correlation[0][1] = 0.50;
                                    correlation[0][2] = 0.30;
                                                    correlation[0][3] = 0.10;
    correlation[1][0] = 0.50;
                    correlation[1][1] = 1.00;
                                    correlation[1][2] = 0.20;
                                                    correlation[1][3] = 0.40;
    correlation[2][0] = 0.30;
                    correlation[2][1] = 0.20;
                                    correlation[2][2] = 1.00;
                                                    correlation[2][3] = 0.60;
    correlation[3][0] = 0.10;
                    correlation[3][1] = 0.40;
                                    correlation[3][2] = 0.60;
                                                    correlation[3][3] = 1.00;



    BigNatural seed = 86421;
    Size fixedSamples = 1023;
    Real minimumTol = 1.0e-2;

    ext::shared_ptr<StochasticProcessArray> process(
                          new StochasticProcessArray(processes, correlation));

    option.setPricingEngine(MakeMCEverestEngine<PseudoRandom>(process)
                            .withStepsPerYear(1)
                            .withSamples(fixedSamples)
                            .withSeed(seed));

    Real value = option.NPV();
    Real storedValue = 0.75784944;
    Real tolerance = 1.0e-8;

    if (std::fabs(value-storedValue) > tolerance)
        BOOST_FAIL(std::setprecision(10)
                   << "    calculated value: " << value << "\n"
                   << "    expected:         " << storedValue);

    tolerance = option.errorEstimate();
    tolerance = std::min<Real>(tolerance/2.0, minimumTol*value);

    option.setPricingEngine(MakeMCEverestEngine<PseudoRandom>(process)
                            .withStepsPerYear(1)
                            .withAbsoluteTolerance(tolerance)
                            .withSeed(seed));

    option.NPV();
    Real accuracy = option.errorEstimate();
    if (accuracy > tolerance)
        BOOST_FAIL(std::setprecision(10)
                   << "    reached accuracy: " << accuracy << "\n"
                   << "    expected:         " << tolerance);
}


test_suite* EverestOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Everest-option tests");
    suite->add(QUANTLIB_TEST_CASE(&EverestOptionTest::testCached));
    return suite;
}

]]></document_content>
  </document>
  <document index="95">
    <source>everestoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_everest_option_hpp
#define quantlib_test_everest_option_hpp

#include <boost/test/unit_test.hpp>

class EverestOptionTest {
  public:
    static void testCached();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="96">
    <source>exchangerate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "exchangerate.hpp"
#include "utilities.hpp"
#include <ql/exchangerate.hpp>
#include <ql/currencies/europe.hpp>
#include <ql/currencies/america.hpp>
#include <ql/currencies/asia.hpp>
#include <ql/currencies/exchangeratemanager.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void ExchangeRateTest::testDirect() {

    BOOST_TEST_MESSAGE("Testing direct exchange rates...");

    Currency EUR = EURCurrency(), USD = USDCurrency();

    ExchangeRate eur_usd = ExchangeRate(EUR, USD, 1.2042);

    Money m1 = 50000.0 * EUR;
    Money m2 = 100000.0 * USD;

    Money::conversionType = Money::NoConversion;

    Money calculated = eur_usd.exchange(m1);
    Money expected(m1.value()*eur_usd.rate(), USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    calculated = eur_usd.exchange(m2);
    expected = Money(m2.value()/eur_usd.rate(), EUR);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}

void ExchangeRateTest::testDerived() {

    BOOST_TEST_MESSAGE("Testing derived exchange rates...");

    Currency EUR = EURCurrency(), USD = USDCurrency(), GBP = GBPCurrency();

    ExchangeRate eur_usd = ExchangeRate(EUR, USD, 1.2042);
    ExchangeRate eur_gbp = ExchangeRate(EUR, GBP, 0.6612);

    ExchangeRate derived = ExchangeRate::chain(eur_usd, eur_gbp);

    Money m1 = 50000.0 * GBP;
    Money m2 = 100000.0 * USD;

    Money::conversionType = Money::NoConversion;

    Money calculated = derived.exchange(m1);
    Money expected(m1.value()*eur_usd.rate()/eur_gbp.rate(), USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    calculated = derived.exchange(m2);
    expected = Money(m2.value()*eur_gbp.rate()/eur_usd.rate(), GBP);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}

void ExchangeRateTest::testDirectLookup() {

    BOOST_TEST_MESSAGE("Testing lookup of direct exchange rates...");

    ExchangeRateManager& rateManager = ExchangeRateManager::instance();
    rateManager.clear();

    Currency EUR = EURCurrency(), USD = USDCurrency();

    ExchangeRate eur_usd1 = ExchangeRate(EUR, USD, 1.1983);
    ExchangeRate eur_usd2 = ExchangeRate(USD, EUR, 1.0/1.2042);
    rateManager.add(eur_usd1, Date(4,August,2004));
    rateManager.add(eur_usd2, Date(5,August,2004));

    Money m1 = 50000.0 * EUR;
    Money m2 = 100000.0 * USD;

    Money::conversionType = Money::NoConversion;

    ExchangeRate eur_usd = rateManager.lookup(EUR, USD,
                                              Date(4,August,2004),
                                              ExchangeRate::Direct);
    Money calculated = eur_usd.exchange(m1);
    Money expected(m1.value()*eur_usd1.rate(), USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    eur_usd = rateManager.lookup(EUR, USD,
                                 Date(5,August,2004),
                                 ExchangeRate::Direct);
    calculated = eur_usd.exchange(m1);
    expected = Money(m1.value()/eur_usd2.rate(), USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    ExchangeRate usd_eur = rateManager.lookup(USD, EUR,
                                              Date(4,August,2004),
                                              ExchangeRate::Direct);

    calculated = usd_eur.exchange(m2);
    expected = Money(m2.value()/eur_usd1.rate(), EUR);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    usd_eur = rateManager.lookup(USD, EUR,
                                 Date(5,August,2004),
                                 ExchangeRate::Direct);

    calculated = usd_eur.exchange(m2);
    expected = Money(m2.value()*eur_usd2.rate(), EUR);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}

void ExchangeRateTest::testTriangulatedLookup() {

    BOOST_TEST_MESSAGE("Testing lookup of triangulated exchange rates...");

    ExchangeRateManager& rateManager = ExchangeRateManager::instance();
    rateManager.clear();

    Currency EUR = EURCurrency(), USD = USDCurrency(), ITL = ITLCurrency();

    ExchangeRate eur_usd1 = ExchangeRate(EUR, USD, 1.1983);
    ExchangeRate eur_usd2 = ExchangeRate(EUR, USD, 1.2042);
    rateManager.add(eur_usd1, Date(4,August,2004));
    rateManager.add(eur_usd2, Date(5,August,2004));

    Money m1 = 50000000.0 * ITL;
    Money m2 = 100000.0 * USD;

    Money::conversionType = Money::NoConversion;

    ExchangeRate itl_usd = rateManager.lookup(ITL, USD,
                                              Date(4,August,2004));
    Money calculated = itl_usd.exchange(m1);
    Money expected(m1.value()*eur_usd1.rate()/1936.27, USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    itl_usd = rateManager.lookup(ITL, USD,
                                 Date(5,August,2004));
    calculated = itl_usd.exchange(m1);
    expected = Money(m1.value()*eur_usd2.rate()/1936.27, USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    ExchangeRate usd_itl = rateManager.lookup(USD, ITL,
                                              Date(4,August,2004));

    calculated = usd_itl.exchange(m2);
    expected = Money(m2.value()*1936.27/eur_usd1.rate(), ITL);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    usd_itl = rateManager.lookup(USD, ITL,
                                 Date(5,August,2004));

    calculated = usd_itl.exchange(m2);
    expected = Money(m2.value()*1936.27/eur_usd2.rate(), ITL);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}

void ExchangeRateTest::testSmartLookup() {

    BOOST_TEST_MESSAGE("Testing lookup of derived exchange rates...");

    Currency EUR = EURCurrency(), USD = USDCurrency(), GBP = GBPCurrency(),
             CHF = CHFCurrency(), SEK = SEKCurrency(), JPY = JPYCurrency();

    ExchangeRateManager& rateManager = ExchangeRateManager::instance();
    rateManager.clear();

    ExchangeRate eur_usd1 = ExchangeRate(EUR, USD, 1.1983);
    ExchangeRate eur_usd2 = ExchangeRate(USD, EUR, 1.0/1.2042);
    rateManager.add(eur_usd1, Date(4,August,2004));
    rateManager.add(eur_usd2, Date(5,August,2004));

    ExchangeRate eur_gbp1 = ExchangeRate(GBP, EUR, 1.0/0.6596);
    ExchangeRate eur_gbp2 = ExchangeRate(EUR, GBP, 0.6612);
    rateManager.add(eur_gbp1, Date(4,August,2004));
    rateManager.add(eur_gbp2, Date(5,August,2004));

    ExchangeRate usd_chf1 = ExchangeRate(USD, CHF, 1.2847);
    ExchangeRate usd_chf2 = ExchangeRate(CHF, USD, 1.0/1.2774);
    rateManager.add(usd_chf1, Date(4,August,2004));
    rateManager.add(usd_chf2, Date(5,August,2004));

    ExchangeRate chf_sek1 = ExchangeRate(SEK, CHF, 0.1674);
    ExchangeRate chf_sek2 = ExchangeRate(CHF, SEK, 1.0/0.1677);
    rateManager.add(chf_sek1, Date(4,August,2004));
    rateManager.add(chf_sek2, Date(5,August,2004));

    ExchangeRate jpy_sek1 = ExchangeRate(SEK, JPY, 14.5450);
    ExchangeRate jpy_sek2 = ExchangeRate(JPY, SEK, 1.0/14.6110);
    rateManager.add(jpy_sek1, Date(4,August,2004));
    rateManager.add(jpy_sek2, Date(5,August,2004));

    Money m1 = 100000.0 * USD;
    Money m2 = 100000.0 * EUR;
    Money m3 = 100000.0 * GBP;
    Money m4 = 100000.0 * CHF;
    Money m5 = 100000.0 * SEK;
    Money m6 = 100000.0 * JPY;

    Money::conversionType = Money::NoConversion;

    // two-rate chain

    ExchangeRate usd_sek = rateManager.lookup(USD, SEK,
                                              Date(4,August,2004));
    Money calculated = usd_sek.exchange(m1);
    Money expected(m1.value()*usd_chf1.rate()/chf_sek1.rate(), SEK);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    usd_sek = rateManager.lookup(SEK, USD, Date(5,August,2004));
    calculated = usd_sek.exchange(m5);
    expected = Money(m5.value()*usd_chf2.rate()/chf_sek2.rate(), USD);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    // three-rate chain

    ExchangeRate eur_sek = rateManager.lookup(EUR, SEK,
                                              Date(4,August,2004));
    calculated = eur_sek.exchange(m2);
    expected = Money(m2.value()*eur_usd1.rate()
                               *usd_chf1.rate()/chf_sek1.rate(), SEK);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    eur_sek = rateManager.lookup(SEK, EUR, Date(5,August,2004));
    calculated = eur_sek.exchange(m5);
    expected = Money(m5.value()*eur_usd2.rate()
                               *usd_chf2.rate()/chf_sek2.rate(), EUR);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    // four-rate chain

    ExchangeRate eur_jpy = rateManager.lookup(EUR, JPY,
                                              Date(4,August,2004));
    calculated = eur_jpy.exchange(m2);
    expected = Money(m2.value()*eur_usd1.rate()*usd_chf1.rate()
                               *jpy_sek1.rate()/chf_sek1.rate(), JPY);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    eur_jpy = rateManager.lookup(JPY, EUR, Date(5,August,2004));
    calculated = eur_jpy.exchange(m6);
    expected = Money(m6.value()*jpy_sek2.rate()*eur_usd2.rate()
                               *usd_chf2.rate()/chf_sek2.rate(), EUR);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    // five-rate chain

    ExchangeRate gbp_jpy = rateManager.lookup(GBP, JPY,
                                              Date(4,August,2004));
    calculated = gbp_jpy.exchange(m3);
    expected = Money(m3.value()*eur_gbp1.rate()*eur_usd1.rate()*usd_chf1.rate()
                               *jpy_sek1.rate()/chf_sek1.rate(), JPY);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }

    gbp_jpy = rateManager.lookup(JPY, GBP, Date(5,August,2004));
    calculated = gbp_jpy.exchange(m6);
    expected = Money(m6.value()*jpy_sek2.rate()*eur_usd2.rate()*usd_chf2.rate()
                               *eur_gbp2.rate()/chf_sek2.rate(), GBP);

    if (!close(calculated,expected)) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}

test_suite* ExchangeRateTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Exchange-rate tests");
    suite->add(QUANTLIB_TEST_CASE(&ExchangeRateTest::testDirect));
    suite->add(QUANTLIB_TEST_CASE(&ExchangeRateTest::testDerived));
    suite->add(QUANTLIB_TEST_CASE(&ExchangeRateTest::testDirectLookup));
    suite->add(QUANTLIB_TEST_CASE(&ExchangeRateTest::testTriangulatedLookup));
    suite->add(QUANTLIB_TEST_CASE(&ExchangeRateTest::testSmartLookup));
    return suite;
}

]]></document_content>
  </document>
  <document index="97">
    <source>exchangerate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_exchange_rate_hpp
#define quantlib_test_exchange_rate_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ExchangeRateTest {
  public:
    static void testDirect();
    static void testDerived();
    static void testDirectLookup();
    static void testTriangulatedLookup();
    static void testSmartLookup();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="98">
    <source>extendedtrees.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2007 Ferdinando Ametrano
 Copyright (C) 2003, 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "extendedtrees.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/binomialengine.hpp>
#include <ql/experimental/lattices/extendedbinomialtree.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, \
                       v, expected, calculated, error, tolerance) \
    BOOST_ERROR(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:       " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    expected " << greekName << ":   " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

namespace extended_trees_test {

    // utilities

    enum EngineType { Analytic,
                      JR, CRR, EQP, TGEO, TIAN, LR, JOSHI };

    ext::shared_ptr<GeneralizedBlackScholesProcess>
    makeProcess(const ext::shared_ptr<Quote>& u,
                const ext::shared_ptr<YieldTermStructure>& q,
                const ext::shared_ptr<YieldTermStructure>& r,
                const ext::shared_ptr<BlackVolTermStructure>& vol) {
        return ext::make_shared<BlackScholesMertonProcess>(
           Handle<Quote>(u),
                                         Handle<YieldTermStructure>(q),
                                         Handle<YieldTermStructure>(r),
                                         Handle<BlackVolTermStructure>(vol));
    }

    ext::shared_ptr<VanillaOption>
    makeOption(const ext::shared_ptr<StrikedTypePayoff>& payoff,
               const ext::shared_ptr<Exercise>& exercise,
               const ext::shared_ptr<Quote>& u,
               const ext::shared_ptr<YieldTermStructure>& q,
               const ext::shared_ptr<YieldTermStructure>& r,
               const ext::shared_ptr<BlackVolTermStructure>& vol,
               EngineType engineType,
               Size binomialSteps) {

        ext::shared_ptr<GeneralizedBlackScholesProcess> stochProcess =
            makeProcess(u,q,r,vol);

        ext::shared_ptr<PricingEngine> engine;
        switch (engineType) {
          case Analytic:
            engine = ext::shared_ptr<PricingEngine>(
                                    new AnalyticEuropeanEngine(stochProcess));
            break;
          case JR:
            engine = ext::shared_ptr<PricingEngine>(
                new BinomialVanillaEngine<ExtendedJarrowRudd>(stochProcess,
                                                              binomialSteps));
            break;
          case CRR:
            engine = ext::shared_ptr<PricingEngine>(
                new BinomialVanillaEngine<ExtendedCoxRossRubinstein>(
                                                              stochProcess,
                                                              binomialSteps));
            break;
          case EQP:
            engine = ext::shared_ptr<PricingEngine>(
                new BinomialVanillaEngine<ExtendedAdditiveEQPBinomialTree>(
                                                              stochProcess,
                                                              binomialSteps));
            break;
          case TGEO:
            engine = ext::shared_ptr<PricingEngine>(
                new BinomialVanillaEngine<ExtendedTrigeorgis>(stochProcess,
                                                              binomialSteps));
            break;
          case TIAN:
            engine = ext::shared_ptr<PricingEngine>(
                new BinomialVanillaEngine<ExtendedTian>(stochProcess,
                                                        binomialSteps));
            break;
          case LR:
            engine = ext::shared_ptr<PricingEngine>(
                      new BinomialVanillaEngine<ExtendedLeisenReimer>(
                                                              stochProcess,
                                                              binomialSteps));
            break;
          case JOSHI:
            engine = ext::shared_ptr<PricingEngine>(
                new BinomialVanillaEngine<ExtendedJoshi4>(stochProcess,
                                                          binomialSteps));
            break;
          default:
            QL_FAIL("unknown engine type");
        }

        ext::shared_ptr<VanillaOption> option(
                                        new EuropeanOption(payoff, exercise));
        option->setPricingEngine(engine);
        return option;
    }

}

namespace {

    void testEngineConsistency(extended_trees_test::EngineType engine,
                               Size binomialSteps,
                               std::map<std::string,Real> tolerance) {

        using namespace extended_trees_test;

        std::map<std::string,Real> calculated, expected;

        // test options
        Option::Type types[] = { Option::Call, Option::Put };
        Real strikes[] = { 75.0, 100.0, 125.0 };
        Integer lengths[] = { 1 };

        // test data
        Real underlyings[] = { 100.0 };
        Rate qRates[] = { 0.00, 0.05 };
        Rate rRates[] = { 0.01, 0.05, 0.15 };
        Volatility vols[] = { 0.11, 0.50, 1.20 };

        DayCounter dc = Actual360();
        Date today = Date::todaysDate();

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
        ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
        ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today,vol,dc);
        ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
        ext::shared_ptr<YieldTermStructure> qTS = flatRate(today,qRate,dc);
        ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
        ext::shared_ptr<YieldTermStructure> rTS = flatRate(today,rRate,dc);

        for (auto& type : types) {
            for (double strike : strikes) {
                for (int length : lengths) {
                    Date exDate = today + length * 360;
                    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
                    ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));
                    // reference option
                    ext::shared_ptr<VanillaOption> refOption =
                        makeOption(payoff, exercise, spot, qTS, rTS, volTS, Analytic, Null<Size>());
                    // option to check
                    ext::shared_ptr<VanillaOption> option =
                        makeOption(payoff, exercise, spot, qTS, rTS, volTS, engine, binomialSteps);

                    for (double u : underlyings) {
                        for (double m : qRates) {
                            for (double n : rRates) {
                                for (double v : vols) {
                                    Rate q = m, r = n;
                                    spot->setValue(u);
                                    qRate->setValue(q);
                                    rRate->setValue(r);
                                    vol->setValue(v);

                                    expected.clear();
                                    calculated.clear();

                                    // FLOATING_POINT_EXCEPTION
                                    expected["value"] = refOption->NPV();
                                    calculated["value"] = option->NPV();

                                    if (option->NPV() > spot->value() * 1.0e-5) {
                                        expected["delta"] = refOption->delta();
                                        expected["gamma"] = refOption->gamma();
                                        expected["theta"] = refOption->theta();
                                        calculated["delta"] = option->delta();
                                        calculated["gamma"] = option->gamma();
                                        calculated["theta"] = option->theta();
                                    }
                                    std::map<std::string, Real>::iterator it;
                                    for (it = calculated.begin(); it != calculated.end(); ++it) {
                                        std::string greek = it->first;
                                        Real expct = expected[greek], calcl = calculated[greek],
                                             tol = tolerance[greek];
                                        Real error = relativeError(expct, calcl, u);
                                        if (error > tol) {
                                            REPORT_FAILURE(greek, payoff, exercise, u, q, r, today,
                                                           v, expct, calcl, error, tol);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}


void ExtendedTreesTest::testJRBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent JR binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = JR;
    Size steps = 251;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 0.002;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

void ExtendedTreesTest::testCRRBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent CRR binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = CRR;
    Size steps = 501;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 0.02;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

void ExtendedTreesTest::testEQPBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent EQP binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = EQP;
    Size steps = 501;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 0.02;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

void ExtendedTreesTest::testTGEOBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent TGEO binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = TGEO;
    Size steps = 251;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 0.002;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

void ExtendedTreesTest::testTIANBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent TIAN binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = TIAN;
    Size steps = 251;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 0.002;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

void ExtendedTreesTest::testLRBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent LR binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = LR;
    Size steps = 251;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 1.0e-6;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

void ExtendedTreesTest::testJOSHIBinomialEngines() {

    BOOST_TEST_MESSAGE("Testing time-dependent Joshi binomial European engines "
                       "against analytic results...");

    using namespace extended_trees_test;

    SavedSettings backup;

    EngineType engine = JOSHI;
    Size steps = 251;
    std::map<std::string,Real> relativeTol;
    relativeTol["value"] = 1.0e-7;
    relativeTol["delta"] = 1.0e-3;
    relativeTol["gamma"] = 1.0e-4;
    relativeTol["theta"] = 0.03;
    testEngineConsistency(engine, steps, relativeTol);
}

test_suite* ExtendedTreesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("European option extended trees tests");

    suite->add(QUANTLIB_TEST_CASE(&ExtendedTreesTest::testJRBinomialEngines));
    suite->add(QUANTLIB_TEST_CASE(&ExtendedTreesTest::testCRRBinomialEngines));
    suite->add(QUANTLIB_TEST_CASE(&ExtendedTreesTest::testEQPBinomialEngines));
    suite->add(QUANTLIB_TEST_CASE(&ExtendedTreesTest::testTGEOBinomialEngines));
    suite->add(QUANTLIB_TEST_CASE(&ExtendedTreesTest::testTIANBinomialEngines));
    suite->add(QUANTLIB_TEST_CASE(&ExtendedTreesTest::testLRBinomialEngines));
    suite->add(QUANTLIB_TEST_CASE(
                               &ExtendedTreesTest::testJOSHIBinomialEngines));

    return suite;
}
]]></document_content>
  </document>
  <document index="99">
    <source>extendedtrees.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_extended_trees_hpp
#define quantlib_test_extended_trees_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ExtendedTreesTest {
  public:
    static void testJRBinomialEngines();
    static void testCRRBinomialEngines();
    static void testEQPBinomialEngines();
    static void testTGEOBinomialEngines();
    static void testTIANBinomialEngines();
    static void testLRBinomialEngines();
    static void testJOSHIBinomialEngines();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="100">
    <source>extensibleoptions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "extensibleoptions.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/holderextensibleoption.hpp>
#include <ql/experimental/exoticoptions/writerextensibleoption.hpp>
#include <ql/experimental/exoticoptions/analyticholderextensibleoptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticwriterextensibleoptionengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void ExtensibleOptionsTest::testAnalyticHolderExtensibleOptionEngine() {
    BOOST_TEST_MESSAGE(
        "Testing analytic engine for holder-extensible option...");

    Option::Type type = Option::Call;
    Real strike1 = 100.0;
    Real strike2 = 105.0;
    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();
    Date exDate1 = today + 180;
    Date exDate2 = today + 270;
    Real premium = 1.0;

    ext::shared_ptr<SimpleQuote> spot = ext::make_shared<SimpleQuote>(100.0);
    ext::shared_ptr<SimpleQuote> qRate = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<SimpleQuote> rRate = ext::make_shared<SimpleQuote>(0.08);
    ext::shared_ptr<SimpleQuote> vol = ext::make_shared<SimpleQuote>(0.25);

    ext::shared_ptr<StrikedTypePayoff> payoff =
        ext::make_shared<PlainVanillaPayoff>(type, strike1);
    ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(exDate1);

    HolderExtensibleOption option(type, premium,
                                  exDate2, strike2,
                                  payoff, exercise);

    Handle<Quote> underlying(spot);
    Handle<YieldTermStructure> dividendTS(flatRate(today, qRate, dc));
    Handle<YieldTermStructure> riskFreeTS(flatRate(today, rRate, dc));
    Handle<BlackVolTermStructure> blackVolTS(flatVol(today, vol, dc));

    const ext::shared_ptr<BlackScholesMertonProcess> process =
        ext::make_shared<BlackScholesMertonProcess>(underlying,
                                                      dividendTS,
                                                      riskFreeTS,
                                                      blackVolTS);

    option.setPricingEngine(
           ext::make_shared<AnalyticHolderExtensibleOptionEngine>(process));

    Real calculated = option.NPV();
    Real expected = 9.4233;
    Real error = std::fabs(calculated-expected);
    Real tolerance = 1e-4;
    if (error > tolerance)
        BOOST_ERROR("Failed to reproduce holder-extensible option value"
                    << "\n    expected:   " << expected
                    << "\n    calculated: " << calculated
                    << "\n    error:      " << error);
}


void ExtensibleOptionsTest::testAnalyticWriterExtensibleOptionEngine() {
    BOOST_TEST_MESSAGE("Testing analytic engine for writer-extensible option...");

    // What we need for the option (tests):
    Option::Type type = Option::Call;
    Real strike1 = 90.0;
    Real strike2 = 82.0;
    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();
    Date exDate1 = today + 180;
    Date exDate2 = today + 270;

    ext::shared_ptr<SimpleQuote> spot = ext::make_shared<SimpleQuote>(80.0);
    ext::shared_ptr<SimpleQuote> qRate = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<YieldTermStructure> dividendTS =
        flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate = ext::make_shared<SimpleQuote>(0.10);
    ext::shared_ptr<YieldTermStructure> riskFreeTS =
        flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol = ext::make_shared<SimpleQuote>(0.30);
    ext::shared_ptr<BlackVolTermStructure> blackVolTS =
        flatVol(today, vol, dc);

    // B&S process (needed for the engine):
    const ext::shared_ptr<GeneralizedBlackScholesProcess> process =
        ext::make_shared<GeneralizedBlackScholesProcess>(
                    Handle<Quote>(spot),
                    Handle<YieldTermStructure>(dividendTS),
                    Handle<YieldTermStructure>(riskFreeTS),
                    Handle<BlackVolTermStructure>(blackVolTS));

    // The engine:
    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<AnalyticWriterExtensibleOptionEngine>(process);

    // Create the arguments:
    ext::shared_ptr<PlainVanillaPayoff> payoff1 =
        ext::make_shared<PlainVanillaPayoff>(type, strike1);
    ext::shared_ptr<Exercise> exercise1 =
        ext::make_shared<EuropeanExercise>(exDate1);
    ext::shared_ptr<PlainVanillaPayoff> payoff2 =
        ext::make_shared<PlainVanillaPayoff>(type, strike2);
    ext::shared_ptr<Exercise> exercise2 =
        ext::make_shared<EuropeanExercise>(exDate2);

    // Create the option by calling the constructor:
    WriterExtensibleOption option(payoff1, exercise1,
                                  payoff2, exercise2);

    //Set the engine of our option:
    option.setPricingEngine(engine);

    //Compare the calculated NPV value to the theoretical value:
    Real calculated = option.NPV();
    Real expected = 6.8238;
    Real error = std::fabs(calculated-expected);
    Real tolerance = 1e-4;
    if (error > tolerance)
        BOOST_ERROR("Failed to reproduce writer-extensible option value"
                    << "\n    expected:   " << expected
                    << "\n    calculated: " << calculated
                    << "\n    error:      " << error);
}

test_suite* ExtensibleOptionsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Extensible option tests");

    suite->add(QUANTLIB_TEST_CASE(
       &ExtensibleOptionsTest::testAnalyticHolderExtensibleOptionEngine));
    suite->add(QUANTLIB_TEST_CASE(
       &ExtensibleOptionsTest::testAnalyticWriterExtensibleOptionEngine));

    return suite;
}
]]></document_content>
  </document>
  <document index="101">
    <source>extensibleoptions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_extensible_options_hpp
#define quantlib_test_extensible_options_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ExtensibleOptionsTest {
  public:
    static void testAnalyticHolderExtensibleOptionEngine();
    static void testAnalyticWriterExtensibleOptionEngine();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="102">
    <source>fastfouriertransform.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2009 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "fastfouriertransform.hpp"
#include "utilities.hpp"
#include <ql/math/fastfouriertransform.hpp>
#include <ql/math/array.hpp>
#include <complex>
#include <vector>
#include <functional>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using namespace std;

void FastFourierTransformTest::testSimple() {
    BOOST_TEST_MESSAGE("Testing complex direct FFT...");
    typedef std::complex<Real> cx;
    cx a[] = { cx(0,0), cx(1,1), cx(3,3), cx(4,4),
               cx(4,4), cx(3,3), cx(1,1), cx(0,0) };
    cx b[8];
    FastFourierTransform fft(3);
    fft.transform(a, a+8, b);
    cx expected[] = { cx(16,16), cx(-4.8284,-11.6569),
                      cx(0,0),   cx(-0.3431,0.8284),
                      cx(0,0),   cx(0.8284, -0.3431),
                      cx(0,0),   cx(-11.6569,-4.8284) };
    for (size_t i = 0; i<8; i++) {
        if ((std::fabs(b[i].real() - expected[i].real()) > 1.0e-2) ||
            (std::fabs(b[i].imag() - expected[i].imag()) > 1.0e-2))
            BOOST_ERROR("Convolution(" << i << ")\n"
                        << std::setprecision(4) << std::scientific
                        << "    calculated: " << b[i] << "\n"
                        << "    expected:   " << expected[i]);
    }
}

void FastFourierTransformTest::testInverse() {
    BOOST_TEST_MESSAGE("Testing convolution via inverse FFT...");
    Array x(3);
    x[0] = 1;
    x[1] = 2;
    x[2] = 3;

    size_t order = FastFourierTransform::min_order(x.size())+1;
    FastFourierTransform fft(order);
    size_t nFrq = fft.output_size();
    std::vector< std::complex<Real> > ft (nFrq);
    std::vector< Real > tmp (nFrq);
    std::complex<Real> z = std::complex<Real>();

    fft.inverse_transform(x.begin(), x.end(), ft.begin());
    for (Size i=0; i<nFrq; ++i) {
        tmp[i] = std::norm<Real>(ft[i]);
        ft[i] = z;
    }
    fft.inverse_transform(tmp.begin(), tmp.end(), ft.begin());

    // 0
    Real calculated = ft[0].real() / nFrq;
    Real expected = x[0]*x[0] + x[1]*x[1] + x[2]*x[2];
    if (fabs (calculated - expected) > 1.0e-10)
        BOOST_ERROR("Convolution(0)\n"
                    << std::setprecision(16) << std::scientific
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);

    // 1
    calculated = ft[1].real() / nFrq;
    expected = x[0]*x[1] + x[1]*x[2];
    if (fabs (calculated - expected) > 1.0e-10)
        BOOST_ERROR("Convolution(1)\n"
                    << std::setprecision(16) << std::scientific
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);

    // 2
    calculated = ft[2].real() / nFrq;
    expected = x[0]*x[2];
    if (fabs (calculated - expected) > 1.0e-10)
        BOOST_ERROR("Convolution(1)\n"
                    << std::setprecision(16) << std::scientific
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);

}



test_suite* FastFourierTransformTest::suite() {
    auto* suite = BOOST_TEST_SUITE("fast fourier transform tests");
    suite->add(QUANTLIB_TEST_CASE(&FastFourierTransformTest::testSimple));
    suite->add(QUANTLIB_TEST_CASE(&FastFourierTransformTest::testInverse));
    return suite;
}

]]></document_content>
  </document>
  <document index="103">
    <source>fastfouriertransform.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2009 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fast_fourier_transform_hpp
#define quantlib_test_fast_fourier_transform_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FastFourierTransformTest {
  public:
    static void testSimple();
    static void testInverse();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="104">
    <source>fdcev.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "fdcev.hpp"
#include "utilities.hpp"

#include <ql/math/functional.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/pricingengines/vanilla/analyticcevengine.hpp>
#include <ql/pricingengines/vanilla/fdcevvanillaengine.hpp>

#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>

#include <boost/make_shared.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;


namespace {
    class ExpectationFct {
      public:
        ExpectationFct(const CEVRNDCalculator& calculator, Time t)
        : t_(t), calculator_(calculator) { }

        Real operator()(Real f) const { return f*calculator_.pdf(f, t_); }

      private:
        const Time t_;
        const CEVRNDCalculator& calculator_;
    };
}

void FdCevTest::testLocalMartingale() {
    BOOST_TEST_MESSAGE(
        "Testing local martingale property of CEV process with PDF...");

    const Time t = 1.0;

    const Real f0 = 2.1;
    const Real alpha = 1.75;
    const Real betas[] = {-2.4, 0.23, 0.9, 1.1, 1.5};

    for (double beta : betas) {
        const CEVRNDCalculator rndCalculator(f0, alpha, beta);

        const Real eps = 1e-10;
        const Real tol = 100*eps;

        const Real upperBound = 10*rndCalculator.invcdf(1-eps, t);

        const Real expectationValue = GaussLobattoIntegral(10000, eps)(
            ExpectationFct(rndCalculator, t), QL_EPSILON, upperBound);

        const Real diff = expectationValue-f0;


        if (beta < 1.0 && std::fabs(diff) > tol) {
            BOOST_ERROR("CEV process should be a martingale for beta < 1.0"
                        << "\n    expected:   " << f0
                        << std::scientific
                        << "\n    difference  " << diff
                        << "\n    tolerance:  " << tol);
        }

        if (beta > 1.0 && diff > -tol) {
            BOOST_ERROR("CEV process should only be a local martingale "
                        "for beta > 1.0. Expectation is E[F_t|F_0] < F_0"
                        << "\n    E[F_t|F_0]: " << expectationValue
                        << "\n    F_0:        " << f0);
        }

        // check local martingale property with Monte-Carlo simulation
        const Size nSims = 5000;

        const Size nSteps = 2000;
        const Real dt = t / nSteps;
        const Real sqrtDt = std::sqrt(dt);

        GeneralStatistics stat;
        const PseudoRandom::rng_type mt(MersenneTwisterUniformRng(42));

        if (beta > 1.2) {
            for (Size i=0; i < nSims; ++i) {
                Real f = f0;
                for (Size j=0; j < nSteps; ++j) {
                    f += alpha * std::pow(f, beta) * mt.next().value * sqrtDt;
                    f = std::max(0.0, f);

                    if (f == 0.0) break; // absorbing boundary
                }
                stat.add(f - f0);
            }

            const Real calculated = stat.mean();
            const Real error = stat.errorEstimate();

            if (std::fabs(calculated - diff) > 2.35*error) {
                BOOST_ERROR(
                    "failed to calculate local martingale property "
                    "by Monte-Carlo Simulation for beta > 1.0. "
                            << "\n    E[F_t|F_0]   : " << expectationValue
                            << "\n    E_MC[F_t|F_0]: " << calculated + f0
                            << "\n    error_MC     : " << error
                            << "\n    difference   : " << std::fabs(calculated - diff)
                            << "\n    tolerance    : " << 2.35*error);
            }
        }
    }
}

void FdCevTest::testFdmCevOp() {
    BOOST_TEST_MESSAGE(
            "Testing FDM constant elasticity of variance (CEV) operator...");

    SavedSettings backup;

    const Date today = Date(22, February, 2018);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const Date maturityDate = today + Period(12, Months);
    const Real strike = 2.3;

    const Option::Type optionTypes[] = { Option::Call, Option::Put};

    const ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturityDate);

    for (auto optionType : optionTypes) {
        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::make_shared<PlainVanillaPayoff>(optionType, strike);

        const ext::shared_ptr<YieldTermStructure> rTS =
            flatRate(today, 0.15, dc);

        const Real f0 = 2.1;
        const Real alpha = 0.75;

        const Real betas[] = { -2.0, -0.5, 0.45, 0.6, 0.9, 1.45 };
        for (double beta : betas) {

            VanillaOption option(payoff, exercise);
            option.setPricingEngine(ext::make_shared<AnalyticCEVEngine>(
                f0, alpha, beta, Handle<YieldTermStructure>(rTS)));

            const Real analyticNPV = option.NPV();

            const Real eps = 1e-3;

            option.setPricingEngine(ext::make_shared<AnalyticCEVEngine>(
                f0*(1+eps), alpha, beta, Handle<YieldTermStructure>(rTS)));
            const Real analyticUpNPV = option.NPV();

            option.setPricingEngine(ext::make_shared<AnalyticCEVEngine>(
                f0*(1-eps), alpha, beta, Handle<YieldTermStructure>(rTS)));
            const Real analyticDownNPV = option.NPV();

            const Real analyticDelta = (analyticUpNPV - analyticDownNPV)
                /(2*eps*f0);

            option.setPricingEngine(ext::make_shared<FdCEVVanillaEngine>(
                f0, alpha, beta, Handle<YieldTermStructure>(rTS),
                100, 1000, 1, 1.0, 1e-6));

            const Real calculatedNPV = option.NPV();
            const Real calculatedDelta = option.delta();

            const Real tol = 0.01;
            if (std::fabs(calculatedNPV - analyticNPV) > tol
                || std::fabs(calculatedDelta - analyticDelta) > tol) {
                BOOST_ERROR(
                    "failed to calculate vanilla option prices/delta "
                    << "\n    beta            : " << beta
                    << "\n    option type     : "
                    << ((payoff->optionType() == Option::Call) ? "Call" : "Put")
                    << "\n    analytic npv    : " << analyticNPV
                    << "\n    pde npv         : " << calculatedNPV
                    << "\n    npv difference  : "
                    << std::fabs(calculatedNPV - analyticNPV)
                    << "\n    tolerance       : " << tol
                    << "\n    analytic delta  : " << analyticDelta
                    << "\n    pde delta       : " << calculatedDelta
                    << "\n    delta difference: "
                    << std::fabs(calculatedDelta - analyticDelta)
                    << "\n    tolerance       : " << tol);
            }
        }
    }
}


test_suite* FdCevTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Finite Difference CEV tests");


    suite->add(QUANTLIB_TEST_CASE(&FdCevTest::testLocalMartingale));
    suite->add(QUANTLIB_TEST_CASE(&FdCevTest::testFdmCevOp));

    return suite;
}
]]></document_content>
  </document>
  <document index="105">
    <source>fdcev.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fd_vec_hpp
#define quantlib_test_fd_vec_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FdCevTest {
  public:
    static void testLocalMartingale();
    static void testFdmCevOp();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel speed);
};

#endif
]]></document_content>
  </document>
  <document index="106">
    <source>fdcir.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "fdcir.hpp"
#include "fdheston.hpp"
#include "utilities.hpp"
#include <ql/instruments/barrieroption.hpp>
#include <ql/math/functional.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/barrier/fdhestonbarrierengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdcirvanillaengine.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/localconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;

void FdCIRTest::testFdmCIRConvergence() {
    BOOST_TEST_MESSAGE("Testing FDM CIR convergence...");

    FdmSchemeDesc schemes[] = {
        FdmSchemeDesc::Hundsdorfer(),
        FdmSchemeDesc::ModifiedCraigSneyd(),
        FdmSchemeDesc::ModifiedHundsdorfer(),
        FdmSchemeDesc::CraigSneyd(),
        FdmSchemeDesc::TrBDF2(),
        FdmSchemeDesc::CrankNicolson(),
    };

    // set up dates
    Date today = Date::todaysDate();

    // our options
    Option::Type type(Option::Put);
    Real underlying = 36;
    Real strike = 40;
    Spread dividendYield = 0.00;
    Rate riskFreeRate = 0.06;
    Volatility volatility = 0.20;
    Date maturity = today + 365;
    DayCounter dayCounter = Actual365Fixed();

    ext::shared_ptr<Exercise> europeanExercise(
        new EuropeanExercise(maturity));

    Handle<Quote> underlyingH(
        ext::shared_ptr<Quote>(new SimpleQuote(underlying)));

    Handle<YieldTermStructure> flatTermStructure(
        ext::shared_ptr<YieldTermStructure>(flatRate(today, riskFreeRate, dayCounter)));
    Handle<YieldTermStructure> flatDividendTS(
        ext::shared_ptr<YieldTermStructure>(flatRate(today, dividendYield, dayCounter)));
    Handle<BlackVolTermStructure> flatVolTS(
        ext::shared_ptr<BlackVolTermStructure>(flatVol(today, volatility, dayCounter)));
    ext::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(type, strike));
    ext::shared_ptr<BlackScholesMertonProcess> bsmProcess(
        new BlackScholesMertonProcess(underlyingH, flatDividendTS,
                                      flatTermStructure, flatVolTS));

    VanillaOption europeanOption(payoff, europeanExercise);

    Real speed = 1.2188;
    Real cirSigma = 0.02438;
    Real level = 0.0183;
    Real initialRate = 0.06;
    Real rho = 0.00789;
    Real lambda = -0.5726;
    Real newSpeed = speed + (cirSigma*lambda); //1.0792
    Real newLevel = (level * speed)/(speed + (cirSigma*lambda));//// 0.0240

    ext::shared_ptr<CoxIngersollRossProcess> cirProcess(new CoxIngersollRossProcess(newSpeed, cirSigma, initialRate, newLevel));

    Real expected = 4.275;
    Real tolerance = 0.0003;

    for (const auto& scheme : schemes) {
        ext::shared_ptr<PricingEngine> fdcirengine =
            MakeFdCIRVanillaEngine(cirProcess, bsmProcess, rho).withFdmSchemeDesc(scheme);
        europeanOption.setPricingEngine(fdcirengine);
        Real calculated = europeanOption.NPV();
        if (std::fabs(expected - calculated) > tolerance) {
            BOOST_ERROR("Failed to reproduce expected npv"
                            << "\n    calculated: " << calculated
                            << "\n    expected:   " << expected
                            << "\n    tolerance:  " << tolerance);
        }
    }
}

test_suite* FdCIRTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Finite Difference CIR tests");

    suite->add(QUANTLIB_TEST_CASE(&FdCIRTest::testFdmCIRConvergence));

    return suite;
}

]]></document_content>
  </document>
  <document index="107">
    <source>fdcir.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fd_cir_hpp
#define quantlib_test_fd_cir_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FdCIRTest {
public:
    static void testFdmCIRConvergence();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="108">
    <source>fdheston.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2008, 2009, 2014 Klaus Spanderen
  Copyright (C) 2014 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "fdheston.hpp"
#include "utilities.hpp"

#include <ql/math/functional.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/instruments/dividendvanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/localconstantvol.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/barrier/fdhestonbarrierengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <ql/pricingengines/barrier/fdblackscholesbarrierengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/tuple.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;


namespace fd_heston_test {
    struct NewBarrierOptionData {
        Barrier::Type barrierType;
        Real barrier;
        Real rebate;
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
    };

    class ParableLocalVolatility : public LocalVolTermStructure {
      public:
        ParableLocalVolatility(
            const Date& referenceDate,
            Real s0,
            Real alpha,
            const DayCounter& dayCounter)
        : LocalVolTermStructure(
              referenceDate, NullCalendar(), Following, dayCounter),
          referenceDate_(referenceDate),
          s0_(s0),
          alpha_(alpha) {}

        Date maxDate() const override { return Date::maxDate(); }
        Real minStrike() const override { return 0.0; }
        Real maxStrike() const override { return std::numeric_limits<Real>::max(); }

      protected:
        Volatility localVolImpl(Time t, Real s) const override {
            return alpha_*(square<Real>()(s0_ - s) + 25.0);
        }

      private:
        const Date referenceDate_;
        const Real s0_, alpha_;
    };
}

void FdHestonTest::testFdmHestonVarianceMesher() {
    BOOST_TEST_MESSAGE("Testing FDM Heston variance mesher...");

    using namespace fd_heston_test;

    SavedSettings backup;

    const Date today = Date(22, February, 2018);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const ext::shared_ptr<HestonProcess> process(
        ext::make_shared<HestonProcess>(
            Handle<YieldTermStructure>(flatRate(0.02, dc)),
            Handle<YieldTermStructure>(flatRate(0.02, dc)),
            Handle<Quote>(ext::make_shared<SimpleQuote>(100.0)),
            0.09, 1.0, 0.09, 0.2, -0.5));

    const ext::shared_ptr<FdmHestonVarianceMesher> mesher
        = ext::make_shared<FdmHestonVarianceMesher>(5, process, 1.0);

    const std::vector<Real> locations = mesher->locations();

    const Real expected[] = {
        0.0, 6.652314e-02, 9.000000e-02, 1.095781e-01, 2.563610e-01
    };

    const Real tol = 1e-6;
    for (Size i=0; i < locations.size(); ++i) {
        const Real diff = std::fabs(expected[i] - locations[i]);

        if (diff > tol) {
            BOOST_ERROR("Failed to reproduce Heston variance mesh"
                        << "\n    calculated: " << locations[i]
                        << "\n    expected:   " << expected[i]
                        << std::scientific
                        << "\n    difference  " << diff
                        << "\n    tolerance:  " << tol);
        }
    }

    const ext::shared_ptr<LocalVolTermStructure> lVol =
        ext::make_shared<LocalConstantVol>(today, 2.5, dc);

    const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> constSlvMesher
        = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>
              (5, process, lVol, 1.0);

    const Real expectedVol = 2.5 * mesher->volaEstimate();
    const Real calculatedVol = constSlvMesher->volaEstimate();

    const Real diff = std::fabs(calculatedVol - expectedVol);
    if (diff > tol) {
        BOOST_ERROR("Failed to reproduce Heston local volatility "
                "variance estimate"
                    << "\n    calculated: " << calculatedVol
                    << "\n    expected:   " << expectedVol
                    << std::scientific
                    << "\n    difference  " << diff
                    << "\n    tolerance:  " << tol);
    }

    const Real alpha = 0.01;
    const ext::shared_ptr<LocalVolTermStructure> leverageFct
        = ext::make_shared<ParableLocalVolatility>(today, 100.0, alpha, dc);

    const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> slvMesher
        = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>(
              5, process, leverageFct, 0.5, 1, 0.01);

    const Real initialVolEstimate =
        ext::make_shared<FdmHestonVarianceMesher>(5, process, 0.5, 1, 0.01)->
            volaEstimate();

    // const Real vEst = leverageFct->localVol(0, 100) * initialVolEstimate;
    // Mathematica solution
    //    N[Integrate[
    //      alpha*((100*Exp[vEst*x*Sqrt[0.5]] - 100)^2 + 25)*
    //       PDF[NormalDistribution[0, 1], x], {x ,
    //       InverseCDF[NormalDistribution[0, 1], 0.01],
    //       InverseCDF[NormalDistribution[0, 1], 0.99]}]]

    const Real leverageAvg = 0.455881 / (1-0.02);

    const Real volaEstExpected =
        0.5*(leverageAvg + leverageFct->localVol(0, 100)) * initialVolEstimate;

    const Real volaEstCalculated = slvMesher->volaEstimate();

    if (std::fabs(volaEstExpected - volaEstCalculated) > 0.001) {
        BOOST_ERROR("Failed to reproduce Heston local volatility "
                "variance estimate"
                    << "\n    calculated: " << calculatedVol
                    << "\n    expected:   " << expectedVol
                    << std::scientific
                    << "\n    difference  " << std::fabs(volaEstExpected - volaEstCalculated)
                    << "\n    tolerance:  " << tol);
    }
}

void FdHestonTest::testFdmHestonBarrierVsBlackScholes() {

    BOOST_TEST_MESSAGE("Testing FDM with barrier option in Heston model...");

    using namespace fd_heston_test;

    SavedSettings backup;

    NewBarrierOptionData values[] = {
        /* The data below are from
          "Option pricing formulas", E.G. Haug, McGraw-Hill 1998 pag. 72
        */
        //     barrierType, barrier, rebate,         type, strike,     s,    q,    r,    t,    v
        { Barrier::DownOut,    95.0,    3.0, Option::Call,     90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,    95.0,    3.0, Option::Call,    100, 100.0, 0.00, 0.08, 1.00, 0.30},
        { Barrier::DownOut,    95.0,    3.0, Option::Call,    110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,   100.0,    3.0, Option::Call,     90, 100.0, 0.00, 0.08, 0.25, 0.25},
        { Barrier::DownOut,   100.0,    3.0, Option::Call,    100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,   100.0,    3.0, Option::Call,    110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpOut,     105.0,    3.0, Option::Call,     90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpOut,     105.0,    3.0, Option::Call,    100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpOut,     105.0,    3.0, Option::Call,    110, 100.0, 0.04, 0.08, 0.50, 0.25},

        { Barrier::DownIn,     95.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,     95.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,     95.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,    100.0,    3.0, Option::Call,    90, 100.0, 0.00, 0.08, 0.25, 0.25},
        { Barrier::DownIn,    100.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,    100.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpIn,      105.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpIn,      105.0,    3.0, Option::Call,   100, 100.0, 0.00, 0.08, 0.40, 0.25},
        { Barrier::UpIn,      105.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.15},

        { Barrier::DownOut,    95.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,    95.0,    3.0, Option::Call,   100, 100.0, 0.00, 0.08, 0.40, 0.35},
        { Barrier::DownOut,    95.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,   100.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.15},
        { Barrier::DownOut,   100.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,   100.0,    3.0, Option::Call,   110, 100.0, 0.00, 0.00, 1.00, 0.20},
        { Barrier::UpOut,     105.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpOut,     105.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpOut,     105.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.30},

        { Barrier::DownIn,     95.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,     95.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,     95.0,    3.0, Option::Call,   110, 100.0, 0.00, 0.08, 1.00, 0.30},
        { Barrier::DownIn,    100.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,    100.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,    100.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpIn,      105.0,    3.0, Option::Call,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpIn,      105.0,    3.0, Option::Call,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpIn,      105.0,    3.0, Option::Call,   110, 100.0, 0.04, 0.08, 0.50, 0.30},

        { Barrier::DownOut,    95.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,    95.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,    95.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,   100.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,   100.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownOut,   100.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpOut,     105.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpOut,     105.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpOut,     105.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.25},

        { Barrier::DownIn,     95.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,     95.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,     95.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,    100.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,    100.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::DownIn,    100.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpIn,      105.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpIn,      105.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.25},
        { Barrier::UpIn,      105.0,    3.0,  Option::Put,   110, 100.0, 0.00, 0.04, 1.00, 0.15},

        { Barrier::DownOut,    95.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,    95.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,    95.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,   100.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,   100.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownOut,   100.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpOut,     105.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpOut,     105.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpOut,     105.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.30},

        { Barrier::DownIn,     95.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,     95.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,     95.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,    100.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,    100.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::DownIn,    100.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 1.00, 0.15},
        { Barrier::UpIn,      105.0,    3.0,  Option::Put,    90, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpIn,      105.0,    3.0,  Option::Put,   100, 100.0, 0.04, 0.08, 0.50, 0.30},
        { Barrier::UpIn,      105.0,    3.0,  Option::Put,   110, 100.0, 0.04, 0.08, 0.50, 0.30}
    };
    
    const DayCounter dc = Actual365Fixed();     
    const Date todaysDate(28, March, 2004);
    const Date exerciseDate(28, March, 2005);
    Settings::instance().evaluationDate() = todaysDate;

    Handle<Quote> spot(
            ext::shared_ptr<Quote>(new SimpleQuote(0.0)));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    ext::shared_ptr<BlackScholesMertonProcess> bsProcess(
                      new BlackScholesMertonProcess(spot, qTS, rTS, volTS));

    ext::shared_ptr<PricingEngine> analyticEngine(
                                        new AnalyticBarrierEngine(bsProcess));

    for (auto& value : values) {
        Date exDate = todaysDate + timeToDays(value.t, 365);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        ext::dynamic_pointer_cast<SimpleQuote>(spot.currentLink())->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));

        BarrierOption barrierOption(value.barrierType, value.barrier, value.rebate, payoff,
                                    exercise);

        const Real v0 = vol->value()*vol->value();
        ext::shared_ptr<HestonProcess> hestonProcess(
             new HestonProcess(rTS, qTS, spot, v0, 1.0, v0, 0.005, 0.0));

        barrierOption.setPricingEngine(ext::shared_ptr<PricingEngine>(
            new FdHestonBarrierEngine(ext::make_shared<HestonModel>(
                              hestonProcess), 200, 101, 3)));

        const Real calculatedHE = barrierOption.NPV();
    
        barrierOption.setPricingEngine(analyticEngine);
        const Real expected = barrierOption.NPV();
    
        const Real tol = 0.0025;
        if (std::fabs(calculatedHE - expected)/expected > tol) {
            BOOST_ERROR("Failed to reproduce expected Heston npv"
                        << "\n    calculated: " << calculatedHE
                        << "\n    expected:   " << expected
                        << "\n    tolerance:  " << tol);
        }
    }
}

void FdHestonTest::testFdmHestonBarrier() {

    BOOST_TEST_MESSAGE("Testing FDM with barrier option for Heston model vs "
                       "Black-Scholes model...");

    SavedSettings backup;

    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(100.0)));

    Handle<YieldTermStructure> rTS(flatRate(0.05, Actual365Fixed()));
    Handle<YieldTermStructure> qTS(flatRate(0.0 , Actual365Fixed()));

    ext::shared_ptr<HestonProcess> hestonProcess(
        new HestonProcess(rTS, qTS, s0, 0.04, 2.5, 0.04, 0.66, -0.8));

    Settings::instance().evaluationDate() = Date(28, March, 2004);
    Date exerciseDate(28, March, 2005);

    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));

    ext::shared_ptr<StrikedTypePayoff> payoff(new
                                      PlainVanillaPayoff(Option::Call, 100));

    BarrierOption barrierOption(Barrier::UpOut, 135, 0.0, payoff, exercise);

    barrierOption.setPricingEngine(ext::shared_ptr<PricingEngine>(
            new FdHestonBarrierEngine(ext::make_shared<HestonModel>(
                              hestonProcess), 50, 400, 100)));

    const Real tol = 0.01;
    const Real npvExpected   =  9.1530;
    const Real deltaExpected =  0.5218;
    const Real gammaExpected = -0.0354;

    if (std::fabs(barrierOption.NPV() - npvExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected npv"
                    << "\n    calculated: " << barrierOption.NPV()
                    << "\n    expected:   " << npvExpected
                    << "\n    tolerance:  " << tol); 
    }
    if (std::fabs(barrierOption.delta() - deltaExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected delta"
                    << "\n    calculated: " << barrierOption.delta()
                    << "\n    expected:   " << deltaExpected
                    << "\n    tolerance:  " << tol); 
    }
    if (std::fabs(barrierOption.gamma() - gammaExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected gamma"
                    << "\n    calculated: " << barrierOption.gamma()
                    << "\n    expected:   " << gammaExpected
                    << "\n    tolerance:  " << tol); 
    }
}

void FdHestonTest::testFdmHestonAmerican() {

    BOOST_TEST_MESSAGE("Testing FDM with American option in Heston model...");

    SavedSettings backup;

    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(100.0)));

    Handle<YieldTermStructure> rTS(flatRate(0.05, Actual365Fixed()));
    Handle<YieldTermStructure> qTS(flatRate(0.0 , Actual365Fixed()));

    ext::shared_ptr<HestonProcess> hestonProcess(
        new HestonProcess(rTS, qTS, s0, 0.04, 2.5, 0.04, 0.66, -0.8));

    Settings::instance().evaluationDate() = Date(28, March, 2004);
    Date exerciseDate(28, March, 2005);

    ext::shared_ptr<Exercise> exercise(new AmericanExercise(exerciseDate));

    ext::shared_ptr<StrikedTypePayoff> payoff(new
                                      PlainVanillaPayoff(Option::Put, 100));

    VanillaOption option(payoff, exercise);
    ext::shared_ptr<PricingEngine> engine(
         new FdHestonVanillaEngine(ext::make_shared<HestonModel>(
                             hestonProcess), 200, 100, 50));
    option.setPricingEngine(engine);
    
    const Real tol = 0.01;
    const Real npvExpected   =  5.66032;
    const Real deltaExpected = -0.30065;
    const Real gammaExpected =  0.02202;
    
    if (std::fabs(option.NPV() - npvExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected npv"
                    << "\n    calculated: " << option.NPV()
                    << "\n    expected:   " << npvExpected
                    << "\n    tolerance:  " << tol); 
    }
    if (std::fabs(option.delta() - deltaExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected delta"
                    << "\n    calculated: " << option.delta()
                    << "\n    expected:   " << deltaExpected
                    << "\n    tolerance:  " << tol); 
    }
    if (std::fabs(option.gamma() - gammaExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected gamma"
                    << "\n    calculated: " << option.gamma()
                    << "\n    expected:   " << gammaExpected
                    << "\n    tolerance:  " << tol); 
    }
}


void FdHestonTest::testFdmHestonIkonenToivanen() {

    BOOST_TEST_MESSAGE("Testing FDM Heston for Ikonen and Toivanen tests...");

    /* check prices of american puts as given in:
       From Efficient numerical methods for pricing American options under 
       stochastic volatility, Samuli Ikonen, Jari Toivanen, 
       http://users.jyu.fi/~tene/papers/reportB12-05.pdf
    */
    SavedSettings backup;

    Handle<YieldTermStructure> rTS(flatRate(0.10, Actual360()));
    Handle<YieldTermStructure> qTS(flatRate(0.0 , Actual360()));

    Settings::instance().evaluationDate() = Date(28, March, 2004);
    Date exerciseDate(26, June, 2004);

    ext::shared_ptr<Exercise> exercise(new AmericanExercise(exerciseDate));

    ext::shared_ptr<StrikedTypePayoff> payoff(new
                                      PlainVanillaPayoff(Option::Put, 10));

    VanillaOption option(payoff, exercise);

    Real strikes[]  = { 8, 9, 10, 11, 12 };
    Real expected[] = { 2.00000, 1.10763, 0.520038, 0.213681, 0.082046 };
    const Real tol = 0.001;
    
    for (Size i=0; i < LENGTH(strikes); ++i) {
        Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(strikes[i])));
        ext::shared_ptr<HestonProcess> hestonProcess(
            new HestonProcess(rTS, qTS, s0, 0.0625, 5, 0.16, 0.9, 0.1));
    
        ext::shared_ptr<PricingEngine> engine(
             new FdHestonVanillaEngine(ext::make_shared<HestonModel>(
                                 hestonProcess), 100, 400));
        option.setPricingEngine(engine);
        
        Real calculated = option.NPV();
        if (std::fabs(calculated - expected[i]) > tol) {
            BOOST_ERROR("Failed to reproduce expected npv"
                        << "\n    strike:     " << strikes[i]
                        << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected[i]
                        << "\n    tolerance:  " << tol); 
        }
    }
}

void FdHestonTest::testFdmHestonBlackScholes() {

    BOOST_TEST_MESSAGE("Testing FDM Heston with Black Scholes model...");

    SavedSettings backup;


    Settings::instance().evaluationDate() = Date(28, March, 2004);
    Date exerciseDate(26, June, 2004);

    Handle<YieldTermStructure> rTS(flatRate(0.10, Actual360()));
    Handle<YieldTermStructure> qTS(flatRate(0.0 , Actual360()));
    Handle<BlackVolTermStructure> volTS(
                    flatVol(rTS->referenceDate(), 0.25, rTS->dayCounter()));
    
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));

    ext::shared_ptr<StrikedTypePayoff> payoff(new
                                      PlainVanillaPayoff(Option::Put, 10));

    VanillaOption option(payoff, exercise);

    Real strikes[]  = { 8, 9, 10, 11, 12 };
    const Real tol = 0.0001;

    for (double& strike : strikes) {
        Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(strike)));

        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
                       new GeneralizedBlackScholesProcess(s0, qTS, rTS, volTS));

        option.setPricingEngine(ext::shared_ptr<PricingEngine>(
                                        new AnalyticEuropeanEngine(bsProcess)));
        
        const Real expected = option.NPV();
        
        ext::shared_ptr<HestonProcess> hestonProcess(
            new HestonProcess(rTS, qTS, s0, 0.0625, 1, 0.0625, 0.0001, 0.0));

        // Hundsdorfer scheme
        option.setPricingEngine(ext::shared_ptr<PricingEngine>(
             new FdHestonVanillaEngine(ext::make_shared<HestonModel>(
                                           hestonProcess), 
                                       100, 400, 3)));
        
        Real calculated = option.NPV();
        if (std::fabs(calculated - expected) > tol) {
            BOOST_ERROR("Failed to reproduce expected npv"
                        << "\n    strike:     " << strike << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected << "\n    tolerance:  " << tol);
        }
        
        // Explicit scheme
        option.setPricingEngine(ext::shared_ptr<PricingEngine>(
             new FdHestonVanillaEngine(ext::make_shared<HestonModel>(
                                           hestonProcess),
                                       4000, 400, 3, 0,
                                       FdmSchemeDesc::ExplicitEuler())));

        calculated = option.NPV();
        if (std::fabs(calculated - expected) > tol) {
            BOOST_ERROR("Failed to reproduce expected npv"
                        << "\n    strike:     " << strike << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected << "\n    tolerance:  " << tol);
        }
    }
}



void FdHestonTest::testFdmHestonEuropeanWithDividends() {

    BOOST_TEST_MESSAGE("Testing FDM with European option with dividends"
                       " in Heston model...");

    SavedSettings backup;

    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(100.0)));

    Handle<YieldTermStructure> rTS(flatRate(0.05, Actual365Fixed()));
    Handle<YieldTermStructure> qTS(flatRate(0.0 , Actual365Fixed()));

    ext::shared_ptr<HestonProcess> hestonProcess(
        new HestonProcess(rTS, qTS, s0, 0.04, 2.5, 0.04, 0.66, -0.8));

    Settings::instance().evaluationDate() = Date(28, March, 2004);
    Date exerciseDate(28, March, 2005);

    ext::shared_ptr<Exercise> exercise(new AmericanExercise(exerciseDate));

    ext::shared_ptr<StrikedTypePayoff> payoff(new
                                      PlainVanillaPayoff(Option::Put, 100));

    const std::vector<Real> dividends(1, 5);
    const std::vector<Date> dividendDates(1, Date(28, September, 2004));

    DividendVanillaOption option(payoff, exercise, dividendDates, dividends);
    ext::shared_ptr<PricingEngine> engine(
         new FdHestonVanillaEngine(ext::make_shared<HestonModel>(
                             hestonProcess), 50, 100, 50));
    option.setPricingEngine(engine);
    
    const Real tol = 0.01;
    const Real gammaTol = 0.001;
    const Real npvExpected   =  7.38216;
    const Real deltaExpected = -0.397902;
    const Real gammaExpected =  0.027747;
        
    if (std::fabs(option.NPV() - npvExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected npv"
                    << "\n    calculated: " << option.NPV()
                    << "\n    expected:   " << npvExpected
                    << "\n    tolerance:  " << tol); 
    }
    if (std::fabs(option.delta() - deltaExpected) > tol) {
        BOOST_ERROR("Failed to reproduce expected delta"
                    << "\n    calculated: " << option.delta()
                    << "\n    expected:   " << deltaExpected
                    << "\n    tolerance:  " << tol); 
    }
    if (std::fabs(option.gamma() - gammaExpected) > gammaTol) {
        BOOST_ERROR("Failed to reproduce expected gamma"
                    << "\n    calculated: " << option.gamma()
                    << "\n    expected:   " << gammaExpected
                    << "\n    tolerance:  " << tol); 
    }
}

namespace {
    struct HestonTestData {
        Real kappa;
        Real theta;
        Real sigma;
        Real rho;
        Real r;
        Real q;
        Real T;
        Real K;
    };    
}

void FdHestonTest::testFdmHestonConvergence() {

    /* convergence tests based on 
       ADI finite difference schemes for option pricing in the
       Heston model with correlation, K.J. in t'Hout and S. Foulon
    */
    
    BOOST_TEST_MESSAGE("Testing FDM Heston convergence...");

    SavedSettings backup;
    
    HestonTestData values[] = {
        { 1.5   , 0.04  , 0.3   , -0.9   , 0.025 , 0.0   , 1.0 , 100 },
        { 3.0   , 0.12  , 0.04  , 0.6    , 0.01  , 0.04  , 1.0 , 100 },
        { 0.6067, 0.0707, 0.2928, -0.7571, 0.03  , 0.0   , 3.0 , 100 },
        { 2.5   , 0.06  , 0.5   , -0.1   , 0.0507, 0.0469, 0.25, 100 }
    };

    FdmSchemeDesc schemes[] = {
        FdmSchemeDesc::Hundsdorfer(),
        FdmSchemeDesc::ModifiedCraigSneyd(),
        FdmSchemeDesc::ModifiedHundsdorfer(),
        FdmSchemeDesc::CraigSneyd(),
        FdmSchemeDesc::TrBDF2(),
        FdmSchemeDesc::CrankNicolson(),
    };
    
    Size tn[] = { 60 };
    Real v0[] = { 0.04 };
    
    const Date todaysDate(28, March, 2004); 
    Settings::instance().evaluationDate() = todaysDate;
    
    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(75.0)));

    for (const auto& scheme : schemes) {
        for (auto& value : values) {
            for (unsigned long j : tn) {
                for (double k : v0) {
                    Handle<YieldTermStructure> rTS(flatRate(value.r, Actual365Fixed()));
                    Handle<YieldTermStructure> qTS(flatRate(value.q, Actual365Fixed()));

                    ext::shared_ptr<HestonProcess> hestonProcess(new HestonProcess(
                        rTS, qTS, s0, k, value.kappa, value.theta, value.sigma, value.rho));

                    Date exerciseDate =
                        todaysDate + Period(static_cast<Integer>(value.T * 365), Days);
                    ext::shared_ptr<Exercise> exercise(
                                          new EuropeanExercise(exerciseDate));

                    ext::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(Option::Call, value.K));

                    VanillaOption option(payoff, exercise);
                    ext::shared_ptr<PricingEngine> engine(new FdHestonVanillaEngine(
                        ext::make_shared<HestonModel>(hestonProcess), j, 101, 51, 0, scheme));
                    option.setPricingEngine(engine);
                    
                    const Real calculated = option.NPV();
                    
                    ext::shared_ptr<PricingEngine> analyticEngine(
                        new AnalyticHestonEngine(
                            ext::make_shared<HestonModel>(
                                hestonProcess), 144));
                    
                    option.setPricingEngine(analyticEngine);
                    const Real expected = option.NPV();
                    if (   std::fabs(expected - calculated)/expected > 0.02
                        && std::fabs(expected - calculated) > 0.002) {
                        BOOST_ERROR("Failed to reproduce expected npv"
                                    << "\n    calculated: " << calculated
                                    << "\n    expected:   " << expected
                                    << "\n    tolerance:  " << 0.01); 
                    }
                }
            }
        }
    }
}

void FdHestonTest::testFdmHestonIntradayPricing() {
#ifdef QL_HIGH_RESOLUTION_DATE

    BOOST_TEST_MESSAGE("Testing FDM Heston intraday pricing ...");

    SavedSettings backup;

    const Option::Type type(Option::Put);
    const Real underlying = 36;
    const Real strike = underlying;
    const Spread dividendYield = 0.00;
    const Rate riskFreeRate = 0.06;
    const Real v0    = 0.2;
    const Real kappa = 1.0;
    const Real theta = v0;
    const Real sigma = 0.0065;
    const Real rho   = -0.75;
    const DayCounter dayCounter = Actual365Fixed();

    const Date maturity(17, May, 2014, 17, 30, 0);

    const ext::shared_ptr<Exercise> europeanExercise(
        new EuropeanExercise(maturity));
    const ext::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(type, strike));
    VanillaOption option(payoff, europeanExercise);

    const Handle<Quote> s0(
         ext::shared_ptr<Quote>(new SimpleQuote(underlying)));
    RelinkableHandle<BlackVolTermStructure> flatVolTS;
    RelinkableHandle<YieldTermStructure> flatTermStructure, flatDividendTS;
    const ext::shared_ptr<HestonProcess> process(
        new HestonProcess(flatTermStructure, flatDividendTS, s0,
              v0, kappa, theta, sigma, rho));
    const ext::shared_ptr<HestonModel> model(new HestonModel(process));
    const ext::shared_ptr<PricingEngine> fdm(
        new FdHestonVanillaEngine(model, 20, 100, 26, 0));
    option.setPricingEngine(fdm);

    const Real gammaExpected[] = {
        1.46757, 1.54696, 1.6408, 1.75409, 1.89464,
        2.07548, 2.32046, 2.67944, 3.28164, 4.64096  };

    for (Size i = 0; i < 10; ++i) {
        const Date now(17, May, 2014, 15, i*15, 0);
        Settings::instance().evaluationDate() = now;

        flatTermStructure.linkTo(ext::shared_ptr<YieldTermStructure>(
            new FlatForward(now, riskFreeRate, dayCounter)));
        flatDividendTS.linkTo(ext::shared_ptr<YieldTermStructure>(
            new FlatForward(now, dividendYield, dayCounter)));

        const Real gammaCalculated = option.gamma();
        if (std::fabs(gammaCalculated - gammaExpected[i]) > 1e-4) {
            BOOST_ERROR("unable to reproduce intraday gamma values at time "
                        << "\n   timestamp : " << io::iso_datetime(now)
                        << "\n   expiry    : " << io::iso_datetime(maturity)
                        << "\n   expected  : " << gammaExpected[i]
                        << "\n   calculated: "<<  gammaCalculated);
        }
    }
#endif
}

void FdHestonTest::testMethodOfLinesAndCN() {
    BOOST_TEST_MESSAGE("Testing method of lines to solve Heston PDEs...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(21, February, 2018);

    Settings::instance().evaluationDate() = today;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(100.0));
    const Handle<YieldTermStructure> qTS(flatRate(today, 0.0, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, 0.0, dc));

    const Real v0    = 0.09;
    const Real kappa = 1.0;
    const Real theta = v0;
    const Real sigma = 0.4;
    const Real rho   = -0.75;

    const Date maturity = today + Period(3, Months);

    const ext::shared_ptr<HestonModel> model(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                rTS, qTS, spot, v0, kappa, theta, sigma, rho)));

    const Size xGrid = 21;
    const Size vGrid = 7;

    const ext::shared_ptr<PricingEngine> fdmDefault(
        ext::make_shared<FdHestonVanillaEngine>(model, 10, xGrid, vGrid, 0));

    const ext::shared_ptr<PricingEngine> fdmMol(
        ext::make_shared<FdHestonVanillaEngine>(
            model, 10, xGrid, vGrid, 0, FdmSchemeDesc::MethodOfLines()));

    const ext::shared_ptr<PlainVanillaPayoff> payoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Put, spot->value());

    VanillaOption option(
        payoff, ext::make_shared<AmericanExercise>(maturity));

    option.setPricingEngine(fdmMol);
    const Real calculatedMoL = option.NPV();

    option.setPricingEngine(fdmDefault);
    const Real expected = option.NPV();

    const Real tol = 0.005;
    const Real diffMoL = std::fabs(expected - calculatedMoL);

    if (diffMoL > tol) {
        BOOST_FAIL("Failed to reproduce european option values with MOL"
                   << "\n    calculated: " << calculatedMoL
                   << "\n    expected:   " << expected
                   << "\n    difference: " << diffMoL
                   << "\n    tolerance:  " << tol);
    }

    const ext::shared_ptr<PricingEngine> fdmCN(
        ext::make_shared<FdHestonVanillaEngine>(
            model, 10, xGrid, vGrid, 0, FdmSchemeDesc::CrankNicolson()));
    option.setPricingEngine(fdmCN);

    const Real calculatedCN = option.NPV();
    const Real diffCN = std::fabs(expected - calculatedCN);

    if (diffCN > tol) {
        BOOST_FAIL("Failed to reproduce european option values with Crank-Nicolson"
                   << "\n    calculated: " << calculatedCN
                   << "\n    expected:   " << expected
                   << "\n    difference: " << diffCN
                   << "\n    tolerance:  " << tol);
    }

    BarrierOption barrierOption(
        Barrier::DownOut, 85.0, 10.0,
        payoff, ext::make_shared<EuropeanExercise>(maturity));

    barrierOption.setPricingEngine(
        ext::make_shared<FdHestonBarrierEngine>(model, 100, 31, 11));

    const Real expectedBarrier = barrierOption.NPV();

    barrierOption.setPricingEngine(
        ext::make_shared<FdHestonBarrierEngine>(model, 100, 31, 11, 0,
            FdmSchemeDesc::MethodOfLines()));

    const Real calculatedBarrierMoL = barrierOption.NPV();

    const Real barrierTol = 0.01;
    const Real barrierDiffMoL = std::fabs(expectedBarrier - calculatedBarrierMoL);

    if (barrierDiffMoL > barrierTol) {
        BOOST_FAIL("Failed to reproduce barrier option values with MOL"
                   << "\n    calculated: " << calculatedBarrierMoL
                   << "\n    expected:   " << expectedBarrier
                   << "\n    difference: " << barrierDiffMoL
                   << "\n    tolerance:  " << barrierTol);
    }

    barrierOption.setPricingEngine(
        ext::make_shared<FdHestonBarrierEngine>(model, 100, 31, 11, 0,
            FdmSchemeDesc::CrankNicolson()));

    const Real calculatedBarrierCN = barrierOption.NPV();
    const Real barrierDiffCN = std::fabs(expectedBarrier - calculatedBarrierCN);

    if (barrierDiffCN > barrierTol) {
        BOOST_FAIL("Failed to reproduce barrier option values with Crank-Nicolson"
                   << "\n    calculated: " << calculatedBarrierCN
                   << "\n    expected:   " << expectedBarrier
                   << "\n    difference: " << barrierDiffCN
                   << "\n    tolerance:  " << barrierTol);
    }
}

void FdHestonTest::testSpuriousOscillations() {
    BOOST_TEST_MESSAGE("Testing for spurious oscillations when "
            "solving the Heston PDEs...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(7, June, 2018);

    Settings::instance().evaluationDate() = today;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(100.0));
    const Handle<YieldTermStructure> qTS(flatRate(today, 0.1, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, 0.0, dc));

    const Real v0    = 0.005;
    const Real kappa = 1.0;
    const Real theta = 0.005;
    const Real sigma = 0.4;
    const Real rho   = -0.75;

    const Date maturity = today + Period(1, Years);

    const ext::shared_ptr<HestonProcess> process =
        ext::make_shared<HestonProcess>(
            rTS, qTS, spot, v0, kappa, theta, sigma, rho);

    const ext::shared_ptr<HestonModel> model =
        ext::make_shared<HestonModel>(process);

    const ext::shared_ptr<FdHestonVanillaEngine> hestonEngine(
        ext::make_shared<FdHestonVanillaEngine>(
            model, 6, 200, 13, 0, FdmSchemeDesc::TrBDF2()));

    VanillaOption option(
        ext::make_shared<PlainVanillaPayoff>(Option::Call, spot->value()),
        ext::make_shared<EuropeanExercise>(maturity));

    option.setupArguments(hestonEngine->getArguments());

    const ext::tuple<FdmSchemeDesc, std::string, bool> descs[] = {
        ext::make_tuple(FdmSchemeDesc::CraigSneyd(), "Craig-Sneyd", true),
        ext::make_tuple(FdmSchemeDesc::Hundsdorfer(), "Hundsdorfer", true),
        ext::make_tuple(
           FdmSchemeDesc::ModifiedHundsdorfer(), "Mod. Hundsdorfer", true),
        ext::make_tuple(FdmSchemeDesc::Douglas(), "Douglas", true),
        ext::make_tuple(FdmSchemeDesc::CrankNicolson(), "Crank-Nicolson", true),
        ext::make_tuple(FdmSchemeDesc::ImplicitEuler(), "Implicit", false),
        ext::make_tuple(FdmSchemeDesc::TrBDF2(), "TR-BDF2", false)
    };

    for (const auto& desc : descs) {
        const ext::shared_ptr<FdmHestonSolver> solver = ext::make_shared<FdmHestonSolver>(
            Handle<HestonProcess>(process), hestonEngine->getSolverDesc(1.0), ext::get<0>(desc));

        std::vector<Real> gammas;
        for (Real x=99; x < 101.001; x+=0.1) {
            gammas.push_back(solver->gammaAt(x, v0));
        }

        Real maximum = QL_MIN_REAL;
        for (Size i=1; i < gammas.size(); ++i) {
            const Real diff = std::fabs(gammas[i] - gammas[i-1]);
            if (diff > maximum)
                maximum = diff;
        }

        const Real tol = 0.01;
        const bool hasSpuriousOscillations = maximum > tol;

        if (hasSpuriousOscillations != ext::get<2>(desc)) {
            BOOST_ERROR("unable to reproduce spurious oscillation behaviour "
                        << "\n   scheme name          : " << ext::get<1>(desc)
                        << "\n   oscillations observed: " << hasSpuriousOscillations
                        << "\n   oscillations expected: " << ext::get<2>(desc));
        }
    }
}

test_suite* FdHestonTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Finite Difference Heston tests");

    suite->add(QUANTLIB_TEST_CASE(&FdHestonTest::testFdmHestonVarianceMesher));
    suite->add(QUANTLIB_TEST_CASE(&FdHestonTest::testFdmHestonBarrier));
    suite->add(QUANTLIB_TEST_CASE(&FdHestonTest::testFdmHestonAmerican));
    suite->add(QUANTLIB_TEST_CASE(&FdHestonTest::testFdmHestonIkonenToivanen));
    suite->add(QUANTLIB_TEST_CASE(
        &FdHestonTest::testFdmHestonEuropeanWithDividends));
    suite->add(QUANTLIB_TEST_CASE(
        &FdHestonTest::testFdmHestonIntradayPricing));
    suite->add(QUANTLIB_TEST_CASE(&FdHestonTest::testMethodOfLinesAndCN));
    suite->add(QUANTLIB_TEST_CASE(&FdHestonTest::testSpuriousOscillations));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(
            &FdHestonTest::testFdmHestonBlackScholes));
        suite->add(QUANTLIB_TEST_CASE(
            &FdHestonTest::testFdmHestonConvergence));
    }

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
            &FdHestonTest::testFdmHestonBarrierVsBlackScholes));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="109">
    <source>fdheston.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Klaus Spanderen
 Copyright (C) 2014 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fd_heston_hpp
#define quantlib_test_fd_heston_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FdHestonTest {
public:
    static void testFdmHestonVarianceMesher();
    static void testFdmHestonBarrier();
    static void testFdmHestonBarrierVsBlackScholes();
    static void testFdmHestonAmerican();
    static void testFdmHestonIkonenToivanen();
    static void testFdmHestonEuropeanWithDividends();
    static void testFdmHestonConvergence();
    static void testFdmHestonBlackScholes();
    static void testFdmHestonIntradayPricing();
    static void testMethodOfLinesAndCN();
    static void testSpuriousOscillations();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="110">
    <source>fdmlinearop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fdm_linear_op_hpp
#define quantlib_test_fdm_linear_op_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FdmLinearOpTest {
public:
    static void testFdmLinearOpLayout();
    static void testUniformGridMesher();
    static void testFirstDerivativesMapApply();
    static void testSecondDerivativesMapApply();
    static void testDerivativeWeightsOnNonUniformGrids();
    static void testSecondOrderMixedDerivativesMapApply();
    static void testTripleBandMapSolve();
    static void testFdmHestonBarrier();
    static void testFdmHestonAmerican();
    static void testFdmHestonExpress();
    static void testFdmHestonHullWhiteOp();
    static void testBiCGstab();
    static void testGMRES();
    static void testCrankNicolsonWithDamping();
    static void testSpareMatrixReference();
    static void testSparseMatrixZeroAssignment();
    static void testFdmMesherIntegral();
    static void testHighInterestRateBlackScholesMesher();
    static void testLowVolatilityHighDiscreteDividendBlackScholesMesher();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="111">
    <source>fdsabr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "fdsabr.hpp"
#include "utilities.hpp"
#include <ql/functional.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/randomnumbers/sobolbrownianbridgersg.hpp>
#include <ql/math/richardsonextrapolation.hpp>
#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>
#include <ql/pricingengines/vanilla/analyticcevengine.hpp>
#include <ql/pricingengines/vanilla/fdsabrvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/sabr.hpp>
#include <boost/make_shared.hpp>
#include <utility>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;

namespace {
    class SabrMonteCarloPricer {
      public:
        SabrMonteCarloPricer(Real f0,
                             Time maturity,
                             ext::shared_ptr<Payoff> payoff,
                             Real alpha,
                             Real beta,
                             Real nu,
                             Real rho)
        : f0_(f0), maturity_(maturity), payoff_(std::move(payoff)), alpha_(alpha), beta_(beta),
          nu_(nu), rho_(rho) {}

        Real operator()(Real dt) const {
            const Size nSims = 64*1024;

            const Real timeStepsPerYear = 1./dt;
            const Size timeSteps = Size(maturity_*timeStepsPerYear+1e-8);

            const Real sqrtDt = std::sqrt(dt);
            const Real w = std::sqrt(1.0-rho_*rho_);

            const Real logAlpha = std::log(alpha_);

            SobolBrownianBridgeRsg rsg(2, timeSteps, SobolBrownianGenerator::Diagonal, 12345U);

            GeneralStatistics stats;

            for (Size i=0; i < nSims; ++i) {
                Real f = f0_;
                Real a = logAlpha;

                const std::vector<Real> n = rsg.nextSequence().value;

                for (Size j=0; j < timeSteps && f > 0.0; ++j) {

                    const Real r1 = n[j];
                    const Real r2 = rho_*r1 + n[j+timeSteps]*w;

                    //Sample CEV distribution: accurate but slow
                    //
                    //const CEVRNDCalculator calc(f, std::exp(a), beta_);
                    //const Real u = CumulativeNormalDistribution()(r1);
                    //f = calc.invcdf(u, dt);

                    // simple Euler method
                    f += std::exp(a)*std::pow(f, beta_)*r1*sqrtDt;
                    a += - 0.5*nu_*nu_*dt + nu_*r2*sqrtDt;
                }
                f = std::max(0.0, f);
                stats.add((*payoff_)(f));
            }

            return stats.mean();
        }

      private:
        const Real f0_;
        const Time maturity_;
        const ext::shared_ptr<Payoff> payoff_;
        const Real alpha_, beta_, nu_, rho_;
    };

}


void FdSabrTest::testFdmSabrOp() {
    BOOST_TEST_MESSAGE("Testing FDM SABR operator...");

    SavedSettings backup;

    const Date today = Date(22, February, 2018);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const Date maturityDate = today + Period(2, Years);
    const Time maturityTime = dc.yearFraction(today, maturityDate);

    const Real strike = 1.5;

    const ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturityDate);

    const ext::shared_ptr<PlainVanillaPayoff> putPayoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Put, strike);
    const ext::shared_ptr<PlainVanillaPayoff> callPayoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Call, strike);

    VanillaOption optionPut(putPayoff, exercise);
    VanillaOption optionCall(callPayoff, exercise);

    const Handle<YieldTermStructure> rTS =
        Handle<YieldTermStructure>(flatRate(today, 0.0, dc));

    const Real f0    = 1.0;
    const Real alpha = 0.35;
    const Real nu    = 1.0;
    const Real rho   = 0.25;

    const Real betas[] = { 0.25, 0.6 };

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess =
        ext::make_shared<GeneralizedBlackScholesProcess>(
            Handle<Quote>(ext::make_shared<SimpleQuote>(f0)),
            rTS, rTS, Handle<BlackVolTermStructure>(flatVol(0.2, dc)));

    for (double beta : betas) {

        const ext::shared_ptr<PricingEngine> pdeEngine =
            ext::make_shared<FdSabrVanillaEngine>(f0, alpha, beta, nu, rho, rTS, 100, 400, 100);

        optionPut.setPricingEngine(pdeEngine);
        const Real pdePut = optionPut.NPV();

        // check put/call parity
        optionCall.setPricingEngine(pdeEngine);
        const Real pdeCall = optionCall.NPV();

        const Real pdeFwd = pdeCall - pdePut;

        const Real parityDiff = std::fabs(pdeFwd - (f0 - strike));
        const Real parityTol = 1e-4;
        if (parityDiff > parityTol) {
            BOOST_ERROR(
                "failed to validate the call/put parity"
                << "\n    beta           : " << beta
                << "\n    strike         : " << strike
                << "\n    fwd (call/put) : " << pdeFwd
                << "\n    fwd (f0-strike): " << f0-strike
                << "\n    diff           : " << parityDiff
                << "\n    tol            : " << parityTol);
        }

        const Real putPdeImplVol =
            optionPut.impliedVolatility(optionPut.NPV(), bsProcess, 1e-6);

        const ext::function<Real(Real)> mcSabr(
            SabrMonteCarloPricer(f0, maturityTime, putPayoff,
                                 alpha, beta, nu, rho));

        const Real mcNPV = RichardsonExtrapolation(
            mcSabr, 1/4.0)(4.0, 2.0);

        const Real putMcImplVol =
            optionPut.impliedVolatility(mcNPV, bsProcess, 1e-6);

        const Real volDiff = std::fabs(putPdeImplVol - putMcImplVol);

        const Real volTol = 5e-3;
        if (volDiff > volTol) {
            BOOST_ERROR(
                "failed to validate PDE against MC implied volatility"
                << "\n    beta         : " << beta
                << "\n    strike       : " << strike
                << "\n    PDE impl vol : " << putPdeImplVol
                << "\n    MC  impl vol : " << putMcImplVol
                << "\n    diff         : " << volDiff
                << "\n    tol          : " << volTol);
        }
    }
}

void FdSabrTest::testFdmSabrCevPricing() {
    BOOST_TEST_MESSAGE("Testing FDM CEV pricing with trivial SABR model...");

    SavedSettings backup;

    const Date today = Date(3, January, 2019);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const Date maturityDate = today + Period(12, Months);

    const Real betas[]   = { 0.1, 0.9 };
    const Real strikes[] = { 0.9, 1.5 };

    const Real f0    = 1.2;
    const Real alpha = 0.35;
    const Real nu    = 1e-3;
    const Real rho   = 0.25;

    const Handle<YieldTermStructure> rTS = Handle<YieldTermStructure>(
        flatRate(today, 0.05, dc));

    const ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturityDate);

    const Option::Type optionTypes[] = {Option::Put, Option::Call};

    const Real tol = 5e-5;

    for (auto optionType : optionTypes) {
        for (double strike : strikes) {
            const ext::shared_ptr<PlainVanillaPayoff> payoff =
                ext::make_shared<PlainVanillaPayoff>(optionType, strike);

            VanillaOption option(payoff, exercise);

            for (double beta : betas) {
                option.setPricingEngine(ext::make_shared<FdSabrVanillaEngine>(
                    f0, alpha, beta, nu, rho, rTS, 100, 400, 3));

                const Real calculated = option.NPV();

                option.setPricingEngine(ext::make_shared<AnalyticCEVEngine>(
                    f0, alpha, beta, rTS));

                const Real expected = option.NPV();

                if (std::fabs(expected-calculated) > tol) {
                    BOOST_ERROR(
                        "failed to calculate vanilla CEV option prices"
                        << "\n    beta            : " << beta
                        << "\n    strike          : " << strike
                        << "\n    option type     : "
                        << ((payoff->optionType() == Option::Call) ? "Call" : "Put")
                        << "\n    analytic npv    : " << expected
                        << "\n    pde npv         : " << calculated
                        << "\n    npv difference  : "
                        << std::fabs(expected - calculated)
                        << "\n    tolerance       : " << tol);
                }
            }
        }
    }
}

void FdSabrTest::testFdmSabrVsVolApproximation() {
    BOOST_TEST_MESSAGE("Testing FDM SABR vs approximations...");

    SavedSettings backup;

    const Date today = Date(8, January, 2019);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const Date maturityDate = today + Period(6, Months);
    const Time maturityTime = dc.yearFraction(today, maturityDate);

    const Handle<YieldTermStructure> rTS = Handle<YieldTermStructure>(
        flatRate(today, 0.05, dc));

    const Real f0 = 100;

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess =
        ext::make_shared<GeneralizedBlackScholesProcess>(
            Handle<Quote>(ext::make_shared<SimpleQuote>(f0)),
            rTS, rTS, Handle<BlackVolTermStructure>(flatVol(0.2, dc)));

    const Real alpha = 0.35;
    const Real beta  = 0.85;
    const Real nu    = 0.75;
    const Real rho   = 0.85;

    const Real strikes[] = { 90, 100, 110};
    const Option::Type optionTypes[] = {Option::Put, Option::Call};

    const Real tol = 2.5e-3;
    for (auto optionType : optionTypes) {
        for (double strike : strikes) {
            VanillaOption option(ext::make_shared<PlainVanillaPayoff>(optionType, strike),
                                 ext::make_shared<EuropeanExercise>(maturityDate));

            option.setPricingEngine(ext::make_shared<FdSabrVanillaEngine>(
                f0, alpha, beta, nu, rho, rTS, 25, 100, 50));

            const Volatility fdmVol =
                option.impliedVolatility(option.NPV(), bsProcess);

            const Real hagenVol = sabrVolatility(
                strike, f0, maturityTime, alpha, beta, nu, rho);

            const Real diff = std::fabs(fdmVol - hagenVol);

            if (std::fabs(fdmVol-hagenVol) > tol) {
                BOOST_ERROR(
                    "large difference between Hagen formula and FDM"
                    << "\n    strike          : " << strike
                    << "\n    option type     : "
                    << ((optionType == Option::Call) ? "Call" : "Put")
                    << "\n    Hagen vol       : " << hagenVol
                    << "\n    pde vol         : " << fdmVol
                    << "\n    vol difference  : " << diff
                    << "\n    tolerance       : " << tol);
            }
        }
    }
}


namespace {
    /*
     * Example and reference values are taken from
     * B. Chen, C.W. Oosterlee, H. Weide,
     * Efficient unbiased simulation scheme for the SABR stochastic volatility model.
     * https://http://ta.twi.tudelft.nl/mf/users/oosterle/oosterlee/SABRMC.pdf
     */

    class OsterleeReferenceResults {
      public:
        explicit OsterleeReferenceResults(Size i) : i_(i) { }

        Real operator()(Real t) const {
            Size i;
            if (close_enough(t, 1/16.))
                i = 0;
            else if (close_enough(t, 1/32.))
                i = 1;
            else
                QL_FAIL("unmatched reference result lookup");

            return data_[i_][i];
        }

      private:
        const Size i_;
        static Real data_[9][3];
    };

    Real OsterleeReferenceResults::data_[9][3] = {
        { 0.0610, 0.0604 }, { 0.0468, 0.0463 }, { 0.0347, 0.0343 },
        { 0.0632, 0.0625 }, { 0.0512, 0.0506 }, { 0.0406, 0.0400 },
        { 0.0635, 0.0630 }, { 0.0523, 0.0520 }, { 0.0422, 0.0421 }
    };
}

void FdSabrTest::testOosterleeTestCaseIV() {
    BOOST_TEST_MESSAGE("Testing Chen, Oosterlee and Weide test case IV...");

    SavedSettings backup;

    const Date today = Date(8, January, 2019);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const Handle<YieldTermStructure> rTS =
        Handle<YieldTermStructure>(flatRate(today, 0.0, dc));

    const Real f0    =  0.07;
    const Real alpha =  0.4;
    const Real nu    =  0.8;
    const Real beta  =  0.4;
    const Real rho   = -0.6;

    const Period maturities[] = {
        Period(2, Years), Period(5, Years), Period(10, Years)
    };

    const Real strikes[] = { 0.4*f0, f0, 1.6*f0 };

    const Real tol = 0.00035;
    for (Size i=0; i < LENGTH(maturities); ++i) {
        const Date maturityDate = today + maturities[i];
        const Time maturityTime = dc.yearFraction(today, maturityDate);

        const Size timeSteps = Size(5*maturityTime);

        const ext::shared_ptr<PricingEngine> engine =
            ext::make_shared<FdSabrVanillaEngine>(
                f0, alpha, beta, nu, rho, rTS, timeSteps, 200, 21);

        const ext::shared_ptr<Exercise> exercise =
            ext::make_shared<EuropeanExercise>(maturityDate);

        for (Size j=0; j < LENGTH(strikes); ++j) {
            const ext::shared_ptr<StrikedTypePayoff> payoff =
                ext::make_shared<PlainVanillaPayoff>(Option::Call, strikes[j]);

            VanillaOption option(payoff, exercise);
            option.setPricingEngine(engine);

            const Real calculated = option.NPV();

            const OsterleeReferenceResults referenceResuts(i*3+j);

            const Real expected = RichardsonExtrapolation(
                ext::function<Real(Real)>(referenceResuts), 1/16., 1)(2.);

            const Real diff = std::fabs(calculated - expected);
            if (diff > tol) {
                BOOST_ERROR(
                    "can not reproduce reference values from Monte-Carlo"
                    << "\n    strike     : " << payoff->strike()
                    << "\n    maturity   : " << maturityDate
                    << "\n    reference  : " << expected
                    << "\n    calculated : " << calculated
                    << "\n    difference : " << diff
                    << "\n    tolerance  : " << tol);
            }
        }
    }
}

void FdSabrTest::testBenchOpSabrCase() {
    BOOST_TEST_MESSAGE("Testing SABR BenchOp problem...");

    /*
     * von Sydow, L, Milovanovi, S, Larsson, E, In't Hout, K,
     * Wiktorsson, M, Oosterlee, C.W, Shcherbakov, V, Wyns, M,
     * Leitao Rodriguez, A, Jain, S, et al. (2018)
     * BENCHOPSLV: the BENCHmarking project in Option
     * PricingStochastic and Local Volatility problems
     * https://ir.cwi.nl/pub/28249
     */

    SavedSettings backup;

    const Date today = Date(8, January, 2019);
    const DayCounter dc = Actual365Fixed();
    Settings::instance().evaluationDate() = today;

    const Handle<YieldTermStructure> rTS =
        Handle<YieldTermStructure>(flatRate(today, 0.0, dc));

    const Size maturityInYears[] = { 2, 10 };

    const Real f0s[]    = { 0.5, 0.07 };
    const Real alphas[] = { 0.5, 0.4 };
    const Real nus[]    = { 0.4, 0.8 };
    const Real betas[]  = { 0.5, 0.5 };
    const Real rhos[]   = { 0.0, -0.6 };

    const Real expected[2][3] = {
        { 0.221383196830866, 0.193836689413803, 0.166240814653231 },
        { 0.052450313614407, 0.046585753491306, 0.039291470612989 }
    };

    const Size gridX = 400;
    const Size gridY = 25;
    const Size gridT = 10;

    const Real factor = 2;

    const Real tol = 2e-4;

    for (Size i=0; i < LENGTH(f0s); ++i) {

        const Date maturity = today + Period(maturityInYears[i]*365, Days);
        const Time T = dc.yearFraction(today, maturity);

        const Real f0    = f0s[i];
        const Real alpha = alphas[i];
        const Real nu    = nus[i];
        const Real beta  = betas[i];
        const Real rho   = rhos[i];

        const Real strikes[] = {
            f0*std::exp(-0.1*std::sqrt(T)), f0, f0*std::exp(0.1*std::sqrt(T))
        };

        for (Size j=0; j < LENGTH(strikes); ++j) {
            const Real strike = strikes[j];

            VanillaOption option(
                ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
                ext::make_shared<EuropeanExercise>(maturity));

            option.setPricingEngine(ext::make_shared<FdSabrVanillaEngine>(
                    f0, alpha, beta, nu, rho, rTS,
                    Size(gridT*factor),
                    Size(gridX*factor),
                    Size(gridY*std::sqrt(factor))));

            const Real calculated = option.NPV();
            const Real diff = std::fabs(calculated - expected[i][j]);

            if (diff > tol) {
                BOOST_ERROR(
                    "failed to reproduce reference values"
                    << "\n    strike     : " << strike
                    << "\n    maturity   : " << maturity
                    << "\n    reference  : " << expected[i][j]
                    << "\n    calculated : " << calculated
                    << "\n    difference : " << diff
                    << "\n    tolerance  : " << tol);
            }
        }
    }
}

test_suite* FdSabrTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Finite Difference SABR tests");

    suite->add(QUANTLIB_TEST_CASE(&FdSabrTest::testFdmSabrCevPricing));
    suite->add(QUANTLIB_TEST_CASE(&FdSabrTest::testFdmSabrVsVolApproximation));
    suite->add(QUANTLIB_TEST_CASE(&FdSabrTest::testOosterleeTestCaseIV));
    suite->add(QUANTLIB_TEST_CASE(&FdSabrTest::testBenchOpSabrCase));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&FdSabrTest::testFdmSabrOp));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="112">
    <source>fdsabr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fd_sabr_hpp
#define quantlib_test_fd_sabr_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FdSabrTest {
  public:
    static void testFdmSabrOp();
    static void testFdmSabrCevPricing();
    static void testFdmSabrVsVolApproximation();
    static void testOosterleeTestCaseIV();
    static void testBenchOpSabrCase();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel speed);
};

#endif
]]></document_content>
  </document>
  <document index="113">
    <source>fittedbonddiscountcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "fittedbonddiscountcurve.hpp"
#include "utilities.hpp"
#include <ql/termstructures/yield/fittedbonddiscountcurve.hpp>
#include <ql/termstructures/yield/nonlinearfittingmethods.hpp>
#include <ql/indexes/ibor/cdor.hpp>
#include <ql/instruments/bonds/zerocouponbond.hpp>
#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/canada.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/math/initializers.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void FittedBondDiscountCurveTest::testEvaluation() {

    BOOST_TEST_MESSAGE("Testing that fitted bond curves work as evaluators...");

    Date today = Settings::instance().evaluationDate();
    ext::shared_ptr<Bond> bond = ext::make_shared<ZeroCouponBond>(3, TARGET(), 100.0,
                                                                  today + Period(10, Years));
    Handle<Quote> q(ext::make_shared<SimpleQuote>(100.0));

    std::vector<ext::shared_ptr<BondHelper> > helpers(1);
    helpers[0] = ext::make_shared<BondHelper>(q, bond);

    ExponentialSplinesFitting fittingMethod;

    Size maxIterations = 0;
    Array guess(9);
    guess[0] = -51293.44;
    guess[1] = -212240.36;
    guess[2] = 168668.51;
    guess[3] = 88792.74;
    guess[4] = 120712.13;
    guess[5] = -34332.83;
    guess[6] = -66479.66;
    guess[7] = 13605.17;
    guess[8] = 0.0;

    FittedBondDiscountCurve curve(0, TARGET(), helpers, Actual365Fixed(),
                                  fittingMethod, 1e-10, maxIterations, guess);

    BOOST_CHECK_NO_THROW(curve.discount(3.0));
}

void FittedBondDiscountCurveTest::testFlatExtrapolation() {

    BOOST_TEST_MESSAGE("Testing fitted bond curve with flat extrapolation...");

    SavedSettings savedSettings;

    Date asof(15, Jul, 2019);
    Settings::instance().evaluationDate() = asof;

    // market quotes for bonds below
    Real quotes[] = {101.2100, 100.6270, 99.9210, 101.6700};

    std::vector<ext::shared_ptr<Bond> > bonds;

    // EJ5346956
    bonds.push_back(ext::make_shared<FixedRateBond>(
        2, 100.0,
        Schedule(Date(1, Feb, 2013), Date(3, Feb, 2020), 6 * Months, Canada(), Following, Following,
                 DateGeneration::Forward, false, Date(3, Aug, 2013)),
        std::vector<Real>(1, 0.046), ActualActual(ActualActual::ISDA)));

    // EK9689119
    bonds.push_back(ext::make_shared<FixedRateBond>(
        2, 100.0,
        Schedule(Date(12, Jun, 2015), Date(12, Jun, 2020), 6 * Months, Canada(), Following,
                 Following, DateGeneration::Forward, false, Date(12, Dec, 2015)),
        std::vector<Real>(1, 0.0295), ActualActual(ActualActual::ISDA)));

    // AQ1410069
    bonds.push_back(ext::make_shared<FixedRateBond>(
        2, 100.0,
        Schedule(Date(24, Nov, 2017), Date(24, Nov, 2020), 6 * Months, Canada(), Following,
                 Following, DateGeneration::Forward, false, Date(24, May, 2018)),
        std::vector<Real>(1, 0.02689), ActualActual(ActualActual::ISDA)));

    // AM5387676
    bonds.push_back(ext::make_shared<FixedRateBond>(
        2, 100.0,
        Schedule(Date(21, Feb, 2017), Date(21, Feb, 2022), 6 * Months, Canada(), Following,
                 Following, DateGeneration::Forward, false, Date(21, Aug, 2017)),
        std::vector<Real>(1, 0.0338), ActualActual(ActualActual::ISDA)));

    std::vector<ext::shared_ptr<BondHelper> > helpers;

    for (Size i = 0; i < bonds.size(); ++i) {
        helpers.push_back(ext::make_shared<BondHelper>(
            Handle<Quote>(ext::make_shared<SimpleQuote>(quotes[i])), bonds[i]));
    }

    // method1 with the usual extrapolation
    NelsonSiegelFitting method1;

    // method2 extrapoates flat before the first and after the last bond maturity
    NelsonSiegelFitting method2(
        Array(), ext::shared_ptr<OptimizationMethod>(), Array(),
        Actual365Fixed().yearFraction(asof, helpers.front()->bond()->maturityDate()),
        Actual365Fixed().yearFraction(asof, helpers.back()->bond()->maturityDate()));

    // Set a guess that will provoke a "bad" calibration for method1, actually this result was
    // observed as a real calibration outcome given the default guess. The setup was more
    // elaborate though and we do not aim to replicate that here.

    Array guess = { 0.0317, 5.0, -3.6796, 24.1703 };

    // build the fitted bond curves

    ext::shared_ptr<FittedBondDiscountCurve> curve1 = ext::make_shared<FittedBondDiscountCurve>(
        asof, helpers, Actual365Fixed(), method1, 1E-10, 10000, guess);

    ext::shared_ptr<FittedBondDiscountCurve> curve2 = ext::make_shared<FittedBondDiscountCurve>(
        asof, helpers, Actual365Fixed(), method2, 1E-10, 10000, guess);

    curve1->enableExtrapolation();
    curve2->enableExtrapolation();

    // extract the model prices using the two curves

    std::vector<Real> modelPrices1, modelPrices2;

    ext::shared_ptr<PricingEngine> engine1 =
        ext::make_shared<DiscountingBondEngine>(Handle<YieldTermStructure>(curve1));
    ext::shared_ptr<PricingEngine> engine2 =
        ext::make_shared<DiscountingBondEngine>(Handle<YieldTermStructure>(curve2));

    for (auto& bond : bonds) {
        bond->setPricingEngine(engine1);
        modelPrices1.push_back(bond->cleanPrice());
        bond->setPricingEngine(engine2);
        modelPrices2.push_back(bond->cleanPrice());
    }
    BOOST_CHECK_EQUAL(curve1->fitResults().errorCode(), EndCriteria::MaxIterations);
    BOOST_CHECK_EQUAL(curve2->fitResults().errorCode(), EndCriteria::MaxIterations);

    // the resulting cost values are similar for both approaches
    // i.e. the fit has a similar quality, I get for example:
    // fitted curve cost1 = 0.0921232
    // fitted curve cost2 = 0.0919438

    // Real cost1 = std::sqrt(curve1->fitResults().minimumCostValue());
    // Real cost2 = std::sqrt(curve2->fitResults().minimumCostValue());

    // It turns out that the model yields are quite close for model1 and model2 while the curve
    // yields are hugely different: for model1 the yields are completely off (>> 100%) while for
    // model2 they are close to the bond model yields, as it should be.
    //
    // The reason why model1 produces reasonable bond yields is that the compounding from the
    // evaluation date to the settlement date of the bonds compensates for the discounting of
    // the bond flows in the "right way", although the level of the curve yields is completely
    // off. I get these results:
    //
    // helper  maturity  market yield model yield 1 model yield 2 curve yield 1 curve yield 2
    //  0      0.556164     0.0235711     0.0235647     0.0235709       8.69643     0.0235709
    //  1      0.912329     0.0222977     0.0231515     0.0231468       5.31326     0.0231466
    //  2       1.36438     0.0272363     0.0254977     0.0255014       3.56288      0.025524
    //  3       2.61096     0.0268932     0.0277398     0.0277418       1.87629     0.0278147

    for (Size i = 0; i < helpers.size(); ++i) {
        Real t = curve1->timeFromReference(helpers[i]->bond()->maturityDate());
        // Real marketYield = bonds[i]->yield(quotes[i], Actual365Fixed(), Continuous, NoFrequency);
        // Real modelYield1 = bonds[i]->yield(modelPrices1[i], Actual365Fixed(), Continuous, NoFrequency);
        Real modelYield2 =
            bonds[i]->yield(modelPrices2[i], Actual365Fixed(), Continuous, NoFrequency);
        // Real curveYield1 = curve1->zeroRate(t, Continuous).rate();
        Real curveYield2 = curve2->zeroRate(t, Continuous).rate();

        BOOST_CHECK_CLOSE(modelYield2, curveYield2, 1.0); // 1.0 percent relative tolerance
    }
    
}


test_suite* FittedBondDiscountCurveTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Fitted bond discount curve tests");
    suite->add(QUANTLIB_TEST_CASE(&FittedBondDiscountCurveTest::testEvaluation));
    suite->add(QUANTLIB_TEST_CASE(&FittedBondDiscountCurveTest::testFlatExtrapolation));
    return suite;
}
]]></document_content>
  </document>
  <document index="114">
    <source>fittedbonddiscountcurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_fitted_bond_discount_curve_hpp
#define quantlib_test_fitted_bond_discount_curve_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FittedBondDiscountCurveTest {
  public:
    static void testEvaluation();
    static void testFlatExtrapolation();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="115">
    <source>forwardoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "forwardoption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/pricingengines/vanilla/binomialengine.hpp>
#include <ql/pricingengines/forward/forwardengine.hpp>
#include <ql/pricingengines/forward/forwardperformanceengine.hpp>
#include <ql/pricingengines/forward/mcforwardeuropeanbsengine.hpp>
#include <ql/pricingengines/forward/mcforwardeuropeanhestonengine.hpp>
#include <ql/experimental/forward/analytichestonforwardeuropeanengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, \
                       v, moneyness, reset, expected, calculated, \
                       error, tolerance) \
    BOOST_ERROR("Forward " << exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:        " << s << "\n" \
               << "    strike:            " << payoff->strike() <<"\n" \
               << "    moneyness:         " << moneyness << "\n" \
               << "    dividend yield:    " << io::rate(q) << "\n" \
               << "    risk-free rate:    " << io::rate(r) << "\n" \
               << "    reference date:    " << today << "\n" \
               << "    reset date:        " << reset << "\n" \
               << "    maturity:          " << exercise->lastDate() << "\n" \
               << "    volatility:        " << io::volatility(v) << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

namespace {

    struct ForwardOptionData {
        Option::Type type;
        Real moneyness;
        Real s;          // spot
        Rate q;          // dividend
        Rate r;          // risk-free rate
        Time start;      // time to reset
        Time t;          // time to maturity
        Volatility v;    // volatility
        Real result;     // expected result
        Real tol;        // tolerance
    };

}


void ForwardOptionTest::testValues() {

    BOOST_TEST_MESSAGE("Testing forward option values...");

    /* The data below are from
       "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
    */
    ForwardOptionData values[] = {
        //  type, moneyness, spot,  div, rate,start,   t,  vol, result, tol
        // "Option pricing formulas", pag. 37
        { Option::Call, 1.1, 60.0, 0.04, 0.08, 0.25, 1.0, 0.30, 4.4064, 1.0e-4 },
        // "Option pricing formulas", VBA code
        {  Option::Put, 1.1, 60.0, 0.04, 0.08, 0.25, 1.0, 0.30, 8.2971, 1.0e-4 }
    };

    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(today, qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(today, vol, dc));

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
         new BlackScholesMertonProcess(Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

    ext::shared_ptr<PricingEngine> engine(
              new ForwardVanillaEngine<AnalyticEuropeanEngine>(stochProcess));

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, 0.0));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
        Date reset = today + timeToDays(value.start);

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ForwardVanillaOption option(value.moneyness, reset, payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        Real tolerance = 1e-4;
        if (error>tolerance) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.moneyness, reset, value.result, calculated, error, tolerance);
        }
    }
}


void ForwardOptionTest::testPerformanceValues() {

    BOOST_TEST_MESSAGE("Testing forward performance option values...");

    /* The data below are the performance equivalent of the
       forward options tested above and taken from
       "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
    */
    ForwardOptionData values[] = {
        //  type, moneyness, spot,  div, rate,start, maturity,  vol,                       result, tol
        { Option::Call, 1.1, 60.0, 0.04, 0.08, 0.25,      1.0, 0.30, 4.4064/60*std::exp(-0.04*0.25), 1.0e-4 },
        {  Option::Put, 1.1, 60.0, 0.04, 0.08, 0.25,      1.0, 0.30, 8.2971/60*std::exp(-0.04*0.25), 1.0e-4 }
    };

    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(today, qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(today, vol, dc));

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
         new BlackScholesMertonProcess(Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

    ext::shared_ptr<PricingEngine> engine(
        new ForwardPerformanceVanillaEngine<AnalyticEuropeanEngine>(
                                                               stochProcess));

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, 0.0));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
        Date reset = today + timeToDays(value.start);

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ForwardVanillaOption option(value.moneyness, reset, payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        Real tolerance = 1e-4;
        if (error>tolerance) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.moneyness, reset, value.result, calculated, error, tolerance);
        }
    }
}


namespace {

    template <template <class> class Engine>
    void testForwardGreeks() {

        std::map<std::string,Real> calculated, expected, tolerance;
        tolerance["delta"]   = 1.0e-5;
        tolerance["gamma"]   = 1.0e-5;
        tolerance["theta"]   = 1.0e-5;
        tolerance["rho"]     = 1.0e-5;
        tolerance["divRho"]  = 1.0e-5;
        tolerance["vega"]    = 1.0e-5;

        Option::Type types[] = { Option::Call, Option::Put };
        Real moneyness[] = { 0.9, 1.0, 1.1 };
        Real underlyings[] = { 100.0 };
        Rate qRates[] = { 0.04, 0.05, 0.06 };
        Rate rRates[] = { 0.01, 0.05, 0.15 };
        Integer lengths[] = { 1, 2 };
        Integer startMonths[] = { 6, 9 };
        Volatility vols[] = { 0.11, 0.50, 1.20 };

        DayCounter dc = Actual360();
        Date today = Settings::instance().evaluationDate();

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
        ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
        ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
        Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
        ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
        Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
          new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

        ext::shared_ptr<PricingEngine> engine(
                            new Engine<AnalyticEuropeanEngine>(stochProcess));

        for (auto& type : types) {
            for (double& moneynes : moneyness) {
                for (int length : lengths) {
                    for (int startMonth : startMonths) {

                        Date exDate = today + length * Years;
                        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

                        Date reset = today + startMonth * Months;

                        ext::shared_ptr<StrikedTypePayoff> payoff(
                            new PlainVanillaPayoff(type, 0.0));

                        ForwardVanillaOption option(moneynes, reset, payoff, exercise);
                        option.setPricingEngine(engine);

                        for (double u : underlyings) {
                            for (double m : qRates) {
                                for (double n : rRates) {
                                    for (double v : vols) {

                                        Rate q = m, r = n;
                                        spot->setValue(u);
                                        qRate->setValue(q);
                                        rRate->setValue(r);
                                        vol->setValue(v);

                                        Real value = option.NPV();
                                        calculated["delta"] = option.delta();
                                        calculated["gamma"] = option.gamma();
                                        calculated["theta"] = option.theta();
                                        calculated["rho"] = option.rho();
                                        calculated["divRho"] = option.dividendRho();
                                        calculated["vega"] = option.vega();

                                        if (value > spot->value() * 1.0e-5) {
                                            // perturb spot and get delta and gamma
                                            Real du = u * 1.0e-4;
                                            spot->setValue(u + du);
                                            Real value_p = option.NPV(), delta_p = option.delta();
                                            spot->setValue(u - du);
                                            Real value_m = option.NPV(), delta_m = option.delta();
                                            spot->setValue(u);
                                            expected["delta"] = (value_p - value_m) / (2 * du);
                                            expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                            // perturb rates and get rho and dividend rho
                                            Spread dr = r * 1.0e-4;
                                            rRate->setValue(r + dr);
                                            value_p = option.NPV();
                                            rRate->setValue(r - dr);
                                            value_m = option.NPV();
                                            rRate->setValue(r);
                                            expected["rho"] = (value_p - value_m) / (2 * dr);

                                            Spread dq = q * 1.0e-4;
                                            qRate->setValue(q + dq);
                                            value_p = option.NPV();
                                            qRate->setValue(q - dq);
                                            value_m = option.NPV();
                                            qRate->setValue(q);
                                            expected["divRho"] = (value_p - value_m) / (2 * dq);

                                            // perturb volatility and get vega
                                            Volatility dv = v * 1.0e-4;
                                            vol->setValue(v + dv);
                                            value_p = option.NPV();
                                            vol->setValue(v - dv);
                                            value_m = option.NPV();
                                            vol->setValue(v);
                                            expected["vega"] = (value_p - value_m) / (2 * dv);

                                            // perturb date and get theta
                                            Time dT = dc.yearFraction(today - 1, today + 1);
                                            Settings::instance().evaluationDate() = today - 1;
                                            value_m = option.NPV();
                                            Settings::instance().evaluationDate() = today + 1;
                                            value_p = option.NPV();
                                            Settings::instance().evaluationDate() = today;
                                            expected["theta"] = (value_p - value_m) / dT;

                                            // compare
                                            std::map<std::string, Real>::iterator it;
                                            for (it = calculated.begin(); it != calculated.end();
                                                 ++it) {
                                                std::string greek = it->first;
                                                Real expct = expected[greek],
                                                     calcl = calculated[greek],
                                                     tol = tolerance[greek];
                                                Real error = relativeError(expct, calcl, u);
                                                if (error > tol) {
                                                    REPORT_FAILURE(greek, payoff, exercise, u, q, r,
                                                                   today, v, moneynes, reset, expct,
                                                                   calcl, error, tol);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}


void ForwardOptionTest::testGreeks() {

    BOOST_TEST_MESSAGE("Testing forward option greeks...");

    SavedSettings backup;

    testForwardGreeks<ForwardVanillaEngine>();
}


void ForwardOptionTest::testPerformanceGreeks() {

    BOOST_TEST_MESSAGE("Testing forward performance option greeks...");

    SavedSettings backup;

    testForwardGreeks<ForwardPerformanceVanillaEngine>();
}


class TestBinomialEngine : public BinomialVanillaEngine<CoxRossRubinstein>
{
private:
public:
   explicit TestBinomialEngine(
           const ext::shared_ptr<GeneralizedBlackScholesProcess > &process)
   : BinomialVanillaEngine<CoxRossRubinstein>(process, 300) // fixed steps
    {}
};


void ForwardOptionTest::testGreeksInitialization() {
   BOOST_TEST_MESSAGE("Testing forward option greeks initialization...");

   DayCounter dc = Actual360();
   SavedSettings backup;
   Date today = Settings::instance().evaluationDate();

   ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
   ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.04));
   Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
   ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.01));
   Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
   ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.11));
   Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

   ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
      new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

   ext::shared_ptr<PricingEngine> engine(
                        new ForwardVanillaEngine<TestBinomialEngine>(stochProcess));
   Date exDate = today + 1*Years;
   ext::shared_ptr<Exercise> exercise(
                                 new EuropeanExercise(exDate));
   Date reset = today + 6*Months;
   ext::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(Option::Call, 0.0));

   ForwardVanillaOption option(0.9, reset, payoff, exercise);
   option.setPricingEngine(engine);

   ext::shared_ptr<PricingEngine> ctrlengine(
                        new TestBinomialEngine(stochProcess));
   VanillaOption ctrloption(payoff, exercise);
   ctrloption.setPricingEngine(ctrlengine);

   Real delta = 0;
   try
   {
      delta = ctrloption.delta();
   }
   catch (const QuantLib::Error &) {
      // if normal option can't calculate delta,
      // nor should forward
      try
      {
         delta   = option.delta();
      }
      catch (const QuantLib::Error &) {
         delta = Null<Real>();
      }
      QL_REQUIRE(delta == Null<Real>(), "Forward delta invalid");
   }

   Real rho  = 0;
   try
   {
      rho = ctrloption.rho();
   }
   catch (const QuantLib::Error &) {
      // if normal option can't calculate rho,
      // nor should forward
      try
      {
         rho = option.rho();
      }
      catch (const QuantLib::Error &) {
         rho = Null<Real>();
      }
      QL_REQUIRE(rho == Null<Real>(), "Forward rho invalid");
   }

   Real divRho = 0;
   try
   {
      divRho = ctrloption.dividendRho();
   }
   catch (const QuantLib::Error &) {
      // if normal option can't calculate divRho,
      // nor should forward
      try
      {
         divRho = option.dividendRho();
      }
      catch (const QuantLib::Error &) {
         divRho = Null<Real>();
      }
      QL_REQUIRE(divRho == Null<Real>(), "Forward dividendRho invalid");
   }

   Real vega = 0;
   try
   {
      vega = ctrloption.vega();
   }
   catch (const QuantLib::Error &) {
      // if normal option can't calculate vega,
      // nor should forward
      try
      {
         vega = option.vega();
      }
      catch (const QuantLib::Error &) {
         vega = Null<Real>();
      }
      QL_REQUIRE(vega == Null<Real>(), "Forward vega invalid");
   }
}


void ForwardOptionTest::testMCPrices() {
   BOOST_TEST_MESSAGE("Testing forward option MC prices...");

   Real tolerance = 5e-4;

   Size timeSteps = 100;
   Size numberOfSamples = 32768;
   Size mcSeed = 42;

   Real q = 0.04;
   Real r = 0.01;
   Real sigma = 0.11;
   Real s = 100;

   DayCounter dc = Actual360();
   SavedSettings backup;
   Date today = Settings::instance().evaluationDate();

   ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(s));
   ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(q));
   Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
   ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(r));
   Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
   ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(sigma));
   Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

   ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
      new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

   ext::shared_ptr<PricingEngine> analyticEngine(
                        new ForwardVanillaEngine<AnalyticEuropeanEngine>(stochProcess));

   ext::shared_ptr<PricingEngine> mcEngine 
      = MakeMCForwardEuropeanBSEngine<PseudoRandom>(stochProcess)
            .withSteps(timeSteps)
            .withSamples(numberOfSamples)
            .withSeed(mcSeed);

   Date exDate = today + 1*Years;
   ext::shared_ptr<Exercise> exercise(
                                 new EuropeanExercise(exDate));
   Date reset = today + 6*Months;
   ext::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(Option::Call, 0.0));

   Real moneyness[] = { 0.8, 0.9, 1.0, 1.1, 1.2 };

   for (double& moneynes : moneyness) {

       ForwardVanillaOption option(moneynes, reset, payoff, exercise);

       option.setPricingEngine(analyticEngine);
       Real analyticPrice = option.NPV();

       option.setPricingEngine(mcEngine);
       Real mcPrice = option.NPV();

       Real error = relativeError(analyticPrice, mcPrice, s);
       if (error > tolerance) {
           REPORT_FAILURE("testMCPrices", payoff, exercise, s, q, r, today, sigma, moneynes, reset,
                          analyticPrice, mcPrice, error, tolerance);
       }
   }
}


void ForwardOptionTest::testHestonMCPrices() {
   BOOST_TEST_MESSAGE("Testing forward option Heston MC prices...");

   Option::Type optionTypes[] = { Option::Call, Option::Put };

   for (auto type : optionTypes) {

       Real mcTolerance = 5e-4;
       Real analyticTolerance = 5e-4;

       Size timeSteps = 50;
       Size numberOfSamples = 32768;
       Size mcSeed = 42;

       Real q = 0.04;
       Real r = 0.01;
       Real sigma_bs = 0.245;
       Real s = 100;

       // Test 1: Set up an equivalent flat Heston and compare to analytical BS pricing
       Real v0 = sigma_bs * sigma_bs;
       Real kappa = 1e-8;
       Real theta = sigma_bs * sigma_bs;
       Real sigma = 1e-8;
       Real rho = -0.93;

       DayCounter dc = Actual360();
       SavedSettings backup;
       Date today = Settings::instance().evaluationDate();

       Date exDate = today + 1 * Years;
       ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
       Date reset = today + 6 * Months;
       ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, 0.0));

       ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(s));
       ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(q));
       Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
       ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(r));
       Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
       ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(sigma_bs));
       Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

       ext::shared_ptr<BlackScholesMertonProcess> bsProcess(
           new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

       ext::shared_ptr<PricingEngine> analyticEngine(
           new ForwardVanillaEngine<AnalyticEuropeanEngine>(bsProcess));

       ext::shared_ptr<HestonProcess> hestonProcess(
           new HestonProcess(rTS, qTS, Handle<Quote>(spot), v0, kappa, theta, sigma, rho));

       ext::shared_ptr<PricingEngine> mcEngine =
           MakeMCForwardEuropeanHestonEngine<LowDiscrepancy>(hestonProcess)
               .withSteps(timeSteps)
               .withSamples(numberOfSamples)
               .withSeed(mcSeed);

       Real moneyness[] = {0.8, 0.9, 1.0, 1.1, 1.2};

       for (double& moneynes : moneyness) {

           ForwardVanillaOption option(moneynes, reset, payoff, exercise);

           option.setPricingEngine(analyticEngine);
           Real analyticPrice = option.NPV();

           option.setPricingEngine(mcEngine);
           Real mcPrice = option.NPV();

           Real mcError = relativeError(analyticPrice, mcPrice, s);
           if (mcError > mcTolerance) {
               REPORT_FAILURE("testHestonMCForwardStartPrices", payoff, exercise, s, q, r, today,
                              sigma_bs, moneynes, reset, analyticPrice, mcPrice, mcError,
                              mcTolerance);
           }
       }


       // Test 2: Using an arbitrary Heston model, check that prices match semi-analytical
       // Heston prices when reset date is t=0
       v0 = sigma_bs * sigma_bs;
       kappa = 1.0;
       theta = 0.08;
       sigma = 0.39;
       rho = -0.93;

       reset = today;

       ext::shared_ptr<HestonProcess> hestonProcessSmile(
           new HestonProcess(rTS, qTS, Handle<Quote>(spot), v0, kappa, theta, sigma, rho));

       ext::shared_ptr<HestonModel> hestonModel(ext::make_shared<HestonModel>(hestonProcessSmile));

       ext::shared_ptr<PricingEngine> analyticHestonEngine(
           ext::make_shared<AnalyticHestonEngine>(hestonModel, 96));

       ext::shared_ptr<PricingEngine> mcEngineSmile =
           MakeMCForwardEuropeanHestonEngine<LowDiscrepancy>(hestonProcessSmile)
               .withSteps(timeSteps)
               .withSamples(numberOfSamples)
               .withSeed(mcSeed);

       ext::shared_ptr<AnalyticHestonForwardEuropeanEngine> analyticForwardHestonEngine(
           new AnalyticHestonForwardEuropeanEngine(hestonProcessSmile));

       for (double& moneynes : moneyness) {

           Real strike = s * moneynes;
           ext::shared_ptr<StrikedTypePayoff> vanillaPayoff(new PlainVanillaPayoff(type, strike));

           VanillaOption vanillaOption(vanillaPayoff, exercise);
           ForwardVanillaOption forwardOption(moneynes, reset, payoff, exercise);

           vanillaOption.setPricingEngine(analyticHestonEngine);
           Real analyticPrice = vanillaOption.NPV();

           forwardOption.setPricingEngine(mcEngineSmile);
           Real mcPrice = forwardOption.NPV();

           Real mcError = relativeError(analyticPrice, mcPrice, s);
           if (mcError > mcTolerance) {
               REPORT_FAILURE("testHestonMCPrices", vanillaPayoff, exercise, s, q, r, today,
                              sigma_bs, moneynes, reset, analyticPrice, mcPrice, mcError,
                              mcTolerance);
           }

           // T=0, testing the Analytic Pricer's T=0 analytical solution
           forwardOption.setPricingEngine(analyticForwardHestonEngine);
           Real hestonAnalyticPrice = forwardOption.NPV();

           Real analyticError = relativeError(analyticPrice, hestonAnalyticPrice, s);
           if (analyticError > analyticTolerance) {
               REPORT_FAILURE("testHestonAnalyticForwardStartPrices", vanillaPayoff, exercise, s, q,
                              r, today, sigma_bs, moneynes, reset, analyticPrice,
                              hestonAnalyticPrice, analyticError, analyticTolerance);
           }
       }
   }
}


void ForwardOptionTest::testHestonAnalyticalVsMCPrices() {
   BOOST_TEST_MESSAGE("Testing Heston analytic vs MC prices...");

   Option::Type optionTypes[] = { Option::Call, Option::Put };

   for (auto type : optionTypes) {

       Real tolerance = 1e-3;
       Size timeSteps = 50;
       Size numberOfSamples = 16383;
       Size mcSeed = 42;

       Real q = 0.03;
       Real r = 0.005;
       Real s = 100;

       Real vol = 0.3;
       Real v0 = vol * vol;
       Real kappa = 11.35;
       Real theta = 0.022;
       Real sigma = 0.618;
       Real rho = -0.5;

       DayCounter dc = Actual360();
       SavedSettings backup;
       Date today = Settings::instance().evaluationDate();

       Date exDate = today + 1 * Years;
       ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
       Date reset = today + 6 * Months;
       ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, 0.0));

       ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(s));
       ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(q));
       Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
       ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(r));
       Handle<YieldTermStructure> rTS(flatRate(rRate, dc));

       ext::shared_ptr<HestonProcess> hestonProcess(
           new HestonProcess(rTS, qTS, Handle<Quote>(spot), v0, kappa, theta, sigma, rho));

       ext::shared_ptr<PricingEngine> mcEngine =
           MakeMCForwardEuropeanHestonEngine<PseudoRandom>(hestonProcess)
               .withSteps(timeSteps)
               .withSamples(numberOfSamples)
               .withSeed(mcSeed);

       ext::shared_ptr<PricingEngine> mcEngineCv =
           MakeMCForwardEuropeanHestonEngine<PseudoRandom>(hestonProcess)
               .withSteps(timeSteps)
               .withSamples(numberOfSamples)
               .withSeed(mcSeed)
               .withControlVariate(true);

       ext::shared_ptr<AnalyticHestonForwardEuropeanEngine> analyticEngine(
           new AnalyticHestonForwardEuropeanEngine(hestonProcess));

      Real moneyness[] = { 0.8, 1.0, 1.2 };

      for (double& m : moneyness) {

          ForwardVanillaOption option(m, reset, payoff, exercise);

          option.setPricingEngine(analyticEngine);
          Real analyticPrice = option.NPV();

          option.setPricingEngine(mcEngine);
          Real mcPrice = option.NPV();
          Real error = relativeError(analyticPrice, mcPrice, s);

          if (error > tolerance) {
              REPORT_FAILURE("testHestonMCVsAnalyticPrices", payoff, exercise, s, q, r, today, vol,
                             m, reset, analyticPrice, mcPrice, error, tolerance);
          }

          option.setPricingEngine(mcEngineCv);
          Real mcPriceCv = option.NPV();

          Real errorCv = relativeError(analyticPrice, mcPriceCv, s);
          if (errorCv > tolerance) {
              REPORT_FAILURE("testHestonMCControlVariateVsAnalyticPrices", payoff, exercise, s, q,
                             r, today, vol, m, reset, analyticPrice, mcPrice, errorCv,
                             tolerance);
          }
      }
   }
}



test_suite* ForwardOptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Forward option tests");

    suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testValues));
    suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testGreeks));
    suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testPerformanceValues));
    suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testPerformanceGreeks));
    suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testGreeksInitialization));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testMCPrices));
    }

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testHestonAnalyticalVsMCPrices));
        suite->add(QUANTLIB_TEST_CASE(&ForwardOptionTest::testHestonMCPrices));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="116">
    <source>forwardoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_forward_option_hpp
#define quantlib_test_forward_option_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ForwardOptionTest {
  public:
    static void testValues();
    static void testGreeks();
    static void testPerformanceValues();
    static void testPerformanceGreeks();
    static void testGreeksInitialization();
    static void testMCPrices();
    static void testHestonMCPrices();
    static void testHestonAnalyticalVsMCPrices();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="117">
    <source>forwardrateagreement.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
   Copyright (C) 2018 Tom Anderson

   This file is part of QuantLib, a free-software/open-source library
   for financial quantitative analysts and developers - http://quantlib.org/

   QuantLib is free software: you can redistribute it and/or modify it
   under the terms of the QuantLib license.  You should have received a
   copy of the license along with this program; if not, please email
   <quantlib-dev@lists.sf.net>. The license is also available online at
   <http://quantlib.org/license.shtml>.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "forwardrateagreement.hpp"
#include "utilities.hpp"
#include <ql/handle.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/instruments/forwardrateagreement.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>


using namespace QuantLib;
using namespace boost::unit_test_framework;

void ForwardRateAgreementTest::testConstructionWithoutACurve() {
        BOOST_TEST_MESSAGE("Testing forward rate agreement construction...");

        Date today = QuantLib::Settings::instance().evaluationDate();

        // set up the index
        RelinkableHandle<YieldTermStructure> curveHandle;
        ext::shared_ptr<IborIndex> index = ext::make_shared<USDLibor>(Period(3, Months), curveHandle);

        // determine the settlement date for a FRA
        Date settlementDate = index->fixingCalendar().advance(today, index->fixingDays() * Days);

        // set up quotes with no values
        std::vector<ext::shared_ptr<SimpleQuote> > quotes = {
            ext::make_shared<SimpleQuote>(),
            ext::make_shared<SimpleQuote>(),
            ext::make_shared<SimpleQuote>()
        };

#ifdef QL_USE_INDEXED_COUPON
        bool useIndexedFra = false;
#else
        bool useIndexedFra = true;
#endif

        // set up the curve (this bit is a very rough sketch - i'm actually using swaps !)
        std::vector<ext::shared_ptr<RateHelper> > helpers;
        helpers.push_back(ext::make_shared<FraRateHelper>(Handle<Quote>(quotes[0]),
                                                          Period(1, Years), index,
                                                          Pillar::LastRelevantDate, Date(),
                                                          useIndexedFra));
        helpers.push_back(ext::make_shared<FraRateHelper>(Handle<Quote>(quotes[1]),
                                                          Period(2, Years), index,
                                                          Pillar::LastRelevantDate, Date(),
                                                          useIndexedFra));
        helpers.push_back(ext::make_shared<FraRateHelper>(Handle<Quote>(quotes[2]),
                                                          Period(3, Years), index,
                                                          Pillar::LastRelevantDate, Date(),
                                                          useIndexedFra));
        ext::shared_ptr<PiecewiseYieldCurve<ForwardRate, QuantLib::Cubic> > curve =
            ext::make_shared<PiecewiseYieldCurve<ForwardRate, QuantLib::Cubic> >(
                today, helpers, index->dayCounter());

        curveHandle.linkTo(curve);

        // set up the instrument to price
        ForwardRateAgreement fra(settlementDate + Period(12, Months),
                                 settlementDate + Period(15, Months),
                                 Position::Long,
                                 0,
                                 1,
                                 index,
                                 curveHandle,
                                 useIndexedFra);

        // finally put values in the quotes
        quotes[0]->setValue(0.01);
        quotes[1]->setValue(0.02);
        quotes[2]->setValue(0.03);

        double rate = fra.forwardRate();
        if (std::fabs(rate - 0.01) > 1e-6) {
            BOOST_ERROR("grid creation failed, got rate " << rate << " expected " << 0.01);
        }
}

test_suite* ForwardRateAgreementTest::suite() {
    auto* suite = BOOST_TEST_SUITE("forward rate agreement");
    suite->add(QUANTLIB_TEST_CASE(&ForwardRateAgreementTest::testConstructionWithoutACurve));
    return suite;
}
]]></document_content>
  </document>
  <document index="118">
    <source>forwardrateagreement.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Tom Anderson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_forward_rate_agreement_hpp
#define quantlib_test_forward_rate_agreement_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ForwardRateAgreementTest {
  public:
    static void testConstructionWithoutACurve();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="119">
    <source>functions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2014 Klaus Spanderen
 Copyright (C) 2015 Johannes Gttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "functions.hpp"
#include "utilities.hpp"
#include <ql/math/factorial.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/math/modifiedbessel.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::exp;

void FunctionsTest::testFactorial() {

    BOOST_TEST_MESSAGE("Testing factorial numbers...");

    Real expected = 1.0;
    Real calculated = Factorial::get(0);
    if (calculated!=expected)
        BOOST_FAIL("Factorial(0) = " << calculated);

    for (Natural i=1; i<171; ++i) {
        expected *= i;
        calculated = Factorial::get(i);
        if (std::fabs(calculated-expected)/expected > 1.0e-9)
            BOOST_FAIL("Factorial(" << i << ")" <<
                       std::setprecision(16) << std::scientific <<
                       "\n calculated: " << calculated <<
                       "\n   expected: " << expected <<
                       "\n rel. error: " <<
                       std::fabs(calculated-expected)/expected);
    }
}

void FunctionsTest::testGammaFunction() {

    BOOST_TEST_MESSAGE("Testing Gamma function...");

    Real expected = 0.0;
    Real calculated = GammaFunction().logValue(1);
    if (std::fabs(calculated) > 1.0e-15)
        BOOST_ERROR("GammaFunction(1)\n"
                    << std::setprecision(16) << std::scientific
                    << "    calculated: " << calculated << "\n"
                    << "    expected:   " << expected);

    for (Size i=2; i<9000; i++) {
        expected  += std::log(Real(i));
        calculated = GammaFunction().logValue(static_cast<Real>(i+1));
        if (std::fabs(calculated-expected)/expected > 1.0e-9)
            BOOST_ERROR("GammaFunction(" << i << ")\n"
                        << std::setprecision(16) << std::scientific
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << expected << "\n"
                        << "    rel. error: "
                        << std::fabs(calculated-expected)/expected);
    }
}

void FunctionsTest::testGammaValues() {

    BOOST_TEST_MESSAGE("Testing Gamma values...");

    // reference results are calculated with R
    Real tasks[][3] = {
            { 0.0001, 9999.422883231624, 1e3},
            { 1.2, 0.9181687423997607, 1e3},
            { 7.3, 1271.4236336639089586, 1e3},
            {-1.1, 9.7148063829028946, 1e3},
            {-4.001,-41.6040228304425312, 1e3},
            {-4.999, -8.347576090315059, 1e3},
            {-19.000001, 8.220610833201313e-12, 1e8},
            {-19.5, 5.811045977502255e-18, 1e3},
            {-21.000001, 1.957288098276488e-14, 1e8},
            {-21.5, 1.318444918321553e-20, 1e6}
    };

    for (auto& task : tasks) {
        const Real x = task[0];
        const Real expected = task[1];
        const Real calculated = GammaFunction().value(x);
        const Real tol = task[2] * QL_EPSILON * std::fabs(expected);

        if (std::fabs(calculated - expected) > tol) {
            BOOST_ERROR("GammaFunction(" << x << ")\n"
                        << std::setprecision(16) << std::scientific
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << expected << "\n"
                        << "    rel. error: "
                        << std::fabs(calculated-expected)/expected);
        }
    }
}

void FunctionsTest::testModifiedBesselFunctions() {
    BOOST_TEST_MESSAGE("Testing modified Bessel function of first and second kind...");

    /* reference values are computed with R and the additional package Bessel
     * http://cran.r-project.org/web/packages/Bessel
     */

    Real r[][4] = {
        {-1.3, 2.0, 1.2079888436539505, 0.1608243636110430},
        { 1.3, 2.0, 1.2908192151358788, 0.1608243636110430},
        { 0.001, 2.0, 2.2794705965773794, 0.1138938963603362},
        { 1.2, 0.5,   0.1768918783499572, 2.1086579232338192},
        { 2.3, 0.1, 0.00037954958988425198, 572.096866928290183},
        {-2.3, 1.1, 1.07222017902746969, 1.88152553684107371},
        {-10.0001, 1.1, 13857.7715614282552, 69288858.9474423379}
    };

    for (auto& i : r) {
        const Real nu = i[0];
        const Real x = i[1];
        const Real expected_i = i[2];
        const Real expected_k = i[3];
        const Real tol_i = 5e4 * QL_EPSILON*std::fabs(expected_i);
        const Real tol_k = 5e4 * QL_EPSILON*std::fabs(expected_k);

        const Real calculated_i = modifiedBesselFunction_i(nu, x);
        const Real calculated_k = modifiedBesselFunction_k(nu, x);

        if (std::fabs(expected_i - calculated_i) > tol_i) {
            BOOST_ERROR("failed to reproduce modified Bessel "
                       << "function of first kind"
                       << "\n order     : " << nu
                       << "\n argument  : " << x
                       << "\n calculated: " << calculated_i
                       << "\n expected  : " << expected_i);
        }
        if (std::fabs(expected_k - calculated_k) > tol_k) {
            BOOST_ERROR("failed to reproduce modified Bessel "
                       << "function of second kind"
                       << "\n order     : " << nu
                       << "\n argument  : " << x
                       << "\n calculated: " << calculated_k
                       << "\n expected  : " << expected_k);
        }
    }

    Real c[][7] = {
        {-1.3, 2.0, 0.0, 1.2079888436539505, 0.0,
                         0.1608243636110430, 0.0},
        { 1.2, 1.5, 0.3, 0.7891550871263575, 0.2721408731632123,
                         0.275126507673411, -0.1316314405663727},
        { 1.2, -1.5,0.0,-0.6650597524355781, -0.4831941938091643,
                        -0.251112360556051, -2.400130904230102},
        {-11.2, 1.5, 0.3,12780719.20252659, 16401053.26770633,
                        -34155172.65672453, -43830147.36759921},
        { 1.2, -1.5,2.0,-0.3869803778520574, 0.9756701796853728,
                        -3.111629716783005, 0.6307859871879062},
        { 1.2, 0.0, 9.9999,-0.03507838078252647, 0.1079601550451466,
                        -0.05979939995451453, 0.3929814473878203},
        { 1.2, 0.0, 10.1, -0.02782046891519293, 0.08562259917678558,
                        -0.02035685034691133, 0.3949834389686676},
        { 1.2, 0.0, 12.1, 0.07092110620741207, -0.2182727210128104,
                        0.3368505862966958, -0.1299038064313366},
        { 1.2, 0.0, 14.1,-0.03014378676768797, 0.09277303628303372,
                        -0.237531022649052, -0.2351923034581644},
        { 1.2, 0.0, 16.1,-0.03823210284792657, 0.1176663135266562,
                        -0.1091239402448228, 0.2930535651966139},
        { 1.2, 0.0, 18.1,0.05626742394733754, -0.173173324361983,
                        0.2941636588154642, -0.02023355577954348},
        { 1.2, 0.0, 180.1,-0.001230682086826484, 0.003787649998122361,
                        0.02284509628723454, 0.09055419580980778},
        { 1.2, 0.0, 21.0,-0.04746415965014021, 0.1460796627610969,
                        -0.2693825171336859, -0.04830804448126782},
        { 1.2, 10.0, 0.0, 2609.784936867044, 0, 1.904394919838336e-05, 0},
        { 1.2, 14.0, 0.0, 122690.4873454286, 0, 2.902060692576643e-07, 0},
        { 1.2, 20.0, 10.0, -37452017.91168936, -13917587.22151363,
                        -3.821534367487143e-10, 4.083211255351664e-10},
        { 1.2, 9.0, 9.0, -621.7335051293694,  618.1455736670332,
                        -4.480795479964915e-05, -3.489034389148745e-08}
    };

    for (auto& i : c) {
        const Real nu = i[0];
        const std::complex<Real> z = std::complex<Real>(i[1], i[2]);
        const std::complex<Real> expected_i = std::complex<Real>(i[3], i[4]);
        const std::complex<Real> expected_k = std::complex<Real>(i[5], i[6]);

        const Real tol_i = 5e4*QL_EPSILON*std::abs(expected_i);
        const Real tol_k = 1e6*QL_EPSILON*std::abs(expected_k);

        const std::complex<Real> calculated_i=modifiedBesselFunction_i(nu, z);
        const std::complex<Real> calculated_k=modifiedBesselFunction_k(nu, z);

        if (std::abs(expected_i - calculated_i) > tol_i) {
            BOOST_ERROR("failed to reproduce modified Bessel "
                       << "function of first kind"
                       << "\n order     : " << nu
                       << "\n argument  : " << z
                       << "\n calculated: " << calculated_i
                       << "\n expected  : " << expected_i);
        }
        if (   std::abs(expected_k) > 1e-4 // do not check small values
            && std::abs(expected_k - calculated_k) > tol_k) {
            BOOST_ERROR("failed to reproduce modified Bessel "
                       << "function of second kind"
                       << "\n order     : " << nu
                       << "\n argument  : " << z
                       << "\n diff      : " << calculated_k-expected_k
                       << "\n calculated: " << calculated_k
                       << "\n expected  : " << expected_k);
        }
    }
}

void FunctionsTest::testWeightedModifiedBesselFunctions() {
    BOOST_TEST_MESSAGE("Testing weighted modified Bessel functions...");
    Real nu = -5.0;
    while (nu <= 5.0) {
        Real x = 0.1;
        while (x <= 15.0) {
            const Real calculated_i = 
                modifiedBesselFunction_i_exponentiallyWeighted(nu, x);
            const Real expected_i = 
                modifiedBesselFunction_i(nu, x) * exp(-x);
            const Real calculated_k = 
                modifiedBesselFunction_k_exponentiallyWeighted(nu, x);
            const Real expected_k = 
                M_PI_2 * (modifiedBesselFunction_i(-nu,x) -
                          modifiedBesselFunction_i(nu,x)) * exp(-x) / std::sin(M_PI*nu);
            const Real tol_i = 1e3 * QL_EPSILON *
                std::fabs(expected_i) * std::max(exp(x), 1.0);
            const Real tol_k = std::max(QL_EPSILON, 
                1e3 * QL_EPSILON *
                std::fabs(expected_k) * std::max(exp(x), 1.0));
            if (std::abs(expected_i - calculated_i) > tol_i) {
                BOOST_ERROR("failed to verify exponentially weighted"
                            << "modified Bessel function of first kind"
                            << "\n order      : " << nu << "\n argument   : "
                            << x << "\n calculated  : " << calculated_i
                            << "\n expected   : " << expected_i);
            }
            if (std::abs(expected_k - calculated_k) > tol_k) {
                BOOST_ERROR("failed to verify exponentially weighted"
                            << "modified Bessel function of second kind"
                            << "\n order      : " << nu << "\n argument   : "
                            << x << "\n calculated  : " << calculated_k
                            << "\n expected   : " << expected_k);
            }
            x += 0.5;
        }
        nu += 0.5;
    }
    nu = -5.0;
    while (nu <= 5.0) {
        Real x = -5.0;
        while (x <= 5.0) {
            Real y = -5.0;
            while (y <= 5.0) {
                const std::complex<Real> z(x, y);
                const std::complex<Real> calculated_i =
                    modifiedBesselFunction_i_exponentiallyWeighted(nu, z);
                const std::complex<Real> expected_i =
                    modifiedBesselFunction_i(nu, z) * exp(-z);
                const std::complex<Real> calculated_k =
                    modifiedBesselFunction_k_exponentiallyWeighted(nu, z);
                const std::complex<Real> expected_k =
                    M_PI_2 * (modifiedBesselFunction_i(-nu, z) * exp(-z) -
                              modifiedBesselFunction_i(nu, z) * exp(-z)) /
                    std::sin(M_PI * nu);
                const Real tol_i = 1e3 * QL_EPSILON*std::abs(calculated_i);
                const Real tol_k = 1e3 * QL_EPSILON*std::abs(calculated_k);
                if (std::abs(calculated_i - expected_i) > tol_i) {
                    BOOST_ERROR("failed to verify exponentially weighted"
                                << "modified Bessel function of first kind"
                                << "\n order      : " << nu
                                << "\n argument   : " << z <<
                                "\n calculated: "
                                << calculated_i << "\n expected   : " << expected_i);
                }
                if (std::abs(calculated_k - expected_k) > tol_k) {
                    BOOST_ERROR("failed to verify exponentially weighted"
                                << "modified Bessel function of second kind"
                                << "\n order      : " << nu
                                << "\n argument   : " << z <<
                                "\n calculated: "
                                << calculated_k << "\n expected   : " << expected_k);
                }
                y += 0.5;
            }
            x += 0.5;
        }
        nu += 0.5;
    }
}

test_suite* FunctionsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Factorial tests");
    suite->add(QUANTLIB_TEST_CASE(&FunctionsTest::testFactorial));
    suite->add(QUANTLIB_TEST_CASE(&FunctionsTest::testGammaFunction));
    suite->add(QUANTLIB_TEST_CASE(&FunctionsTest::testGammaValues));
    suite->add(QUANTLIB_TEST_CASE(
                        &FunctionsTest::testModifiedBesselFunctions));
    suite->add(QUANTLIB_TEST_CASE(
                        &FunctionsTest::testWeightedModifiedBesselFunctions));
    return suite;
}
]]></document_content>
  </document>
  <document index="120">
    <source>functions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_functions_hpp
#define quantlib_test_functions_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class FunctionsTest {
  public:
    static void testFactorial();
    static void testGammaFunction();
    static void testGammaValues();
    static void testModifiedBesselFunctions();
    static void testWeightedModifiedBesselFunctions();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="121">
    <source>garch.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "garch.hpp"
#include "utilities.hpp"
#include <ql/models/volatility/garch.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/math/randomnumbers/inversecumulativerng.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;

namespace garch_test {

    class DummyOptimizationMethod : public OptimizationMethod {
      public:
        EndCriteria::Type minimize(Problem& P, const EndCriteria& endCriteria) override {
            P.setFunctionValue(P.value(P.currentValue()));
            return EndCriteria::None;
        }
    };

    struct Results {
        Real alpha;
        Real beta;
        Real omega;
        Real logLikelihood;
    };

    typedef InverseCumulativeRng<MersenneTwisterUniformRng,
                                 InverseCumulativeNormal>
        GaussianGenerator;
}

#define CHECK(results, garch, member) \
    if (std::fabs(results.member - garch.member()) > 1.0e-6) { \
        BOOST_ERROR("Failed to reproduce expected " #member \
                    << "\n    calculated: " << garch.member() \
                    << "\n    expected:   " << results.member); \
    }

void GARCHTest::testCalibration() {

    BOOST_TEST_MESSAGE("Testing GARCH model calibration...");

    using namespace garch_test;

    Date start(7, July, 1962), d = start;
    TimeSeries<Volatility> ts;
    Garch11 garch(0.2, 0.3, 0.4);
    GaussianGenerator rng(MersenneTwisterUniformRng(48));

    Volatility r = 0.0, v = 0.0;
    for (std::size_t i = 0; i < 50000; ++i, d += 1) {
        v = garch.forecast(r, v);
        r = rng.next().value * std::sqrt(v);
        ts[d] = r;
    }

    // Default calibration; works fine in most cases
    Garch11 cgarch1(ts);

    Results calibrated = { 0.207592, 0.281979, 0.204647, -0.0217413 };

    CHECK(calibrated, cgarch1, alpha);
    CHECK(calibrated, cgarch1, beta);
    CHECK(calibrated, cgarch1, omega);
    CHECK(calibrated, cgarch1, logLikelihood);

    // Type 1 initial guess - no further optimization
    Garch11 cgarch2(ts, Garch11::MomentMatchingGuess);
    DummyOptimizationMethod m;
    cgarch2.calibrate(ts, m, EndCriteria (3, 2, 0.0, 0.0, 0.0));
    Results expected1 = { 0.265749, 0.156956, 0.230964, -0.0227179 };

    CHECK(expected1, cgarch2, alpha);
    CHECK(expected1, cgarch2, beta);
    CHECK(expected1, cgarch2, omega);
    CHECK(expected1, cgarch2, logLikelihood);

    // Optimization from this initial guess
    cgarch2.calibrate(ts);

    CHECK(calibrated, cgarch2, alpha);
    CHECK(calibrated, cgarch2, beta);
    CHECK(calibrated, cgarch2, omega);
    CHECK(calibrated, cgarch2, logLikelihood);

    // Type 2 initial guess - no further optimization
    Garch11 cgarch3(ts, Garch11::GammaGuess);
    cgarch3.calibrate(ts, m, EndCriteria (3, 2, 0.0, 0.0, 0.0));
    Results expected2 = { 0.269896, 0.211373, 0.207534, -0.022798 };

    CHECK(expected2, cgarch3, alpha);
    CHECK(expected2, cgarch3, beta);
    CHECK(expected2, cgarch3, omega);
    CHECK(expected2, cgarch3, logLikelihood);

    // Optimization from this initial guess
    cgarch3.calibrate(ts);

    CHECK(calibrated, cgarch3, alpha);
    CHECK(calibrated, cgarch3, beta);
    CHECK(calibrated, cgarch3, omega);
    CHECK(calibrated, cgarch3, logLikelihood);

    // Double optimization using type 1 and 2 initial guesses
    Garch11 cgarch4(ts,  Garch11::DoubleOptimization);
    cgarch4.calibrate(ts);

    CHECK(calibrated, cgarch4, alpha);
    CHECK(calibrated, cgarch4, beta);
    CHECK(calibrated, cgarch4, omega);
    CHECK(calibrated, cgarch4, logLikelihood);

    // Alternative, gradient based optimization - usually gives worse
    // results than simplex
    LevenbergMarquardt lm;
    cgarch4.calibrate(ts, lm, EndCriteria (100000, 500, 1e-8, 1e-8, 1e-8));
    Results expected3 = { 0.265196, 0.277364, 0.678812, -0.216313 };

    CHECK(expected3, cgarch4, alpha);
    CHECK(expected3, cgarch4, beta);
    CHECK(expected3, cgarch4, omega);
    CHECK(expected3, cgarch4, logLikelihood);
}

namespace garch_test {

    static Real expected_calc[] = {
        0.452769, 0.513323, 0.530141, 0.5350841, 0.536558,
        0.536999, 0.537132, 0.537171, 0.537183, 0.537187
    };

    void check_ts(const std::pair<Date, Volatility> &x) {
        if (x.first.serialNumber() < 22835 || x.first.serialNumber() > 22844) {
            BOOST_ERROR("Failed to reproduce calculated GARCH time: "
                        << "\n    calculated: " << x.first.serialNumber()
                        << "\n    expected:   [22835, 22844]");
        }
        Real error =
            std::fabs(x.second - expected_calc[x.first.serialNumber()-22835]);
        if (error > 1.0e-6) {
            BOOST_ERROR("Failed to reproduce calculated GARCH value at "
                        << x.first.serialNumber() << ": "
                        << "\n    calculated: " << x.second
                        << "\n    expected:   "
                        << expected_calc[x.first.serialNumber()-22835]);
        }
    }

}

void GARCHTest::testCalculation() {
    BOOST_TEST_MESSAGE("Testing GARCH model calculation...");

    using namespace garch_test;

    Date d(7, July, 1962);
    TimeSeries<Volatility> ts;
    Garch11 garch(0.2, 0.3, 0.4);

    Volatility r = 0.1;
    for (std::size_t i = 0; i < 10; ++i, d += 1) {
        ts[d] = r;
    }

    TimeSeries<Volatility> tsout = garch.calculate(ts);
    std::for_each(tsout.cbegin(), tsout.cend(), check_ts);
}

test_suite* GARCHTest::suite() {
    auto* suite = BOOST_TEST_SUITE("GARCH model tests");
    suite->add(QUANTLIB_TEST_CASE(&GARCHTest::testCalibration));
    suite->add(QUANTLIB_TEST_CASE(&GARCHTest::testCalculation));
    return suite;
}
]]></document_content>
  </document>
  <document index="122">
    <source>garch.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_garch_hpp
#define quantlib_test_garch_hpp

#include <boost/test/unit_test.hpp>

class GARCHTest {
  public:
    static void testCalibration();
    static void testCalculation();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="123">
    <source>gaussianquadratures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "gaussianquadratures.hpp"
#include "utilities.hpp"

#include <ql/types.hpp>
#include <ql/math/matrix.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/integrals/momentbasedgaussianpolynomial.hpp>
#include <ql/math/integrals/gausslaguerrecosinepolynomial.hpp>
#include <ql/experimental/math/gaussiannoncentralchisquaredpolynomial.hpp>

#include <boost/math/distributions/non_central_chi_squared.hpp>

#ifndef TEST_BOOST_MULTIPRECISION_GAUSSIAN_QUADRATURE
//#define TEST_BOOST_MULTIPRECISION_GAUSSIAN_QUADRATURE
#endif

#ifdef TEST_BOOST_MULTIPRECISION_GAUSSIAN_QUADRATURE
    #if BOOST_VERSION < 105300
        #error This boost version is too old to support boost multi precision
    #endif

    #include <boost/multiprecision/cpp_dec_float.hpp>
#endif

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace gaussian_quadratures_test {

    template <class T>
    void testSingle(const T& I, const std::string& tag,
                    const boost::function<Real(Real)>& f, Real expected) {
        Real calculated = I(f);
        if (std::fabs(calculated-expected) > 1.0e-4) {
            BOOST_ERROR("integrating" << tag << "\n"
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << expected);
        }
    }

    // test functions

    Real inv_exp(Real x) {
        return std::exp(-x);
    }

    Real x_inv_exp(Real x) {
        return x*std::exp(-x);
    }

    Real x_normaldistribution(Real x) {
        return x*NormalDistribution()(x);
    }

    Real x_x_normaldistribution(Real x) {
        return x*x*NormalDistribution()(x);
    }

    Real inv_cosh(Real x) {
        return 1/std::cosh(x);
    }

    Real x_inv_cosh(Real x) {
        return x/std::cosh(x);
    }

    Real x_x_nonCentralChiSquared(Real x) {
        return x * x * boost::math::pdf(
            boost::math::non_central_chi_squared_distribution<Real>(4.0,1.0),x);
    }

    Real x_sin_exp_nonCentralChiSquared(Real x) {
        return x * std::sin(0.1*x) * std::exp(0.3*x) * boost::math::pdf(
            boost::math::non_central_chi_squared_distribution<Real>(1.0,1.0),x);
    }

    template <class T>
    void testSingleJacobi(const T& I) {
        testSingle(I, "f(x) = 1",
                   constant<Real,Real>(1.0), 2.0);
        testSingle(I, "f(x) = x",
                   identity<Real>(),         0.0);
        testSingle(I, "f(x) = x^2",
                   square<Real>(),           2/3.);
        testSingle(I, "f(x) = sin(x)",
                   static_cast<Real(*)(Real)>(std::sin), 0.0);
        testSingle(I, "f(x) = cos(x)",
                   static_cast<Real(*)(Real)>(std::cos),
                   std::sin(1.0)-std::sin(-1.0));
        testSingle(I, "f(x) = Gaussian(x)",
                   NormalDistribution(),
                   CumulativeNormalDistribution()(1.0)
                   -CumulativeNormalDistribution()(-1.0));
    }

    template <class T>
    void testSingleLaguerre(const T& I) {
        testSingle(I, "f(x) = exp(-x)",
                   inv_exp, 1.0);
        testSingle(I, "f(x) = x*exp(-x)",
                   x_inv_exp, 1.0);
        testSingle(I, "f(x) = Gaussian(x)",
                   NormalDistribution(), 0.5);
    }

    void testSingleTabulated(const boost::function<Real(Real)>& f,
                             const std::string& tag,
                             Real expected, Real tolerance) {
        const Size order[] = { 6, 7, 12, 20 };
        TabulatedGaussLegendre quad;
        for (unsigned long i : order) {
            quad.order(i);
            Real realised = quad(f);
            if (std::fabs(realised-expected) > tolerance) {
                BOOST_ERROR(" integrating " << tag << "\n"
                                            << "    order " << i << "\n"
                                            << "    realised: " << realised << "\n"
                                            << "    expected: " << expected);
            }
        }
    }

}


void GaussianQuadraturesTest::testJacobi() {
    BOOST_TEST_MESSAGE("Testing Gauss-Jacobi integration...");

    using namespace gaussian_quadratures_test;

    testSingleJacobi(GaussLegendreIntegration(16));
    testSingleJacobi(GaussChebyshevIntegration(130));
    testSingleJacobi(GaussChebyshev2ndIntegration(130));
    testSingleJacobi(GaussGegenbauerIntegration(50,0.55));
}

void GaussianQuadraturesTest::testLaguerre() {
     BOOST_TEST_MESSAGE("Testing Gauss-Laguerre integration...");

     using namespace gaussian_quadratures_test;

     testSingleLaguerre(GaussLaguerreIntegration(16));
     testSingleLaguerre(GaussLaguerreIntegration(150,0.01));

     testSingle(GaussLaguerreIntegration(16, 1.0), "f(x) = x*exp(-x)",
                x_inv_exp, 1.0);
     testSingle(GaussLaguerreIntegration(32, 0.9), "f(x) = x*exp(-x)",
                x_inv_exp, 1.0);
}

void GaussianQuadraturesTest::testHermite() {
     BOOST_TEST_MESSAGE("Testing Gauss-Hermite integration...");

     using namespace gaussian_quadratures_test;

     testSingle(GaussHermiteIntegration(16), "f(x) = Gaussian(x)",
                NormalDistribution(), 1.0);
     testSingle(GaussHermiteIntegration(16,0.5), "f(x) = x*Gaussian(x)",
                x_normaldistribution, 0.0);
     testSingle(GaussHermiteIntegration(64,0.9), "f(x) = x*x*Gaussian(x)",
                x_x_normaldistribution, 1.0);
}

void GaussianQuadraturesTest::testHyperbolic() {
     BOOST_TEST_MESSAGE("Testing Gauss hyperbolic integration...");

     using namespace gaussian_quadratures_test;

     testSingle(GaussHyperbolicIntegration(16), "f(x) = 1/cosh(x)",
                inv_cosh, M_PI);
     testSingle(GaussHyperbolicIntegration(16), "f(x) = x/cosh(x)",
                x_inv_cosh, 0.0);
}

void GaussianQuadraturesTest::testTabulated() {
     BOOST_TEST_MESSAGE("Testing tabulated Gauss-Laguerre integration...");

     using namespace gaussian_quadratures_test;

     testSingleTabulated(constant<Real,Real>(1.0), "f(x) = 1",
                         2.0,       1.0e-13);
     testSingleTabulated(identity<Real>(), "f(x) = x",
                         0.0,       1.0e-13);
     testSingleTabulated(square<Real>(), "f(x) = x^2",
                         (2.0/3.0), 1.0e-13);
     testSingleTabulated(cube<Real>(), "f(x) = x^3",
                         0.0,       1.0e-13);
     testSingleTabulated(fourth_power<Real>(), "f(x) = x^4",
                         (2.0/5.0), 1.0e-13);
}

void GaussianQuadraturesTest::testNonCentralChiSquared() {
     BOOST_TEST_MESSAGE(
         "Testing Gauss non-central chi-squared integration...");

     using namespace gaussian_quadratures_test;

     testSingle(
        GaussianQuadrature(2, GaussNonCentralChiSquaredPolynomial(4.0, 1.0)),
        "f(x) = x^2 * nonCentralChiSquared(4, 1)(x)",
        x_x_nonCentralChiSquared, 37.0);

     testSingle(
        GaussianQuadrature(14, GaussNonCentralChiSquaredPolynomial(1.0, 1.0)),
        "f(x) = x * sin(0.1*x)*exp(0.3*x)*nonCentralChiSquared(1, 1)(x)",
        x_sin_exp_nonCentralChiSquared, 17.408092);
}


void GaussianQuadraturesTest::testNonCentralChiSquaredSumOfNodes() {
     BOOST_TEST_MESSAGE(
         "Testing Gauss non-central chi-squared sum of nodes...");

     using namespace gaussian_quadratures_test;

     // Walter Gautschi, How and How not to check Gaussian Quadrature Formulae
     // https://www.cs.purdue.edu/homes/wxg/selected_works/section_08/084.pdf

     // Expected results have been calculated with a multi precision library
     // following the description of test #4 in the paper above.
     // Using QuantLib's own determinant function will not work here
     // as it supports only double precision.

     const Real expected[] = {
         47.53491786730293,
         70.6103295419633383,
         98.0593406849441607,
         129.853401537905341,
         165.96963582663912,
         206.389183233992043
     };

     const Real nu=4.0;
     const Real lambda=1.0;
     const GaussNonCentralChiSquaredPolynomial orthPoly(nu, lambda);

     const Real tol = 1e-5;

	 for (Size n = 4; n < 10; ++n) {
		 const Array x = GaussianQuadrature(n, orthPoly).x();
         const Real calculated = std::accumulate(x.begin(), x.end(), 0.0);


         if (std::fabs(calculated - expected[n-4]) > tol) {
             BOOST_ERROR("failed to reproduce rule of sum"
                         << "\n    calculated: " << calculated
                         << "\n    expected:   " << expected[n-4]
                         << "\n    diff    :   " << calculated - expected[n-4]);
         }
     }
}

namespace gaussian_quadratures_test {
    template <class mp_float>
    class MomentBasedGaussLaguerrePolynomial
            : public MomentBasedGaussianPolynomial<mp_float> {
      public:
        mp_float moment(Size i) const override {
            if (i == 0)
                return mp_float(1.0);
            else
                return mp_float(i)*moment(i-1);
        }

        Real w(Real x) const override { return std::exp(-x); }
    };
}

void GaussianQuadraturesTest::testMomentBasedGaussianPolynomial() {
     BOOST_TEST_MESSAGE("Testing moment-based Gaussian polynomials...");

     using namespace gaussian_quadratures_test;

     GaussLaguerrePolynomial g;

     std::vector<ext::shared_ptr<GaussianOrthogonalPolynomial> > ml;
     ml.push_back(
         ext::make_shared<MomentBasedGaussLaguerrePolynomial<Real> >());

#ifdef TEST_BOOST_MULTIPRECISION_GAUSSIAN_QUADRATURE
     ml.push_back(
         ext::make_shared<MomentBasedGaussLaguerrePolynomial<
             boost::multiprecision::number<
                 boost::multiprecision::cpp_dec_float<20> > > >());
#endif

     const Real tol = 1e-12;
     for (auto& k : ml) {

         for (Size i=0; i < 10; ++i) {
             const Real diffAlpha = std::fabs(k->alpha(i) - g.alpha(i));
             const Real diffBeta = std::fabs(k->beta(i) - g.beta(i));

             if (diffAlpha > tol) {
                 BOOST_ERROR("failed to reproduce alpha for Laguerre quadrature"
                             << "\n    calculated: " << k->alpha(i) << "\n    expected  : "
                             << g.alpha(i) << "\n    diff      : " << diffAlpha);
             }
             if (i > 0 && diffBeta > tol) {
                 BOOST_ERROR("failed to reproduce beta for Laguerre quadrature"
                             << "\n    calculated: " << k->beta(i) << "\n    expected  : "
                             << g.beta(i) << "\n    diff      : " << diffBeta);
             }
         }
     }
}

void GaussianQuadraturesTest::testGaussLaguerreCosinePolynomial() {
    BOOST_TEST_MESSAGE("Testing Gauss-Laguerre-Cosine quadrature...");

    using namespace gaussian_quadratures_test;

    const GaussianQuadrature quadCosine(
            16, GaussLaguerreCosinePolynomial<Real>(0.2));

    testSingle(quadCosine, "f(x) = exp(-x)",
               inv_exp, 1.0);
    testSingle(quadCosine, "f(x) = x*exp(-x)",
               x_inv_exp, 1.0);

    const GaussianQuadrature quadSine(
            16, GaussLaguerreSinePolynomial<Real>(0.2));

    testSingle(quadSine, "f(x) = exp(-x)",
               inv_exp, 1.0);
    testSingle(quadSine, "f(x) = x*exp(-x)",
               x_inv_exp, 1.0);
}

test_suite* GaussianQuadraturesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Gaussian quadratures tests");
    suite->add(QUANTLIB_TEST_CASE(&GaussianQuadraturesTest::testJacobi));
    suite->add(QUANTLIB_TEST_CASE(&GaussianQuadraturesTest::testLaguerre));
    suite->add(QUANTLIB_TEST_CASE(&GaussianQuadraturesTest::testHermite));
    suite->add(QUANTLIB_TEST_CASE(&GaussianQuadraturesTest::testHyperbolic));
    suite->add(QUANTLIB_TEST_CASE(&GaussianQuadraturesTest::testTabulated));
    suite->add(QUANTLIB_TEST_CASE(
        &GaussianQuadraturesTest::testMomentBasedGaussianPolynomial));
    suite->add(QUANTLIB_TEST_CASE(
        &GaussianQuadraturesTest::testGaussLaguerreCosinePolynomial));

    return suite;
}

test_suite* GaussianQuadraturesTest::experimental() {
    auto* suite = BOOST_TEST_SUITE("Gaussian quadratures experimental tests");

    suite->add(QUANTLIB_TEST_CASE(
        &GaussianQuadraturesTest::testNonCentralChiSquared));
    suite->add(QUANTLIB_TEST_CASE(
        &GaussianQuadraturesTest::testNonCentralChiSquaredSumOfNodes));

    return suite;
}
]]></document_content>
  </document>
  <document index="124">
    <source>gaussianquadratures.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_gaussian_quadratures_hpp
#define quantlib_test_gaussian_quadratures_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class GaussianQuadraturesTest {
  public:
    static void testJacobi();
    static void testLaguerre();
    static void testHermite();
    static void testHyperbolic();
    static void testTabulated();
    static void testNonCentralChiSquared();
    static void testNonCentralChiSquaredSumOfNodes();
    static void testMomentBasedGaussianPolynomial();
    static void testGaussLaguerreCosinePolynomial();

    static boost::unit_test_framework::test_suite* suite();
    static boost::unit_test_framework::test_suite* experimental();
};


#endif
]]></document_content>
  </document>
  <document index="125">
    <source>gjrgarchmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "gjrgarchmodel.hpp"
#include "utilities.hpp"
#include <ql/processes/gjrgarchprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/models/equity/gjrgarchmodel.hpp>
#include <ql/models/equity/hestonmodelhelper.hpp>
#include <ql/pricingengines/vanilla/analyticgjrgarchengine.hpp>
#include <ql/pricingengines/vanilla/mceuropeangjrgarchengine.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/time/period.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void GJRGARCHModelTest::testEngines() {
    BOOST_TEST_MESSAGE(
       "Testing Monte Carlo GJR-GARCH engine against "
       "analytic GJR-GARCH engine...");

    DayCounter dayCounter = ActualActual(ActualActual::ISDA);

    const Date today = Date::todaysDate();
    Handle<YieldTermStructure> riskFreeTS(flatRate(today, 0.05, dayCounter));
    Handle<YieldTermStructure> dividendTS(flatRate(today, 0.0, dayCounter));

    const Real s0 = 50.0;
    const Real omega = 2.0e-6;
    const Real alpha = 0.024;
    const Real beta = 0.93;
    const Real gamma = 0.059;
    const Real daysPerYear = 365.0; // number of trading days per year
    const Size maturity[] = {90, 180};
    const Real strike[] = {35,40,45,50,55,60};
    const Real Lambda[] = {0.0,0.1,0.2};
    Real analytic[3][2][6]; // correct values of analytic approximation
    analytic[0][0][0] = 15.4315;
    analytic[0][0][1] = 10.5552;
    analytic[0][0][2] = 5.9625;
    analytic[0][0][3] = 2.3282;
    analytic[0][0][4] = 0.5408;
    analytic[0][0][5] = 0.0835;
    analytic[0][1][0] = 15.8969;
    analytic[0][1][1] = 11.2173;
    analytic[0][1][2] = 6.9112;
    analytic[0][1][3] = 3.4788;
    analytic[0][1][4] = 1.3769;
    analytic[0][1][5] = 0.4357;
    analytic[1][0][0] = 15.4556;
    analytic[1][0][1] = 10.6929;
    analytic[1][0][2] = 6.2381;
    analytic[1][0][3] = 2.6831;
    analytic[1][0][4] = 0.7822;
    analytic[1][0][5] = 0.1738;
    analytic[1][1][0] = 16.0587;
    analytic[1][1][1] = 11.5338;
    analytic[1][1][2] = 7.3170;
    analytic[1][1][3] = 3.9074;
    analytic[1][1][4] = 1.7279;
    analytic[1][1][5] = 0.6568;
    analytic[2][0][0] = 15.8000;
    analytic[2][0][1] = 11.2734;
    analytic[2][0][2] = 7.0376;
    analytic[2][0][3] = 3.6767;
    analytic[2][0][4] = 1.5871;
    analytic[2][0][5] = 0.5934;
    analytic[2][1][0] = 16.9286;
    analytic[2][1][1] = 12.3170;
    analytic[2][1][2] = 8.0405;
    analytic[2][1][3] = 4.6348;
    analytic[2][1][4] = 2.3429;
    analytic[2][1][5] = 1.0590;
    Real mcValues[3][2][6]; // correct values of Monte Carlo
    mcValues[0][0][0] = 15.4332;
    mcValues[0][0][1] = 10.5453;
    mcValues[0][0][2] = 5.9351;
    mcValues[0][0][3] = 2.3521;
    mcValues[0][0][4] = 0.5597;
    mcValues[0][0][5] = 0.0776;
    mcValues[0][1][0] = 15.8910;
    mcValues[0][1][1] = 11.1772;
    mcValues[0][1][2] = 6.8827;
    mcValues[0][1][3] = 3.5096;
    mcValues[0][1][4] = 1.4196;
    mcValues[0][1][5] = 0.4502;
    mcValues[1][0][0] = 15.4580;
    mcValues[1][0][1] = 10.6433;
    mcValues[1][0][2] = 6.2019;
    mcValues[1][0][3] = 2.7513;
    mcValues[1][0][4] = 0.8374;
    mcValues[1][0][5] = 0.1706;
    mcValues[1][1][0] = 15.9884;
    mcValues[1][1][1] = 11.4139;
    mcValues[1][1][2] = 7.3103;
    mcValues[1][1][3] = 4.0497;
    mcValues[1][1][4] = 1.8862;
    mcValues[1][1][5] = 0.7322;
    mcValues[2][0][0] = 15.6619;
    mcValues[2][0][1] = 11.1263;
    mcValues[2][0][2] = 7.0968;
    mcValues[2][0][3] = 3.9152;
    mcValues[2][0][4] = 1.8133;
    mcValues[2][0][5] = 0.7010;
    mcValues[2][1][0] = 16.5195;
    mcValues[2][1][1] = 12.3181;
    mcValues[2][1][2] = 8.6085;
    mcValues[2][1][3] = 5.5700;
    mcValues[2][1][4] = 3.3103;
    mcValues[2][1][5] = 1.8053;

    for (Size k = 0; k < 3; ++k) {
        Real lambda = Lambda[k];
        Real m1 = beta+(alpha+gamma*CumulativeNormalDistribution()(lambda))
            *(1.0+lambda*lambda)+gamma*lambda*std::exp(-lambda*lambda/2.0)
            /std::sqrt(2.0*M_PI);
        Real v0 = omega/(1.0-m1);
        Handle<Quote> q(ext::shared_ptr<Quote>(new SimpleQuote(s0)));
        ext::shared_ptr<GJRGARCHProcess> process(new GJRGARCHProcess(
            riskFreeTS, dividendTS, q, v0, omega, alpha, beta, gamma, lambda, daysPerYear));
        ext::shared_ptr<PricingEngine> engine1 =
            MakeMCEuropeanGJRGARCHEngine<PseudoRandom>(process)
            .withStepsPerYear(20)
            .withAbsoluteTolerance(0.02)
            .withSeed(1234);

        ext::shared_ptr<PricingEngine> engine2(
            new AnalyticGJRGARCHEngine(ext::make_shared<GJRGARCHModel>(
                                               process)));
        for (Size i = 0; i < 2; ++i) {
            for (Size j = 0; j < 6; ++j) {
                Real x = strike[j];

                ext::shared_ptr<StrikedTypePayoff> payoff(
                                     new PlainVanillaPayoff(Option::Call, x));
                Date exDate = today + maturity[i];
                ext::shared_ptr<Exercise> exercise(
                                                new EuropeanExercise(exDate));

                VanillaOption option(payoff, exercise);

                option.setPricingEngine(engine1);
                Real calculated = option.NPV();

                option.setPricingEngine(engine2);
                Real expected = option.NPV();
                Real tolerance = 7.5e-2;

                if (std::fabs(expected - analytic[k][i][j]) > 2.0*tolerance) {
                    BOOST_ERROR("failed to match results from engines"
                                << "\n    correct value:    "
                                << analytic[k][i][j]
                                << "\n    Analytic Approx.: "
                                << expected
                                << " +/- " << tolerance);
                }
                if (std::fabs(calculated-mcValues[k][i][j]) > 2.0*tolerance) {
                    BOOST_ERROR("failed to match results from engines"
                                << "\n    correct value:    "
                                << mcValues[k][i][j]
                                << "\n    Monte Carlo: " << calculated
                                << " +/- " << tolerance);
                }
            }
        }
    }
}


void GJRGARCHModelTest::testDAXCalibration() {
    /* this example is taken from A. Sepp
       Pricing European-Style Options under Jump Diffusion Processes
       with Stochstic Volatility: Applications of Fourier Transform
       http://math.ut.ee/~spartak/papers/stochjumpvols.pdf
    */

    BOOST_TEST_MESSAGE(
         "Testing GJR-GARCH model calibration using DAX volatility data...");

    SavedSettings backup;

    Date settlementDate(5, July, 2002);
    Settings::instance().evaluationDate() = settlementDate;

    DayCounter dayCounter = Actual365Fixed();
    Calendar calendar = TARGET();

    Integer t[] = { 13, 41, 75, 165, 256, 345, 524, 703 };
    Rate r[] = { 0.0357,0.0349,0.0341,0.0355,0.0359,0.0368,0.0386,0.0401 };

    std::vector<Date> dates;
    std::vector<Rate> rates;
    dates.push_back(settlementDate);
    rates.push_back(0.0357);
    Size i;
    for (i = 0; i < 8; ++i) {
        dates.push_back(settlementDate + t[i]);
        rates.push_back(r[i]);
    }
    Handle<YieldTermStructure> riskFreeTS(
                       ext::shared_ptr<YieldTermStructure>(
                                    new ZeroCurve(dates, rates, dayCounter)));

    Handle<YieldTermStructure> dividendTS(
                                   flatRate(settlementDate, 0.0, dayCounter));

    Volatility v[] =
      { 0.6625,0.4875,0.4204,0.3667,0.3431,0.3267,0.3121,0.3121,
        0.6007,0.4543,0.3967,0.3511,0.3279,0.3154,0.2984,0.2921,
        0.5084,0.4221,0.3718,0.3327,0.3155,0.3027,0.2919,0.2889,
        0.4541,0.3869,0.3492,0.3149,0.2963,0.2926,0.2819,0.2800,
        0.4060,0.3607,0.3330,0.2999,0.2887,0.2811,0.2751,0.2775,
        0.3726,0.3396,0.3108,0.2781,0.2788,0.2722,0.2661,0.2686,
        0.3550,0.3277,0.3012,0.2781,0.2781,0.2661,0.2661,0.2681,
        0.3428,0.3209,0.2958,0.2740,0.2688,0.2627,0.2580,0.2620,
        0.3302,0.3062,0.2799,0.2631,0.2573,0.2533,0.2504,0.2544,
        0.3343,0.2959,0.2705,0.2540,0.2504,0.2464,0.2448,0.2462,
        0.3460,0.2845,0.2624,0.2463,0.2425,0.2385,0.2373,0.2422,
        0.3857,0.2860,0.2578,0.2399,0.2357,0.2327,0.2312,0.2351,
        0.3976,0.2860,0.2607,0.2356,0.2297,0.2268,0.2241,0.2320 };

    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(4468.17)));
    Real strike[] = { 3400,3600,3800,4000,4200,4400,
                      4500,4600,4800,5000,5200,5400,5600 };

    std::vector<ext::shared_ptr<CalibrationHelper> > options;

    const Real omega = 2.0e-6;
    const Real alpha = 0.024;
    const Real beta = 0.93;
    const Real gamma = 0.059;
    const Real lambda = 0.1;
    const Real daysPerYear = 365.0; // number of trading days per year
    const Real m1 = beta+(alpha+gamma*CumulativeNormalDistribution()(lambda))
            *(1.0+lambda*lambda)+gamma*lambda*std::exp(-lambda*lambda/2.0)
            /std::sqrt(2.0*M_PI);
    const Real v0 = omega/(1.0-m1);

    ext::shared_ptr<GJRGARCHProcess> process(new GJRGARCHProcess(
                             riskFreeTS, dividendTS, s0, v0,
                             omega, alpha, beta, gamma, lambda, daysPerYear));
    ext::shared_ptr<GJRGARCHModel> model(new GJRGARCHModel(process));

    ext::shared_ptr<PricingEngine> engine(
        new AnalyticGJRGARCHEngine(ext::shared_ptr<GJRGARCHModel>(model)));

    for (Size s = 3; s < 10; ++s) {
        for (Size m = 0; m < 3; ++m) {
            Handle<Quote> vol(ext::shared_ptr<Quote>(
                                                  new SimpleQuote(v[s*8+m])));

            Period maturity((int)((t[m]+3)/7.), Weeks); // round to weeks
            ext::shared_ptr<BlackCalibrationHelper> option(
                    new HestonModelHelper(maturity, calendar,
                                          s0->value(), strike[s], vol,
                                          riskFreeTS, dividendTS,
                                          BlackCalibrationHelper::ImpliedVolError));
            option->setPricingEngine(engine);
            options.push_back(option);
        }
    }

    Simplex om(0.05);
    model->calibrate(options, om,
                     EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8));

    Real sse = 0;
    for (i = 0; i < options.size(); ++i) {
        const Real diff = options[i]->calibrationError()*100.0;
        sse += diff*diff;
    }
    Real maxExpected = 15;
    if (sse > maxExpected) {
        BOOST_FAIL("Failed to reproduce calibration error"
                   << "\n    calculated: " << sse
                   << "\n    expected: < " << maxExpected);
    }
}

test_suite* GJRGARCHModelTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("GJR-GARCH model tests");

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&GJRGARCHModelTest::testDAXCalibration));
    }

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&GJRGARCHModelTest::testEngines));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="126">
    <source>gjrgarchmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_gjrgarch_model_hpp
#define quantlib_test_gjrgarch_model_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class GJRGARCHModelTest {
  public:
    static void testEngines();
    static void testDAXCalibration();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="127">
    <source>gsr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "gsr.hpp"
#include "utilities.hpp"
#include <ql/processes/gsrprocess.hpp>
#include <ql/models/shortrate/onefactormodels/gsr.hpp>
#include <ql/instruments/nonstandardswap.hpp>
#include <ql/instruments/nonstandardswaption.hpp>
#include <ql/pricingengines/swaption/gaussian1dswaptionengine.hpp>
#include <ql/pricingengines/swaption/gaussian1djamshidianswaptionengine.hpp>
#include <ql/pricingengines/swaption/gaussian1dnonstandardswaptionengine.hpp>
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/models/shortrate/calibrationhelpers/swaptionhelper.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/pricingengines/swaption/jamshidianswaptionengine.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/termstructures/volatility/swaption/swaptionconstantvol.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;

using std::fabs;

void GsrTest::testGsrProcess() {

    BOOST_TEST_MESSAGE("Testing GSR process...");

    Date refDate = Settings::instance().evaluationDate();

    // constant reversion, constant volatility, test conditional expectation and
    // variance against
    // existing HullWhiteForwardProcess
    // technically we test two representations of the same constant reversion
    // and volatility structure,
    // namely with and without step dates

    Real tol = 1E-8;

    Real reversion = 0.01;
    Real modelvol = 0.01;

    Handle<YieldTermStructure> yts0(ext::shared_ptr<YieldTermStructure>(
        new FlatForward(0, TARGET(), 0.00, Actual365Fixed())));

    std::vector<Date> stepDates0;
    std::vector<Real> vols0(1, modelvol);
    std::vector<Real> reversions0(1, reversion);

    std::vector<Date> stepDates1;
    for (Size i = 1; i < 60; i++)
        stepDates1.push_back(refDate + (i * 6 * Months));
    std::vector<Real> vols1(stepDates1.size() + 1, modelvol);
    std::vector<Real> reversions1(stepDates1.size() + 1, reversion);

    Real T = 10.0;
    do {

        ext::shared_ptr<Gsr> model(
            new Gsr(yts0, stepDates0, vols0, reversions0, T));
        ext::shared_ptr<StochasticProcess1D> gsrProcess =
            model->stateProcess();
        ext::shared_ptr<Gsr> model2(
            new Gsr(yts0, stepDates1, vols1, reversions1, T));
        ext::shared_ptr<StochasticProcess1D> gsrProcess2 =
            model2->stateProcess();

        ext::shared_ptr<HullWhiteForwardProcess> hwProcess(
            new HullWhiteForwardProcess(yts0, reversion, modelvol));
        hwProcess->setForwardMeasureTime(T);

        Real w, t, xw, hwVal, gsrVal, gsr2Val;

        t = 0.5;
        do {
            w = 0.0;
            do {
                xw = -0.1;
                do {
                    hwVal = hwProcess->expectation(w, xw, t - w);
                    gsrVal = gsrProcess->expectation(w, xw, t - w);
                    gsr2Val = gsrProcess2->expectation(w, xw, t - w);
                    if (fabs(hwVal - gsrVal) > tol)
                        BOOST_ERROR(
                            "Expectation E^{T="
                            << T << "}(x(" << t << ") | x(" << w << ") = " << xw
                            << " is different in HullWhiteProcess(" << hwVal
                            << ") and GsrProcess (" << gsrVal << ")");
                    if (fabs(hwVal - gsr2Val) > tol)
                        BOOST_ERROR(
                            "Expectation E^{T="
                            << T << "}(x(" << t << ") | x(" << w << ") = " << xw
                            << " is different in HullWhiteProcess(" << hwVal
                            << ") and GsrProcess2 (" << gsr2Val << ")");

                    hwVal = hwProcess->variance(w, xw, t - w);
                    gsrVal = gsrProcess->variance(w, xw, t - w);
                    gsr2Val = gsrProcess2->variance(w, xw, t - w);
                    if (fabs(hwVal - gsrVal) > tol)
                        BOOST_ERROR("Variance V((x("
                                    << t << ") | x(" << w << ") = " << xw
                                    << " is different in HullWhiteProcess("
                                    << hwVal << ") and GsrProcess (" << gsrVal
                                    << ")");
                    if (fabs(hwVal - gsr2Val) > tol)
                        BOOST_ERROR("Variance V((x("
                                    << t << ") | x(" << w << ") = " << xw
                                    << " is different in HullWhiteProcess("
                                    << hwVal << ") and GsrProcess2 (" << gsr2Val
                                    << ")");
                    xw += 0.01;
                } while (xw <= 0.1);
                w += t / 5.0;
            } while (w <= t - 0.1);
            t += T / 20.0;
        } while (t <= T - 0.1);
        T += 10.0;
    } while (T <= 30.0);

    // time dependent reversion and volatility (test cases to be added)

    Array times(2);
    Array vols(3);
    Array reversions(3);

    times[0] = 1.0;
    times[1] = 2.0;
    vols[0] = 0.2;
    vols[1] = 0.3;
    vols[2] = 0.4;
    reversions[0] = 0.50;
    reversions[1] = 0.80;
    reversions[2] = 1.30;

    GsrProcess p(times, vols, reversions);
    p.setForwardMeasureTime(10.0);

    // add more test cases here ...
}

void GsrTest::testGsrModel() {

    BOOST_TEST_MESSAGE("Testing GSR model...");

    Date refDate = Settings::instance().evaluationDate();

    Real modelvol = 0.01;
    Real reversion = 0.01;

    std::vector<Date> stepDates; // no step dates
    std::vector<Real> vols(1, modelvol);
    std::vector<Real> reversions(1, reversion);

    std::vector<Date> stepDates1; // artificial step dates (should yield the
                                  // same result)
    for (Size i = 1; i < 60; i++)
        stepDates1.push_back(refDate + (i * 6 * Months));
    std::vector<Real> vols1(stepDates1.size() + 1, modelvol);
    std::vector<Real> reversions1(stepDates1.size() + 1, reversion);

    Handle<YieldTermStructure> yts(ext::shared_ptr<YieldTermStructure>(
        new FlatForward(0, TARGET(), 0.03, Actual365Fixed())));
    ext::shared_ptr<Gsr> model(
        new Gsr(yts, stepDates, vols, reversions, 50.0));
    ext::shared_ptr<Gsr> model2(
        new Gsr(yts, stepDates1, vols1, reversions1, 50.0));
    ext::shared_ptr<HullWhite> hw(new HullWhite(yts, reversion, modelvol));

    // test zerobond prices against existing HullWhite model
    // technically we test two representations of the same constant reversion
    // and volatility structure,
    // namely with and without step dates

    Real tol0 = 1E-8;

    Real w, t, xw;

    w = 0.1;
    do {
        t = w + 0.1;
        do {
            xw = -0.10;
            do {
                Real yw =
                    (xw - model->stateProcess()->expectation(0.0, 0.0, w)) /
                    model->stateProcess()->stdDeviation(0.0, 0.0, w);
                Real rw = xw + 0.03; // instantaneous forward is 0.03
                Real gsrVal = model->zerobond(t, w, yw);
                Real gsr2Val = model2->zerobond(t, w, yw);
                Real hwVal = hw->discountBond(w, t, rw);
                if (fabs(gsrVal - hwVal) > tol0)
                    BOOST_ERROR("Zerobond P("
                                << w << "," << t << " | x=" << xw << " / y="
                                << yw << ") is different in HullWhite ("
                                << hwVal << ") and Gsr (" << gsrVal << ")");
                if (fabs(gsr2Val - hwVal) > tol0)
                    BOOST_ERROR("Zerobond P("
                                << w << "," << t << " | x=" << xw << " / y="
                                << yw << ") is different in HullWhite ("
                                << hwVal << ") and Gsr2 (" << gsr2Val << ")");
                xw += 0.01;
            } while (xw <= 0.10);
            t += 2.5;
        } while (t <= 50.0);
        w += 5.0;
    } while (w <= 50.0);

    // test standard, nonstandard and jamshidian engine against existing Hull
    // White Jamshidian engine

    Date expiry = TARGET().advance(refDate, 5 * Years);
    Period tenor = 10 * Years;
    ext::shared_ptr<SwapIndex> swpIdx(new EuriborSwapIsdaFixA(tenor, yts));
    Real forward = swpIdx->fixing(expiry);

    ext::shared_ptr<VanillaSwap> underlying = swpIdx->underlyingSwap(expiry);
    ext::shared_ptr<VanillaSwap> underlyingFixed =
        MakeVanillaSwap(10 * Years, swpIdx->iborIndex(), forward)
            .withEffectiveDate(swpIdx->valueDate(expiry))
            .withFixedLegCalendar(swpIdx->fixingCalendar())
            .withFixedLegDayCount(swpIdx->dayCounter())
            .withFixedLegTenor(swpIdx->fixedLegTenor())
            .withFixedLegConvention(swpIdx->fixedLegConvention())
            .withFixedLegTerminationDateConvention(
                 swpIdx->fixedLegConvention());
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(expiry));
    ext::shared_ptr<Swaption> stdswaption(
        new Swaption(underlyingFixed, exercise));
    ext::shared_ptr<NonstandardSwaption> nonstdswaption(
        new NonstandardSwaption(*stdswaption));

    stdswaption->setPricingEngine(ext::shared_ptr<PricingEngine>(
        new JamshidianSwaptionEngine(hw, yts)));
    Real HwJamNpv = stdswaption->NPV();

    nonstdswaption->setPricingEngine(ext::shared_ptr<PricingEngine>(
        new Gaussian1dNonstandardSwaptionEngine(model, 64, 7.0, true, false)));
    stdswaption->setPricingEngine(ext::shared_ptr<PricingEngine>(
        new Gaussian1dSwaptionEngine(model, 64, 7.0, true, false)));
    Real GsrNonStdNpv = nonstdswaption->NPV();
    Real GsrStdNpv = stdswaption->NPV();
    stdswaption->setPricingEngine(ext::shared_ptr<PricingEngine>(
        new Gaussian1dJamshidianSwaptionEngine(model)));
    Real GsrJamNpv = stdswaption->NPV();

    if (fabs(HwJamNpv - GsrNonStdNpv) > 0.00005)
        BOOST_ERROR(
            "Jamshidian HW NPV ("
            << HwJamNpv
            << ") deviates from Gaussian1dNonstandardSwaptionEngine NPV ("
            << GsrNonStdNpv << ")");
    if (fabs(HwJamNpv - GsrStdNpv) > 0.00005)
        BOOST_ERROR("Jamshidian HW NPV ("
                    << HwJamNpv
                    << ") deviates from Gaussian1dSwaptionEngine NPV ("
                    << GsrStdNpv << ")");
    if (fabs(HwJamNpv - GsrJamNpv) > 0.00005)
        BOOST_ERROR("Jamshidian HW NPV ("
                    << HwJamNpv
                    << ") deviates from Gaussian1dJamshidianEngine NPV ("
                    << GsrJamNpv << ")");
}

test_suite *GsrTest::suite() {
    auto* suite = BOOST_TEST_SUITE("GSR model tests");
    suite->add(QUANTLIB_TEST_CASE(&GsrTest::testGsrProcess));
    suite->add(QUANTLIB_TEST_CASE(&GsrTest::testGsrModel));
    return suite;
}
]]></document_content>
  </document>
  <document index="128">
    <source>gsr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_gsr_hpp
#define quantlib_test_gsr_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class GsrTest {
  public:
    static void testGsrProcess();
    static void testGsrModel();
    static void testNonstandardSwaption();
    static void testDummy();
    static boost::unit_test_framework::test_suite *suite();
};

#endif
]]></document_content>
  </document>
  <document index="129">
    <source>hestonmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2007, 2010, 2012, 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_heston_model_hpp
#define quantlib_test_heston_model_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class HestonModelTest {
  public:
    static void testBlackCalibration();
    static void testDAXCalibration();
    static void testAnalyticVsBlack();
    static void testAnalyticVsCached();
    static void testKahlJaeckelCase();
    static void testMcVsCached();
    static void testFdBarrierVsCached();    
    static void testFdVanillaVsCached();    
    static void testDifferentIntegrals();
    static void testMultipleStrikesEngine();
    static void testAnalyticPiecewiseTimeDependent();
    static void testDAXCalibrationOfTimeDependentModel();
    static void testAlanLewisReferencePrices();
    static void testAnalyticPDFHestonEngine();
    static void testExpansionOnAlanLewisReference();
    static void testExpansionOnFordeReference();
    static void testAllIntegrationMethods();
    static void testCosHestonCumulants();
    static void testCosHestonEngine();
    static void testCharacteristicFct();
    static void testAndersenPiterbargPricing();
    static void testAndersenPiterbargControlVariateIntegrand();
    static void testAndersenPiterbargConvergence();
    static void testPiecewiseTimeDependentChFvsHestonChF();
    static void testPiecewiseTimeDependentComparison();
    static void testPiecewiseTimeDependentChFAsymtotic();
    static void testSmallSigmaExpansion();
    static void testSmallSigmaExpansion4ExpFitting();
    static void testExponentialFitting4StrikesAndMaturities();
    static void testHestonEngineIntegration();
    static void testOptimalControlVariateChoice();
    static void testAsymptoticControlVariate();
    static void testLocalVolFromHestonModel();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
    static boost::unit_test_framework::test_suite* experimental();
};


#endif
]]></document_content>
  </document>
  <document index="130">
    <source>hestonslvmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014, 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2014, 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_heston_slv_model_hpp
#define quantlib_test_heston_slv_model_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class HestonSLVModelTest {
public:
    static void testBlackScholesFokkerPlanckFwdEquation();
    static void testSquareRootZeroFlowBC();
    static void testTransformedZeroFlowBC();
    static void testSquareRootEvolveWithStationaryDensity();
    static void testSquareRootLogEvolveWithStationaryDensity();
    static void testSquareRootFokkerPlanckFwdEquation();
    static void testHestonFokkerPlanckFwdEquation();
    static void testHestonFokkerPlanckFwdEquationLogLVLeverage();
    static void testBlackScholesFokkerPlanckFwdEquationLocalVol();
    static void testFDMCalibration();
    static void testLocalVolsvSLVPropDensity();
    static void testBarrierPricingViaHestonLocalVol();
    static void testBarrierPricingMixedModels();
    static void testMonteCarloVsFdmPricing();
    static void testMonteCarloCalibration();
    static void testMoustacheGraph();
    static void testForwardSkewSLV();
    static void testDiffusionAndDriftSlvProcess();

    static boost::unit_test_framework::test_suite* experimental(SpeedLevel);

};

#endif
]]></document_content>
  </document>
  <document index="131">
    <source>himalayaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "himalayaoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/himalayaoption.hpp>
#include <ql/experimental/exoticoptions/mchimalayaengine.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void HimalayaOptionTest::testCached() {

    BOOST_TEST_MESSAGE("Testing Himalaya option against cached values...");

    Date today = Settings::instance().evaluationDate();

    DayCounter dc = Actual360();
    std::vector<Date> fixingDates;
    for (Size i=0; i<5; ++i)
        fixingDates.push_back(today+i*90);

    Real strike = 101.0;
    HimalayaOption option(fixingDates, strike);

    Handle<YieldTermStructure> riskFreeRate(flatRate(today, 0.05, dc));

    std::vector<ext::shared_ptr<StochasticProcess1D> > processes(4);
    processes[0] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(100.0))),
              Handle<YieldTermStructure>(flatRate(today, 0.01, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.30, dc))));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(110.0))),
              Handle<YieldTermStructure>(flatRate(today, 0.05, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.35, dc))));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(90.0))),
              Handle<YieldTermStructure>(flatRate(today, 0.04, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.25, dc))));
    processes[3] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(105.0))),
              Handle<YieldTermStructure>(flatRate(today, 0.03, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.20, dc))));

    Matrix correlation(4,4);
    correlation[0][0] = 1.00;
                    correlation[0][1] = 0.50;
                                    correlation[0][2] = 0.30;
                                                    correlation[0][3] = 0.10;
    correlation[1][0] = 0.50;
                    correlation[1][1] = 1.00;
                                    correlation[1][2] = 0.20;
                                                    correlation[1][3] = 0.40;
    correlation[2][0] = 0.30;
                    correlation[2][1] = 0.20;
                                    correlation[2][2] = 1.00;
                                                    correlation[2][3] = 0.60;
    correlation[3][0] = 0.10;
                    correlation[3][1] = 0.40;
                                    correlation[3][2] = 0.60;
                                                    correlation[3][3] = 1.00;



    BigNatural seed = 86421;
    Size fixedSamples = 1023;

    ext::shared_ptr<StochasticProcessArray> process(
                          new StochasticProcessArray(processes, correlation));

    option.setPricingEngine(MakeMCHimalayaEngine<PseudoRandom>(process)
                            .withSamples(fixedSamples)
                            .withSeed(seed));

    Real value = option.NPV();
    Real storedValue = 6.60370398;
    Real tolerance = 1.0e-8;

    if (std::fabs(value-storedValue) > tolerance)
        BOOST_FAIL(std::setprecision(10)
                   << "    calculated value: " << value << "\n"
                   << "    expected:         " << storedValue);

    Real minimumTol = 1.0e-2;
    tolerance = option.errorEstimate();
    tolerance = std::min<Real>(tolerance/2.0, minimumTol*value);

    option.setPricingEngine(MakeMCHimalayaEngine<PseudoRandom>(process)
                            .withAbsoluteTolerance(tolerance)
                            .withSeed(seed));

    option.NPV();
    Real accuracy = option.errorEstimate();
    if (accuracy > tolerance)
        BOOST_FAIL(std::setprecision(10)
                   << "    reached accuracy: " << accuracy << "\n"
                   << "    expected:         " << tolerance);
}


test_suite* HimalayaOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Himalaya-option tests");
    suite->add(QUANTLIB_TEST_CASE(&HimalayaOptionTest::testCached));
    return suite;
}

]]></document_content>
  </document>
  <document index="132">
    <source>himalayaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_himalaya_option_hpp
#define quantlib_test_himalaya_option_hpp

#include <boost/test/unit_test.hpp>

class HimalayaOptionTest {
  public:
    static void testCached();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="133">
    <source>hybridhestonhullwhiteprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008, 2009, 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_hybrid_heston_hull_white_process_hpp
#define quantlib_test_hybrid_heston_hull_white_process_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class HybridHestonHullWhiteProcessTest {
  public:
    static void testBsmHullWhiteEngine();
    static void testCompareBsmHWandHestonHW();
    static void testZeroBondPricing();
    static void testMcVanillaPricing();
    static void testMcPureHestonPricing();
    static void testAnalyticHestonHullWhitePricing();
    static void testCallableEquityPricing();
    static void testDiscretizationError();
    static void testFdmHestonHullWhiteEngine();
    static void testBsmHullWhitePricing();
    static void testSpatialDiscretizatinError();
    static void testHestonHullWhiteCalibration();
    static void testH1HWPricingEngine();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="134">
    <source>indexes.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "indexes.hpp"
#include "utilities.hpp"
#include <ql/indexes/bmaindex.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void IndexTest::testFixingObservability() {
    BOOST_TEST_MESSAGE("Testing observability of index fixings...");

    ext::shared_ptr<InterestRateIndex> i1 = ext::make_shared<Euribor6M>();
    ext::shared_ptr<InterestRateIndex> i2 = ext::make_shared<BMAIndex>();

    Flag f1;
    f1.registerWith(i1);
    f1.lower();

    Flag f2;
    f2.registerWith(i2);
    f2.lower();

    Date today = Date::todaysDate();

    ext::shared_ptr<Index> euribor = ext::make_shared<Euribor6M>();

    Date d1 = today;
    while (!euribor->isValidFixingDate(d1))
        d1++;

    euribor->addFixing(d1, -0.003);
    if (!f1.isUp())
        BOOST_FAIL("Observer was not notified of added Euribor fixing");

    ext::shared_ptr<Index> bma = ext::make_shared<BMAIndex>();

    Date d2 = today;
    while (!bma->isValidFixingDate(d2))
        d2++;

    bma->addFixing(d2, 0.01);
    if (!f2.isUp())
        BOOST_FAIL("Observer was not notified of added BMA fixing");
}

void IndexTest::testFixingHasHistoricalFixing() {
    BOOST_TEST_MESSAGE("Testing if index has historical fixings...");

    auto testCase = [](const std::string& indexName, const bool& expected, const bool& testResult) {
        if (expected != testResult) {
            BOOST_FAIL("Historical fixing " << (testResult ? "" : "not ") << "found for "
                                            << indexName << ".");
        }
    };

    std::string name;
    auto fixingFound = true;
    auto fixingNotFound = false;

    auto euribor3M = ext::make_shared<Euribor3M>();
    auto euribor6M = ext::make_shared<Euribor6M>();
    auto euribor6M_a = ext::make_shared<Euribor6M>();

    Date today = Settings::instance().evaluationDate();
    while (!euribor6M->isValidFixingDate(today))
        today--;

    IndexManager::instance().clearHistories();

    euribor6M->addFixing(today, 0.01);

    name = euribor3M->name();
    testCase(name, fixingNotFound, euribor3M->hasHistoricalFixing(today));
    testCase(name, fixingNotFound, IndexManager::instance().hasHistoricalFixing(name, today));

    name = euribor6M->name();
    testCase(name, fixingFound, euribor6M->hasHistoricalFixing(today));
    testCase(name, fixingFound, euribor6M_a->hasHistoricalFixing(today));
    testCase(name, fixingFound, IndexManager::instance().hasHistoricalFixing(name, today));

    IndexManager::instance().clearHistories();

    name = euribor3M->name();
    testCase(name, fixingNotFound, euribor3M->hasHistoricalFixing(today));
    testCase(name, fixingNotFound, IndexManager::instance().hasHistoricalFixing(name, today));

    name = euribor6M->name();
    testCase(name, fixingNotFound, euribor6M->hasHistoricalFixing(today));
    testCase(name, fixingNotFound, euribor6M_a->hasHistoricalFixing(today));
    testCase(name, fixingNotFound, IndexManager::instance().hasHistoricalFixing(name, today));
}


test_suite* IndexTest::suite() {
    auto* suite = BOOST_TEST_SUITE("index tests");
    suite->add(QUANTLIB_TEST_CASE(&IndexTest::testFixingObservability));
    suite->add(QUANTLIB_TEST_CASE(&IndexTest::testFixingHasHistoricalFixing));
    return suite;
}
]]></document_content>
  </document>
  <document index="135">
    <source>indexes.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_indexes_hpp
#define quantlib_test_indexes_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class IndexTest {
  public:
    static void testFixingObservability();
    static void testFixingHasHistoricalFixing();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="136">
    <source>inflation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2008 Piero Del Boca

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "inflation.hpp"
#include "utilities.hpp"

#include <ql/cashflows/indexedcashflow.hpp>
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/indexes/inflation/euhicp.hpp>
#include <ql/termstructures/inflation/piecewisezeroinflationcurve.hpp>
#include <ql/termstructures/inflation/piecewiseyoyinflationcurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/date.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/schedule.hpp>

#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>

#include <ql/cashflows/yoyinflationcoupon.hpp>
#include <ql/cashflows/inflationcouponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/instruments/yearonyearinflationswap.hpp>

#include <functional>


using boost::unit_test_framework::test_suite;

using namespace QuantLib;

using std::fabs;
using std::pow;
using std::vector;

#undef REPORT_FAILURE
#define REPORT_FAILURE(d, res, periodName) \
    BOOST_ERROR("wrong " << periodName << " inflation period for Date (1 " \
        << d << "), Start Date ( " \
        << res.first << "), End Date (" \
        << res.second << ")"); \

namespace inflation_test {

    struct Datum {
        Date date;
        Rate rate;
    };

    ext::shared_ptr<YieldTermStructure> nominalTermStructure() {
        Date evaluationDate(13, August, 2007);
        return ext::shared_ptr<YieldTermStructure>(
            new FlatForward(evaluationDate, 0.05, Actual360()));
    }

    template <class T>
    std::vector<ext::shared_ptr<BootstrapHelper<T> > > makeHelpers(
        const std::vector<Datum>& iiData,
        std::function<ext::shared_ptr<BootstrapHelper<T> >(const Handle<Quote>&, const Date&)>
            makeHelper) {

        std::vector<ext::shared_ptr<BootstrapHelper<T> > > instruments;
        for (Datum datum : iiData) {
            Date maturity = datum.date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(new SimpleQuote(datum.rate / 100.0)));
            auto anInstrument = makeHelper(quote, maturity);
            instruments.push_back(anInstrument);
        }

        return instruments;
    }
}

//===========================================================================================
// zero inflation tests, index, termstructure, and swaps
//===========================================================================================

namespace inflation_test {

void checkSeasonality(const Handle<ZeroInflationTermStructure>& hz, 
    const ext::shared_ptr<ZeroInflationIndex>& ii) {
    
    QL_REQUIRE(!hz->hasSeasonality(), "We require that the initially passed in term structure "
        << "does not have seasonality");

    // Tolerance that we will use below when comparing projected index fixings
    Rate tolerance = 1e-12;

    Date trueBaseDate = inflationPeriod(hz->baseDate(), ii->frequency()).second;
    Date seasonalityBaseDate(31, January, trueBaseDate.year());
    
    // Create two different seasonality objects
    
    // 1) Monthly seasonality with all elements equal to 1 <=> no seasonality
    vector<Rate> seasonalityFactors(12, 1.0);
    ext::shared_ptr<MultiplicativePriceSeasonality> unitSeasonality = 
        ext::make_shared<MultiplicativePriceSeasonality>(seasonalityBaseDate, Monthly, seasonalityFactors);

    // 2) Seasonality with factors != 1.0
    seasonalityFactors[0] = 1.003245;
    seasonalityFactors[1] = 1.000000;
    seasonalityFactors[2] = 0.999715;
    seasonalityFactors[3] = 1.000495;
    seasonalityFactors[4] = 1.000929;
    seasonalityFactors[5] = 0.998687;
    seasonalityFactors[6] = 0.995949;
    seasonalityFactors[7] = 0.994682;
    seasonalityFactors[8] = 0.995949;
    seasonalityFactors[9] = 1.000519;
    seasonalityFactors[10] = 1.003705;
    seasonalityFactors[11] = 1.004186;

    ext::shared_ptr<MultiplicativePriceSeasonality> nonUnitSeasonality =
        ext::make_shared<MultiplicativePriceSeasonality>(seasonalityBaseDate, Monthly, seasonalityFactors);
    
    // Create dates on which we will check fixings
    vector<Date> fixingDates(12);
    Date anchorDate(14, January, 2013);
    for (Size i = 0; i < fixingDates.size(); ++i) {
        fixingDates[i] = anchorDate + i * Months;
    }

    // Projected inflation index fixings when there is no seasonality
    vector<Rate> noSeasonalityFixings(12, 1.0);
    for (Size i = 0; i < fixingDates.size(); ++i) {
        noSeasonalityFixings[i] = ii->fixing(fixingDates[i], true);
    }

    // Set seasonality of all 1's and get the projected index fixings
    hz->setSeasonality(unitSeasonality);
    vector<Rate> unitSeasonalityFixings(12, 1.0);
    for (Size i = 0; i < fixingDates.size(); ++i) {
        unitSeasonalityFixings[i] = ii->fixing(fixingDates[i], true);
    }

    // Check that the unit seasonality fixings agree with the no seasonality fixings
    for (Size i = 0; i < fixingDates.size(); i++) {
        if (fabs(noSeasonalityFixings[i] - unitSeasonalityFixings[i]) > tolerance) {
            BOOST_ERROR("Seasonality doesn't work correctly when seasonality factors are set = 1"
                << "No seasonality fixing is: " << noSeasonalityFixings[i] 
                << " but unit seasonality fixing is: " << unitSeasonalityFixings[i]
                << " for fixing date " << io::iso_date(fixingDates[i]));
        }
    }

    // Testing seasonality correction when seasonality factors are different from 1
    // We expect to see that I_{SA}(t) = I_{NSA}(t) * S(t) / S(t_b)
    Month baseCpiMonth = hz->baseDate().month();
    Size baseCpiIndex = static_cast<Size>(baseCpiMonth) - 1;
    Rate baseSeasonality = seasonalityFactors[baseCpiIndex];

    // These are the expected fixings
    vector<Rate> expectedSeasonalityFixings(12, 1.0);
    for (Size i = 0; i < expectedSeasonalityFixings.size(); ++i) {
        expectedSeasonalityFixings[i] = ii->fixing(fixingDates[i], true) * 
            seasonalityFactors[i] / baseSeasonality;
    }

    // Set the seasonality and calculate the actual seasonally adjusted fixings
    hz->setSeasonality(nonUnitSeasonality);
    vector<Rate> nonUnitSeasonalityFixings(12, 1.0);
    for (Size i = 0; i < fixingDates.size(); ++i) {
        nonUnitSeasonalityFixings[i] = ii->fixing(fixingDates[i], true);
    }

    // Check that the calculated fixings agree with the expected fixings
    for (Size i = 0; i < fixingDates.size(); i++) {
        if (fabs(expectedSeasonalityFixings[i] - nonUnitSeasonalityFixings[i]) > tolerance) {
            BOOST_ERROR("Seasonality doesn't work correctly for non-unit seasonality factors."
                << " Expected fixing is: " << expectedSeasonalityFixings[i]
                << " but calculated fixing is: " << nonUnitSeasonalityFixings[i]
                << " for fixing date " << io::iso_date(fixingDates[i]));
        }
    }

    // Testing that unsetting seasonality works also
    hz->setSeasonality();
    vector<Rate> unsetSeasonalityFixings(12, 1.0);
    for (Size i = 0; i < fixingDates.size(); ++i) {
        unsetSeasonalityFixings[i] = ii->fixing(fixingDates[i], true);
    }

    // Check that seasonality has been unset by comparing with the no seasonality fixings
    for (Size i = 0; i < fixingDates.size(); i++) {
        if (fabs(noSeasonalityFixings[i] - unsetSeasonalityFixings[i]) > tolerance) {
            BOOST_ERROR("Unsetting seasonality doesn't work correctly."
                << " No seasonality fixing is: " << noSeasonalityFixings[i]
                << " but after unsetting seasonality fixing is: " << unitSeasonalityFixings[i]
                << " for fixing date " << io::iso_date(fixingDates[i]));
        }
    }
}

}

void InflationTest::testZeroIndex() {
    BOOST_TEST_MESSAGE("Testing zero inflation indices...");

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    EUHICP euhicp(true);
    if (euhicp.name() != "EU HICP"
        || euhicp.frequency() != Monthly
        || euhicp.revised()
        || !euhicp.interpolated()
        || euhicp.availabilityLag() != 1*Months) {
        BOOST_ERROR("wrong EU HICP data ("
                    << euhicp.name() << ", "
                    << euhicp.frequency() << ", "
                    << euhicp.revised() << ", "
                    << euhicp.interpolated() << ", "
                    << euhicp.availabilityLag() << ")");
    }

    UKRPI ukrpi(false);
    if (ukrpi.name() != "UK RPI"
        || ukrpi.frequency() != Monthly
        || ukrpi.revised()
        || ukrpi.interpolated()
        || ukrpi.availabilityLag() != 1*Months) {
        BOOST_ERROR("wrong UK RPI data ("
                    << ukrpi.name() << ", "
                    << ukrpi.frequency() << ", "
                    << ukrpi.revised() << ", "
                    << ukrpi.interpolated() << ", "
                    << ukrpi.availabilityLag() << ")");
    }

    // Retrieval test.
    //----------------
    // make sure of the evaluation date
    Date evaluationDate(13, August, 2007);
    evaluationDate = UnitedKingdom().adjust(evaluationDate);
    Settings::instance().evaluationDate() = evaluationDate;

    // fixing data
    Date from(1, January, 2005);
    Date to(13, August, 2007);
    Schedule rpiSchedule = MakeSchedule().from(from).to(to)
    .withTenor(1*Months)
    .withCalendar(UnitedKingdom())
    .withConvention(ModifiedFollowing);

    Real fixData[] = { 189.9, 189.9, 189.6, 190.5, 191.6, 192.0,
        192.2, 192.2, 192.6, 193.1, 193.3, 193.6,
        194.1, 193.4, 194.2, 195.0, 196.5, 197.7,
        198.5, 198.5, 199.2, 200.1, 200.4, 201.1,
        202.7, 201.6, 203.1, 204.4, 205.4, 206.2,
        207.3, 206.1 };

    bool interp = false;
    ext::shared_ptr<UKRPI> iir(new UKRPI(interp));
    for (Size i=0; i<LENGTH(fixData); i++) {
        iir->addFixing(rpiSchedule[i], fixData[i]);
    }

    Date todayMinusLag = evaluationDate - iir->availabilityLag();
    std::pair<Date,Date> lim = inflationPeriod(todayMinusLag, iir->frequency());
    todayMinusLag = lim.first;

    Real eps = 1.0e-8;

    // -1 because last value not yet available,
    // (no TS so can't forecast).
    for (Size i=0; i<rpiSchedule.size()-1;i++) {
        std::pair<Date,Date> lim = inflationPeriod(rpiSchedule[i],
                                                   iir->frequency());
        for (Date d=lim.first; d<=lim.second; d++) {
            if (d < inflationPeriod(todayMinusLag,iir->frequency()).first) {
                if (std::fabs(iir->fixing(d) - fixData[i]) > eps)
                    BOOST_ERROR("Fixings not constant within a period: "
                                << iir->fixing(d)
                                << ", should be " << fixData[i]);
            }
        }
    }
}



void InflationTest::testZeroTermStructure() {
    BOOST_TEST_MESSAGE("Testing zero inflation term structure...");

    using namespace inflation_test;

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    // try the Zero UK
    Calendar calendar = UnitedKingdom();
    BusinessDayConvention bdc = ModifiedFollowing;
    Date evaluationDate(13, August, 2007);
    evaluationDate = calendar.adjust(evaluationDate);
    Settings::instance().evaluationDate() = evaluationDate;

    // fixing data
    Date from(1, January, 2005);
    Date to(13, August, 2007);
    Schedule rpiSchedule = MakeSchedule().from(from).to(to)
    .withTenor(1*Months)
    .withCalendar(UnitedKingdom())
    .withConvention(ModifiedFollowing);

    Real fixData[] = { 189.9, 189.9, 189.6, 190.5, 191.6, 192.0,
        192.2, 192.2, 192.6, 193.1, 193.3, 193.6,
        194.1, 193.4, 194.2, 195.0, 196.5, 197.7,
        198.5, 198.5, 199.2, 200.1, 200.4, 201.1,
        202.7, 201.6, 203.1, 204.4, 205.4, 206.2,
        207.3};

    RelinkableHandle<ZeroInflationTermStructure> hz;
    bool interp = false;
    ext::shared_ptr<UKRPI> iiUKRPI(new UKRPI(interp, hz));
    for (Size i=0; i<LENGTH(fixData); i++) {
        iiUKRPI->addFixing(rpiSchedule[i], fixData[i]);
    }

    ext::shared_ptr<ZeroInflationIndex> ii = ext::dynamic_pointer_cast<ZeroInflationIndex>(iiUKRPI);
    ext::shared_ptr<YieldTermStructure> nominalTS = nominalTermStructure();

    // now build the zero inflation curve
    std::vector<Datum> zcData = {
        { Date(13, August, 2008), 2.93 },
        { Date(13, August, 2009), 2.95 },
        { Date(13, August, 2010), 2.965 },
        { Date(15, August, 2011), 2.98 },
        { Date(13, August, 2012), 3.0 },
        { Date(13, August, 2014), 3.06 },
        { Date(13, August, 2017), 3.175 },
        { Date(13, August, 2019), 3.243 },
        { Date(15, August, 2022), 3.293 },
        { Date(14, August, 2027), 3.338 },
        { Date(13, August, 2032), 3.348 },
        { Date(15, August, 2037), 3.348 },
        { Date(13, August, 2047), 3.308 },
        { Date(13, August, 2057), 3.228 }
    };

    Period observationLag = Period(2,Months);
    DayCounter dc = Thirty360(Thirty360::BondBasis);
    Frequency frequency = Monthly;

    auto makeHelper = [&](const Handle<Quote>& quote, const Date& maturity) {
        return ext::make_shared<ZeroCouponInflationSwapHelper>(
            quote, observationLag, maturity, calendar, bdc, dc, ii, CPI::AsIndex,
            Handle<YieldTermStructure>(nominalTS));
    };
    auto helpers = makeHelpers<ZeroInflationTermStructure>(zcData, makeHelper);

    Rate baseZeroRate = zcData[0].rate/100.0;
    ext::shared_ptr<PiecewiseZeroInflationCurve<Linear> > pZITS(
                        new PiecewiseZeroInflationCurve<Linear>(
                        evaluationDate, calendar, dc, observationLag,
                        frequency, ii->interpolated(), baseZeroRate,
                        helpers));
    pZITS->recalculate();

    // first check that the zero rates on the curve match the data
    // and that the helpers give the correct impled rates
    const Real eps = 0.00000001;
    bool forceLinearInterpolation = false;
    for (Size i=0; i<zcData.size(); i++) {
        BOOST_REQUIRE_MESSAGE(std::fabs(zcData[i].rate/100.0
            - pZITS->zeroRate(zcData[i].date, observationLag, forceLinearInterpolation)) < eps,
            "ZITS zeroRate != instrument "
            << pZITS->zeroRate(zcData[i].date, observationLag, forceLinearInterpolation)
            << " vs " << zcData[i].rate/100.0
            << " interpolation: " << ii->interpolated()
            << " forceLinearInterpolation " << forceLinearInterpolation);
        BOOST_REQUIRE_MESSAGE(std::fabs(helpers[i]->impliedQuote()
            - zcData[i].rate/100.0) < eps,
            "ZITS implied quote != instrument "
            << helpers[i]->impliedQuote()
            << " vs " << zcData[i].rate/100.0);
    }


    // now test the forecasting capability of the index.
    hz.linkTo(pZITS);
    from = hz->baseDate();
    to = hz->maxDate()-1*Months; // a bit of margin for adjustments
    Schedule testIndex = MakeSchedule().from(from).to(to)
                            .withTenor(1*Months)
                            .withCalendar(UnitedKingdom())
                            .withConvention(ModifiedFollowing);


    // we are testing UKRPI which is not interpolated
    Date bd = hz->baseDate();
    Real bf = ii->fixing(bd);
    for (const auto& d : testIndex) {
        Real z = hz->zeroRate(d, Period(0, Days));
        Real t = hz->dayCounter().yearFraction(bd, d);
        if(!ii->interpolated()) // because fixing constant over period
            t = hz->dayCounter().yearFraction(bd,
                inflationPeriod(d, ii->frequency()).first);
        Real calc = bf * pow( 1+z, t);
        if (t<=0)
            calc = ii->fixing(d,false); // still historical
        if (std::fabs(calc - ii->fixing(d,true))/10000.0 > eps)
            BOOST_ERROR("ZC index does not forecast correctly for date " << d
                        << " from base date " << bd
                        << " with fixing " << bf
                        << ", correct:  " << calc
                        << ", fix: " << ii->fixing(d,true)
                        << ", t " << t);
    }


    //===========================================================================================
    // Test zero-inflation-indexed (i.e. cpi ratio) cashflow
    // just ordinary indexed cashflow with a zero inflation index

    Date baseDate(1, January, 2006);
    Date fixDate(1, August, 2014);
    Date payDate=UnitedKingdom().adjust(fixDate+Period(3,Months),ModifiedFollowing);
    ext::shared_ptr<Index> ind = ext::dynamic_pointer_cast<Index>(ii);
    BOOST_REQUIRE_MESSAGE(ind,"dynamic_pointer_cast to Index from InflationIndex failed");

    Real notional = 1000000.0;//1m
    IndexedCashFlow iicf(notional,ind,baseDate,fixDate,payDate);
    Real correctIndexed = ii->fixing(iicf.fixingDate())/ii->fixing(iicf.baseDate());
    Real calculatedIndexed = iicf.amount()/iicf.notional();
    BOOST_REQUIRE_MESSAGE(std::fabs(correctIndexed - calculatedIndexed) < eps,
               "IndexedCashFlow indexing wrong: " << calculatedIndexed << " vs correct = "
               << correctIndexed);


    //===========================================================================================
    // Test zero coupon swap

    // first make one ...

    ext::shared_ptr<ZeroInflationIndex> zii = ext::dynamic_pointer_cast<ZeroInflationIndex>(ii);
    BOOST_REQUIRE_MESSAGE(zii,"dynamic_pointer_cast to ZeroInflationIndex from UKRPI failed");
    ZeroCouponInflationSwap nzcis(Swap::Payer,
                                  1000000.0,
                                  evaluationDate,
                                  zcData[6].date,    // end date = maturity
                                  calendar, bdc, dc, zcData[6].rate/100.0, // fixed rate
                                  zii, observationLag, CPI::AsIndex);

    // N.B. no coupon pricer because it is not a coupon, effect of inflation curve via
    //      inflation curve attached to the inflation index.
    Handle<YieldTermStructure> hTS(nominalTS);
    ext::shared_ptr<PricingEngine> sppe(new DiscountingSwapEngine(hTS));
    nzcis.setPricingEngine(sppe);

    // ... and price it, should be zero
    BOOST_CHECK_MESSAGE(fabs(nzcis.NPV())<0.00001,"ZCIS does not reprice to zero "
                        << nzcis.NPV()
                        << evaluationDate << " to " << zcData[6].date << " becoming " << nzcis.maturityDate()
                        << " rate " << zcData[6].rate
                        << " fixed leg " << nzcis.legNPV(0)
                        << " indexed-predicted inflated leg " << nzcis.legNPV(1)
                        << " discount " << nominalTS->discount(nzcis.maturityDate())
                        );

    // Perform checks on the seasonality for this non-interpolated index
    checkSeasonality(hz, ii);

    //==============================================================================
    // now do an INTERPOLATED index, i.e. repeat everything on a fake version of
    // UKRPI (to save making another term structure)

    bool interpYES = true;
    ext::shared_ptr<UKRPI> iiUKRPIyes(new UKRPI(interpYES, hz));
    for (Size i=0; i<LENGTH(fixData);i++) {
        iiUKRPIyes->addFixing(rpiSchedule[i], fixData[i]);
    }

    ext::shared_ptr<ZeroInflationIndex> iiyes
        = ext::dynamic_pointer_cast<ZeroInflationIndex>(iiUKRPIyes);

    // now build the zero inflation curve
    // same data, bigger lag or it will be a self-contradiction
    Period observationLagyes = Period(3,Months);

    auto makeHelperYes = [&](const Handle<Quote>& quote, const Date& maturity) {
        return ext::make_shared<ZeroCouponInflationSwapHelper>(
            quote, observationLagyes, maturity, calendar, bdc, dc, iiyes, CPI::AsIndex,
            Handle<YieldTermStructure>(nominalTS));
    };
    auto helpersyes = makeHelpers<ZeroInflationTermStructure>(zcData, makeHelperYes);

    ext::shared_ptr<PiecewiseZeroInflationCurve<Linear> > pZITSyes(
            new PiecewiseZeroInflationCurve<Linear>(
            evaluationDate, calendar, dc, observationLagyes,
            frequency, iiyes->interpolated(), baseZeroRate,
            helpersyes));
    pZITSyes->recalculate();

    // first check that the zero rates on the curve match the data
    // and that the helpers give the correct impled rates
    forceLinearInterpolation = false;   // still
    for (Size i=0; i<zcData.size(); i++) {
        BOOST_CHECK_MESSAGE(std::fabs(zcData[i].rate/100.0
                    - pZITSyes->zeroRate(zcData[i].date, observationLagyes, forceLinearInterpolation)) < eps,
                    "ZITS INTERPOLATED zeroRate != instrument "
                    << pZITSyes->zeroRate(zcData[i].date, observationLagyes, forceLinearInterpolation)
                    << " date " << zcData[i].date << " observationLagyes " << observationLagyes
                    << " vs " << zcData[i].rate/100.0
                    << " interpolation: " << iiyes->interpolated()
                    << " forceLinearInterpolation " << forceLinearInterpolation);
        BOOST_CHECK_MESSAGE(std::fabs(helpersyes[i]->impliedQuote()
                        - zcData[i].rate/100.0) < eps,
                    "ZITS INTERPOLATED implied quote != instrument "
                    << helpersyes[i]->impliedQuote()
                    << " vs " << zcData[i].rate/100.0);
    }


    //======================================================================================
    // now test the forecasting capability of the index.
    hz.linkTo(pZITSyes);
    from = hz->baseDate()+1*Months; // to avoid historical linear bit for rest of base month
    to = hz->maxDate()-1*Months; // a bit of margin for adjustments
    testIndex = MakeSchedule().from(from).to(to)
    .withTenor(1*Months)
    .withCalendar(UnitedKingdom())
    .withConvention(ModifiedFollowing);

    // we are testing UKRPI which is FAKE interpolated for testing here
    bd = hz->baseDate();
    bf = iiyes->fixing(bd);
    for (const auto& d : testIndex) {
        Real z = hz->zeroRate(d, Period(0, Days));
        Real t = hz->dayCounter().yearFraction(bd, d);
        Real calc = bf * pow( 1+z, t);
        if (t<=0) calc = iiyes->fixing(d); // still historical
        if (std::fabs(calc - iiyes->fixing(d)) > eps)
            BOOST_ERROR("ZC INTERPOLATED index does not forecast correctly for date " << d
                        << " from base date " << bd
                        << " with fixing " << bf
                        << ", correct:  " << calc
                        << ", fix: " << iiyes->fixing(d)
                        << ", t " << t
                        << ", zero " << z);
    }


    //===========================================================================================
    // Test zero coupon swap

    ext::shared_ptr<ZeroInflationIndex> ziiyes = ext::dynamic_pointer_cast<ZeroInflationIndex>(iiyes);
    BOOST_REQUIRE_MESSAGE(ziiyes,"dynamic_pointer_cast to ZeroInflationIndex from UKRPI-I failed");
    ZeroCouponInflationSwap nzcisyes(Swap::Payer,
                                     1000000.0,
                                     evaluationDate,
                                     zcData[6].date,    // end date = maturity
                                     calendar, bdc, dc, zcData[6].rate/100.0, // fixed rate
                                     ziiyes, observationLagyes, CPI::AsIndex);

    // N.B. no coupon pricer because it is not a coupon, effect of inflation curve via
    //      inflation curve attached to the inflation index.
    nzcisyes.setPricingEngine(sppe);

    // ... and price it, should be zero
    BOOST_CHECK_MESSAGE(fabs(nzcisyes.NPV())<0.00001,"ZCIS-I does not reprice to zero "
                        << nzcisyes.NPV()
                        << evaluationDate << " to " << zcData[6].date << " becoming " << nzcisyes.maturityDate()
                        << " rate " << zcData[6].rate
                        << " fixed leg " << nzcisyes.legNPV(0)
                        << " indexed-predicted inflated leg " << nzcisyes.legNPV(1)
                        << " discount " << nominalTS->discount(nzcisyes.maturityDate())
                        );

    // Perform checks on the seasonality for this interpolated index
    checkSeasonality(hz, iiyes);

    // remove circular refernce
    hz.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
}

void InflationTest::testZeroIndexFutureFixing() {
    BOOST_TEST_MESSAGE("Testing that zero inflation indices forecast future fixings...");

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    EUHICP euhicp(false);

    Date sample_date = Date(1,December,2013);
    Real sample_fixing = 117.48;
    euhicp.addFixing(sample_date, sample_fixing);

    // fixing date in the past
    Date evaluationDate = euhicp.fixingCalendar().adjust(sample_date + 2*Weeks);
    Settings::instance().evaluationDate() = evaluationDate;
    Real fixing = euhicp.fixing(sample_date);
    if (std::fabs(fixing - sample_fixing) > 1e-12)
        BOOST_ERROR("Failed to retrieve correct fixing: "
                    << "\n    returned: " << fixing
                    << "\n    expected: " << sample_fixing);

    // fixing date in the future
    evaluationDate = euhicp.fixingCalendar().adjust(sample_date - 2*Weeks);
    Settings::instance().evaluationDate() = evaluationDate;
    bool retrieved = false;
    try {
        fixing = euhicp.fixing(sample_date);
        // the above should throw for lack of a forecast curve, so
        // this shouldn't be executed and retrieved should stay false
        retrieved = true;
    } catch (Error&) {}

    if (retrieved)
        BOOST_ERROR("Retrieved future fixing: "
                    << "\n    returned: " << fixing);
}



//===========================================================================================
// year on year tests, index, termstructure, and swaps
//===========================================================================================

void InflationTest::testYYIndex() {
    BOOST_TEST_MESSAGE("Testing year-on-year inflation indices...");

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    YYEUHICP yyeuhicp(true);
    if (yyeuhicp.name() != "EU YY_HICP"
        || yyeuhicp.frequency() != Monthly
        || yyeuhicp.revised()
        || !yyeuhicp.interpolated()
        || yyeuhicp.ratio()
        || yyeuhicp.availabilityLag() != 1*Months) {
        BOOST_ERROR("wrong year-on-year EU HICP data ("
                    << yyeuhicp.name() << ", "
                    << yyeuhicp.frequency() << ", "
                    << yyeuhicp.revised() << ", "
                    << yyeuhicp.interpolated() << ", "
                    << yyeuhicp.ratio() << ", "
                    << yyeuhicp.availabilityLag() << ")");
    }

    YYEUHICPr yyeuhicpr(true);
    if (yyeuhicpr.name() != "EU YYR_HICP"
        || yyeuhicpr.frequency() != Monthly
        || yyeuhicpr.revised()
        || !yyeuhicpr.interpolated()
        || !yyeuhicpr.ratio()
        || yyeuhicpr.availabilityLag() != 1*Months) {
        BOOST_ERROR("wrong year-on-year EU HICPr data ("
                    << yyeuhicpr.name() << ", "
                    << yyeuhicpr.frequency() << ", "
                    << yyeuhicpr.revised() << ", "
                    << yyeuhicpr.interpolated() << ", "
                    << yyeuhicpr.ratio() << ", "
                    << yyeuhicpr.availabilityLag() << ")");
    }

    YYUKRPI yyukrpi(false);
    if (yyukrpi.name() != "UK YY_RPI"
        || yyukrpi.frequency() != Monthly
        || yyukrpi.revised()
        || yyukrpi.interpolated()
        || yyukrpi.ratio()
        || yyukrpi.availabilityLag() != 1*Months) {
        BOOST_ERROR("wrong year-on-year UK RPI data ("
                    << yyukrpi.name() << ", "
                    << yyukrpi.frequency() << ", "
                    << yyukrpi.revised() << ", "
                    << yyukrpi.interpolated() << ", "
                    << yyukrpi.ratio() << ", "
                    << yyukrpi.availabilityLag() << ")");
    }

    YYUKRPIr yyukrpir(false);
    if (yyukrpir.name() != "UK YYR_RPI"
        || yyukrpir.frequency() != Monthly
        || yyukrpir.revised()
        || yyukrpir.interpolated()
        || !yyukrpir.ratio()
        || yyukrpir.availabilityLag() != 1*Months) {
        BOOST_ERROR("wrong year-on-year UK RPIr data ("
                    << yyukrpir.name() << ", "
                    << yyukrpir.frequency() << ", "
                    << yyukrpir.revised() << ", "
                    << yyukrpir.interpolated() << ", "
                    << yyukrpir.ratio() << ", "
                    << yyukrpir.availabilityLag() << ")");
    }


    // Retrieval test.
    //----------------
    // make sure of the evaluation date
    Date evaluationDate(13, August, 2007);
    evaluationDate = UnitedKingdom().adjust(evaluationDate);
    Settings::instance().evaluationDate() = evaluationDate;

    // fixing data
    Date from(1, January, 2005);
    Date to(13, August, 2007);
    Schedule rpiSchedule = MakeSchedule().from(from).to(to)
    .withTenor(1*Months)
    .withCalendar(UnitedKingdom())
    .withConvention(ModifiedFollowing);

    Real fixData[] = { 189.9, 189.9, 189.6, 190.5, 191.6, 192.0,
        192.2, 192.2, 192.6, 193.1, 193.3, 193.6,
        194.1, 193.4, 194.2, 195.0, 196.5, 197.7,
        198.5, 198.5, 199.2, 200.1, 200.4, 201.1,
        202.7, 201.6, 203.1, 204.4, 205.4, 206.2,
        207.3 };

    bool interp = false;
    ext::shared_ptr<YYUKRPIr> iir(new YYUKRPIr(interp));
    ext::shared_ptr<YYUKRPIr> iirYES(new YYUKRPIr(true));
    for (Size i=0; i<LENGTH(fixData);i++) {
        iir->addFixing(rpiSchedule[i], fixData[i]);
        iirYES->addFixing(rpiSchedule[i], fixData[i]);
    }

    Date todayMinusLag = evaluationDate - iir->availabilityLag();
    std::pair<Date,Date> lim = inflationPeriod(todayMinusLag, iir->frequency());
    todayMinusLag = lim.second + 1 - 2*Period(iir->frequency());

    Real eps = 1.0e-8;

    // Interpolation tests
    //--------------------
    // (no TS so can't forecast).
    for (Size i=13; i<rpiSchedule.size();i++) {
        std::pair<Date,Date> lim = inflationPeriod(rpiSchedule[i],
                                                   iir->frequency());
        std::pair<Date,Date> limBef = inflationPeriod(rpiSchedule[i-12],
                                                      iir->frequency());
        for (Date d=lim.first; d<=lim.second; d++) {
            if (d < todayMinusLag) {
                Rate expected = fixData[i]/fixData[i-12] - 1.0;
                Rate calculated = iir->fixing(d);
                BOOST_CHECK_MESSAGE(std::fabs(calculated - expected) < eps,
                                    "Non-interpolated fixings not constant within a period: "
                                    << calculated
                                    << ", should be "
                                    << expected);

                Real dp= lim.second + 1- lim.first;
                Real dpBef=limBef.second + 1 - limBef.first;
                Real dl = d-lim.first;
                // potentially does not work on 29th Feb
                Real dlBef = NullCalendar().advance(d, -1*Years, ModifiedFollowing)
                -limBef.first;

                Real linearNow = fixData[i] + (fixData[i+1]-fixData[i])*dl/dp;
                Real linearBef = fixData[i-12] + (fixData[i+1-12]-fixData[i-12])*dlBef/dpBef;
                Rate expectedYES = linearNow / linearBef - 1.0;
                Rate calculatedYES = iirYES->fixing(d);
                BOOST_CHECK_MESSAGE(fabs(expectedYES-calculatedYES)<eps,
                                    "Error in interpolated fixings: expect "<<expectedYES
                                    <<" see " << calculatedYES
                                    <<" flat " << calculated
                                    <<", data: "<< fixData[i-12] <<", "<< fixData[i+1-12]
                                    <<", "<<    fixData[i] <<", "<< fixData[i+1]
                                    <<", fac: "<< dp <<", "<< dl
                                    <<", "<< dpBef <<", "<< dlBef
                                    <<", to: "<<linearNow<<", "<<linearBef
                                    );
            }
        }
    }

}


void InflationTest::testYYTermStructure() {
    BOOST_TEST_MESSAGE("Testing year-on-year inflation term structure...");

    using namespace inflation_test;

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    // try the YY UK
    Calendar calendar = UnitedKingdom();
    BusinessDayConvention bdc = ModifiedFollowing;
    Date evaluationDate(13, August, 2007);
    evaluationDate = calendar.adjust(evaluationDate);
    Settings::instance().evaluationDate() = evaluationDate;


    // fixing data
    Date from(1, January, 2005);
    Date to(13, August, 2007);
    Schedule rpiSchedule = MakeSchedule().from(from).to(to)
    .withTenor(1*Months)
    .withCalendar(UnitedKingdom())
    .withConvention(ModifiedFollowing);
    Real fixData[] = { 189.9, 189.9, 189.6, 190.5, 191.6, 192.0,
        192.2, 192.2, 192.6, 193.1, 193.3, 193.6,
        194.1, 193.4, 194.2, 195.0, 196.5, 197.7,
        198.5, 198.5, 199.2, 200.1, 200.4, 201.1,
        202.7, 201.6, 203.1, 204.4, 205.4, 206.2,
        207.3 };

    RelinkableHandle<YoYInflationTermStructure> hy;
    bool interp = false;
    ext::shared_ptr<YYUKRPIr> iir(new YYUKRPIr(interp, hy));
    for (Size i=0; i<LENGTH(fixData); i++) {
        iir->addFixing(rpiSchedule[i], fixData[i]);
    }



    ext::shared_ptr<YieldTermStructure> nominalTS = nominalTermStructure();

    // now build the YoY inflation curve
    std::vector<Datum> yyData = {
        { Date(13, August, 2008), 2.95 },
        { Date(13, August, 2009), 2.95 },
        { Date(13, August, 2010), 2.93 },
        { Date(15, August, 2011), 2.955 },
        { Date(13, August, 2012), 2.945 },
        { Date(13, August, 2013), 2.985 },
        { Date(13, August, 2014), 3.01 },
        { Date(13, August, 2015), 3.035 },
        { Date(13, August, 2016), 3.055 },  // note that
        { Date(13, August, 2017), 3.075 },  // some dates will be on
        { Date(13, August, 2019), 3.105 },  // holidays but the payment
        { Date(15, August, 2022), 3.135 },  // calendar will roll them
        { Date(13, August, 2027), 3.155 },
        { Date(13, August, 2032), 3.145 },
        { Date(13, August, 2037), 3.145 }
    };

    Period observationLag = Period(2,Months);
    DayCounter dc = Thirty360(Thirty360::BondBasis);

    // now build the helpers ...
    auto makeHelper = [&](const Handle<Quote>& quote, const Date& maturity) {
        return ext::make_shared<YearOnYearInflationSwapHelper>(
            quote, observationLag, maturity, calendar, bdc, dc, iir,
            Handle<YieldTermStructure>(nominalTS));
    };
    auto helpers = makeHelpers<YoYInflationTermStructure>(yyData, makeHelper);

    Rate baseYYRate = yyData[0].rate/100.0;
    ext::shared_ptr<PiecewiseYoYInflationCurve<Linear> > pYYTS(
        new PiecewiseYoYInflationCurve<Linear>(
                evaluationDate, calendar, dc, observationLag,
                iir->frequency(),iir->interpolated(), baseYYRate,
                helpers));
    pYYTS->recalculate();

    // validation
    // yoy swaps should reprice to zero
    // yy rates should not equal yySwap rates
    Real eps = 0.000001;
    // usual swap engine
    Handle<YieldTermStructure> hTS(nominalTS);
    ext::shared_ptr<PricingEngine> sppe(new DiscountingSwapEngine(hTS));

    // make sure that the index has the latest yoy term structure
    hy.linkTo(pYYTS);

    for (Size j = 1; j < yyData.size(); j++) {

        from = nominalTS->referenceDate();
        to = yyData[j].date;
        Schedule yoySchedule = MakeSchedule().from(from).to(to)
        .withConvention(Unadjusted) // fixed leg gets calendar from
        .withCalendar(calendar)     // schedule
        .withTenor(1*Years)
        .backwards()
        ;

        YearOnYearInflationSwap yyS2(Swap::Payer,
                                     1000000.0,
                                     yoySchedule,//fixed schedule, but same as yoy
                                     yyData[j].rate/100.0,
                                     dc,
                                     yoySchedule,
                                     iir,
                                     observationLag,
                                     0.0,        //spread on index
                                     dc,
                                     UnitedKingdom());

        yyS2.setPricingEngine(sppe);

        BOOST_CHECK_MESSAGE(fabs(yyS2.NPV())<eps,"fresh yoy swap NPV!=0 from TS "
                <<"swap quote for pt " << j
                << ", is " << yyData[j].rate/100.0
                <<" vs YoY rate "<< pYYTS->yoyRate(yyData[j].date-observationLag)
                <<" at quote date "<<(yyData[j].date-observationLag)
                <<", NPV of a fresh yoy swap is " << yyS2.NPV()
                <<"\n      fair rate " << yyS2.fairRate()
                <<" payment "<<yyS2.paymentConvention());
    }

    Size jj=3;
    for (Size k = 0; k < 14; k++) {

        from = nominalTS->referenceDate() - k*Months;
        to = yyData[jj].date - k*Months;
        Schedule yoySchedule = MakeSchedule().from(from).to(to)
        .withConvention(Unadjusted) // fixed leg gets calendar from
        .withCalendar(calendar)     // schedule
        .withTenor(1*Years)
        .backwards()
        ;

        YearOnYearInflationSwap yyS3(Swap::Payer,
                                     1000000.0,
                                     yoySchedule,//fixed schedule, but same as yoy
                                     yyData[jj].rate/100.0,
                                     dc,
                                     yoySchedule,
                                     iir,
                                     observationLag,
                                     0.0,        //spread on index
                                     dc,
                                     UnitedKingdom());

        yyS3.setPricingEngine(sppe);

        BOOST_CHECK_MESSAGE(fabs(yyS3.NPV())< 20000.0,
                            "unexpected size of aged YoY swap, aged "
                            <<k<<" months: YY aged NPV = " << yyS3.NPV()
                            <<", legs "<< yyS3.legNPV(0) << " and " << yyS3.legNPV(1)
                            );
    }
    // remove circular refernce
    hy.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
}

void InflationTest::testPeriod() {
    BOOST_TEST_MESSAGE("Testing inflation period...");

    Date d;
    Frequency f;
    std::pair<Date,Date> res;
    int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

    for (int year = 1950; year < 2051; ++year) {

        if (Date::isLeap(year))
            days[2] = 29;
        else
            days[2] = 28;

        for (Size i=1; i<=12; ++i){

            d = Date(1,Month(i),year);
            
            f = Monthly;
            res = inflationPeriod (d,f);
            if (res.first != Date(1,Month(i),year)
                || res.second != Date(days[i],Month(i),year)) {
                REPORT_FAILURE(d, res, "Monthly");
            }

            f = Quarterly;
            res = inflationPeriod (d,f);
            
            if ( (i==1 || i==2 || i==3) &&
                (res.first != Date(1,Month(1),year)
                 || res.second != Date(31,Month(3),year))) {
                REPORT_FAILURE(d, res, "Quarterly");
            }
            else if ( (i==4 || i==5 || i==6) &&
                (res.first != Date(1,Month(4),year)
                 || res.second != Date(30,Month(6),year))) {
                REPORT_FAILURE(d, res, "Quarterly");
            }
            else if ( (i==7 || i==8 || i==9) &&
                (res.first != Date(1,Month(7),year)
                 || res.second != Date(30,Month(9),year))) {
                REPORT_FAILURE(d, res, "Quarterly");
            }
            else if ( (i==10 || i==11 || i==12) &&
                (res.first != Date(1,Month(10),year)
                 || res.second != Date(31,Month(12),year))) {
                REPORT_FAILURE(d, res, "Quarterly");
            }

            f = Semiannual;
            res = inflationPeriod (d,f);
            
            if ( (i>0 && i<7) && (
                res.first != Date(1,Month(1),year)
                || res.second != Date(30,Month(6),year))) {
                REPORT_FAILURE(d, res, "Semiannual");
            }
            else if ( (i>6 && i<13) && (
                res.first != Date(1,Month(7),year)
                || res.second != Date(31,Month(12),year))) {
                REPORT_FAILURE(d, res, "Semiannual");
            }

            f = Annual;
            res = inflationPeriod (d,f);
            
            if (res.first != Date(1,Month(1),year)
                || res.second != Date(31,Month(12),year)) {
                REPORT_FAILURE(d, res, "Annual");
            }
        }
    }
}

test_suite* InflationTest::suite() {

    auto* suite = BOOST_TEST_SUITE("Inflation tests");

    suite->add(QUANTLIB_TEST_CASE(&InflationTest::testPeriod));

    suite->add(QUANTLIB_TEST_CASE(&InflationTest::testZeroIndex));
    suite->add(QUANTLIB_TEST_CASE(&InflationTest::testZeroTermStructure));
    suite->add(QUANTLIB_TEST_CASE(&InflationTest::testZeroIndexFutureFixing));

    suite->add(QUANTLIB_TEST_CASE(&InflationTest::testYYIndex));
    suite->add(QUANTLIB_TEST_CASE(&InflationTest::testYYTermStructure));

    return suite;
}
]]></document_content>
  </document>
  <document index="137">
    <source>inflation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflation_hpp
#define quantlib_test_inflation_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
 comment block of the corresponding class */

class InflationTest {
public:
    static void testPeriod();
    static void testZeroIndex();
    static void testZeroTermStructure();
    static void testZeroIndexFutureFixing();
    static void testYYIndex();
    static void testYYTermStructure();
    static boost::unit_test_framework::test_suite* suite();
};


#endif

]]></document_content>
  </document>
  <document index="138">
    <source>inflationcapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2004, 2005, 2006, 2007, 2008 StatPro Italia srl
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "inflationcapfloor.hpp"
#include "utilities.hpp"
#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/math/matrix.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/quotes/simplequote.hpp>

#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/indexes/inflation/euhicp.hpp>
#include <ql/termstructures/inflation/piecewiseyoyinflationcurve.hpp>
#include <ql/cashflows/yoyinflationcoupon.hpp>
#include <ql/cashflows/inflationcouponpricer.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/schedule.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/volatility/inflation/yoyinflationoptionletvolatilitystructure.hpp>
#include <ql/pricingengines/blackformula.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::fabs;

namespace inflation_capfloor_test {

    struct Datum {
        Date date;
        Rate rate;
    };

    template <class T, class U, class I>
    std::vector<ext::shared_ptr<BootstrapHelper<T> > > makeHelpers(
                 const std::vector<Datum>& iiData,
                 const ext::shared_ptr<I> &ii, const Period &observationLag,
                 const Calendar &calendar,
                 const BusinessDayConvention &bdc,
                 const DayCounter &dc,
                 const Handle<YieldTermStructure>& discountCurve) {

        std::vector<ext::shared_ptr<BootstrapHelper<T> > > instruments;
        for (Datum datum : iiData) {
            Date maturity = datum.date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(
                    new SimpleQuote(datum.rate/100.0)));
            ext::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
                    quote, observationLag, maturity,
                    calendar, bdc, dc, ii, discountCurve));
            instruments.push_back(anInstrument);
        }

        return instruments;
    }


    struct CommonVars {
        // common data

        Frequency frequency;
        std::vector<Real> nominals;
        Calendar calendar;
        BusinessDayConvention convention;
        Natural fixingDays;
        Date evaluationDate;
        Natural settlementDays;
        Date settlement;
        Period observationLag;
        DayCounter dc;
        ext::shared_ptr<YYUKRPIr> iir;

        RelinkableHandle<YieldTermStructure> nominalTS;
        ext::shared_ptr<YoYInflationTermStructure> yoyTS;
        RelinkableHandle<YoYInflationTermStructure> hy;

        // cleanup

        SavedSettings backup;

        // setup
        CommonVars()
        : nominals(1,1000000) {
            // option variables
            frequency = Annual;
            // usual setup
            calendar = UnitedKingdom();
            convention = ModifiedFollowing;
            Date today(13, August, 2007);
            evaluationDate = calendar.adjust(today);
            Settings::instance().evaluationDate() = evaluationDate;
            settlementDays = 0;
            fixingDays = 0;
            settlement = calendar.advance(today,settlementDays,Days);
            dc = Thirty360(Thirty360::BondBasis);

            // yoy index
            //      fixing data
            Date from(1, January, 2005);
            Date to(13, August, 2007);
            Schedule rpiSchedule = MakeSchedule().from(from).to(to)
            .withTenor(1*Months)
            .withCalendar(UnitedKingdom())
            .withConvention(ModifiedFollowing);
            Real fixData[] = { 189.9, 189.9, 189.6, 190.5, 191.6, 192.0,
                192.2, 192.2, 192.6, 193.1, 193.3, 193.6,
                194.1, 193.4, 194.2, 195.0, 196.5, 197.7,
                198.5, 198.5, 199.2, 200.1, 200.4, 201.1,
                202.7, 201.6, 203.1, 204.4, 205.4, 206.2,
                207.3, -999.0, -999 };
            // link from yoy index to yoy TS
            bool interp = false;
            iir = ext::make_shared<YYUKRPIr>(interp, hy);
            for (Size i=0; i<rpiSchedule.size();i++) {
                iir->addFixing(rpiSchedule[i], fixData[i]);
            }

            ext::shared_ptr<YieldTermStructure> nominalFF(
                new FlatForward(evaluationDate, 0.05, ActualActual(ActualActual::ISDA)));
            nominalTS.linkTo(nominalFF);

            // now build the YoY inflation curve
            Period observationLag = Period(2,Months);

            std::vector<Datum> yyData = {
                { Date(13, August, 2008), 2.95 },
                { Date(13, August, 2009), 2.95 },
                { Date(13, August, 2010), 2.93 },
                { Date(15, August, 2011), 2.955 },
                { Date(13, August, 2012), 2.945 },
                { Date(13, August, 2013), 2.985 },
                { Date(13, August, 2014), 3.01 },
                { Date(13, August, 2015), 3.035 },
                { Date(13, August, 2016), 3.055 },  // note that
                { Date(13, August, 2017), 3.075 },  // some dates will be on
                { Date(13, August, 2019), 3.105 },  // holidays but the payment
                { Date(15, August, 2022), 3.135 },  // calendar will roll them
                { Date(13, August, 2027), 3.155 },
                { Date(13, August, 2032), 3.145 },
                { Date(13, August, 2037), 3.145 }
            };

            // now build the helpers ...
            std::vector<ext::shared_ptr<BootstrapHelper<YoYInflationTermStructure> > > helpers =
            makeHelpers<YoYInflationTermStructure,YearOnYearInflationSwapHelper,
            YoYInflationIndex>(yyData, iir,
                               observationLag,
                               calendar, convention, dc,
                               Handle<YieldTermStructure>(nominalTS));

            Rate baseYYRate = yyData[0].rate/100.0;
            ext::shared_ptr<PiecewiseYoYInflationCurve<Linear> > pYYTS(
                new PiecewiseYoYInflationCurve<Linear>(
                        evaluationDate, calendar, dc, observationLag,
                        iir->frequency(),iir->interpolated(), baseYYRate,
                        helpers));
            pYYTS->recalculate();
            yoyTS = ext::dynamic_pointer_cast<YoYInflationTermStructure>(pYYTS);


            // make sure that the index has the latest yoy term structure
            hy.linkTo(pYYTS);
        }

        // utilities
        Leg makeYoYLeg(const Date& startDate, Integer length) const {
            ext::shared_ptr<YoYInflationIndex> ii =
                ext::dynamic_pointer_cast<YoYInflationIndex>(iir);
            Date endDate = calendar.advance(startDate,length*Years,Unadjusted);
            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              Unadjusted,Unadjusted,// ref periods & acc periods
                              DateGeneration::Forward, false);
            return yoyInflationLeg(schedule, calendar, ii, observationLag)
            .withNotionals(nominals)
            .withPaymentDayCounter(dc)
            .withPaymentAdjustment(convention);
        }


        ext::shared_ptr<PricingEngine> makeEngine(Volatility volatility, Size which) const {

            ext::shared_ptr<YoYInflationIndex>
            yyii = ext::dynamic_pointer_cast<YoYInflationIndex>(iir);

            Handle<YoYOptionletVolatilitySurface>
                vol(ext::make_shared<ConstantYoYOptionletVolatility>(
                                                       volatility,
                                                       settlementDays,
                                                       calendar,
                                                       convention,
                                                       dc,
                                                       observationLag,
                                                       frequency,
                                                       iir->interpolated()));


            switch (which) {
                case 0:
                    return ext::shared_ptr<PricingEngine>(
                            new YoYInflationBlackCapFloorEngine(iir, vol, nominalTS));
                    break;
                case 1:
                    return ext::shared_ptr<PricingEngine>(
                            new YoYInflationUnitDisplacedBlackCapFloorEngine(iir, vol, nominalTS));
                    break;
                case 2:
                    return ext::shared_ptr<PricingEngine>(
                            new YoYInflationBachelierCapFloorEngine(iir, vol, nominalTS));
                    break;
                default:
                    BOOST_FAIL("unknown engine request: which = "<<which
                               <<"should be 0=Black,1=DD,2=Bachelier");
                    break;
            }
            // make compiler happy
            QL_FAIL("never get here - no engine resolution");
        }


        ext::shared_ptr<YoYInflationCapFloor> makeYoYCapFloor(YoYInflationCapFloor::Type type,
                                                              const Leg& leg,
                                                              Rate strike,
                                                              Volatility volatility,
                                                              Size which) const {
            ext::shared_ptr<YoYInflationCapFloor> result;
            switch (type) {
                case YoYInflationCapFloor::Cap:
                    result = ext::shared_ptr<YoYInflationCapFloor>(
                        new YoYInflationCap(leg, std::vector<Rate>(1, strike)));
                    break;
                case YoYInflationCapFloor::Floor:
                    result = ext::shared_ptr<YoYInflationCapFloor>(
                        new YoYInflationFloor(leg, std::vector<Rate>(1, strike)));
                    break;
                default:
                    QL_FAIL("unknown YoYInflation cap/floor type");
            }
            result->setPricingEngine(makeEngine(volatility, which));
            return result;
        }
    };

}



void InflationCapFloorTest::testConsistency() {

    BOOST_TEST_MESSAGE("Testing consistency between yoy inflation cap,"
                       " floor and collar...");

    using namespace inflation_capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    Rate cap_rates[] = { 0.01, 0.025, 0.029, 0.03, 0.031, 0.035, 0.07 };
    Rate floor_rates[] = { 0.01, 0.025, 0.029, 0.03, 0.031, 0.035, 0.07 };
    Volatility vols[] = { 0.001, 0.005, 0.010, 0.015, 0.020 };

    for (Size whichPricer = 0; whichPricer < 3; whichPricer++) {
        for (int& length : lengths) {
            for (double& cap_rate : cap_rates) {
                for (double& floor_rate : floor_rates) {
                    for (double vol : vols) {

                        Leg leg = vars.makeYoYLeg(vars.evaluationDate, length);

                        ext::shared_ptr<YoYInflationCapFloor> cap = vars.makeYoYCapFloor(
                            YoYInflationCapFloor::Cap, leg, cap_rate, vol, whichPricer);

                        ext::shared_ptr<YoYInflationCapFloor> floor = vars.makeYoYCapFloor(
                            YoYInflationCapFloor::Floor, leg, floor_rate, vol, whichPricer);

                        YoYInflationCollar collar(leg, std::vector<Rate>(1, cap_rate),
                                                  std::vector<Rate>(1, floor_rate));
                        collar.setPricingEngine(vars.makeEngine(vol, whichPricer));

                        if (std::fabs((cap->NPV() - floor->NPV()) - collar.NPV()) > 1e-6) {
                            BOOST_FAIL("inconsistency between cap, floor and collar:\n"
                                       << "    length:       " << length << " years\n"
                                       << "    volatility:   " << io::volatility(vol) << "\n"
                                       << "    cap value:    " << cap->NPV()
                                       << " at strike: " << io::rate(cap_rate) << "\n"
                                       << "    floor value:  " << floor->NPV()
                                       << " at strike: " << io::rate(floor_rate) << "\n"
                                       << "    collar value: " << collar.NPV());


                            // test re-composition by optionlets, N.B. ONE per year
                            Real capletsNPV = 0.0;
                            std::vector<ext::shared_ptr<YoYInflationCapFloor> > caplets;
                            for (Integer m = 0; m < length * 1; m++) {
                                caplets.push_back(cap->optionlet(m));
                                caplets[m]->setPricingEngine(vars.makeEngine(vol, whichPricer));
                                capletsNPV += caplets[m]->NPV();
                            }

                            if (std::fabs(cap->NPV() - capletsNPV) > 1e-6) {
                                BOOST_FAIL("sum of caplet NPVs does not equal cap NPV:\n"
                                           << "    length:       " << length << " years\n"
                                           << "    volatility:   " << io::volatility(vol) << "\n"
                                           << "    cap value:    " << cap->NPV()
                                           << " at strike: " << io::rate(cap_rate) << "\n"
                                           << "    sum of caplets value:  " << capletsNPV
                                           << " at strike (first): "
                                           << io::rate(caplets[0]->capRates()[0]) << "\n");
                            }

                            Real floorletsNPV = 0.0;
                            std::vector<ext::shared_ptr<YoYInflationCapFloor> > floorlets;
                            for (Integer m = 0; m < length * 1; m++) {
                                floorlets.push_back(floor->optionlet(m));
                                floorlets[m]->setPricingEngine(vars.makeEngine(vol, whichPricer));
                                floorletsNPV += floorlets[m]->NPV();
                            }

                            if (std::fabs(floor->NPV() - floorletsNPV) > 1e-6) {
                                BOOST_FAIL("sum of floorlet NPVs does not equal floor NPV:\n"
                                           << "    length:       " << length << " years\n"
                                           << "    volatility:   " << io::volatility(vol) << "\n"
                                           << "    cap value:    " << floor->NPV()
                                           << " at strike: " << io::rate(floor_rate) << "\n"
                                           << "    sum of floorlets value:  " << floorletsNPV
                                           << " at strike (first): "
                                           << io::rate(floorlets[0]->floorRates()[0]) << "\n");
                            }

                            Real collarletsNPV = 0.0;
                            std::vector<ext::shared_ptr<YoYInflationCapFloor> > collarlets;
                            for (Integer m = 0; m < length * 1; m++) {
                                collarlets.push_back(collar.optionlet(m));
                                collarlets[m]->setPricingEngine(vars.makeEngine(vol, whichPricer));
                                collarletsNPV += collarlets[m]->NPV();
                            }

                            if (std::fabs(collar.NPV() - collarletsNPV) > 1e-6) {
                                BOOST_FAIL("sum of collarlet NPVs does not equal collar NPV:\n"
                                           << "    length:       " << length << " years\n"
                                           << "    volatility:   " << io::volatility(vol) << "\n"
                                           << "    cap value:    " << collar.NPV()
                                           << " at strike floor: " << io::rate(floor_rate)
                                           << " at strike cap: " << io::rate(cap_rate) << "\n"
                                           << "    sum of collarlets value:  " << collarletsNPV
                                           << " at strike floor (first): "
                                           << io::rate(collarlets[0]->floorRates()[0])
                                           << " at strike cap (first): "
                                           << io::rate(collarlets[0]->capRates()[0]) << "\n");
                            }
                        }
                    }
                }
            }
        }
    } // pricer loop
    // remove circular refernce
    vars.hy.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
}


// Test inflation cap/floor parity, i.e. that cap-floor = swap, note that this
// is different from nominal because in nominal world standard cap/floors do
// not have the first optionlet.  This is because they set in advance so
// there is no point.  However, yoy inflation generally sets in arrears,
// (actually in arrears with a lag of a few months) thus the first optionlet
// is relevant.  Hence we can do a parity test without a special definition
// of the YoY cap/floor instrument.
void InflationCapFloorTest::testParity() {

    BOOST_TEST_MESSAGE("Testing yoy inflation cap/floor parity...");

    using namespace inflation_capfloor_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    // vol is low ...
    Rate strikes[] = { 0., 0.025, 0.029, 0.03, 0.031, 0.035, 0.07 };
    // yoy inflation vol is generally very low
    Volatility vols[] = { 0.001, 0.005, 0.010, 0.015, 0.020 };

    // cap-floor-swap parity is model-independent
    for (Size whichPricer = 0; whichPricer < 3; whichPricer++) {
        for (int& length : lengths) {
            for (double strike : strikes) {
                for (double vol : vols) {

                    Leg leg = vars.makeYoYLeg(vars.evaluationDate, length);

                    ext::shared_ptr<Instrument> cap = vars.makeYoYCapFloor(
                        YoYInflationCapFloor::Cap, leg, strike, vol, whichPricer);

                    ext::shared_ptr<Instrument> floor = vars.makeYoYCapFloor(
                        YoYInflationCapFloor::Floor, leg, strike, vol, whichPricer);

                    Date from = vars.nominalTS->referenceDate();
                    Date to = from + length * Years;
                    Schedule yoySchedule = MakeSchedule().from(from).to(to)
                    .withTenor(1*Years)
                    .withCalendar(UnitedKingdom())
                    .withConvention(Unadjusted)
                    .backwards()
                    ;

                    YearOnYearInflationSwap swap(Swap::Payer, 1000000.0,
                                                 yoySchedule, // fixed schedule, but same as yoy
                                                 strike, vars.dc, yoySchedule, vars.iir,
                                                 vars.observationLag,
                                                 0.0, // spread on index
                                                 vars.dc, UnitedKingdom());

                    Handle<YieldTermStructure> hTS(vars.nominalTS);
                    ext::shared_ptr<PricingEngine> sppe(new DiscountingSwapEngine(hTS));
                    swap.setPricingEngine(sppe);

                    // N.B. nominals are 10e6
                    if (std::fabs((cap->NPV()-floor->NPV()) - swap.NPV()) > 1.0e-6) {
                        BOOST_FAIL("put/call parity violated:\n"
                                   << "    length:      " << length << " years\n"
                                   << "    volatility:  " << io::volatility(vol) << "\n"
                                   << "    strike:      " << io::rate(strike) << "\n"
                                   << "    cap value:   " << cap->NPV() << "\n"
                                   << "    floor value: " << floor->NPV() << "\n"
                                   << "    swap value:  " << swap.NPV());
                    }
                }
            }
        }
    }
    // remove circular refernce
    vars.hy.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
}




void InflationCapFloorTest::testCachedValue() {

    BOOST_TEST_MESSAGE("Testing Black yoy inflation cap/floor price"
                       " against cached values...");

    using namespace inflation_capfloor_test;

    CommonVars vars;

    Size whichPricer = 0; // black

    Real K = 0.0295; // one centi-point is fair rate error i.e. < 1 cp
    Size j = 2;
    Leg leg = vars.makeYoYLeg(vars.evaluationDate,j);
    ext::shared_ptr<Instrument> cap
        = vars.makeYoYCapFloor(YoYInflationCapFloor::Cap,leg, K, 0.01, whichPricer);

    ext::shared_ptr<Instrument> floor
        = vars.makeYoYCapFloor(YoYInflationCapFloor::Floor,leg, K, 0.01, whichPricer);


    // close to atm prices
    Real cachedCapNPVblack   = 219.452;
    Real cachedFloorNPVblack =  314.641;
    // N.B. notionals are 10e6.
    BOOST_CHECK_MESSAGE(fabs(cap->NPV()-cachedCapNPVblack)<0.02,"yoy cap cached NPV wrong "
                        <<cap->NPV()<<" should be "<<cachedCapNPVblack<<" Black pricer"
                        <<" diff was "<<(fabs(cap->NPV()-cachedCapNPVblack)));
    BOOST_CHECK_MESSAGE(fabs(floor->NPV()-cachedFloorNPVblack)<0.02,"yoy floor cached NPV wrong "
                        <<floor->NPV()<<" should be "<<cachedFloorNPVblack<<" Black pricer"
                        <<" diff was "<<(fabs(floor->NPV()-cachedFloorNPVblack)));

    whichPricer = 1; // dd

    cap
    = vars.makeYoYCapFloor(YoYInflationCapFloor::Cap,leg, K, 0.01, whichPricer);

    floor
    = vars.makeYoYCapFloor(YoYInflationCapFloor::Floor,leg, K, 0.01, whichPricer);

    // close to atm prices
    Real cachedCapNPVdd   = 9114.61;
    Real cachedFloorNPVdd =  9209.8;
    // N.B. notionals are 10e6.
    BOOST_CHECK_MESSAGE(fabs(cap->NPV()-cachedCapNPVdd)<0.22,"yoy cap cached NPV wrong "
                        <<cap->NPV()<<" should be "<<cachedCapNPVdd<<" dd Black pricer"
                        <<" diff was "<<(fabs(cap->NPV()-cachedCapNPVdd)));
    BOOST_CHECK_MESSAGE(fabs(floor->NPV()-cachedFloorNPVdd)<0.22,"yoy floor cached NPV wrong "
                        <<floor->NPV()<<" should be "<<cachedFloorNPVdd<<" dd Black pricer"
                        <<" diff was "<<(fabs(floor->NPV()-cachedFloorNPVdd)));

    whichPricer = 2; // bachelier

    cap
    = vars.makeYoYCapFloor(YoYInflationCapFloor::Cap,leg, K, 0.01, whichPricer);

    floor
    = vars.makeYoYCapFloor(YoYInflationCapFloor::Floor,leg, K, 0.01, whichPricer);

    // close to atm prices
    Real cachedCapNPVbac   = 8852.4;
    Real cachedFloorNPVbac =  8947.59;
    // N.B. notionals are 10e6.
    BOOST_CHECK_MESSAGE(fabs(cap->NPV()-cachedCapNPVbac)<0.22,"yoy cap cached NPV wrong "
                        <<cap->NPV()<<" should be "<<cachedCapNPVbac<<" bac Black pricer"
                        <<" diff was "<<(fabs(cap->NPV()-cachedCapNPVbac)));
    BOOST_CHECK_MESSAGE(fabs(floor->NPV()-cachedFloorNPVbac)<0.22,"yoy floor cached NPV wrong "
                        <<floor->NPV()<<" should be "<<cachedFloorNPVbac<<" bac Black pricer"
                        <<" diff was "<<(fabs(floor->NPV()-cachedFloorNPVbac)));

    // remove circular refernce
    vars.hy.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
}


test_suite* InflationCapFloorTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Inflation (year-on-year) Cap and floor tests");
    suite->add(QUANTLIB_TEST_CASE(&InflationCapFloorTest::testConsistency));
    suite->add(QUANTLIB_TEST_CASE(&InflationCapFloorTest::testParity));
    suite->add(QUANTLIB_TEST_CASE(&InflationCapFloorTest::testCachedValue));
    return suite;
}


]]></document_content>
  </document>
  <document index="139">
    <source>inflationcapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflation_cap_floor_hpp
#define quantlib_test_inflation_cap_floor_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
 comment block of the corresponding class */

class InflationCapFloorTest {
public:
    static void testConsistency();
    static void testParity();
    static void testCachedValue();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="140">
    <source>inflationcapflooredcoupon.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2004, 2005, 2006, 2007, 2008 StatPro Italia srl
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "inflationcapfloor.hpp"
#include "utilities.hpp"
#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/math/matrix.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/quotes/simplequote.hpp>

#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/indexes/inflation/euhicp.hpp>
#include <ql/termstructures/inflation/piecewiseyoyinflationcurve.hpp>
#include <ql/cashflows/yoyinflationcoupon.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/schedule.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/volatility/inflation/yoyinflationoptionletvolatilitystructure.hpp>
#include <ql/cashflows/inflationcouponpricer.hpp>
#include <ql/pricingengines/blackformula.hpp>

#include "inflationcapflooredcoupon.hpp"


using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::fabs;

namespace inflation_capfloored_coupon_test {
    struct Datum {
        Date date;
        Rate rate;
    };

    template <class T, class U, class I>
    std::vector<ext::shared_ptr<BootstrapHelper<T> > > makeHelpers(
                        const std::vector<Datum>& iiData,
                        const ext::shared_ptr<I> &ii, const Period &observationLag,
                        const Calendar &calendar,
                        const BusinessDayConvention &bdc,
                        const DayCounter &dc,
                        const Handle<YieldTermStructure>& discountCurve) {

        std::vector<ext::shared_ptr<BootstrapHelper<T> > > instruments;
        for (Datum datum : iiData) {
            Date maturity = datum.date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(
                            new SimpleQuote(datum.rate/100.0)));
            ext::shared_ptr<BootstrapHelper<T> > anInstrument(new U(
                            quote, observationLag, maturity,
                            calendar, bdc, dc, ii, discountCurve));
            instruments.push_back(anInstrument);
        }

        return instruments;
    }


    struct CommonVars {
        // common data

        Size length;
        Date startDate;
        Real volatility;

        Frequency frequency;
        std::vector<Real> nominals;
        Calendar calendar;
        BusinessDayConvention convention;
        Natural fixingDays;
        Date evaluationDate;
        Natural settlementDays;
        Date settlement;
        Period observationLag;
        DayCounter dc;
        ext::shared_ptr<YYUKRPIr> iir;

        RelinkableHandle<YieldTermStructure> nominalTS;
        ext::shared_ptr<YoYInflationTermStructure> yoyTS;
        RelinkableHandle<YoYInflationTermStructure> hy;

        // cleanup

        SavedSettings backup;

        // setup
        CommonVars()
        : nominals(1,1000000) {
            // option variables
            frequency = Annual;
            // usual setup
            volatility = 0.01;
            length = 7;
            calendar = UnitedKingdom();
            convention = ModifiedFollowing;
            Date today(13, August, 2007);
            evaluationDate = calendar.adjust(today);
            Settings::instance().evaluationDate() = evaluationDate;
            settlementDays = 0;
            fixingDays = 0;
            settlement = calendar.advance(today,settlementDays,Days);
            startDate = settlement;
            dc = Thirty360(Thirty360::BondBasis);

            // yoy index
            //      fixing data
            Date from(1, January, 2005);
            Date to(13, August, 2007);
            Schedule rpiSchedule = MakeSchedule().from(from).to(to)
            .withTenor(1*Months)
            .withCalendar(UnitedKingdom())
            .withConvention(ModifiedFollowing);
            Real fixData[] = { 189.9, 189.9, 189.6, 190.5, 191.6, 192.0,
                192.2, 192.2, 192.6, 193.1, 193.3, 193.6,
                194.1, 193.4, 194.2, 195.0, 196.5, 197.7,
                198.5, 198.5, 199.2, 200.1, 200.4, 201.1,
                202.7, 201.6, 203.1, 204.4, 205.4, 206.2,
                207.3, -999.0, -999 };
            // link from yoy index to yoy TS
            bool interp = false;
            iir = ext::make_shared<YYUKRPIr>(interp, hy);
            for (Size i=0; i<rpiSchedule.size();i++) {
                iir->addFixing(rpiSchedule[i], fixData[i]);
            }

            ext::shared_ptr<YieldTermStructure> nominalFF(
                        new FlatForward(evaluationDate, 0.05, ActualActual(ActualActual::ISDA)));
            nominalTS.linkTo(nominalFF);

            // now build the YoY inflation curve
            Period observationLag = Period(2,Months);

            std::vector<Datum> yyData = {
                { Date(13, August, 2008), 2.95 },
                { Date(13, August, 2009), 2.95 },
                { Date(13, August, 2010), 2.93 },
                { Date(15, August, 2011), 2.955 },
                { Date(13, August, 2012), 2.945 },
                { Date(13, August, 2013), 2.985 },
                { Date(13, August, 2014), 3.01 },
                { Date(13, August, 2015), 3.035 },
                { Date(13, August, 2016), 3.055 },  // note that
                { Date(13, August, 2017), 3.075 },  // some dates will be on
                { Date(13, August, 2019), 3.105 },  // holidays but the payment
                { Date(15, August, 2022), 3.135 },  // calendar will roll them
                { Date(13, August, 2027), 3.155 },
                { Date(13, August, 2032), 3.145 },
                { Date(13, August, 2037), 3.145 }
            };

            // now build the helpers ...
            std::vector<ext::shared_ptr<BootstrapHelper<YoYInflationTermStructure> > > helpers =
            makeHelpers<YoYInflationTermStructure,YearOnYearInflationSwapHelper,
            YoYInflationIndex>(yyData, iir,
                               observationLag,
                               calendar, convention, dc,
                               Handle<YieldTermStructure>(nominalTS));

            Rate baseYYRate = yyData[0].rate/100.0;
            ext::shared_ptr<PiecewiseYoYInflationCurve<Linear> > pYYTS(
                            new PiecewiseYoYInflationCurve<Linear>(
                                evaluationDate, calendar, dc, observationLag,
                                iir->frequency(),iir->interpolated(), baseYYRate,
                                helpers));
            pYYTS->recalculate();
            yoyTS = ext::dynamic_pointer_cast<YoYInflationTermStructure>(pYYTS);


            // make sure that the index has the latest yoy term structure
            hy.linkTo(pYYTS);
        }

        // utilities
        Leg makeYoYLeg(const Date& startDate,
                       Integer length,
                       const Rate gearing = 1.0,
                       const Rate spread = 0.0) const {
            ext::shared_ptr<YoYInflationIndex> ii =
            ext::dynamic_pointer_cast<YoYInflationIndex>(iir);
            Date endDate = calendar.advance(startDate,length*Years,Unadjusted);
            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              Unadjusted,Unadjusted,// ref periods & acc periods
                              DateGeneration::Forward, false);

            std::vector<Rate> gearingVector(length, gearing);
            std::vector<Spread> spreadVector(length, spread);

            Leg yoyLeg = yoyInflationLeg(schedule, calendar, ii, observationLag)
            .withNotionals(nominals)
            .withPaymentDayCounter(dc)
            .withGearings(gearingVector)
            .withSpreads(spreadVector)
            .withPaymentAdjustment(convention);

            return yoyLeg;
        }

        Leg makeFixedLeg(const Date& startDate, Integer length) const {

            Date endDate = calendar.advance(startDate, length, Years,
                                            convention);
            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              convention, convention,
                              DateGeneration::Forward, false);
            std::vector<Rate> coupons(length, 0.0);
            return FixedRateLeg(schedule)
            .withNotionals(nominals)
            .withCouponRates(coupons, dc);
        }


        Leg makeYoYCapFlooredLeg(Size which,
                                 const Date& startDate,
                                 Integer length,
                                 const std::vector<Rate>& caps,
                                 const std::vector<Rate>& floors,
                                 Volatility volatility,
                                 const Rate gearing = 1.0,
                                 const Rate spread = 0.0) const {

            Handle<YoYOptionletVolatilitySurface>
            vol(ext::make_shared<ConstantYoYOptionletVolatility>(
                            volatility,
                                settlementDays,
                                calendar,
                                convention,
                                dc,
                                observationLag,
                                frequency,
                                iir->interpolated()));

            ext::shared_ptr<YoYInflationCouponPricer> pricer;
            switch (which) {
                case 0:
                    pricer = ext::shared_ptr<YoYInflationCouponPricer>(
                            new BlackYoYInflationCouponPricer(vol, nominalTS));
                    break;
                case 1:
                    pricer = ext::shared_ptr<YoYInflationCouponPricer>(
                            new UnitDisplacedBlackYoYInflationCouponPricer(vol, nominalTS));
                    break;
                case 2:
                    pricer = ext::shared_ptr<YoYInflationCouponPricer>(
                            new BachelierYoYInflationCouponPricer(vol, nominalTS));
                    break;
                default:
                    BOOST_FAIL("unknown coupon pricer request: which = "<<which
                               <<"should be 0=Black,1=DD,2=Bachelier");
                    break;
            }


            std::vector<Rate> gearingVector(length, gearing);
            std::vector<Spread> spreadVector(length, spread);

            ext::shared_ptr<YoYInflationIndex> ii =
            ext::dynamic_pointer_cast<YoYInflationIndex>(iir);
            Date endDate = calendar.advance(startDate,length*Years,Unadjusted);
            Schedule schedule(startDate, endDate, Period(frequency), calendar,
                              Unadjusted,Unadjusted,// ref periods & acc periods
                              DateGeneration::Forward, false);

            Leg yoyLeg =  yoyInflationLeg(schedule, calendar, ii, observationLag)
            .withNotionals(nominals)
            .withPaymentDayCounter(dc)
            .withPaymentAdjustment(convention)
            .withGearings(gearingVector)
            .withSpreads(spreadVector)
            .withCaps(caps)
            .withFloors(floors);

            setCouponPricer(yoyLeg, pricer);

            return yoyLeg;
        }


        ext::shared_ptr<PricingEngine> makeEngine(Volatility volatility, Size which) const {

            ext::shared_ptr<YoYInflationIndex>
            yyii = ext::dynamic_pointer_cast<YoYInflationIndex>(iir);

            Handle<YoYOptionletVolatilitySurface>
            vol(ext::make_shared<ConstantYoYOptionletVolatility>(
                    volatility,
                            settlementDays,
                            calendar,
                            convention,
                            dc,
                            observationLag,
                            frequency,
                            iir->interpolated()));


            switch (which) {
                case 0:
                    return ext::shared_ptr<PricingEngine>(
                            new YoYInflationBlackCapFloorEngine(iir, vol, nominalTS));
                    break;
                case 1:
                    return ext::shared_ptr<PricingEngine>(
                            new YoYInflationUnitDisplacedBlackCapFloorEngine(iir, vol, nominalTS));
                    break;
                case 2:
                    return ext::shared_ptr<PricingEngine>(
                            new YoYInflationBachelierCapFloorEngine(iir, vol, nominalTS));
                    break;
                default:
                    BOOST_FAIL("unknown engine request: which = "<<which
                               <<"should be 0=Black,1=DD,2=Bachelier");
                    break;
            }
            // make compiler happy
            QL_FAIL("never get here - no engine resolution");
        }


        ext::shared_ptr<YoYInflationCapFloor> makeYoYCapFloor(YoYInflationCapFloor::Type type,
                                                              const Leg& leg,
                                                              Rate strike,
                                                              Volatility volatility,
                                                              Size which) const {
            ext::shared_ptr<YoYInflationCapFloor> result;
            switch (type) {
                case YoYInflationCapFloor::Cap:
                    result = ext::shared_ptr<YoYInflationCapFloor>(
                                new YoYInflationCap(leg, std::vector<Rate>(1, strike)));
                    break;
                case YoYInflationCapFloor::Floor:
                    result = ext::shared_ptr<YoYInflationCapFloor>(
                                new YoYInflationFloor(leg, std::vector<Rate>(1, strike)));
                    break;
                default:
                    QL_FAIL("unknown YoYInflation cap/floor type");
            }
            result->setPricingEngine(makeEngine(volatility, which));
            return result;
        }
    };

}



void InflationCapFlooredCouponTest::testDecomposition() {

    BOOST_TEST_MESSAGE("Testing collared coupon against its decomposition...");

    using namespace inflation_capfloored_coupon_test;

    CommonVars vars;

    Real tolerance = 1e-10;
    Real npvVanilla,npvCappedLeg,npvFlooredLeg,npvCollaredLeg,npvCap,npvFloor,npvCollar;
    Real error;
    Rate floorstrike = 0.05;
    Rate capstrike = 0.10;
    std::vector<Rate> caps(vars.length,capstrike);
    std::vector<Rate> caps0 = std::vector<Rate>();
    std::vector<Rate> floors(vars.length,floorstrike);
    std::vector<Rate> floors0 = std::vector<Rate>();
    Rate gearing_p = Rate(0.5);
    auto spread_p = Spread(0.002);
    Rate gearing_n = Rate(-1.5);
    auto spread_n = Spread(0.12);
    // fixed leg with zero rate
    Leg fixedLeg  =
    vars.makeFixedLeg(vars.startDate,vars.length);
    // floating leg with gearing=1 and spread=0
    Leg floatLeg  =
    vars.makeYoYLeg(vars.startDate,vars.length);
    // floating leg with positive gearing (gearing_p) and spread<>0
    Leg floatLeg_p =
    vars.makeYoYLeg(vars.startDate,vars.length,gearing_p,spread_p);
    // floating leg with negative gearing (gearing_n) and spread<>0
    Leg floatLeg_n =
    vars.makeYoYLeg(vars.startDate,vars.length,gearing_n,spread_n);
    // Swap with null fixed leg and floating leg with gearing=1 and spread=0
    Swap vanillaLeg(fixedLeg,floatLeg);
    // Swap with null fixed leg and floating leg with positive gearing and spread<>0
    Swap vanillaLeg_p(fixedLeg,floatLeg_p);
    // Swap with null fixed leg and floating leg with negative gearing and spread<>0
    Swap vanillaLeg_n(fixedLeg,floatLeg_n);

    ext::shared_ptr<PricingEngine> engine(
            new DiscountingSwapEngine(vars.nominalTS));

    vanillaLeg.setPricingEngine(engine);    // here use the autoset feature
    vanillaLeg_p.setPricingEngine(engine);
    vanillaLeg_n.setPricingEngine(engine);

    // CAPPED coupon - Decomposition of payoff
    // Payoff = Nom * Min(rate,strike) * accrualperiod =
    // = Nom * [rate + Min(0,strike-rate)] * accrualperiod =
    // = Nom * rate * accrualperiod - Nom * Max(rate-strike,0) * accrualperiod =
    // = VanillaFloatingLeg - Call
    //

    Size whichPricer = 0;

    // Case gearing = 1 and spread = 0
    Leg cappedLeg =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,
                           caps,floors0,vars.volatility);
    Swap capLeg(fixedLeg,cappedLeg);
    capLeg.setPricingEngine(engine);
    YoYInflationCap cap(floatLeg, std::vector<Rate>(1, capstrike));
    cap.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg.NPV();
    npvCappedLeg = capLeg.NPV();
    npvCap = cap.NPV();
    error = std::abs(npvCappedLeg - (npvVanilla-npvCap));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Capped Leg: gearing=1, spread=0%, strike=" << capstrike*100 <<
                    "%\n" <<
                    "  Capped Floating Leg NPV: " << npvCappedLeg << "\n" <<
                    "  Floating Leg NPV - Cap NPV: " << npvVanilla - npvCap << "\n" <<
                    "  Diff: " << error );
    }

    // gearing = 1 and spread = 0
    // FLOORED coupon - Decomposition of payoff
    // Payoff = Nom * Max(rate,strike) * accrualperiod =
    // = Nom * [rate + Max(0,strike-rate)] * accrualperiod =
    // = Nom * rate * accrualperiod + Nom * Max(strike-rate,0) * accrualperiod =
    // = VanillaFloatingLeg + Put
    //

    Leg flooredLeg =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,
                           caps0,floors,vars.volatility);
    Swap floorLeg(fixedLeg,flooredLeg);
    floorLeg.setPricingEngine(engine);
    YoYInflationFloor floor(floatLeg, std::vector<Rate>(1, floorstrike));
    floor.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvFlooredLeg = floorLeg.NPV();
    npvFloor = floor.NPV();
    error = std::abs(npvFlooredLeg-(npvVanilla + npvFloor));
    if (error>tolerance) {
        BOOST_ERROR("YoY Floored Leg: gearing=1, spread=0%, strike=" << floorstrike *100 <<
                    "%\n" <<
                    "  Floored Floating Leg NPV: " << npvFlooredLeg << "\n" <<
                    "  Floating Leg NPV + Floor NPV: " << npvVanilla + npvFloor << "\n" <<
                    "  Diff: " << error );
    }

    // gearing = 1 and spread = 0
    // COLLARED coupon - Decomposition of payoff
    // Payoff = Nom * Min(strikem,Max(rate,strikeM)) * accrualperiod =
    // = VanillaFloatingLeg - Collar
    //

    Leg collaredLeg =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,
                           caps,floors,vars.volatility);
    Swap collarLeg(fixedLeg,collaredLeg);
    collarLeg.setPricingEngine(engine);
    YoYInflationCollar collar(floatLeg,
                  std::vector<Rate>(1, capstrike),
                  std::vector<Rate>(1, floorstrike));
    collar.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvCollaredLeg = collarLeg.NPV();
    npvCollar = collar.NPV();
    error = std::abs(npvCollaredLeg -(npvVanilla - npvCollar));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Collared Leg: gearing=1, spread=0%, strike=" <<
                    floorstrike*100 << "% and " << capstrike*100 << "%\n" <<
                    "  Collared Floating Leg NPV: " << npvCollaredLeg << "\n" <<
                    "  Floating Leg NPV - Collar NPV: " << npvVanilla - npvCollar << "\n" <<
                    "  Diff: " << error );
    }

    // gearing = a and spread = b
    // CAPPED coupon - Decomposition of payoff
    // Payoff
    // = Nom * Min(a*rate+b,strike) * accrualperiod =
    // = Nom * [a*rate+b + Min(0,strike-a*rate-b)] * accrualperiod =
    // = Nom * a*rate+b * accrualperiod + Nom * Min(strike-b-a*rate,0) * accrualperiod
    // --> If a>0 (assuming positive effective strike):
    // Payoff = VanillaFloatingLeg - Call(a*rate+b,strike)
    // --> If a<0 (assuming positive effective strike):
    // Payoff = VanillaFloatingLeg + Nom * Min(strike-b+|a|*rate+,0) * accrualperiod =
    // = VanillaFloatingLeg + Put(|a|*rate+b,strike)
    //

    // Positive gearing
    Leg cappedLeg_p =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,caps,floors0,
                           vars.volatility,gearing_p,spread_p);
    Swap capLeg_p(fixedLeg,cappedLeg_p);
    capLeg_p.setPricingEngine(engine);
    YoYInflationCap cap_p(floatLeg_p,std::vector<Rate>(1,capstrike));
    cap_p.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg_p.NPV();
    npvCappedLeg = capLeg_p.NPV();
    npvCap = cap_p.NPV();
    error = std::abs(npvCappedLeg - (npvVanilla-npvCap));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Capped Leg: gearing=" << gearing_p << ", " <<
                    "spread= " << spread_p *100 <<
                    "%, strike=" << capstrike*100  << "%, " <<
                    "effective strike= " << (capstrike-spread_p)/gearing_p*100 <<
                    "%\n" <<
                    "  Capped Floating Leg NPV: " << npvCappedLeg << "\n" <<
                    "  Vanilla Leg NPV: " << npvVanilla << "\n" <<
                    "  Cap NPV: " << npvCap << "\n" <<
                    "  Floating Leg NPV - Cap NPV: " << npvVanilla - npvCap << "\n" <<
                    "  Diff: " << error );
    }

    // Negative gearing
    Leg cappedLeg_n =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,caps,floors0,
                           vars.volatility,gearing_n,spread_n);
    Swap capLeg_n(fixedLeg,cappedLeg_n);
    capLeg_n.setPricingEngine(engine);
    YoYInflationFloor floor_n(floatLeg,std::vector<Rate>(1,(capstrike-spread_n)/gearing_n));
    floor_n.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg_n.NPV();
    npvCappedLeg = capLeg_n.NPV();
    npvFloor = floor_n.NPV();
    error = std::abs(npvCappedLeg - (npvVanilla+ gearing_n*npvFloor));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Capped Leg: gearing=" << gearing_n << ", " <<
                    "spread= " << spread_n *100 <<
                    "%, strike=" << capstrike*100  << "%, " <<
                    "effective strike= " << (capstrike-spread_n)/gearing_n*100 <<
                    "%\n" <<
                    "  Capped Floating Leg NPV: " << npvCappedLeg << "\n" <<
                    "  npv Vanilla: " << npvVanilla << "\n" <<
                    "  npvFloor: " << npvFloor << "\n" <<
                    "  Floating Leg NPV - Cap NPV: " << npvVanilla + gearing_n*npvFloor << "\n" <<
                    "  Diff: " << error );
    }

    // gearing = a and spread = b
    // FLOORED coupon - Decomposition of payoff
    // Payoff
    // = Nom * Max(a*rate+b,strike) * accrualperiod =
    // = Nom * [a*rate+b + Max(0,strike-a*rate-b)] * accrualperiod =
    // = Nom * a*rate+b * accrualperiod + Nom * Max(strike-b-a*rate,0) * accrualperiod
    // --> If a>0 (assuming positive effective strike):
    // Payoff = VanillaFloatingLeg + Put(a*rate+b,strike)
    // --> If a<0 (assuming positive effective strike):
    // Payoff = VanillaFloatingLeg + Nom * Max(strike-b+|a|*rate+,0) * accrualperiod =
    // = VanillaFloatingLeg - Call(|a|*rate+b,strike)
    //

    // Positive gearing
    Leg flooredLeg_p1 =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,caps0,floors,
                           vars.volatility,gearing_p,spread_p);
    Swap floorLeg_p1(fixedLeg,flooredLeg_p1);
    floorLeg_p1.setPricingEngine(engine);
    YoYInflationFloor floor_p1(floatLeg_p,std::vector<Rate>(1,floorstrike));
    floor_p1.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg_p.NPV();
    npvFlooredLeg = floorLeg_p1.NPV();
    npvFloor = floor_p1.NPV();
    error = std::abs(npvFlooredLeg - (npvVanilla+npvFloor));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Floored Leg: gearing=" << gearing_p << ", "
                    << "spread= " << spread_p *100<< "%, strike=" << floorstrike *100 << "%, "
                    << "effective strike= " << (floorstrike-spread_p)/gearing_p*100
                    << "%\n" <<
                    "  Floored Floating Leg NPV: "    << npvFlooredLeg
                    << "\n" <<
                    "  Floating Leg NPV + Floor NPV: " << npvVanilla + npvFloor
                    << "\n" <<
                    "  Diff: " << error );
    }
    // Negative gearing
    Leg flooredLeg_n =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,caps0,floors,
                           vars.volatility,gearing_n,spread_n);
    Swap floorLeg_n(fixedLeg,flooredLeg_n);
    floorLeg_n.setPricingEngine(engine);
    YoYInflationCap cap_n(floatLeg,std::vector<Rate>(1,(floorstrike-spread_n)/gearing_n));
    cap_n.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg_n.NPV();
    npvFlooredLeg = floorLeg_n.NPV();
    npvCap = cap_n.NPV();
    error = std::abs(npvFlooredLeg - (npvVanilla - gearing_n*npvCap));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Capped Leg: gearing=" << gearing_n << ", " <<
                    "spread= " << spread_n *100 <<
                    "%, strike=" << floorstrike*100  << "%, " <<
                    "effective strike= " << (floorstrike-spread_n)/gearing_n*100 <<
                    "%\n" <<
                    "  Capped Floating Leg NPV: " << npvFlooredLeg << "\n" <<
                    "  Floating Leg NPV - Cap NPV: " << npvVanilla - gearing_n*npvCap << "\n" <<
                    "  Diff: " << error );
    }
    // gearing = a and spread = b
    // COLLARED coupon - Decomposition of payoff
    // Payoff = Nom * Min(caprate,Max(a*rate+b,floorrate)) * accrualperiod
    // --> If a>0 (assuming positive effective strike):
    // Payoff = VanillaFloatingLeg - Collar(a*rate+b, floorrate, caprate)
    // --> If a<0 (assuming positive effective strike):
    // Payoff = VanillaFloatingLeg + Collar(|a|*rate+b, caprate, floorrate)
    //
    // Positive gearing
    Leg collaredLeg_p =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,caps,floors,
                           vars.volatility,gearing_p,spread_p);
    Swap collarLeg_p1(fixedLeg,collaredLeg_p);
    collarLeg_p1.setPricingEngine(engine);
    YoYInflationCollar collar_p(floatLeg_p,
                    std::vector<Rate>(1,capstrike),
                    std::vector<Rate>(1,floorstrike));
    collar_p.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg_p.NPV();
    npvCollaredLeg = collarLeg_p1.NPV();
    npvCollar = collar_p.NPV();
    error = std::abs(npvCollaredLeg - (npvVanilla - npvCollar));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Collared Leg: gearing=" << gearing_p << ", "
                    << "spread= " << spread_p*100 << "%, strike="
                    << floorstrike*100 << "% and " << capstrike*100
                    << "%, "
                    << "effective strike=" << (floorstrike-spread_p)/gearing_p*100
                    <<  "% and " << (capstrike-spread_p)/gearing_p*100
                    << "%\n" <<
                    "  Collared Floating Leg NPV: "    << npvCollaredLeg
                    << "\n" <<
                    "  Floating Leg NPV - Collar NPV: " << npvVanilla - npvCollar
                    << "\n" <<
                    "  Diff: " << error );
    }
    // Negative gearing
    Leg collaredLeg_n =
    vars.makeYoYCapFlooredLeg(whichPricer,vars.startDate,vars.length,caps,floors,
                           vars.volatility,gearing_n,spread_n);
    Swap collarLeg_n1(fixedLeg,collaredLeg_n);
    collarLeg_n1.setPricingEngine(engine);
    YoYInflationCollar collar_n(floatLeg,
                    std::vector<Rate>(1,(floorstrike-spread_n)/gearing_n),
                    std::vector<Rate>(1,(capstrike-spread_n)/gearing_n));
    collar_n.setPricingEngine(vars.makeEngine(vars.volatility,whichPricer));
    npvVanilla = vanillaLeg_n.NPV();
    npvCollaredLeg = collarLeg_n1.NPV();
    npvCollar = collar_n.NPV();
    error = std::abs(npvCollaredLeg - (npvVanilla - gearing_n*npvCollar));
    if (error>tolerance) {
        BOOST_ERROR("\nYoY Collared Leg: gearing=" << gearing_n << ", "
                    << "spread= " << spread_n*100 << "%, strike="
                    << floorstrike*100 << "% and " << capstrike*100
                    << "%, "
                    << "effective strike=" << (floorstrike-spread_n)/gearing_n*100
                    <<  "% and " << (capstrike-spread_n)/gearing_n*100
                    << "%\n" <<
                    "  Collared Floating Leg NPV: "    << npvCollaredLeg
                    << "\n" <<
                    "  Floating Leg NPV - Collar NPV: " << npvVanilla - gearing_n*npvCollar
                    << "\n" <<
                    "  Diff: " << error );
    }
    // remove circular refernce
    vars.hy.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
}


void InflationCapFlooredCouponTest::testInstrumentEquality() {

    BOOST_TEST_MESSAGE("Testing inflation capped/floored coupon against"
                       " inflation capfloor instrument...");

    using namespace inflation_capfloored_coupon_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 3, 5, 7, 10, 15, 20 };
    // vol is low ...
    Rate strikes[] = { 0.01, 0.025, 0.029, 0.03, 0.031, 0.035, 0.07 };
    // yoy inflation vol is generally very low
    Volatility vols[] = { 0.001, 0.005, 0.010, 0.015, 0.020 };

    // this is model independent
    // capped coupon = fwd - cap, and fwd = swap(0)
    // floored coupon = fwd + floor
    for (Size whichPricer = 0; whichPricer < 3; whichPricer++) {
        for (int& length : lengths) {
            for (double& strike : strikes) {
                for (double vol : vols) {

                    Leg leg = vars.makeYoYLeg(vars.evaluationDate, length);

                    ext::shared_ptr<Instrument> cap = vars.makeYoYCapFloor(
                        YoYInflationCapFloor::Cap, leg, strike, vol, whichPricer);

                    ext::shared_ptr<Instrument> floor = vars.makeYoYCapFloor(
                        YoYInflationCapFloor::Floor, leg, strike, vol, whichPricer);

                    Date from = vars.nominalTS->referenceDate();
                    Date to = from + length * Years;
                    Schedule yoySchedule = MakeSchedule().from(from).to(to)
                    .withTenor(1*Years)
                    .withCalendar(UnitedKingdom())
                    .withConvention(Unadjusted)
                    .backwards()
                    ;

                    YearOnYearInflationSwap swap(Swap::Payer,
                                                 1000000.0,
                                                 yoySchedule,//fixed schedule, but same as yoy
                                                 0.0,//strikes[j],
                                                 vars.dc,
                                                 yoySchedule,
                                                 vars.iir,
                                                 vars.observationLag,
                                                 0.0,        //spread on index
                                                 vars.dc,
                                                 UnitedKingdom());

                    Handle<YieldTermStructure> hTS(vars.nominalTS);
                    ext::shared_ptr<PricingEngine> sppe(new DiscountingSwapEngine(hTS));
                    swap.setPricingEngine(sppe);

                    Leg leg2 = vars.makeYoYCapFlooredLeg(whichPricer, from, length,
                                                         std::vector<Rate>(length, strike), // cap
                                                         std::vector<Rate>(),               // floor
                                                         vol,
                                                         1.0,  // gearing
                                                         0.0); // spread

                    Leg leg3 = vars.makeYoYCapFlooredLeg(whichPricer, from, length,
                                                         std::vector<Rate>(),               // cap
                                                         std::vector<Rate>(length, strike), // floor
                                                         vol,
                                                         1.0,  // gearing
                                                         0.0); // spread

                    // N.B. nominals are 10e6
                    Real capped = CashFlows::npv(leg2,(**vars.nominalTS),false);
                    if ( fabs(capped - (swap.NPV() - cap->NPV())) > 1.0e-6) {
                        BOOST_FAIL("capped coupon != swap(0) - cap:\n"
                                   << "    length:      " << length << " years\n"
                                   << "    volatility:  " << io::volatility(vol) << "\n"
                                   << "    strike:      " << io::rate(strike) << "\n"
                                   << "    cap value:   " << cap->NPV() << "\n"
                                   << "    swap value:  " << swap.NPV() << "\n"
                                   << "   capped coupon " << capped);
                    }


                    // N.B. nominals are 10e6
                    Real floored = CashFlows::npv(leg3,(**vars.nominalTS),false);
                    if ( fabs(floored - (swap.NPV() + floor->NPV())) > 1.0e-6) {
                        BOOST_FAIL("floored coupon != swap(0) + floor :\n"
                                   << "    length:      " << length << " years\n"
                                   << "    volatility:  " << io::volatility(vol) << "\n"
                                   << "    strike:      " << io::rate(strike) << "\n"
                                   << "    floor value: " << floor->NPV() << "\n"
                                   << "    swap value:  " << swap.NPV() << "\n"
                                   << "  floored coupon " << floored);
                    }
                }
            }
        }
    }
    // remove circular refernce
    vars.hy.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
}




test_suite* InflationCapFlooredCouponTest::suite() {
    auto* suite = BOOST_TEST_SUITE("YoY inflation capped and floored coupon tests");
    suite->add(QUANTLIB_TEST_CASE(&InflationCapFlooredCouponTest::testDecomposition));
    suite->add(QUANTLIB_TEST_CASE(&InflationCapFlooredCouponTest::testInstrumentEquality));
    return suite;
}

]]></document_content>
  </document>
  <document index="141">
    <source>inflationcapflooredcoupon.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2009 Chris Kenyon


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflation_cap_floored_coupon_hpp
#define quantlib_test_inflation_cap_floored_coupon_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
 comment block of the corresponding class */

class InflationCapFlooredCouponTest {
public:
    static void testDecomposition();
    static void testInstrumentEquality();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="142">
    <source>inflationcpibond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon
 Copyright (C) 2012 StatPro Italia srl
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "inflationcpibond.hpp"
#include "utilities.hpp"
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/indexes/ibor/gbplibor.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/inflation/piecewisezeroinflationcurve.hpp>
#include <ql/cashflows/indexedcashflow.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/cpicouponpricer.hpp>
#include <ql/instruments/cpiswap.hpp>
#include <ql/instruments/bonds/cpibond.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#include <iostream>

namespace inflation_cpi_bond_test {

    struct Datum {
        Date date;
        Rate rate;
    };

    typedef BootstrapHelper<ZeroInflationTermStructure> Helper;

    std::vector<ext::shared_ptr<Helper> > makeHelpers(
        const std::vector<Datum>& iiData,
        const ext::shared_ptr<ZeroInflationIndex>& ii,
        const Period& observationLag,
        const Calendar& calendar,
        const BusinessDayConvention& bdc,
        const DayCounter& dc,
        const Handle<YieldTermStructure>& yTS) {

        std::vector<ext::shared_ptr<Helper> > instruments;
        for (Datum datum : iiData) {
            Date maturity = datum.date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(
                                new SimpleQuote(datum.rate/100.0)));
            ext::shared_ptr<Helper> h(new ZeroCouponInflationSwapHelper(
                quote, observationLag, maturity, calendar, bdc, dc, ii, CPI::AsIndex, yTS));
            instruments.push_back(h);
        }
        return instruments;
    }


    struct CommonVars {

        Calendar calendar;
        BusinessDayConvention convention;
        Date evaluationDate;
        Period observationLag;
        DayCounter dayCounter;

        ext::shared_ptr<UKRPI> ii;

        RelinkableHandle<YieldTermStructure> yTS;
        RelinkableHandle<ZeroInflationTermStructure> cpiTS;

        // cleanup

        SavedSettings backup;
        IndexHistoryCleaner cleaner;

        // setup
        CommonVars() {
            // usual setup
            calendar = UnitedKingdom();
            convention = ModifiedFollowing;
            Date today(25, November, 2009);
            evaluationDate = calendar.adjust(today);
            Settings::instance().evaluationDate() = evaluationDate;
            dayCounter = ActualActual(ActualActual::ISDA);

            Date from(20, July, 2007);
            Date to(20, November, 2009);
            Schedule rpiSchedule =
                MakeSchedule().from(from).to(to)
                .withTenor(1*Months)
                .withCalendar(UnitedKingdom())
                .withConvention(ModifiedFollowing);

            bool interp = false;
            ii = ext::make_shared<UKRPI>(interp, cpiTS);

            Real fixData[] = {
                206.1, 207.3, 208.0, 208.9, 209.7, 210.9,
                209.8, 211.4, 212.1, 214.0, 215.1, 216.8,
                216.5, 217.2, 218.4, 217.7, 216,
                212.9, 210.1, 211.4, 211.3, 211.5,
                212.8, 213.4, 213.4, 213.4, 214.4
            };
            for (Size i=0; i<LENGTH(fixData); ++i) {
                ii->addFixing(rpiSchedule[i], fixData[i]);
            }

            yTS.linkTo(ext::shared_ptr<YieldTermStructure>(
                          new FlatForward(evaluationDate, 0.05, dayCounter)));

            // now build the zero inflation curve
            observationLag = Period(2,Months);

            std::vector<Datum> zciisData = {
                { Date(25, November, 2010), 3.0495 },
                { Date(25, November, 2011), 2.93 },
                { Date(26, November, 2012), 2.9795 },
                { Date(25, November, 2013), 3.029 },
                { Date(25, November, 2014), 3.1425 },
                { Date(25, November, 2015), 3.211 },
                { Date(25, November, 2016), 3.2675 },
                { Date(25, November, 2017), 3.3625 },
                { Date(25, November, 2018), 3.405 },
                { Date(25, November, 2019), 3.48 },
                { Date(25, November, 2021), 3.576 },
                { Date(25, November, 2024), 3.649 },
                { Date(26, November, 2029), 3.751 },
                { Date(27, November, 2034), 3.77225 },
                { Date(25, November, 2039), 3.77 },
                { Date(25, November, 2049), 3.734 },
                { Date(25, November, 2059), 3.714 },
            };

            std::vector<ext::shared_ptr<Helper> > helpers =
                makeHelpers(zciisData, ii,
                            observationLag, calendar, convention, dayCounter, yTS);

            Rate baseZeroRate = zciisData[0].rate/100.0;
            cpiTS.linkTo(ext::shared_ptr<ZeroInflationTermStructure>(
                  new PiecewiseZeroInflationCurve<Linear>(
                         evaluationDate, calendar, dayCounter, observationLag,
                         ii->frequency(),ii->interpolated(), baseZeroRate,
                         helpers)));
        }

        // teardown
        ~CommonVars() {
            // break circular references and allow curves to be destroyed
            cpiTS.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
        }
    };

}


void InflationCPIBondTest::testCleanPrice() {
    IndexManager::instance().clearHistories();

    using namespace inflation_cpi_bond_test;
  
    CommonVars common;

    Real notional = 1000000.0;
    std::vector<Rate> fixedRates(1, 0.1);
    DayCounter fixedDayCount = Actual365Fixed();
    BusinessDayConvention fixedPaymentConvention = ModifiedFollowing;
    Calendar fixedPaymentCalendar = UnitedKingdom();
    ext::shared_ptr<ZeroInflationIndex> fixedIndex = common.ii;
    Period contractObservationLag = Period(3,Months);
    CPI::InterpolationType observationInterpolation = CPI::Flat;
    Natural settlementDays = 3;
    bool growthOnly = true;

    Real baseCPI = 206.1;
    // set the schedules
    Date startDate(2, October, 2007);
    Date endDate(2, October, 2052);
    Schedule fixedSchedule =
        MakeSchedule().from(startDate).to(endDate)
                      .withTenor(Period(6,Months))
                      .withCalendar(UnitedKingdom())
                      .withConvention(Unadjusted)
                      .backwards();

    CPIBond bond(settlementDays, notional, growthOnly,
                 baseCPI, contractObservationLag, fixedIndex,
                 observationInterpolation, fixedSchedule,
                 fixedRates, fixedDayCount, fixedPaymentConvention);

    ext::shared_ptr<DiscountingBondEngine> engine(
                                 new DiscountingBondEngine(common.yTS));
    bond.setPricingEngine(engine);

    Real storedPrice = 383.01816406;
    Real calculated = bond.cleanPrice();
    Real tolerance = 1.0e-8;
    if (std::fabs(calculated-storedPrice) > tolerance) {
        BOOST_FAIL("failed to reproduce expected CPI-bond clean price"
                   << std::fixed << std::setprecision(12)
                   << "\n  expected:   " << storedPrice
                   << "\n  calculated: " << calculated);
    }
}


test_suite* InflationCPIBondTest::suite() {
    auto* suite = BOOST_TEST_SUITE("CPI bond tests");

    suite->add(QUANTLIB_TEST_CASE(&InflationCPIBondTest::testCleanPrice));

    return suite;
}

]]></document_content>
  </document>
  <document index="143">
    <source>inflationcpibond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 StatPro Italia srl
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflationcpibond_hpp
#define quantlib_test_inflationcpibond_hpp

#include <boost/test/unit_test.hpp>

class InflationCPIBondTest {
  public:
    static void testCleanPrice();
    static boost::unit_test_framework::test_suite* suite();
};



#endif
]]></document_content>
  </document>
  <document index="144">
    <source>inflationcpicapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/types.hpp>
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/termstructures/bootstraphelper.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/indexes/ibor/gbplibor.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/inflation/piecewisezeroinflationcurve.hpp>
#include <ql/cashflows/indexedcashflow.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>

#include "utilities.hpp"

#include "inflationcpicapfloor.hpp"
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/cpicouponpricer.hpp>
#include <ql/instruments/cpiswap.hpp>
#include <ql/instruments/bonds/cpibond.hpp>
#include <ql/instruments/cpicapfloor.hpp>

#include <ql/experimental/inflation/cpicapfloortermpricesurface.hpp>
#include <ql/experimental/inflation/cpicapfloorengines.hpp>

#include <iostream>


using namespace QuantLib;
using namespace boost::unit_test_framework;
using namespace std;


namespace inflation_cpi_capfloor_test {
    struct Datum {
        Date date;
        Rate rate;
    };

    template <class T, class U, class I>
    std::vector<ext::shared_ptr<BootstrapHelper<T> > > makeHelpers(
        Datum iiData[], Size N,
        const ext::shared_ptr<I> &ii, const Period &observationLag,
        const Calendar &calendar,
        const BusinessDayConvention &bdc,
        const DayCounter &dc,
        const Handle<YieldTermStructure>& discountCurve) {

        std::vector<ext::shared_ptr<BootstrapHelper<T> > > instruments;
        for (Size i=0; i<N; i++) {
            Date maturity = iiData[i].date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(
                                new SimpleQuote(iiData[i].rate/100.0)));
            ext::shared_ptr<BootstrapHelper<T> > anInstrument(new U(quote, observationLag, maturity,
                                                                    calendar, bdc, dc, ii,
                                                                    CPI::AsIndex, discountCurve));
            instruments.push_back(anInstrument);
        }

        return instruments;
    }


    struct CommonVars {
        // common data

        Size length;
        Date startDate;
        Rate baseZeroRate;
        Real volatility;

        Frequency frequency;
        std::vector<Real> nominals;
        Calendar calendar;
        BusinessDayConvention convention;
        Natural fixingDays;
        Date evaluationDate;
        Natural settlementDays;
        Date settlement;
        Period observationLag, contractObservationLag;
        CPI::InterpolationType contractObservationInterpolation;
        DayCounter dcZCIIS,dcNominal;
        std::vector<Date> zciisD;
        std::vector<Rate> zciisR;
        ext::shared_ptr<UKRPI> ii;
        RelinkableHandle<ZeroInflationIndex> hii;
        Size zciisDataLength;

        RelinkableHandle<YieldTermStructure> nominalUK;
        RelinkableHandle<ZeroInflationTermStructure> cpiUK;
        RelinkableHandle<ZeroInflationTermStructure> hcpi;

        vector<Rate> cStrikesUK;
        vector<Rate> fStrikesUK;
        vector<Period> cfMaturitiesUK;
        ext::shared_ptr<Matrix> cPriceUK;
        ext::shared_ptr<Matrix> fPriceUK;

        ext::shared_ptr<CPICapFloorTermPriceSurface> cpiCFsurfUK;

        // cleanup

        SavedSettings backup;

        // setup
        CommonVars()
        : nominals(1,1000000) {
            //std::cout <<"CommonVars" << std::endl;
            // option variables
            frequency = Annual;
            // usual setup
            volatility = 0.01;
            length = 7;
            calendar = UnitedKingdom();
            convention = ModifiedFollowing;
            Date today(1, June, 2010);
            evaluationDate = calendar.adjust(today);
            Settings::instance().evaluationDate() = evaluationDate;
            settlementDays = 0;
            fixingDays = 0;
            settlement = calendar.advance(today,settlementDays,Days);
            startDate = settlement;
            dcZCIIS = ActualActual(ActualActual::ISDA);
            dcNominal = ActualActual(ActualActual::ISDA);

            // uk rpi index
            //      fixing data
            Date from(1, July, 2007);
            Date to(1, June, 2010);
            Schedule rpiSchedule = MakeSchedule().from(from).to(to)
            .withTenor(1*Months)
            .withCalendar(UnitedKingdom())
            .withConvention(ModifiedFollowing);
            Real fixData[] = {
                206.1, 207.3, 208.0, 208.9, 209.7, 210.9,
                209.8, 211.4, 212.1, 214.0, 215.1, 216.8,   //  2008
                216.5, 217.2, 218.4, 217.7, 216.0, 212.9,
                210.1, 211.4, 211.3, 211.5, 212.8, 213.4,   //  2009
                213.4, 214.4, 215.3, 216.0, 216.6, 218.0,
                217.9, 219.2, 220.7, 222.8, -999, -999,     //  2010
                -999};

            // link from cpi index to cpi TS
            bool interp = false;// this MUST be false because the observation lag is only 2 months
                                // for ZCIIS; but not for contract if the contract uses a bigger lag.
            ii = ext::make_shared<UKRPI>(interp, hcpi);
            for (Size i=0; i<rpiSchedule.size();i++) {
                ii->addFixing(rpiSchedule[i], fixData[i], true);// force overwrite in case multiple use
            };


            Datum nominalData[] = {
                { Date( 2, June, 2010), 0.499997 },
                { Date( 3, June, 2010), 0.524992 },
                { Date( 8, June, 2010), 0.524974 },
                { Date( 15, June, 2010), 0.549942 },
                { Date( 22, June, 2010), 0.549913 },
                { Date( 1, July, 2010), 0.574864 },
                { Date( 2, August, 2010), 0.624668 },
                { Date( 1, September, 2010), 0.724338 },
                { Date( 16, September, 2010), 0.769461 },
                { Date( 1, December, 2010), 0.997501 },
                //{ Date( 16, December, 2010), 0.838164 },
                { Date( 17, March, 2011), 0.916996 },
                { Date( 16, June, 2011), 0.984339 },
                { Date( 22, September, 2011), 1.06085 },
                { Date( 22, December, 2011), 1.141788 },
                { Date( 1, June, 2012), 1.504426 },
                { Date( 3, June, 2013), 1.92064 },
                { Date( 2, June, 2014), 2.290824 },
                { Date( 1, June, 2015), 2.614394 },
                { Date( 1, June, 2016), 2.887445 },
                { Date( 1, June, 2017), 3.122128 },
                { Date( 1, June, 2018), 3.322511 },
                { Date( 3, June, 2019), 3.483997 },
                { Date( 1, June, 2020), 3.616896 },
                { Date( 1, June, 2022), 3.8281 },
                { Date( 2, June, 2025), 4.0341 },
                { Date( 3, June, 2030), 4.070854 },
                { Date( 1, June, 2035), 4.023202 },
                { Date( 1, June, 2040), 3.954748 },
                { Date( 1, June, 2050), 3.870953 },
                { Date( 1, June, 2060), 3.85298 },
                { Date( 2, June, 2070), 3.757542 },
                { Date( 3, June, 2080), 3.651379 }
            };

            std::vector<Date> nomD;
            std::vector<Rate> nomR;
            for (auto& i : nominalData) {
                nomD.push_back(i.date);
                nomR.push_back(i.rate / 100.0);
            }
            ext::shared_ptr<YieldTermStructure> nominalTS =
                ext::make_shared<InterpolatedZeroCurve<Linear>>(nomD,nomR,dcNominal);

            nominalUK.linkTo(nominalTS);


            // now build the zero inflation curve
            observationLag = Period(2,Months);
            contractObservationLag = Period(3,Months);
            contractObservationInterpolation = CPI::Flat;

            Datum zciisData[] = {
                { Date(1, June, 2011), 3.087 },
                { Date(1, June, 2012), 3.12 },
                { Date(1, June, 2013), 3.059 },
                { Date(1, June, 2014), 3.11 },
                { Date(1, June, 2015), 3.15 },
                { Date(1, June, 2016), 3.207 },
                { Date(1, June, 2017), 3.253 },
                { Date(1, June, 2018), 3.288 },
                { Date(1, June, 2019), 3.314 },
                { Date(1, June, 2020), 3.401 },
                { Date(1, June, 2022), 3.458 },
                { Date(1, June, 2025), 3.52 },
                { Date(1, June, 2030), 3.655 },
                { Date(1, June, 2035), 3.668 },
                { Date(1, June, 2040), 3.695 },
                { Date(1, June, 2050), 3.634 },
                { Date(1, June, 2060), 3.629 },
            };
            zciisDataLength = 17;
            for (Size i = 0; i < zciisDataLength; i++) {
                zciisD.push_back(zciisData[i].date);
                zciisR.push_back(zciisData[i].rate);
            }

            // now build the helpers ...
            std::vector<ext::shared_ptr<BootstrapHelper<ZeroInflationTermStructure> > > helpers =
            makeHelpers<ZeroInflationTermStructure,ZeroCouponInflationSwapHelper,
            ZeroInflationIndex>(zciisData, zciisDataLength, ii,
                                observationLag,
                                calendar, convention, dcZCIIS,
                                Handle<YieldTermStructure>(nominalTS));

            // we can use historical or first ZCIIS for this
            // we know historical is WAY off market-implied, so use market implied flat.
            baseZeroRate = zciisData[0].rate/100.0;
            ext::shared_ptr<PiecewiseZeroInflationCurve<Linear> > pCPIts(
                                new PiecewiseZeroInflationCurve<Linear>(
                                    evaluationDate, calendar, dcZCIIS, observationLag,
                                    ii->frequency(),ii->interpolated(), baseZeroRate,
                                    helpers));
            pCPIts->recalculate();
            cpiUK.linkTo(pCPIts);
            hii.linkTo(ii);

            // make sure that the index has the latest zero inflation term structure
            hcpi.linkTo(pCPIts);

            // cpi CF price surf data
            Period cfMat[] = {3*Years, 5*Years, 7*Years, 10*Years, 15*Years, 20*Years, 30*Years};
            Real cStrike[] = {0.03, 0.04, 0.05, 0.06};
            Real fStrike[] = {-0.01, 0, 0.01, 0.02};
            Size ncStrikes = 4, nfStrikes = 4, ncfMaturities = 7;

            Real cPrice[7][4] = {
                {227.6, 100.27, 38.8, 14.94},
                {345.32, 127.9, 40.59, 14.11},
                {477.95, 170.19, 50.62, 16.88},
                {757.81, 303.95, 107.62, 43.61},
                {1140.73, 481.89, 168.4, 63.65},
                {1537.6, 607.72, 172.27, 54.87},
                {2211.67, 839.24, 184.75, 45.03}};
            Real fPrice[7][4] = {
                {15.62, 28.38, 53.61, 104.6},
                {21.45, 36.73, 66.66, 129.6},
                {24.45, 42.08, 77.04, 152.24},
                {39.25, 63.52, 109.2, 203.44},
                {36.82, 63.62, 116.97, 232.73},
                {39.7, 67.47, 121.79, 238.56},
                {41.48, 73.9, 139.75, 286.75}};

            // now load the data into vector and Matrix classes
            cStrikesUK.clear();
            fStrikesUK.clear();
            cfMaturitiesUK.clear();
            for(Size i = 0; i < ncStrikes; i++) cStrikesUK.push_back(cStrike[i]);
            for(Size i = 0; i < nfStrikes; i++) fStrikesUK.push_back(fStrike[i]);
            for(Size i = 0; i < ncfMaturities; i++) cfMaturitiesUK.push_back(cfMat[i]);
            cPriceUK = ext::make_shared<Matrix>(ncStrikes, ncfMaturities);
            fPriceUK = ext::make_shared<Matrix>(nfStrikes, ncfMaturities);
            for(Size i = 0; i < ncStrikes; i++) {
                for(Size j = 0; j < ncfMaturities; j++) {
                    (*cPriceUK)[i][j] = cPrice[j][i]/10000.0;
                }
            }
            for(Size i = 0; i < nfStrikes; i++) {
                for(Size j = 0; j < ncfMaturities; j++) {
                    (*fPriceUK)[i][j] = fPrice[j][i]/10000.0;
                }
            }
        }
    };

}



void InflationCPICapFloorTest::cpicapfloorpricesurface() {
    BOOST_TEST_MESSAGE("Checking CPI cap/floor against price surface...");
    
    using namespace inflation_cpi_capfloor_test;
    
    CommonVars common;

    Real nominal = 1.0;
    InterpolatedCPICapFloorTermPriceSurface
    <Bilinear> cpiSurf(nominal,
                       common.baseZeroRate,
                       common.observationLag,
                       common.calendar,
                       common.convention,
                       common.dcZCIIS,
                       common.hii,
                       common.nominalUK,
                       common.cStrikesUK,
                       common.fStrikesUK,
                       common.cfMaturitiesUK,
                       *(common.cPriceUK),
                       *(common.fPriceUK));

    // test code - note order of indices
     for (Size i =0; i<common.fStrikesUK.size(); i++){

         Real qK = common.fStrikesUK[i];
         Size nMat = common.cfMaturitiesUK.size();
         for (Size j=0; j<nMat; j++) {
             Period t = common.cfMaturitiesUK[j];
             Real a = (*(common.fPriceUK))[i][j];
             Real b = cpiSurf.floorPrice(t,qK);

             QL_REQUIRE(fabs(a-b)<1e-7,"cannot reproduce cpi floor data from surface: "
                        << a << " vs constructed = " << b);
         }

     }

    for (Size i =0; i<common.cStrikesUK.size(); i++){

        Real qK = common.cStrikesUK[i];
        Size nMat = common.cfMaturitiesUK.size();
        for (Size j=0; j<nMat; j++) {
            Period t = common.cfMaturitiesUK[j];
            Real a = (*(common.cPriceUK))[i][j];
            Real b = cpiSurf.capPrice(t,qK);

            QL_REQUIRE(fabs(a-b)<1e-7,"cannot reproduce cpi cap data from surface: "
                       << a << " vs constructed = " << b);
        }
    }

    // Test the price method also i.e. does it pick out the correct premium?
    // Look up premium from surface at 3 years and strike of 1%
    // Expect, as 1% < ATM, to get back floor premium at 1% i.e. 53.61 bps
    Real premium = cpiSurf.price(3 * Years, 0.01);
    Real expPremium = (*common.fPriceUK)[2][0];
    if (fabs(premium - expPremium) > 1e-12) {
        BOOST_ERROR("The requested premium, " << premium
            << ", does not equal the expected premium, " << expPremium << ".");
    }

    // remove circular refernce
    common.hcpi.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
}


void InflationCPICapFloorTest::cpicapfloorpricer() {
    BOOST_TEST_MESSAGE("Checking CPI cap/floor pricer...");
    
    using namespace inflation_cpi_capfloor_test;

    CommonVars common;
    Real nominal = 1.0;
    ext::shared_ptr<CPICapFloorTermPriceSurface> cpiCFpriceSurf(new InterpolatedCPICapFloorTermPriceSurface
                                                    <Bilinear>(nominal,
                                                               common.baseZeroRate,
                                                               common.observationLag,
                                                               common.calendar,
                                                               common.convention,
                                                               common.dcZCIIS,
                                                               common.hii,
                                                               common.nominalUK,
                                                               common.cStrikesUK,
                                                               common.fStrikesUK,
                                                               common.cfMaturitiesUK,
                                                               *(common.cPriceUK),
                                                               *(common.fPriceUK)));

    common.cpiCFsurfUK = cpiCFpriceSurf;

    // interpolation pricer first
    // N.B. no new instrument required but we do need a new pricer

    Date startDate = Settings::instance().evaluationDate();
    Date maturity(startDate + Period(3,Years));
    Calendar fixCalendar = UnitedKingdom(), payCalendar = UnitedKingdom();
    BusinessDayConvention fixConvention(Unadjusted), payConvention(ModifiedFollowing);
    Rate strike(0.03);
    Real baseCPI = common.hii->fixing(fixCalendar.adjust(startDate-common.observationLag,fixConvention));
    CPI::InterpolationType observationInterpolation = CPI::AsIndex;
    CPICapFloor aCap(Option::Call,
                     nominal,
                     startDate,   // start date of contract (only)
                     baseCPI,
                     maturity,    // this is pre-adjustment!
                     fixCalendar,
                     fixConvention,
                     payCalendar,
                     payConvention,
                     strike,
                     common.hii,
                     common.observationLag,
                     observationInterpolation);

    Handle<CPICapFloorTermPriceSurface> cpiCFsurfUKh(common.cpiCFsurfUK);
    ext::shared_ptr<PricingEngine>engine(new InterpolatingCPICapFloorEngine(cpiCFsurfUKh));

    aCap.setPricingEngine(engine);

    // We should get back the cap premium at strike 0.03 i.e. 227.6 bps
    Real cached = (*common.cPriceUK)[0][0];

    QL_REQUIRE(fabs(cached - aCap.NPV())<1e-10,"InterpolatingCPICapFloorEngine does not reproduce cached price: "
               << cached << " vs " << aCap.NPV());

    // remove circular refernce
    common.hcpi.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
}




test_suite* InflationCPICapFloorTest::suite() {
    auto* suite = BOOST_TEST_SUITE("CPIswaption tests");

    suite->add(QUANTLIB_TEST_CASE(&InflationCPICapFloorTest::cpicapfloorpricesurface));
    suite->add(QUANTLIB_TEST_CASE(&InflationCPICapFloorTest::cpicapfloorpricer));

    return suite;
}

]]></document_content>
  </document>
  <document index="145">
    <source>inflationcpicapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon
 
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */


#ifndef quantlib_inflationcpicapfloor_test_hpp
#define quantlib_inflationcpicapfloor_test_hpp


// Boost.Test
#include <boost/test/unit_test.hpp>

//! Tests cpi cap/floor price data
//! N.B. a cpi cap produces ONE flow only - because inflation is cumulative.
class InflationCPICapFloorTest {
public:
    //! tests CPI price surface reproduction
    static void cpicapfloorpricesurface();
    //! tests interpolation pricer
    static void cpicapfloorpricer();
    
    static boost::unit_test_framework::test_suite* suite();
};



#endif
]]></document_content>
  </document>
  <document index="146">
    <source>inflationcpiswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "utilities.hpp"
#include "inflationcpiswap.hpp"
#include <ql/types.hpp>
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/termstructures/bootstraphelper.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/indexes/ibor/gbplibor.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/inflation/piecewisezeroinflationcurve.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/indexedcashflow.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/cpicouponpricer.hpp>
#include <ql/instruments/cpiswap.hpp>
#include <ql/instruments/bonds/cpibond.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#include <iostream>

using std::fabs;

namespace inflation_cpi_swap_test {
    struct Datum {
        Date date;
        Rate rate;
    };

    template <class T, class U, class I>
    std::vector<ext::shared_ptr<BootstrapHelper<T> > > makeHelpers(
        Datum iiData[], Size N,
        const ext::shared_ptr<I> &ii, const Period &observationLag,
        const Calendar &calendar,
        const BusinessDayConvention &bdc,
        const DayCounter &dc,
        const Handle<YieldTermStructure>& discountCurve) {

        std::vector<ext::shared_ptr<BootstrapHelper<T> > > instruments;
        for (Size i=0; i<N; i++) {
            Date maturity = iiData[i].date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(
                                new SimpleQuote(iiData[i].rate/100.0)));
            ext::shared_ptr<BootstrapHelper<T> > anInstrument(new U(quote, observationLag, maturity,
                                                                    calendar, bdc, dc, ii,
                                                                    CPI::AsIndex, discountCurve));
            instruments.push_back(anInstrument);
        }

        return instruments;
    }


    struct CommonVars {
        // common data

        Size length;
        Date startDate;
        Real volatility;

        Frequency frequency;
        std::vector<Real> nominals;
        Calendar calendar;
        BusinessDayConvention convention;
        Natural fixingDays;
        Date evaluationDate;
        Natural settlementDays;
        Date settlement;
        Period observationLag, contractObservationLag;
        CPI::InterpolationType contractObservationInterpolation;
        DayCounter dcZCIIS,dcNominal;
        std::vector<Date> zciisD;
        std::vector<Rate> zciisR;
        ext::shared_ptr<UKRPI> ii;
        Size zciisDataLength;

        RelinkableHandle<YieldTermStructure> nominalTS;
        ext::shared_ptr<ZeroInflationTermStructure> cpiTS;
        RelinkableHandle<ZeroInflationTermStructure> hcpi;

        // cleanup

        SavedSettings backup;
        IndexHistoryCleaner cleaner;

        // setup
        CommonVars()
        : nominals(1,1000000) {

            // option variables
            frequency = Annual;
            // usual setup
            volatility = 0.01;
            length = 7;
            calendar = UnitedKingdom();
            convention = ModifiedFollowing;
            Date today(25, November, 2009);
            evaluationDate = calendar.adjust(today);
            Settings::instance().evaluationDate() = evaluationDate;
            settlementDays = 0;
            fixingDays = 0;
            settlement = calendar.advance(today,settlementDays,Days);
            startDate = settlement;
            dcZCIIS = ActualActual(ActualActual::ISDA);
            dcNominal = ActualActual(ActualActual::ISDA);

            // uk rpi index
            //      fixing data
            Date from(20, July, 2007);
            //Date from(20, July, 2008);
            Date to(20, November, 2009);
            Schedule rpiSchedule = MakeSchedule().from(from).to(to)
            .withTenor(1*Months)
            .withCalendar(UnitedKingdom())
            .withConvention(ModifiedFollowing);
            Real fixData[] = {
                206.1, 207.3, 208.0, 208.9, 209.7, 210.9,
                209.8, 211.4, 212.1, 214.0, 215.1, 216.8,
                216.5, 217.2, 218.4, 217.7, 216,
                212.9, 210.1, 211.4, 211.3, 211.5,
                212.8, 213.4, 213.4, 213.4, 214.4,
                -999.0, -999.0 };

            // link from cpi index to cpi TS
            bool interp = false;// this MUST be false because the observation lag is only 2 months
                                // for ZCIIS; but not for contract if the contract uses a bigger lag.
            ii = ext::make_shared<UKRPI>(interp, hcpi);
            for (Size i=0; i<rpiSchedule.size();i++) {
                ii->addFixing(rpiSchedule[i], fixData[i], true);// force overwrite in case multiple use
            };


            Datum nominalData[] = {
                { Date(26, November, 2009), 0.475 },
                { Date(2, December, 2009), 0.47498 },
                { Date(29, December, 2009), 0.49988 },
                { Date(25, February, 2010), 0.59955 },
                { Date(18, March, 2010), 0.65361 },
                { Date(25, May, 2010), 0.82830 },
                //  { Date(17, June, 2010), 0.7 },  // can't bootstrap with this data point
                { Date(16, September, 2010), 0.78960 },
                { Date(16, December, 2010), 0.93762 },
                { Date(17, March, 2011), 1.12037 },
                { Date(16, June, 2011), 1.31308 },
                { Date(22, September, 2011),1.52011 },
                { Date(25, November, 2011), 1.78399 },
                { Date(26, November, 2012), 2.41170 },
                { Date(25, November, 2013), 2.83935 },
                { Date(25, November, 2014), 3.12888 },
                { Date(25, November, 2015), 3.34298 },
                { Date(25, November, 2016), 3.50632 },
                { Date(27, November, 2017), 3.63666 },
                { Date(26, November, 2018), 3.74723 },
                { Date(25, November, 2019), 3.83988 },
                { Date(25, November, 2021), 4.00508 },
                { Date(25, November, 2024), 4.16042 },
                { Date(26, November, 2029), 4.15577 },
                { Date(27, November, 2034), 4.04933 },
                { Date(25, November, 2039), 3.95217 },
                { Date(25, November, 2049), 3.80932 },
                { Date(25, November, 2059), 3.80849 },
                { Date(25, November, 2069), 3.72677 },
                { Date(27, November, 2079), 3.63082 }
            };

            std::vector<Date> nomD;
            std::vector<Rate> nomR;
            for (auto& i : nominalData) {
                nomD.push_back(i.date);
                nomR.push_back(i.rate / 100.0);
            }
            ext::shared_ptr<YieldTermStructure> nominal =
                ext::make_shared<InterpolatedZeroCurve<Linear>>(nomD,nomR,dcNominal);

            nominalTS.linkTo(nominal);

            // now build the zero inflation curve
            observationLag = Period(2,Months);
            contractObservationLag = Period(3,Months);
            contractObservationInterpolation = CPI::Flat;

            Datum zciisData[] = {
                { Date(25, November, 2010), 3.0495 },
                { Date(25, November, 2011), 2.93 },
                { Date(26, November, 2012), 2.9795 },
                { Date(25, November, 2013), 3.029 },
                { Date(25, November, 2014), 3.1425 },
                { Date(25, November, 2015), 3.211 },
                { Date(25, November, 2016), 3.2675 },
                { Date(25, November, 2017), 3.3625 },
                { Date(25, November, 2018), 3.405 },
                { Date(25, November, 2019), 3.48 },
                { Date(25, November, 2021), 3.576 },
                { Date(25, November, 2024), 3.649 },
                { Date(26, November, 2029), 3.751 },
                { Date(27, November, 2034), 3.77225 },
                { Date(25, November, 2039), 3.77 },
                { Date(25, November, 2049), 3.734 },
                { Date(25, November, 2059), 3.714 },
            };
            zciisDataLength = 17;
            for (Size i = 0; i < zciisDataLength; i++) {
                zciisD.push_back(zciisData[i].date);
                zciisR.push_back(zciisData[i].rate);
            }

            // now build the helpers ...
            std::vector<ext::shared_ptr<BootstrapHelper<ZeroInflationTermStructure> > > helpers =
            makeHelpers<ZeroInflationTermStructure,ZeroCouponInflationSwapHelper,
            ZeroInflationIndex>(zciisData, zciisDataLength, ii,
                                observationLag,
                                calendar, convention, dcZCIIS,
                                Handle<YieldTermStructure>(nominalTS));

            // we can use historical or first ZCIIS for this
            // we know historical is WAY off market-implied, so use market implied flat.
            Rate baseZeroRate = zciisData[0].rate/100.0;
            ext::shared_ptr<PiecewiseZeroInflationCurve<Linear> > pCPIts(
                                new PiecewiseZeroInflationCurve<Linear>(
                                    evaluationDate, calendar, dcZCIIS, observationLag,
                                    ii->frequency(),ii->interpolated(), baseZeroRate,
                                    helpers));
            pCPIts->recalculate();
            cpiTS = ext::dynamic_pointer_cast<ZeroInflationTermStructure>(pCPIts);


            // make sure that the index has the latest zero inflation term structure
            hcpi.linkTo(pCPIts);
        }
    };

}



void CPISwapTest::consistency() {
    BOOST_TEST_MESSAGE("Checking CPI swap against inflation term structure...");

    using namespace inflation_cpi_swap_test;

    // check inflation leg vs calculation directly from inflation TS
    CommonVars common;

    // ZeroInflationSwap aka CPISwap

    Swap::Type type = Swap::Payer;
    Real nominal = 1000000.0;
    bool subtractInflationNominal = true;
    // float+spread leg
    Spread spread = 0.0;
    DayCounter floatDayCount = Actual365Fixed();
    BusinessDayConvention floatPaymentConvention = ModifiedFollowing;
    Natural fixingDays = 0;
    ext::shared_ptr<IborIndex> floatIndex(new GBPLibor(Period(6,Months),
                                                         common.nominalTS));

    // fixed x inflation leg
    Rate fixedRate = 0.1;//1% would be 0.01
    Real baseCPI = 206.1; // would be 206.13871 if we were interpolating
    DayCounter fixedDayCount = Actual365Fixed();
    BusinessDayConvention fixedPaymentConvention = ModifiedFollowing;
    Calendar fixedPaymentCalendar = UnitedKingdom();
    ext::shared_ptr<ZeroInflationIndex> fixedIndex = common.ii;
    Period contractObservationLag = common.contractObservationLag;
    CPI::InterpolationType observationInterpolation = common.contractObservationInterpolation;

    // set the schedules
    Date startDate(2, October, 2007);
    Date endDate(2, October, 2052);
    Schedule floatSchedule = MakeSchedule().from(startDate).to(endDate)
    .withTenor(Period(6,Months))
    .withCalendar(UnitedKingdom())
    .withConvention(floatPaymentConvention)
    .backwards()
    ;
    Schedule fixedSchedule = MakeSchedule().from(startDate).to(endDate)
    .withTenor(Period(6,Months))
    .withCalendar(UnitedKingdom())
    .withConvention(Unadjusted)
    .backwards()
    ;


    CPISwap zisV(type, nominal, subtractInflationNominal,
                 spread, floatDayCount, floatSchedule,
                 floatPaymentConvention, fixingDays, floatIndex,
                 fixedRate, baseCPI, fixedDayCount, fixedSchedule,
                 fixedPaymentConvention, contractObservationLag,
                 fixedIndex, observationInterpolation);
    Date asofDate = Settings::instance().evaluationDate();

    Real floatFix[] = {0.06255,0.05975,0.0637,0.018425,0.0073438,-1,-1};
    Real cpiFix[] = {211.4,217.2,211.4,213.4,-2,-2};
    for(Size i=0;i<floatSchedule.size(); i++){
        if (floatSchedule[i] < common.evaluationDate) {
            floatIndex->addFixing(floatSchedule[i], floatFix[i],true);//true=overwrite
        }

        ext::shared_ptr<CPICoupon>
        zic = ext::dynamic_pointer_cast<CPICoupon>(zisV.cpiLeg()[i]);
        if (zic != nullptr) {
            if (zic->fixingDate() < (common.evaluationDate - Period(1,Months))) {
                fixedIndex->addFixing(zic->fixingDate(), cpiFix[i],true);
            }
        }
    }

    // simple structure so simple pricing engine - most work done by index
    ext::shared_ptr<DiscountingSwapEngine> dse(new DiscountingSwapEngine(common.nominalTS));
    zisV.setPricingEngine(dse);
    
    // get float+spread & fixed*inflation leg prices separately
    Real testInfLegNPV = 0.0;
    for(Size i=0;i<zisV.leg(0).size(); i++){

        Date zicPayDate = (zisV.leg(0))[i]->date();
        if(zicPayDate > asofDate) {
            testInfLegNPV += (zisV.leg(0))[i]->amount()*common.nominalTS->discount(zicPayDate);
        }

        ext::shared_ptr<CPICoupon>
            zicV = ext::dynamic_pointer_cast<CPICoupon>(zisV.cpiLeg()[i]);
        if (zicV != nullptr) {
            Real diff = fabs( zicV->rate() - (fixedRate*(zicV->indexFixing()/baseCPI)) );
            QL_REQUIRE(diff<1e-8,"failed "<<i<<"th coupon reconstruction as "
                       << (fixedRate*(zicV->indexFixing()/baseCPI)) << " vs rate = "
                       <<zicV->rate() << ", with difference: " << diff);
        }
    }

    Real error = fabs(testInfLegNPV - zisV.legNPV(0));
    QL_REQUIRE(error<1e-5,
               "failed manual inf leg NPV calc vs pricing engine: " <<
               testInfLegNPV << " vs " << zisV.legNPV(0));

    Real diff = fabs(1-zisV.NPV()/4191660.0);
    
    Real max_diff;
    if (IborCoupon::usingAtParCoupons())
        max_diff = 1e-5;
    else
        max_diff = 3e-5;

    QL_REQUIRE(diff<max_diff,
               "failed stored consistency value test, ratio = " << diff);

    // remove circular refernce
    common.hcpi.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
}


void CPISwapTest::zciisconsistency() {
    BOOST_TEST_MESSAGE("Checking CPI swap against zero-coupon inflation swap...");

    using namespace inflation_cpi_swap_test;

    CommonVars common;

    Swap::Type ztype = Swap::Payer;
    Real  nominal = 1000000.0;
    Date startDate(common.evaluationDate);
    Date endDate(25, November, 2059);
    Calendar cal = UnitedKingdom();
    BusinessDayConvention paymentConvention = ModifiedFollowing;
    DayCounter dummyDC, dc = ActualActual(ActualActual::ISDA);
    Period observationLag(2,Months);

    Rate quote = 0.03714;
    ZeroCouponInflationSwap zciis(ztype, nominal, startDate, endDate, cal, paymentConvention, dc,
                                  quote, common.ii, observationLag, CPI::AsIndex);

    // simple structure so simple pricing engine - most work done by index
    ext::shared_ptr<DiscountingSwapEngine>
    dse(new DiscountingSwapEngine(common.nominalTS));

    zciis.setPricingEngine(dse);
    QL_REQUIRE(fabs(zciis.NPV())<1e-3,"zciis does not reprice to zero");

    std::vector<Date> oneDate = {endDate};
    Schedule schOneDate(oneDate, cal, paymentConvention);

    Swap::Type stype = Swap::Payer;
    Real inflationNominal = nominal;
    Real floatNominal = inflationNominal * std::pow(1.0+quote,50);
    bool subtractInflationNominal = true;
    Real dummySpread=0.0, dummyFixedRate=0.0;
    Natural fixingDays = 0;
    Date baseDate = startDate - observationLag;
    Real baseCPI = common.ii->fixing(baseDate);

    ext::shared_ptr<IborIndex> dummyFloatIndex;

    CPISwap cS(stype, floatNominal, subtractInflationNominal, dummySpread, dummyDC, schOneDate,
               paymentConvention, fixingDays, dummyFloatIndex,
               dummyFixedRate, baseCPI, dummyDC, schOneDate, paymentConvention, observationLag,
               common.ii, CPI::AsIndex, inflationNominal);

    cS.setPricingEngine(dse);
    QL_REQUIRE(fabs(cS.NPV())<1e-3,"CPISwap as ZCIIS does not reprice to zero");

    for (Size i=0; i<2; i++) {
        QL_REQUIRE(fabs(cS.legNPV(i)-zciis.legNPV(i))<1e-3,"zciis leg does not equal CPISwap leg");
    }
    // remove circular refernce
    common.hcpi.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
}


void CPISwapTest::cpibondconsistency() {
    BOOST_TEST_MESSAGE("Checking CPI swap against CPI bond...");

    using namespace inflation_cpi_swap_test;

    CommonVars common;

    // ZeroInflationSwap aka CPISwap

    Swap::Type type = Swap::Payer;
    Real nominal = 1000000.0;
    bool subtractInflationNominal = true;
    // float+spread leg
    Spread spread = 0.0;
    DayCounter floatDayCount = Actual365Fixed();
    BusinessDayConvention floatPaymentConvention = ModifiedFollowing;
    Natural fixingDays = 0;
    ext::shared_ptr<IborIndex> floatIndex(new GBPLibor(Period(6,Months),
                                                         common.nominalTS));

    // fixed x inflation leg
    Rate fixedRate = 0.1;//1% would be 0.01
    Real baseCPI = 206.1; // would be 206.13871 if we were interpolating
    DayCounter fixedDayCount = Actual365Fixed();
    BusinessDayConvention fixedPaymentConvention = ModifiedFollowing;
    Calendar fixedPaymentCalendar = UnitedKingdom();
    ext::shared_ptr<ZeroInflationIndex> fixedIndex = common.ii;
    Period contractObservationLag = common.contractObservationLag;
    CPI::InterpolationType observationInterpolation = common.contractObservationInterpolation;

    // set the schedules
    Date startDate(2, October, 2007);
    Date endDate(2, October, 2052);
    Schedule floatSchedule = MakeSchedule().from(startDate).to(endDate)
    .withTenor(Period(6,Months))
    .withCalendar(UnitedKingdom())
    .withConvention(floatPaymentConvention)
    .backwards()
    ;
    Schedule fixedSchedule = MakeSchedule().from(startDate).to(endDate)
    .withTenor(Period(6,Months))
    .withCalendar(UnitedKingdom())
    .withConvention(Unadjusted)
    .backwards()
    ;


    CPISwap zisV(type, nominal, subtractInflationNominal,
                 spread, floatDayCount, floatSchedule,
                 floatPaymentConvention, fixingDays, floatIndex,
                 fixedRate, baseCPI, fixedDayCount, fixedSchedule,
                 fixedPaymentConvention, contractObservationLag,
                 fixedIndex, observationInterpolation);

    Real floatFix[] = {0.06255,0.05975,0.0637,0.018425,0.0073438,-1,-1};
    Real cpiFix[] = {211.4,217.2,211.4,213.4,-2,-2};
    for(Size i=0;i<floatSchedule.size(); i++){
        if (floatSchedule[i] < common.evaluationDate) {
            floatIndex->addFixing(floatSchedule[i], floatFix[i],true);//true=overwrite
        }

        ext::shared_ptr<CPICoupon>
        zic = ext::dynamic_pointer_cast<CPICoupon>(zisV.cpiLeg()[i]);
        if (zic != nullptr) {
            if (zic->fixingDate() < (common.evaluationDate - Period(1,Months))) {
                fixedIndex->addFixing(zic->fixingDate(), cpiFix[i],true);
            }
        }
    }


    // simple structure so simple pricing engine - most work done by index
    ext::shared_ptr<DiscountingSwapEngine> dse(new DiscountingSwapEngine(common.nominalTS));
    zisV.setPricingEngine(dse);

    // now do the bond equivalent
    std::vector<Rate> fixedRates(1,fixedRate);
    Natural settlementDays = 1;// cannot be zero!
    bool growthOnly = true;
    CPIBond cpiB(settlementDays, nominal, growthOnly,
                 baseCPI, contractObservationLag, fixedIndex,
                 observationInterpolation, fixedSchedule,
                 fixedRates, fixedDayCount, fixedPaymentConvention);

    ext::shared_ptr<DiscountingBondEngine> dbe(new DiscountingBondEngine(common.nominalTS));
    cpiB.setPricingEngine(dbe);

    QL_REQUIRE(fabs(cpiB.NPV() - zisV.legNPV(0))<1e-5,"cpi bond does not equal equivalent cpi swap leg");
    // remove circular reference
    common.hcpi.linkTo(ext::shared_ptr<ZeroInflationTermStructure>());
}


test_suite* CPISwapTest::suite() {
    auto* suite = BOOST_TEST_SUITE("CPISwap tests");

    suite->add(QUANTLIB_TEST_CASE(&CPISwapTest::consistency));
    suite->add(QUANTLIB_TEST_CASE(&CPISwapTest::zciisconsistency));
    suite->add(QUANTLIB_TEST_CASE(&CPISwapTest::cpibondconsistency));

    return suite;
}

]]></document_content>
  </document>
  <document index="147">
    <source>inflationcpiswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Chris Kenyon
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflationcpiswap_hpp
#define quantlib_test_inflationcpiswap_hpp

#include <boost/test/unit_test.hpp>

//! Classic inflation index ratio-from-base products.  Always have some "notional" flow.
class CPISwapTest {
public:
    //! consistency test w.r.t. manual build-up of calculatons
    static void consistency();
    //! a CPI swap can look like a Zero Coupon Inflation Inedex Swap, check it gies same prices
    static void zciisconsistency();
    //! one leg of a CPI swap looks like a CPI bond with growthOnly=true
    static void cpibondconsistency();
    static boost::unit_test_framework::test_suite* suite();
};



#endif
]]></document_content>
  </document>
  <document index="148">
    <source>inflationvolatility.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "inflationvolatility.hpp"
#include "utilities.hpp"

#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/inflation/interpolatedyoyinflationcurve.hpp>

#include <ql/cashflows/inflationcoupon.hpp>
#include <ql/cashflows/inflationcouponpricer.hpp>

#include <ql/experimental/inflation/yoycapfloortermpricesurface.hpp>
#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>
#include <ql/experimental/inflation/yoyoptionletstripper.hpp>

#include <ql/experimental/inflation/kinterpolatedyoyoptionletvolatilitysurface.hpp>
#include <ql/experimental/inflation/interpolatedyoyoptionletstripper.hpp>

#include <ql/cashflows/capflooredinflationcoupon.hpp>
#include <ql/indexes/inflation/euhicp.hpp>
#include <ql/indexes/inflation/ukrpi.hpp>

#include <iostream>


// local namespace for data
//*************************************************************************
namespace inflation_volatility_test {

    using namespace std;
    using namespace QuantLib;

    // local data globals
    Handle<YieldTermStructure> nominalEUR;
    Handle<YieldTermStructure> nominalGBP;

    RelinkableHandle<YoYInflationTermStructure> yoyEU;
    RelinkableHandle<YoYInflationTermStructure> yoyUK;

    vector<Rate> cStrikesEU;
    vector<Rate> fStrikesEU;
    vector<Period> cfMaturitiesEU;
    ext::shared_ptr<Matrix> cPriceEU;
    ext::shared_ptr<Matrix> fPriceEU;

    ext::shared_ptr<YoYInflationIndex> yoyIndexUK;
    ext::shared_ptr<YoYInflationIndex> yoyIndexEU;

    vector<Rate> cStrikesUK;
    vector<Rate> fStrikesUK;
    vector<Period> cfMaturitiesUK;
    ext::shared_ptr<Matrix> cPriceUK;
    ext::shared_ptr<Matrix> fPriceUK;

    ext::shared_ptr<InterpolatedYoYCapFloorTermPriceSurface<Bicubic,Cubic> > priceSurfEU;

    void reset() {
        nominalEUR = Handle<YieldTermStructure>();
        nominalGBP = Handle<YieldTermStructure>();
        priceSurfEU.reset();
        yoyEU.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
        yoyUK.linkTo(ext::shared_ptr<YoYInflationTermStructure>());
        yoyIndexUK.reset();
        yoyIndexEU.reset();
        cPriceEU.reset();
        fPriceEU.reset();
        cPriceUK.reset();
        fPriceUK.reset();
        yoyIndexUK.reset();

        cStrikesEU.clear();        
        fStrikesEU.clear();
        cStrikesUK.clear();        
        fStrikesUK.clear();
        cfMaturitiesEU.clear();
        cfMaturitiesUK.clear();
    }

    void setup() {

        // make sure of the evaluation date
        Date eval = Date(Day(23), Month(11), Year(2007));
        Settings::instance().evaluationDate() = eval;

        yoyIndexUK = ext::shared_ptr<YoYInflationIndex>(new YYUKRPIr(true, yoyUK));
        yoyIndexEU = ext::shared_ptr<YoYInflationIndex>(new YYEUHICPr(true, yoyEU));

        // nominal yield curve (interpolated; times assume year parts have 365 days)
        Real timesEUR[] = {0.0109589, 0.0684932, 0.263014, 0.317808, 0.567123, 0.816438,
               1.06575, 1.31507, 1.56438, 2.0137, 3.01918, 4.01644,
               5.01644, 6.01644, 7.01644, 8.01644, 9.02192, 10.0192,
               12.0192, 15.0247, 20.0301, 25.0356, 30.0329, 40.0384,
               50.0466};
        Real ratesEUR[] = {0.0415600, 0.0426840, 0.0470980, 0.0458506, 0.0449550, 0.0439784,
               0.0431887, 0.0426604, 0.0422925, 0.0424591, 0.0421477, 0.0421853,
               0.0424016, 0.0426969, 0.0430804, 0.0435011, 0.0439368, 0.0443825,
               0.0452589, 0.0463389, 0.0472636, 0.0473401, 0.0470629, 0.0461092,
               0.0450794};

        Real timesGBP[] = {0.008219178, 0.010958904, 0.01369863,  0.019178082,  0.073972603,
               0.323287671, 0.57260274,  0.821917808, 1.071232877,  1.320547945,
               1.506849315, 2.002739726, 3.002739726, 4.002739726,  5.005479452,
               6.010958904, 7.008219178, 8.005479452, 9.008219178, 10.00821918,
               12.01369863, 15.0109589,  20.01369863, 25.01917808,  30.02191781,
               40.03287671, 50.03561644, 60.04109589, 70.04931507};
        Real ratesGBP[] = {0.0577363, 0.0582314, 0.0585265, 0.0587165, 0.0596598,
               0.0612506, 0.0589676, 0.0570512, 0.0556147, 0.0546082,
               0.0549492, 0.053801, 0.0529333, 0.0524068, 0.0519712,
               0.0516615, 0.0513711, 0.0510433, 0.0507974, 0.0504833,
               0.0498998, 0.0490464, 0.04768, 0.0464862, 0.045452,
               0.0437699, 0.0425311, 0.0420073, 0.041151};

        vector <Real> r;
        vector <Date> d;
        Size nTimesEUR = LENGTH(timesEUR);
        Size nTimesGBP = LENGTH(timesGBP);
        for (Size i = 0; i < nTimesEUR; i++) {
            r.push_back(ratesEUR[i]);
            Size ys = (Size)floor(timesEUR[i]);
            Size ds = (Size)((timesEUR[i]-(Real)ys)*365);
            Date dd = eval + Period(ys,Years) + Period(ds,Days);
            d.push_back( dd );
        }

        ext::shared_ptr<InterpolatedZeroCurve<Cubic> >
            euriborTS(new InterpolatedZeroCurve<Cubic>(d, r, Actual365Fixed()));
        Handle<YieldTermStructure> nominalHeur(euriborTS, false);
        nominalEUR = nominalHeur;   // copy to global

        d.clear();
        r.clear();
        for (Size i = 0; i < nTimesGBP; i++) {
            r.push_back(ratesGBP[i]);
            Size ys = (Size)floor(timesGBP[i]);
            Size ds = (Size)((timesGBP[i]-(Real)ys)*365);
            Date dd = eval + Period(ys,Years) + Period(ds,Days);
            d.push_back( dd );
        }

        ext::shared_ptr<InterpolatedZeroCurve<Cubic> >
            gbpLiborTS(new InterpolatedZeroCurve<Cubic>(d, r, Actual365Fixed()));
        Handle<YieldTermStructure> nominalHgbp(gbpLiborTS, false);
        nominalGBP = nominalHgbp;   // copy to global

        // times = years - lag, where the lag is 2 months or 2/12
        // because this data is derived from cap/floor data that
        // is based on a 2 month lag.

        // note that these are NOT swap rates
        // also not that the first value MUST be in the base period
        // i.e. the first rate is for a negative time
        Real yoyEUrates[] = {0.0237951,
             0.0238749, 0.0240334, 0.0241934, 0.0243567, 0.0245323,
             0.0247213, 0.0249348, 0.0251768, 0.0254337, 0.0257258,
             0.0260217, 0.0263006, 0.0265538, 0.0267803, 0.0269378,
             0.0270608, 0.0271363, 0.0272, 0.0272512, 0.0272927,
             0.027317, 0.0273615, 0.0273811, 0.0274063, 0.0274307,
             0.0274625, 0.027527, 0.0275952, 0.0276734, 0.027794};

        d.clear();
        r.clear();
        Date baseDate = TARGET().advance(eval, -2, Months, ModifiedFollowing);
        for (Size i = 0; i < LENGTH(yoyEUrates); i++) {
            Date dd = TARGET().advance(baseDate, i, Years, ModifiedFollowing);
            d.push_back(dd);
            r.push_back(yoyEUrates[i]);
        }

        bool indexIsInterpolated = true;    // actually false for UKRPI but smooth surfaces are
                                            // better for finding intersections etc

        ext::shared_ptr<InterpolatedYoYInflationCurve<Linear> >
            pYTSEU( new InterpolatedYoYInflationCurve<Linear>(
                    eval, TARGET(), Actual365Fixed(), Period(2,Months), Monthly,
                    indexIsInterpolated, d, r) );
        yoyEU.linkTo(pYTSEU);

        // price data
        const Size ncStrikesEU = 6;
        const Size nfStrikesEU = 6;
        const Size ncfMaturitiesEU = 7;
        Real capStrikesEU[ncStrikesEU] = {0.02, 0.025, 0.03, 0.035, 0.04, 0.05};
        Period capMaturitiesEU[ncfMaturitiesEU] = {3*Years, 5*Years, 7*Years,
            10*Years, 15*Years, 20*Years, 30*Years};
        Real capPricesEU[ncStrikesEU][ncfMaturitiesEU] =
            {{116.225, 204.945, 296.285, 434.29, 654.47, 844.775, 1132.33},
                {34.305, 71.575, 114.1, 184.33, 307.595, 421.395, 602.35},
                {6.37, 19.085, 35.635, 66.42, 127.69, 189.685, 296.195},
                {1.325, 5.745, 12.585, 26.945, 58.95, 94.08, 158.985},
                {0.501, 2.37, 5.38, 13.065, 31.91, 53.95, 96.97},
                {0.501, 0.695, 1.47, 4.415, 12.86, 23.75, 46.7}};

        Real floorStrikesEU[nfStrikesEU] = {-0.01, 0.00, 0.005, 0.01, 0.015, 0.02};
        Real floorPricesEU[nfStrikesEU][ncfMaturitiesEU] =
            {{0.501, 0.851, 2.44, 6.645, 16.23, 26.85, 46.365},
                {0.501, 2.236, 5.555, 13.075, 28.46, 44.525, 73.08},
                {1.025, 3.935, 9.095, 19.64, 39.93, 60.375, 96.02},
                {2.465, 7.885, 16.155, 31.6, 59.34, 86.21, 132.045},
                {6.9, 17.92, 32.085, 56.08, 95.95, 132.85, 194.18},
                {23.52, 47.625, 74.085, 114.355, 175.72, 229.565, 316.285}};

        // now load the data into vector and Matrix classes
        cStrikesEU.clear();
        fStrikesEU.clear();
        cfMaturitiesEU.clear();
        for (double& i : capStrikesEU)
            cStrikesEU.push_back(i);
        for (double& i : floorStrikesEU)
            fStrikesEU.push_back(i);
        for (auto& i : capMaturitiesEU)
            cfMaturitiesEU.push_back(i);
        ext::shared_ptr<Matrix> tcPriceEU(new Matrix(ncStrikesEU, ncfMaturitiesEU));
        ext::shared_ptr<Matrix> tfPriceEU(new Matrix(nfStrikesEU, ncfMaturitiesEU));
        for(Size i = 0; i < ncStrikesEU; i++) {
            for(Size j = 0; j < ncfMaturitiesEU; j++) {
                (*tcPriceEU)[i][j] = capPricesEU[i][j];
            }
        }
        for(Size i = 0; i < nfStrikesEU; i++) {
            for(Size j = 0; j < ncfMaturitiesEU; j++) {
                (*tfPriceEU)[i][j] = floorPricesEU[i][j];
            }
        }
        cPriceEU = tcPriceEU;   // copy to global
        fPriceEU = tfPriceEU;
    }


    void setupPriceSurface() {

        // construct:
        //  calendar, business day convention, and day counter are
        //  taken from the nominal base give the reference date for
        //  the inflation options (generally 2 or 3 months before
        //  nominal reference date)
        Natural fixingDays = 0;
        Size lag = 3;// must be 3 because we use an interpolated index (EU)
        Period yyLag = Period(lag,Months);
        Rate baseRate = 1; // not really used
        DayCounter dc = Actual365Fixed();
        TARGET cal;
        BusinessDayConvention bdc = ModifiedFollowing;
        const ext::shared_ptr<QuantLib::YieldTermStructure>& pn = nominalEUR.currentLink();
        Handle<QuantLib::YieldTermStructure> n(pn,false);
        ext::shared_ptr<InterpolatedYoYCapFloorTermPriceSurface<Bicubic,Cubic> >
        cfEUprices(new InterpolatedYoYCapFloorTermPriceSurface<Bicubic,Cubic>(
                                       fixingDays,
                                       yyLag, yoyIndexEU, baseRate,
                                       n, dc,
                                       cal,    bdc,
                                       cStrikesEU, fStrikesEU, cfMaturitiesEU,
                                       (*cPriceEU), (*fPriceEU)));

        priceSurfEU = cfEUprices;
    }

}

//***************************************************************************



void InflationVolTest::testYoYPriceSurfaceToVol() {
    BOOST_TEST_MESSAGE("Testing conversion from YoY price surface "
                       "to YoY volatility surface...");

    using namespace inflation_volatility_test;

    SavedSettings backup;

    setup();

    // first get the price surface set up
    setupPriceSurface();

    // caplet pricer, recall that setCapletVolatility(Handle<YoYOptionletVolatilitySurface>)
    // exists ... we'll use it with the -Curve variant of the surface
    // test UNIT DISPLACED pricer
    ext::shared_ptr<YoYOptionletVolatilitySurface> pVS;
    Handle<YoYOptionletVolatilitySurface> hVS(pVS, false); // pVS does NOT own whatever it points to later, hence the handle does not either
    ext::shared_ptr<YoYInflationUnitDisplacedBlackCapFloorEngine>
        yoyPricerUD(new YoYInflationUnitDisplacedBlackCapFloorEngine(yoyIndexEU,hVS,nominalEUR)); //hVS
    // N.B. the vol gets set in the stripper ... else no point!

    // cap stripper
    ext::shared_ptr<YoYOptionletStripper> yoyOptionletStripper(
                             new InterpolatedYoYOptionletStripper<Linear>() );

    // now set up all the variables for the stripping
    Natural settlementDays = 0;
    TARGET cal;
    BusinessDayConvention bdc = ModifiedFollowing;
    DayCounter dc = Actual365Fixed();

    ext::shared_ptr<YoYCapFloorTermPriceSurface> capFloorPrices = priceSurfEU;
    Period lag = priceSurfEU->observationLag();

    Real slope = -0.5; //when you have bad data, i.e. very low/constant
    //prices for short dated extreem strikes
    //then you cannot assume constant caplet vol
    //(else arbitrage)
    // N.B. if this is too extreme then can't
    // get a no-arbitrage solution anyway
    // the way the slope is used means that the slope is
    // proportional to the level so higher slopes at
    // the edges when things are more volatile

    // Actually is doesn't matter what the interpolation is because we only
    // intend to use the K values that correspond to quotes ... for model fitting.
    ext::shared_ptr<KInterpolatedYoYOptionletVolatilitySurface<Linear> > yoySurf(new
                    KInterpolatedYoYOptionletVolatilitySurface<Linear>(settlementDays,
                cal, bdc, dc, lag, capFloorPrices, yoyPricerUD, yoyOptionletStripper,
                                                              slope) );

    // now use it for something ... like stating what the T=const lines look like
    const Real volATyear1[] = {
          0.0128, 0.0093, 0.0083, 0.0073, 0.0064,
          0.0058, 0.0042, 0.0046, 0.0053, 0.0064,
          0.0098
    };
    const Real volATyear3[] = {
          0.0079, 0.0058, 0.0051, 0.0045, 0.0039,
          0.0035, 0.0026, 0.0028, 0.0033, 0.0039,
          0.0060
    };

    Date d = yoySurf->baseDate() + Period(1,Years);
    pair<vector<Rate>, vector<Volatility> > someSlice;
    someSlice = yoySurf->Dslice(d);

    Size n = someSlice.first.size();
    Real eps = 0.0001;
    for(Size i = 0; i < n; i++){
        QL_REQUIRE( fabs(someSlice.second[i] - volATyear1[i]) < eps,
                   " could not recover 1yr vol: " << someSlice.second[i]
                   << " vs " << volATyear1[i] );
    }

    d = yoySurf->baseDate() + Period(3,Years);
    pair<vector<Rate>, vector<Volatility> >
        someOtherSlice = yoySurf->Dslice(d);
    n = someOtherSlice.first.size();
    for(Size i = 0; i < n; i++){
        QL_REQUIRE(fabs(someOtherSlice.second[i]-volATyear3[i]) < eps,
                        "could not recover 3yr vol: "
                        << someOtherSlice.second[i]<< " vs " << volATyear3[i] );
    }

    reset();
}




void InflationVolTest::testYoYPriceSurfaceToATM() {
    BOOST_TEST_MESSAGE("Testing conversion from YoY cap-floor surface "
                       "to YoY inflation term structure...");

    using namespace inflation_volatility_test;

    SavedSettings backup;

    setup();

    setupPriceSurface();

    pair<vector<Time>, vector<Rate> > yyATMt = priceSurfEU->atmYoYSwapTimeRates();
    pair<vector<Date>, vector<Rate> > yyATMd = priceSurfEU->atmYoYSwapDateRates();

    // Real dy = (Real)lag / 12.0;
    const Real crv[] = {0.024586, 0.0247575, 0.0249396, 0.0252596,
                          0.0258498, 0.0262883, 0.0267915};
    const Real swaps[] = {0.024586, 0.0247575, 0.0249396, 0.0252596,
                          0.0258498, 0.0262883, 0.0267915};
    const Real ayoy[] = {0.0247659, 0.0251437, 0.0255945, 0.0265234,
                           0.0280457, 0.0285534, 0.0295884};
    Real eps = 2e-5;
    for(Size i = 0; i < yyATMt.first.size(); i++) {
        QL_REQUIRE(fabs( yyATMt.second[i] - crv[i] ) < eps,
                   "could not recover cached yoy swap curve "
                   << yyATMt.second[i]<< " vs " << crv[i]);
    }

    for(Size i = 0; i < yyATMd.first.size(); i++) {
        QL_REQUIRE(fabs( priceSurfEU->atmYoYSwapRate(yyATMd.first[i])  - swaps[i] ) < eps,
                   "could not recover yoy swap curve "
                   << priceSurfEU->atmYoYSwapRate(yyATMd.first[i]) << " vs " << swaps[i]);
    }
    for(Size i = 0; i < yyATMd.first.size(); i++) {
        QL_REQUIRE(fabs( priceSurfEU->atmYoYRate(yyATMd.first[i])  - ayoy[i] ) < eps,
                   " could not recover cached yoy curve "
                   << priceSurfEU->atmYoYRate(yyATMd.first[i]) << " vs " << ayoy[i]
                   <<" at "<<yyATMd.first[i]);
    }
    reset();
}


boost::unit_test_framework::test_suite* InflationVolTest::suite() {
    auto* suite = BOOST_TEST_SUITE("yoyOptionletStripper (yoy inflation vol) tests");

    suite->add(QUANTLIB_TEST_CASE(&InflationVolTest::testYoYPriceSurfaceToATM));
    suite->add(QUANTLIB_TEST_CASE(&InflationVolTest::testYoYPriceSurfaceToVol));

    return suite;
}


]]></document_content>
  </document>
  <document index="149">
    <source>inflationvolatility.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflationvol_hpp
#define quantlib_test_inflationvol_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
 comment block of the corresponding class */


class InflationVolTest {
public:
    static void testYoYPriceSurfaceToATM();
    static void testYoYPriceSurfaceToVol();

    static boost::unit_test_framework::test_suite* suite();
};




#endif //quantlib_test_inflationvol_hpp

]]></document_content>
  </document>
  <document index="150">
    <source>inflationzciisinterpolation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include "inflationzciisinterpolation.hpp"
#include "utilities.hpp"
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/inflation/piecewisezeroinflationcurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/schedule.hpp>
#include <iostream>

using boost::unit_test_framework::test_suite;
using namespace QuantLib;

using ZeroCouponInflationSwapHelpers =
    std::vector<ext::shared_ptr<BootstrapHelper<ZeroInflationTermStructure> > >;

namespace ZCIIS {
    struct Result {
        ext::shared_ptr<ZeroInflationIndex> index;
        ZeroCouponInflationSwapHelpers helpers;
        ext::shared_ptr<ZeroInflationCurve> curve;
        ext::shared_ptr<ZeroCouponInflationSwap> swap;
    };

    struct Setup {
        Setup(bool indexIsInterpolated, CPI::InterpolationType observationInterpolation)
        : indexIsInterpolated(indexIsInterpolated),
          observationInterpolation(observationInterpolation) {
            evaluationDate = calendar.adjust(unadjustedEvaluationDate);
            Settings::instance().evaluationDate() = evaluationDate;

            nominalTermStructure = ext::shared_ptr<YieldTermStructure>(
                new FlatForward(evaluationDate, 0.05, Actual360()));
        }

        bool indexIsInterpolated;
        CPI::InterpolationType observationInterpolation;

        Date unadjustedEvaluationDate{Date(13, August, 2007)};
        Date evaluationDate;

        Calendar calendar{UnitedKingdom()};
        BusinessDayConvention bdc{ModifiedFollowing};
        DayCounter dc{Thirty360(Thirty360::BondBasis)};
        Period observationLag{Period(3, Months)};

        ZeroCouponInflationSwap::Type swapType{ZeroCouponInflationSwap::Payer};
        Real swapNomimal{1000000.00};

        Date indexFixingScheduleFrom{Date(1, January, 2005)};
        Date indexFixingScheduleTo{Date(13, August, 2007)};

        ext::shared_ptr<YieldTermStructure> nominalTermStructure;
    };

    std::ostream& operator<<(std::ostream& out, const Setup& setup) {
        std::string observationInterpolation;
        switch (setup.observationInterpolation) {
            case CPI::AsIndex:
                observationInterpolation = "CPI::AsIndex";
                break;
            case CPI::Flat:
                observationInterpolation = "CPI::Flat";
                break;
            case CPI::Linear:
                observationInterpolation = "CPI::Linear";
                break;
            default:
                QL_FAIL("Unknown CPI::InterpolationType...");
        }

        return out << observationInterpolation << " (Index "
                   << (setup.indexIsInterpolated ? "" : "not ") << "interpolated)";
    }

    Real fixData[] = {189.9, 189.9, 189.6, 190.5, 191.6, 192.0, 192.2, 192.2, 192.6, 193.1, 193.3,
                      193.6, 194.1, 193.4, 194.2, 195.0, 196.5, 197.7, 198.5, 198.5, 199.2, 200.1,
                      200.4, 201.1, 202.7, 201.6, 203.1, 204.4, 205.4, 206.2, 207.3};

    ext::shared_ptr<UKRPI> makeUKRPI(const Setup& setup,
                                     const RelinkableHandle<ZeroInflationTermStructure>& hz) {
        // fixing data
        Schedule rpiSchedule = MakeSchedule()
                                   .from(setup.indexFixingScheduleFrom)
                                   .to(setup.indexFixingScheduleTo)
                                   .withTenor(1 * Months)
                                   .withCalendar(setup.calendar)
                                   .withConvention(setup.bdc);

        ext::shared_ptr<UKRPI> ukrpi(new UKRPI(setup.indexIsInterpolated, hz));
        for (Size i = 0; i < LENGTH(fixData); i++) {
            ukrpi->addFixing(rpiSchedule[i], fixData[i]);
        }

        return ukrpi;
    }

    struct Datum {
        Date date;
        Rate rate;
    };

    std::vector<Datum> zcData = {{Date(13, August, 2008), 2.93},  {Date(13, August, 2009), 2.95},
                                 {Date(13, August, 2010), 2.965}, {Date(15, August, 2011), 2.98},
                                 {Date(13, August, 2012), 3.0},   {Date(13, August, 2014), 3.06},
                                 {Date(13, August, 2017), 3.175}, {Date(13, August, 2019), 3.243},
                                 {Date(15, August, 2022), 3.293}, {Date(14, August, 2027), 3.338},
                                 {Date(13, August, 2032), 3.348}, {Date(15, August, 2037), 3.348},
                                 {Date(13, August, 2047), 3.308}, {Date(13, August, 2057), 3.228}};


    ZeroCouponInflationSwapHelpers makeHelpers(const Setup& setup,
                                               const ext::shared_ptr<ZeroInflationIndex>& index) {
        auto makeHelper = [&setup, &index](const Handle<Quote>& quote, const Date& maturity) {
            return ext::make_shared<ZeroCouponInflationSwapHelper>(
                quote, setup.observationLag, maturity, setup.calendar, setup.bdc, setup.dc, index,
                setup.observationInterpolation,
                Handle<YieldTermStructure>(setup.nominalTermStructure));
        };

        ZeroCouponInflationSwapHelpers instruments;
        for (Datum datum : zcData) {
            Date maturity = datum.date;
            Handle<Quote> quote(ext::shared_ptr<Quote>(new SimpleQuote(datum.rate / 100.0)));
            auto anInstrument = makeHelper(quote, maturity);
            instruments.push_back(anInstrument);
        }

        return instruments;
    }

    ext::shared_ptr<ZeroInflationCurve>
    makeZeroInflationCurve(const Setup& setup,
                           const ext::shared_ptr<ZeroInflationIndex>& index,
                           const ZeroCouponInflationSwapHelpers& helpers) {
        auto frequency = Monthly;

        Rate baseZeroRate = zcData[0].rate / 100.0;
        ext::shared_ptr<PiecewiseZeroInflationCurve<Linear> > pZITS(
            new PiecewiseZeroInflationCurve<Linear>(setup.evaluationDate, setup.calendar, setup.dc,
                                                    setup.observationLag, frequency,
                                                    index->interpolated(), baseZeroRate, helpers));
        pZITS->recalculate();

        return pZITS;
    }

    ext::shared_ptr<ZeroCouponInflationSwap>
    makeZeroCouponInflationSwap(const Setup& setup,
                                const ext::shared_ptr<ZeroInflationIndex>& index,
                                const ext::shared_ptr<ZeroInflationCurve>& curve) {
        auto maturity = zcData[6].date;
        auto fixedRate = zcData[6].rate / 100.0;

        return ext::make_shared<ZeroCouponInflationSwap>(
            setup.swapType, setup.swapNomimal, setup.evaluationDate, maturity, setup.calendar,
            setup.bdc, setup.dc, fixedRate, index, setup.observationLag,
            setup.observationInterpolation);
    }

    Result makeResult(const Setup& setup) {
        Result result;

        RelinkableHandle<ZeroInflationTermStructure> hz;

        result.index = makeUKRPI(setup, hz);
        result.helpers = makeHelpers(setup, result.index);
        result.curve = makeZeroInflationCurve(setup, result.index, result.helpers);
        result.swap = makeZeroCouponInflationSwap(setup, result.index, result.curve);

        hz.linkTo(result.curve);

        return result;
    }

    void runTest(const Setup& setup) {
        BOOST_TEST_MESSAGE("Testing ZCIIS " << setup << "...");

        auto result = ZCIIS::makeResult(setup);
    }
}

void InflationZCIISInterpolationTest::asIndexNotInterpolated() {
    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    bool indexIsInterpolated = false;
    const auto setup = ZCIIS::Setup(indexIsInterpolated, CPI::AsIndex);

    ZCIIS::runTest(setup);
}

void InflationZCIISInterpolationTest::asIndexInterpolated() {
    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    bool indexIsInterpolated = true;
    const auto setup = ZCIIS::Setup(indexIsInterpolated, CPI::AsIndex);

    ZCIIS::runTest(setup);
}

void InflationZCIISInterpolationTest::flatNotInterpolated() {
    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    bool indexIsInterpolated = false;
    const auto setup = ZCIIS::Setup(indexIsInterpolated, CPI::Flat);

    ZCIIS::runTest(setup);
}

void InflationZCIISInterpolationTest::flatInterpolated() {
    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    bool indexIsInterpolated = true;
    const auto setup = ZCIIS::Setup(indexIsInterpolated, CPI::Flat);

    ZCIIS::runTest(setup);
}

void InflationZCIISInterpolationTest::linearNotInterpolated() {
    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    bool indexIsInterpolated = false;
    const auto setup = ZCIIS::Setup(indexIsInterpolated, CPI::Linear);

    ZCIIS::runTest(setup);
}

void InflationZCIISInterpolationTest::linearInterpolated() {
    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    bool indexIsInterpolated = true;
    const auto setup = ZCIIS::Setup(indexIsInterpolated, CPI::Linear);

    ZCIIS::runTest(setup);
}

test_suite* InflationZCIISInterpolationTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Zero Coupon Inflation Index Swap (ZCIIS) interpolation tests");

    //suite->add(QUANTLIB_TEST_CASE(&InflationZCIISInterpolationTest::asIndexNotInterpolated));
    suite->add(QUANTLIB_TEST_CASE(&InflationZCIISInterpolationTest::asIndexInterpolated));

    suite->add(QUANTLIB_TEST_CASE(&InflationZCIISInterpolationTest::flatNotInterpolated));
    suite->add(QUANTLIB_TEST_CASE(&InflationZCIISInterpolationTest::flatInterpolated));

    suite->add(QUANTLIB_TEST_CASE(&InflationZCIISInterpolationTest::linearNotInterpolated));
    suite->add(QUANTLIB_TEST_CASE(&InflationZCIISInterpolationTest::linearInterpolated));

    return suite;
}
]]></document_content>
  </document>
  <document index="151">
    <source>inflationzciisinterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Ralf Konrad Eckel
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#ifndef quantlib_test_inflationzciisinterpolation_hpp
#define quantlib_test_inflationzciisinterpolation_hpp

#include <boost/test/unit_test.hpp>

//! Test the ZCIIS interpolation types AsIndex, Flat and Linear
class InflationZCIISInterpolationTest {
  public:
    static void asIndexNotInterpolated();
    static void asIndexInterpolated();
    static void flatNotInterpolated();
    static void flatInterpolated();
    static void linearNotInterpolated();
    static void linearInterpolated();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="152">
    <source>instruments.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "instruments.hpp"
#include "utilities.hpp"
#include <ql/instruments/stock.hpp>
#include <ql/instruments/compositeinstrument.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/daycounters/actual360.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void InstrumentTest::testObservable() {

    BOOST_TEST_MESSAGE("Testing observability of instruments...");

    ext::shared_ptr<SimpleQuote> me1(new SimpleQuote(0.0));
    RelinkableHandle<Quote> h(me1);
    ext::shared_ptr<Instrument> s(new Stock(h));

    Flag f;
    f.registerWith(s);
    
    s->NPV();
    me1->setValue(3.14);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of instrument change");
    
    s->NPV();
    f.lower();
    ext::shared_ptr<SimpleQuote> me2(new SimpleQuote(0.0));
    h.linkTo(me2);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of instrument change");

    f.lower();
    s->freeze();
    s->NPV();
    me2->setValue(2.71);
    if (f.isUp())
        BOOST_FAIL("Observer was notified of frozen instrument change");
    s->NPV();
    s->unfreeze();
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of instrument change");
}


void InstrumentTest::testCompositeWhenShiftingDates() {

    BOOST_TEST_MESSAGE(
        "Testing reaction of composite instrument to date changes...");

    SavedSettings backup;

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();

    ext::shared_ptr<StrikedTypePayoff> payoff(
                                 new PlainVanillaPayoff(Option::Call, 100.0));
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(today+30));

    ext::shared_ptr<Instrument> option(new EuropeanOption(payoff, exercise));

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(100.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(0.0, dc);
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(0.01, dc);
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(0.1, dc);

    ext::shared_ptr<BlackScholesMertonProcess> process(
        new BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));
    ext::shared_ptr<PricingEngine> engine(new AnalyticEuropeanEngine(process));

    option->setPricingEngine(engine);

    CompositeInstrument composite;
    composite.add(option);

    Settings::instance().evaluationDate() = today+45;

    if (!composite.isExpired())
        BOOST_FAIL("Composite didn't detect expiration");
    if (composite.NPV() != 0.0)
        BOOST_FAIL("Composite didn't return a null NPV");

    Settings::instance().evaluationDate() = today;

    if (composite.isExpired())
        BOOST_FAIL("Composite didn't detect aliveness");
    if (composite.NPV() == 0.0)
        BOOST_FAIL("Composite didn't recalculate");
}

test_suite* InstrumentTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Instrument tests");
    suite->add(QUANTLIB_TEST_CASE(&InstrumentTest::testObservable));
    suite->add(QUANTLIB_TEST_CASE(
                            &InstrumentTest::testCompositeWhenShiftingDates));
    return suite;
}

]]></document_content>
  </document>
  <document index="153">
    <source>instruments.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2016 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_instruments_hpp
#define quantlib_test_instruments_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class InstrumentTest {
  public:
    static void testObservable();
    static void testCompositeWhenShiftingDates();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="154">
    <source>integrals.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "integrals.hpp"
#include "utilities.hpp"
#include <ql/math/functional.hpp>
#include <ql/math/integrals/exponentialintegrals.hpp>
#include <ql/math/integrals/filonintegral.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/integrals/simpsonintegral.hpp>
#include <ql/math/integrals/trapezoidintegral.hpp>
#include <ql/math/integrals/kronrodintegral.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/integrals/discreteintegrals.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/termstructures/volatility/abcd.hpp>
#include <ql/math/integrals/twodimensionalintegral.hpp>
#include <ql/experimental/math/piecewisefunction.hpp>
#include <ql/experimental/math/piecewiseintegral.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;

namespace integrals_test {

    Real tolerance = 1.0e-6;

    template <class T>
    void testSingle(const T& I, const std::string& tag,
                    const ext::function<Real (Real)>& f,
                    Real xMin, Real xMax, Real expected) {
        Real calculated = I(f,xMin,xMax);
        if (std::fabs(calculated-expected) > integrals_test::tolerance) {
            BOOST_FAIL(std::setprecision(10)
                       << "integrating " << tag
                       << "    calculated: " << calculated
                       << "    expected:   " << expected);
        }
    }

    template <class T>
    void testSeveral(const T& I) {
        testSingle(I, "f(x) = 0",
                   constant<Real,Real>(0.0), 0.0, 1.0, 0.0);
        testSingle(I, "f(x) = 1",
                   constant<Real,Real>(1.0), 0.0, 1.0, 1.0);
        testSingle(I, "f(x) = x",
                   identity<Real>(),           0.0, 1.0, 0.5);
        testSingle(I, "f(x) = x^2",
                   square<Real>(),             0.0, 1.0, 1.0/3.0);
        testSingle(I, "f(x) = sin(x)",
                   static_cast<Real(*)(Real)>(std::sin), 0.0, M_PI, 2.0);
        testSingle(I, "f(x) = cos(x)",
                   static_cast<Real(*)(Real)>(std::cos), 0.0, M_PI, 0.0);
        testSingle(I, "f(x) = Gaussian(x)",
                   NormalDistribution(), -10.0, 10.0, 1.0);
        testSingle(I, "f(x) = Abcd2(x)",
                   AbcdSquared(0.07, 0.07, 0.5, 0.1, 8.0, 10.0), 5.0, 6.0,
                   AbcdFunction(0.07, 0.07, 0.5, 0.1).covariance(5.0, 6.0, 8.0, 10.0));
    }

    template <class T>
    void testDegeneratedDomain(const T& I) {
        testSingle(I, "f(x) = 0 over [1, 1 + macheps]",
                   constant<Real, Real>(0.0), 1.0, 1.0 + QL_EPSILON, 0.0);
    }

}


void IntegralTest::testSegment() {
    BOOST_TEST_MESSAGE("Testing segment integration...");

    using namespace integrals_test;

    testSeveral(SegmentIntegral(10000));
    testDegeneratedDomain(SegmentIntegral(10000));
}

void IntegralTest::testTrapezoid() {
    BOOST_TEST_MESSAGE("Testing trapezoid integration...");

    using namespace integrals_test;

    testSeveral(TrapezoidIntegral<Default>(integrals_test::tolerance, 10000));
    testDegeneratedDomain(TrapezoidIntegral<Default>(integrals_test::tolerance, 10000));
}

void IntegralTest::testMidPointTrapezoid() {
    BOOST_TEST_MESSAGE("Testing mid-point trapezoid integration...");

    using namespace integrals_test;

    testSeveral(TrapezoidIntegral<MidPoint>(integrals_test::tolerance, 10000));
    testDegeneratedDomain(TrapezoidIntegral<MidPoint>(integrals_test::tolerance, 10000));
}

void IntegralTest::testSimpson() {
    BOOST_TEST_MESSAGE("Testing Simpson integration...");

    using namespace integrals_test;

    testSeveral(SimpsonIntegral(integrals_test::tolerance, 10000));
    testDegeneratedDomain(SimpsonIntegral(integrals_test::tolerance, 10000));
}

void IntegralTest::testGaussKronrodAdaptive() {
    BOOST_TEST_MESSAGE("Testing adaptive Gauss-Kronrod integration...");

    using namespace integrals_test;

    Size maxEvaluations = 1000;
    testSeveral(GaussKronrodAdaptive(integrals_test::tolerance, maxEvaluations));
    testDegeneratedDomain(GaussKronrodAdaptive(integrals_test::tolerance, maxEvaluations));
}

void IntegralTest::testGaussLobatto() {
    BOOST_TEST_MESSAGE("Testing adaptive Gauss-Lobatto integration...");

    using namespace integrals_test;

    Size maxEvaluations = 1000;
    testSeveral(GaussLobattoIntegral(maxEvaluations, integrals_test::tolerance));
    // on degenerated domain [1,1+macheps] an exception is thrown
    // which is also ok, but not tested here
}

void IntegralTest::testGaussKronrodNonAdaptive() {
    BOOST_TEST_MESSAGE("Testing non-adaptive Gauss-Kronrod integration...");

    using namespace integrals_test;

    Real precision = integrals_test::tolerance;
    Size maxEvaluations = 100;
    Real relativeAccuracy = integrals_test::tolerance;
    GaussKronrodNonAdaptive gaussKronrodNonAdaptive(precision, maxEvaluations,
                                                    relativeAccuracy);
    testSeveral(gaussKronrodNonAdaptive);
    testDegeneratedDomain(gaussKronrodNonAdaptive);
}

void IntegralTest::testTwoDimensionalIntegration() {
    BOOST_TEST_MESSAGE("Testing two dimensional adaptive "
                       "Gauss-Lobatto integration...");

    using namespace integrals_test;

    const Size maxEvaluations = 1000;
    const Real calculated = TwoDimensionalIntegral(
        ext::shared_ptr<Integrator>(
            new TrapezoidIntegral<Default>(integrals_test::tolerance, maxEvaluations)),
        ext::shared_ptr<Integrator>(
            new TrapezoidIntegral<Default>(integrals_test::tolerance, maxEvaluations)))(
        std::multiplies<Real>(),
        std::make_pair(0.0, 0.0), std::make_pair(1.0, 2.0));

    const Real expected = 1.0;
    if (std::fabs(calculated-expected) > integrals_test::tolerance) {
        BOOST_FAIL(std::setprecision(10)
                   << "two dimensional integration: "
                   << "\n    calculated: " << calculated
                   << "\n    expected:   " << expected);
    }
}

namespace integrals_test {

    class sineF {
      public:
        Real operator()(Real x) const {
            return std::exp(-0.5*(x - M_PI_2/100));
        }
    };

    class cosineF {
      public:
        Real operator()(Real x) const {
            return std::exp(-0.5*x);
        }
    };

}

void IntegralTest::testFolinIntegration() {
    BOOST_TEST_MESSAGE("Testing Folin's integral formulae...");

    using namespace integrals_test;

    // Examples taken from
    // http://www.tat.physik.uni-tuebingen.de/~kokkotas/Teaching/Num_Methods_files/Comp_Phys5.pdf
    const Size nr[] = { 4, 8, 16, 128, 256, 1024, 2048 };
    const Real expected[] = { 4.55229440e-5,4.72338540e-5, 4.72338540e-5,
                              4.78308678e-5,4.78404787e-5, 4.78381120e-5,
                              4.78381084e-5};

    const Real t = 100;
    const Real o = M_PI_2/t;

    const Real tol = 1e-12;

    for (Size i=0; i < LENGTH(nr); ++i) {
        const Size n = nr[i];
        const Real calculatedCosine
            = FilonIntegral(FilonIntegral::Cosine, t, n)(cosineF(),0,2*M_PI);
        const Real calculatedSine
            = FilonIntegral(FilonIntegral::Sine, t, n)
                (sineF(), o,2*M_PI + o);

        if (std::fabs(calculatedCosine-expected[i]) > tol) {
            BOOST_FAIL(std::setprecision(10)
                << "Filon Cosine integration failed: "
                << "\n    calculated: " << calculatedCosine
                << "\n    expected:   " << expected[i]);
        }
        if (std::fabs(calculatedSine-expected[i]) > tol) {
            BOOST_FAIL(std::setprecision(10)
                << "Filon Sine integration failed: "
                << "\n    calculated: " << calculatedCosine
                << "\n    expected:   " << expected[i]);
        }
    }
}

namespace integrals_test {

    Real f1(Real x) {
        return 1.2*x*x+3.2*x+3.1;
    }

    Real f2(Real x) {
        return 4.3*(x-2.34)*(x-2.34)-6.2*(x-2.34) + f1(2.34);
    }

}

void IntegralTest::testDiscreteIntegrals() {
    BOOST_TEST_MESSAGE("Testing discrete integral formulae...");

    using namespace integrals_test;

    Array x(6), f(6);
    x[0] = 1.0; x[1] = 2.02; x[2] = 2.34; x[3] = 3.3; x[4] = 4.2; x[5] = 4.6;

    std::transform(x.begin(), x.begin()+3, f.begin(),   f1);
    std::transform(x.begin()+3, x.end(),   f.begin()+3, f2);

    const Real expectedSimpson =
        16.0401216 + 30.4137528 + 0.2*f2(4.2) + 0.2*f2(4.6);
    const Real expectedTrapezoid =
          0.5*(f1(1.0)  + f1(2.02))*1.02
        + 0.5*(f1(2.02) + f1(2.34))*0.32
        + 0.5*(f2(2.34) + f2(3.3) )*0.96
        + 0.5*(f2(3.3)  + f2(4.2) )*0.9
        + 0.5*(f2(4.2)  + f2(4.6) )*0.4;

    const Real calculatedSimpson =  DiscreteSimpsonIntegral()(x, f);
    const Real calculatedTrapezoid = DiscreteTrapezoidIntegral()(x, f);

    const Real tol = 1e-12;
    if (std::fabs(calculatedSimpson-expectedSimpson) > tol) {
        BOOST_FAIL(std::setprecision(16)
            << "discrete Simpson integration failed: "
            << "\n    calculated: " << calculatedSimpson
            << "\n    expected:   " << expectedSimpson);
    }

    if (std::fabs(calculatedTrapezoid-expectedTrapezoid) > tol) {
        BOOST_FAIL(std::setprecision(16)
            << "discrete Trapezoid integration failed: "
            << "\n    calculated: " << calculatedTrapezoid
            << "\n    expected:   " << expectedTrapezoid);
    }
}

void IntegralTest::testDiscreteIntegrator() {
    BOOST_TEST_MESSAGE("Testing discrete integrator formulae...");

    using namespace integrals_test;

    testSeveral(DiscreteSimpsonIntegrator(300));
    testSeveral(DiscreteTrapezoidIntegrator(3000));
}

namespace integrals_test{

std::vector<Real> x, y;

Real pw_fct(const Real t) { return QL_PIECEWISE_FUNCTION(x, y, t); }

void pw_check(const Integrator &in, const Real a, const Real b,
              const Real expected) {
    Real calculated = in(pw_fct, a, b);
    if (!close(calculated, expected))
        BOOST_FAIL(std::setprecision(16)
                   << "piecewise integration over [" << a << "," << b
                   << "] failed: "
                   << "\n   calculated: " << calculated
                   << "\n   expected:   " << expected
                   << "\n   difference: " << (calculated - expected));
}
} // empty namespace

void IntegralTest::testPiecewiseIntegral() {
    BOOST_TEST_MESSAGE("Testing piecewise integral...");

    using namespace integrals_test;

    x = { 1.0, 2.0, 3.0, 4.0, 5.0 };
    y = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };
    ext::shared_ptr<Integrator> segment =
        ext::make_shared<SegmentIntegral>(1);
    ext::shared_ptr<Integrator> piecewise =
        ext::make_shared<PiecewiseIntegral>(segment, x);
    pw_check(*piecewise, -1.0, 0.0, 1.0);
    pw_check(*piecewise, 0.0, 1.0, 1.0);
    pw_check(*piecewise, 0.0, 1.5, 2.0);
    pw_check(*piecewise, 0.0, 2.0, 3.0);
    pw_check(*piecewise, 0.0, 2.5, 4.5);
    pw_check(*piecewise, 0.0, 3.0, 6.0);
    pw_check(*piecewise, 0.0, 4.0, 10.0);
    pw_check(*piecewise, 0.0, 5.0, 15.0);
    pw_check(*piecewise, 0.0, 6.0, 21.0);
    pw_check(*piecewise, 0.0, 7.0, 27.0);
    pw_check(*piecewise, 3.5, 4.5, 4.5);
    pw_check(*piecewise, 5.0, 10.0, 30.0);
    pw_check(*piecewise, 9.0, 10.0, 6.0);
}

namespace integrals_test {
    template <class T>
    void reportSiCiFail(
            const std::string& name, T z, T c, T e, Real diff, Real tol) {
        BOOST_FAIL(std::setprecision(16)
            << name << " calculation failed for " << z
            << "\n calculated: " << c
            << "\n expected:   " << e
            << "\n difference: " << diff
            << "\n tolerance:  " << tol);
    }
}

void IntegralTest::testExponentialIntegral() {
    BOOST_TEST_MESSAGE("Testing exponential integrals...");

    using namespace ExponentialIntegral;

    // reference values are calculated with Mathematica or Python/mpmath
    const Real data[][10] = {
            {0.0010000000000000000208, 0.0, 0.00099999994444444613193, 0.0, -6.330539864080593754, 0.0, -6.3295393640250381967, 0.0, 6.3315393641361493112, 0.0},
            {0.00070710678118654756077, 0.00070710678118654751747, 0.00070710682047025644818, 0.00070710674190283627304, -6.3305396140806145873, 0.785397913397448279, -6.329832507338711751, 0.7861055202179185354, 6.3312467208225174236, -0.78469130657697802259},
            {6.1232339957367660136e-20, 0.0010000000000000000208, 6.1232350162201617204e-20, 0.001000000055555557243, -6.330539364080593754, 1.570796326794896558, -6.3305398640805937539, 1.5717963267393410041, 6.330539864080593754, -1.5697963268504521119},
            {-0.00070710678118654747417, 0.00070710678118654760407, -0.00070710682047025636158, 0.00070710674190283635964, -6.3305396140806145873, 2.356194740192344837, -6.3312467208225174235, 2.3569013470128150935, 6.3298325073387117511, -2.3554871333718745805},
            {-0.0010000000000000000208, 1.2246467991473532027e-19, -0.00099999994444444613193, 1.2246465950321797194e-19, -6.330539864080593754, 3.141592653589793116, -6.3315393641361493112, 3.1415926535897931161, 6.3295393640250381967, -3.1415926535897931159},
            {-0.00070710678118654764736, -0.00070710678118654743088, -0.00070710682047025653477, -0.00070710674190283618645, -6.3305396140806145873, -2.3561947401923450819, -6.3312467208225174237, -2.3569013470128153382, 6.3298325073387117509, 2.3554871333718748256},
            {-1.8369701987210298041e-19, -0.0010000000000000000208, -1.8369705049015472569e-19, -0.001000000055555557243, -6.330539364080593754, -1.5707963267948968029, -6.3305398640805937541, -1.5717963267393412491, 6.3305398640805937538, 1.5697963268504523568},
            {0.00070710678118654738758, -0.00070710678118654769066, 0.00070710682047025627499, -0.00070710674190283644623, -6.3305396140806145873, -0.78539791339744852393, -6.3298325073387117512, -0.78610552021791878051, 6.3312467208225174234, 0.78469130657697826735},
            {0.10000000000000000555, 0.0, 0.099944461108276955702, 0.0, -1.7278683866572965838, 0.0, -1.6228128139692766136, 0.0, 1.8229239584193906159, 0.0},
            {0.07071067811865475853, 0.0707106781186547542, 0.070749950041603603669, 0.070671382625480302524, -1.7253704697591484327, 0.78289816362892975745, -1.6546990871336681256, 0.8586481132075703999, 1.7960418523846287393, -0.7171482131243632012},
            {6.123233995736766226e-18, 0.10000000000000000555, 6.1334444895968712791e-18, 0.10005557222505700112, -1.7228683861943336147, 1.5707963267948965577, -1.7278683866572965777, 1.670740787903173514, 1.7278683866572965899, -1.4708518656866196026},
            {-0.070710678118654749871, 0.07071067811865476286, -0.070749950041603595024, 0.070671382625480311198, -1.7253704697591484321, 2.3586944899608633586, -1.7960418523846287312, 2.4244444404654299234, 1.6546990871336681349, -2.2829445403822227075},
            {-0.10000000000000000555, 1.2246467991473532452e-17, -0.099944461108276955702, 1.2226067414369268591e-17, -1.7278683866572965838, 3.1415926535897931166, -1.8229239584193906159, 3.1415926535897931277, 1.6228128139692766136, -3.1415926535897931031},
            {-0.07071067811865476719, -0.070710678118654745541, -0.070749950041603612314, -0.07067138262548029385, -1.7253704697591484333, -2.3586944899608636035, -1.7960418523846287474, -2.4244444404654301511, 1.6546990871336681163, 2.2829445403822229697},
            {-1.8369701987210298678e-17, -0.10000000000000000555, -1.8400333469093536425e-17, -0.10005557222505700112, -1.7228683861943336147, -1.5707963267948968038, -1.7278683866572966021, -1.6707407879031737577, 1.7278683866572965654, 1.4708518656866198463},
            {0.070710678118654741211, -0.07071067811865477152, 0.070749950041603586379, -0.070671382625480319872, -1.7253704697591484315, -0.78289816362893000238, -1.6546990871336681441, -0.85864811320757066212, 1.7960418523846287232, 0.71714821312436342884},
            {0.25, 0.0, 0.2491335703197571641, 0.0, -0.82466306258094565309, 0.0, -0.54254326466191372953, 0.0, 1.0442826344437381945, 0.0},
            {0.17677669529663688651, 0.17677669529663687569, 0.17738935115398995617, 0.17616173766104897661, -0.80911938627521916259, 0.76977321991145556311, -0.63295764861417017313, 0.97841245803743094036, 0.98528112393626814822, -0.62363375572945104943},
            {1.5308084989341914715e-17, 0.25, 1.5468043259937507815e-17, 0.2508696848909122325, -0.79341294955282596203, 1.5707963267948965561, -0.82466306258094563794, 1.819929897114653724, 0.82466306258094566823, -1.3216627564751393958},
            {-0.17677669529663686486, 0.17677669529663689734, -0.17738935115398993475, 0.17616173766104899848, -0.80911938627521915876, 2.3718194336783375529, -0.98528112393626813018, 2.517958897860342088, 0.63295764861417019883, -2.1631801955523621542},
            {-0.25, 3.0616169978683829431e-17, -0.2491335703197571641, 3.0298246679137807606e-17, -0.82466306258094565309, 3.1415926535897931198, -1.0442826344437381945, 3.1415926535897931431, 0.54254326466191372953, -3.1415926535897930812},
            {-0.17677669529663690816, -0.17677669529663685404, -0.1773893511539899776, -0.17616173766104895473, -0.80911938627521916642, -2.3718194336783377978, -0.98528112393626816627, -2.5179588978603422901, 0.63295764861417014743, 2.163180195552362442},
            {-4.5924254968025744146e-17, -0.25, -4.6404129781529084775e-17, -0.2508696848909122325, -0.79341294955282596203, -1.5707963267948968087, -0.82466306258094569853, -1.8199298971146539613, 0.82466306258094560764, 1.3216627564751396331},
            {0.17677669529663684321, -0.17677669529663691899, 0.17738935115398991333, -0.17616173766104902036, -0.80911938627521915494, -0.769773219911455808, -0.63295764861417022453, -0.97841245803743122809, 0.98528112393626811213, 0.62363375572945125148},
            {0.5, 0.0, 0.49310741804306668916, 0.0, -0.17778407880661290134, 0.0, 0.45421990486317357992, 0.0, 0.55977359477616081175, 0.0},
            {0.35355339059327377302, 0.35355339059327375138, 0.3584268697133189464, 0.34860625536259795411, -0.11658254521497154353, 0.72290178026868503268, 0.23202371014762644078, 1.2063214162395304511, 0.46518880057756951253, -0.48946767681289259981},
            {3.0616169978683829431e-17, 0.5, 3.190788489546069124e-17, 0.50699674981966719583, -0.052776844956493615913, 1.5707963267948965502, -0.17778407880661287198, 2.0639037448379632547, 0.17778407880661293069, -1.0776889087518298763},
            {-0.35355339059327372973, 0.35355339059327379467, -0.35842686971331890493, 0.34860625536259799919, -0.11658254521497152822, 2.4186908733211080836, -0.46518880057756948275, 2.652124976776900558, -0.2320237101476263804, -1.9352712373502626237},
            {-0.5, 6.1232339957367658861e-17, -0.49310741804306668916, 5.8712695126944314728e-17, -0.17778407880661290134, 3.141592653589793131, -0.55977359477616081175, 3.1415926535897931642, -0.45421990486317357992, -3.1415926535897930366},
            {-0.35355339059327381632, -0.35355339059327370808, -0.35842686971331898787, -0.34860625536259790903, -0.11658254521497155883, -2.4186908733211083279, -0.4651888005775695423, -2.6521249767769007193, -0.23202371014762650116, 1.9352712373502629509},
            {-9.1848509936051488292e-17, -0.5, -9.5723654690421041556e-17, -0.50699674981966719583, -0.052776844956493615913, -1.5707963267948968264, -0.1777840788066129894, -2.0639037448379634696, 0.17778407880661281327, 1.0776889087518300913},
            {0.35355339059327368643, -0.35355339059327383797, 0.35842686971331886346, -0.34860625536259804427, -0.11658254521497151291, -0.72290178026868527697, 0.23202371014762632001, -1.2063214162395307784, 0.46518880057756945298, 0.48946767681289276116},
            {1.0, 0.0, 0.94608307036718301494, 0.0, 0.33740392290096813466, 0.0, 1.8951178163559367555, 0.0, 0.21938393439552027368, 0.0},
            {0.70710678118654754605, 0.70710678118654750275, 0.74519215535365930209, 0.66666481741950631398, 0.56680209825930888934, 0.53562961732242986806, 1.233466915678815284, 1.7803588648261259588, 0.099862719160197444251, -0.28997455411880742612},
            {6.1232339957367658861e-17, 1.0, 7.1960319005373041642e-17, 1.0572508753757285146, 0.83786694098020824089, 1.5707963267948965247, 0.33740392290096818619, 2.5168793971620796011, -0.33740392290096808314, -0.62471325642771357121},
            {-0.70710678118654745945, 0.70710678118654758935, -0.74519215535365923063, 0.66666481741950641427, 0.5668020982593089504, 2.605963036267363253, -0.099862719160197405024, 2.8516180994709857664, -1.2334669156788151226, -1.3612337887636670908},
            {-1.0, 1.2246467991473531772e-16, -0.94608307036718301494, 1.0305047480945999774e-16, 0.33740392290096813466, 3.1415926535897931723, -0.21938393439552027368, 3.1415926535897931934, -1.8951178163559367555, -3.1415926535897929056},
            {-0.70710678118654763265, -0.70710678118654741616, -0.74519215535365937355, -0.66666481741950621369, 0.56680209825930882828, -2.6059630362673634878, -0.099862719160197483478, -2.8516180994709858582, -1.2334669156788154453, 1.3612337887636674684},
            {-1.8369701987210297658e-16, -1.0, -2.158809570266204413e-16, -1.0572508753757285146, 0.83786694098020824089, -1.5707963267948969027, 0.33740392290096798009, -2.5168793971620797334, -0.33740392290096828924, 0.62471325642771370354},
            {0.70710678118654737286, -0.70710678118654767594, 0.74519215535365915917, -0.66666481741950651456, 0.56680209825930901147, -0.53562961732243010279, 1.2334669156788149613, -1.7803588648261263365, 0.099862719160197365796, 0.28997455411880751794},
            {1.5, 0.0, 1.3246835311721196804, 0.0, 0.47035631719539988668, 0.0, 3.301285449129797838, 0.0, 0.1000195824066326519, 0.0},
            {1.0606601717798213191, 1.0606601717798212541, 1.1839593855572855609, 0.9194789610047786165, 0.93002583013377829907, 0.22553329329273497242, 1.8495047911385570699, 2.5292224190594471214, -0.010546869128999664075, -0.16130364794487607552},
            {9.1848509936051488292e-17, 1.5, 1.3038076345658281264e-16, 1.7006525157682152449, 1.600632933361582593, 1.5707963267948964752, 0.47035631719539994775, 2.8954798579670162953, -0.4703563171953998256, -0.24611279562277693453},
            {-1.0606601717798211892, 1.060660171779821384, -1.1839593855572854849, 0.91947896100477878934, 0.93002583013377843491, 2.9160593602970581693, 0.010546869128999701077, 2.9802890056449171422, -1.8495047911385567612, -0.61237023453034594437},
            {-1.5, 1.8369701987210297658e-16, -1.3246835311721196804, 1.2215790424776667532e-16, 0.47035631719539988668, 3.1415926535897932298, -0.1000195824066326519, 3.1415926535897932111, -3.301285449129797838, -3.1415926535897926896},
            {-1.060660171779821449, -1.0606601717798211242, -1.1839593855572856369, -0.91947896100477844366, 0.93002583013377816324, -2.9160593602970583627, 0.010546869128999627072, -2.9802890056449171836, -1.8495047911385573786, 0.6123702345303462898},
            {-2.7554552980815446488e-16, -1.5, -3.9114229038065365107e-16, -1.7006525157682152449, 1.600632933361582593, -1.5707963267948970514, 0.47035631719539970344, -2.8954798579670163126, -0.47035631719540006991, 0.24611279562277695186},
            {1.0606601717798210593, -1.0606601717798215139, 1.1839593855572854089, -0.91947896100477896218, 0.93002583013377857075, -0.22553329329273516584, 1.8495047911385564526, -2.5292224190594474668, -0.010546869128999738079, 0.16130364794487611693},
            {2.0, 0.0, 1.6054129768026948486, 0.0, 0.4229808287748649957, 0.0, 4.9542343560018901634, 0.0, 0.048900510708061119567, 0.0},
            {1.4142135623730950921, 1.4142135623730950055, 1.6883194933582990243, 1.0649044719839209475, 1.1044891171909028954, -0.19981522706084708457, 2.1693935891748240916, 3.4589310472140426889, -0.039584645206981933184, -0.08229206049744467714},
            {1.2246467991473531772e-16, 2.0, 2.2208114946641807464e-16, 2.5015674333549756415, 2.4526669226469145219, 1.5707963267948963889, 0.42298082877486505138, 3.1762093035975914933, -0.42298082877486494002, 0.034616650007798203864},
            {-1.4142135623730949189, 1.4142135623730951787, -1.6883194933582989874, 1.0649044719839212109, 1.1044891171909031294, 3.3414078806506402814, 0.039584645206981962593, 3.0593005930923485567, -2.169393589174823594, 0.31733839362424952895},
            {-2.0, 2.4492935982947063545e-16, -1.6054129768026948486, 1.1135681831696612616e-16, 0.4229808287748649957, 3.1415926535897932894, -0.048900510708061119567, 3.1415926535897932219, -4.9542343560018901634, -3.1415926535897923336},
            {-1.4142135623730952653, -1.4142135623730948323, -1.6883194933582990613, -1.064904471983920684, 1.1044891171909026613, -3.3414078806506403646, 0.039584645206981903775, -3.059300593092348566, -2.1693935891748245892, -0.31733839362424937184},
            {-3.6739403974420595317e-16, -2.0, -6.6624344842268023737e-16, -2.5015674333549756415, 2.4526669226469145219, -1.5707963267948973103, 0.42298082877486482866, -3.1762093035975913914, -0.42298082877486516273, -0.03461665000779830579},
            {1.4142135623730947457, -1.4142135623730953519, 1.6883194933582989504, -1.0649044719839214744, 1.1044891171909033635, 0.19981522706084700137, 2.1693935891748230965, -3.458931047214042846, -0.039584645206981992002, 0.082292060497444686426},
            {5.0, 0.0, 1.5499312449446741373, 0.0, -0.19002974965664387862, 0.0, 40.185275355803177455, 0.0, 0.0011482955912753257973, 0.0},
            {3.5355339059327377302, 3.5355339059327375138, 3.6871508611543429709, -3.157181373909001357, -3.1547681046716106125, -2.1118502909279661892, -6.311949478580612776, 7.3697974788772077195, -0.0024132692373907452624, 0.0045042434314801607547},
            {3.0616169978683829431e-16, 5.0, 4.5436362172750887551e-15, 20.09321182569722639, 20.092063530105951065, 1.5707963267948920752, -0.19002974965664393734, 3.1207275717395707391, 0.1900297496566438199, -0.020865081850222464588},
            {-3.5355339059327372973, 3.5355339059327379467, -3.6871508611543449094, -3.1571813739090021642, -3.1547681046716114182, 5.2534429445177613695, 0.0024132692373907438925, 3.1460968970212734025, 6.3119494785806111631, 4.2282048252874106008},
            {-5.0, 6.1232339957367658861e-16, -1.5499312449446741373, -1.174343542809398959e-16, -0.19002974965664387862, 3.1415926535897932037, -0.0011482955912753257973, 3.1415926535897932376, -40.185275355803177455, -3.1415926535897750631},
            {-3.5355339059327381632, -3.5355339059327370808, -3.6871508611543410324, 3.1571813739090005499, -3.1547681046716098067, -5.2534429445177574859, 0.0024132692373907466323, -3.1460968970212733959, 6.3119494785806143889, -4.2282048252874183613},
            {-9.1848509936051488292e-16, -5.0, -1.3630908648516543815e-14, -20.09321182569722639, 20.092063530105951065, -1.5707963267949102514, -0.19002974965664370247, -3.1207275717395708086, 0.19002974965664405477, 0.020865081850222534065},
            {3.5355339059327368643, -3.5355339059327383797, 3.6871508611543468479, 3.1571813739090029713, -3.154768104671612224, 2.1118502909279700728, -6.3119494785806095501, -7.3697974788771999589, -0.0024132692373907425226, -0.004504243431480167346},
            {10.0, 0.0, 1.6583475942188740493, 0.0, -0.045456433004455372635, 0.0, 2492.2289762418777591, 0.0, 4.1569689296853242774e-6, 0.0},
            {7.0710678118654754605, 7.0710678118654750275, -3.7745175303432929615, 62.642575559232345941, 62.642571122904060317, 5.3452347019798827768, 125.28514668213645736, -7.5489559055283299711, 4.4363282856236060522e-6, -0.000079155158306803868409},
            {6.1232339957367658861e-16, 10.0, 6.7436601941373126554e-13, 1246.1144901994233444, 1246.1144860424544147, 1.5707963267942222532, -0.045456433004455405946, 3.2291439210137707199, 0.045456433004455339323, 0.087551267423977378721},
            {-7.0710678118654745945, 7.0710678118654758935, 3.7745175303433438135, 62.642575559232397046, 62.642571122904111422, -2.2036420483901403904, -4.4363282856235323221e-6, 3.1415134984314864345, -125.28514668213635515, -10.690548559118021506},
            {-10.0, 1.2246467991473531772e-15, -1.6583475942188740493, -6.6623371218859982286e-17, -0.045456433004455372635, 3.1415926535897933412, -4.1569689296853242774e-6, 3.1415926535897932385, -2492.2289762418777591, -3.1415926535870957744},
            {-7.0710678118654763265, -7.0710678118654741616, 3.7745175303432421091, -62.642575559232294835, 62.642571122904009212, 2.2036420483900386859, -4.4363282856236797822e-6, -3.1415134984314864347, -125.28514668213655957, 10.690548559118224914},
            {-1.8369701987210297658e-15, -10.0, -2.0230980582411937966e-12, -1246.1144901994233444, 1246.1144860424544147, -1.5707963267969197173, -0.045456433004455272699, -3.2291439210137705144, 0.04545643300445547257, -0.087551267423977584235},
            {7.0710678118654737286, -7.0710678118654767594, -3.7745175303433946658, -62.642575559232448152, 62.642571122904162528, -5.3452347019799844813, 125.28514668213625294, 7.5489559055281265623, 4.4363282856234585915e-6, 0.000079155158306804015139},
            {15.0, 0.0, 1.6181944437083687391, 0.0, 0.046278677674360439604, 0.0, 234955.85249076830358, 0.0, 1.9186278921478669771e-8, 0.0},
            {10.606601717798213191, 10.606601717798212541, -471.05515346873571713, -1328.2594907541181068, -1328.2594913017652105, 472.62595127241629118, -2656.5189820558856064, -942.11030841435617353, 5.4764710367805069957e-7, 1.4768856774331466472e-6},
            {9.1848509936051488292e-16, 15.0, 1.0008479153886857898e-10, 117477.92624539374493, 117477.92624537455865, 1.5707963266948118277, 0.046278677674360479423, 3.1889907705032654049, -0.046278677674360399786, 0.047398116913472073375},
            {-10.606601717798211892, 10.60660171779821384, 471.05515346873477896, -1328.2594907541203959, -1328.2594913017674995, -469.48435861882555978, -5.4764710367805350438e-7, 3.1415941304754706716, 2656.5189820558810283, -945.2519010679478431},
            {-15.0, 1.8369701987210297658e-15, -1.6181944437083687391, 7.9637292204322254463e-17, 0.046278677674360439604, 3.1415926535897933315, -1.9186278921478669771e-8, 3.1415926535897932385, -234955.85249076830358, -3.1415926531894540723},
            {-10.60660171779821449, -10.606601717798211242, 471.05515346873665531, 1328.2594907541158178, -1328.2594913017629215, 469.48435861882743613, -5.4764710367804789476e-7, -3.1415941304754706716, 2656.5189820558901845, 945.25190106794409045},
            {-2.7554552980815446488e-15, -15.0, -3.0025437461660077385e-10, -117477.92624539374493, 117477.92624537455865, -1.5707963270951509938, 0.046278677674360320148, -3.1889907705032652188, -0.04627867767436055906, -0.047398116913472259445},
            {10.606601717798210593, -10.606601717798215139, -471.05515346873384079, 1328.2594907541226849, -1328.2594913017697886, -472.62595127241441484, -2656.5189820558764503, 942.11030841435992621, 5.4764710367805630921e-7, -1.4768856774331489463e-6},
            {20.0, 0.0, 1.5482417010434398402, 0.0, 0.04441982084535331654, 0.0, 25615652.66405658882, 0.0, 9.8355252906498816904e-11, 0.0},
            {14.142135623730950921, 14.142135623730950055, 24486.68965358318626, 26235.092183360235647, 26235.092183384186671, -24485.118857281672279, 52470.184366744507202, 48973.379307191653857, -2.3951024244493564362e-8, -2.5280915398646225218e-8},
            {1.2246467991473531772e-15, 20.0, 1.4853900090407493933e-8, 12807826.332028294459, 12807826.332028294361, 1.5707963119409965288, 0.044419820845353372442, 3.1190380278383364344, -0.044419820845353260638, -0.02255462575145675408},
            {-14.142135623730949189, 14.142135623730951787, -24486.689653583186682, 26235.092183360320531, 26235.092183384271555, 24488.260449935262494, 2.3951024244493652701e-8, 3.1415926283088778398, -52470.184366744337435, 48970.23771453806322},
            {-20.0, 2.4492935982947063545e-15, -1.5482417010434398402, 1.1180354790034662799e-16, 0.04441982084535331654, 3.1415926535897931885, -9.8355252906498816904e-11, 3.1415926535897932385, -25615652.66405658882, -3.1415925941741928768},
            {-14.142135623730952653, -14.142135623730948323, -24486.689653583185838, -26235.092183360150763, 26235.092183384101787, -24488.26044993526165, 2.3951024244493476023e-8, -3.1415926283088778398, -52470.184366744676971, -48970.237714538064908},
            {-3.6739403974420595317e-15, -20.0, -4.4561700271222483452e-8, -12807826.332028294459, 12807826.332028294361, -1.5707963713565968905, 0.044419820845353148834, -3.1190380278383365344, -0.044419820845353484245, 0.022554625751456854031},
            {14.142135623730947457, -14.142135623730953519, 24486.689653583187103, -26235.092183360405415, 26235.09218338435644, 24485.118857281673122, 52470.184366744167666, -48973.37930719165217, -2.3951024244493741041e-8, 2.528091539864622434e-8},
            {24.989999999999998437, 0.0, 1.5315374843262580141, 0.0, -0.0072448862399538447391, 0.0, 2977286754.0962403117, 0.0, 5.4047414055481939457e-13, 0.0},
            {17.67059846185182207, 17.670598461851820988, -885673.16331345207799, -400248.00540652140574, -400248.00540652215797, 885674.7341097792085, -800496.01081304623667, -1771346.3266269055961, 7.5223231588352466724e-10, 3.3560562518531656391e-10},
            {1.5301961755346176992e-15, 24.989999999999998437, 2.1825789542468514196e-6, 1488643377.0481201559, 1488643377.0481201559, 1.5707941442159423724, -0.0072448862399538534498, 3.1023338111211545727, 0.0072448862399538360284, -0.039258842468638544566},
            {-17.670598461851819906, 17.670598461851823152, 885673.16331345318248, -400248.0054065240787, -400248.00540652483093, -885671.59251712672318, -7.5223231588352706351e-10, 3.1415926539253988636, 800496.01081304089075, -1771349.4682195569769},
            {-24.989999999999998437, 3.0603923510692353985e-15, -1.5315374843262580141, -1.7421457417638512695e-17, -0.0072448862399538447391, 3.1415926535897931172, -5.4047414055481939457e-13, 3.1415926535897932385, -2977286754.0962403117, -3.1415839232739762511},
            {-17.670598461851824234, -17.670598461851818824, 885673.16331345097349, 400248.00540651873277, -400248.005406519485, 885671.5925171245142, -7.5223231588352227096e-10, -3.1415926539253988636, 800496.01081305158263, 1771349.4682195613948},
            {-4.5905885266038530977e-15, -24.989999999999998437, -6.5477368627405542588e-6, -1488643377.0481201559, 1488643377.0481201559, -1.5708028745317593598, -0.0072448862399538186069, -3.1023338111211548151, 0.0072448862399538708713, 0.039258842468638787005},
            {17.670598461851817742, -17.670598461851825316, -885673.16331345428695, 400248.00540652675168, -400248.00540652750391, -885674.73410978141745, -800496.01081303554482, 1771346.3266269011781, 7.5223231588352945979e-10, -3.3560562518531458362e-10}
    };

    const Real tol = 1e-10;

    for (const auto& i : data) {
        const Real x = i[0];
        const Real y = (std::abs(i[1]) < 1e-12) ? 0.0 : i[1];
        const std::complex<Real> z(x, y);


        const std::complex<Real> si = Si(z);
        std::complex<Real> ref(i[2], i[3]);
        Real diff = std::abs(si-ref)/std::abs(ref);
        if (diff > tol
            || (std::abs(ref.real()) < tol && std::abs(si.real()) > tol)
            || (std::abs(ref.imag()) < tol && std::abs(si.imag()) > tol)) {
            integrals_test::reportSiCiFail("Si", z, si, ref, diff, tol);
        }

        const std::complex<Real> ci = Ci(z);
        ref = std::complex<Real>(i[4], i[5]);
        diff = std::min(std::abs(ci-ref), std::abs(ci-ref)/std::abs(ref));
        if (diff > tol
            || (std::abs(ref.real()) < tol && std::abs(ci.real()) > tol)
            || (std::abs(ref.imag()) < tol && std::abs(ci.imag()) > tol)) {
            integrals_test::reportSiCiFail("Ci", z, ci, ref, diff, tol);
        }

        const std::complex<Real> ei = Ei(z);
        ref = std::complex<Real>(i[6], i[7]);
        diff = std::abs(ei-ref)/std::abs(ref);
        if (diff > tol
            || (std::abs(ref.real()) < tol && std::abs(ei.real()) > tol)
            || (std::abs(ref.imag()) < tol && std::abs(ei.imag()) > tol)) {
            integrals_test::reportSiCiFail("Ei", z, ei, ref, diff, tol);
        }

        const std::complex<Real> e1 = E1(z);
        ref = std::complex<Real>(i[8], i[9]);
        diff = std::min(std::abs(e1-ref), std::abs(e1-ref)/std::abs(ref));
        if (std::abs(z) < 10.0)
            if (diff > tol
            || (std::abs(ref.real()) < tol && std::abs(e1.real()) > tol)
            || (std::abs(ref.imag()) < tol && std::abs(e1.imag()) > tol)) {
            integrals_test::reportSiCiFail("E1", z, e1, ref, diff, tol);
        }
    }
}



void IntegralTest::testRealSiCiIntegrals() {
    BOOST_TEST_MESSAGE("Testing real Ci and Si...");

    using namespace ExponentialIntegral;

    // reference values are calculated with Mathematica or Python/mpmath
    const Real data[][3] = {
            {1e-12, 1e-12, -27.0538054510270153677},
            {0.1, 0.09994446110827695570, -1.7278683866572965838},
            {1.0, 0.9460830703671830149, 0.3374039229009681347},
            {1.9999, 1.6053675097543679041, 0.4230016343635392},
            {3.9999, 1.758222058430840841, -0.140965355646150101},
            {4.0001, 1.758184218306157867, -0.140998037827177150},
            {5.0, 1.5499312449446741373, -0.19002974965664387862},
            {7.0, 1.4545966142480935906, 0.076695278482184518383,},
            {10.0, 1.6583475942188740493, -0.045456433004455372635},
            {15.0, 1.6181944437083687391, 0.046278677674360439604},
            {20.0, 1.5482417010434398402, 0.04441982084535331654},
            {24.9, 1.532210740207620024, -0.010788215638781789846},
            {25.1, 1.5311526281483412938, -0.0028719014454227088097},
            {30.0, 1.566756540030351111, -0.033032417282071143779},
            {40.0, 1.5869851193547845068, 0.019020007896208766962},
            {400.0, 1.5721148692738117518, -0.00212398883084634893},
            {4000.0, 1.5709788562309441985, -0.00017083030544201591130}
    };


    const Real tol = 1e-12;

    for (const auto& i : data) {
        Real x = i[0];
        Real si = Si(x);

        Real diff = std::fabs(si - i[1]);
        if (diff > tol) {
            integrals_test::reportSiCiFail("SineIntegral", x, si, i[1], diff, tol);
        }

        const Real ci = Ci(x);
        diff = std::fabs(ci - i[2]);
        if (diff > tol) {
            integrals_test::reportSiCiFail("CosineIntegral", x, ci, i[2], diff, tol);
        }

        x = -i[0];
        si = Si(x);
        diff = std::fabs(si + i[1]);
        if (diff > tol) {
            integrals_test::reportSiCiFail("SineIntegral", x, si, -i[1], diff, tol);
        }
    }
}

test_suite* IntegralTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Integration tests");
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testSegment));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testTrapezoid));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testMidPointTrapezoid));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testSimpson));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testGaussKronrodAdaptive));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testGaussKronrodNonAdaptive));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testGaussLobatto));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testTwoDimensionalIntegration));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testFolinIntegration));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testDiscreteIntegrals));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testDiscreteIntegrator));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testPiecewiseIntegral));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testExponentialIntegral));
    suite->add(QUANTLIB_TEST_CASE(&IntegralTest::testRealSiCiIntegrals));
    return suite;
}

]]></document_content>
  </document>
  <document index="155">
    <source>integrals.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_integrals_hpp
#define quantlib_test_integrals_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class IntegralTest {
  public:
    static void testSegment();
    static void testTrapezoid();
    static void testMidPointTrapezoid();
    static void testSimpson();
    static void testGaussKronrodAdaptive();
    static void testGaussKronrodNonAdaptive();
    static void testGaussLobatto();
    static void testTwoDimensionalIntegration();
    static void testFolinIntegration();
    static void testDiscreteIntegrals();
    static void testDiscreteIntegrator();
    static void testPiecewiseIntegral();
    static void testRealSiCiIntegrals();
    static void testExponentialIntegral();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="156">
    <source>interestrates.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "interestrates.hpp"
#include "utilities.hpp"
#include <ql/interestrate.hpp>
#include <ql/math/rounding.hpp>
#include <ql/math/comparison.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <iomanip>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    struct InterestRateData {
        Rate r;
        Compounding comp;
        Frequency freq;
        Time t;
        Compounding comp2;
        Frequency freq2;
        Rate expected;
        Size precision;
    };

}


void InterestRateTest::testConversions() {
    BOOST_TEST_MESSAGE("Testing interest-rate conversions...");

    InterestRateData cases[] = {
        // data from "Option Pricing Formulas", Haug, pag.181-182
        // Rate,Compounding,        Frequency,   Time, Compounding2,      Frequency2,  Rate2, precision
        {0.0800, Compounded,        Quarterly,   1.00, Continuous,            Annual, 0.0792, 4},
        {0.1200, Continuous,           Annual,   1.00, Compounded,            Annual, 0.1275, 4},
        {0.0800, Compounded,        Quarterly,   1.00, Compounded,            Annual, 0.0824, 4},
        {0.0700, Compounded,        Quarterly,   1.00, Compounded,        Semiannual, 0.0706, 4},
        // undocumented, but reasonable :)
        {0.0100, Compounded,           Annual,   1.00,     Simple,            Annual, 0.0100, 4},
        {0.0200,     Simple,           Annual,   1.00, Compounded,            Annual, 0.0200, 4},
        {0.0300, Compounded,       Semiannual,   0.50,     Simple,            Annual, 0.0300, 4},
        {0.0400,     Simple,           Annual,   0.50, Compounded,        Semiannual, 0.0400, 4},
        {0.0500, Compounded, EveryFourthMonth,  1.0/3,     Simple,            Annual, 0.0500, 4},
        {0.0600,     Simple,           Annual,  1.0/3, Compounded,  EveryFourthMonth, 0.0600, 4},
        {0.0500, Compounded,        Quarterly,   0.25,     Simple,            Annual, 0.0500, 4},
        {0.0600,     Simple,           Annual,   0.25, Compounded,         Quarterly, 0.0600, 4},
        {0.0700, Compounded,        Bimonthly,  1.0/6,     Simple,            Annual, 0.0700, 4},
        {0.0800,     Simple,           Annual,  1.0/6, Compounded,         Bimonthly, 0.0800, 4},
        {0.0900, Compounded,          Monthly, 1.0/12,     Simple,            Annual, 0.0900, 4},
        {0.1000,     Simple,           Annual, 1.0/12, Compounded,           Monthly, 0.1000, 4},

        {0.0300, SimpleThenCompounded,       Semiannual,   0.25,               Simple,            Annual, 0.0300, 4},
        {0.0300, SimpleThenCompounded,       Semiannual,   0.25,               Simple,        Semiannual, 0.0300, 4},
        {0.0300, SimpleThenCompounded,       Semiannual,   0.25,               Simple,         Quarterly, 0.0300, 4},
        {0.0300, SimpleThenCompounded,       Semiannual,   0.50,               Simple,            Annual, 0.0300, 4},
        {0.0300, SimpleThenCompounded,       Semiannual,   0.50,               Simple,        Semiannual, 0.0300, 4},
        {0.0300, SimpleThenCompounded,       Semiannual,   0.75,           Compounded,        Semiannual, 0.0300, 4},

        {0.0400,               Simple,       Semiannual,   0.25, SimpleThenCompounded,         Quarterly, 0.0400, 4},
        {0.0400,               Simple,       Semiannual,   0.25, SimpleThenCompounded,        Semiannual, 0.0400, 4},
        {0.0400,               Simple,       Semiannual,   0.25, SimpleThenCompounded,            Annual, 0.0400, 4},

        {0.0400,           Compounded,        Quarterly,   0.50, SimpleThenCompounded,         Quarterly, 0.0400, 4},
        {0.0400,               Simple,       Semiannual,   0.50, SimpleThenCompounded,        Semiannual, 0.0400, 4},
        {0.0400,               Simple,       Semiannual,   0.50, SimpleThenCompounded,            Annual, 0.0400, 4},

        {0.0400,           Compounded,        Quarterly,   0.75, SimpleThenCompounded,         Quarterly, 0.0400, 4},
        {0.0400,           Compounded,       Semiannual,   0.75, SimpleThenCompounded,        Semiannual, 0.0400, 4},
        {0.0400,               Simple,       Semiannual,   0.75, SimpleThenCompounded,            Annual, 0.0400, 4}
    };

    Rounding roundingPrecision;
    Rate r3, r2;
    Date d1 = Date::todaysDate(), d2;
    InterestRate ir, ir2, ir3, expectedIR;
    Real compoundf, error;
    DiscountFactor disc;


    for (auto& i : cases) {
        ir = InterestRate(i.r, Actual360(), i.comp, i.freq);
        d2 = d1 + timeToDays(i.t);
        roundingPrecision = Rounding(i.precision);

        // check that the compound factor is the inverse of the discount factor
        compoundf = ir.compoundFactor(d1, d2);
        disc = ir.discountFactor(d1, d2);
        error = std::fabs(disc-1.0/compoundf);
        if (error>1e-15)
            BOOST_FAIL("\n  " << ir
                       << std::setprecision(16)
                       << "\n  1.0/compound_factor: " << 1.0/compoundf
                       << "\n  discount_factor:     " << disc
                       << "\n  error:               " << error);

        // check that the equivalent InterestRate with *same* daycounter,
        // compounding, and frequency is the *same* InterestRate
        ir2 = ir.equivalentRate(ir.dayCounter(),
                                ir.compounding(),
                                ir.frequency(),
                                d1, d2);
        error = std::fabs(ir.rate()-ir2.rate());
        if (error>1e-15)
            BOOST_FAIL(std::setprecision(12)
                       << "\n    original interest rate: " << ir
                       << "\n  equivalent interest rate: " << ir2
                       << "\n                rate error: " << error);
        if (ir.dayCounter()!=ir2.dayCounter())
            BOOST_FAIL("\n day counter error"
                       << "\n original interest rate:   " << ir
                       << "\n equivalent interest rate: " << ir2);
        if (ir.compounding()!=ir2.compounding())
            BOOST_FAIL("\n compounding error"
                       << "\n original interest rate:   " << ir
                       << "\n equivalent interest rate: " << ir2);
        if (ir.frequency()!=ir2.frequency())
            BOOST_FAIL("\n frequency error"
                       << "\n    original interest rate: " << ir
                       << "\n  equivalent interest rate: " << ir2);

        // check that the equivalent rate with *same* daycounter,
        // compounding, and frequency is the *same* rate
        r2 = ir.equivalentRate(ir.dayCounter(),
                               ir.compounding(),
                               ir.frequency(),
                               d1, d2);
        error = std::fabs(ir.rate()-r2);
        if (error>1e-15)
            BOOST_FAIL(std::setprecision(12)
                       << "\n    original rate: " << ir
                       << "\n  equivalent rate: " << io::rate(r2)
                       << "\n            error: " << error);

        // check that the equivalent InterestRate with *different*
        // compounding, and frequency is the *expected* InterestRate
        ir3 = ir.equivalentRate(ir.dayCounter(), i.comp2, i.freq2, d1, d2);
        expectedIR = InterestRate(i.expected, ir.dayCounter(), i.comp2, i.freq2);
        r3 = roundingPrecision(ir3.rate());
        error = std::fabs(r3-expectedIR.rate());
        if (error>1.0e-17)
            BOOST_FAIL(std::setprecision(i.precision + 1)
                       << "\n               original interest rate: " << ir
                       << "\n  calculated equivalent interest rate: " << ir3
                       << "\n            truncated equivalent rate: " << io::rate(r3)
                       << "\n    expected equivalent interest rate: " << expectedIR
                       << "\n                           rate error: " << error);
        if (ir3.dayCounter()!=expectedIR.dayCounter())
            BOOST_FAIL("\n day counter error"
                       << "\n    original interest rate: " << ir3
                       << "\n  equivalent interest rate: " << expectedIR);
        if (ir3.compounding()!=expectedIR.compounding())
            BOOST_FAIL("\n compounding error"
                       << "\n    original interest rate: " << ir3
                       << "\n  equivalent interest rate: " << expectedIR);
        if (ir3.frequency()!=expectedIR.frequency())
            BOOST_FAIL("\n frequency error"
                       << "\n    original interest rate: " << ir3
                       << "\n  equivalent interest rate: " << expectedIR);

        // check that the equivalent rate with *different*
        // compounding, and frequency is the *expected* rate
        r3 = ir.equivalentRate(ir.dayCounter(), i.comp2, i.freq2, d1, d2);
        r3 = roundingPrecision(r3);
        error = std::fabs(r3 - i.expected);
        if (error>1.0e-17)
            BOOST_FAIL(std::setprecision(i.precision - 2)
                       << "\n  calculated equivalent rate: " << io::rate(r3)
                       << "\n    expected equivalent rate: " << io::rate(i.expected)
                       << "\n                       error: " << error);
    }
}

test_suite* InterestRateTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Interest Rate tests");
    suite->add(QUANTLIB_TEST_CASE(&InterestRateTest::testConversions));
    return suite;
}

]]></document_content>
  </document>
  <document index="157">
    <source>interestrates.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_interestrates_hpp
#define quantlib_test_interestrates_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class InterestRateTest {
  public:
    static void testConversions();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="158">
    <source>interpolations.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2005, 2006 StatPro Italia srl
 Copyright (C) 2009 Dimitri Reiswich
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_interpolations_hpp
#define quantlib_test_interpolations_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class InterpolationTest {
  public:
    // cubic spline tests
    static void testSplineOnGenericValues();
    static void testSimmetricEndConditions();
    static void testDerivativeEndConditions();
    static void testNonRestrictiveHymanFilter();
    static void testSplineOnRPN15AValues();
    static void testSplineOnGaussianValues();
    static void testSplineErrorOnGaussianValues();
    static void testMultiSpline();
    static void testAsFunctor();
    static void testFritschButland();
    // other interpolations
    static void testBackwardFlat();
    static void testForwardFlat();
    static void testSabrInterpolation();
    static void testKernelInterpolation();
    static void testKernelInterpolation2D();
    static void testBicubicDerivatives();
    static void testBicubicUpdate();
    static void testUnknownRichardsonExtrapolation();
    static void testRichardsonExtrapolation();
    static void testNoArbSabrInterpolation();
    static void testSabrSingleCases();
    static void testFlochKennedySabrIsSmoothAroundATM();
    static void testLeFlochKennedySabrExample();
    static void testTransformations();
    static void testLagrangeInterpolation();
    static void testLagrangeInterpolationAtSupportPoint();
    static void testLagrangeInterpolationDerivative();
    static void testLagrangeInterpolationOnChebyshevPoints();
    static void testBSplines();
    static void testBackwardFlatOnSinglePoint();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="159">
    <source>jumpdiffusion.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "jumpdiffusion.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/jumpdiffusionengine.hpp>
#include <ql/processes/merton76process.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE_1
#define REPORT_FAILURE_1(greekName, payoff, exercise, s, q, r, today, v, \
                         intensity, meanLogJump, jumpVol, expected, \
                         calculated, error, tolerance) \
    BOOST_FAIL(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    underlying value: " << s << "\n" \
               << "    strike:           " << payoff->strike() <<"\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << "    intensity:        " << intensity << "\n" \
               << "    mean log-jump:    " << meanLogJump << "\n" \
               << "    jump volatility:  " << jumpVol << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        "  << tolerance);

#undef REPORT_FAILURE_2
#define REPORT_FAILURE_2(greekName, payoff, exercise, s, q, r, today, v, \
                         intensity, gamma, expected, calculated, \
                         error, tolerance) \
    BOOST_FAIL(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    underlying value: " << s << "\n" \
               << "    strike:           " << payoff->strike() <<"\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n" \
               << "    intensity:        " << intensity << "\n" \
               << "    gamma:            " << gamma << "\n\n" \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

namespace {

    struct HaugMertonData {
        Option::Type type;
        Real strike;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility
        Real jumpIntensity;
        Real gamma;
        Real result;   // result
        Real tol;      // tolerance
    };

}


void JumpDiffusionTest::testMerton76() {

    BOOST_TEST_MESSAGE("Testing Merton 76 jump-diffusion model "
                       "for European options...");

    SavedSettings backup;

    /* The data below are from
       "Option pricing formulas", E.G. Haug, McGraw-Hill 1998, pag 9

       Haug use the arbitrary truncation criterium of 11 terms in the sum,
       which doesn't guarantee convergence up to 1e-2.
       Using Haug's criterium Haug's values have been correctly reproduced.
       the following values have the right 1e-2 accuracy: any value different
       from Haug has been noted.
    */
    HaugMertonData values[] = {
        //        type, strike,   spot,    q,    r,    t,  vol, int, gamma, value, tol
        // gamma = 0.25, strike = 80
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.25, 20.67, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.25, 21.74, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.25, 23.63, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.25, 20.65, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.25, 21.70, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.25, 23.61, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.25, 20.64, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.25, 21.70, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.25, 23.61, 1e-2 }, // Haug 23.28
        // gamma = 0.25, strike = 90
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.25, 11.00, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.25, 12.74, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.25, 15.40, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.25, 10.98, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.25, 12.75, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.25, 15.42, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.25, 10.98, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.25, 12.75, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.25, 15.42, 1e-2 }, // Haug 15.20
        // gamma = 0.25, strike = 100
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.25,  3.42, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.25,  5.88, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.25,  8.95, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.25,  3.51, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.25,  5.96, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.25,  9.02, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.25,  3.53, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.25,  5.97, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.25,  9.03, 1e-2 }, // Haug 8.89
        // gamma = 0.25, strike = 110
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.25,  0.55, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.25,  2.11, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.25,  4.67, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.25,  0.56, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.25,  2.16, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.25,  4.73, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.25,  0.56, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.25,  2.17, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.25,  4.74, 1e-2 }, // Haug 4.66
        // gamma = 0.25, strike = 120
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.25,  0.10, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.25,  0.64, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.25,  2.23, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.25,  0.06, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.25,  0.63, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.25,  2.25, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.25,  0.05, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.25,  0.62, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.25,  2.25, 1e-2 }, // Haug 2.21

        // gamma = 0.50, strike = 80
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.50, 20.72, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.50, 21.83, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.50, 23.71, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.50, 20.66, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.50, 21.73, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.50, 23.63, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.50, 20.65, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.50, 21.71, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.50, 23.61, 1e-2 }, // Haug 23.28
        // gamma = 0.50, strike = 90
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.50, 11.04, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.50, 12.72, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.50, 15.34, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.50, 11.02, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.50, 12.76, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.50, 15.41, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.50, 11.00, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.50, 12.75, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.50, 15.41, 1e-2 }, // Haug 15.18
        // gamma = 0.50, strike = 100
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.50,  3.14, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.50,  5.58, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.50,  8.71, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.50,  3.39, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.50,  5.87, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.50,  8.96, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.50,  3.46, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.50,  5.93, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.50,  9.00, 1e-2 }, // Haug 8.85
        // gamma = 0.50, strike = 110
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.50,  0.53, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.50,  1.93, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.50,  4.42, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.50,  0.58, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.50,  2.11, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.50,  4.67, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.50,  0.57, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.50,  2.14, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.50,  4.71, 1e-2 }, // Haug 4.62
        // gamma = 0.50, strike = 120
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.50,  0.19, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.50,  0.71, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.50,  2.15, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.50,  0.10, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.50,  0.66, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.50,  2.23, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.50,  0.07, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.50,  0.64, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.50,  2.24, 1e-2 }, // Haug 2.19

        // gamma = 0.75, strike = 80
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.75, 20.79, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.75, 21.96, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.75, 23.86, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.75, 20.68, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.75, 21.78, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.75, 23.67, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.75, 20.66, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.75, 21.74, 1e-2 },
        { Option::Call,  80.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.75, 23.64, 1e-2 }, // Haug 23.30
        // gamma = 0.75, strike = 90
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.75, 11.11, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.75, 12.75, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.75, 15.30, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.75, 11.09, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.75, 12.78, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.75, 15.39, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.75, 11.04, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.75, 12.76, 1e-2 },
        { Option::Call,  90.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.75, 15.40, 1e-2 }, // Haug 15.17
        // gamma = 0.75, strike = 100
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.75,  2.70, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.75,  5.08, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.75,  8.24, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.75,  3.16, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.75,  5.71, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.75,  8.85, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.75,  3.33, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.75,  5.85, 1e-2 },
        { Option::Call, 100.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.75,  8.95, 1e-2 }, // Haug 8.79
        // gamma = 0.75, strike = 110
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.75,  0.54, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.75,  1.69, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.75,  3.99, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.75,  0.62, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.75,  2.05, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.75,  4.57, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.75,  0.60, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.75,  2.11, 1e-2 },
        { Option::Call, 110.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.75,  4.66, 1e-2 }, // Haug 4.56
        // gamma = 0.75, strike = 120
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25, 1.0,  0.75,  0.29, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25, 1.0,  0.75,  0.84, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25, 1.0,  0.75,  2.09, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25, 5.0,  0.75,  0.15, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25, 5.0,  0.75,  0.71, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25, 5.0,  0.75,  2.21, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.10, 0.25,10.0,  0.75,  0.11, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.25, 0.25,10.0,  0.75,  0.67, 1e-2 },
        { Option::Call, 120.00, 100.00, 0.00, 0.08, 0.50, 0.25,10.0,  0.75,  2.23, 1e-2 }  // Haug 2.17
};



    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    ext::shared_ptr<SimpleQuote> jumpIntensity(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> meanLogJump(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> jumpVol(new SimpleQuote(0.0));

    ext::shared_ptr<Merton76Process> stochProcess(
           new Merton76Process(Handle<Quote>(spot),
                               Handle<YieldTermStructure>(qTS),
                               Handle<YieldTermStructure>(rTS),
                               Handle<BlackVolTermStructure>(volTS),
                               Handle<Quote>(jumpIntensity),
                               Handle<Quote>(meanLogJump),
                               Handle<Quote>(jumpVol)));
    ext::shared_ptr<PricingEngine> engine(
                                       new JumpDiffusionEngine(stochProcess));

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);


        jumpIntensity->setValue(value.jumpIntensity);

        // delta in Haug's notation
        Real jVol = value.v * std::sqrt(value.gamma / value.jumpIntensity);
        jumpVol->setValue(jVol);

        // z in Haug's notation
        Real diffusionVol = value.v * std::sqrt(1.0 - value.gamma);
        vol  ->setValue(diffusionVol);

        // Haug is assuming zero meanJump
        Real meanJump = 0.0;
        meanLogJump->setValue(std::log(1.0+meanJump)-0.5*jVol*jVol);

        Volatility totalVol =
            std::sqrt(value.jumpIntensity * jVol * jVol + diffusionVol * diffusionVol);
        Volatility volError = std::fabs(totalVol - value.v);
        QL_REQUIRE(volError<1e-13,
                   volError << " mismatch");

        EuropeanOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > value.tol) {
            REPORT_FAILURE_2("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                             value.jumpIntensity, value.gamma, value.result, calculated, error,
                             value.tol);
        }
    }
}

void JumpDiffusionTest::testGreeks() {

    BOOST_TEST_MESSAGE("Testing jump-diffusion option greeks...");

    SavedSettings backup;

    std::map<std::string,Real> calculated, expected, tolerance;
    tolerance["delta"]  = 1.0e-4;
    tolerance["gamma"]  = 1.0e-4;
    tolerance["theta"]  = 1.1e-4;
    tolerance["rho"]    = 1.0e-4;
    tolerance["divRho"] = 1.0e-4;
    tolerance["vega"]   = 1.0e-4;

    Option::Type types[] = { Option::Put, Option::Call };
    Real strikes[] = { 50.0, 100.0, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { -0.05, 0.0, 0.05 };
    Rate rRates[] = { 0.0, 0.01, 0.2 };
    // The testsuite check fails if a too short maturity is chosen(i.e. 1 year).
    // The problem is in the theta calculation. With the finite difference(fd) method
    // we might get values too close to the jump steps, invalidating the fd methodology
    // for calculating greeks.
    Time residualTimes[] = { 5.0 };
    Volatility vols[] = { 0.11 };
    Real jInt[] = { 1.0, 5.0 };
    Real mLJ[] = { -0.20, 0.0, 0.20 };
    Volatility jV[] = { 0.01, 0.25 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    ext::shared_ptr<SimpleQuote> jumpIntensity(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> meanLogJump(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> jumpVol(new SimpleQuote(0.0));

    ext::shared_ptr<Merton76Process> stochProcess(
          new Merton76Process(Handle<Quote>(spot), qTS, rTS, volTS,
                              Handle<Quote>(jumpIntensity),
                              Handle<Quote>(meanLogJump),
                              Handle<Quote>(jumpVol)));

    ext::shared_ptr<StrikedTypePayoff> payoff;

    // The jumpdiffusionengine greeks are very sensitive to the
    // convergence level.  A tolerance of 1.0e-08 is usually
    // sufficient to get reasonable results
    ext::shared_ptr<PricingEngine> engine(
                                 new JumpDiffusionEngine(stochProcess,1e-08));

    for (auto& type : types) {
        for (double strike : strikes) {
            for (double& jj1 : jInt) {
                jumpIntensity->setValue(jj1);
                for (double& jj2 : mLJ) {
                    meanLogJump->setValue(jj2);
                    for (double& jj3 : jV) {
                        jumpVol->setValue(jj3);
                        for (double residualTime : residualTimes) {
                            Date exDate = today + timeToDays(residualTime);
                            ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
                            for (Size kk = 0; kk < 1; kk++) {
                                // option to check
                                if (kk == 0) {
                                    payoff = ext::shared_ptr<StrikedTypePayoff>(
                                        new PlainVanillaPayoff(type, strike));
                                } else if (kk == 1) {
                                    payoff = ext::shared_ptr<StrikedTypePayoff>(
                                        new CashOrNothingPayoff(type, strike, 100.0));
                                }
                                EuropeanOption option(payoff, exercise);
                                option.setPricingEngine(engine);

                                for (double u : underlyings) {
                                    for (double q : qRates) {
                                        for (double r : rRates) {
                                            for (double v : vols) {
                                                spot->setValue(u);
                                                qRate->setValue(q);
                                                rRate->setValue(r);
                                                vol->setValue(v);

                                                Real value = option.NPV();
                                                calculated["delta"] = option.delta();
                                                calculated["gamma"] = option.gamma();
                                                calculated["theta"] = option.theta();
                                                calculated["rho"] = option.rho();
                                                calculated["divRho"] = option.dividendRho();
                                                calculated["vega"] = option.vega();

                                                if (value > spot->value() * 1.0e-5) {
                                                    // perturb spot and get delta and gamma
                                                    Real du = u * 1.0e-5;
                                                    spot->setValue(u + du);
                                                    Real value_p = option.NPV(),
                                                         delta_p = option.delta();
                                                    spot->setValue(u - du);
                                                    Real value_m = option.NPV(),
                                                         delta_m = option.delta();
                                                    spot->setValue(u);
                                                    expected["delta"] =
                                                        (value_p - value_m) / (2 * du);
                                                    expected["gamma"] =
                                                        (delta_p - delta_m) / (2 * du);

                                                    // perturb rates and get rho and dividend rho
                                                    Spread dr = 1.0e-5;
                                                    rRate->setValue(r + dr);
                                                    value_p = option.NPV();
                                                    rRate->setValue(r - dr);
                                                    value_m = option.NPV();
                                                    rRate->setValue(r);
                                                    expected["rho"] =
                                                        (value_p - value_m) / (2 * dr);

                                                    Spread dq = 1.0e-5;
                                                    qRate->setValue(q + dq);
                                                    value_p = option.NPV();
                                                    qRate->setValue(q - dq);
                                                    value_m = option.NPV();
                                                    qRate->setValue(q);
                                                    expected["divRho"] =
                                                        (value_p - value_m) / (2 * dq);

                                                    // perturb volatility and get vega
                                                    Volatility dv = v * 1.0e-4;
                                                    vol->setValue(v + dv);
                                                    value_p = option.NPV();
                                                    vol->setValue(v - dv);
                                                    value_m = option.NPV();
                                                    vol->setValue(v);
                                                    expected["vega"] =
                                                        (value_p - value_m) / (2 * dv);

                                                    // get theta from time-shifted options
                                                    Time dT = dc.yearFraction(today - 1, today + 1);
                                                    Settings::instance().evaluationDate() =
                                                        today - 1;
                                                    value_m = option.NPV();
                                                    Settings::instance().evaluationDate() =
                                                        today + 1;
                                                    value_p = option.NPV();
                                                    Settings::instance().evaluationDate() = today;
                                                    expected["theta"] = (value_p - value_m) / dT;
                                                    // compare
                                                    std::map<std::string, Real>::iterator it;
                                                    for (it = expected.begin();
                                                         it != expected.end(); ++it) {
                                                        std::string greek = it->first;
                                                        Real expct = expected[greek],
                                                             calcl = calculated[greek],
                                                             tol = tolerance[greek];
                                                        Real error = std::fabs(expct - calcl);
                                                        if (error > tol) {
                                                            REPORT_FAILURE_1(
                                                                greek, payoff, exercise, u, q, r,
                                                                today, v, jj1, jj2, jj3, expct,
                                                                calcl, error, tol);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } // strike loop
                }
            }
        }
    } // type loop
}


test_suite* JumpDiffusionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Jump-diffusion tests");
    suite->add(QUANTLIB_TEST_CASE(&JumpDiffusionTest::testMerton76));
    suite->add(QUANTLIB_TEST_CASE(&JumpDiffusionTest::testGreeks));
    return suite;
}
]]></document_content>
  </document>
  <document index="160">
    <source>jumpdiffusion.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_jumpdiffusion_hpp
#define quantlib_test_jumpdiffusion_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class JumpDiffusionTest {
  public:
    static void testMerton76();
    static void testGreeks();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="161">
    <source>lazyobject.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "lazyobject.hpp"
#include "utilities.hpp"
#include <ql/instruments/stock.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using ext::shared_ptr;

void LazyObjectTest::testDiscardingNotifications() {

    BOOST_TEST_MESSAGE(
        "Testing that lazy objects discard notifications after the first...");

    ext::shared_ptr<SimpleQuote> q(new SimpleQuote(0.0));
    ext::shared_ptr<Instrument> s(new Stock(Handle<Quote>(q)));

    Flag f;
    f.registerWith(s);
    
    s->NPV();
    q->setValue(1.0);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of change");
    
    f.lower();
    q->setValue(2.0);
    if (f.isUp())
        BOOST_FAIL("Observer was notified of second change");

    f.lower();
    s->NPV();
    q->setValue(3.0);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of change after recalculation");
}


void LazyObjectTest::testForwardingNotifications() {

    BOOST_TEST_MESSAGE(
        "Testing that lazy objects forward all notifications when told...");

    ext::shared_ptr<SimpleQuote> q(new SimpleQuote(0.0));
    ext::shared_ptr<Instrument> s(new Stock(Handle<Quote>(q)));

    s->alwaysForwardNotifications();

    Flag f;
    f.registerWith(s);
    
    s->NPV();
    q->setValue(1.0);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of change");
    
    f.lower();
    q->setValue(2.0);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of second change");
}


test_suite* LazyObjectTest::suite() {
    auto* suite = BOOST_TEST_SUITE("LazyObject tests");
    suite->add(
        QUANTLIB_TEST_CASE(&LazyObjectTest::testDiscardingNotifications));
    suite->add(
        QUANTLIB_TEST_CASE(&LazyObjectTest::testForwardingNotifications));
    return suite;
}

]]></document_content>
  </document>
  <document index="162">
    <source>lazyobject.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_lazy_object_hpp
#define quantlib_test_lazy_object_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class LazyObjectTest {
  public:
    static void testDiscardingNotifications();
    static void testForwardingNotifications();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="163">
    <source>libormarketmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "libormarketmodel.hpp"
#include "utilities.hpp"

#include <ql/indexes/ibor/euribor.hpp>
#include <ql/instruments/capfloor.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/termstructures/volatility/optionlet/capletvariancecurve.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>

#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>

#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/analyticcapfloorengine.hpp>

#include <ql/models/shortrate/calibrationhelpers/caphelper.hpp>
#include <ql/models/shortrate/calibrationhelpers/swaptionhelper.hpp>

#include <ql/legacy/libormarketmodels/lfmcovarproxy.hpp>
#include <ql/legacy/libormarketmodels/lmexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmlinexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmfixedvolmodel.hpp>
#include <ql/legacy/libormarketmodels/lmextlinexpvolmodel.hpp>
#include <ql/legacy/libormarketmodels/liborforwardmodel.hpp>
#include <ql/legacy/libormarketmodels/lfmswaptionengine.hpp>
#include <ql/legacy/libormarketmodels/lfmhullwhiteparam.hpp>

#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace libor_market_model_test {

    ext::shared_ptr<IborIndex> makeIndex(std::vector<Date> dates, const std::vector<Rate>& rates) {
        DayCounter dayCounter = Actual360();

        RelinkableHandle<YieldTermStructure> termStructure;

        ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));

        Date todaysDate =
            index->fixingCalendar().adjust(Date(4,September,2005));
        Settings::instance().evaluationDate() = todaysDate;

        dates[0] = index->fixingCalendar().advance(todaysDate,
                                                   index->fixingDays(), Days);

        termStructure.linkTo(ext::shared_ptr<YieldTermStructure>(
                                    new ZeroCurve(dates, rates, dayCounter)));

        return index;
    }


    ext::shared_ptr<IborIndex> makeIndex() {
        std::vector<Date> dates = {{4,September,2005}, {4,September,2018}};
        std::vector<Rate> rates = {0.039, 0.041};

        return makeIndex(dates, rates);
    }


    ext::shared_ptr<OptionletVolatilityStructure>
    makeCapVolCurve(const Date& todaysDate) {
        Volatility vols[] = {14.40, 17.15, 16.81, 16.64, 16.17,
                             15.78, 15.40, 15.21, 14.86};

        std::vector<Date> dates;
        std::vector<Volatility> capletVols;
        ext::shared_ptr<LiborForwardModelProcess> process(
                               new LiborForwardModelProcess(10, makeIndex()));

        for (Size i=0; i < 9; ++i) {
            capletVols.push_back(vols[i]/100);
            dates.push_back(process->fixingDates()[i+1]);
        }

        return ext::make_shared<CapletVarianceCurve>(
                         todaysDate, dates,
                                                 capletVols, Actual360());
    }

}


void LiborMarketModelTest::testSimpleCovarianceModels() {
    BOOST_TEST_MESSAGE("Testing simple covariance models...");

    using namespace libor_market_model_test;

    SavedSettings backup;

    const Size size = 10;
    const Real tolerance = 1e-14;
    Size i;

    ext::shared_ptr<LmCorrelationModel> corrModel(
                                new LmExponentialCorrelationModel(size, 0.1));

    Matrix recon = corrModel->correlation(0.0)
        - corrModel->pseudoSqrt(0.0)*transpose(corrModel->pseudoSqrt(0.0));

    for (i=0; i<size; ++i) {
        for (Size j=0; j<size; ++j) {
            if (std::fabs(recon[i][j]) > tolerance)
                BOOST_ERROR("Failed to reproduce correlation matrix"
                            << "\n    calculated: " << recon[i][j]
                            << "\n    expected:   " << 0);
        }
    }

    std::vector<Time> fixingTimes(size);
    for (i=0; i<size; ++i) {
        fixingTimes[i] = 0.5*i;
    }

    const Real a=0.2;
    const Real b=0.1;
    const Real c=2.1;
    const Real d=0.3;

    ext::shared_ptr<LmVolatilityModel> volaModel(
             new LmLinearExponentialVolatilityModel(fixingTimes, a, b, c, d));

    ext::shared_ptr<LfmCovarianceProxy> covarProxy(
                                new LfmCovarianceProxy(volaModel, corrModel));

    ext::shared_ptr<LiborForwardModelProcess> process(
                             new LiborForwardModelProcess(size, makeIndex()));

    ext::shared_ptr<LiborForwardModel> liborModel(
                        new LiborForwardModel(process, volaModel, corrModel));

    for (Real t=0; t<4.6; t+=0.31) {
        recon = covarProxy->covariance(t)
            - covarProxy->diffusion(t)*transpose(covarProxy->diffusion(t));

        for (Size i=0; i<size; ++i) {
            for (Size j=0; j<size; ++j) {
                if (std::fabs(recon[i][j]) > tolerance)
                    BOOST_ERROR("Failed to reproduce correlation matrix"
                                << "\n    calculated: " << recon[i][j]
                                << "\n    expected:   " << 0);
            }
        }

        Array volatility = volaModel->volatility(t);

        for (Size k=0; k<size; ++k) {
            Real expected = 0;
            if (k>2*t) {
                const Real T = fixingTimes[k];
                expected=(a*(T-t)+d)*std::exp(-b*(T-t)) + c;
            }

            if (std::fabs(expected - volatility[k]) > tolerance)
                BOOST_ERROR("Failed to reproduce volatities"
                            << "\n    calculated: " << volatility[k]
                            << "\n    expected:   " << expected);
        }
    }
}


void LiborMarketModelTest::testCapletPricing() {
    BOOST_TEST_MESSAGE("Testing caplet pricing...");

    using namespace libor_market_model_test;

    SavedSettings backup;

    const Size size = 10;
    Real tolerance;
    if (!IborCoupon::usingAtParCoupons())
        tolerance = 1e-5;
    else
        tolerance = 1e-12;

    ext::shared_ptr<IborIndex> index = makeIndex();
    ext::shared_ptr<LiborForwardModelProcess> process(
        new LiborForwardModelProcess(size, index));

    // set-up pricing engine
    const ext::shared_ptr<OptionletVolatilityStructure> capVolCurve =
        makeCapVolCurve(Settings::instance().evaluationDate());

    Array variances = LfmHullWhiteParameterization(process, capVolCurve)
        .covariance(0.0).diagonal();

    ext::shared_ptr<LmVolatilityModel> volaModel(
        new LmFixedVolatilityModel(Sqrt(variances),
                                   process->fixingTimes()));

    ext::shared_ptr<LmCorrelationModel> corrModel(
                                new LmExponentialCorrelationModel(size, 0.3));

    ext::shared_ptr<AffineModel> model(
                        new LiborForwardModel(process, volaModel, corrModel));

    const Handle<YieldTermStructure> termStructure =
        process->index()->forwardingTermStructure();

    ext::shared_ptr<AnalyticCapFloorEngine> engine1(
                            new AnalyticCapFloorEngine(model, termStructure));

    ext::shared_ptr<Cap> cap1(
        new Cap(process->cashFlows(),
                std::vector<Rate>(size, 0.04)));
    cap1->setPricingEngine(engine1);

    const Real expected = 0.015853935178;
    const Real calculated = cap1->NPV();

    if (std::fabs(expected - calculated) > tolerance)
        BOOST_ERROR("Failed to reproduce npv"
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected);
}

void LiborMarketModelTest::testCalibration() {
    BOOST_TEST_MESSAGE("Testing calibration of a Libor forward model...");

    using namespace libor_market_model_test;

    SavedSettings backup;

    const Size size = 14;
    const Real tolerance = 8e-3;

    Volatility capVols[] = {0.145708,0.158465,0.166248,0.168672,
                            0.169007,0.167956,0.166261,0.164239,
                            0.162082,0.159923,0.157781,0.155745,
                            0.153776,0.151950,0.150189,0.148582,
                            0.147034,0.145598,0.144248};

    Volatility swaptionVols[] = {0.170595, 0.166844, 0.158306, 0.147444,
                                 0.136930, 0.126833, 0.118135, 0.175963,
                                 0.166359, 0.155203, 0.143712, 0.132769,
                                 0.122947, 0.114310, 0.174455, 0.162265,
                                 0.150539, 0.138734, 0.128215, 0.118470,
                                 0.110540, 0.169780, 0.156860, 0.144821,
                                 0.133537, 0.123167, 0.114363, 0.106500,
                                 0.164521, 0.151223, 0.139670, 0.128632,
                                 0.119123, 0.110330, 0.103114, 0.158956,
                                 0.146036, 0.134555, 0.124393, 0.115038,
                                 0.106996, 0.100064};

    ext::shared_ptr<IborIndex> index = makeIndex();
    ext::shared_ptr<LiborForwardModelProcess> process(
        new LiborForwardModelProcess(size, index));
    Handle<YieldTermStructure> termStructure = index->forwardingTermStructure();

    // set-up the model
    ext::shared_ptr<LmVolatilityModel> volaModel(
                    new LmExtLinearExponentialVolModel(process->fixingTimes(),
                                                       0.5,0.6,0.1,0.1));

    ext::shared_ptr<LmCorrelationModel> corrModel(
                     new LmLinearExponentialCorrelationModel(size, 0.5, 0.8));

    ext::shared_ptr<LiborForwardModel> model(
                        new LiborForwardModel(process, volaModel, corrModel));

    Size swapVolIndex = 0;
    DayCounter dayCounter=index->forwardingTermStructure()->dayCounter();

    // set-up calibration helper
    std::vector<ext::shared_ptr<CalibrationHelper> > calibrationHelpers;

    Size i;
    for (i=2; i < size; ++i) {
        const Period maturity = i*index->tenor();
        Handle<Quote> capVol(
            ext::shared_ptr<Quote>(new SimpleQuote(capVols[i-2])));

        ext::shared_ptr<BlackCalibrationHelper> caphelper(
            new CapHelper(maturity, capVol, index, Annual,
                          index->dayCounter(), true, termStructure,
                          BlackCalibrationHelper::ImpliedVolError));

        caphelper->setPricingEngine(ext::shared_ptr<PricingEngine>(
                           new AnalyticCapFloorEngine(model, termStructure)));

        calibrationHelpers.push_back(caphelper);

        if (i<= size/2) {
            // add a few swaptions to test swaption calibration as well
            for (Size j=1; j <= size/2; ++j) {
                const Period len = j*index->tenor();
                Handle<Quote> swaptionVol(
                    ext::shared_ptr<Quote>(
                        new SimpleQuote(swaptionVols[swapVolIndex++])));

                ext::shared_ptr<BlackCalibrationHelper> swaptionHelper(
                    new SwaptionHelper(maturity, len, swaptionVol, index,
                                       index->tenor(), dayCounter,
                                       index->dayCounter(),
                                       termStructure,
                                       BlackCalibrationHelper::ImpliedVolError));

                swaptionHelper->setPricingEngine(
                     ext::shared_ptr<PricingEngine>(
                                 new LfmSwaptionEngine(model,termStructure)));

                calibrationHelpers.push_back(swaptionHelper);
            }
        }
    }

    LevenbergMarquardt om(1e-6, 1e-6, 1e-6);
    model->calibrate(calibrationHelpers, om, EndCriteria(2000, 100, 1e-6, 1e-6, 1e-6));

    // measure the calibration error
    Real calculated = 0.0;
    for (i=0; i<calibrationHelpers.size(); ++i) {
        Real diff = calibrationHelpers[i]->calibrationError();
        calculated += diff*diff;
    }

    if (std::sqrt(calculated) > tolerance)
        BOOST_ERROR("Failed to calibrate libor forward model"
                    << "\n    calculated diff: " << std::sqrt(calculated)
                    << "\n    expected : smaller than  " << tolerance);
}

void LiborMarketModelTest::testSwaptionPricing() {
    BOOST_TEST_MESSAGE("Testing forward swap and swaption pricing...");

    using namespace libor_market_model_test;

    SavedSettings backup;

    const Size size  = 10;
    const Size steps = 8*size;

    Real tolerance;
    if (!IborCoupon::usingAtParCoupons())
        tolerance = 1e-6;
    else
        tolerance = 1e-12;

    std::vector<Date> dates = {{4,September,2005}, {4,September,2011}};
    std::vector<Rate> rates = {0.04, 0.08};

    ext::shared_ptr<IborIndex> index = makeIndex(dates, rates);

    ext::shared_ptr<LiborForwardModelProcess> process(
                                   new LiborForwardModelProcess(size, index));

    ext::shared_ptr<LmCorrelationModel> corrModel(
                                new LmExponentialCorrelationModel(size, 0.5));

    ext::shared_ptr<LmVolatilityModel> volaModel(
        new LmLinearExponentialVolatilityModel(process->fixingTimes(),
                                               0.291, 1.483, 0.116, 0.00001));

   // set-up pricing engine
    process->setCovarParam(ext::shared_ptr<LfmCovarianceParameterization>(
                               new LfmCovarianceProxy(volaModel, corrModel)));

    // set-up a small Monte-Carlo simulation to price swations
    typedef PseudoRandom::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;

    std::vector<Time> tmp = process->fixingTimes();
    TimeGrid grid(tmp.begin(), tmp.end(), steps);

    Size i;
    std::vector<Size> location;
    for (i=0; i < tmp.size(); ++i) {
        location.push_back(
                      std::find(grid.begin(),grid.end(),tmp[i])-grid.begin());
    }

    rsg_type rsg = PseudoRandom::make_sequence_generator(
                       process->factors()*(grid.size()-1),
                       BigNatural(42));

    const Size nrTrails = 5000;
    MultiPathGenerator<rsg_type> generator(process, grid, rsg, false);

    ext::shared_ptr<LiborForwardModel>
        liborModel(new LiborForwardModel(process, volaModel, corrModel));

    Calendar calendar = index->fixingCalendar();
    DayCounter dayCounter = index->forwardingTermStructure()->dayCounter();
    BusinessDayConvention convention = index->businessDayConvention();

    Date settlement  = index->forwardingTermStructure()->referenceDate();

    for (i=1; i < size; ++i) {
        for (Size j=1; j <= size-i; ++j) {
            Date fwdStart    = settlement + Period(6*i, Months);
            Date fwdMaturity = fwdStart + Period(6*j, Months);

            Schedule schedule(fwdStart, fwdMaturity, index->tenor(), calendar,
                               convention, convention, DateGeneration::Forward, false);

            Rate swapRate  = 0.0404;
            ext::shared_ptr<VanillaSwap> forwardSwap(
                new VanillaSwap(Swap::Receiver, 1.0,
                                schedule, swapRate, dayCounter,
                                schedule, index, 0.0, index->dayCounter()));
            forwardSwap->setPricingEngine(ext::shared_ptr<PricingEngine>(
                new DiscountingSwapEngine(index->forwardingTermStructure())));

            // check forward pricing first
            const Real expected = forwardSwap->fairRate();
            const Real calculated = liborModel->S_0(i-1,i+j-1);

            if (std::fabs(expected - calculated) > tolerance)
                BOOST_ERROR("Failed to reproduce fair forward swap rate"
                            << "\n    calculated: " << calculated
                            << "\n    expected:   " << expected);

            swapRate = forwardSwap->fairRate();
            forwardSwap = ext::make_shared<VanillaSwap>(
                                Swap::Receiver, 1.0,
                                schedule, swapRate, dayCounter,
                                schedule, index, 0.0, index->dayCounter());
            forwardSwap->setPricingEngine(ext::shared_ptr<PricingEngine>(
                new DiscountingSwapEngine(index->forwardingTermStructure())));

            if (i == j && i<=size/2) {
                ext::shared_ptr<PricingEngine> engine(
                     new LfmSwaptionEngine(liborModel,
                                           index->forwardingTermStructure()));
                ext::shared_ptr<Exercise> exercise(
                    new EuropeanExercise(process->fixingDates()[i]));

                ext::shared_ptr<Swaption> swaption(
                    new Swaption(forwardSwap, exercise));
                swaption->setPricingEngine(engine);

                GeneralStatistics stat;

                for (Size n=0; n<nrTrails; ++n) {
                    sample_type path = (n % 2) != 0U ? generator.antithetic() : generator.next();

                    std::vector<Rate> rates(size);
                    for (Size k=0; k<process->size(); ++k) {
                        rates[k] = path.value[k][location[i]];
                    }
                    std::vector<DiscountFactor> dis =
                        process->discountBond(rates);

                    Real npv=0.0;
                    for (Size m=i; m < i+j; ++m) {
                        npv += (swapRate - rates[m])
                               * (  process->accrualEndTimes()[m]
                                  - process->accrualStartTimes()[m])*dis[m];
                    }
                    stat.add(std::max(npv, 0.0));
                }

                if (std::fabs(swaption->NPV() - stat.mean())
                    > stat.errorEstimate()*2.35)
                    BOOST_ERROR("Failed to reproduce swaption npv"
                                << "\n    calculated: " << stat.mean()
                                << "\n    expected:   " << swaption->NPV());
            }
        }
    }
}


test_suite* LiborMarketModelTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Libor market model tests");

    suite->add(QUANTLIB_TEST_CASE(
                          &LiborMarketModelTest::testSimpleCovarianceModels));
    suite->add(QUANTLIB_TEST_CASE(&LiborMarketModelTest::testCapletPricing));
    suite->add(QUANTLIB_TEST_CASE(&LiborMarketModelTest::testSwaptionPricing));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&LiborMarketModelTest::testCalibration));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="164">
    <source>libormarketmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_libor_market_model_hpp
#define quantlib_test_libor_market_model_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class LiborMarketModelTest {
  public:
    static void testSimpleCovarianceModels();
    static void testCapletPricing();
    static void testSwaptionPricing();
    static void testCalibration();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif

]]></document_content>
  </document>
  <document index="165">
    <source>libormarketmodelprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "libormarketmodelprocess.hpp"
#include "utilities.hpp"
#include <ql/timegrid.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <ql/termstructures/volatility/optionlet/capletvariancecurve.hpp>
#include <ql/legacy/libormarketmodels/lfmhullwhiteparam.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace libor_market_model_process_test {

    Size len = 10;

    ext::shared_ptr<IborIndex> makeIndex() {
        DayCounter dayCounter = Actual360();
        std::vector<Date> dates = {{4,September,2005}, {4,September,2018}};
        std::vector<Rate> rates = {0.01, 0.08};

        RelinkableHandle<YieldTermStructure> termStructure(
                      ext::shared_ptr<YieldTermStructure>(
                                      new ZeroCurve(dates,rates,dayCounter)));

        ext::shared_ptr<IborIndex> index(new Euribor1Y(termStructure));

        Date todaysDate =
            index->fixingCalendar().adjust(Date(4,September,2005));
        Settings::instance().evaluationDate() = todaysDate;

        dates[0] = index->fixingCalendar().advance(todaysDate,
                                                   index->fixingDays(), Days);

        termStructure.linkTo(ext::shared_ptr<YieldTermStructure>(
                                    new ZeroCurve(dates, rates, dayCounter)));

        return index;
    }

    ext::shared_ptr<CapletVarianceCurve>
    makeCapVolCurve(const Date& todaysDate) {
        Volatility vols[] = {14.40, 17.15, 16.81, 16.64, 16.17,
                             15.78, 15.40, 15.21, 14.86, 14.54};

        std::vector<Date> dates;
        std::vector<Volatility> capletVols;
        ext::shared_ptr<LiborForwardModelProcess> process(
                            new LiborForwardModelProcess(len+1, makeIndex()));

        for (Size i=0; i < len; ++i) {
            capletVols.push_back(vols[i]/100);
            dates.push_back(process->fixingDates()[i+1]);
        }

        return ext::make_shared<CapletVarianceCurve>(todaysDate, dates, capletVols,
                                                     ActualActual(ActualActual::ISDA));
    }

    ext::shared_ptr<LiborForwardModelProcess>
    makeProcess(const Matrix& volaComp = Matrix()) {
        Size factors = (volaComp.empty() ? 1 : volaComp.columns());

        ext::shared_ptr<IborIndex> index = makeIndex();
        ext::shared_ptr<LiborForwardModelProcess> process(
                                    new LiborForwardModelProcess(len, index));

        ext::shared_ptr<LfmCovarianceParameterization> fct(
                new LfmHullWhiteParameterization(
                    process,
                    makeCapVolCurve(Settings::instance().evaluationDate()),
                    volaComp * transpose(volaComp), factors));

        process->setCovarParam(fct);

        return process;
    }

}


void LiborMarketModelProcessTest::testInitialisation() {
    BOOST_TEST_MESSAGE("Testing caplet LMM process initialisation...");

    SavedSettings backup;

    DayCounter dayCounter = Actual360();
    RelinkableHandle<YieldTermStructure> termStructure(
        flatRate(Date::todaysDate(), 0.04, dayCounter));

    ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
    ext::shared_ptr<OptionletVolatilityStructure> capletVol(new
        ConstantOptionletVolatility(termStructure->referenceDate(),
                                    termStructure->calendar(),
                                    Following,
                                    0.2,
                                    termStructure->dayCounter()));

    Calendar calendar = index->fixingCalendar();

    for (Integer daysOffset=0; daysOffset < 1825 /* 5 year*/; daysOffset+=8) {
        Date todaysDate = calendar.adjust(Date::todaysDate()+daysOffset);
        Settings::instance().evaluationDate() = todaysDate;
        Date settlementDate =
            calendar.advance(todaysDate, index->fixingDays(), Days);

        termStructure.linkTo(flatRate(settlementDate, 0.04, dayCounter));

        LiborForwardModelProcess process(60, index);

        std::vector<Time> fixings = process.fixingTimes();
        for (Size i=1; i < fixings.size()-1; ++i) {
            Size ileft  = process.nextIndexReset(fixings[i]-0.000001);
            Size iright = process.nextIndexReset(fixings[i]+0.000001);
            Size ii     = process.nextIndexReset(fixings[i]);

            if ((ileft != i) || (iright != i+1) || (ii != i+1)) {
                BOOST_ERROR("Failed to next index resets");
            }
        }

    }
}

void LiborMarketModelProcessTest::testLambdaBootstrapping() {
    BOOST_TEST_MESSAGE("Testing caplet LMM lambda bootstrapping...");

    using namespace libor_market_model_process_test;

    SavedSettings backup;

    Real tolerance = 1e-10;
    Volatility lambdaExpected[]= {14.3010297550, 19.3821411939, 15.9816590141,
                                  15.9953118303, 14.0570815635, 13.5687599894,
                                  12.7477197786, 13.7056638165, 11.6191989567};

    ext::shared_ptr<LiborForwardModelProcess> process = makeProcess();

    Matrix covar = process->covariance(0.0, Null<Array>(), 1.0);

    for (Size i=0; i<9; ++i) {
        const Real calculated = std::sqrt(covar[i+1][i+1]);
        const Real expected   = lambdaExpected[i]/100;

        if (std::fabs(calculated - expected) > tolerance)
            BOOST_ERROR("Failed to reproduce expected lambda values"
                        << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected);
    }

    ext::shared_ptr<LfmCovarianceParameterization> param =
        process->covarParam();

    std::vector<Time> tmp = process->fixingTimes();
    TimeGrid grid(tmp.begin(), tmp.end(), 14);

    for (double t : grid) {
        Matrix diff = (param->integratedCovariance(t) -
                       param->LfmCovarianceParameterization::integratedCovariance(t));

        for (Size i=0; i<diff.rows(); ++i) {
            for (Size j=0; j<diff.columns(); ++j) {
                if (std::fabs(diff[i][j]) > tolerance) {
                     BOOST_FAIL("Failed to reproduce integrated covariance" <<
                        "\n    i: " << i <<
                        "\n    j: " << j <<
                        "\nerror: " << diff[i][j]);
                }
            }
        }
    }
}

void LiborMarketModelProcessTest::testMonteCarloCapletPricing() {
    BOOST_TEST_MESSAGE("Testing caplet LMM Monte-Carlo caplet pricing...");

    using namespace libor_market_model_process_test;

    SavedSettings backup;

    /* factor loadings are taken from Hull & White article
       plus extra normalisation to get orthogonal eigenvectors
       http://www.rotman.utoronto.ca/~amackay/fin/libormktmodel2.pdf */
    Real compValues[] = {0.85549771, 0.46707264, 0.22353259,
                         0.91915359, 0.37716089, 0.11360610,
                         0.96438280, 0.26413316,-0.01412414,
                         0.97939148, 0.13492952,-0.15028753,
                         0.95970595,-0.00000000,-0.28100621,
                         0.97939148,-0.13492952,-0.15028753,
                         0.96438280,-0.26413316,-0.01412414,
                         0.91915359,-0.37716089, 0.11360610,
                         0.85549771,-0.46707264, 0.22353259};

    Matrix volaComp(9,3);
    std::copy(compValues, compValues+9*3, volaComp.begin());

    ext::shared_ptr<LiborForwardModelProcess> process1 = makeProcess();
    ext::shared_ptr<LiborForwardModelProcess> process2 = makeProcess(
                                                                    volaComp);
    std::vector<Time> tmp = process1->fixingTimes();
    TimeGrid grid(tmp.begin(), tmp.end(),12);

    Size i;
    std::vector<Size> location;
    for (i=0; i < tmp.size(); ++i) {
        location.push_back(
                      std::find(grid.begin(),grid.end(),tmp[i])-grid.begin());
    }

    // set-up a small Monte-Carlo simulation to price caplets
    // and ratchet caps using a one- and a three factor libor market model
    typedef LowDiscrepancy::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;

    BigNatural seed = 42;
    rsg_type rsg1 = LowDiscrepancy::make_sequence_generator(
                            process1->factors()*(grid.size()-1), seed);
    rsg_type rsg2 = LowDiscrepancy::make_sequence_generator(
                            process2->factors()*(grid.size()-1), seed);
    MultiPathGenerator<rsg_type> generator1(process1, grid, rsg1, false);
    MultiPathGenerator<rsg_type> generator2(process2, grid, rsg2, false);

    const Size nrTrails = 250000;
    std::vector<GeneralStatistics> stat1(process1->size());
    std::vector<GeneralStatistics> stat2(process2->size());
    std::vector<GeneralStatistics> stat3(process2->size()-1);
    for (i=0; i<nrTrails; ++i) {
        sample_type path1 = generator1.next();
        sample_type path2 = generator2.next();

        std::vector<Rate> rates1(len);
        std::vector<Rate> rates2(len);
        for (Size j=0; j<process1->size(); ++j) {
            rates1[j] = path1.value[j][location[j]];
            rates2[j] = path2.value[j][location[j]];
        }

        std::vector<DiscountFactor> dis1 = process1->discountBond(rates1);
        std::vector<DiscountFactor> dis2 = process2->discountBond(rates2);

        for (Size k=0; k<process1->size(); ++k) {
            Real accrualPeriod =  process1->accrualEndTimes()[k]
                                - process1->accrualStartTimes()[k];
            // caplet payoff function, cap rate at 4%
            Real payoff1 = std::max(rates1[k] - 0.04, 0.0) * accrualPeriod;

            Real payoff2 = std::max(rates2[k] - 0.04, 0.0) * accrualPeriod;
            stat1[k].add(dis1[k] * payoff1);
            stat2[k].add(dis2[k] * payoff2);

            if (k != 0) {
                // ratchet cap payoff function
                Real payoff3 =  std::max(rates2[k] - (rates2[k-1]+0.0025), 0.0)
                              * accrualPeriod;
                stat3[k-1].add(dis2[k] * payoff3);
            }
        }

    }

    Real capletNpv[] = {0.000000000000, 0.000002841629, 0.002533279333,
                        0.009577143571, 0.017746502618, 0.025216116835,
                        0.031608230268, 0.036645683881, 0.039792254012,
                        0.041829864365};

    Real ratchetNpv[] = {0.0082644895, 0.0082754754, 0.0082159966,
                         0.0082982822, 0.0083803357, 0.0084366961,
                         0.0084173270, 0.0081803406, 0.0079533814};

    for (Size k=0; k < process1->size(); ++k) {

        Real calculated1 = stat1[k].mean();
        Real tolerance1  = stat1[k].errorEstimate();
        Real expected    = capletNpv[k];

        if (std::fabs(calculated1 - expected) > tolerance1) {
            BOOST_ERROR("Failed to reproduce expected caplet NPV"
                        << "\n    calculated: " << calculated1
                        << "\n    error int:  " << tolerance1
                        << "\n    expected:   " << expected);
        }

        Real calculated2 = stat2[k].mean();
        Real tolerance2  = stat2[k].errorEstimate();

        if (std::fabs(calculated2 - expected) > tolerance2) {
            BOOST_ERROR("Failed to reproduce expected caplet NPV"
                        << "\n    calculated: " << calculated2
                        << "\n    error int:  " << tolerance2
                        << "\n    expected:   " << expected);
        }

        if (k != 0) {
            Real calculated3 = stat3[k-1].mean();
            Real tolerance3  = stat3[k-1].errorEstimate();
            expected    = ratchetNpv[k-1];

            Real refError = 1e-5; // 1e-5. error bars of the reference values

            if (std::fabs(calculated3 - expected) > tolerance3 + refError) {
                BOOST_ERROR("Failed to reproduce expected caplet NPV"
                            << "\n    calculated: " << calculated3
                            << "\n    error int:  " << tolerance3 + refError
                            << "\n    expected:   " << expected);
            }
        }
    }
}

test_suite* LiborMarketModelProcessTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Libor market model process tests");

    suite->add(QUANTLIB_TEST_CASE(
         &LiborMarketModelProcessTest::testInitialisation));
    suite->add(QUANTLIB_TEST_CASE(
         &LiborMarketModelProcessTest::testLambdaBootstrapping));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(
            &LiborMarketModelProcessTest::testMonteCarloCapletPricing));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="166">
    <source>libormarketmodelprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_libor_market_model_process_hpp
#define quantlib_test_libor_market_model_process_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class LiborMarketModelProcessTest {
  public:
    static void testInitialisation();
    static void testLambdaBootstrapping();
    static void testMonteCarloCapletPricing();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif

]]></document_content>
  </document>
  <document index="167">
    <source>linearleastsquaresregression.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2010 Slava Mazur

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "linearleastsquaresregression.hpp"
#include "utilities.hpp"
#include <ql/math/functional.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/linearleastsquaresregression.hpp>
#include <ql/functional.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#include <boost/circular_buffer.hpp>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

using namespace QuantLib;
using namespace boost::unit_test_framework;

void LinearLeastSquaresRegressionTest::testRegression() {

    BOOST_TEST_MESSAGE("Testing linear least-squares regression...");

    SavedSettings backup;

    const Real tolerance = 0.05;

    const Size nr=100000;
    PseudoRandom::rng_type rng(PseudoRandom::urng_type(1234U));

    std::vector<ext::function<Real(Real)>> v = {
        [](Real x){ return 1.0; },
        [](Real x){ return x; },
        [](Real x){ return x*x; },
        [](Real x){ return std::sin(x); }
    };

    std::vector<ext::function<Real(Real)>> w(v);
    w.emplace_back([](Real x){ return x*x; });

    for (Size k=0; k<3; ++k) {
        Size i;
        const Real a[] = {
            rng.next().value,
            rng.next().value,
            rng.next().value,
            rng.next().value
        };

        std::vector<Real> x(nr), y(nr);
        for (i=0; i<nr; ++i) {
            x[i] = rng.next().value;

            // regression in y = a_1 + a_2*x + a_3*x^2 + a_4*sin(x) + eps
            y[i] =  a[0]*v[0](x[i]) + a[1]*v[1](x[i]) + a[2]*v[2](x[i])
                + a[3]*v[3](x[i]) + rng.next().value;
        }

        LinearRegression m(x, y, v);

        for (i=0; i<v.size(); ++i) {
            if (m.standardErrors()[i] > tolerance) {
                BOOST_ERROR("Failed to reproduce linear regression coef."
                    << "\n    error:     " << m.standardErrors()[i]
                << "\n    tolerance: " << tolerance);
            }
            if (std::fabs(m.coefficients()[i]-a[i]) > 3*m.standardErrors()[i]) {
                BOOST_ERROR("Failed to reproduce linear regression coef."
                    << "\n    calculated: " << m.coefficients()[i]
                << "\n    error:      " << m.standardErrors()[i]
                << "\n    expected:   " << a[i]);
            }
        }

        m = LinearRegression(x, y, w);

        const Real ma[] = {m.coefficients()[0], m.coefficients()[1], 
            m.coefficients()[2]+m.coefficients()[4],
            m.coefficients()[3]};
        const Real err[] = {m.standardErrors()[0], m.standardErrors()[1],
            std::sqrt( m.standardErrors()[2]*m.standardErrors()[2]
        +m.standardErrors()[4]*m.standardErrors()[4]),
            m.standardErrors()[3]};
        for (i=0; i<v.size(); ++i) {
            if (std::fabs(ma[i] - a[i]) > 3*err[i]) {
                BOOST_ERROR("Failed to reproduce linear regression coef."
                    << "\n    calculated: " << ma[i]
                << "\n    error:      " << err[i]
                << "\n    expected:   " << a[i]);
            }
        }
    }
}

namespace linear_least_square_regression_test {

    struct get_item {
        Size i;
        explicit get_item(Size i) : i(i) {}
        Real operator()(const Array& a) const {
            return a[i];
        }
    };

}

void LinearLeastSquaresRegressionTest::testMultiDimRegression() {

    BOOST_TEST_MESSAGE(
        "Testing multi-dimensional linear least-squares regression...");

    using namespace ext::placeholders;
    using namespace linear_least_square_regression_test;

    SavedSettings backup;

    const Size nr=100000;
    const Size dims = 4;
    const Real tolerance = 0.01;
    PseudoRandom::rng_type rng(PseudoRandom::urng_type(1234U));

    std::vector<ext::function<Real(Array)> > v;
    v.emplace_back(constant<Array, Real>(1.0));
    for (Size i=0; i < dims; ++i) {
        v.emplace_back(get_item(i));
    }

    Array coeff(v.size());
    for (Size i=0; i < v.size(); ++i) {
        coeff[i] = rng.next().value;
    }

    std::vector<Real> y(nr, 0.0);
    std::vector<Array> x(nr, Array(dims));
    for (Size i=0; i < nr; ++i) {
        for (Size j=0; j < dims; ++j) {
            x[i][j] = rng.next().value;
        }

        for (Size j=0; j < v.size(); ++j) {
            y[i] += coeff[j]*v[j](x[i]);
        }
        y[i] += rng.next().value;
    }

    LinearRegression m(x, y, v);

    for (Size i=0; i < v.size(); ++i) {
        if (m.standardErrors()[i] > tolerance) {
            BOOST_ERROR("Failed to reproduce linear regression coef."
                << "\n    error:     " << m.standardErrors()[i]
            << "\n    tolerance: " << tolerance);
        }

        if (std::fabs(m.coefficients()[i]-coeff[i]) > 3*tolerance) {
            BOOST_ERROR("Failed to reproduce linear regression coef."
                << "\n    calculated: " << m.coefficients()[i]
            << "\n    error:      " << m.standardErrors()[i]
            << "\n    expected:   " << coeff[i]);
        }
    }

    // much simpler
    LinearRegression m1(x, y, Real(1.0));

    for (Size i=0; i < m1.dim(); ++i) {
        if (m1.standardErrors()[i] > tolerance) {
            BOOST_ERROR("Failed to reproduce linear regression coef."
                << "\n    error:     " << m1.standardErrors()[i]
            << "\n    tolerance: " << tolerance);
        }

        if (std::fabs(m1.coefficients()[i]-coeff[i]) > 3*tolerance) {
            BOOST_ERROR("Failed to reproduce linear regression coef."
                << "\n    calculated: " << m1.coefficients()[i]
            << "\n    error:      " << m1.standardErrors()[i]
            << "\n    expected:   " << coeff[i]);
        }
    }
}

void LinearLeastSquaresRegressionTest::test1dLinearRegression() {

    BOOST_TEST_MESSAGE("Testing 1D simple linear least-squares regression...");

    /* Example taken from the QuantLib-User list, see posting
    * Multiple linear regression/weighted regression, Boris Skorodumov */

    SavedSettings backup;

    std::vector<Real> x = {2.4, 1.8, 2.5, 3.0, 2.1, 1.2, 2.0, 2.7, 3.6};
    std::vector<Real> y = {7.8, 5.5, 8.0, 9.0, 6.5, 4.0, 6.3, 8.4, 10.2};

    std::vector<ext::function<Real(Real)>> v = {
        [](Real x) { return 1.0; },
        [](Real x) { return x; }
    };

    LinearRegression m(x, y);

    const Real tol = 0.0002;
    const Real coeffExpected[]  = { 0.9448, 2.6853 };
    const Real errorsExpected[] = { 0.3654, 0.1487 };

    for (Size i=0; i < 2; ++i) {
        if (std::fabs(m.standardErrors()[i]-errorsExpected[i]) > tol) {
            BOOST_ERROR("Failed to reproduce linear regression standard errors"
                << "\n    calculated: " << m.standardErrors()[i]
            << "\n    expected:   " << errorsExpected[i]                                          
            << "\n    tolerance:  " << tol);
        }

        if (std::fabs(m.coefficients()[i]-coeffExpected[i]) > tol) {
            BOOST_ERROR("Failed to reproduce linear regression coef."
                << "\n    calculated: " << m.coefficients()[i]
            << "\n    expected:   " << coeffExpected[i]
            << "\n    tolerance:  " << tol);
        }
    }    

    // an alternative container type 
    boost::circular_buffer<Real> cx(x.begin(), x.end()), cy(y.begin(), y.end());
    LinearRegression m1(cx, cy);

    for (Size i=0; i < 2; ++i) {
        if (std::fabs(m1.standardErrors()[i]-errorsExpected[i]) > tol) {
            BOOST_ERROR("Failed to reproduce linear regression standard errors"
                << "\n    calculated: " << m1.standardErrors()[i]
            << "\n    expected:   " << errorsExpected[i]                                          
            << "\n    tolerance:  " << tol);
        }

        if (std::fabs(m1.coefficients()[i]-coeffExpected[i]) > tol) {
            BOOST_ERROR("Failed to reproduce linear regression coef."
                << "\n    calculated: " << m1.coefficients()[i]
            << "\n    expected:   " << coeffExpected[i]
            << "\n    tolerance:  " << tol);
        }
    }    
}


test_suite* LinearLeastSquaresRegressionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("linear least squares regression tests");
    suite->add(QUANTLIB_TEST_CASE(
        &LinearLeastSquaresRegressionTest::testRegression));
    suite->add(QUANTLIB_TEST_CASE(
        &LinearLeastSquaresRegressionTest::testMultiDimRegression));
    suite->add(QUANTLIB_TEST_CASE(
        &LinearLeastSquaresRegressionTest::test1dLinearRegression));
    return suite;
}

]]></document_content>
  </document>
  <document index="168">
    <source>linearleastsquaresregression.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_linear_least_squares_regression_hpp
#define quantlib_test_linear_least_squares_regression_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class LinearLeastSquaresRegressionTest {
  public:
    static void testRegression();
    static void testMultiDimRegression();
    static void test1dLinearRegression();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="169">
    <source>lookbackoptions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2005, 2007 StatPro Italia srl
 Copyright (C) 2006 Warren Chou

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "lookbackoptions.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/instruments/lookbackoption.hpp>
#include <ql/pricingengines/lookback/analyticcontinuousfloatinglookback.hpp>
#include <ql/pricingengines/lookback/analyticcontinuousfixedlookback.hpp>
#include <ql/pricingengines/lookback/analyticcontinuouspartialfloatinglookback.hpp>
#include <ql/pricingengines/lookback/analyticcontinuouspartialfixedlookback.hpp>
#include <ql/pricingengines/lookback/mclookbackengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/processes/blackscholesprocess.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE_FLOATING
#define REPORT_FAILURE_FLOATING(greekName, minmax, payoff, exercise, \
                                s, q, r, today, v, \
                                expected, calculated, error, tolerance) \
    BOOST_ERROR( \
        exerciseTypeToString(exercise) \
        << payoff->optionType() << " lookback option with " \
        << payoffTypeToString(payoff) << " payoff:\n" \
        << "    underlying value: " << s << "\n" \
        << "    dividend yield:   " << io::rate(q) << "\n" \
        << "    risk-free rate:   " << io::rate(r) << "\n" \
        << "    reference date:   " << today << "\n" \
        << "    maturity:         " << exercise->lastDate() << "\n" \
        << "    volatility:       " << io::volatility(v) << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);

#undef REPORT_FAILURE_FIXED
#define REPORT_FAILURE_FIXED(greekName, minmax, payoff, exercise, \
                             s, q, r, today, v, \
                             expected, calculated, error, tolerance) \
    BOOST_ERROR( \
        exerciseTypeToString(exercise) \
        << payoff->optionType() << " lookback option with " \
        << payoffTypeToString(payoff) << " payoff:\n" \
        << "    underlying value: " << s << "\n" \
        << "    strike:           " << payoff->strike() << "\n" \
        << "    dividend yield:   " << io::rate(q) << "\n" \
        << "    risk-free rate:   " << io::rate(r) << "\n" \
        << "    reference date:   " << today << "\n" \
        << "    maturity:         " << exercise->lastDate() << "\n" \
        << "    volatility:       " << io::volatility(v) << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);

#undef REPORT_FAILURE_MC
#define REPORT_FAILURE_MC(lookbackType, optionType, analytical, monteCarlo, tolerance) \
    BOOST_ERROR( \
        "Analytical and MC " << lookbackType << " " << optionType << " values differed by more than tolerance" << "\n" \
        << "    Analytical:    " << analytical << "\n" \
        << "    Monte Carlo:   " << monteCarlo << "\n" \
        << "    tolerance:     " << tolerance << "\n" \
        << "    difference:    " << std::abs(analytical - monteCarlo));

namespace {

    struct LookbackOptionData {
        Option::Type type;
        Real strike;
        Real minmax;
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Time t;        // time to maturity
        Volatility v;  // volatility

        //Partial-time lookback options:
        Real l;        // level above/below actual extremum
        Real t1;       // time to start of lookback period

        Real result;   // result
        Real tol;      // tolerance
    };

}


void LookbackOptionTest::testAnalyticContinuousFloatingLookback() {

    BOOST_TEST_MESSAGE(
           "Testing analytic continuous floating-strike lookback options...");


    LookbackOptionData values[] = {

        // data from "Option Pricing Formulas", Haug, 1998, pg.61-62

        // type,             strike, minmax, s,     q,    r,    t,    v,    l, t1, result,  tol
        {  Option::Call,     0,      100,    120.0, 0.06, 0.10, 0.50, 0.30, 0, 0,  25.3533, 1.0e-4},

        // data from "Connecting discrete and continuous path-dependent options",
        // Broadie, Glasserman & Kou, 1999, pg.70-74

        // type,             strike, minmax, s,     q,    r,    t,    v,    l, t1, result,  tol
        {  Option::Call,     0,      100,    100.0, 0.00, 0.05, 1.00, 0.30, 0, 0,  23.7884, 1.0e-4},
        {  Option::Call,     0,      100,    100.0, 0.00, 0.05, 0.20, 0.30, 0, 0,  10.7190, 1.0e-4},
        {  Option::Call,     0,      100,    110.0, 0.00, 0.05, 0.20, 0.30, 0, 0,  14.4597, 1.0e-4},
        {  Option::Put,      0,      100,    100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  15.3526, 1.0e-4},
        {  Option::Put,      0,      110,    100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  16.8468, 1.0e-4},
        {  Option::Put,      0,      120,    100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  21.0645, 1.0e-4},
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<FloatingTypePayoff> payoff(new FloatingTypePayoff(value.type));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                  new AnalyticContinuousFloatingLookbackEngine(stochProcess));

        ContinuousFloatingLookbackOption option(value.minmax, payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE_FLOATING("value", values[i].minmax, payoff, exercise, value.s, value.q,
                                    value.r, today, value.v, expected, calculated, error,
                                    value.tol);
        }
    }
}


void LookbackOptionTest::testAnalyticContinuousFixedLookback() {

    BOOST_TEST_MESSAGE(
              "Testing analytic continuous fixed-strike lookback options...");

    LookbackOptionData values[] = {
        // data from "Option Pricing Formulas", Haug, 1998, pg.63-64
        //type,            strike, minmax,  s,     q,    r,    t,    v,    l, t1, result,  tol
        { Option::Call,    95,     100,     100.0, 0.00, 0.10, 0.50, 0.10, 0, 0,  13.2687, 1.0e-4},
        { Option::Call,    95,     100,     100.0, 0.00, 0.10, 0.50, 0.20, 0, 0,  18.9263, 1.0e-4},
        { Option::Call,    95,     100,     100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  24.9857, 1.0e-4},
        { Option::Call,    100,    100,     100.0, 0.00, 0.10, 0.50, 0.10, 0, 0,   8.5126, 1.0e-4},
        { Option::Call,    100,    100,     100.0, 0.00, 0.10, 0.50, 0.20, 0, 0,  14.1702, 1.0e-4},
        { Option::Call,    100,    100,     100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  20.2296, 1.0e-4},
        { Option::Call,    105,    100,     100.0, 0.00, 0.10, 0.50, 0.10, 0, 0,   4.3908, 1.0e-4},
        { Option::Call,    105,    100,     100.0, 0.00, 0.10, 0.50, 0.20, 0, 0,   9.8905, 1.0e-4},
        { Option::Call,    105,    100,     100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  15.8512, 1.0e-4},
        { Option::Call,    95,     100,     100.0, 0.00, 0.10, 1.00, 0.10, 0, 0,  18.3241, 1.0e-4},
        { Option::Call,    95,     100,     100.0, 0.00, 0.10, 1.00, 0.20, 0, 0,  26.0731, 1.0e-4},
        { Option::Call,    95,     100,     100.0, 0.00, 0.10, 1.00, 0.30, 0, 0,  34.7116, 1.0e-4},
        { Option::Call,    100,    100,     100.0, 0.00, 0.10, 1.00, 0.10, 0, 0,  13.8000, 1.0e-4},
        { Option::Call,    100,    100,     100.0, 0.00, 0.10, 1.00, 0.20, 0, 0,  21.5489, 1.0e-4},
        { Option::Call,    100,    100,     100.0, 0.00, 0.10, 1.00, 0.30, 0, 0,  30.1874, 1.0e-4},
        { Option::Call,    105,    100,     100.0, 0.00, 0.10, 1.00, 0.10, 0, 0,   9.5445, 1.0e-4},
        { Option::Call,    105,    100,     100.0, 0.00, 0.10, 1.00, 0.20, 0, 0,  17.2965, 1.0e-4},
        { Option::Call,    105,    100,     100.0, 0.00, 0.10, 1.00, 0.30, 0, 0,  25.9002, 1.0e-4},

        {  Option::Put,    95,     100,     100.0, 0.00, 0.10, 0.50, 0.10, 0, 0,   0.6899, 1.0e-4},
        {  Option::Put,    95,     100,     100.0, 0.00, 0.10, 0.50, 0.20, 0, 0,   4.4448, 1.0e-4},
        {  Option::Put,    95,     100,     100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,   8.9213, 1.0e-4},
        {  Option::Put,    100,    100,     100.0, 0.00, 0.10, 0.50, 0.10, 0, 0,   3.3917, 1.0e-4},
        {  Option::Put,    100,    100,     100.0, 0.00, 0.10, 0.50, 0.20, 0, 0,   8.3177, 1.0e-4},
        {  Option::Put,    100,    100,     100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  13.1579, 1.0e-4},
        {  Option::Put,    105,    100,     100.0, 0.00, 0.10, 0.50, 0.10, 0, 0,   8.1478, 1.0e-4},
        {  Option::Put,    105,    100,     100.0, 0.00, 0.10, 0.50, 0.20, 0, 0,  13.0739, 1.0e-4},
        {  Option::Put,    105,    100,     100.0, 0.00, 0.10, 0.50, 0.30, 0, 0,  17.9140, 1.0e-4},
        {  Option::Put,    95,     100,     100.0, 0.00, 0.10, 1.00, 0.10, 0, 0,   1.0534, 1.0e-4},
        {  Option::Put,    95,     100,     100.0, 0.00, 0.10, 1.00, 0.20, 0, 0,   6.2813, 1.0e-4},
        {  Option::Put,    95,     100,     100.0, 0.00, 0.10, 1.00, 0.30, 0, 0,  12.2376, 1.0e-4},
        {  Option::Put,    100,    100,     100.0, 0.00, 0.10, 1.00, 0.10, 0, 0,   3.8079, 1.0e-4},
        {  Option::Put,    100,    100,     100.0, 0.00, 0.10, 1.00, 0.20, 0, 0,  10.1294, 1.0e-4},
        {  Option::Put,    100,    100,     100.0, 0.00, 0.10, 1.00, 0.30, 0, 0,  16.3889, 1.0e-4},
        {  Option::Put,    105,    100,     100.0, 0.00, 0.10, 1.00, 0.10, 0, 0,   8.3321, 1.0e-4},
        {  Option::Put,    105,    100,     100.0, 0.00, 0.10, 1.00, 0.20, 0, 0,  14.6536, 1.0e-4},
        {  Option::Put,    105,    100,     100.0, 0.00, 0.10, 1.00, 0.30, 0, 0,  20.9130, 1.0e-4}

    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                     new AnalyticContinuousFixedLookbackEngine(stochProcess));

        ContinuousFixedLookbackOption option(value.minmax, payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE_FIXED("value", values[i].minmax, payoff, exercise, value.s, value.q,
                                 value.r, today, value.v, expected, calculated, error, value.tol);
        }
    }
}

void LookbackOptionTest::testAnalyticContinuousPartialFloatingLookback() {

    BOOST_TEST_MESSAGE(
           "Testing analytic continuous partial floating-strike lookback options...");


    LookbackOptionData values[] = {

        // data from "Option Pricing Formulas, Second Edition", Haug, 2006, pg.146

        //type,         strike, minmax, s,    q,    r,    t,    v,    l,  t1,     result,   tol
        { Option::Call, 0,       90,     90,   0,   0.06, 1,    0.1,  1,  0.25,   8.6524,   1.0e-4},
        { Option::Call, 0,       90,     90,   0,   0.06, 1,    0.1,  1,  0.5,    9.2128,   1.0e-4},
        { Option::Call, 0,       90,     90,   0,   0.06, 1,    0.1,  1,  0.75,   9.5567,   1.0e-4},

        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.1,  1,  0.25,  10.5751,   1.0e-4},
        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.1,  1,  0.5,   11.2601,   1.0e-4},
        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.1,  1,  0.75,  11.6804,   1.0e-4},

        { Option::Call, 0,       90,     90,   0,   0.06, 1,    0.2,  1,  0.25,  13.3402,   1.0e-4},
        { Option::Call, 0,       90,     90,   0,   0.06, 1,    0.2,  1,  0.5,   14.5121,   1.0e-4},
        { Option::Call, 0,       90,     90,   0,   0.06, 1,    0.2,  1,  0.75,  15.314,    1.0e-4},

        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.2,  1,  0.25,  16.3047,   1.0e-4},
        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.2,  1,  0.5,   17.737,    1.0e-4},
        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.2,  1,  0.75,  18.7171,   1.0e-4},

        { Option::Call, 0,      90,      90,    0,  0.06, 1,    0.3,  1,  0.25,  17.9831,   1.0e-4},
        { Option::Call, 0,      90,      90,    0,  0.06, 1,    0.3,  1,  0.5,   19.6618,   1.0e-4},
        { Option::Call, 0,      90,      90,    0,  0.06, 1,    0.3,  1,  0.75,  20.8493,   1.0e-4},

        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.3,  1,  0.25,  21.9793,   1.0e-4},
        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.3,  1,  0.5,   24.0311,   1.0e-4},
        { Option::Call, 0,      110,    110,   0,   0.06, 1,    0.3,  1,  0.75,  25.4825,   1.0e-4},

        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.1,  1,  0.25,   2.7189,   1.0e-4},
        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.1,  1,  0.5,    3.4639,   1.0e-4},
        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.1,  1,  0.75,   4.1912,   1.0e-4},

        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.1,  1,  0.25,   3.3231,   1.0e-4},
        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.1,  1,  0.5,    4.2336,   1.0e-4},
        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.1,  1,  0.75,   5.1226,   1.0e-4},

        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.2,  1,  0.25,   7.9153,   1.0e-4},
        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.2,  1,  0.5,    9.5825,   1.0e-4},
        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.2,  1,  0.75,  11.0362,   1.0e-4},

        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.2,  1,  0.25,   9.6743,   1.0e-4},
        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.2,  1,  0.5,   11.7119,   1.0e-4},
        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.2,  1,  0.75,  13.4887,   1.0e-4},

        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.3,  1,  0.25,  13.4719,   1.0e-4},
        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.3,  1,  0.5,   16.1495,   1.0e-4},
        { Option::Put, 0,       90,      90,   0,   0.06, 1,    0.3,  1,  0.75,  18.4071,   1.0e-4},

        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.3,  1,  0.25,  16.4657,   1.0e-4},
        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.3,  1,  0.5,   19.7383,   1.0e-4},
        { Option::Put, 0,      110,     110,   0,   0.06, 1,    0.3,  1,  0.75,  22.4976,   1.0e-4}
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<FloatingTypePayoff> payoff(new FloatingTypePayoff(value.type));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                  new AnalyticContinuousPartialFloatingLookbackEngine(stochProcess));

        Date lookbackEnd = today + timeToDays(value.t1);
        ContinuousPartialFloatingLookbackOption option(value.minmax, value.l, lookbackEnd, payoff,
                                                       exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE_FLOATING("value", values[i].minmax, payoff, exercise, value.s, value.q,
                                    value.r, today, value.v, expected, calculated, error,
                                    value.tol);
        }
    }
}

void LookbackOptionTest::testAnalyticContinuousPartialFixedLookback() {

    BOOST_TEST_MESSAGE(
              "Testing analytic continuous fixed-strike lookback options...");

    LookbackOptionData values[] = {
        // data from "Option Pricing Formulas, Second Edition", Haug, 2006, pg.148
        //type,         strike, minmax, s,    q,    r,    t,    v, l,   t1,  result,   tol
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.1, 0, 0.25,  20.2845, 1.0e-4},
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.1, 0, 0.5,   19.6239, 1.0e-4},
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.1, 0, 0.75,  18.6244, 1.0e-4},
        
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.1, 0, 0.25,   4.0432, 1.0e-4},
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.1, 0, 0.5,    3.958,  1.0e-4},
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.1, 0, 0.75,   3.7015, 1.0e-4},
        
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.2, 0, 0.25,  27.5385, 1.0e-4},
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.2, 0, 0.5,   25.8126, 1.0e-4},
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.2, 0, 0.75,  23.4957, 1.0e-4},
        
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.2, 0, 0.25,  11.4895, 1.0e-4},
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.2, 0, 0.5,   10.8995, 1.0e-4},
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.2, 0, 0.75,   9.8244, 1.0e-4},
        
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.3, 0, 0.25,  35.4578, 1.0e-4},
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.3, 0, 0.5,   32.7172, 1.0e-4},
        { Option::Call,     90, 0,    100,    0, 0.06,    1,  0.3, 0, 0.75,  29.1473, 1.0e-4},
        
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.3, 0, 0.25,  19.725,  1.0e-4},
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.3, 0, 0.5,   18.4025, 1.0e-4},
        { Option::Call,    110, 0,    100,    0, 0.06,    1,  0.3, 0, 0.75,  16.2976, 1.0e-4},
        
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.1, 0, 0.25,   0.4973, 1.0e-4},
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.1, 0, 0.5,    0.4632, 1.0e-4},
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.1, 0, 0.75,   0.3863, 1.0e-4},
        
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.1, 0, 0.25,  12.6978, 1.0e-4},
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.1, 0, 0.5,   10.9492, 1.0e-4},
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.1, 0, 0.75,   9.1555, 1.0e-4},
        
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.2, 0, 0.25,   4.5863, 1.0e-4},
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.2, 0, 0.5,    4.1925, 1.0e-4},
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.2, 0, 0.75,   3.5831, 1.0e-4},
        
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.2, 0, 0.25,  19.0255, 1.0e-4},
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.2, 0, 0.5,   16.9433, 1.0e-4},
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.2, 0, 0.75,  14.6505, 1.0e-4},
        
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.3, 0, 0.25,   9.9348, 1.0e-4},
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.3, 0, 0.5,    9.1111, 1.0e-4},
        { Option::Put,      90, 0,    100,    0, 0.06,    1,  0.3, 0, 0.75,   7.9267, 1.0e-4},
        
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.3, 0, 0.25,  25.2112, 1.0e-4},
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.3, 0, 0.5,   22.8217, 1.0e-4},
        { Option::Put,     110, 0,    100,    0, 0.06,    1,  0.3, 0, 0.75,  20.0566, 1.0e-4}
    };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                            new BlackScholesMertonProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                     new AnalyticContinuousPartialFixedLookbackEngine(stochProcess));

        Date lookbackStart = today + timeToDays(value.t1);
        ContinuousPartialFixedLookbackOption option(lookbackStart,
                                             payoff,
                                             exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol) {
            REPORT_FAILURE_FIXED("value", values[i].minmax, payoff, exercise, value.s, value.q,
                                 value.r, today, value.v, expected, calculated, error, value.tol);
        }
    }
}

void LookbackOptionTest::testMonteCarloLookback() {
    BOOST_TEST_MESSAGE("Testing Monte Carlo engines for lookback options...");

    Real tolerance = 0.1;

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    Real strike = 90;
    Real t = 1;
    Real t1= 0.25;

    Date exDate = today + timeToDays(t);
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    spot ->setValue(100);
    qRate->setValue(0);
    rRate->setValue(0.06);
    vol  ->setValue(0.1);

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
        new BlackScholesMertonProcess(
            Handle<Quote>(spot),
            Handle<YieldTermStructure>(qTS),
            Handle<YieldTermStructure>(rTS),
            Handle<BlackVolTermStructure>(volTS)));

    Option::Type types[] = { Option::Call, Option::Put };

    for (auto type : types) {
        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));

        /**
         * Partial Fixed
         * **/

        Date lookbackStart = today + timeToDays(t1);
        ContinuousPartialFixedLookbackOption partialFixedLookback(lookbackStart,
                                                                  payoff,
                                                                  exercise);
        ext::shared_ptr<PricingEngine> engine(
            new AnalyticContinuousPartialFixedLookbackEngine(stochProcess));
        partialFixedLookback.setPricingEngine(engine);

        Real analytical = partialFixedLookback.NPV();

        ext::shared_ptr<PricingEngine> mcpartialfixedengine =
            MakeMCLookbackEngine<ContinuousPartialFixedLookbackOption, PseudoRandom>
            (stochProcess)
            .withSteps(2000)
            .withAntitheticVariate()
            .withSeed(1)
            .withAbsoluteTolerance(tolerance);

        partialFixedLookback.setPricingEngine(mcpartialfixedengine);
        Real monteCarlo = partialFixedLookback.NPV();

        Real diff = std::abs(analytical - monteCarlo);

        if (diff > tolerance){
            REPORT_FAILURE_MC("Partial Fixed", type, analytical, monteCarlo, tolerance);
        }

        /**
         * Fixed
         * **/

        Real minMax = 100;

        ContinuousFixedLookbackOption fixedLookback(minMax,
                                                    payoff,
                                                    exercise);
        ext::shared_ptr<PricingEngine> analyticalfixedengine(
            new AnalyticContinuousFixedLookbackEngine(stochProcess));
        fixedLookback.setPricingEngine(analyticalfixedengine);

        analytical = fixedLookback.NPV();

        ext::shared_ptr<PricingEngine> mcfixedengine =
            MakeMCLookbackEngine<ContinuousFixedLookbackOption, PseudoRandom>
            (stochProcess)
            .withSteps(2000)
            .withAntitheticVariate()
            .withSeed(1)
            .withAbsoluteTolerance(tolerance);

        fixedLookback.setPricingEngine(mcfixedengine);
        monteCarlo = fixedLookback.NPV();

        diff = std::abs(analytical - monteCarlo);

        if (diff > tolerance){
            REPORT_FAILURE_MC("Fixed", type, analytical, monteCarlo, tolerance);
        }

        /**
         * Partial Floating
         * **/

        Real lambda = 1;
        Date lookbackEnd = today + timeToDays(t1);

        ext::shared_ptr<FloatingTypePayoff> floatingPayoff(new FloatingTypePayoff(type));

        ContinuousPartialFloatingLookbackOption partialFloating(minMax,
                                                                lambda,
                                                                lookbackEnd,
                                                                floatingPayoff,
                                                                exercise);
        ext::shared_ptr<PricingEngine> analyticalpartialFloatingengine(
            new AnalyticContinuousPartialFloatingLookbackEngine(stochProcess));
        partialFloating.setPricingEngine(analyticalpartialFloatingengine);

        analytical = partialFloating.NPV();

        ext::shared_ptr<PricingEngine> mcpartialfloatingengine =
            MakeMCLookbackEngine<ContinuousPartialFloatingLookbackOption, PseudoRandom>
            (stochProcess)
            .withSteps(2000)
            .withAntitheticVariate()
            .withSeed(1)
            .withAbsoluteTolerance(tolerance);

        partialFloating.setPricingEngine(mcpartialfloatingengine);
        monteCarlo = partialFloating.NPV();

        diff = std::abs(analytical - monteCarlo);

        if (diff > tolerance){
            REPORT_FAILURE_MC("Partial Floating", type, analytical, monteCarlo, tolerance);
        }

        /**
         * Floating
         * **/

        ContinuousFloatingLookbackOption floating(minMax,
                                                  floatingPayoff,
                                                  exercise);
        ext::shared_ptr<PricingEngine> analyticalFloatingengine(
            new AnalyticContinuousFloatingLookbackEngine(stochProcess));
        floating.setPricingEngine(analyticalFloatingengine);

        analytical = floating.NPV();

        ext::shared_ptr<PricingEngine> mcfloatingengine =
            MakeMCLookbackEngine<ContinuousFloatingLookbackOption, PseudoRandom>
            (stochProcess)
            .withSteps(2000)
            .withAntitheticVariate()
            .withSeed(1)
            .withAbsoluteTolerance(tolerance);

        floating.setPricingEngine(mcfloatingengine);
        monteCarlo = floating.NPV();

        diff = std::abs(analytical - monteCarlo);

        if (diff > tolerance){
            REPORT_FAILURE_MC("Floating", type, analytical, monteCarlo, tolerance);
        }
    }
}


test_suite* LookbackOptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Lookback option tests");

    suite->add(QUANTLIB_TEST_CASE(&LookbackOptionTest::testAnalyticContinuousFloatingLookback));
    suite->add(QUANTLIB_TEST_CASE(&LookbackOptionTest::testAnalyticContinuousFixedLookback));
    suite->add(QUANTLIB_TEST_CASE(&LookbackOptionTest::testAnalyticContinuousPartialFloatingLookback));
    suite->add(QUANTLIB_TEST_CASE(&LookbackOptionTest::testAnalyticContinuousPartialFixedLookback));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&LookbackOptionTest::testMonteCarloLookback));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="170">
    <source>lookbackoptions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_lookback_options_hpp
#define quantlib_test_lookback_options_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class LookbackOptionTest {
  public:
    static void testAnalyticContinuousFloatingLookback();
    static void testAnalyticContinuousFixedLookback();
    static void testAnalyticContinuousPartialFloatingLookback();
    static void testAnalyticContinuousPartialFixedLookback();
    static void testMonteCarloLookback();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="171">
    <source>lowdiscrepancysequences.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "lowdiscrepancysequences.hpp"
#include "utilities.hpp"
#include <ql/math/statistics/discrepancystatistics.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/math/randomnumbers/faurersg.hpp>
#include <ql/math/randomnumbers/haltonrsg.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/randomnumbers/seedgenerator.hpp>
#include <ql/math/randomnumbers/primitivepolynomials.hpp>
#include <ql/math/randomnumbers/randomizedlds.hpp>
#include <ql/math/randomnumbers/randomsequencegenerator.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/randomnumbers/latticerules.hpp>
#include <ql/math/randomnumbers/latticersg.hpp>

//#define PRINT_ONLY
#ifdef PRINT_ONLY
#include <fstream>
#endif

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::fabs;

void LowDiscrepancyTest::testSeedGenerator() {
    BOOST_TEST_MESSAGE("Testing random-seed generator...");
    SeedGenerator::instance().get();
}

void LowDiscrepancyTest::testPolynomialsModuloTwo() {

    BOOST_TEST_MESSAGE("Testing " << PPMT_MAX_DIM <<
                       " primitive polynomials modulo two...");

    const Size jj[] = {
                 1,       1,       2,       2,       6,       6,      18,
                16,      48,      60,     176,     144,     630,     756,
              1800,    2048,    7710,    7776,   27594,   24000,   84672,
            120032,  356960,  276480, 1296000, 1719900, 4202496
    };

    Size i=0,j=0,n=0;
    BigInteger polynomial=0;
    while (n<PPMT_MAX_DIM || polynomial!=-1) {
        if (polynomial==-1) {
            ++i; // Increase degree index
            j=0; // Reset index of polynomial in degree.
        }
        polynomial = PrimitivePolynomials[i][j];
        if (polynomial==-1) {
            --n;
            if (j!=jj[i]) {
                BOOST_ERROR("Only " << j << " polynomials in degree " << i+1
                            << " instead of " << jj[i]);
            }
        }
        ++j; // Increase index of polynomial in degree i+1
        ++n; // Increase overall polynomial counter
    }

}

void LowDiscrepancyTest::testRandomizedLowDiscrepancySequence() {

    BOOST_TEST_MESSAGE("Testing randomized low-discrepancy sequences up to "
                       "dimension " << PPMT_MAX_DIM << "...");

    RandomizedLDS<SobolRsg, RandomSequenceGenerator<MersenneTwisterUniformRng> > rldsg(PPMT_MAX_DIM);
    rldsg.nextSequence();
    rldsg.lastSequence();
    rldsg.nextRandomizer();

    MersenneTwisterUniformRng t0;
    SobolRsg t1(PPMT_MAX_DIM);
    RandomSequenceGenerator<MersenneTwisterUniformRng> t2(PPMT_MAX_DIM);
    RandomizedLDS<SobolRsg, RandomSequenceGenerator<MersenneTwisterUniformRng> > rldsg2(t1, t2);
    rldsg2.nextSequence();
    rldsg2.lastSequence();
    rldsg2.nextRandomizer();

    RandomizedLDS<SobolRsg, RandomSequenceGenerator<MersenneTwisterUniformRng> > rldsg3(t1);
    rldsg3.nextSequence();
    rldsg3.lastSequence();
    rldsg3.nextRandomizer();

}

namespace
{
    void testRandomizedLatticeRule(LatticeRule::type name,
                                   const std::string& nameString)
    {
        Size maxDim = 30;
        Size N = 1024;
        Size numberBatches = 32;

        BOOST_TEST_MESSAGE("Testing randomized lattice sequences (" << nameString
                           << ") up to dimension " << maxDim << "...");

        std::vector<Real> z;

        LatticeRule::getRule(name, z, N);
        LatticeRsg latticeGenerator(maxDim,
            z,
            N);

        unsigned long seed = 12345678UL;
        MersenneTwisterUniformRng rng( seed);

        RandomSequenceGenerator<MersenneTwisterUniformRng> rsg(maxDim,
                                                               rng);

        RandomizedLDS<LatticeRsg, RandomSequenceGenerator<MersenneTwisterUniformRng> > rldsg(latticeGenerator,rsg);

        SequenceStatistics outerStats(maxDim);

        for (Size i=0; i < numberBatches; ++i)
        {
            SequenceStatistics innerStats(maxDim);
            for (Size j=0; j < N; ++j)
            {
                innerStats.add(rldsg.nextSequence().value);
            }
            outerStats.add(innerStats.mean());
            rldsg.nextRandomizer();
        }

        std::vector<Real> means(outerStats.mean());
        std::vector<Real> sds(outerStats.errorEstimate());

        std::vector<Real> errorInSds(maxDim);

        for (Size i=0; i < maxDim; ++i)
            errorInSds[i] = (means[i]-0.5)/ sds[i];

        Real tolerance = 4.0;

        for (Size i=0; i < maxDim; ++i)
            if (fabs(errorInSds[i] ) > tolerance)
                BOOST_ERROR("Lattice generator" << nameString <<" returns  a mean of " <<
                means[i] << " with error equal to  " << errorInSds[i]
            << " standard deviations in dimension " << i);
    }
}


void LowDiscrepancyTest::testRandomizedLattices()
{
    testRandomizedLatticeRule(LatticeRule::A, "A");
    testRandomizedLatticeRule(LatticeRule::B, "B");
    testRandomizedLatticeRule(LatticeRule::C, "C");
    testRandomizedLatticeRule(LatticeRule::D, "D");

}


void LowDiscrepancyTest::testSobol() {

    BOOST_TEST_MESSAGE("Testing Sobol sequences up to dimension "
                       << PPMT_MAX_DIM << "...");

    std::vector<Real> point;
    Real tolerance = 1.0e-15;

    // testing max dimensionality
    Size dimensionality = PPMT_MAX_DIM;
    BigNatural seed = 123456;
    SobolRsg rsg(dimensionality, seed);
    Size points = 100, i;
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        if (point.size()!=dimensionality) {
            BOOST_ERROR("Sobol sequence generator returns "
                        " a sequence of wrong dimensionality: " << point.size()
                        << " instead of  " << dimensionality);
        }
    }

    // testing homogeneity properties
    dimensionality = 33;
    seed = 123456;
    rsg = SobolRsg(dimensionality, seed);
    SequenceStatistics stat(dimensionality);
    std::vector<Real> mean;
    Size k = 0;
    for (Integer j=1; j<5; j++) { // five cycle
        points = Size(std::pow(2.0, j))-1; // base 2
        for (; k<points; k++) {
            point = rsg.nextSequence().value;
            stat.add(point);
        }
        mean = stat.mean();
        for (i=0; i<dimensionality; i++) {
            Real error = std::fabs(mean[i]-0.5);
            if (error > tolerance) {
                BOOST_ERROR(io::ordinal(i+1) << " dimension: "
                            << std::fixed
                            << "mean (" << mean[i]
                            << ") at the end of the " << io::ordinal(j+1)
                            << " cycle in Sobol sequence is not " << 0.5
                            << std::scientific
                            << " (error = " << error << ")");
            }
        }
    }

    // testing first dimension (van der Corput sequence)
    const Real vanderCorputSequenceModuloTwo[] = {
        // first cycle (zero excluded)
        0.50000,
        // second cycle
        0.75000, 0.25000,
        // third cycle
        0.37500, 0.87500, 0.62500, 0.12500,
        // fourth cycle
        0.18750, 0.68750, 0.93750, 0.43750, 0.31250, 0.81250, 0.56250, 0.06250,
        // fifth cycle
        0.09375, 0.59375, 0.84375, 0.34375, 0.46875, 0.96875, 0.71875, 0.21875,
        0.15625, 0.65625, 0.90625, 0.40625, 0.28125, 0.78125, 0.53125, 0.03125
    };

    dimensionality = 1;
    rsg = SobolRsg(dimensionality);
    points = Size(std::pow(2.0, 5))-1; // five cycles
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw ("
                        << std::fixed << point[0]
                        << ") in 1-D Sobol sequence is not in the "
                        << "van der Corput sequence modulo two: "
                        << "it should have been "
                        << vanderCorputSequenceModuloTwo[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }
}

void LowDiscrepancyTest::testFaure() {

    BOOST_TEST_MESSAGE("Testing Faure sequences...");

    std::vector<Real> point;
    Real tolerance = 1.0e-15;

    // testing "high" dimensionality
    Size dimensionality = PPMT_MAX_DIM;
    FaureRsg rsg(dimensionality);
    Size points = 100, i;
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        if (point.size()!=dimensionality) {
            BOOST_ERROR("Faure sequence generator returns "
                        " a sequence of wrong dimensionality: " << point.size()
                        << " instead of  " << dimensionality);
        }
    }

    // 1-dimension Faure (van der Corput sequence base 2)
    const Real vanderCorputSequenceModuloTwo[] = {
        // first cycle (zero excluded)
        0.50000,
        // second cycle
        0.75000, 0.25000,
        // third cycle
        0.37500, 0.87500, 0.62500, 0.12500,
        // fourth cycle
        0.18750, 0.68750, 0.93750, 0.43750, 0.31250, 0.81250, 0.56250, 0.06250,
        // fifth cycle
        0.09375, 0.59375, 0.84375, 0.34375, 0.46875, 0.96875, 0.71875, 0.21875,
        0.15625, 0.65625, 0.90625, 0.40625, 0.28125, 0.78125, 0.53125, 0.03125
    };
    dimensionality = 1;
    rsg = FaureRsg(dimensionality);
    points = Size(std::pow(2.0, 5))-1; // five cycles
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 1 ("
                        << std::fixed << point[0]
                        << ") in 3-D Faure sequence should have been "
                        << vanderCorputSequenceModuloTwo[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }

    // 2nd dimension of the 2-dimensional Faure sequence
    // (shuffled van der Corput sequence base 2)
    // checked with the code provided with "Economic generation of
    // low-discrepancy sequences with a b-ary gray code", by E. Thiemard
    const Real FaureDimensionTwoOfTwo[] = {
        // first cycle (zero excluded)
        0.50000,
        // second cycle
        0.25000, 0.75000,
        // third cycle
        0.37500, 0.87500, 0.12500, 0.62500,
        // fourth cycle
        0.31250, 0.81250, 0.06250, 0.56250, 0.18750, 0.68750, 0.43750, 0.93750,
        // fifth cycle
        0.46875, 0.96875, 0.21875, 0.71875, 0.09375, 0.59375, 0.34375, 0.84375,
        0.15625, 0.65625, 0.40625, 0.90625, 0.28125, 0.78125, 0.03125, 0.53125
    };
    dimensionality = 2;
    rsg = FaureRsg(dimensionality);
    points = Size(std::pow(2.0, 5))-1; // five cycles
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 1 ("
                        << std::fixed << point[0]
                        << ") in 3-D Faure sequence should have been "
                        << vanderCorputSequenceModuloTwo[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
        error = std::fabs(point[1]-FaureDimensionTwoOfTwo[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 2 ("
                        << std::fixed << point[1]
                        << ") in 3-D Faure sequence should have been "
                        << FaureDimensionTwoOfTwo[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }

    // 3-dimension Faure sequence (shuffled van der Corput sequence base 3)
    // see "Monte Carlo Methods in Financial Engineering,"
    // by Paul Glasserman, 2004 Springer Verlag, pag. 299
    const Real FaureDimensionOneOfThree[] = {
        // first cycle (zero excluded)
        1.0/3,  2.0/3,
        // second cycle
        7.0/9,  1.0/9,  4.0/9,  5.0/9,  8.0/9,  2.0/9
    };
    const Real FaureDimensionTwoOfThree[] = {
        // first cycle (zero excluded)
        1.0/3,  2.0/3,
        // second cycle
        1.0/9,  4.0/9,  7.0/9,  2.0/9,  5.0/9,  8.0/9
    };
    const Real FaureDimensionThreeOfThree[] = {
        // first cycle (zero excluded)
        1.0/3,  2.0/3,
        // second cycle
        4.0/9,  7.0/9,  1.0/9,  8.0/9,  2.0/9,  5.0/9
    };

    dimensionality = 3;
    rsg = FaureRsg(dimensionality);
    points = Size(std::pow(3.0, 2))-1; // three cycles
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        Real error = std::fabs(point[0]-FaureDimensionOneOfThree[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 1 ("
                        << std::fixed << point[0]
                        << ") in 3-D Faure sequence should have been "
                        << FaureDimensionOneOfThree[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
        error = std::fabs(point[1]-FaureDimensionTwoOfThree[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 2 ("
                        << std::fixed << point[1]
                        << ") in 3-D Faure sequence should have been "
                        << FaureDimensionTwoOfThree[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
        error = std::fabs(point[2]-FaureDimensionThreeOfThree[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw, dimension 3 ("
                        << std::fixed << point[2]
                        << ") in 3-D Faure sequence should have been "
                        << FaureDimensionThreeOfThree[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }
}

void LowDiscrepancyTest::testHalton() {

    BOOST_TEST_MESSAGE("Testing Halton sequences...");

    std::vector<Real> point;
    Real tolerance = 1.0e-15;

    // testing "high" dimensionality
    Size dimensionality = PPMT_MAX_DIM;
    HaltonRsg rsg(dimensionality, 0, false, false);
    Size points = 100, i, k;
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        if (point.size()!=dimensionality) {
            BOOST_ERROR("Halton sequence generator returns "
                        " a sequence of wrong dimensionality: " << point.size()
                        << " instead of  " << dimensionality);
        }
    }

    // testing first and second dimension (van der Corput sequence)
    const Real vanderCorputSequenceModuloTwo[] = {
        // first cycle (zero excluded)
        0.50000,
        // second cycle
        0.25000, 0.75000,
        // third cycle
        0.12500, 0.62500, 0.37500, 0.87500,
        // fourth cycle
        0.06250, 0.56250, 0.31250, 0.81250, 0.18750, 0.68750, 0.43750, 0.93750,
        // fifth cycle
        0.03125, 0.53125, 0.28125, 0.78125, 0.15625, 0.65625, 0.40625, 0.90625,
        0.09375, 0.59375, 0.34375, 0.84375, 0.21875, 0.71875, 0.46875, 0.96875,
    };

    dimensionality = 1;
    rsg = HaltonRsg(dimensionality, 0, false, false);
    points = Size(std::pow(2.0, 5))-1;  // five cycles
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
        if (error > tolerance) {
            BOOST_ERROR(io::ordinal(i+1) << " draw ("
                        << std::fixed << point[0]
                        << ") in 1-D Halton sequence is not in the "
                        << "van der Corput sequence modulo two: "
                        << "it should have been "
                        << vanderCorputSequenceModuloTwo[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }

    const Real vanderCorputSequenceModuloThree[] = {
        // first cycle (zero excluded)
        1.0/3,  2.0/3,
        // second cycle
        1.0/9,  4.0/9,  7.0/9,  2.0/9,  5.0/9,  8.0/9,
        // third cycle
        1.0/27, 10.0/27, 19.0/27,  4.0/27, 13.0/27, 22.0/27,
        7.0/27, 16.0/27, 25.0/27,  2.0/27, 11.0/27, 20.0/27,
        5.0/27, 14.0/27, 23.0/27,  8.0/27, 17.0/27, 26.0/27
    };

    dimensionality = 2;
    rsg = HaltonRsg(dimensionality, 0, false, false);
    points = Size(std::pow(3.0, 3))-1;  // three cycles of the higher dimension
    for (i=0; i<points; i++) {
        point = rsg.nextSequence().value;
        Real error = std::fabs(point[0]-vanderCorputSequenceModuloTwo[i]);
        if (error > tolerance) {
            BOOST_ERROR("First component of " << io::ordinal(i+1)
                        << " draw (" << std::fixed << point[0]
                        << ") in 2-D Halton sequence is not in the "
                        << "van der Corput sequence modulo two: "
                        << "it should have been "
                        << vanderCorputSequenceModuloTwo[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
        error = std::fabs(point[1]-vanderCorputSequenceModuloThree[i]);
        if (error > tolerance) {
            BOOST_ERROR("Second component of " << io::ordinal(i+1)
                        << " draw (" << std::fixed << point[1]
                        << ") in 2-D Halton sequence is not in the "
                        << "van der Corput sequence modulo three: "
                        << "it should have been "
                        << vanderCorputSequenceModuloThree[i]
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }

    // testing homogeneity properties
    dimensionality = 33;
    rsg = HaltonRsg(dimensionality, 0, false, false);
    SequenceStatistics stat(dimensionality);
    std::vector<Real> mean, stdev, variance, skewness, kurtosis;
    k = 0;
    Integer j;
    for (j=1; j<5; j++) { // five cycle
        points = Size(std::pow(2.0, j))-1; // base 2
        for (; k<points; k++) {
            point = rsg.nextSequence().value;
            stat.add(point);
        }
        mean = stat.mean();
        Real error = std::fabs(mean[0] - 0.5);
        if (error > tolerance) {
            BOOST_ERROR("First dimension mean (" << std::fixed << mean[0]
                        << ") at the end of the " << io::ordinal(j+1)
                        << " cycle in Halton sequence is not " << 0.5
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }

    // reset generator and gaussianstatistics
    rsg  = HaltonRsg(dimensionality, 0, false, false);
    stat.reset(dimensionality);
    k = 0;
    for (j=1; j<3; j++) { // three cycle
        points = Size(std::pow(3.0, j))-1; // base 3
        for (; k<points; k++) {
            point = rsg.nextSequence().value;
            stat.add(point);
        }
        mean = stat.mean();
        Real error = std::fabs(mean[1] - 0.5);
        if (error > tolerance) {
            BOOST_ERROR("Second dimension mean (" << std::fixed << mean[1]
                        << ") at the end of the " << io::ordinal(j+1)
                        << " cycle in Halton sequence is not " << 0.5
                        << std::scientific
                        << " (error = " << error << ")");
        }
    }

}

namespace {

    const Real dim002Discr_Sobol[] = {
        8.33e-004, 4.32e-004, 2.24e-004, 1.12e-004,
        5.69e-005, 2.14e-005 // , null
    };
    const Real dim002DiscrMersenneTwis[] = {
        8.84e-003, 5.42e-003, 5.23e-003, 4.47e-003,
        4.75e-003, 3.11e-003, 2.97e-003
    };
    const Real dim002DiscrPlain_Halton[] = {
        1.26e-003, 6.73e-004, 3.35e-004, 1.91e-004,
        1.11e-004, 5.05e-005, 2.42e-005
    };
    const Real dim002DiscrRShiftHalton[] = {1.32e-003, 7.25e-004};
    const Real dim002DiscrRStRShHalton[] = {1.35e-003, 9.43e-004};
    const Real dim002DiscrRStartHalton[] = {1.08e-003, 6.40e-004};
    const Real dim002Discr__Unit_Sobol[] = {
        8.33e-004, 4.32e-004, 2.24e-004, 1.12e-004,
        5.69e-005, 2.14e-005 // , null
    };

    const Real dim003Discr_Sobol[] = {
        1.21e-003, 6.37e-004, 3.40e-004, 1.75e-004,
        9.21e-005, 4.79e-005, 2.56e-005
    };
    const Real dim003DiscrMersenneTwis[] = {
        7.02e-003, 4.94e-003, 4.82e-003, 4.91e-003,
        3.33e-003, 2.80e-003, 2.62e-003
    };
    const Real dim003DiscrPlain_Halton[] = {
        1.63e-003, 9.62e-004, 4.83e-004, 2.67e-004,
        1.41e-004, 7.64e-005, 3.93e-005
    };
    const Real dim003DiscrRShiftHalton[] = {1.96e-003, 1.03e-003};
    const Real dim003DiscrRStRShHalton[] = {2.17e-003, 1.54e-003};
    const Real dim003DiscrRStartHalton[] = {1.48e-003, 7.77e-004};
    const Real dim003Discr__Unit_Sobol[] = {
        1.21e-003, 6.37e-004, 3.40e-004, 1.75e-004,
        9.21e-005, 4.79e-005, 2.56e-005
    };

    const Real dim005Discr_Sobol[] = {
        1.59e-003, 9.55e-004, 5.33e-004, 3.22e-004,
        1.63e-004, 9.41e-005, 5.19e-005
    };
    const Real dim005DiscrMersenneTwis[] = {
        4.28e-003, 3.48e-003, 2.48e-003, 1.98e-003,
        1.57e-003, 1.39e-003, 6.33e-004
    };
    const Real dim005DiscrPlain_Halton[] = {
        1.93e-003, 1.23e-003, 6.89e-004, 4.22e-004,
        2.13e-004, 1.25e-004, 7.17e-005
    };
    const Real dim005DiscrRShiftHalton[] = {2.02e-003, 1.36e-003};
    const Real dim005DiscrRStRShHalton[] = {2.11e-003, 1.25e-003};
    const Real dim005DiscrRStartHalton[] = {1.74e-003, 1.08e-003};
    const Real dim005Discr__Unit_Sobol[] = {
        1.85e-003, 9.39e-004, 5.19e-004, 2.99e-004,
        1.75e-004, 9.51e-005, 5.55e-005
    };

    const Real dim010DiscrJackel_Sobol[] = {
        7.08e-004, 5.31e-004, 3.60e-004, 2.18e-004,
        1.57e-004, 1.12e-004, 6.39e-005
    };
    const Real dim010DiscrSobLev_Sobol[] = {
        7.01e-004, 5.10e-004, 3.28e-004, 2.21e-004,
        1.57e-004, 1.08e-004, 6.38e-005
    };
    const Real dim010DiscrMersenneTwis[] = {
        8.83e-004, 6.56e-004, 4.87e-004, 3.37e-004,
        3.06e-004, 1.73e-004, 1.43e-004
    };
    const Real dim010DiscrPlain_Halton[] = {
        1.23e-003, 6.89e-004, 4.03e-004, 2.83e-004,
        1.61e-004, 1.08e-004, 6.69e-005
    };
    const Real dim010DiscrRShiftHalton[] = {9.25e-004, 6.40e-004};
    const Real dim010DiscrRStRShHalton[] = {8.41e-004, 5.42e-004};
    const Real dim010DiscrRStartHalton[] = {7.89e-004, 5.33e-004};
    const Real dim010Discr__Unit_Sobol[] = {
        7.67e-004, 4.92e-004, 3.47e-004, 2.34e-004,
        1.39e-004, 9.47e-005, 5.72e-005
    };

    const Real dim015DiscrJackel_Sobol[] = {
        1.59e-004, 1.23e-004, 7.73e-005, 5.51e-005,
        3.91e-005, 2.73e-005, 1.96e-005
    };
    const Real dim015DiscrSobLev_Sobol[] = {
        1.48e-004, 1.06e-004, 8.19e-005, 6.29e-005,
        4.16e-005, 2.54e-005, 1.73e-005
    };
    const Real dim015DiscrMersenneTwis[] = {
        1.63e-004, 1.12e-004, 8.36e-005, 6.09e-005,
        4.34e-005, 2.95e-005, 2.10e-005
    };
    const Real dim015DiscrPlain_Halton[] = {
        5.75e-004, 3.12e-004, 1.70e-004, 9.89e-005,
        5.33e-005, 3.45e-005, 2.11e-005
    };
    const Real dim015DiscrRShiftHalton[] = {1.75e-004, 1.19e-004};
    const Real dim015DiscrRStRShHalton[] = {1.66e-004, 1.34e-004};
    const Real dim015DiscrRStartHalton[] = {2.09e-004, 1.30e-004};
    const Real dim015Discr__Unit_Sobol[] = {
        2.24e-004, 1.39e-004, 9.86e-005, 6.02e-005,
        4.39e-005, 3.06e-005, 2.32e-005
    };

    const Real dim030DiscrJackel_Sobol[] = {
        6.43e-007, 5.28e-007, 3.88e-007, 2.49e-007,
        2.09e-007, 1.55e-007, 1.07e-007
    };
    const Real dim030DiscrSobLev_Sobol[] = {
        1.03e-006, 6.06e-007, 3.81e-007, 2.71e-007,
        2.68e-007, 1.73e-007, 1.21e-007
    };
    const Real dim030DiscrMersenneTwis[] = {
        4.38e-007, 3.25e-007, 4.47e-007, 2.85e-007,
        2.03e-007, 1.50e-007, 1.17e-007
    };
    const Real dim030DiscrPlain_Halton[] = {
        4.45e-004, 2.23e-004, 1.11e-004, 5.56e-005,
        2.78e-005, 1.39e-005, 6.95e-006
    };
    const Real dim030DiscrRShiftHalton[] = {8.11e-007, 6.05e-007};
    const Real dim030DiscrRStRShHalton[] = {1.85e-006, 1.03e-006};
    const Real dim030DiscrRStartHalton[] = {4.42e-007, 4.64e-007};
    const Real dim030Discr__Unit_Sobol[] = {
        4.35e-005, 2.17e-005, 1.09e-005, 5.43e-006,
        2.73e-006, 1.37e-006, 6.90e-007
    };

    const Real dim050DiscrJackel_Sobol[] = {
        2.98e-010, 2.91e-010, 2.62e-010, 1.53e-010,
        1.48e-010, 1.15e-010, 8.41e-011
    };
    const Real dim050DiscrSobLev_Sobol[] = {
        3.11e-010, 2.52e-010, 1.61e-010, 1.54e-010,
        1.11e-010, 8.60e-011, 1.17e-010
    };
    const Real dim050DiscrSobLem_Sobol[] = {
        4.57e-010, 6.84e-010, 3.68e-010, 2.20e-010,
        1.81e-010, 1.14e-010, 8.31e-011
    };
    const Real dim050DiscrMersenneTwis[] = {
        3.27e-010, 2.42e-010, 1.47e-010, 1.98e-010,
        2.31e-010, 1.30e-010, 8.09e-011
    };
    const Real dim050DiscrPlain_Halton[] = {
        4.04e-004, 2.02e-004, 1.01e-004, 5.05e-005,
        2.52e-005, 1.26e-005, 6.31e-006
    };
    const Real dim050DiscrRShiftHalton[] = {1.14e-010, 1.25e-010};
    const Real dim050DiscrRStRShHalton[] = {2.92e-010, 5.02e-010};
    const Real dim050DiscrRStartHalton[] = {1.93e-010, 6.82e-010};
    const Real dim050Discr__Unit_Sobol[] = {
        1.63e-005, 8.14e-006, 4.07e-006, 2.04e-006,
        1.02e-006, 5.09e-007, 2.54e-007
    };

    const Real dim100DiscrJackel_Sobol[] = {
        1.26e-018, 1.55e-018, 8.46e-019, 4.43e-019,
        4.04e-019, 2.44e-019, 4.86e-019
    };
    const Real dim100DiscrSobLev_Sobol[] = {
        1.17e-018, 2.65e-018, 1.45e-018, 7.28e-019,
        6.33e-019, 3.36e-019, 3.43e-019
    };
    const Real dim100DiscrSobLem_Sobol[] = {
        8.79e-019, 4.60e-019, 6.69e-019, 7.17e-019,
        5.81e-019, 2.97e-019, 2.64e-019
    };
    const Real dim100DiscrMersenneTwis[] = {
        5.30e-019, 7.29e-019, 3.71e-019, 3.33e-019,
        1.33e-017, 6.70e-018, 3.36e-018
    };
    const Real dim100DiscrPlain_Halton[] = {
        3.63e-004, 1.81e-004, 9.07e-005, 4.53e-005,
        2.27e-005, 1.13e-005, 5.66e-006
    };
    const Real dim100DiscrRShiftHalton[] = {3.36e-019, 2.19e-019};
    const Real dim100DiscrRStRShHalton[] = {4.44e-019, 2.24e-019};
    const Real dim100DiscrRStartHalton[] = {9.85e-020, 8.34e-019};
    const Real dim100Discr__Unit_Sobol[] = {
        4.97e-006, 2.48e-006, 1.24e-006, 6.20e-007,
        3.10e-007, 1.55e-007, 7.76e-008
    };

    const Size dimensionality[] = {2, 3, 5, 10, 15, 30, 50, 100 };

    // 7 discrepancy measures for each dimension of all sequence generators
    // would take a few days ... too long for usual/frequent test running
    const Size discrepancyMeasuresNumber = 1;

    // let's add some generality here...

    class MersenneFactory {
      public:
        typedef RandomSequenceGenerator<MersenneTwisterUniformRng>
        MersenneTwisterUniformRsg;
        typedef MersenneTwisterUniformRsg generator_type;
        MersenneTwisterUniformRsg make(Size dim,
                                       BigNatural seed) const {
            return MersenneTwisterUniformRsg(dim,seed);
        }
        std::string name() const { return "Mersenne Twister"; }
    };

    class SobolFactory {
      public:
        typedef SobolRsg generator_type;
        explicit SobolFactory(SobolRsg::DirectionIntegers unit) : unit_(unit) {}
        SobolRsg make(Size dim,
                      BigNatural seed) const {
            return SobolRsg(dim,seed,unit_);
        }
        std::string name() const {
            std::string prefix;
            switch (unit_) {
              case SobolRsg::Unit:
                prefix = "unit-initialized ";
                break;
              case SobolRsg::Jaeckel:
                prefix = "Jaeckel-initialized ";
                break;
              case SobolRsg::SobolLevitan:
                prefix = "SobolLevitan-initialized ";
                break;
              case SobolRsg::SobolLevitanLemieux:
                prefix = "SobolLevitanLemieux-initialized ";
                break;
              case SobolRsg::Kuo:
                prefix = "Kuo";
                break;
              case SobolRsg::Kuo2:
                prefix = "Kuo2";
                break;
              case SobolRsg::Kuo3:
                prefix = "Kuo3";
                break;
              default:
                QL_FAIL("unknown direction integers");
            }
            return prefix + "Sobol sequences: ";
        }
      private:
        SobolRsg::DirectionIntegers unit_;
    };

    class HaltonFactory {
      public:
        typedef HaltonRsg generator_type;
        HaltonFactory(bool randomStart, bool randomShift)
        : start_(randomStart), shift_(randomShift) {}
        HaltonRsg make(Size dim,
                       BigNatural seed) const {
            return HaltonRsg(dim,seed,start_,shift_);
        }
        std::string name() const {
            std::string prefix = start_ ?
                "random-start " :
                "";
            if (shift_)
                prefix += "random-shift ";
            return prefix + "Halton";
        }
      private:
        bool start_, shift_;
    };

    template <class T>
    void testGeneratorDiscrepancy(const T& generatorFactory,
                                  #ifndef PRINT_ONLY
                                  const Real * const discrepancy[8],
                                  const std::string&,
                                  const std::string&
                                  #else
                                  const Real * const [8],
                                  const std::string& fileName,
                                  const std::string& arrayName
                                  #endif
                                  ) {

        #ifndef PRINT_ONLY
        Real tolerance = 1.0e-2;
        #endif

        std::vector<Real> point;
        Size dim;
        BigNatural seed = 123456;
        Real discr;
        // more than 1 discrepancy measures take long time
        Size sampleLoops = std::max<Size>(1, discrepancyMeasuresNumber);

        #ifdef PRINT_ONLY
        std::ofstream outStream(fileName.c_str());
        #endif
        for (Integer i = 0; i<8; i++) {
            #ifdef PRINT_ONLY
            outStream << std::endl;
            #endif

            dim = dimensionality[i];
            DiscrepancyStatistics stat(dim);

            typename T::generator_type rsg = generatorFactory.make(dim, seed);

            Size j, k=0, jMin=10;
            stat.reset();
            #ifdef PRINT_ONLY
            outStream << "const Real dim" << dim
                      << arrayName << "[] = {" ;
            #endif
            for (j=jMin; j<jMin+sampleLoops; j++) {
                Size points = Size(std::pow(2.0, Integer(j)))-1;
                for (; k<points; k++) {
                    point = rsg.nextSequence().value;
                    stat.add(point);
                }

                discr = stat.discrepancy();

                #ifdef PRINT_ONLY
                if (j!=jMin)
                    outStream << ", ";
                outStream << std::fixed << std::setprecision(2) << discr;
                #else
                if (std::fabs(discr-discrepancy[i][j-jMin])>tolerance*discr) {
                    BOOST_ERROR(generatorFactory.name()
                                << "discrepancy dimension " << dimensionality[i]
                                << " at " << points << " samples is "
                                << discr << " instead of "
                                << discrepancy[i][j-jMin]);
                }
                #endif
            }
            #ifdef PRINT_ONLY
            outStream << "};" << std::endl;
            #endif
        }
        #ifdef PRINT_ONLY
        outStream.close();
        #endif
    }

}


void LowDiscrepancyTest::testMersenneTwisterDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing Mersenne-twister discrepancy...");

    const Real * const discrepancy[8] = {
        dim002DiscrMersenneTwis, dim003DiscrMersenneTwis,
        dim005DiscrMersenneTwis, dim010DiscrMersenneTwis,
        dim015DiscrMersenneTwis, dim030DiscrMersenneTwis,
        dim050DiscrMersenneTwis, dim100DiscrMersenneTwis
    };

    testGeneratorDiscrepancy(MersenneFactory(),
                             discrepancy,
                             "MersenneDiscrepancy.txt",
                             "DiscrMersenneTwis");
}

void LowDiscrepancyTest::testPlainHaltonDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing plain Halton discrepancy...");

    const Real * const discrepancy[8] = {
        dim002DiscrPlain_Halton, dim003DiscrPlain_Halton,
        dim005DiscrPlain_Halton, dim010DiscrPlain_Halton,
        dim015DiscrPlain_Halton, dim030DiscrPlain_Halton,
        dim050DiscrPlain_Halton, dim100DiscrPlain_Halton};

    testGeneratorDiscrepancy(HaltonFactory(false,false),
                             discrepancy,
                             "PlainHaltonDiscrepancy.txt",
                             "DiscrPlain_Halton");
}

void LowDiscrepancyTest::testRandomStartHaltonDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing random-start Halton discrepancy...");

    const Real * const discrepancy[8] = {
        dim002DiscrRStartHalton, dim003DiscrRStartHalton,
        dim005DiscrRStartHalton, dim010DiscrRStartHalton,
        dim015DiscrRStartHalton, dim030DiscrRStartHalton,
        dim050DiscrRStartHalton, dim100DiscrRStartHalton};

    testGeneratorDiscrepancy(HaltonFactory(true,false),
                             discrepancy,
                             "RandomStartHaltonDiscrepancy.txt",
                             "DiscrRStartHalton");
}

void LowDiscrepancyTest::testRandomShiftHaltonDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing random-shift Halton discrepancy...");

    const Real * const discrepancy[8] = {
        dim002DiscrRShiftHalton, dim003DiscrRShiftHalton,
        dim005DiscrRShiftHalton, dim010DiscrRShiftHalton,
        dim015DiscrRShiftHalton, dim030DiscrRShiftHalton,
        dim050DiscrRShiftHalton, dim100DiscrRShiftHalton};

    testGeneratorDiscrepancy(HaltonFactory(false,true),
                             discrepancy,
                             "RandomShiftHaltonDiscrepancy.txt",
                             "DiscrRShiftHalton");
}

void LowDiscrepancyTest::testRandomStartRandomShiftHaltonDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing random-start, random-shift Halton discrepancy...");

    const Real * const discrepancy[8] = {
        dim002DiscrRStRShHalton, dim003DiscrRStRShHalton,
        dim005DiscrRStRShHalton, dim010DiscrRStRShHalton,
        dim015DiscrRStRShHalton, dim030DiscrRStRShHalton,
        dim050DiscrRStRShHalton, dim100DiscrRStRShHalton};

    testGeneratorDiscrepancy(HaltonFactory(true,true),
                             discrepancy,
                             "RandomStartRandomShiftHaltonDiscrepancy.txt",
                             "DiscrRStRShHalton");
}

void LowDiscrepancyTest::testJackelSobolDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing Jaeckel-Sobol discrepancy...");

    const Real * const discrepancy[8] = {
        dim002Discr_Sobol, dim003Discr_Sobol,
        dim005Discr_Sobol, dim010DiscrJackel_Sobol,
        dim015DiscrJackel_Sobol, dim030DiscrJackel_Sobol,
        dim050DiscrJackel_Sobol, dim100DiscrJackel_Sobol};

    testGeneratorDiscrepancy(SobolFactory(SobolRsg::Jaeckel),
                             discrepancy,
                             "JackelSobolDiscrepancy.txt",
                             "DiscrJackel_Sobol");
}

void LowDiscrepancyTest::testSobolLevitanSobolDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing Levitan-Sobol discrepancy...");

    const Real * const discrepancy[8] = {
        dim002Discr_Sobol, dim003Discr_Sobol,
        dim005Discr_Sobol, dim010DiscrSobLev_Sobol,
        dim015DiscrSobLev_Sobol, dim030DiscrSobLev_Sobol,
        dim050DiscrSobLev_Sobol, dim100DiscrSobLev_Sobol};

    testGeneratorDiscrepancy(SobolFactory(SobolRsg::SobolLevitan),
                             discrepancy,
                             "SobolLevitanSobolDiscrepancy.txt",
                             "DiscrSobLev_Sobol");
}

void LowDiscrepancyTest::testSobolLevitanLemieuxSobolDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing Levitan-Lemieux-Sobol discrepancy...");

    const Real * const discrepancy[8] = {
        dim002Discr_Sobol, dim003Discr_Sobol,
        dim005Discr_Sobol, dim010DiscrSobLev_Sobol,
        dim015DiscrSobLev_Sobol, dim030DiscrSobLev_Sobol,
        dim050DiscrSobLem_Sobol, dim100DiscrSobLem_Sobol};

    testGeneratorDiscrepancy(SobolFactory(SobolRsg::SobolLevitanLemieux),
                             discrepancy,
                             "SobolLevitanLemieuxSobolDiscrepancy.txt",
                             "DiscrSobLevLem_Sobol");
}

void LowDiscrepancyTest::testUnitSobolDiscrepancy() {

    BOOST_TEST_MESSAGE("Testing unit Sobol discrepancy...");

    const Real * const discrepancy[8] = {
        dim002Discr__Unit_Sobol, dim003Discr__Unit_Sobol,
        dim005Discr__Unit_Sobol, dim010Discr__Unit_Sobol,
        dim015Discr__Unit_Sobol, dim030Discr__Unit_Sobol,
        dim050Discr__Unit_Sobol, dim100Discr__Unit_Sobol};

        testGeneratorDiscrepancy(SobolFactory(SobolRsg::Unit),
                             discrepancy,
                             "UnitSobolDiscrepancy.txt",
                             "Discr__Unit_Sobol");
}


void LowDiscrepancyTest::testSobolSkipping() {

    BOOST_TEST_MESSAGE("Testing Sobol sequence skipping...");

    unsigned long seed = 42;
    Size dimensionality[] = { 1, 10, 100, 1000 };
    unsigned long skip[] = { 0, 1, 42, 512, 100000 };
    SobolRsg::DirectionIntegers integers[] = { SobolRsg::Unit,
                                               SobolRsg::Jaeckel,
                                               SobolRsg::SobolLevitan,
                                               SobolRsg::SobolLevitanLemieux };

    for (auto& integer : integers) {
        for (Size& j : dimensionality) {
            for (unsigned long& k : skip) {

                // extract n samples
                SobolRsg rsg1(j, seed, integer);
                for (Size l = 0; l < k; l++)
                    rsg1.nextInt32Sequence();

                // skip n samples at once
                SobolRsg rsg2(j, seed, integer);
                rsg2.skipTo(k);

                // compare next 100 samples
                for (Size m = 0; m < 100; m++) {
                    std::vector<boost::uint_least32_t> s1 = rsg1.nextInt32Sequence();
                    std::vector<boost::uint_least32_t> s2 = rsg2.nextInt32Sequence();
                    for (Size n = 0; n < s1.size(); n++) {
                        if (s1[n] != s2[n]) {
                            BOOST_ERROR("Mismatch after skipping:"
                                        << "\n  size:     " << j << "\n  integers: " << integer
                                        << "\n  skipped:  " << k << "\n  at index: " << n
                                        << "\n  expected: " << s1[n] << "\n  found:    " << s2[n]);
                        }
                    }
                }
            }
        }
    }
}


test_suite* LowDiscrepancyTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Low-discrepancy sequence tests");

    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testRandomizedLattices));


    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testSeedGenerator));

    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testPolynomialsModuloTwo));

    suite->add(QUANTLIB_TEST_CASE(&LowDiscrepancyTest::testSobol));
    suite->add(QUANTLIB_TEST_CASE(&LowDiscrepancyTest::testHalton));
    suite->add(QUANTLIB_TEST_CASE(&LowDiscrepancyTest::testFaure));

    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testMersenneTwisterDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testPlainHaltonDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testRandomStartHaltonDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testRandomShiftHaltonDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testRandomStartRandomShiftHaltonDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
        &LowDiscrepancyTest::testUnitSobolDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testJackelSobolDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testSobolLevitanSobolDiscrepancy));
    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testSobolLevitanLemieuxSobolDiscrepancy));

    suite->add(QUANTLIB_TEST_CASE(&LowDiscrepancyTest::testSobolSkipping));

    suite->add(QUANTLIB_TEST_CASE(
           &LowDiscrepancyTest::testRandomizedLowDiscrepancySequence));

    return suite;
}
]]></document_content>
  </document>
  <document index="172">
    <source>lowdiscrepancysequences.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_lowdiscrepancysequences_hpp
#define quantlib_test_lowdiscrepancysequences_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class LowDiscrepancyTest {
  public:
    static void testSeedGenerator();

    static void testPolynomialsModuloTwo();

    static void testSobol();
    static void testHalton();
    static void testFaure();

    static void testMersenneTwisterDiscrepancy();
    static void testPlainHaltonDiscrepancy();
    static void testRandomStartHaltonDiscrepancy();
    static void testRandomShiftHaltonDiscrepancy();
    static void testRandomStartRandomShiftHaltonDiscrepancy();
    static void testJackelSobolDiscrepancy();
    static void testSobolLevitanSobolDiscrepancy();
    static void testSobolLevitanLemieuxSobolDiscrepancy();
    static void testUnitSobolDiscrepancy();

    static void testRandomizedLowDiscrepancySequence();

    static void testSobolSkipping();

    static void testRandomizedLattices();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="173">
    <source>main.cpp</source>
    <document_content><![CDATA[#ifdef BOOST_TEST_DYN_LINK
/* This file needs to be linked with the test suite in case the
   shared-library version of the Boost unit-test framework is used. */
#include <boost/test/unit_test.hpp>
#include <boost/test/framework.hpp>

using namespace boost::unit_test;

test_suite* init_unit_test_suite(int, char* []);

bool init_function() {
    framework::master_test_suite().add(init_unit_test_suite(0,0));
    return true;
}

int main( int argc, char* argv[] ) {
    return ::boost::unit_test::unit_test_main( &init_function, argc, argv );
}

#endif
]]></document_content>
  </document>
  <document index="174">
    <source>margrabeoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "margrabeoption.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/experimental/exoticoptions/analyticamericanmargrabeengine.hpp>
#include <ql/experimental/exoticoptions/analyticeuropeanmargrabeengine.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, exercise, \
                       s1, s2, Q1, Q2, q1, q2, r, today, v1, v2, rho,   \
                       expected, calculated, error, tolerance)          \
    BOOST_ERROR( \
        exerciseTypeToString(exercise) << " " \
        << "Call option on Exchange Asset s2 for Asset s1" \
        << " with null payoff:\n" \
        << "1st underlying value: " << s1 << "\n" \
        << "2nd underlying value: " << s2 << "\n" \
        << "1st underlying quantity: " << Q1 << "\n" \
        << "2nd underlying quantity: " << Q2 << "\n" \
        << "  1st dividend yield: " << io::rate(q1) << "\n" \
        << "  2nd dividend yield: " << io::rate(q2) << "\n" \
        << "      risk-free rate: " << io::rate(r) << "\n" \
        << "      reference date: " << today << "\n" \
        << "            maturity: " << exercise->lastDate() << "\n" \
        << "1st asset volatility: " << io::volatility(v1) << "\n" \
        << "2nd asset volatility: " << io::volatility(v2) << "\n" \
        << "         correlation: " << rho << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);

#undef REPORT_FAILURE2
#define REPORT_FAILURE2(greekName, exercise, s1, s2, q1, q2, r, today, \
                       v1, v2, expected, calculated, error, tolerance) \
    BOOST_ERROR(exerciseTypeToString(exercise) << " " \
        << "    European option with " \
        << "    null pay off      " << "\n" \
        << "    spot1 value:      " << s1 << "\n" \
        << "    spot2 value:      " << s2 << "\n" \
        << "    strike: 0         " << "\n" \
        << "    dividend yield 1: " << io::rate(q1) << "\n" \
        << "    dividend yield 2: " << io::rate(q2) << "\n" \
        << "    risk-free rate:   " << io::rate(r) << "\n" \
        << "    reference date:   " << today << "\n" \
        << "    maturity:         " << exercise->lastDate() << "\n" \
        << "    volatility 1:     " << io::volatility(v1) << "\n\n" \
        << "    volatility 2:     " << io::volatility(v2) << "\n\n" \
        << "    expected " << greekName << ":   " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);

namespace {

    struct MargrabeOptionTwoData {
        Real s1;
        Real s2;
        Integer Q1;
        Integer Q2;
        Rate q1;
        Rate q2;
        Rate r;
        Time t; // years
        Volatility v1;
        Volatility v2;
        Real rho;
        Real result;
        Real delta1;
        Real delta2;
        Real gamma1;
        Real gamma2;
        Real theta;
        Real rho_greek;
        Real tol;
    };

    struct MargrabeAmericanOptionTwoData {
        Real s1;
        Real s2;
        Integer Q1;
        Integer Q2;
        Rate q1;
        Rate q2;
        Rate r;
        Time t; // years
        Volatility v1;
        Volatility v2;
        Real rho;
        Real result;
        Real tol;
    };

}

void MargrabeOptionTest::testEuroExchangeTwoAssets() {

    BOOST_TEST_MESSAGE("Testing European one-asset-for-another option...");

    /*
        Exchange-One-Asset-for-Another European Options
    */
    MargrabeOptionTwoData values[] = {
        //Simplification : we assume that the option always exchanges S2 for S1
        //s1,  s2,  Q1,  Q2,  q1,  q2,  r,  t,  v1,  v2,  rho,  result,
                   //delta1,  delta2,  gamma1,  gamma2,  theta, rho, tol
        // data from "given article p.52"
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.15, -0.50, 2.125, 0.841, -0.818, 0.112, 0.135, -2.043, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.20, -0.50, 2.199, 0.813, -0.784, 0.109, 0.132, -2.723, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.25, -0.50, 2.283, 0.788, -0.753, 0.105, 0.126, -3.419, 0.0, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.15, 0.00, 2.045, 0.883, -0.870, 0.108, 0.131, -1.168, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.20, 0.00, 2.091, 0.857, -0.838, 0.112, 0.135, -1.698, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.25, 0.00, 2.152, 0.830, -0.805, 0.111, 0.134, -2.302, 0.0, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.15, 0.50, 1.974, 0.946, -0.942, 0.079, 0.096, -0.126, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.20, 0.50, 1.989, 0.929, -0.922, 0.092, 0.111, -0.398, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.25, 0.50, 2.019, 0.902, -0.891, 0.104, 0.125, -0.838, 0.0, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, -0.50, 2.762, 0.672, -0.602, 0.072, 0.087, -1.207, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, -0.50, 2.989, 0.661, -0.578, 0.064, 0.078, -1.457, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, -0.50, 3.228, 0.653, -0.557, 0.058, 0.070, -1.712, 0.0, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, 0.00, 2.479, 0.695, -0.640, 0.085, 0.102, -0.874, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, 0.00, 2.650, 0.680, -0.616, 0.077, 0.093, -1.078, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, 0.00, 2.847, 0.668, -0.592, 0.069, 0.083, -1.302, 0.0, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, 0.50, 2.138, 0.746, -0.713, 0.106, 0.128, -0.416, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, 0.50, 2.231, 0.728, -0.689, 0.099, 0.120, -0.550, 0.0, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, 0.50, 2.374, 0.707, -0.659, 0.090, 0.109, -0.741, 0.0, 1.0e-3},

        //Quantity tests from Excel calcuations
        {22.0, 10.0, 1, 2, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, 0.50, 2.138, 0.746, -1.426, 0.106, 0.255, -0.987, 0.0, 1.0e-3},
        {11.0, 20.0, 2, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, 0.50, 2.231, 1.455, -0.689, 0.198, 0.120, 0.410, 0.0, 1.0e-3},
        {11.0, 10.0, 2, 2, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, 0.50, 2.374, 1.413, -1.317, 0.181, 0.219, -0.336, 0.0, 1.0e-3}
    };

    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot2(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate1(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS1 = flatRate(today, qRate1, dc);
    ext::shared_ptr<SimpleQuote> qRate2(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS2 = flatRate(today, qRate2, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(today, vol2, dc);

    for (auto& value : values) {

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        spot1->setValue(value.s1);
        spot2->setValue(value.s2);
        qRate1->setValue(value.q1);
        qRate2->setValue(value.q2);
        rRate->setValue(value.r);
        vol1->setValue(value.v1);
        vol2->setValue(value.v2);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess1(new
            BlackScholesMertonProcess(Handle<Quote>(spot1),
                                      Handle<YieldTermStructure>(qTS1),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS1)));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess2(new
            BlackScholesMertonProcess(Handle<Quote>(spot2),
                                      Handle<YieldTermStructure>(qTS2),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS2)));

        std::vector<ext::shared_ptr<StochasticProcess1D> > procs = {stochProcess1, stochProcess2};

        Matrix correlationMatrix(2, 2, value.rho);
        for (Integer j=0; j < 2; j++) {
            correlationMatrix[j][j] = 1.0;
        }

        ext::shared_ptr<PricingEngine> engine(
            new AnalyticEuropeanMargrabeEngine(stochProcess1, stochProcess2, value.rho));

        MargrabeOption margrabeOption(value.Q1, value.Q2, exercise);

        // analytic engine
        margrabeOption.setPricingEngine(engine);

        Real calculated = margrabeOption.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        Real tolerance = value.tol;
        if (error > tolerance) {
            REPORT_FAILURE("value", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }

        calculated = margrabeOption.delta1();
        expected = value.delta1;
        error= std::fabs(calculated-expected);
        if (error>tolerance) {
            REPORT_FAILURE("delta1", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }

        calculated = margrabeOption.delta2();
        expected = value.delta2;
        error= std::fabs(calculated-expected);
        if (error>tolerance) {
            REPORT_FAILURE("delta2", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }

        calculated = margrabeOption.gamma1();
        expected = value.gamma1;
        error= std::fabs(calculated-expected);
        if (error>tolerance) {
            REPORT_FAILURE("gamma1", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }

        calculated = margrabeOption.gamma2();
        expected = value.gamma2;
        error= std::fabs(calculated-expected);
        if (error>tolerance) {
            REPORT_FAILURE("gamma2", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }

        calculated = margrabeOption.theta();
        expected = value.theta;
        error= std::fabs(calculated-expected);
        if (error>tolerance) {
            REPORT_FAILURE("theta", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }

        calculated = margrabeOption.rho();
        expected = value.rho_greek;
        error= std::fabs(calculated-expected);
        if (error>tolerance) {
            REPORT_FAILURE("rho_greek", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }
    }
}

void MargrabeOptionTest::testGreeks() {

    BOOST_TEST_MESSAGE("Testing analytic European exchange option greeks...");

    SavedSettings backup;

    std::map<std::string,Real> calculated, expected, tolerance;
    tolerance["delta1"]  = 1.0e-5;
    tolerance["delta2"]  = 1.0e-5;
    tolerance["gamma1"]  = 1.0e-5;
    tolerance["gamma2"]  = 1.0e-5;
    tolerance["theta"]   = 1.0e-5;
    tolerance["rho"]     = 1.0e-5;

    Real underlyings1[]  = { 22.0 };
    Real underlyings2[]  = { 20.0 };
    Rate qRates1[]       = { 0.06, 0.16, 0.04 };
    Rate qRates2[]       = { 0.04, 0.14, 0.02 };
    Rate rRates[]        = { 0.1, 0.2, 0.08 };
    Time residualTimes[] = { 0.1, 0.5 };
    Volatility vols1[]   = { 0.20 };
    Volatility vols2[]   = { 0.15, 0.20, 0.25};

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot2(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate1(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS1 = flatRate(qRate1, dc);
    ext::shared_ptr<SimpleQuote> qRate2(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS2 = flatRate(qRate2, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(vol1, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(vol2, dc);

    for (double residualTime : residualTimes) {
        Date exDate = today + timeToDays(residualTime);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

        // option to check
        ext::shared_ptr<BlackScholesMertonProcess> stochProcess1(new BlackScholesMertonProcess(
            Handle<Quote>(spot1), Handle<YieldTermStructure>(qTS1), Handle<YieldTermStructure>(rTS),
            Handle<BlackVolTermStructure>(volTS1)));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess2(new BlackScholesMertonProcess(
            Handle<Quote>(spot2), Handle<YieldTermStructure>(qTS2), Handle<YieldTermStructure>(rTS),
            Handle<BlackVolTermStructure>(volTS2)));

        std::vector<ext::shared_ptr<StochasticProcess1D> > procs = {stochProcess1, stochProcess2};

        // The correlation -0.5 can be different real between -1 and 1 for more tests
        Real correlation = -0.5;
        Matrix correlationMatrix(2, 2, correlation);
        for (Integer j = 0; j < 2; j++) {
            correlationMatrix[j][j] = 1.0;

            ext::shared_ptr<PricingEngine> engine(
                new AnalyticEuropeanMargrabeEngine(stochProcess1, stochProcess2, correlation));

            // The quantities of S1 and S2 can be different from 1 & 1 for more tests
            MargrabeOption margrabeOption(1, 1, exercise);

            // analytic engine
            margrabeOption.setPricingEngine(engine);

            for (Size l = 0; l < LENGTH(underlyings1); l++) {
                for (Size m=0; m<LENGTH(qRates1); m++) {
                    for (double n : rRates) {
                        for (Size p = 0; p < LENGTH(vols1); p++) {
                            Real u1 = underlyings1[l], u2 = underlyings2[l], u;
                            Rate q1 = qRates1[m], q2 = qRates2[m], r = n;
                            Volatility v1 = vols1[p], v2 = vols2[p];

                            spot1->setValue(u1);
                            spot2->setValue(u2);
                            qRate1->setValue(q1);
                            qRate2->setValue(q2);
                            rRate->setValue(r);
                            vol1->setValue(v1);
                            vol2->setValue(v2);

                            Real value = margrabeOption.NPV();

                            calculated["delta1"] = margrabeOption.delta1();
                            calculated["delta2"] = margrabeOption.delta2();
                            calculated["gamma1"] = margrabeOption.gamma1();
                            calculated["gamma2"] = margrabeOption.gamma2();
                            calculated["theta"] = margrabeOption.theta();
                            calculated["rho"] = margrabeOption.rho();

                            if (value > spot1->value() * 1.0e-5) {
                                // perturb spot and get delta1 and gamma
                                u = u1;
                                Real du = u * 1.0e-4;
                                spot1->setValue(u + du);
                                Real value_p = margrabeOption.NPV(),
                                     delta_p = margrabeOption.delta1();
                                spot1->setValue(u - du);
                                Real value_m = margrabeOption.NPV(),
                                     delta_m = margrabeOption.delta1();
                                spot1->setValue(u);
                                expected["delta1"] = (value_p - value_m) / (2 * du);
                                expected["gamma1"] = (delta_p - delta_m) / (2 * du);

                                u = u2;
                                spot2->setValue(u + du);
                                value_p = margrabeOption.NPV();
                                delta_p = margrabeOption.delta2();
                                spot2->setValue(u - du);
                                value_m = margrabeOption.NPV();
                                delta_m = margrabeOption.delta2();
                                spot2->setValue(u);
                                expected["delta2"] = (value_p - value_m) / (2 * du);
                                expected["gamma2"] = (delta_p - delta_m) / (2 * du);

                                // perturb rates and get rho
                                Spread dr = r * 1.0e-4;
                                rRate->setValue(r + dr);
                                value_p = margrabeOption.NPV();
                                rRate->setValue(r - dr);
                                value_m = margrabeOption.NPV();
                                rRate->setValue(r);
                                expected["rho"] = (value_p - value_m) / (2 * dr);

                                // perturb date and get theta
                                Time dT = dc.yearFraction(today - 1, today + 1);
                                Settings::instance().evaluationDate() = today - 1;
                                value_m = margrabeOption.NPV();
                                Settings::instance().evaluationDate() = today + 1;
                                value_p = margrabeOption.NPV();
                                Settings::instance().evaluationDate() = today;
                                expected["theta"] = (value_p - value_m) / dT;

                                // compare
                                std::map<std::string, Real>::iterator it;
                                for (it = calculated.begin(); it != calculated.end(); ++it) {
                                    std::string greek = it->first;
                                    Real expct = expected[greek], calcl = calculated[greek],
                                         tol = tolerance[greek];
                                    Real error = relativeError(expct, calcl, u1);
                                    if (error > tol) {
                                        REPORT_FAILURE2(greek, exercise, u1, u2, q1, q2, r, today,
                                                        v1, v2, expct, calcl, error, tol);
                                    }
                                }
                            }
                        }
                    }
                }
              }
          }
    }
}

void MargrabeOptionTest::testAmericanExchangeTwoAssets() {

    BOOST_TEST_MESSAGE("Testing American one-asset-for-another option...");

    MargrabeAmericanOptionTwoData values[] = {
        //Simplification : we assume that the option always exchanges S2 for S1
        //s1, s2, Q1, Q2, q1, q2, r, t, v1, v2, rho, result, tol
        // data from Haug

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.15, -0.50, 2.1357, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.20, -0.50, 2.2074, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.25, -0.50, 2.2902, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.15, 0.00, 2.0592, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.20, 0.00, 2.1032, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.25, 0.00, 2.1618, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.15, 0.50, 2.0001, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.20, 0.50, 2.0110, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.10, 0.20, 0.25, 0.50, 2.0359, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, -0.50, 2.8051, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, -0.50, 3.0288, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, -0.50, 3.2664, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, 0.00, 2.5282, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, 0.00, 2.6945, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, 0.00, 2.8893, 1.0e-3},

        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.15, 0.50, 2.2053, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.20, 0.50, 2.2906, 1.0e-3},
        {22.0, 20.0, 1, 1, 0.06, 0.04, 0.10, 0.50, 0.20, 0.25, 0.50, 2.4261, 1.0e-3}
    };

    Date today = Settings::instance().evaluationDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot1(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> spot2(new SimpleQuote(0.0));

    ext::shared_ptr<SimpleQuote> qRate1(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS1 = flatRate(today, qRate1, dc);
    ext::shared_ptr<SimpleQuote> qRate2(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS2 = flatRate(today, qRate2, dc);

    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(today, vol2, dc);

    for (auto& value : values) {

        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new AmericanExercise(today, exDate));

        spot1->setValue(value.s1);
        spot2->setValue(value.s2);
        qRate1->setValue(value.q1);
        qRate2->setValue(value.q2);
        rRate->setValue(value.r);
        vol1->setValue(value.v1);
        vol2->setValue(value.v2);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess1(new
            BlackScholesMertonProcess(Handle<Quote>(spot1),
                                      Handle<YieldTermStructure>(qTS1),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS1)));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess2(new
            BlackScholesMertonProcess(Handle<Quote>(spot2),
                                      Handle<YieldTermStructure>(qTS2),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS2)));

        std::vector<ext::shared_ptr<StochasticProcess1D> > procs = {stochProcess1,stochProcess2};

        Matrix correlationMatrix(2, 2, value.rho);
        for (Integer j=0; j < 2; j++) {
            correlationMatrix[j][j] = 1.0;
        }

        ext::shared_ptr<PricingEngine> engine(
            new AnalyticAmericanMargrabeEngine(stochProcess1, stochProcess2, value.rho));

        MargrabeOption margrabeOption(value.Q1, value.Q2, exercise);

        // analytic engine
        margrabeOption.setPricingEngine(engine);

        Real calculated = margrabeOption.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        Real tolerance = value.tol;
        if (error > tolerance) {
            REPORT_FAILURE("value", exercise, value.s1, value.s2, value.Q1, value.Q2, value.q1,
                           value.q2, value.r, today, value.v1, value.v2, value.rho, expected,
                           calculated, error, tolerance);
        }
    }
}

test_suite* MargrabeOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Exchange option tests");
    suite->add(
        QUANTLIB_TEST_CASE(&MargrabeOptionTest::testEuroExchangeTwoAssets));
    suite->add(
        QUANTLIB_TEST_CASE(&MargrabeOptionTest::testAmericanExchangeTwoAssets));
    suite->add(QUANTLIB_TEST_CASE(&MargrabeOptionTest::testGreeks));
    return suite;
}
]]></document_content>
  </document>
  <document index="175">
    <source>margrabeoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_margrabe_option_hpp
#define quantlib_test_margrabe_option_hpp

#include <boost/test/unit_test.hpp>

class MargrabeOptionTest {
  public:
    static void testEuroExchangeTwoAssets();
    static void testAmericanExchangeTwoAssets();
    static void testGreeks();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="176">
    <source>marketmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_market_model_hpp
#define quantlib_test_market_model_hpp

#include <ql/qldefines.hpp>
#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarketModelTest {
  public:
    enum MarketModelType { ExponentialCorrelationFlatVolatility,
        ExponentialCorrelationAbcdVolatility/*, CalibratedMM*/
    };
    static void testInverseFloater();
    static void testPeriodAdapter();
    static void testAllMultiStepProducts();
    static void testOneStepForwardsAndOptionlets();
    static void testOneStepNormalForwardsAndOptionlets();
    static void testCallableSwapNaif();
    static void testCallableSwapLS();
    static void testCallableSwapAnderson(
        MarketModelType marketModel, std::size_t testedFactor);
    static void testGreeks();
    static void testPathwiseGreeks();
    static void testPathwiseVegas();
    static void testPathwiseMarketVegas();
    static void testStochVolForwardsAndOptionlets();
    static void testAbcdVolatilityIntegration();
    static void testAbcdVolatilityCompare();
    static void testAbcdVolatilityFit();
    static void testDriftCalculator();
    static void testIsInSubset();
    static void testAbcdDegenerateCases();
    static void testCovariance();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="177">
    <source>marketmodel_cms.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "marketmodel_cms.hpp"
#include "utilities.hpp"
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/curvestates/cmswapcurvestate.hpp>
#include <ql/models/marketmodels/evolvers/lognormalcmswapratepc.hpp>
#include <ql/legacy/libormarketmodels/lmlinexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmextlinexpvolmodel.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/math/statistics/convergencestatistics.hpp>
#include <ql/math/functional.hpp>
#include <iostream>
#include <sstream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace market_model_cms_test {

    Date todaysDate, startDate, endDate;
    std::vector<Time> rateTimes;
    std::vector<Real> accruals;
    Calendar calendar;
    DayCounter dayCounter;
    std::vector<Rate> todaysForwards, todaysCMSwapRates;
    std::vector<Real> cMSwapAnnuity;
    Spread displacement;
    std::vector<DiscountFactor> todaysDiscounts;
    std::vector<Volatility> volatilities, blackVols;
    Real a, b, c, d;
    Real longTermCorrelation, beta;
    Size measureOffset_;
    unsigned long seed_;
    Size paths_, trainingPaths_;
    bool printReport_ = false;
    Size spanningForwards;

    void setup() {

        // Times
        calendar = NullCalendar();
        todaysDate = Settings::instance().evaluationDate();
        //startDate = todaysDate + 5*Years;
        endDate = todaysDate + 10*Years;
        Schedule dates(todaysDate, endDate, Period(Semiannual),
                       calendar, Following, Following,
                       DateGeneration::Backward, false);
        rateTimes = std::vector<Time>(dates.size()-1);

        accruals = std::vector<Real>(rateTimes.size()-1);
        dayCounter = SimpleDayCounter();
        for (Size i=1; i<dates.size(); ++i)
            rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

        for (Size i=1; i<rateTimes.size(); ++i)
            accruals[i-1] = rateTimes[i] - rateTimes[i-1];

        // Rates & displacement
        todaysForwards = std::vector<Rate>(accruals.size());
        displacement = 0.02;
        for (Size i=0; i<todaysForwards.size(); ++i)
            todaysForwards[i] = 0.03 + 0.0010*i;
        LMMCurveState curveState_lmm(rateTimes);
        curveState_lmm.setOnForwardRates(todaysForwards);
        // until ConstantMaturitySwap is ready
        spanningForwards = todaysForwards.size();
        todaysCMSwapRates = curveState_lmm.cmSwapRates(spanningForwards);

        // Discounts
        todaysDiscounts = std::vector<DiscountFactor>(rateTimes.size());
        todaysDiscounts[0] = 0.95;
        for (Size i=1; i<rateTimes.size(); ++i)
            todaysDiscounts[i] = todaysDiscounts[i-1] /
                (1.0+todaysForwards[i-1]*accruals[i-1]);

        // Swaption Volatilities
        Volatility mktVols[] = {0.15541283,
                                0.18719678,
                                0.20890740,
                                0.22318179,
                                0.23212717,
                                0.23731450,
                                0.23988649,
                                0.24066384,
                                0.24023111,
                                0.23900189,
                                0.23726699,
                                0.23522952,
                                0.23303022,
                                0.23076564,
                                0.22850101,
                                0.22627951,
                                0.22412881,
                                0.22206569,
                                0.22009939
        };
        a = -0.0597;
        b =  0.1677;
        c =  0.5403;
        d =  0.1710;
        volatilities = std::vector<Volatility>(todaysCMSwapRates.size());
        blackVols = std::vector<Volatility>(todaysCMSwapRates.size());
        for (Size i=0; i<todaysCMSwapRates.size(); i++) {
            volatilities[i] = todaysCMSwapRates[i]*mktVols[i]/
                (todaysCMSwapRates[i]+displacement);
            blackVols[i]= mktVols[i];
        }

        // Cap/Floor Correlation
        longTermCorrelation = 0.5;
        beta = 0.2;
        measureOffset_ = 5;

        // Monte Carlo
        seed_ = 42;

        #ifdef _DEBUG
        paths_ = 127;
        trainingPaths_ = 31;
        #else
        paths_ = 32767; //262144-1; //; // 2^15-1
        trainingPaths_ = 8191; // 2^13-1
        #endif
    }

    ext::shared_ptr<SequenceStatisticsInc>
    simulate(const ext::shared_ptr<MarketModelEvolver>& evolver,
             const MarketModelMultiProduct& product) {
        Size initialNumeraire = evolver->numeraires().front();
        Real initialNumeraireValue = todaysDiscounts[initialNumeraire];

        AccountingEngine engine(evolver, product, initialNumeraireValue);
        ext::shared_ptr<SequenceStatisticsInc> stats(
                          new SequenceStatisticsInc(product.numberOfProducts()));
        engine.multiplePathValues(*stats, paths_);
        return stats;
    }


    enum MarketModelType { ExponentialCorrelationFlatVolatility,
                           ExponentialCorrelationAbcdVolatility/*,
                           CalibratedMM*/
    };

    std::string marketModelTypeToString(MarketModelType type) {
        switch (type) {
          case ExponentialCorrelationFlatVolatility:
            return "Exp. Corr. Flat Vol.";
          case ExponentialCorrelationAbcdVolatility:
            return "Exp. Corr. Abcd Vol.";
            //case CalibratedMM:
            //    return "CalibratedMarketModel";
          default:
            QL_FAIL("unknown MarketModelEvolver type");
        }
    }

    ext::shared_ptr<MarketModel> makeMarketModel(
                                        const EvolutionDescription& evolution,
                                        Size numberOfFactors,
                                        MarketModelType marketModelType,
                                        Spread rateBump = 0.0,
                                        Volatility volBump = 0.0) {

        std::vector<Time> fixingTimes(evolution.rateTimes());
        fixingTimes.pop_back();
        ext::shared_ptr<LmVolatilityModel> volModel(new
            LmExtLinearExponentialVolModel(fixingTimes, 0.5, 0.6, 0.1, 0.1));
        ext::shared_ptr<LmCorrelationModel> corrModel(new
            LmLinearExponentialCorrelationModel(evolution.numberOfRates(),
                                                longTermCorrelation, beta));
        std::vector<Rate> bumpedRates(todaysCMSwapRates.size());
        LMMCurveState curveState_lmm(rateTimes);
        curveState_lmm.setOnForwardRates(todaysForwards);
        std::vector<Rate> usedRates =
            curveState_lmm.cmSwapRates(spanningForwards);
        std::transform(usedRates.begin(), usedRates.end(),
                       bumpedRates.begin(),
                       add<Rate>(rateBump));

        std::vector<Volatility> bumpedVols(volatilities.size());
        std::transform(volatilities.begin(), volatilities.end(),
                       bumpedVols.begin(),
                       add<Volatility>(volBump));
        Matrix correlations = exponentialCorrelations(evolution.rateTimes(),
                                                      longTermCorrelation,
                                                      beta);
        ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
            TimeHomogeneousForwardCorrelation(correlations,
                                              evolution.rateTimes()));
        switch (marketModelType) {
          case ExponentialCorrelationFlatVolatility:
            return ext::shared_ptr<MarketModel>(new
                FlatVol(bumpedVols,
                               corr,
                               evolution,
                               numberOfFactors,
                               bumpedRates,
                               std::vector<Spread>(bumpedRates.size(),
                                                   displacement)));
          case ExponentialCorrelationAbcdVolatility:
            return ext::shared_ptr<MarketModel>(new
                AbcdVol(0.0,0.0,1.0,1.0,
                               bumpedVols,
                               corr,
                               evolution,
                               numberOfFactors,
                               bumpedRates,
                               std::vector<Spread>(bumpedRates.size(),
                                                   displacement)));
          //case CalibratedMM:
          //    return ext::shared_ptr<MarketModel>(new
          //        CalibratedMarketModel(volModel, corrModel,
          //                              evolution,
          //                              numberOfFactors,
          //                              bumpedForwards,
          //                              displacement));
          default:
            QL_FAIL("unknown MarketModel type");
        }
    }

    enum MeasureType { ProductSuggested, Terminal,
                       MoneyMarket, MoneyMarketPlus };

    std::string measureTypeToString(MeasureType type) {
        switch (type) {
          case ProductSuggested:
            return "ProductSuggested measure";
          case Terminal:
            return "Terminal measure";
          case MoneyMarket:
            return "Money Market measure";
          case MoneyMarketPlus:
            return "Money Market Plus measure";
          default:
            QL_FAIL("unknown measure type");
        }
    }

    std::vector<Size> makeMeasure(const MarketModelMultiProduct& product,
                                  MeasureType measureType) {
        std::vector<Size> result;
        const EvolutionDescription& evolution(product.evolution());
        switch (measureType) {
          case ProductSuggested:
            result = product.suggestedNumeraires();
            break;
          case Terminal:
            result = terminalMeasure(evolution);
            if (!isInTerminalMeasure(evolution, result)) {
                BOOST_ERROR("failure in verifying Terminal measure:\n"
                            << to_stream(result));
            }
            break;
          case MoneyMarket:
            result = moneyMarketMeasure(evolution);
            if (!isInMoneyMarketMeasure(evolution, result)) {
                BOOST_ERROR("failure in verifying MoneyMarket measure:\n"
                            << to_stream(result));
            }
            break;
          case MoneyMarketPlus:
            result = moneyMarketPlusMeasure(evolution, measureOffset_);
            if (!isInMoneyMarketPlusMeasure(evolution, result,
                                            measureOffset_)) {
                BOOST_ERROR("failure in verifying MoneyMarketPlus(" <<
                            measureOffset_ << ") measure:\n" <<
                            to_stream(result));
            }
            break;
          default:
            QL_FAIL("unknown measure type");
        }
        checkCompatibility(evolution, result);
        if (printReport_) {
            BOOST_TEST_MESSAGE("    " << measureTypeToString(measureType) << ": "
                               << to_stream(result));
        }
        return result;
    }

    enum EvolverType { Ipc, Pc, NormalPc};

    std::string evolverTypeToString(EvolverType type) {
        switch (type) {
          case Ipc:
            return "iterative predictor corrector";
          case Pc:
            return "predictor corrector";
          case NormalPc:
            return "predictor corrector for normal case";
          default:
            QL_FAIL("unknown MarketModelEvolver type");
        }
    }

    ext::shared_ptr<MarketModelEvolver> makeMarketModelEvolver(
                            const ext::shared_ptr<MarketModel>& marketModel,
                            const std::vector<Size>& numeraires,
                            const BrownianGeneratorFactory& generatorFactory,
                            EvolverType evolverType,
                            Size initialStep = 0) {
        switch (evolverType) {
          case Pc:
            return ext::shared_ptr<MarketModelEvolver>(new
                LogNormalCmSwapRatePc(spanningForwards,
                                    marketModel, generatorFactory,
                                    numeraires,
                                    initialStep));
          default:
            QL_FAIL("unknown ConstantMaturitySwapMarketModelEvolver type");
        }
    }


    void
    checkCMSAndSwaptions(const SequenceStatisticsInc& stats,
                         const Rate fixedRate,
                         const std::vector<ext::shared_ptr<StrikedTypePayoff> >& displacedPayoff,
                         const ext::shared_ptr<MarketModel>&, // marketModel,
                         const std::string& config) {
        std::vector<Real> results = stats.mean();
        std::vector<Real> errors = stats.errorEstimate();
        std::vector<Real> discrepancies(todaysForwards.size());

        Size N = todaysForwards.size();
        // check Swaps
        Real maxError = QL_MIN_REAL;
        LMMCurveState curveState_lmm(rateTimes);
        curveState_lmm.setOnForwardRates(todaysForwards);

        std::vector<Real> expectedNPVs(todaysCMSwapRates.size());
        Real errorThreshold = 0.5;
        for (Size i=0; i<N; ++i) {
            Real expectedNPV = curveState_lmm.cmSwapAnnuity(i, i, spanningForwards)
                * (todaysCMSwapRates[i]-fixedRate) * todaysDiscounts[i];
            expectedNPVs[i] = expectedNPV;
            discrepancies[i] = (results[i]-expectedNPVs[i])/errors[i];
            maxError = std::max(std::fabs(discrepancies[i]), maxError);
        }

        if (maxError > errorThreshold) {
            BOOST_TEST_MESSAGE(config);
            for (Size i=0; i<N; ++i) {
                BOOST_TEST_MESSAGE(io::ordinal(i+1) << " CMS NPV: "
                                   << io::rate(results[i])
                                   << " +- " << io::rate(errors[i])
                                   << "; expected: " << io::rate(expectedNPVs[i])
                                   << "; discrepancy/error = "
                                   << discrepancies[N-1-i]
                                   << " standard errors");
            }
            BOOST_ERROR("test failed");
        }

        // check Swaptions
        maxError = 0;

        std::vector<Rate> expectedSwaptions(N);
        for (Size i=0; i<N; ++i) {
            Real expectedSwaption =
                BlackCalculator(displacedPayoff[i],
                                todaysCMSwapRates[i]+displacement,
                                volatilities[i]*std::sqrt(rateTimes[i]),
                                curveState_lmm.cmSwapAnnuity(i,i, spanningForwards)
                                * todaysDiscounts[i]).value();
            expectedSwaptions[i] = expectedSwaption;
            discrepancies[i] = (results[N+i]-expectedSwaptions[i])/errors[N+i];
            maxError = std::max(std::fabs(discrepancies[i]), maxError);
        }
        errorThreshold = 2.0;

        if (maxError > errorThreshold) {
            BOOST_TEST_MESSAGE(config);
            for (Size i=1; i<=N; ++i) {
                BOOST_TEST_MESSAGE(io::ordinal(i) << " Swaption: "
                                   << io::rate(results[2*N-i])
                                   << " +- " << io::rate(errors[2*N-i])
                                   << "; expected: " << io::rate(expectedSwaptions[N-i])
                                   << "; discrepancy/error = "
                                   << io::percent(discrepancies[N-i])
                                   << " standard errors");
            }
            BOOST_ERROR("test failed");
        }
    }

}


void MarketModelCmsTest::testMultiStepCmSwapsAndSwaptions() {

    BOOST_TEST_MESSAGE("Testing exact repricing of "
                       "multi-step constant maturity swaps and swaptions "
                       "in a lognormal constant maturity swap market model...");

    using namespace market_model_cms_test;

    setup();

    Real fixedRate = 0.04;

    // swaps
    std::vector<Time> swapPaymentTimes(rateTimes.begin()+1, rateTimes.end());
    // until ConstantMaturitySwap is ready
    MultiStepCoterminalSwaps swaps(rateTimes, accruals, accruals,
                                   swapPaymentTimes,
                                   fixedRate);
    // swaptions
    std::vector<Time> swaptionPaymentTimes(rateTimes.begin(), rateTimes.end()-1);
    std::vector<ext::shared_ptr<StrikedTypePayoff> >
        displacedPayoff(todaysForwards.size()), undisplacedPayoff(todaysForwards.size());
    for (Size i=0; i<undisplacedPayoff.size(); ++i) {
        displacedPayoff[i] = ext::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(Option::Call, fixedRate+displacement));

        undisplacedPayoff[i] = ext::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(Option::Call, fixedRate));
    }

    // until ConstantMaturitySwap is ready
    MultiStepCoterminalSwaptions swaptions(rateTimes,
                                           swaptionPaymentTimes,
                                           undisplacedPayoff);
    MultiProductComposite product;
    product.add(swaps);
    product.add(swaptions);
    product.finalize();

    EvolutionDescription evolution = product.evolution();

    MarketModelType marketModels[] = {// CalibratedMM,
                                    ExponentialCorrelationFlatVolatility,
                                    ExponentialCorrelationAbcdVolatility };

    for (auto& j : marketModels) {

        Size testedFactors[] = { /*4, 8,*/ todaysForwards.size()};
        for (unsigned long factors : testedFactors) {
            // Composite's ProductSuggested is the Terminal one
            MeasureType measures[] = { // ProductSuggested,
                                       Terminal,
                                      // MoneyMarketPlus,
                                       MoneyMarket};
            for (auto& measure : measures) {
                std::vector<Size> numeraires = makeMeasure(product, measure);

                ext::shared_ptr<MarketModel> marketModel = makeMarketModel(evolution, factors, j);

                EvolverType evolvers[] = { Pc/*, Ipc*/ };

                ext::shared_ptr<MarketModelEvolver> evolver;
                Size stop = isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
                for (Size i=0; i<LENGTH(evolvers)-stop; i++) {
                    for (Size n=0; n<1; n++) {
                        //MTBrownianGeneratorFactory generatorFactory(seed_);
                        SobolBrownianGeneratorFactory generatorFactory(
                                     SobolBrownianGenerator::Diagonal, seed_);
                        evolver = makeMarketModelEvolver(marketModel,
                                                         numeraires,
                                                         generatorFactory,
                                                         evolvers[i]);
                        std::ostringstream config;
                        config << marketModelTypeToString(j) << ", " << factors
                               << (factors > 1 ?
                                       (factors == todaysForwards.size() ? " (full) factors, " :
                                                                           " factors, ") :
                                       " factor,")
                               << measureTypeToString(measure) << ", "
                               << evolverTypeToString(evolvers[i]) << ", "
                               << "MT BGF";
                        if (printReport_)
                            BOOST_TEST_MESSAGE("    " << config.str());

                        ext::shared_ptr<SequenceStatisticsInc> stats = simulate(evolver, product);
                        checkCMSAndSwaptions(*stats, fixedRate,
                                             displacedPayoff, marketModel,config.str());

                    }
                }
            }
        }
    }
}



// --- Call the desired tests
test_suite* MarketModelCmsTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("CMS Market-model tests");

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
                      &MarketModelCmsTest::testMultiStepCmSwapsAndSwaptions));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="178">
    <source>marketmodel_cms.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_market_cms_model_hpp
#define quantlib_test_market_cms_model_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarketModelCmsTest {
  public:
    static void testMultiStepCmSwapsAndSwaptions();
   
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="179">
    <source>marketmodel_smm.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "marketmodel_smm.hpp"
#include "utilities.hpp"
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswap.hpp>
#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/models/marketmodels/evolvers/lognormalcotswapratepc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/browniangenerators/mtbrowniangenerator.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/methods/montecarlo/genericlsregression.hpp>
#include <ql/legacy/libormarketmodels/lmlinexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmextlinexpvolmodel.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/statistics/convergencestatistics.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <sstream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace market_model_smm_test {

    Date todaysDate, startDate, endDate;
    std::vector<Time> rateTimes;
    std::vector<Real> accruals;
    Calendar calendar;
    DayCounter dayCounter;
    std::vector<Rate> todaysForwards, todaysSwaps;
    std::vector<Real> coterminalAnnuity;
    Spread displacement;
    std::vector<DiscountFactor> todaysDiscounts;
    std::vector<Volatility> volatilities, blackVols;
    Real a, b, c, d;
    Real longTermCorrelation, beta;
    Size measureOffset_;
    unsigned long seed_;
    Size paths_, trainingPaths_;
    bool printReport_ = false;

    void setup() {

        // Times
        calendar = NullCalendar();
        todaysDate = Settings::instance().evaluationDate();
        //startDate = todaysDate + 5*Years;
        endDate = todaysDate + 10*Years;
        Schedule dates(todaysDate, endDate, Period(Semiannual),
                       calendar, Following, Following, DateGeneration::Backward, false);
        rateTimes = std::vector<Time>(dates.size()-1);
        accruals = std::vector<Real>(rateTimes.size()-1);
        dayCounter = SimpleDayCounter();
        for (Size i=1; i<dates.size(); ++i)
            rateTimes[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);
        for (Size i=1; i<rateTimes.size(); ++i)
            accruals[i-1] = rateTimes[i] - rateTimes[i-1];

        // Rates & displacement
        todaysForwards = std::vector<Rate>(accruals.size());
        displacement = 0.02;
        for (Size i=0; i<todaysForwards.size(); ++i) {
            todaysForwards[i] = 0.03 + 0.0010*i;
            //todaysForwards[i] = 0.04;
        }
        LMMCurveState curveState_lmm(rateTimes);
        curveState_lmm.setOnForwardRates(todaysForwards);
        todaysSwaps = curveState_lmm.coterminalSwapRates();

        // Discounts
        todaysDiscounts = std::vector<DiscountFactor>(rateTimes.size());
        todaysDiscounts[0] = 0.95;
        for (Size i=1; i<rateTimes.size(); ++i)
            todaysDiscounts[i] = todaysDiscounts[i-1] /
                (1.0+todaysForwards[i-1]*accruals[i-1]);

        // Swaption Volatilities
        Volatility mktVols[] = {0.15541283,
                                0.18719678,
                                0.20890740,
                                0.22318179,
                                0.23212717,
                                0.23731450,
                                0.23988649,
                                0.24066384,
                                0.24023111,
                                0.23900189,
                                0.23726699,
                                0.23522952,
                                0.23303022,
                                0.23076564,
                                0.22850101,
                                0.22627951,
                                0.22412881,
                                0.22206569,
                                0.22009939
        };
        a = -0.0597;
        b =  0.1677;
        c =  0.5403;
        d =  0.1710;
        volatilities = std::vector<Volatility>(todaysSwaps.size());
        blackVols = std::vector<Volatility>(todaysSwaps.size());
        for (Size i=0; i<todaysSwaps.size(); i++) {
            volatilities[i] = todaysSwaps[i]*mktVols[i]/
                (todaysSwaps[i]+displacement);
            blackVols[i]= mktVols[i];
        }

        // Cap/Floor Correlation
        longTermCorrelation = 0.5;
        beta = 0.2;
        measureOffset_ = 5;

        // Monte Carlo
        seed_ = 42;

#ifdef _DEBUG
        paths_ = 127;
        trainingPaths_ = 31;
#else
        paths_ = 32767; //262144-1; //; // 2^15-1
        trainingPaths_ = 8191; // 2^13-1
#endif
    }

    ext::shared_ptr<SequenceStatisticsInc>
    simulate(const ext::shared_ptr<MarketModelEvolver>& evolver,
             const MarketModelMultiProduct& product) {
        Size initialNumeraire = evolver->numeraires().front();
        Real initialNumeraireValue = todaysDiscounts[initialNumeraire];

        AccountingEngine engine(evolver, product, initialNumeraireValue);
        ext::shared_ptr<SequenceStatisticsInc> stats(
                          new SequenceStatisticsInc(product.numberOfProducts()));
        engine.multiplePathValues(*stats, paths_);
        return stats;
    }


    enum MarketModelType { ExponentialCorrelationFlatVolatility,
                           ExponentialCorrelationAbcdVolatility/*,
                           CalibratedMM*/
    };

    std::string marketModelTypeToString(MarketModelType type) {
        switch (type) {
          case ExponentialCorrelationFlatVolatility:
            return "Exp. Corr. Flat Vol.";
          case ExponentialCorrelationAbcdVolatility:
            return "Exp. Corr. Abcd Vol.";
            //case CalibratedMM:
            //    return "CalibratedMarketModel";
          default:
            QL_FAIL("unknown MarketModelEvolver type");
        }
    }


    ext::shared_ptr<MarketModel> makeMarketModel(
                                        const EvolutionDescription& evolution,
                                        Size numberOfFactors,
                                        MarketModelType marketModelType,
                                        Spread rateBump = 0.0,
                                        Volatility volBump = 0.0) {

        std::vector<Time> fixingTimes(evolution.rateTimes());
        fixingTimes.pop_back();
        ext::shared_ptr<LmVolatilityModel> volModel(new
            LmExtLinearExponentialVolModel(fixingTimes, 0.5, 0.6, 0.1, 0.1));
        ext::shared_ptr<LmCorrelationModel> corrModel(new
            LmLinearExponentialCorrelationModel(evolution.numberOfRates(),
                                                longTermCorrelation, beta));
        std::vector<Rate> bumpedRates(todaysForwards.size());
        LMMCurveState curveState_lmm(rateTimes);
        curveState_lmm.setOnForwardRates(todaysForwards);
        std::vector<Rate> usedRates = curveState_lmm.coterminalSwapRates();
        std::transform(usedRates.begin(), usedRates.end(),
                       bumpedRates.begin(),
                       add<Rate>(rateBump));

        std::vector<Volatility> bumpedVols(volatilities.size());
        std::transform(volatilities.begin(), volatilities.end(),
                       bumpedVols.begin(),
                       add<Volatility>(volBump));
        Matrix correlations = exponentialCorrelations(evolution.rateTimes(),
                                                      longTermCorrelation,
                                                      beta);
        ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
            TimeHomogeneousForwardCorrelation(correlations,
                                              evolution.rateTimes()));
        switch (marketModelType) {
          case ExponentialCorrelationFlatVolatility:
            return ext::shared_ptr<MarketModel>(new
                FlatVol(bumpedVols,
                               corr,
                               evolution,
                               numberOfFactors,
                               bumpedRates,
                               std::vector<Spread>(bumpedRates.size(), displacement)));
          case ExponentialCorrelationAbcdVolatility:
            return ext::shared_ptr<MarketModel>(new
                AbcdVol(0.0,0.0,1.0,1.0,
                               bumpedVols,
                               corr,
                               evolution,
                               numberOfFactors,
                               bumpedRates,
                               std::vector<Spread>(bumpedRates.size(), displacement)));
            //case CalibratedMM:
            //    return ext::shared_ptr<MarketModel>(new
            //        CalibratedMarketModel(volModel, corrModel,
            //                              evolution,
            //                              numberOfFactors,
            //                              bumpedForwards,
            //                              displacement));
          default:
            QL_FAIL("unknown MarketModel type");
        }
    }

    enum MeasureType { ProductSuggested, Terminal,
                       MoneyMarket, MoneyMarketPlus };

    std::string measureTypeToString(MeasureType type) {
        switch (type) {
          case ProductSuggested:
            return "ProductSuggested measure";
          case Terminal:
            return "Terminal measure";
          case MoneyMarket:
            return "Money Market measure";
          case MoneyMarketPlus:
            return "Money Market Plus measure";
          default:
            QL_FAIL("unknown measure type");
        }
    }

    std::vector<Size> makeMeasure(const MarketModelMultiProduct& product,
                                  MeasureType measureType) {
        std::vector<Size> result;
        const EvolutionDescription& evolution(product.evolution());
        switch (measureType) {
          case ProductSuggested:
            result = product.suggestedNumeraires();
            break;
          case Terminal:
            result = terminalMeasure(evolution);
            if (!isInTerminalMeasure(evolution, result)) {
                BOOST_ERROR("\nfailure in verifying Terminal measure:\n"
                            << to_stream(result));
            }
            break;
          case MoneyMarket:
            result = moneyMarketMeasure(evolution);
            if (!isInMoneyMarketMeasure(evolution, result)) {
                BOOST_ERROR("\nfailure in verifying MoneyMarket measure:\n"
                            << to_stream(result));
            }
            break;
          case MoneyMarketPlus:
            result = moneyMarketPlusMeasure(evolution, measureOffset_);
            if (!isInMoneyMarketPlusMeasure(evolution, result, measureOffset_)) {
                BOOST_ERROR("\nfailure in verifying MoneyMarketPlus(" <<
                            measureOffset_ << ") measure:\n" <<
                            to_stream(result));
            }
            break;
          default:
            QL_FAIL("unknown measure type");
        }
        checkCompatibility(evolution, result);
        if (printReport_) {
            BOOST_TEST_MESSAGE("    " << measureTypeToString(measureType) << ": " << to_stream(result));
        }
        return result;
    }

    enum EvolverType { Ipc, Pc , NormalPc};

    std::string evolverTypeToString(EvolverType type) {
        switch (type) {
          case Ipc:
            return "iterative predictor corrector";
          case Pc:
            return "predictor corrector";
          case NormalPc:
            return "predictor corrector for normal case";
          default:
            QL_FAIL("unknown MarketModelEvolver type");
        }
    }

    ext::shared_ptr<MarketModelEvolver> makeMarketModelEvolver(
                            const ext::shared_ptr<MarketModel>& marketModel,
                            const std::vector<Size>& numeraires,
                            const BrownianGeneratorFactory& generatorFactory,
                            EvolverType evolverType,
                            Size initialStep = 0) {
        switch (evolverType) {
          case Pc:
            return ext::shared_ptr<MarketModelEvolver>(new
                LogNormalCotSwapRatePc(marketModel, generatorFactory,
                                            numeraires,
                                            initialStep));
          default:
            QL_FAIL("unknown CoterminalSwapMarketModelEvolver type");
        }
    }

    void checkCoterminalSwapsAndSwaptions(
        const SequenceStatisticsInc& stats,
        const Rate fixedRate,
        const std::vector<ext::shared_ptr<StrikedTypePayoff> >& displacedPayoff,
        const ext::shared_ptr<MarketModel>&, // marketModel,
        const std::string& config) {

        std::vector<Real> results = stats.mean();
        std::vector<Real> errors = stats.errorEstimate();
        std::vector<Real> discrepancies(todaysForwards.size());

        Size N = todaysForwards.size();

        // check Swaps
        Real maxError = QL_MIN_REAL;
        LMMCurveState curveState_lmm(rateTimes);
        curveState_lmm.setOnForwardRates(todaysForwards);

        std::vector<Real> expectedNPVs(todaysSwaps.size());
        Real errorThreshold = 0.5;
        for (Size i=0; i<N; ++i) {
            Real expectedNPV = curveState_lmm.coterminalSwapAnnuity(i, i)
                * (todaysSwaps[i]-fixedRate) * todaysDiscounts[i];
            expectedNPVs[i] = expectedNPV;
            discrepancies[i] = (results[i]-expectedNPVs[i])/errors[i];
            maxError = std::max(std::fabs(discrepancies[i]), maxError);
        }
        if (maxError > errorThreshold) {
            BOOST_TEST_MESSAGE(config);
            for (Size i=0; i<N; ++i) {
                BOOST_TEST_MESSAGE(
                              io::ordinal(i+1) << " coterminal swap NPV: "
                              << io::rate(results[i])
                              << " +- " << io::rate(errors[i])
                              << "; expected: " << io::rate(expectedNPVs[i])
                              << "; discrepancy/error = "
                              << discrepancies[N-1-i]
                              << " standard errors");
            }
            BOOST_ERROR("test failed");
        }

        // check Swaptions
        maxError = 0;
        std::vector<Rate> expectedSwaptions(N);
        for (Size i=0; i<N; ++i) {
            Real expectedSwaption =
                BlackCalculator(displacedPayoff[i],
                                todaysSwaps[i]+displacement,
                                volatilities[i]*std::sqrt(rateTimes[i]),
                                curveState_lmm.coterminalSwapAnnuity(i,i) *
                                todaysDiscounts[i]).value();
            expectedSwaptions[i] = expectedSwaption;
            discrepancies[i] = (results[N+i]-expectedSwaptions[i])/errors[N+i];
            maxError = std::max(std::fabs(discrepancies[i]), maxError);
        }
        errorThreshold = 2.0;

        if (maxError > errorThreshold) {
            BOOST_TEST_MESSAGE(config);
            for (Size i=1; i<=N; ++i) {
                BOOST_TEST_MESSAGE(
                              io::ordinal(i) << " Swaption: "
                              << io::rate(results[2*N-i])
                              << " +- " << io::rate(errors[2*N-i])
                              << "; expected: " << io::rate(expectedSwaptions[N-i])
                              << "; discrepancy/error = "
                              << io::percent(discrepancies[N-i])
                              << " standard errors");
            }
            BOOST_ERROR("test failed");
        }
    }

}


void MarketModelSmmTest::testMultiStepCoterminalSwapsAndSwaptions() {

    BOOST_TEST_MESSAGE("Testing exact repricing of "
                       "multi-step coterminal swaps and swaptions "
                       "in a lognormal coterminal swap rate market model...");

    using namespace market_model_smm_test;

    setup();

    Real fixedRate = 0.04;

    // swaps
    std::vector<Time> swapPaymentTimes(rateTimes.begin()+1, rateTimes.end());
    MultiStepCoterminalSwaps swaps(rateTimes, accruals, accruals,
                                   swapPaymentTimes,
                                   fixedRate);
    // swaptions
    std::vector<Time> swaptionPaymentTimes(rateTimes.begin(), rateTimes.end()-1);
    std::vector<ext::shared_ptr<StrikedTypePayoff> >
        displacedPayoff(todaysForwards.size()), undisplacedPayoff(todaysForwards.size());
    for (Size i=0; i<undisplacedPayoff.size(); ++i) {
        displacedPayoff[i] = ext::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(Option::Call, fixedRate+displacement));

        undisplacedPayoff[i] = ext::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(Option::Call, fixedRate));
    }

    MultiStepCoterminalSwaptions swaptions(rateTimes,
                                           swaptionPaymentTimes,
                                           undisplacedPayoff);
    MultiProductComposite product;
    product.add(swaps);
    product.add(swaptions);
    product.finalize();
    EvolutionDescription evolution = product.evolution();
    MarketModelType marketModels[] = {// CalibratedMM,
                                       ExponentialCorrelationFlatVolatility,
                                       ExponentialCorrelationAbcdVolatility };
    for (auto& j : marketModels) {
        Size testedFactors[] = { /*4, 8,*/ todaysForwards.size()};
        for (unsigned long factors : testedFactors) {
            // Composite's ProductSuggested is the Terminal one
            MeasureType measures[] = { // ProductSuggested,
                                       Terminal,
                                       //MoneyMarketPlus,
                                       MoneyMarket};
            for (auto& measure : measures) {
                std::vector<Size> numeraires = makeMeasure(product, measure);
                ext::shared_ptr<MarketModel> marketModel = makeMarketModel(evolution, factors, j);
                EvolverType evolvers[] = { Pc /*, Ipc */};
                ext::shared_ptr<MarketModelEvolver> evolver;
                Size stop = isInTerminalMeasure(evolution, numeraires) ? 0 : 1;
                for (Size i=0; i<LENGTH(evolvers)-stop; i++) {
                    for (Size n=0; n<1; n++) {
                        //MTBrownianGeneratorFactory generatorFactory(seed_);
                        SobolBrownianGeneratorFactory generatorFactory(
                                    SobolBrownianGenerator::Diagonal, seed_);
                        evolver = makeMarketModelEvolver(marketModel,
                                                         numeraires,
                                                         generatorFactory,
                                                         evolvers[i]);
                        std::ostringstream config;
                        config << marketModelTypeToString(j) << ", " << factors
                               << (factors > 1 ?
                                       (factors == todaysForwards.size() ? " (full) factors, " :
                                                                           " factors, ") :
                                       " factor,")
                               << measureTypeToString(measure) << ", "
                               << evolverTypeToString(evolvers[i]) << ", "
                               << "MT BGF";
                        if (printReport_)
                            BOOST_TEST_MESSAGE("    " << config.str());
                        ext::shared_ptr<SequenceStatisticsInc> stats = simulate(evolver, product);
                        checkCoterminalSwapsAndSwaptions(*stats, fixedRate,
                                                         displacedPayoff, marketModel,config.str());
                    }
                }
            }
        }
    }
}



// --- Call the desired tests
test_suite* MarketModelSmmTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("SMM Market-model tests");

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
            &MarketModelSmmTest::testMultiStepCoterminalSwapsAndSwaptions));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="180">
    <source>marketmodel_smm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_market_model_smm_hpp
#define quantlib_test_market_model_smm_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarketModelSmmTest {
  public:
 /*   static void testMultiStepForwardsAndOptionlets();
    static void testOneStepForwardsAndOptionlets();
    static void testOneStepNormalForwardsAndOptionlets();
    static void testMultiStepCoterminalSwapsAndSwaptions();
    static void testMultiStepCoinitialSwaps();
    static void testCallableSwapNaif();
    static void testCallableSwapLS();
    static void testCallableSwapAnderson();
    static void testGreeks();
    static void testAbcdVolatilityIntegration();
    static void testAbcdVolatilityCompare();
    static void testAbcdVolatilityFit();
    static void testDriftCalculator();
    static void testIsInSubset();*/
    static void testMultiStepCoterminalSwapsAndSwaptions();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="181">
    <source>marketmodel_smmcapletalphacalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "marketmodel_smmcapletalphacalibration.hpp"
#include "utilities.hpp"
#include <ql/models/marketmodels/models/capletcoterminalalphacalibration.hpp>
#include <ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantabcdvariance.hpp>
#include <ql/models/marketmodels/models/capletcoterminalswaptioncalibration.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswap.hpp>
#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/models/marketmodels/evolvers/lognormalcotswapratepc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/browniangenerators/mtbrowniangenerator.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/methods/montecarlo/genericlsregression.hpp>
#include <ql/legacy/libormarketmodels/lmlinexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmextlinexpvolmodel.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/statistics/convergencestatistics.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <sstream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace market_model_smm_caplet_alpha_calibration_test {

    Date todaysDate_, startDate_, endDate_;
    std::vector<Time> rateTimes_;
    std::vector<Real> accruals_;
    Calendar calendar_;
    DayCounter dayCounter_;
    std::vector<Rate> todaysForwards_, todaysSwaps_;
    std::vector<Real> coterminalAnnuity_;
    Size numberOfFactors_;
    Real alpha_, alphaMax_, alphaMin_;
    Spread displacement_;
    std::vector<DiscountFactor> todaysDiscounts_;
    std::vector<Volatility> swaptionDisplacedVols_, swaptionVols_;
    std::vector<Volatility> capletDisplacedVols_, capletVols_;
    Real a_, b_, c_, d_;
    Real longTermCorrelation_, beta_;
    Size measureOffset_;
    unsigned long seed_;
    Size paths_, trainingPaths_;
    bool printReport_ = false;

    void setup() {

        // Times
        calendar_ = NullCalendar();
        todaysDate_ = Settings::instance().evaluationDate();
        //startDate = todaysDate + 5*Years;
        endDate_ = todaysDate_ + 66*Months;
        Schedule dates(todaysDate_, endDate_, Period(Semiannual),
                       calendar_, Following, Following, DateGeneration::Backward, false);
        rateTimes_ = std::vector<Time>(dates.size()-1);
        accruals_ = std::vector<Real>(rateTimes_.size()-1);
        dayCounter_ = SimpleDayCounter();
        for (Size i=1; i<dates.size(); ++i)
            rateTimes_[i-1] = dayCounter_.yearFraction(todaysDate_, dates[i]);
        for (Size i=1; i<rateTimes_.size(); ++i)
            accruals_[i-1] = rateTimes_[i] - rateTimes_[i-1];

        // Rates & displacement
        todaysForwards_ = std::vector<Rate>(accruals_.size());
        numberOfFactors_ = 3;
        alpha_ = 0.0;
        alphaMax_ = 1.0;
        alphaMin_ = -1.0;
        displacement_ = 0.0;
        for (Size i=0; i<todaysForwards_.size(); ++i) {
            todaysForwards_[i] = 0.03 + 0.0025*i;
            //    todaysForwards_[i] = 0.03;
        }
        LMMCurveState curveState_lmm(rateTimes_);
        curveState_lmm.setOnForwardRates(todaysForwards_);
        todaysSwaps_ = curveState_lmm.coterminalSwapRates();

        // Discounts
        todaysDiscounts_ = std::vector<DiscountFactor>(rateTimes_.size());
        todaysDiscounts_[0] = 0.95;
        for (Size i=1; i<rateTimes_.size(); ++i)
            todaysDiscounts_[i] = todaysDiscounts_[i-1] /
                (1.0+todaysForwards_[i-1]*accruals_[i-1]);

        //// Swaption Volatilities
        //Volatility mktSwaptionVols[] = {
        //                        0.15541283,
        //                        0.18719678,
        //                        0.20890740,
        //                        0.22318179,
        //                        0.23212717,
        //                        0.23731450,
        //                        0.23988649,
        //                        0.24066384,
        //                        0.24023111,
        //                        0.23900189,
        //                        0.23726699,
        //                        0.23522952,
        //                        0.23303022,
        //                        0.23076564,
        //                        0.22850101,
        //                        0.22627951,
        //                        0.22412881,
        //                        0.22206569,
        //                        0.22009939
        //};

        //a = -0.0597;
        //b =  0.1677;
        //c =  0.5403;
        //d =  0.1710;

        a_ = 0.0;
        b_ = 0.17;
        c_ = 1.0;
        d_ = 0.10;

        Volatility mktCapletVols[] = {
            0.1640,
            0.1740,
            0.1840,
            0.1940,
            0.1840,
            0.1740,
            0.1640,
            0.1540,
            0.1440,
            0.1340376439125532
        };

        //swaptionDisplacedVols = std::vector<Volatility>(todaysSwaps.size());
        //swaptionVols = std::vector<Volatility>(todaysSwaps.size());
        //capletDisplacedVols = std::vector<Volatility>(todaysSwaps.size());
        capletVols_.resize(todaysSwaps_.size());
        for (Size i=0; i<todaysSwaps_.size(); i++) {
            //    swaptionDisplacedVols[i] = todaysSwaps[i]*mktSwaptionVols[i]/
            //                              (todaysSwaps[i]+displacement);
            //    swaptionVols[i]= mktSwaptionVols[i];
            //    capletDisplacedVols[i] = todaysForwards[i]*mktCapletVols[i]/
            //                            (todaysForwards[i]+displacement);
            capletVols_[i]= mktCapletVols[i];
        }

        // Cap/Floor Correlation
        longTermCorrelation_ = 0.5;
        beta_ = 0.2;
        measureOffset_ = 5;

        // Monte Carlo
        seed_ = 42;

#ifdef _DEBUG
        paths_ = 127;
        trainingPaths_ = 31;
#else
        paths_ = 32767; //262144-1; //; // 2^15-1
        trainingPaths_ = 8191; // 2^13-1
#endif
    }

    enum MarketModelType { ExponentialCorrelationFlatVolatility,
                           ExponentialCorrelationAbcdVolatility/*,
                           CalibratedMM*/
    };

    enum MeasureType { ProductSuggested, Terminal,
                       MoneyMarket, MoneyMarketPlus };

    enum EvolverType { Ipc, Pc , NormalPc};

}


void MarketModelSmmCapletAlphaCalibrationTest::testFunction() {

    BOOST_TEST_MESSAGE("Testing alpha caplet calibration "
                       "in a lognormal coterminal swap market model...");

    using namespace market_model_smm_caplet_alpha_calibration_test;

    setup();

    Size numberOfRates = todaysForwards_.size();

    EvolutionDescription evolution(rateTimes_);
    // Size numberOfSteps = evolution.numberOfSteps();

    ext::shared_ptr<PiecewiseConstantCorrelation> fwdCorr(new
        ExponentialForwardCorrelation(rateTimes_,
                                      longTermCorrelation_,
                                      beta_));

    ext::shared_ptr<LMMCurveState> cs(new LMMCurveState(rateTimes_));
    cs->setOnForwardRates(todaysForwards_);

    ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
        CotSwapFromFwdCorrelation(fwdCorr, *cs, displacement_));

    std::vector<ext::shared_ptr<PiecewiseConstantVariance> >
                                    swapVariances(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        swapVariances[i] = ext::shared_ptr<PiecewiseConstantVariance>(new
            PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                          i, rateTimes_));
    }

    // create calibrator
    std::vector<Real> alphaInitial(numberOfRates, alpha_);
    std::vector<Real> alphaMax(numberOfRates,  1.0);
    std::vector<Real> alphaMin(numberOfRates, -1.0);
    bool maximizeHomogeneity = false; //?
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet market vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols_));
        BOOST_TEST_MESSAGE("alphaMin:           " << alphaMin_);
        BOOST_TEST_MESSAGE("alphaInitial:       " << alpha_);
        BOOST_TEST_MESSAGE("alphaMax:           " << alphaMax_);
        BOOST_TEST_MESSAGE("maximizeHomogeneity:" << maximizeHomogeneity);
    }
    CTSMMCapletAlphaFormCalibration calibrator(evolution,
                                               corr,
                                               swapVariances,
                                               capletVols_,
                                               cs,
                                               displacement_,
                                               alphaInitial,
                                               alphaMax,
                                               alphaMin,
                                               maximizeHomogeneity);
    // calibrate
    Natural maxIterations = 10;
    Real capletTolerance = 1e-4; // i.e. 1 bp
    Natural innerMaxIterations = 100;
    Real innerTolerance = 1e-8;

    if (printReport_) {
        BOOST_TEST_MESSAGE("numberOfFactors:    " << numberOfFactors_);
        BOOST_TEST_MESSAGE("maxIterations:      " << maxIterations);
        BOOST_TEST_MESSAGE("capletTolerance:    " << io::rate(capletTolerance));
        BOOST_TEST_MESSAGE("innerMaxIterations: " << innerMaxIterations);
        BOOST_TEST_MESSAGE("innerTolerance:     " << io::rate(innerTolerance));
    }

    bool result = calibrator.calibrate(numberOfFactors_,
                                       maxIterations,
                                       capletTolerance,
                                       innerMaxIterations,
                                       innerTolerance);
    if (!result)
        BOOST_ERROR("calibration failed");

    const std::vector<Matrix>& swapPseudoRoots = calibrator.swapPseudoRoots();
    ext::shared_ptr<MarketModel> smm(new
        PseudoRootFacade(swapPseudoRoots,
                         rateTimes_,
                         cs->coterminalSwapRates(),
                         std::vector<Spread>(numberOfRates, displacement_)));
    CotSwapToFwdAdapter flmm(smm);
    Matrix capletTotCovariance = flmm.totalCovariance(numberOfRates-1);

    std::vector<Volatility> capletVols(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
    }
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet smm implied vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols));
        BOOST_TEST_MESSAGE("failures: " << calibrator.failures());
        BOOST_TEST_MESSAGE("deformationSize: " << calibrator.deformationSize());
        BOOST_TEST_MESSAGE("capletRmsError: " << calibrator.capletRmsError());
        BOOST_TEST_MESSAGE("capletMaxError: " << calibrator.capletMaxError());
        BOOST_TEST_MESSAGE("swaptionRmsError: " << calibrator.swaptionRmsError());
        BOOST_TEST_MESSAGE("swaptionMaxError: " << calibrator.swaptionMaxError());
    }

    // check perfect swaption fit
    Real error, swapTolerance = 1e-14;
    Matrix swapTerminalCovariance(numberOfRates, numberOfRates, 0.0);
    for (Size i=0; i<numberOfRates; ++i) {
        Volatility expSwaptionVol = swapVariances[i]->totalVolatility(i);
        swapTerminalCovariance += swapPseudoRoots[i] * transpose(swapPseudoRoots[i]);
        Volatility swaptionVol = std::sqrt(swapTerminalCovariance[i][i]/rateTimes_[i]);
        error = std::fabs(swaptionVol-expSwaptionVol);
        if (error>swapTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " swaption vol:"
                        "\n expected:  " << io::rate(expSwaptionVol) <<
                        "\n realized:  " << io::rate(swaptionVol) <<
                        "\n error:     " << error <<
                        "\n tolerance: " << swapTolerance);
    }

    // check caplet fit
    for (Size i=0; i<numberOfRates; ++i) {
        error = std::fabs(capletVols[i]-capletVols_[i]);
        if (error>capletTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                        "\n expected:         " << io::rate(capletVols_[i]) <<
                        "\n realized:         " << io::rate(capletVols[i]) <<
                        "\n percentage error: " << error/capletVols_[i] <<
                        "\n error:            " << error <<
                        "\n tolerance:        " << capletTolerance);
    }
}


// --- Call the desired tests
test_suite* MarketModelSmmCapletAlphaCalibrationTest::suite() {
    auto* suite = BOOST_TEST_SUITE("SMM Caplet alpha calibration test");

    suite->add(QUANTLIB_TEST_CASE(&MarketModelSmmCapletAlphaCalibrationTest::testFunction));

    return suite;
}
]]></document_content>
  </document>
  <document index="182">
    <source>marketmodel_smmcapletalphacalibration.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_market_model_smm_caplet_alpha_calibration_hpp
#define quantlib_test_market_model_smm_caplet_alpha_calibration_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarketModelSmmCapletAlphaCalibrationTest {
  public:
    static void testFunction();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="183">
    <source>marketmodel_smmcapletcalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "marketmodel_smmcapletcalibration.hpp"
#include "utilities.hpp"
#include <ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantabcdvariance.hpp>
#include <ql/models/marketmodels/models/capletcoterminalswaptioncalibration.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswap.hpp>
#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/models/marketmodels/evolvers/lognormalcotswapratepc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/browniangenerators/mtbrowniangenerator.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/methods/montecarlo/genericlsregression.hpp>
#include <ql/legacy/libormarketmodels/lmlinexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmextlinexpvolmodel.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/statistics/convergencestatistics.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <sstream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace market_model_smm_caplet_calibration_test {

    Date todaysDate_, startDate_, endDate_;
    std::vector<Time> rateTimes_;
    std::vector<Real> accruals_;
    Calendar calendar_;
    DayCounter dayCounter_;
    std::vector<Rate> todaysForwards_, todaysSwaps_;
    std::vector<Real> coterminalAnnuity_;
    Size numberOfFactors_;
    Real alpha_, alphaMax_, alphaMin_;
    Spread displacement_;
    std::vector<DiscountFactor> todaysDiscounts_;
    std::vector<Volatility> swaptionDisplacedVols_, swaptionVols_;
    std::vector<Volatility> capletDisplacedVols_, capletVols_;
    Real a_, b_, c_, d_;
    Real longTermCorrelation_, beta_;
    Size measureOffset_;
    unsigned long seed_;
    Size paths_, trainingPaths_;
    bool printReport_ = false;

    void setup() {

        // Times
        calendar_ = NullCalendar();
        todaysDate_ = Settings::instance().evaluationDate();
        //startDate = todaysDate + 5*Years;
        endDate_ = todaysDate_ + 66*Months;
        Schedule dates(todaysDate_, endDate_, Period(Semiannual),
                       calendar_, Following, Following, DateGeneration::Backward, false);
        rateTimes_ = std::vector<Time>(dates.size()-1);
        accruals_ = std::vector<Real>(rateTimes_.size()-1);
        dayCounter_ = SimpleDayCounter();
        for (Size i=1; i<dates.size(); ++i)
            rateTimes_[i-1] = dayCounter_.yearFraction(todaysDate_, dates[i]);
        for (Size i=1; i<rateTimes_.size(); ++i)
            accruals_[i-1] = rateTimes_[i] - rateTimes_[i-1];

        // Rates & displacement
        todaysForwards_ = std::vector<Rate>(accruals_.size());
        numberOfFactors_ = 3;
        alpha_ = -0.05;
        alphaMax_ = 1.0;
        alphaMin_ = -1.0;
        displacement_ = 0.0;
        for (Size i=0; i<todaysForwards_.size(); ++i) {
            todaysForwards_[i] = 0.03 + 0.0025*i;
            //todaysForwards_[i] = 0.03;
        }
        LMMCurveState curveState_lmm(rateTimes_);
        curveState_lmm.setOnForwardRates(todaysForwards_);
        todaysSwaps_ = curveState_lmm.coterminalSwapRates();

        // Discounts
        todaysDiscounts_ = std::vector<DiscountFactor>(rateTimes_.size());
        todaysDiscounts_[0] = 0.95;
        for (Size i=1; i<rateTimes_.size(); ++i)
            todaysDiscounts_[i] = todaysDiscounts_[i-1] /
                (1.0+todaysForwards_[i-1]*accruals_[i-1]);

        //// Swaption Volatilities
        //Volatility mktSwaptionVols[] = {
        //                        0.15541283,
        //                        0.18719678,
        //                        0.20890740,
        //                        0.22318179,
        //                        0.23212717,
        //                        0.23731450,
        //                        0.23988649,
        //                        0.24066384,
        //                        0.24023111,
        //                        0.23900189,
        //                        0.23726699,
        //                        0.23522952,
        //                        0.23303022,
        //                        0.23076564,
        //                        0.22850101,
        //                        0.22627951,
        //                        0.22412881,
        //                        0.22206569,
        //                        0.22009939
        //};

        //a = -0.0597;
        //b =  0.1677;
        //c =  0.5403;
        //d =  0.1710;

        a_ = 0.0;
        b_ = 0.17;
        c_ = 1.0;
        d_ = 0.10;

        Volatility mktCapletVols[] = {
            0.1640,
            0.1740,
            0.1840,
            0.1940,
            0.1840,
            0.1740,
            0.1640,
            0.1540,
            0.1440,
            0.1340376439125532
        };

        //swaptionDisplacedVols = std::vector<Volatility>(todaysSwaps.size());
        //swaptionVols = std::vector<Volatility>(todaysSwaps.size());
        //capletDisplacedVols = std::vector<Volatility>(todaysSwaps.size());
        capletVols_.resize(todaysSwaps_.size());
        for (Size i=0; i<todaysSwaps_.size(); i++) {
            //    swaptionDisplacedVols[i] = todaysSwaps[i]*mktSwaptionVols[i]/
            //                              (todaysSwaps[i]+displacement);
            //    swaptionVols[i]= mktSwaptionVols[i];
            //    capletDisplacedVols[i] = todaysForwards[i]*mktCapletVols[i]/
            //                            (todaysForwards[i]+displacement);
            capletVols_[i]= mktCapletVols[i];
        }

        // Cap/Floor Correlation
        longTermCorrelation_ = 0.5;
        beta_ = 0.2;
        measureOffset_ = 5;

        // Monte Carlo
        seed_ = 42;

#ifdef _DEBUG
        paths_ = 127;
        trainingPaths_ = 31;
#else
        paths_ = 32767; //262144-1; //; // 2^15-1
        trainingPaths_ = 8191; // 2^13-1
#endif
    }

    enum MarketModelType { ExponentialCorrelationFlatVolatility,
                           ExponentialCorrelationAbcdVolatility/*,
                           CalibratedMM*/
    };

    enum MeasureType { ProductSuggested, Terminal,
                       MoneyMarket, MoneyMarketPlus };

    enum EvolverType { Ipc, Pc , NormalPc };

}



void MarketModelSmmCapletCalibrationTest::testFunction() {

    BOOST_TEST_MESSAGE("Testing GHLS caplet calibration "
                       "in a lognormal coterminal swap market model...");

    using namespace market_model_smm_caplet_calibration_test;

    setup();

    Size numberOfRates = todaysForwards_.size();

    EvolutionDescription evolution(rateTimes_);
    // Size numberOfSteps = evolution.numberOfSteps();

    ext::shared_ptr<PiecewiseConstantCorrelation> fwdCorr(new
        ExponentialForwardCorrelation(rateTimes_,
                                      longTermCorrelation_,
                                      beta_));

    ext::shared_ptr<LMMCurveState> cs(new LMMCurveState(rateTimes_));
    cs->setOnForwardRates(todaysForwards_);

    ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
        CotSwapFromFwdCorrelation(fwdCorr, *cs, displacement_));

    std::vector<ext::shared_ptr<PiecewiseConstantVariance> >
                                    swapVariances(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        swapVariances[i] = ext::shared_ptr<PiecewiseConstantVariance>(new
            PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                          i, rateTimes_));
    }

    // create calibrator
    std::vector<Real> alpha(numberOfRates, alpha_);
    bool lowestRoot = true;
    bool useFullApprox = false;
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet market vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols_));
        BOOST_TEST_MESSAGE("alpha:              " << alpha_);
        BOOST_TEST_MESSAGE("lowestRoot:         " << lowestRoot);
        BOOST_TEST_MESSAGE("useFullApprox:      " << useFullApprox);
    }
    CTSMMCapletOriginalCalibration calibrator(evolution,
                                              corr,
                                              swapVariances,
                                              capletVols_,
                                              cs,
                                              displacement_,
                                              alpha,
                                              lowestRoot,
                                              useFullApprox);
    // calibrate
    Natural maxIterations = 2;
    Real capletTolerance = 0.0001;
    Natural innerMaxIterations = 50;
    Real innerTolerance = 1e-9;
    if (printReport_) {
        BOOST_TEST_MESSAGE("alpha:              " << alpha_);
        BOOST_TEST_MESSAGE("lowestRoot:         " << lowestRoot);
        BOOST_TEST_MESSAGE("useFullApprox:      " << useFullApprox);
    }
    bool result = calibrator.calibrate(numberOfFactors_,
                                       maxIterations,
                                       capletTolerance/10,
                                       innerMaxIterations,
                                       innerTolerance);
    if (!result)
        BOOST_ERROR("calibration failed");

    const std::vector<Matrix>& swapPseudoRoots = calibrator.swapPseudoRoots();
    ext::shared_ptr<MarketModel> smm(new
        PseudoRootFacade(swapPseudoRoots,
                         rateTimes_,
                         cs->coterminalSwapRates(),
                         std::vector<Spread>(numberOfRates, displacement_)));
    CotSwapToFwdAdapter flmm(smm);
    Matrix capletTotCovariance = flmm.totalCovariance(numberOfRates-1);

    std::vector<Volatility> capletVols(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
    }
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet smm implied vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols));
        BOOST_TEST_MESSAGE("failures: " << calibrator.failures());
        BOOST_TEST_MESSAGE("deformationSize: " << calibrator.deformationSize());
        BOOST_TEST_MESSAGE("capletRmsError: " << calibrator.capletRmsError());
        BOOST_TEST_MESSAGE("capletMaxError: " << calibrator.capletMaxError());
        BOOST_TEST_MESSAGE("swaptionRmsError: " << calibrator.swaptionRmsError());
        BOOST_TEST_MESSAGE("swaptionMaxError: " << calibrator.swaptionMaxError());
    }

    // check perfect swaption fit
    Real error, swapTolerance = 1e-14;
    Matrix swapTerminalCovariance(numberOfRates, numberOfRates, 0.0);
    for (Size i=0; i<numberOfRates; ++i) {
        Volatility expSwaptionVol = swapVariances[i]->totalVolatility(i);
        swapTerminalCovariance += swapPseudoRoots[i] * transpose(swapPseudoRoots[i]);
        Volatility swaptionVol = std::sqrt(swapTerminalCovariance[i][i]/rateTimes_[i]);
        error = std::fabs(swaptionVol-expSwaptionVol);
        if (error>swapTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " swaption vol:"
                        "\n expected:  " << io::rate(expSwaptionVol) <<
                        "\n realized:  " << io::rate(swaptionVol) <<
                        "\n error:     " << error <<
                        "\n tolerance: " << swapTolerance);
    }

    // check caplet fit
    for (Size i=0; i<numberOfRates; ++i) {
        error = std::fabs(capletVols[i]-capletVols_[i]);
        if (error>capletTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                        "\n expected:         " << io::rate(capletVols_[i]) <<
                        "\n realized:         " << io::rate(capletVols[i]) <<
                        "\n percentage error: " << error/capletVols_[i] <<
                        "\n error:            " << error <<
                        "\n tolerance:        " << capletTolerance);
    }
}


// --- Call the desired tests
test_suite* MarketModelSmmCapletCalibrationTest::suite() {
    auto* suite = BOOST_TEST_SUITE("SMM Caplet calibration test");

    suite->add(QUANTLIB_TEST_CASE(&MarketModelSmmCapletCalibrationTest::testFunction));

    return suite;
}
]]></document_content>
  </document>
  <document index="184">
    <source>marketmodel_smmcapletcalibration.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_market_model_smm_caplet_calibration_hpp
#define quantlib_test_market_model_smm_caplet_calibration_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarketModelSmmCapletCalibrationTest {
  public:
    static void testFunction();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="185">
    <source>marketmodel_smmcaplethomocalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "marketmodel_smmcaplethomocalibration.hpp"
#include "utilities.hpp"

#include <ql/math/optimization/spherecylinder.hpp>
#include <ql/models/marketmodels/models/fwdtocotswapadapter.hpp>
#include <ql/models/marketmodels/models/fwdperiodadapter.hpp>
#include <ql/models/marketmodels/models/capletcoterminalmaxhomogeneity.hpp>
#include <ql/models/marketmodels/models/alphaformconcrete.hpp>
#include <ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantabcdvariance.hpp>
#include <ql/models/marketmodels/models/capletcoterminalswaptioncalibration.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswap.hpp>
#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/models/marketmodels/evolvers/lognormalcotswapratepc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/browniangenerators/mtbrowniangenerator.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/methods/montecarlo/genericlsregression.hpp>
#include <ql/legacy/libormarketmodels/lmlinexpcorrmodel.hpp>
#include <ql/legacy/libormarketmodels/lmextlinexpvolmodel.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/statistics/convergencestatistics.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <sstream>
#include <ql/models/marketmodels/models/capletcoterminalperiodic.hpp>
#include <ql/models/marketmodels/models/volatilityinterpolationspecifierabcd.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::fabs;
using std::sqrt;

namespace market_model_smm_caplet_homo_calibration_test {

    Date todaysDate_, startDate_, endDate_;
    std::vector<Time> rateTimes_;
    std::vector<Real> accruals_;
    Calendar calendar_;
    DayCounter dayCounter_;
    std::vector<Rate> todaysForwards_, todaysSwaps_;
    std::vector<Real> coterminalAnnuity_;
    Size numberOfFactors_;
    Real alpha_, alphaMax_, alphaMin_;
    Spread displacement_;
    std::vector<DiscountFactor> todaysDiscounts_;
    std::vector<Volatility> swaptionDisplacedVols_, swaptionVols_;
    std::vector<Volatility> capletDisplacedVols_, capletVols_;
    Real a_, b_, c_, d_;
    Real longTermCorrelation_, beta_;
    Size measureOffset_;
    unsigned long seed_;
    Size paths_, trainingPaths_;
    bool printReport_ = false;

    void setup() {

        // Times
        calendar_ = NullCalendar();
        todaysDate_ = Settings::instance().evaluationDate();
        //startDate = todaysDate + 5*Years;
        endDate_ = todaysDate_ + 66*Months;
        Schedule dates(todaysDate_, endDate_, Period(Semiannual),
                       calendar_, Following, Following, DateGeneration::Backward, false);
        rateTimes_ = std::vector<Time>(dates.size()-1);
        accruals_ = std::vector<Real>(rateTimes_.size()-1);
        dayCounter_ = SimpleDayCounter();
        for (Size i=1; i<dates.size(); ++i)
            rateTimes_[i-1] = dayCounter_.yearFraction(todaysDate_, dates[i]);
        for (Size i=1; i<rateTimes_.size(); ++i)
            accruals_[i-1] = rateTimes_[i] - rateTimes_[i-1];

        // Rates & displacement
        todaysForwards_ = std::vector<Rate>(accruals_.size());
        numberOfFactors_ = 3;
        alpha_ = 0.0;
        alphaMax_ = 1.0;
        alphaMin_ = -1.0;
        displacement_ = 0.0;
        for (Size i=0; i<todaysForwards_.size(); ++i) {
            // FLOATING_POINT_EXCEPTION
            todaysForwards_[i] = 0.03 + 0.0025*i;
            //    todaysForwards_[i] = 0.03;
        }
        LMMCurveState curveState_lmm(rateTimes_);
        curveState_lmm.setOnForwardRates(todaysForwards_);
        todaysSwaps_ = curveState_lmm.coterminalSwapRates();

        // Discounts
        todaysDiscounts_ = std::vector<DiscountFactor>(rateTimes_.size());
        todaysDiscounts_[0] = 0.95;
        for (Size i=1; i<rateTimes_.size(); ++i)
            todaysDiscounts_[i] = todaysDiscounts_[i-1] /
                (1.0+todaysForwards_[i-1]*accruals_[i-1]);

        //// Swaption Volatilities
        //Volatility mktSwaptionVols[] = {
        //                        0.15541283,
        //                        0.18719678,
        //                        0.20890740,
        //                        0.22318179,
        //                        0.23212717,
        //                        0.23731450,
        //                        0.23988649,
        //                        0.24066384,
        //                        0.24023111,
        //                        0.23900189,
        //                        0.23726699,
        //                        0.23522952,
        //                        0.23303022,
        //                        0.23076564,
        //                        0.22850101,
        //                        0.22627951,
        //                        0.22412881,
        //                        0.22206569,
        //                        0.22009939
        //};

        //a = -0.0597;
        //b =  0.1677;
        //c =  0.5403;
        //d =  0.1710;

        a_ = 0.0;
        b_ = 0.17;
        c_ = 1.0;
        d_ = 0.10;

        Volatility mktCapletVols[] = {
            0.1640,
            0.1740,
            0.1840,
            0.1940,
            0.1840,
            0.1740,
            0.1640,
            0.1540,
            0.1440,
            0.1340376439125532
        };

        //swaptionDisplacedVols = std::vector<Volatility>(todaysSwaps.size());
        //swaptionVols = std::vector<Volatility>(todaysSwaps.size());
        //capletDisplacedVols = std::vector<Volatility>(todaysSwaps.size());
        capletVols_.resize(todaysSwaps_.size());
        for (Size i=0; i<todaysSwaps_.size(); i++) {
            //    swaptionDisplacedVols[i] = todaysSwaps[i]*mktSwaptionVols[i]/
            //                              (todaysSwaps[i]+displacement);
            //    swaptionVols[i]= mktSwaptionVols[i];
            //    capletDisplacedVols[i] = todaysForwards[i]*mktCapletVols[i]/
            //                            (todaysForwards[i]+displacement);
            capletVols_[i]= mktCapletVols[i];
        }

        // Cap/Floor Correlation
        longTermCorrelation_ = 0.5;
        beta_ = 0.2;
        measureOffset_ = 5;

        // Monte Carlo
        seed_ = 42;

#ifdef _DEBUG
        paths_ = 127;
        trainingPaths_ = 31;
#else
        paths_ = 32767; //262144-1; //; // 2^15-1
        trainingPaths_ = 8191; // 2^13-1
#endif
    }

    enum MarketModelType { ExponentialCorrelationFlatVolatility,
                           ExponentialCorrelationAbcdVolatility/*,
                           CalibratedMM*/
    };

    enum MeasureType { ProductSuggested, Terminal,
                       MoneyMarket, MoneyMarketPlus };

    enum EvolverType { Ipc, Pc , NormalPc };

}



void MarketModelSmmCapletHomoCalibrationTest::testFunction() {

    BOOST_TEST_MESSAGE("Testing max homogeneity caplet calibration "
                       "in a lognormal coterminal swap market model...");

    using namespace market_model_smm_caplet_homo_calibration_test;

    setup();

    Size numberOfRates = todaysForwards_.size();

    EvolutionDescription evolution(rateTimes_);
    // Size numberOfSteps = evolution.numberOfSteps();

    ext::shared_ptr<PiecewiseConstantCorrelation> fwdCorr(new
        ExponentialForwardCorrelation(rateTimes_,
                                      longTermCorrelation_,
                                      beta_));

    ext::shared_ptr<LMMCurveState> cs(new LMMCurveState(rateTimes_));
    cs->setOnForwardRates(todaysForwards_);

    ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
        CotSwapFromFwdCorrelation(fwdCorr, *cs, displacement_));

    std::vector<ext::shared_ptr<PiecewiseConstantVariance> >
                                    swapVariances(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        swapVariances[i] = ext::shared_ptr<PiecewiseConstantVariance>(new
            PiecewiseConstantAbcdVariance(a_, b_, c_, d_,
                                          i, rateTimes_));
    }

    // create calibrator
    Real caplet0Swaption1Priority = 1.0;
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet market vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols_));
        BOOST_TEST_MESSAGE("caplet0Swapt1Prior: " << caplet0Swaption1Priority);
    }
    CTSMMCapletMaxHomogeneityCalibration calibrator(evolution,
                                                    corr,
                                                    swapVariances,
                                                    capletVols_,
                                                    cs,
                                                    displacement_,
                                                    caplet0Swaption1Priority);
    // calibrate
    Natural maxIterations = 10;
    Real capletTolerance = 1e-4; // i.e. 1 bp
    Natural innerMaxIterations = 100;
    Real innerTolerance = 1e-8;
    if (printReport_) {
        BOOST_TEST_MESSAGE("numberOfFactors:    " << numberOfFactors_);
        BOOST_TEST_MESSAGE("maxIterations:      " << maxIterations);
        BOOST_TEST_MESSAGE("capletTolerance:    " << io::rate(capletTolerance));
        BOOST_TEST_MESSAGE("innerMaxIterations: " << innerMaxIterations);
        BOOST_TEST_MESSAGE("innerTolerance:     " << io::rate(innerTolerance));
    }
    bool result = calibrator.calibrate(numberOfFactors_,
                                       maxIterations,
                                       capletTolerance,
                                       innerMaxIterations,
                                       innerTolerance);
    if (!result)
        BOOST_ERROR("calibration failed");

    const std::vector<Matrix>& swapPseudoRoots = calibrator.swapPseudoRoots();
    ext::shared_ptr<MarketModel> smm(new
        PseudoRootFacade(swapPseudoRoots,
                         rateTimes_,
                         cs->coterminalSwapRates(),
                         std::vector<Spread>(numberOfRates, displacement_)));
    ext::shared_ptr<MarketModel> flmm(new CotSwapToFwdAdapter(smm));
    Matrix capletTotCovariance = flmm->totalCovariance(numberOfRates-1);

    std::vector<Volatility> capletVols(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
    }
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet smm implied vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols));
        BOOST_TEST_MESSAGE("failures: " << calibrator.failures());
        BOOST_TEST_MESSAGE("deformationSize: " << calibrator.deformationSize());
        BOOST_TEST_MESSAGE("capletRmsError: " << calibrator.capletRmsError());
        BOOST_TEST_MESSAGE("capletMaxError: " << calibrator.capletMaxError());
        BOOST_TEST_MESSAGE("swaptionRmsError: " << calibrator.swaptionRmsError());
        BOOST_TEST_MESSAGE("swaptionMaxError: " << calibrator.swaptionMaxError());
      }

    // check perfect swaption fit
    Real error, swapTolerance = 1e-14;
    Matrix swapTerminalCovariance(numberOfRates, numberOfRates, 0.0);
    for (Size i=0; i<numberOfRates; ++i) {
        Volatility expSwaptionVol = swapVariances[i]->totalVolatility(i);
        swapTerminalCovariance += swapPseudoRoots[i] * transpose(swapPseudoRoots[i]);
        Volatility swaptionVol = std::sqrt(swapTerminalCovariance[i][i]/rateTimes_[i]);
        error = std::fabs(swaptionVol-expSwaptionVol);
        if (error>swapTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " swaption vol:"
                        "\n expected:  " << io::rate(expSwaptionVol) <<
                        "\n realized:  " << io::rate(swaptionVol) <<
                        "\n error:     " << error <<
                        "\n tolerance: " << swapTolerance);
    }

    // check caplet fit
    for (Size i=0; i<numberOfRates; ++i) {
        error = std::fabs(capletVols[i]-capletVols_[i]);
        if (error>capletTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                        "\n expected:         " << io::rate(capletVols_[i]) <<
                        "\n realized:         " << io::rate(capletVols[i]) <<
                        "\n percentage error: " << error/capletVols_[i] <<
                        "\n error:            " << error <<
                        "\n tolerance:        " << capletTolerance);
    }

    Size period =2;
    Size offset =0;
    std::vector<Spread> adaptedDisplacements;
    ext::shared_ptr<MarketModel> adapted(new FwdPeriodAdapter(flmm,period,offset,adaptedDisplacements));
   // FwdToCotSwapAdapter newSwapMM(adapted);
   // for (Size i=0; i < newSwapMM.numberOfRates(); ++i)
     //      BOOST_TEST_MESSAGE("swap MM time dependent vols: "<< i << std::fixed <<
       //               std::setprecision(6) << Array(newSwapMM.timeDependentVolatility(i)));






}



void MarketModelSmmCapletHomoCalibrationTest::testPeriodFunction()
{

    BOOST_TEST_MESSAGE("Testing max homogeneity periodic caplet calibration "
                       "in a lognormal coterminal swap market model...");

    using namespace market_model_smm_caplet_homo_calibration_test;

    setup();

    Size numberOfRates = todaysForwards_.size();
    Size period=2;
    Size offset = numberOfRates % period;
    Size numberBigRates = numberOfRates / period;

    EvolutionDescription evolution(rateTimes_);

    std::vector<Time> bigRateTimes(numberBigRates+1);

    for (Size i=0; i <= numberBigRates; ++i)
        bigRateTimes[i] = rateTimes_[i*period+offset];

    ext::shared_ptr<PiecewiseConstantCorrelation> fwdCorr(new
        ExponentialForwardCorrelation(rateTimes_,
                                      longTermCorrelation_,
                                      beta_));

    ext::shared_ptr<LMMCurveState> cs(new LMMCurveState(rateTimes_));
    cs->setOnForwardRates(todaysForwards_);

    ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
        CotSwapFromFwdCorrelation(fwdCorr, *cs, displacement_));

    std::vector<PiecewiseConstantAbcdVariance >
                                    swapVariances;
    for (Size i=0; i<numberBigRates; ++i) {
        swapVariances.emplace_back(a_, b_, c_, d_, i, bigRateTimes);
    }

    VolatilityInterpolationSpecifierabcd varianceInterpolator(period, offset, swapVariances, // these should be associated with the long rates
                                                                   rateTimes_ // these should be associated with the shorter rates
                                                                   );


    // create calibrator
    Real caplet0Swaption1Priority = 1.0;
    if (printReport_) {
        BOOST_TEST_MESSAGE("caplet market vols: " << std::fixed <<
                           std::setprecision(4) << io::sequence(capletVols_));
        BOOST_TEST_MESSAGE("caplet0Swapt1Prior: " << caplet0Swaption1Priority);
    }

     // calibrate
    Natural maxUnperiodicIterations = 10;
    Real toleranceUnperiodic = 1e-5; // i.e. 1 bp
    Natural max1dIterations = 100;
    Real tolerance1d = 1e-8;
    Size maxPeriodIterations = 30;
    Real periodTolerance = 1e-5;

     std::vector<Matrix> swapPseudoRoots;
     Real deformationSize;
     Real totalSwaptionError;
     std::vector<Real>  finalScales;  //scalings used for matching
     Size iterationsDone; // number of  period iteratations done
     Real errorImprovement; // improvement in error for last iteration
     Matrix modelSwaptionVolsMatrix;

       if (printReport_) {
        BOOST_TEST_MESSAGE("numberOfFactors:    " << numberOfFactors_);
        BOOST_TEST_MESSAGE("maxUnperiodicIterations:      " << maxUnperiodicIterations);
        BOOST_TEST_MESSAGE("toleranceUnperiodic:    " << io::rate(toleranceUnperiodic));
        BOOST_TEST_MESSAGE("max1dIterations: " << max1dIterations);
        BOOST_TEST_MESSAGE("tolerance1d:     " << io::rate(tolerance1d));

       }

       /*Integer failures =*/ capletSwaptionPeriodicCalibration(
        evolution,
        corr,
        varianceInterpolator,
        capletVols_,
        cs,
        displacement_,
        caplet0Swaption1Priority,
        numberOfFactors_,
        period,
        max1dIterations,
        tolerance1d,
        maxUnperiodicIterations,
        toleranceUnperiodic,
        maxPeriodIterations,
        periodTolerance,
        deformationSize,
        totalSwaptionError, // ?
        swapPseudoRoots,  // the thing we really want the pseudo root for each time step
        finalScales,  //scalings used for matching
        iterationsDone, // number of  period iteratations done
        errorImprovement, // improvement in error for last iteration
        modelSwaptionVolsMatrix // the swaption vols calibrated to at each step of the iteration
        );


    ext::shared_ptr<MarketModel> smm(new
        PseudoRootFacade(swapPseudoRoots,
                         rateTimes_,
                         cs->coterminalSwapRates(),
                         std::vector<Spread>(numberOfRates, displacement_)));
    ext::shared_ptr<MarketModel> flmm(new CotSwapToFwdAdapter(smm));
    Matrix capletTotCovariance = flmm->totalCovariance(numberOfRates-1);




    std::vector<Volatility> capletVols(numberOfRates);
    for (Size i=0; i<numberOfRates; ++i) {
        capletVols[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes_[i]);
    }

    Real error;
    Real capletTolerance = 1e-4; // i.e. 1 bp

    // check caplet fit
    for (Size i=0; i<numberOfRates; ++i) {
        error = std::fabs(capletVols[i]-capletVols_[i]);
        if (error>capletTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i+1) << " caplet vol:"
                        "\n expected:         " << io::rate(capletVols_[i]) <<
                        "\n realized:         " << io::rate(capletVols[i]) <<
                        "\n percentage error: " << error/capletVols_[i] <<
                        "\n error:            " << error <<
                        "\n tolerance:        " << capletTolerance);
    }



    std::vector<Spread> adaptedDisplacements(numberBigRates,displacement_);
    ext::shared_ptr<MarketModel> adaptedFlmm(new FwdPeriodAdapter(flmm,period,offset,adaptedDisplacements));

     ext::shared_ptr<MarketModel> adaptedsmm(new FwdToCotSwapAdapter(adaptedFlmm));

      // check perfect swaption fit
    Real  swapTolerance = 2e-5;

    Matrix swapTerminalCovariance(adaptedsmm->totalCovariance(adaptedsmm->numberOfSteps()-1));

    for (Size i=0; i<numberBigRates; ++i) {
        Volatility expSwaptionVol = swapVariances[i].totalVolatility(i);
        // Real cov = swapTerminalCovariance[i][i];
        Time time = adaptedsmm->evolution().rateTimes()[i];
        Volatility swaptionVol =  sqrt(swapTerminalCovariance[i][i]/time);

        error = std::fabs(swaptionVol-expSwaptionVol);
        if (error>swapTolerance)
            BOOST_ERROR("failed to reproduce " << io::ordinal(i) << " swaption vol:"
                        "\n expected:  " << io::rate(expSwaptionVol) <<
                        "\n realized:  " << io::rate(swaptionVol) <<
                        "\n error:     " << error <<
                        "\n tolerance: " << swapTolerance);
    }






}


void MarketModelSmmCapletHomoCalibrationTest::testSphereCylinder() {

    BOOST_TEST_MESSAGE("Testing sphere-cylinder optimization...");

    {
        Real R =1.0;
        Real S =0.5;
        Real alpha=1.5;
        Real Z1=1.0/sqrt(3.0);
        Real Z2=1.0/sqrt(3.0);
        Real Z3=1.0/sqrt(3.0);

        SphereCylinderOptimizer optimizer(R, S, alpha, Z1, Z2, Z3);
        Size maxIterations=100;
        Real tolerance=1e-8;
        Real y1, y2, y3;

        optimizer.findClosest(maxIterations, tolerance, y1, y2, y3);

        Real errorTol = 1e-12;
        if ( fabs(y1-1.0) > errorTol)
            BOOST_ERROR("\n failed to reproduce y1=1: "
            << y1 << ", " << y2 << ", "  << y3);

        if ( fabs(y2-0.0) > errorTol)
            BOOST_ERROR("\n failed to reproduce y2=0: "
            << y1 << ", " << y2 << ", "  << y3);

        if ( fabs(y3-0.0) > errorTol)
            BOOST_ERROR("\n failed to reproduce y3=0: "
            << y1 << ", " <<y2 << ", "  << y3);


        optimizer.findByProjection(y1, y2, y3);

        if ( fabs(y1-1.0) > errorTol)
            BOOST_ERROR("\nfindByProjection failed to reproduce y1=1: "
            << y1 << ", " << y2 << ", "  << y3);

        if ( fabs(y2-0.0) > errorTol)
            BOOST_ERROR("\n findByProjection failed to reproduce y2=0: "
            << y1 << ", " << y2 << ", "  << y3);

        if ( fabs(y3-0.0) > errorTol)
            BOOST_ERROR("\n findByProjection failed to reproduce y3=0: "
            << y1 << ", " <<y2 << ", "  << y3);
    }

   {
        Real R =5.0;
        Real S =1.0;
        Real alpha=1.0;
        Real Z1=1.0;
        Real Z2=2.0;
        Real Z3=sqrt(20.0);

        SphereCylinderOptimizer optimizer(R, S, alpha, Z1, Z2, Z3);
        Size maxIterations=100;
        Real tolerance=1e-8;
        Real y1,y2,y3;

        optimizer.findClosest(maxIterations, tolerance, y1, y2, y3);

        Real errorTol = 1e-4;
        if ( fabs(y1-1.03306) > errorTol)
            BOOST_ERROR("\n failed to reproduce y1=1.03306: "
            << y1 << ", " << y2 << ", "  << y3);

        if ( fabs(y2-0.999453) > errorTol)
            BOOST_ERROR("\n failed to reproduce y2=0.999453: "
            << y1 << ", " << y2 << ", "  << y3);

        if ( fabs(y3-4.78893) > errorTol)
            BOOST_ERROR("\n failed to reproduce y3=4.78893: "
            << y1 << ", " <<y2 << ", "  << y3);


        optimizer.findByProjection(y1, y2, y3);

        if ( fabs(y1-1.0) > errorTol)
            BOOST_ERROR("\n findByProjection failed to reproduce y1 =1: "
            << y1 << " " << y2 << " "  << y3);

        if ( fabs(y2-1.0) > errorTol)
            BOOST_ERROR("\n findByProjection failed to reproduce y2 =1: "
            << y1 << " " << y2 << " "  << y3);

        if ( fabs(y3-sqrt(23.0)) > errorTol)
            BOOST_ERROR("\n findByProjection failed to reproduce y3 =sqrt(23): "
            << y1 << " " <<y2 << " "  << y3);

    }
}


// --- Call the desired tests
test_suite* MarketModelSmmCapletHomoCalibrationTest::suite() {
    auto* suite = BOOST_TEST_SUITE("SMM Caplet homogeneous calibration test");

    suite->add(QUANTLIB_TEST_CASE(
                     &MarketModelSmmCapletHomoCalibrationTest::testFunction));
    suite->add(QUANTLIB_TEST_CASE(
               &MarketModelSmmCapletHomoCalibrationTest::testPeriodFunction));

    suite->add(QUANTLIB_TEST_CASE(
               &MarketModelSmmCapletHomoCalibrationTest::testSphereCylinder));

    return suite;
}
]]></document_content>
  </document>
  <document index="186">
    <source>marketmodel_smmcaplethomocalibration.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_market_model_smm_caplet_homo_calibration_hpp
#define quantlib_test_market_model_smm_caplet_homo_calibration_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarketModelSmmCapletHomoCalibrationTest {
  public:
    static void testFunction();
    static void testPeriodFunction();
    static void testSphereCylinder();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="187">
    <source>markovfunctional.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_markovfunctional_hpp
#define quantlib_test_markovfunctional_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MarkovFunctionalTest {
  public:
    static void testMfStateProcess();
    static void testKahaleSmileSection();
    static void testCalibrationOneInstrumentSet();
    static void testCalibrationTwoInstrumentSets();
    static void testVanillaEngines();
    static void testBermudanSwaption();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="188">
    <source>matrices.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007, 2008 Klaus Spanderen
 Copyright (C) 2007 Neil Firth
 Copyright (C) 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "matrices.hpp"
#include "utilities.hpp"
#include <ql/experimental/math/moorepenroseinverse.hpp>
#include <ql/math/initializers.hpp>
#include <ql/math/matrix.hpp>
#include <ql/math/matrixutilities/basisincompleteordered.hpp>
#include <ql/math/matrixutilities/bicgstab.hpp>
#include <ql/math/matrixutilities/choleskydecomposition.hpp>
#include <ql/math/matrixutilities/gmres.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/matrixutilities/qrdecomposition.hpp>
#include <ql/math/matrixutilities/svd.hpp>
#include <ql/math/matrixutilities/symmetricschurdecomposition.hpp>
#include <ql/math/matrixutilities/sparsematrix.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <cmath>
#include <utility>
#include <numeric>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::fabs;

namespace matrices_test {

    Size N;
    Matrix M1, M2, M3, M4, M5, M6, M7, I;

    Real norm(const Array& v) {
        return std::sqrt(DotProduct(v,v));
    }

    Real norm(const Matrix& m) {
        Real sum = 0.0;
        for (Size i=0; i<m.rows(); i++)
            for (Size j=0; j<m.columns(); j++)
                sum += m[i][j]*m[i][j];
        return std::sqrt(sum);
    }

    void setup() {

        N = 3;
        M1 = M2 = I = Matrix(N,N);
        M3 = Matrix(3,4);
        M4 = Matrix(4,3);
        M5 = Matrix(4, 4, 0.0);
        M6 = Matrix(4, 4, 0.0);

        M1[0][0] = 1.0;  M1[0][1] = 0.9;  M1[0][2] = 0.7;
        M1[1][0] = 0.9;  M1[1][1] = 1.0;  M1[1][2] = 0.4;
        M1[2][0] = 0.7;  M1[2][1] = 0.4;  M1[2][2] = 1.0;

        M2[0][0] = 1.0;  M2[0][1] = 0.9;  M2[0][2] = 0.7;
        M2[1][0] = 0.9;  M2[1][1] = 1.0;  M2[1][2] = 0.3;
        M2[2][0] = 0.7;  M2[2][1] = 0.3;  M2[2][2] = 1.0;

        I[0][0] = 1.0;  I[0][1] = 0.0;  I[0][2] = 0.0;
        I[1][0] = 0.0;  I[1][1] = 1.0;  I[1][2] = 0.0;
        I[2][0] = 0.0;  I[2][1] = 0.0;  I[2][2] = 1.0;

        M3[0][0] = 1; M3[0][1] = 2; M3[0][2] = 3; M3[0][3] = 4;
        M3[1][0] = 2; M3[1][1] = 0; M3[1][2] = 2; M3[1][3] = 1;
        M3[2][0] = 0; M3[2][1] = 1; M3[2][2] = 0; M3[2][3] = 0;

        M4[0][0] = 1;  M4[0][1] = 2;  M4[0][2] = 400;
        M4[1][0] = 2;  M4[1][1] = 0;  M4[1][2] = 1;
        M4[2][0] = 30; M4[2][1] = 2;  M4[2][2] = 0;
        M4[3][0] = 2;  M4[3][1] = 0;  M4[3][2] = 1.05;

        // from Higham - nearest correlation matrix
        M5[0][0] = 2;   M5[0][1] = -1;  M5[0][2] = 0.0; M5[0][3] = 0.0;
        M5[1][0] = M5[0][1];  M5[1][1] = 2;   M5[1][2] = -1;  M5[1][3] = 0.0;
        M5[2][0] = M5[0][2]; M5[2][1] = M5[1][2];  M5[2][2] = 2;   M5[2][3] = -1;
        M5[3][0] = M5[0][3]; M5[3][1] = M5[1][3]; M5[3][2] = M5[2][3];  M5[3][3] = 2;

        // from Higham - nearest correlation matrix to M5
        M6[0][0] = 1;        M6[0][1] = -0.8084124981;  M6[0][2] = 0.1915875019;   M6[0][3] = 0.106775049;
        M6[1][0] = M6[0][1]; M6[1][1] = 1;        M6[1][2] = -0.6562326948;  M6[1][3] = M6[0][2];
        M6[2][0] = M6[0][2]; M6[2][1] = M6[1][2]; M6[2][2] = 1;        M6[2][3] = M6[0][1];
        M6[3][0] = M6[0][3]; M6[3][1] = M6[1][3]; M6[3][2] = M6[2][3]; M6[3][3] = 1;

        M7 = M1;
        M7[0][1] = 0.3; M7[0][2] = 0.2; M7[2][1] = 1.2;
    }

}


void MatricesTest::testEigenvectors() {

    BOOST_TEST_MESSAGE("Testing eigenvalues and eigenvectors calculation...");

    using namespace matrices_test;

    setup();

    Matrix testMatrices[] = { M1, M2 };

    for (auto& M : testMatrices) {

        SymmetricSchurDecomposition dec(M);
        Array eigenValues = dec.eigenvalues();
        Matrix eigenVectors = dec.eigenvectors();
        Real minHolder = QL_MAX_REAL;

        for (Size i=0; i<N; i++) {
            Array v(N);
            for (Size j=0; j<N; j++)
                v[j] = eigenVectors[j][i];
            // check definition
            Array a = M*v;
            Array b = eigenValues[i]*v;
            if (norm(a-b) > 1.0e-15)
                BOOST_FAIL("Eigenvector definition not satisfied");
            // check decreasing ordering
            if (eigenValues[i] >= minHolder) {
                BOOST_FAIL("Eigenvalues not ordered: " << eigenValues);
            } else
                minHolder = eigenValues[i];
        }

        // check normalization
        Matrix m = eigenVectors * transpose(eigenVectors);
        if (norm(m-I) > 1.0e-15)
            BOOST_FAIL("Eigenvector not normalized");
    }
}

void MatricesTest::testSqrt() {

    BOOST_TEST_MESSAGE("Testing matricial square root...");

    using namespace matrices_test;

    setup();

    Matrix m = pseudoSqrt(M1, SalvagingAlgorithm::None);
    Matrix temp = m*transpose(m);
    Real error = norm(temp - M1);
    Real tolerance = 1.0e-12;
    if (error>tolerance) {
        BOOST_FAIL("Matrix square root calculation failed\n"
                   << "original matrix:\n" << M1
                   << "pseudoSqrt:\n" << m
                   << "pseudoSqrt*pseudoSqrt:\n" << temp
                   << "\nerror:     " << error
                   << "\ntolerance: " << tolerance);
    }
}

void MatricesTest::testHighamSqrt() {
    BOOST_TEST_MESSAGE("Testing Higham matricial square root...");

    using namespace matrices_test;

    setup();

    Matrix tempSqrt = pseudoSqrt(M5, SalvagingAlgorithm::Higham);
    Matrix ansSqrt = pseudoSqrt(M6, SalvagingAlgorithm::None);
    Real error = norm(ansSqrt - tempSqrt);
    Real tolerance = 1.0e-4;
    if (error>tolerance) {
        BOOST_FAIL("Higham matrix correction failed\n"
                   << "original matrix:\n" << M5
                   << "pseudoSqrt:\n" << tempSqrt
                   << "should be:\n" << ansSqrt
                   << "\nerror:     " << error
                   << "\ntolerance: " << tolerance);
    }
}

void MatricesTest::testSVD() {

    BOOST_TEST_MESSAGE("Testing singular value decomposition...");

    using namespace matrices_test;

    setup();

    Real tol = 1.0e-12;
    Matrix testMatrices[] = { M1, M2, M3, M4 };

    for (auto& A : testMatrices) {
        // m >= n required (rows >= columns)
        SVD svd(A);
        // U is m x n
        const Matrix& U = svd.U();
        // s is n long
        Array s = svd.singularValues();
        // S is n x n
        Matrix S = svd.S();
        // V is n x n
        const Matrix& V = svd.V();

        for (Size i=0; i < S.rows(); i++) {
            if (S[i][i] != s[i])
                BOOST_FAIL("S not consistent with s");
        }

        // tests
        Matrix U_Utranspose = transpose(U)*U;
        if (norm(U_Utranspose-I) > tol)
            BOOST_FAIL("U not orthogonal (norm of U^T*U-I = "
                       << norm(U_Utranspose-I) << ")");

        Matrix V_Vtranspose = transpose(V)*V;
        if (norm(V_Vtranspose-I) > tol)
            BOOST_FAIL("V not orthogonal (norm of V^T*V-I = "
                       << norm(V_Vtranspose-I) << ")");

        Matrix A_reconstructed = U * S * transpose(V);
        if (norm(A_reconstructed-A) > tol)
            BOOST_FAIL("Product does not recover A: (norm of U*S*V^T-A = "
                       << norm(A_reconstructed-A) << ")");
    }
}

void MatricesTest::testQRDecomposition() {

    BOOST_TEST_MESSAGE("Testing QR decomposition...");

    using namespace matrices_test;

    setup();

    Real tol = 1.0e-12;
    Matrix testMatrices[] = { M1, M2, I,
                              M3, transpose(M3), M4, transpose(M4), M5 };

    for (const auto& A : testMatrices) {
        Matrix Q, R;
        bool pivot = true;
        const std::vector<Size> ipvt = qrDecomposition(A, Q, R, pivot);

        Matrix P(A.columns(), A.columns(), 0.0);

        // reverse column pivoting
        for (Size i=0; i < P.columns(); ++i) {
            P[ipvt[i]][i] = 1.0;
        }

        if (norm(Q*R - A*P) > tol)
            BOOST_FAIL("Q*R does not match matrix A*P (norm = "
                       << norm(Q*R-A*P) << ")");

        pivot = false;
        qrDecomposition(A, Q, R, pivot);

        if (norm(Q*R - A) > tol)
            BOOST_FAIL("Q*R does not match matrix A (norm = "
                       << norm(Q*R-A) << ")");
    }
}

void MatricesTest::testQRSolve() {

    BOOST_TEST_MESSAGE("Testing QR solve...");

    using namespace matrices_test;

    setup();

    Real tol = 1.0e-12;
    MersenneTwisterUniformRng rng(1234);
    Matrix bigM(50, 100, 0.0);
    for (Size i=0; i < std::min(bigM.rows(), bigM.columns()); ++i) {
        bigM[i][i] = i+1.0;
    }

    Matrix randM(50, 200);
    for (Size i=0; i < randM.rows(); ++i)
        for (Size j=0; j < randM.columns(); ++j)
            randM[i][j] = rng.next().value;

    Matrix testMatrices[] = {M1, M2, M3, transpose(M3),
                              M4, transpose(M4), M5, I, M7,
                              bigM, transpose(bigM),
                              randM, transpose(randM) };

    for (const auto& A : testMatrices) {
        Array b(A.rows());

        for (Size k=0; k < 10; ++k) {
            for (double& iter : b) {
                iter = rng.next().value;
            }
            const Array x = qrSolve(A, b, true);

            if (A.columns() >= A.rows()) {
                if (norm(A*x - b) > tol)
                    BOOST_FAIL("A*x does not match vector b (norm = "
                               << norm(A*x - b) << ")");
            }
            else {
                // use the SVD to calculate the reference values
                const Size n = A.columns();
                Array xr(n, 0.0);

                SVD svd(A);
                const Matrix& V = svd.V();
                const Matrix& U = svd.U();
                const Array&  w = svd.singularValues();
                const Real threshold = n*QL_EPSILON;

                for (Size i=0; i<n; ++i) {
                    if (w[i] > threshold) {
                        const Real u = std::inner_product(U.column_begin(i),
                                                          U.column_end(i),
                                                          b.begin(), 0.0)/w[i];

                        for (Size j=0; j<n; ++j) {
                            xr[j]  +=u*V[j][i];
                        }
                    }
                }

                if (norm(xr-x) > tol) {
                    BOOST_FAIL("least square solution does not match (norm = "
                               << norm(x - xr) << ")");

                }
            }
        }
    }
}

void MatricesTest::testInverse() {

    BOOST_TEST_MESSAGE("Testing LU inverse calculation...");

    using namespace matrices_test;

    setup();

    Real tol = 1.0e-12;
    Matrix testMatrices[] = { M1, M2, I, M5 };

    for (const auto& A : testMatrices) {
        const Matrix invA = inverse(A);

        const Matrix I1 = invA*A;
        const Matrix I2 = A*invA;

        Matrix identity(A.rows(), A.rows(), 0.0);
        for (Size i=0; i < A.rows(); ++i) identity[i][i] = 1.0;

        if (norm(I1 - identity) > tol)
            BOOST_FAIL("inverse(A)*A does not recover unit matrix (norm = "
                       << norm(I1-identity) << ")");

        if (norm(I2 - identity) > tol)
            BOOST_FAIL("A*inverse(A) does not recover unit matrix (norm = "
                       << norm(I1-identity) << ")");
    }
}

void MatricesTest::testDeterminant() {

    BOOST_TEST_MESSAGE("Testing LU determinant calculation...");

    using namespace matrices_test;

    setup();
    Real tol = 1e-10;

    Matrix testMatrices[] = {M1, M2, M5, M6, I};
    // expected results calculated with octave
    Real expected[] = { 0.044, -0.012, 5.0, 5.7621e-11, 1.0};

    for (Size j=0; j<LENGTH(testMatrices); ++j) {
        const Real calculated = determinant(testMatrices[j]);
        if (std::fabs(expected[j] - calculated) > tol)
            BOOST_FAIL("determinant calculation failed "
                       << "\n matrix     :\n" << testMatrices[j]
                       << "\n calculated : " << calculated
                       << "\n expected   : " << expected[j]);
    }

    MersenneTwisterUniformRng rng(1234);
    for (Size j=0; j<100; ++j) {
        Matrix m(3, 3, 0.0);
        for (double& iter : m)
            iter = rng.next().value;

        if ((j % 3) == 0U) {
            // every third matrix is a singular matrix
            Size row = Size(3*rng.next().value);
            std::fill(m.row_begin(row), m.row_end(row), 0.0);
        }

        Real a=m[0][0];
        Real b=m[0][1];
        Real c=m[0][2];
        Real d=m[1][0];
        Real e=m[1][1];
        Real f=m[1][2];
        Real g=m[2][0];
        Real h=m[2][1];
        Real i=m[2][2];

        const Real expected = a*e*i+b*f*g+c*d*h-(g*e*c+h*f*a+i*d*b);
        const Real calculated = determinant(m);

        if (std::fabs(expected-calculated) > tol)
            BOOST_FAIL("determinant calculation failed "
                       << "\n matrix     :\n" << m
                       << "\n calculated : " << calculated
                       << "\n expected   : " << expected);
    }
}

void MatricesTest::testOrthogonalProjection() {
    BOOST_TEST_MESSAGE("Testing orthogonal projections...");

    Size dimension = 1000;
    Size numberVectors = 50;
    Real multiplier = 100;
    Real tolerance = 1e-6;
    unsigned long seed = 1;

    Real errorAcceptable = 1E-11;

    Matrix test(numberVectors,dimension);

    MersenneTwisterUniformRng rng(seed);

    for (Size i=0; i < numberVectors; ++i)
        for (Size j=0; j < dimension; ++j)
            test[i][j] = rng.next().value;

    OrthogonalProjections projector(test,
                                    multiplier,
                                    tolerance  );

    Size numberFailures =0;
    Size failuresTwo=0;

    for (Size i=0; i < numberVectors; ++i)
    {
        // check output vector i is orthogonal to all other vectors

        if (projector.validVectors()[i])
        {
            for (Size j=0; j < numberVectors; ++j)
                  if (projector.validVectors()[j] && i != j)
                  {
                      Real dotProduct=0.0;
                      for (Size k=0; k < dimension; ++k)
                          dotProduct += test[j][k]*projector.GetVector(i)[k];

                      if (fabs(dotProduct) > errorAcceptable)
                          ++numberFailures;

                  }

           Real innerProductWithOriginal =0.0;
           Real normSq =0.0;

           for (Size j=0; j < dimension; ++j)
           {
                innerProductWithOriginal +=   projector.GetVector(i)[j]*test[i][j];
                normSq += test[i][j]*test[i][j];
           }

           if (fabs(innerProductWithOriginal-normSq) > errorAcceptable)
               ++failuresTwo;

        }

    }

    if (numberFailures > 0 || failuresTwo >0)
        BOOST_FAIL("OrthogonalProjections test failed with " << numberFailures << " failures  of orthogonality and "
                    << failuresTwo << " failures of projection size.");

}

void MatricesTest::testCholeskyDecomposition() {

    BOOST_TEST_MESSAGE("Testing Cholesky Decomposition...");

    // This test case fails prior to release 1.8

    // The eigenvalues of this matrix are
    // 0.0438523; 0.0187376; 0.000245617; 0.000127656; 8.35899e-05; 6.14215e-05;
    // 1.94241e-05; 1.14417e-06; 9.79481e-18; 1.31141e-18; 5.81155e-19

    Real tmp[11][11] = {
        {6.4e-05, 5.28e-05, 2.28e-05, 0.00032, 0.00036, 6.4e-05,
         6.3968010664e-06, 7.2e-05, 7.19460269899e-06, 1.2e-05,
         1.19970004999e-06},
        {5.28e-05, 0.000121, 1.045e-05, 0.00044, 0.000165, 2.2e-05,
         2.19890036657e-06, 1.65e-05, 1.64876311852e-06, 1.1e-05,
         1.09972504583e-06},
        {2.28e-05, 1.045e-05, 9.025e-05, 0, 0.0001425, 9.5e-06,
         9.49525158294e-07, 2.85e-05, 2.84786356835e-06, 4.75e-06,
         4.74881269789e-07},
        {0.00032, 0.00044, 0, 0.04, 0.009, 0.0008, 7.996001333e-05, 0.0006,
         5.99550224916e-05, 0.0001, 9.99750041661e-06},
        {0.00036, 0.000165, 0.0001425, 0.009, 0.0225, 0.0003, 2.99850049987e-05,
         0.001125, 0.000112415667172, 0.000225, 2.24943759374e-05},
        {6.4e-05, 2.2e-05, 9.5e-06, 0.0008, 0.0003, 0.0001, 9.99500166625e-06,
         7.5e-05, 7.49437781145e-06, 2e-05, 1.99950008332e-06},
        {6.3968010664e-06, 2.19890036657e-06, 9.49525158294e-07,
         7.996001333e-05, 2.99850049987e-05, 9.99500166625e-06,
         9.99000583083e-07, 7.49625124969e-06, 7.49063187129e-07,
         1.99900033325e-06, 1.99850066645e-07},
        {7.2e-05, 1.65e-05, 2.85e-05, 0.0006, 0.001125, 7.5e-05,
         7.49625124969e-06, 0.000225, 2.24831334343e-05, 1.5e-05,
         1.49962506249e-06},
        {7.19460269899e-06, 1.64876311852e-06, 2.84786356835e-06,
         5.99550224916e-05, 0.000112415667172, 7.49437781145e-06,
         7.49063187129e-07, 2.24831334343e-05, 2.24662795123e-06,
         1.49887556229e-06, 1.49850090584e-07},
        {1.2e-05, 1.1e-05, 4.75e-06, 0.0001, 0.000225, 2e-05, 1.99900033325e-06,
         1.5e-05, 1.49887556229e-06, 2.5e-05, 2.49937510415e-06},
        {1.19970004999e-06, 1.09972504583e-06, 4.74881269789e-07,
         9.99750041661e-06, 2.24943759374e-05, 1.99950008332e-06,
         1.99850066645e-07, 1.49962506249e-06, 1.49850090584e-07,
         2.49937510415e-06, 2.49875036451e-07}};

    Matrix m(11,11);
    for(Size i=0;i<11;++i) {
        for(Size j=0;j<11;++j) {
            m[i][j] = tmp[i][j];
        }
    }

    Matrix c = CholeskyDecomposition(m,true);
    Matrix m2 = c * transpose(c);

    Real tol = 1.0E-12;
    for(Size i=0;i<11;++i) {
        for(Size j=0;j<11;++j) {
            if(std::isnan(m2[i][j])) {
                BOOST_FAIL("Faield to verify Cholesky decomposition at (i,j)=("
                           << i << "," << j << "), replicated value is nan");
            }
            // this does not detect nan values
            if(std::abs(m[i][j]-m2[i][j]) > tol) {
                BOOST_FAIL("Failed to verify Cholesky decomposition at (i,j)=("
                           << i << "," << j << "), original value is "
                           << m[i][j] << ", replicated value is " << m2[i][j]);
            }
        }
    }
}

void MatricesTest::testMoorePenroseInverse() {

    BOOST_TEST_MESSAGE("Testing Moore-Penrose inverse...");

    // this is taken from
    // http://de.mathworks.com/help/matlab/ref/pinv.html
    Real tmp[8][6] = {{64, 2, 3, 61, 60, 6},    {9, 55, 54, 12, 13, 51},
                      {17, 47, 46, 20, 21, 43}, {40, 26, 27, 37, 36, 30},
                      {32, 34, 35, 29, 28, 38}, {41, 23, 22, 44, 45, 19},
                      {49, 15, 14, 52, 53, 11}, {8, 58, 59, 5, 4, 62}};
    Matrix A(8, 6);
    for (Size i = 0; i < 8; ++i) {
        for (Size j = 0; j < 6; ++j) {
            A(i, j) = tmp[i][j];
        }
    }

    Matrix P = moorePenroseInverse(A);
    Array b(8, 260.0);
    Array x = P*b;

    Real cached[6] = {1.153846153846152, 1.461538461538463, 1.384615384615384,
                      1.384615384615385, 1.461538461538462, 1.153846153846152};
    Real tol = 500.0 * QL_EPSILON;

    for (Size i = 0; i < 6; ++i) {
        if (std::abs(x[i] - cached[i]) > tol) {
            BOOST_FAIL("Failed to verify minimal norm solution obtained from "
                       "Moore-Penrose-Inverse against cached results, component "
                       << i << " is " << x[i] << ", expected " << cached[i]
                       << ", difference " << x[i] - cached[i] << ", tolerance "
                       << tol);
        }
    }

    Array y = A*x;
    Real tol2 = 2000.0 * QL_EPSILON;
    for (Size i = 0; i < 6; ++i) {
        if (std::abs(y[i] - 260.0) > tol2) {
            BOOST_FAIL(
                "Failed to verify minimal norm solution obtained from "
                "Moore-Penrose-Inverse when back-substituting, rhs component "
                << i << " is " << y[i] << ", expected 260.0, difference "
                << y[i] - 260.0 << ", tolerance " << tol2);
        }
    }

}


namespace matrices_test {
    class MatrixMult {
      public:
        explicit MatrixMult(Matrix m) : m_(std::move(m)) {}
        Disposable<Array> operator()(const Array& x) const {
            Array retVal = m_*x;
            return retVal;
        }

      private:
        const Matrix m_;
    };

    Real norm2(const Array& x) {
        return std::sqrt(DotProduct(x,x));
    }
}

void MatricesTest::testIterativeSolvers() {
    BOOST_TEST_MESSAGE("Testing iterative solvers...");

    using namespace matrices_test;

    setup();

    Array b(3);
    b[0] = 1.0; b[1] = 0.5; b[2] = 3.0;

    const Real relTol = 1e4*QL_EPSILON;

    const Array x = BiCGstab(MatrixMult(M1), 3, relTol).solve(b).x;
    if (norm2(M1*x-b)/norm2(b) > relTol) {
        BOOST_FAIL("Failed to calculate inverse using BiCGstab"
                << "\n  rel error     : " << norm2(M1*x-b)/norm2(b)
                << "\n  rel tolerance : " << relTol);
    }

    const GMRESResult u = GMRES(MatrixMult(M1), 3, relTol).solve(b, b);
    if (norm2(M1*u.x-b)/norm2(b) > relTol) {
        BOOST_FAIL("Failed to calculate inverse using gmres"
                << "\n  rel error     : " << norm2(M1*u.x-b)/norm2(b)
                << "\n  rel tolerance : " << relTol);
    }
    const Array errors = Array(u.errors.begin(), u.errors.end());
    for (double error : errors) {
        const Array x = GMRES(MatrixMult(M1), 10, 1.01 * error).solve(b, b).x;

        const Real calculated = norm2(M1*x-b)/norm2(b);
        const Real expected = error;

        if (std::fabs(calculated - expected) > relTol) {
            BOOST_FAIL("Failed to calculate solution error"
                    << "\n  calculated error: " << calculated
                    << "\n  expected error  : " << expected);
        }
    }

    const Array v = GMRES(MatrixMult(M1), 1, relTol,
        MatrixMult(inverse(M1))).solve(b, b).x;

    if (norm2(M1*v-b)/norm2(b) > relTol) {
        BOOST_FAIL("Failed to calculate inverse using gmres "
                   "with exact preconditioning"
                << "\n  rel error     : " << norm2(M1*v-b)/norm2(b)
                << "\n  rel tolerance : " << relTol);
    }

    const Array w = GMRES(MatrixMult(M1), 3, relTol,
        MatrixMult(M1)).solve(b, b).x;
    if (norm2(M1*w-b)/norm2(b) > relTol) {
        BOOST_FAIL("Failed to calculate inverse using gmres "
                   "with nonsense preconditioning"
                << "\n  rel error     : " << norm2(M1*w-b)/norm2(b)
                << "\n  rel tolerance : " << relTol);
    }
}

void MatricesTest::testInitializers() {
    BOOST_TEST_MESSAGE("Testing matrix initializers...");

    Matrix m1 = {};
    BOOST_REQUIRE(m1.rows() == 0);
    BOOST_REQUIRE(m1.columns() == 0);

    Matrix m2 = {
        {1.0, 2.0, 3.0},
        {4.0, 5.0, 6.0}
    };
    BOOST_REQUIRE(m2.rows() == 2);
    BOOST_REQUIRE(m2.columns() == 3);
    BOOST_CHECK_EQUAL(m2(0, 0), 1.0);
    BOOST_CHECK_EQUAL(m2(0, 1), 2.0);
    BOOST_CHECK_EQUAL(m2(0, 2), 3.0);
    BOOST_CHECK_EQUAL(m2(1, 0), 4.0);
    BOOST_CHECK_EQUAL(m2(1, 1), 5.0);
    BOOST_CHECK_EQUAL(m2(1, 2), 6.0);
}


namespace {

    typedef std::pair< std::pair< std::vector<Size>, std::vector<Size> >,
                   std::vector<Real> > coordinate_tuple;

    coordinate_tuple sparseMatrixToCoordinateTuple(const SparseMatrix& m) {
        std::vector<Size> row_idx, col_idx;
        std::vector<Real> data;
        for (auto iter1 = m.begin1(); iter1 != m.end1(); ++iter1)
            for (auto iter2 = iter1.begin(); iter2 != iter1.end(); ++iter2) {
                row_idx.push_back(iter1.index1());
                col_idx.push_back(iter2.index2());
                data.push_back(*iter2);
            }

        return std::make_pair(std::make_pair(row_idx, col_idx), data);
    }

}

void MatricesTest::testSparseMatrixMemory() {

    BOOST_TEST_MESSAGE("Testing sparse matrix memory layout...");

    SparseMatrix m(8, 4);
    BOOST_CHECK_EQUAL(m.filled1(), 1);
    BOOST_CHECK_EQUAL(m.size1(), 8);
    BOOST_CHECK_EQUAL(m.size2(), 4);
    BOOST_CHECK_EQUAL(std::distance(m.begin1(), m.end1()), m.size1());

    auto coords = sparseMatrixToCoordinateTuple(m);
    BOOST_CHECK_EQUAL(coords.first.first.size(), 0);

    m(3, 1) = 42;
    coords = sparseMatrixToCoordinateTuple(m);
    BOOST_CHECK_EQUAL(std::distance(m.begin1(), m.end1()), m.size1());
    BOOST_CHECK_EQUAL(coords.first.first.size(), 1);
    BOOST_CHECK_EQUAL(coords.first.first[0], 3);
    BOOST_CHECK_EQUAL(coords.first.second[0], 1);
    BOOST_CHECK_EQUAL(coords.second[0], 42);

    m(1, 2) = 6;
    coords = sparseMatrixToCoordinateTuple(m);
    BOOST_CHECK_EQUAL(coords.first.first.size(), 2);
    BOOST_CHECK_EQUAL(coords.first.first[0], 1);
    BOOST_CHECK_EQUAL(coords.first.second[0], 2);
    BOOST_CHECK_EQUAL(coords.second[0], 6);

    Array x{1, 2, 3, 4};
    Array y = prod(m, x);
    BOOST_CHECK_EQUAL(y, Array({0, 18, 0, 84}));

    m(3, 2) = 43;
    coords = sparseMatrixToCoordinateTuple(m);
    BOOST_CHECK_EQUAL(coords.first.first.size(), 3);
    BOOST_CHECK_EQUAL(coords.first.first[2], 3);
    BOOST_CHECK_EQUAL(coords.first.second[2], 2);
    BOOST_CHECK_EQUAL(coords.second[2], 43);

    m(7, 3) = 44;
    coords = sparseMatrixToCoordinateTuple(m);
    BOOST_CHECK_EQUAL(coords.first.first.size(), 4);
    BOOST_CHECK_EQUAL(coords.first.first[3], 7);
    BOOST_CHECK_EQUAL(coords.first.second[3], 3);
    BOOST_CHECK_EQUAL(coords.second[3], 44);

    Size entries(0);
    for (auto iter1 = m.begin1(); iter1 != m.end1(); ++iter1)
        entries+=std::distance(iter1.begin(), iter1.end());

    BOOST_CHECK_EQUAL(entries, 4);

}

test_suite* MatricesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Matrix tests");

    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testOrthogonalProjection));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testEigenvectors));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testSqrt));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testSVD));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testHighamSqrt));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testQRDecomposition));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testQRSolve));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testInverse));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testDeterminant));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testSparseMatrixMemory));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testCholeskyDecomposition));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testMoorePenroseInverse));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testIterativeSolvers));
    suite->add(QUANTLIB_TEST_CASE(&MatricesTest::testInitializers));
    return suite;
}

]]></document_content>
  </document>
  <document index="189">
    <source>matrices.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2004, 2007 Neil Firth
 Copyright (C) 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_matrices_hpp
#define quantlib_test_matrices_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MatricesTest {
  public:
    static void testEigenvectors();
    static void testSqrt();
    static void testHighamSqrt();
    static void testSVD();
    static void testQRDecomposition();
    static void testQRSolve();
    static void testInverse();
    static void testDeterminant();
    static void testOrthogonalProjection();
    static void testCholeskyDecomposition();
    static void testMoorePenroseInverse();
    static void testIterativeSolvers();
    static void testInitializers();
    static void testSparseMatrixMemory();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="190">
    <source>mclongstaffschwartzengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "mclongstaffschwartzengine.hpp"
#include "utilities.hpp"
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/pricingengines/mclongstaffschwartzengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/mcamericanengine.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    class AmericanMaxPathPricer : public EarlyExercisePathPricer<MultiPath>  {
      public:
        explicit AmericanMaxPathPricer(ext::shared_ptr<Payoff> payoff)
        : payoff_(std::move(payoff)) {}

        StateType state(const MultiPath& path, Size t) const override {
            Array tmp(path.assetNumber());
            for (Size i=0; i<path.assetNumber(); ++i) {
                tmp[i]=path[i][t];
            }

            return tmp;
        }

        Real operator()(const MultiPath& path, Size t) const override {
            const Array tmp = state(path, t);
            return (*payoff_)(*std::max_element(tmp.begin(), tmp.end()));
        }

        std::vector<ext::function<Real(StateType)> > basisSystem() const override {
            return LsmBasisSystem::multiPathBasisSystem(2, 2,
                                                        LsmBasisSystem::Monomial);
        }

      protected:
        const ext::shared_ptr<Payoff> payoff_;
    };

    template <class RNG>
    class MCAmericanMaxEngine
        : public MCLongstaffSchwartzEngine<VanillaOption::engine,
                                           MultiVariate,RNG>{
      public:
        MCAmericanMaxEngine(
                            const ext::shared_ptr<StochasticProcessArray>& processes,
                            Size timeSteps,
                            Size timeStepsPerYear,
                            bool brownianbridge,
                            bool antitheticVariate,
                            bool controlVariate,
                            Size requiredSamples,
                            Real requiredTolerance,
                            Size maxSamples,
                            BigNatural seed,
                            Size nCalibrationSamples = Null<Size>())
        : MCLongstaffSchwartzEngine<VanillaOption::engine,
                                    MultiVariate,RNG>(processes,
                                                      timeSteps,
                                                      timeStepsPerYear,
                                                      brownianbridge,
                                                      antitheticVariate,
                                                      controlVariate,
                                                      requiredSamples,
                                                      requiredTolerance,
                                                      maxSamples,
                                                      seed, nCalibrationSamples)
        { }

      protected:
        ext::shared_ptr<LongstaffSchwartzPathPricer<MultiPath> > lsmPathPricer() const override {
            ext::shared_ptr<StochasticProcessArray> processArray =
            ext::dynamic_pointer_cast<StochasticProcessArray>(this->process_);
            QL_REQUIRE(processArray && processArray->size() > 0,
                       "Stochastic process array required");

            ext::shared_ptr<GeneralizedBlackScholesProcess> process =
                ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                    processArray->process(0));
            QL_REQUIRE(process, "generalized Black-Scholes proces required");

            ext::shared_ptr<AmericanMaxPathPricer> earlyExercisePathPricer(
                          new AmericanMaxPathPricer(this->arguments_.payoff));

            return ext::make_shared<LongstaffSchwartzPathPricer<MultiPath> > (
                
                    this->timeGrid(),
                    earlyExercisePathPricer,
                    process->riskFreeRate().currentLink());
        }
    };

}


void MCLongstaffSchwartzEngineTest::testAmericanOption() {
    BOOST_TEST_MESSAGE("Testing Monte-Carlo pricing of American options...");

    SavedSettings backup;

    // most of the example taken from the EquityOption.cpp
    const Option::Type type(Option::Put);
    const Real underlying = 36;
    const Spread dividendYield = 0.00;
    const Rate riskFreeRate = 0.06;
    const Volatility volatility = 0.20;

    const Date todaysDate(15, May, 1998);
    const Date settlementDate(17, May, 1998);
    Settings::instance().evaluationDate() = todaysDate;

    const Date maturity(17, May, 1999);
    const DayCounter dayCounter = Actual365Fixed();

    ext::shared_ptr<Exercise> americanExercise(
        new AmericanExercise(settlementDate, maturity));

    // bootstrap the yield/dividend/vol curves
    Handle<YieldTermStructure> flatTermStructure(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(settlementDate, riskFreeRate, dayCounter)));
    Handle<YieldTermStructure> flatDividendTS(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(settlementDate, dividendYield, dayCounter)));

    // expected results for exercise probability, evaluated with third-party
    // product (using Cox-Rubinstein binomial tree)
    Matrix expectedExProb(2, 3);
    expectedExProb[0][0] = 0.48013; // (price: 2.105)
    expectedExProb[0][1] = 0.51678; // (price: 3.451)
    expectedExProb[0][2] = 0.54598; // (price: 4.807)
    expectedExProb[1][0] = 0.75549; // (price: 4.505)
    expectedExProb[1][1] = 0.67569; // (price: 5.764)
    expectedExProb[1][2] = 0.65562; // (price: 7.138)

    LsmBasisSystem::PolynomType polynomTypes[]
        = { LsmBasisSystem::Monomial, LsmBasisSystem::Laguerre,
            LsmBasisSystem::Hermite, LsmBasisSystem::Hyperbolic,
            LsmBasisSystem::Chebyshev2nd };

    for (Integer i=0; i<2; ++i) {
        for (Integer j=0; j<3; ++j) {
            Handle<BlackVolTermStructure> flatVolTS(
                ext::shared_ptr<BlackVolTermStructure>(
                    new BlackConstantVol(settlementDate, NullCalendar(),
                                         volatility+0.1*j, dayCounter)));

            ext::shared_ptr<StrikedTypePayoff> payoff(
                new PlainVanillaPayoff(type, underlying+4*i));

            Handle<Quote> underlyingH(
                ext::shared_ptr<Quote>(new SimpleQuote(underlying)));

            ext::shared_ptr<GeneralizedBlackScholesProcess>
                stochasticProcess(new GeneralizedBlackScholesProcess(
                                      underlyingH, flatDividendTS,
                                      flatTermStructure, flatVolTS));

            VanillaOption americanOption(payoff, americanExercise);

            ext::shared_ptr<PricingEngine> mcengine =
                MakeMCAmericanEngine<PseudoRandom>(stochasticProcess)
                  .withSteps(75)
                  .withAntitheticVariate()
                  .withAbsoluteTolerance(0.02)
                  .withSeed(42)
                  .withPolynomOrder(3)
                  .withBasisSystem(
                       polynomTypes[0*(i*3+j)%LENGTH(polynomTypes)]);

            americanOption.setPricingEngine(mcengine);
            // FLOATING_POINT_EXCEPTION
            const Real calculated = americanOption.NPV();
            const Real errorEstimate = americanOption.errorEstimate();
            const Real exerciseProbability =
                americanOption.result<QuantLib::Real>("exerciseProbability");

            americanOption.setPricingEngine(ext::shared_ptr<PricingEngine>(
                        new FdBlackScholesVanillaEngine(stochasticProcess, 401, 200)));
            const Real expected = americanOption.NPV();

            // Check price
            if (std::fabs(calculated - expected) > 2.34*errorEstimate) {
                BOOST_ERROR("Failed to reproduce american option prices"
                            << "\n    expected: " << expected
                            << "\n    calculated:   " << calculated
                            << " +/- " << errorEstimate);
            }

            // Check exercise probability (tolerance 1.5%)
            if (std::fabs(exerciseProbability - expectedExProb[i][j]) > 0.015) {
                BOOST_ERROR("Failed to reproduce american option "
                            << "exercise probability"
                            << "\n    expected: " << expectedExProb[i][j]
                            << "\n    calculated:   " << exerciseProbability);
            }
        }
    }
}

void MCLongstaffSchwartzEngineTest::testAmericanMaxOption() {

    // reference values taken from
    // "Monte Carlo Methods in Financial Engineering",
    // by Paul Glasserman, 2004 Springer Verlag, p. 462

    BOOST_TEST_MESSAGE("Testing Monte-Carlo pricing of American max options...");

    SavedSettings backup;

    // most of the example taken from the EquityOption.cpp
    const Option::Type type(Option::Call);
    const Real strike = 100;
    const Spread dividendYield = 0.10;
    const Rate riskFreeRate = 0.05;
    const Volatility volatility = 0.20;

    const Date todaysDate(15, May, 1998);
    const Date settlementDate(17, May, 1998);
    Settings::instance().evaluationDate() = todaysDate;

    const Date maturity(16, May, 2001);
    const DayCounter dayCounter = Actual365Fixed();

    ext::shared_ptr<Exercise> americanExercise(
        new AmericanExercise(settlementDate, maturity));

    // bootstrap the yield/dividend/vol curves
    Handle<YieldTermStructure> flatTermStructure(
        ext::shared_ptr<YieldTermStructure>(
            new FlatForward(settlementDate, riskFreeRate, dayCounter)));
    Handle<YieldTermStructure> flatDividendTS(
        ext::shared_ptr<YieldTermStructure>(
            new FlatForward(settlementDate, dividendYield, dayCounter)));

    Handle<BlackVolTermStructure> flatVolTS(
        ext::shared_ptr<BlackVolTermStructure>(new
            BlackConstantVol(settlementDate, NullCalendar(),
                             volatility, dayCounter)));

    ext::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(type, strike));

    RelinkableHandle<Quote> underlyingH;

    ext::shared_ptr<GeneralizedBlackScholesProcess> stochasticProcess(new
        GeneralizedBlackScholesProcess(
            underlyingH, flatDividendTS, flatTermStructure, flatVolTS));

    const Size numberAssets = 2;
    Matrix corr(numberAssets, numberAssets, 0.0);
    std::vector<ext::shared_ptr<StochasticProcess1D> > v;

    for (Size i=0; i<numberAssets; ++i) {
        v.push_back(stochasticProcess);
        corr[i][i] = 1.0;
    }

    ext::shared_ptr<StochasticProcessArray> process(
        new StochasticProcessArray(v, corr));
    VanillaOption americanMaxOption(payoff, americanExercise);

    ext::shared_ptr<PricingEngine> mcengine(
        new MCAmericanMaxEngine<PseudoRandom>(process, 25, Null<Size>(), false,
                                              true, false, 4096,
                                              Null<Real>(), Null<Size>(),
                                              42, 1024));
    americanMaxOption.setPricingEngine(mcengine);

    const Real expected[] = {8.08, 13.90, 21.34};
    for (Size i = 0; i < 3; ++i) {

        const Real underlying = 90.0 + i*10.0;
        underlyingH.linkTo(
            ext::shared_ptr<Quote>(new SimpleQuote(underlying)));

        const Real calculated  = americanMaxOption.NPV();
        const Real errorEstimate = americanMaxOption.errorEstimate();
        if (std::fabs(calculated - expected[i]) > 2.34*errorEstimate) {
                BOOST_ERROR("Failed to reproduce american option prices"
                            << "\n    expected: " << expected[i]
                            << "\n    calculated:   " << calculated
                            << " +/- " << errorEstimate);
        }
    }
}

test_suite* MCLongstaffSchwartzEngineTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Longstaff Schwartz MC engine tests");

    suite->add(QUANTLIB_TEST_CASE(&MCLongstaffSchwartzEngineTest::testAmericanMaxOption));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&MCLongstaffSchwartzEngineTest::testAmericanOption));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="191">
    <source>mclongstaffschwartzengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_mc_longstaff_schwartz_engine_hpp
#define quantlib_test_mc_longstaff_schwartz_engine_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MCLongstaffSchwartzEngineTest {
  public:
    static void testAmericanOption();
    static void testAmericanMaxOption();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="192">
    <source>mersennetwister.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "mersennetwister.hpp"
#include "utilities.hpp"
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void MersenneTwisterTest::testValues() {

    BOOST_TEST_MESSAGE("Testing Mersenne twister...");

    // the following numbers are provided by MT authors in order
    // to check any actual implementation of MT
    static const unsigned long referenceLongValues[] = {
        1067595299UL,  955945823UL,  477289528UL, 4107218783UL, 4228976476UL,
        3344332714UL, 3355579695UL,  227628506UL,  810200273UL, 2591290167UL,
        2560260675UL, 3242736208UL,  646746669UL, 1479517882UL, 4245472273UL,
        1143372638UL, 3863670494UL, 3221021970UL, 1773610557UL, 1138697238UL,
        1421897700UL, 1269916527UL, 2859934041UL, 1764463362UL, 3874892047UL,
        3965319921UL,   72549643UL, 2383988930UL, 2600218693UL, 3237492380UL,
        2792901476UL,  725331109UL,  605841842UL,  271258942UL,  715137098UL,
        3297999536UL, 1322965544UL, 4229579109UL, 1395091102UL, 3735697720UL,
        2101727825UL, 3730287744UL, 2950434330UL, 1661921839UL, 2895579582UL,
        2370511479UL, 1004092106UL, 2247096681UL, 2111242379UL, 3237345263UL,
        4082424759UL,  219785033UL, 2454039889UL, 3709582971UL,  835606218UL,
        2411949883UL, 2735205030UL,  756421180UL, 2175209704UL, 1873865952UL,
        2762534237UL, 4161807854UL, 3351099340UL,  181129879UL, 3269891896UL,
         776029799UL, 2218161979UL, 3001745796UL, 1866825872UL, 2133627728UL,
          34862734UL, 1191934573UL, 3102311354UL, 2916517763UL, 1012402762UL,
        2184831317UL, 4257399449UL, 2899497138UL, 3818095062UL, 3030756734UL,
        1282161629UL,  420003642UL, 2326421477UL, 2741455717UL, 1278020671UL,
        3744179621UL,  271777016UL, 2626330018UL, 2560563991UL, 3055977700UL,
        4233527566UL, 1228397661UL, 3595579322UL, 1077915006UL, 2395931898UL,
        1851927286UL, 3013683506UL, 1999971931UL, 3006888962UL, 1049781534UL,
        1488758959UL, 3491776230UL,  104418065UL, 2448267297UL, 3075614115UL,
        3872332600UL,  891912190UL, 3936547759UL, 2269180963UL, 2633455084UL,
        1047636807UL, 2604612377UL, 2709305729UL, 1952216715UL,  207593580UL,
        2849898034UL,  670771757UL, 2210471108UL,  467711165UL,  263046873UL,
        3569667915UL, 1042291111UL, 3863517079UL, 1464270005UL, 2758321352UL,
        3790799816UL, 2301278724UL, 3106281430UL,    7974801UL, 2792461636UL,
         555991332UL,  621766759UL, 1322453093UL,  853629228UL,  686962251UL,
        1455120532UL,  957753161UL, 1802033300UL, 1021534190UL, 3486047311UL,
        1902128914UL, 3701138056UL, 4176424663UL, 1795608698UL,  560858864UL,
        3737752754UL, 3141170998UL, 1553553385UL, 3367807274UL,  711546358UL,
        2475125503UL,  262969859UL,  251416325UL, 2980076994UL, 1806565895UL,
         969527843UL, 3529327173UL, 2736343040UL, 2987196734UL, 1649016367UL,
        2206175811UL, 3048174801UL, 3662503553UL, 3138851612UL, 2660143804UL,
        1663017612UL, 1816683231UL,  411916003UL, 3887461314UL, 2347044079UL,
        1015311755UL, 1203592432UL, 2170947766UL, 2569420716UL,  813872093UL,
        1105387678UL, 1431142475UL,  220570551UL, 4243632715UL, 4179591855UL,
        2607469131UL, 3090613241UL,  282341803UL, 1734241730UL, 1391822177UL,
        1001254810UL,  827927915UL, 1886687171UL, 3935097347UL, 2631788714UL,
        3905163266UL,  110554195UL, 2447955646UL, 3717202975UL, 3304793075UL,
        3739614479UL, 3059127468UL,  953919171UL, 2590123714UL, 1132511021UL,
        3795593679UL, 2788030429UL,  982155079UL, 3472349556UL,  859942552UL,
        2681007391UL, 2299624053UL,  647443547UL,  233600422UL,  608168955UL,
        3689327453UL, 1849778220UL, 1608438222UL, 3968158357UL, 2692977776UL,
        2851872572UL,  246750393UL, 3582818628UL, 3329652309UL, 4036366910UL,
        1012970930UL,  950780808UL, 3959768744UL, 2538550045UL,  191422718UL,
        2658142375UL, 3276369011UL, 2927737484UL, 1234200027UL, 1920815603UL,
        3536074689UL, 1535612501UL, 2184142071UL, 3276955054UL,  428488088UL,
        2378411984UL, 4059769550UL, 3913744741UL, 2732139246UL,   64369859UL,
        3755670074UL,  842839565UL, 2819894466UL, 2414718973UL, 1010060670UL,
        1839715346UL, 2410311136UL,  152774329UL, 3485009480UL, 4102101512UL,
        2852724304UL,  879944024UL, 1785007662UL, 2748284463UL, 1354768064UL,
        3267784736UL, 2269127717UL, 3001240761UL, 3179796763UL,  895723219UL,
         865924942UL, 4291570937UL,   89355264UL, 1471026971UL, 4114180745UL,
        3201939751UL, 2867476999UL, 2460866060UL, 3603874571UL, 2238880432UL,
        3308416168UL, 2072246611UL, 2755653839UL, 3773737248UL, 1709066580UL,
        4282731467UL, 2746170170UL, 2832568330UL,  433439009UL, 3175778732UL,
          26248366UL, 2551382801UL,  183214346UL, 3893339516UL, 1928168445UL,
        1337157619UL, 3429096554UL, 3275170900UL, 1782047316UL, 4264403756UL,
        1876594403UL, 4289659572UL, 3223834894UL, 1728705513UL, 4068244734UL,
        2867840287UL, 1147798696UL,  302879820UL, 1730407747UL, 1923824407UL,
        1180597908UL, 1569786639UL,  198796327UL,  560793173UL, 2107345620UL,
        2705990316UL, 3448772106UL, 3678374155UL,  758635715UL,  884524671UL,
         486356516UL, 1774865603UL, 3881226226UL, 2635213607UL, 1181121587UL,
        1508809820UL, 3178988241UL, 1594193633UL, 1235154121UL,  326117244UL,
        2304031425UL,  937054774UL, 2687415945UL, 3192389340UL, 2003740439UL,
        1823766188UL, 2759543402UL,   10067710UL, 1533252662UL, 4132494984UL,
          82378136UL,  420615890UL, 3467563163UL,  541562091UL, 3535949864UL,
        2277319197UL, 3330822853UL, 3215654174UL, 4113831979UL, 4204996991UL,
        2162248333UL, 3255093522UL, 2219088909UL, 2978279037UL,  255818579UL,
        2859348628UL, 3097280311UL, 2569721123UL, 1861951120UL, 2907080079UL,
        2719467166UL,  998319094UL, 2521935127UL, 2404125338UL,  259456032UL,
        2086860995UL, 1839848496UL, 1893547357UL, 2527997525UL, 1489393124UL,
        2860855349UL,   76448234UL, 2264934035UL,  744914583UL, 2586791259UL,
        1385380501UL,   66529922UL, 1819103258UL, 1899300332UL, 2098173828UL,
        1793831094UL,  276463159UL,  360132945UL, 4178212058UL,  595015228UL,
         177071838UL, 2800080290UL, 1573557746UL, 1548998935UL,  378454223UL,
        1460534296UL, 1116274283UL, 3112385063UL, 3709761796UL,  827999348UL,
        3580042847UL, 1913901014UL,  614021289UL, 4278528023UL, 1905177404UL,
          45407939UL, 3298183234UL, 1184848810UL, 3644926330UL, 3923635459UL,
        1627046213UL, 3677876759UL,  969772772UL, 1160524753UL, 1522441192UL,
         452369933UL, 1527502551UL,  832490847UL, 1003299676UL, 1071381111UL,
        2891255476UL,  973747308UL, 4086897108UL, 1847554542UL, 3895651598UL,
        2227820339UL, 1621250941UL, 2881344691UL, 3583565821UL, 3510404498UL,
         849362119UL,  862871471UL,  797858058UL, 2867774932UL, 2821282612UL,
        3272403146UL, 3997979905UL,  209178708UL, 1805135652UL,    6783381UL,
        2823361423UL,  792580494UL, 4263749770UL,  776439581UL, 3798193823UL,
        2853444094UL, 2729507474UL, 1071873341UL, 1329010206UL, 1289336450UL,
        3327680758UL, 2011491779UL,   80157208UL,  922428856UL, 1158943220UL,
        1667230961UL, 2461022820UL, 2608845159UL,  387516115UL, 3345351910UL,
        1495629111UL, 4098154157UL, 3156649613UL, 3525698599UL, 4134908037UL,
         446713264UL, 2137537399UL, 3617403512UL,  813966752UL, 1157943946UL,
        3734692965UL, 1680301658UL, 3180398473UL, 3509854711UL, 2228114612UL,
        1008102291UL,  486805123UL,  863791847UL, 3189125290UL, 1050308116UL,
        3777341526UL, 4291726501UL,  844061465UL, 1347461791UL, 2826481581UL,
         745465012UL, 2055805750UL, 4260209475UL, 2386693097UL, 2980646741UL,
         447229436UL, 2077782664UL, 1232942813UL, 4023002732UL, 1399011509UL,
        3140569849UL, 2579909222UL, 3794857471UL,  900758066UL, 2887199683UL,
        1720257997UL, 3367494931UL, 2668921229UL,  955539029UL, 3818726432UL,
        1105704962UL, 3889207255UL, 2277369307UL, 2746484505UL, 1761846513UL,
        2413916784UL, 2685127085UL, 4240257943UL, 1166726899UL, 4215215715UL,
        3082092067UL, 3960461946UL, 1663304043UL, 2087473241UL, 4162589986UL,
        2507310778UL, 1579665506UL,  767234210UL,  970676017UL,  492207530UL,
        1441679602UL, 1314785090UL, 3262202570UL, 3417091742UL, 1561989210UL,
        3011406780UL, 1146609202UL, 3262321040UL, 1374872171UL, 1634688712UL,
        1280458888UL, 2230023982UL,  419323804UL, 3262899800UL,   39783310UL,
        1641619040UL, 1700368658UL, 2207946628UL, 2571300939UL, 2424079766UL,
         780290914UL, 2715195096UL, 3390957695UL,  163151474UL, 2309534542UL,
        1860018424UL,  555755123UL,  280320104UL, 1604831083UL, 2713022383UL,
        1728987441UL, 3639955502UL,  623065489UL, 3828630947UL, 4275479050UL,
        3516347383UL, 2343951195UL, 2430677756UL,  635534992UL, 3868699749UL,
         808442435UL, 3070644069UL, 4282166003UL, 2093181383UL, 2023555632UL,
        1568662086UL, 3422372620UL, 4134522350UL, 3016979543UL, 3259320234UL,
        2888030729UL, 3185253876UL, 4258779643UL, 1267304371UL, 1022517473UL,
         815943045UL,  929020012UL, 2995251018UL, 3371283296UL, 3608029049UL,
        2018485115UL,  122123397UL, 2810669150UL, 1411365618UL, 1238391329UL,
        1186786476UL, 3155969091UL, 2242941310UL, 1765554882UL,  279121160UL,
        4279838515UL, 1641578514UL, 3796324015UL,   13351065UL,  103516986UL,
        1609694427UL,  551411743UL, 2493771609UL, 1316337047UL, 3932650856UL,
        4189700203UL,  463397996UL, 2937735066UL, 1855616529UL, 2626847990UL,
          55091862UL, 3823351211UL,  753448970UL, 4045045500UL, 1274127772UL,
        1124182256UL,   92039808UL, 2126345552UL,  425973257UL,  386287896UL,
        2589870191UL, 1987762798UL, 4084826973UL, 2172456685UL, 3366583455UL,
        3602966653UL, 2378803535UL, 2901764433UL, 3716929006UL, 3710159000UL,
        2653449155UL, 3469742630UL, 3096444476UL, 3932564653UL, 2595257433UL,
         318974657UL, 3146202484UL,  853571438UL,  144400272UL, 3768408841UL,
         782634401UL, 2161109003UL,  570039522UL, 1886241521UL,   14249488UL,
        2230804228UL, 1604941699UL, 3928713335UL, 3921942509UL, 2155806892UL,
         134366254UL,  430507376UL, 1924011722UL,  276713377UL,  196481886UL,
        3614810992UL, 1610021185UL, 1785757066UL,  851346168UL, 3761148643UL,
        2918835642UL, 3364422385UL, 3012284466UL, 3735958851UL, 2643153892UL,
        3778608231UL, 1164289832UL,  205853021UL, 2876112231UL, 3503398282UL,
        3078397001UL, 3472037921UL, 1748894853UL, 2740861475UL,  316056182UL,
        1660426908UL,  168885906UL,  956005527UL, 3984354789UL,  566521563UL,
        1001109523UL, 1216710575UL, 2952284757UL, 3834433081UL, 3842608301UL,
        2467352408UL, 3974441264UL, 3256601745UL, 1409353924UL, 1329904859UL,
        2307560293UL, 3125217879UL, 3622920184UL, 3832785684UL, 3882365951UL,
        2308537115UL, 2659155028UL, 1450441945UL, 3532257603UL, 3186324194UL,
        1225603425UL, 1124246549UL,  175808705UL, 3009142319UL, 2796710159UL,
        3651990107UL,  160762750UL, 1902254979UL, 1698648476UL, 1134980669UL,
         497144426UL, 3302689335UL, 4057485630UL, 3603530763UL, 4087252587UL,
         427812652UL,  286876201UL,  823134128UL, 1627554964UL, 3745564327UL,
        2589226092UL, 4202024494UL,   62878473UL, 3275585894UL, 3987124064UL,
        2791777159UL, 1916869511UL, 2585861905UL, 1375038919UL, 1403421920UL,
          60249114UL, 3811870450UL, 3021498009UL, 2612993202UL,  528933105UL,
        2757361321UL, 3341402964UL, 2621861700UL,  273128190UL, 4015252178UL,
        3094781002UL, 1621621288UL, 2337611177UL, 1796718448UL, 1258965619UL,
        4241913140UL, 2138560392UL, 3022190223UL, 4174180924UL,  450094611UL,
        3274724580UL,  617150026UL, 2704660665UL, 1469700689UL, 1341616587UL,
         356715071UL, 1188789960UL, 2278869135UL, 1766569160UL, 2795896635UL,
          57824704UL, 2893496380UL, 1235723989UL, 1630694347UL, 3927960522UL,
         428891364UL, 1814070806UL, 2287999787UL, 4125941184UL, 3968103889UL,
        3548724050UL, 1025597707UL, 1404281500UL, 2002212197UL,   92429143UL,
        2313943944UL, 2403086080UL, 3006180634UL, 3561981764UL, 1671860914UL,
        1768520622UL, 1803542985UL,  844848113UL, 3006139921UL, 1410888995UL,
        1157749833UL, 2125704913UL, 1789979528UL, 1799263423UL,  741157179UL,
        2405862309UL,  767040434UL, 2655241390UL, 3663420179UL, 2172009096UL,
        2511931187UL, 1680542666UL,  231857466UL, 1154981000UL,  157168255UL,
        1454112128UL, 3505872099UL, 1929775046UL, 2309422350UL, 2143329496UL,
        2960716902UL,  407610648UL, 2938108129UL, 2581749599UL,  538837155UL,
        2342628867UL,  430543915UL,  740188568UL, 1937713272UL, 3315215132UL,
        2085587024UL, 4030765687UL,  766054429UL, 3517641839UL,  689721775UL,
        1294158986UL, 1753287754UL, 4202601348UL, 1974852792UL,   33459103UL,
        3568087535UL, 3144677435UL, 1686130825UL, 4134943013UL, 3005738435UL,
        3599293386UL,  426570142UL,  754104406UL, 3660892564UL, 1964545167UL,
         829466833UL,  821587464UL, 1746693036UL, 1006492428UL, 1595312919UL,
        1256599985UL, 1024482560UL, 1897312280UL, 2902903201UL,  691790057UL,
        1037515867UL, 3176831208UL, 1968401055UL, 2173506824UL, 1089055278UL,
        1748401123UL, 2941380082UL,  968412354UL, 1818753861UL, 2973200866UL,
        3875951774UL, 1119354008UL, 3988604139UL, 1647155589UL, 2232450826UL,
        3486058011UL, 3655784043UL, 3759258462UL,  847163678UL, 1082052057UL,
         989516446UL, 2871541755UL, 3196311070UL, 3929963078UL,  658187585UL,
        3664944641UL, 2175149170UL, 2203709147UL, 2756014689UL, 2456473919UL,
        3890267390UL, 1293787864UL, 2830347984UL, 3059280931UL, 4158802520UL,
        1561677400UL, 2586570938UL,  783570352UL, 1355506163UL,   31495586UL,
        3789437343UL, 3340549429UL, 2092501630UL,  896419368UL,  671715824UL,
        3530450081UL, 3603554138UL, 1055991716UL, 3442308219UL, 1499434728UL,
        3130288473UL, 3639507000UL,   17769680UL, 2259741420UL,  487032199UL,
        4227143402UL, 3693771256UL, 1880482820UL, 3924810796UL,  381462353UL,
        4017855991UL, 2452034943UL, 2736680833UL, 2209866385UL, 2128986379UL,
         437874044UL,  595759426UL,  641721026UL, 1636065708UL, 3899136933UL,
         629879088UL, 3591174506UL,  351984326UL, 2638783544UL, 2348444281UL,
        2341604660UL, 2123933692UL,  143443325UL, 1525942256UL,  364660499UL,
         599149312UL,  939093251UL, 1523003209UL,  106601097UL,  376589484UL,
        1346282236UL, 1297387043UL,  764598052UL, 3741218111UL,  933457002UL,
        1886424424UL, 3219631016UL,  525405256UL, 3014235619UL,  323149677UL,
        2038881721UL, 4100129043UL, 2851715101UL, 2984028078UL, 1888574695UL,
        2014194741UL, 3515193880UL, 4180573530UL, 3461824363UL, 2641995497UL,
        3179230245UL, 2902294983UL, 2217320456UL, 4040852155UL, 1784656905UL,
        3311906931UL,   87498458UL, 2752971818UL, 2635474297UL, 2831215366UL,
        3682231106UL, 2920043893UL, 3772929704UL, 2816374944UL,  309949752UL,
        2383758854UL,  154870719UL,  385111597UL, 1191604312UL, 1840700563UL,
         872191186UL, 2925548701UL, 1310412747UL, 2102066999UL, 1504727249UL,
        3574298750UL, 1191230036UL, 3330575266UL, 3180292097UL, 3539347721UL,
         681369118UL, 3305125752UL, 3648233597UL,  950049240UL, 4173257693UL,
        1760124957UL,  512151405UL,  681175196UL,  580563018UL, 1169662867UL,
        4015033554UL, 2687781101UL,  699691603UL, 2673494188UL, 1137221356UL,
         123599888UL,  472658308UL, 1053598179UL, 1012713758UL, 3481064843UL,
        3759461013UL, 3981457956UL, 3830587662UL, 1877191791UL, 3650996736UL,
         988064871UL, 3515461600UL, 4089077232UL, 2225147448UL, 1249609188UL,
        2643151863UL, 3896204135UL, 2416995901UL, 1397735321UL, 3460025646UL
    };

    static const double referenceValues[] = {
        0.76275443, 0.99000644, 0.98670464, 0.10143112, 0.27933125,
        0.69867227, 0.94218740, 0.03427201, 0.78842173, 0.28180608,
        0.92179002, 0.20785655, 0.54534773, 0.69644020, 0.38107718,
        0.23978165, 0.65286910, 0.07514568, 0.22765211, 0.94872929,
        0.74557914, 0.62664415, 0.54708246, 0.90959343, 0.42043116,
        0.86334511, 0.19189126, 0.14718544, 0.70259889, 0.63426346,
        0.77408121, 0.04531601, 0.04605807, 0.88595519, 0.69398270,
        0.05377184, 0.61711170, 0.05565708, 0.10133577, 0.41500776,
        0.91810699, 0.22320679, 0.23353705, 0.92871862, 0.98897234,
        0.19786706, 0.80558809, 0.06961067, 0.55840445, 0.90479405,
        0.63288060, 0.95009721, 0.54948447, 0.20645042, 0.45000959,
        0.87050869, 0.70806991, 0.19406895, 0.79286390, 0.49332866,
        0.78483914, 0.75145146, 0.12341941, 0.42030252, 0.16728160,
        0.59906494, 0.37575460, 0.97815160, 0.39815952, 0.43595080,
        0.04952478, 0.33917805, 0.76509902, 0.61034321, 0.90654701,
        0.92915732, 0.85365931, 0.18812377, 0.65913428, 0.28814566,
        0.59476081, 0.27835931, 0.60722542, 0.68310435, 0.69387186,
        0.03699800, 0.65897714, 0.17527003, 0.02889304, 0.86777366,
        0.12352068, 0.91439461, 0.32022990, 0.44445731, 0.34903686,
        0.74639273, 0.65918367, 0.92492794, 0.31872642, 0.77749724,
        0.85413832, 0.76385624, 0.32744211, 0.91326300, 0.27458185,
        0.22190155, 0.19865383, 0.31227402, 0.85321225, 0.84243342,
        0.78544200, 0.71854080, 0.92503892, 0.82703064, 0.88306297,
        0.47284073, 0.70059042, 0.48003761, 0.38671694, 0.60465770,
        0.41747204, 0.47163243, 0.72750808, 0.65830223, 0.10955369,
        0.64215401, 0.23456345, 0.95944940, 0.72822249, 0.40888451,
        0.69980355, 0.26677428, 0.57333635, 0.39791582, 0.85377858,
        0.76962816, 0.72004885, 0.90903087, 0.51376506, 0.37732665,
        0.12691640, 0.71249738, 0.81217908, 0.37037313, 0.32772374,
        0.14238259, 0.05614811, 0.74363008, 0.39773267, 0.94859135,
        0.31452454, 0.11730313, 0.62962618, 0.33334237, 0.45547255,
        0.10089665, 0.56550662, 0.60539371, 0.16027624, 0.13245301,
        0.60959939, 0.04671662, 0.99356286, 0.57660859, 0.40269560,
        0.45274629, 0.06699735, 0.85064246, 0.87742744, 0.54508392,
        0.87242982, 0.29321385, 0.67660627, 0.68230715, 0.79052073,
        0.48592054, 0.25186266, 0.93769755, 0.28565487, 0.47219067,
        0.99054882, 0.13155240, 0.47110470, 0.98556600, 0.84397623,
        0.12875246, 0.90953202, 0.49129015, 0.23792727, 0.79481194,
        0.44337770, 0.96564297, 0.67749118, 0.55684872, 0.27286897,
        0.79538393, 0.61965356, 0.22487929, 0.02226018, 0.49248200,
        0.42247006, 0.91797788, 0.99250134, 0.23449967, 0.52531508,
        0.10246337, 0.78685622, 0.34310922, 0.89892996, 0.40454552,
        0.68608407, 0.30752487, 0.83601319, 0.54956031, 0.63777550,
        0.82199797, 0.24890696, 0.48801123, 0.48661910, 0.51223987,
        0.32969635, 0.31075073, 0.21393155, 0.73453207, 0.15565705,
        0.58584522, 0.28976728, 0.97621478, 0.61498701, 0.23891470,
        0.28518540, 0.46809591, 0.18371914, 0.37597910, 0.13492176,
        0.66849449, 0.82811466, 0.56240330, 0.37548956, 0.27562998,
        0.27521910, 0.74096121, 0.77176757, 0.13748143, 0.99747138,
        0.92504502, 0.09175241, 0.21389176, 0.21766512, 0.31183245,
        0.23271221, 0.21207367, 0.57903312, 0.77523344, 0.13242613,
        0.31037988, 0.01204835, 0.71652949, 0.84487594, 0.14982178,
        0.57423142, 0.45677888, 0.48420169, 0.53465428, 0.52667473,
        0.46880526, 0.49849733, 0.05670710, 0.79022476, 0.03872047,
        0.21697212, 0.20443086, 0.28949326, 0.81678186, 0.87629474,
        0.92297064, 0.27373097, 0.84625273, 0.51505586, 0.00582792,
        0.33295971, 0.91848412, 0.92537226, 0.91760033, 0.07541125,
        0.71745848, 0.61158698, 0.00941650, 0.03135554, 0.71527471,
        0.24821915, 0.63636652, 0.86159918, 0.26450229, 0.60160194,
        0.35557725, 0.24477500, 0.07186456, 0.51757096, 0.62120362,
        0.97981062, 0.69954667, 0.21065616, 0.13382753, 0.27693186,
        0.59644095, 0.71500764, 0.04110751, 0.95730081, 0.91600724,
        0.47704678, 0.26183479, 0.34706971, 0.07545431, 0.29398385,
        0.93236070, 0.60486023, 0.48015011, 0.08870451, 0.45548581,
        0.91872718, 0.38142712, 0.10668643, 0.01397541, 0.04520355,
        0.93822273, 0.18011940, 0.57577277, 0.91427606, 0.30911399,
        0.95853475, 0.23611214, 0.69619891, 0.69601980, 0.76765372,
        0.58515930, 0.49479057, 0.11288752, 0.97187699, 0.32095365,
        0.57563608, 0.40760618, 0.78703383, 0.43261152, 0.90877651,
        0.84686346, 0.10599030, 0.72872803, 0.19315490, 0.66152912,
        0.10210518, 0.06257876, 0.47950688, 0.47062066, 0.72701157,
        0.48915116, 0.66110261, 0.60170685, 0.24516994, 0.12726050,
        0.03451185, 0.90864994, 0.83494878, 0.94800035, 0.91035206,
        0.14480751, 0.88458997, 0.53498312, 0.15963215, 0.55378627,
        0.35171349, 0.28719791, 0.09097957, 0.00667896, 0.32309622,
        0.87561479, 0.42534520, 0.91748977, 0.73908457, 0.41793223,
        0.99279792, 0.87908370, 0.28458072, 0.59132853, 0.98672190,
        0.28547393, 0.09452165, 0.89910674, 0.53681109, 0.37931425,
        0.62683489, 0.56609740, 0.24801549, 0.52948179, 0.98328855,
        0.66403523, 0.55523786, 0.75886666, 0.84784685, 0.86829981,
        0.71448906, 0.84670080, 0.43922919, 0.20771016, 0.64157936,
        0.25664246, 0.73055695, 0.86395782, 0.65852932, 0.99061803,
        0.40280575, 0.39146298, 0.07291005, 0.97200603, 0.20555729,
        0.59616495, 0.08138254, 0.45796388, 0.33681125, 0.33989127,
        0.18717090, 0.53545811, 0.60550838, 0.86520709, 0.34290701,
        0.72743276, 0.73023855, 0.34195926, 0.65019733, 0.02765254,
        0.72575740, 0.32709576, 0.03420866, 0.26061893, 0.56997511,
        0.28439072, 0.84422744, 0.77637570, 0.55982168, 0.06720327,
        0.58449067, 0.71657369, 0.15819609, 0.58042821, 0.07947911,
        0.40193792, 0.11376012, 0.88762938, 0.67532159, 0.71223735,
        0.27829114, 0.04806073, 0.21144026, 0.58830274, 0.04140071,
        0.43215628, 0.12952729, 0.94668759, 0.87391019, 0.98382450,
        0.27750768, 0.90849647, 0.90962737, 0.59269720, 0.96102026,
        0.49544979, 0.32007095, 0.62585546, 0.03119821, 0.85953001,
        0.22017528, 0.05834068, 0.80731217, 0.53799961, 0.74166948,
        0.77426600, 0.43938444, 0.54862081, 0.58575513, 0.15886492,
        0.73214332, 0.11649057, 0.77463977, 0.85788827, 0.17061997,
        0.66838056, 0.96076133, 0.07949296, 0.68521946, 0.89986254,
        0.05667410, 0.12741385, 0.83470977, 0.63969104, 0.46612929,
        0.10200126, 0.01194925, 0.10476340, 0.90285217, 0.31221221,
        0.32980614, 0.46041971, 0.52024973, 0.05425470, 0.28330912,
        0.60426543, 0.00598243, 0.97244013, 0.21135841, 0.78561597,
        0.78428734, 0.63422849, 0.32909934, 0.44771136, 0.27380750,
        0.14966697, 0.18156268, 0.65686758, 0.28726350, 0.97074787,
        0.63676171, 0.96649494, 0.24526295, 0.08297372, 0.54257548,
        0.03166785, 0.33735355, 0.15946671, 0.02102971, 0.46228045,
        0.11892296, 0.33408336, 0.29875681, 0.29847692, 0.73767569,
        0.02080745, 0.62980060, 0.08082293, 0.22993106, 0.25031439,
        0.87787525, 0.45150053, 0.13673441, 0.63407612, 0.97907688,
        0.52241942, 0.50580158, 0.06273902, 0.05270283, 0.77031811,
        0.05113352, 0.24393329, 0.75036441, 0.37436336, 0.22877652,
        0.59975358, 0.85707591, 0.88691457, 0.85547165, 0.36641027,
        0.58720133, 0.45462835, 0.09243817, 0.32981586, 0.07820411,
        0.25421519, 0.36004706, 0.60092307, 0.46192412, 0.36758683,
        0.98424170, 0.08019934, 0.68594024, 0.45826386, 0.29962317,
        0.79365413, 0.89231296, 0.49478547, 0.87645944, 0.23590734,
        0.28106737, 0.75026285, 0.08136314, 0.79582424, 0.76010628,
        0.82792971, 0.27947652, 0.72482861, 0.82191216, 0.46171689,
        0.79189752, 0.96043686, 0.51609668, 0.88995725, 0.28998963,
        0.55191845, 0.03934737, 0.83033700, 0.49553013, 0.98009549,
        0.19017594, 0.98347750, 0.33452066, 0.87144372, 0.72106301,
        0.71272114, 0.71465963, 0.88361677, 0.85571283, 0.73782329,
        0.20920458, 0.34855153, 0.46766817, 0.02780062, 0.74898344,
        0.03680650, 0.44866557, 0.77426312, 0.91025891, 0.25195236,
        0.87319953, 0.63265037, 0.25552148, 0.27422476, 0.95217406,
        0.39281839, 0.66441573, 0.09158900, 0.94515992, 0.07800798,
        0.02507888, 0.39901462, 0.17382573, 0.12141278, 0.85502334,
        0.19902911, 0.02160210, 0.44460522, 0.14688742, 0.68020336,
        0.71323733, 0.60922473, 0.95400380, 0.99611159, 0.90897777,
        0.41073520, 0.66206647, 0.32064685, 0.62805003, 0.50677209,
        0.52690101, 0.87473387, 0.73918362, 0.39826974, 0.43683919,
        0.80459118, 0.32422684, 0.01958019, 0.95319576, 0.98326137,
        0.83931735, 0.69060863, 0.33671416, 0.68062550, 0.65152380,
        0.33392969, 0.03451730, 0.95227244, 0.68200635, 0.85074171,
        0.64721009, 0.51234433, 0.73402047, 0.00969637, 0.93835057,
        0.80803854, 0.31485260, 0.20089527, 0.01323282, 0.59933780,
        0.31584602, 0.20209563, 0.33754800, 0.68604181, 0.24443049,
        0.19952227, 0.78162632, 0.10336988, 0.11360736, 0.23536740,
        0.23262256, 0.67803776, 0.48749791, 0.74658435, 0.92156640,
        0.56706407, 0.36683221, 0.99157136, 0.23421374, 0.45183767,
        0.91609720, 0.85573315, 0.37706276, 0.77042618, 0.30891908,
        0.40709595, 0.06944866, 0.61342849, 0.88817388, 0.58734506,
        0.98711323, 0.14744128, 0.63242656, 0.87704136, 0.68347125,
        0.84446569, 0.43265239, 0.25146321, 0.04130111, 0.34259839,
        0.92697368, 0.40878778, 0.56990338, 0.76204273, 0.19820348,
        0.66314909, 0.02482844, 0.06669207, 0.50205581, 0.26084093,
        0.65139159, 0.41650223, 0.09733904, 0.56344203, 0.62651696,
        0.67332139, 0.58037374, 0.47258086, 0.21010758, 0.05713135,
        0.89390629, 0.10781246, 0.32037450, 0.07628388, 0.34227964,
        0.42190597, 0.58201860, 0.77363549, 0.49595133, 0.86031236,
        0.83906769, 0.81098161, 0.26694195, 0.14215941, 0.88210306,
        0.53634237, 0.12090720, 0.82480459, 0.75930318, 0.31847147,
        0.92768077, 0.01037616, 0.56201727, 0.88107122, 0.35925856,
        0.85860762, 0.61109408, 0.70408301, 0.58434977, 0.92192494,
        0.62667915, 0.75988365, 0.06858761, 0.36156496, 0.58057195,
        0.13636150, 0.57719713, 0.59340255, 0.63530602, 0.22976282,
        0.71915530, 0.41162531, 0.63979565, 0.09931342, 0.79344045,
        0.10893790, 0.84450224, 0.23122236, 0.99485593, 0.73637397,
        0.17276368, 0.13357764, 0.74965804, 0.64991737, 0.61990341,
        0.41523170, 0.05878239, 0.05687301, 0.05497131, 0.42868366,
        0.42571090, 0.25810502, 0.89642955, 0.30439758, 0.39310223,
        0.11357431, 0.04288255, 0.23397550, 0.11200634, 0.85621396,
        0.89733974, 0.37508865, 0.42077265, 0.68597384, 0.72781399,
        0.19296476, 0.61699087, 0.31667128, 0.67756410, 0.00177323,
        0.05725176, 0.79474693, 0.18885238, 0.06724856, 0.68193156,
        0.42202167, 0.22082041, 0.28554673, 0.64995708, 0.87851940,
        0.29124547, 0.61009521, 0.87374537, 0.05743712, 0.69902994,
        0.81925115, 0.45653873, 0.37236821, 0.31118709, 0.52734307,
        0.39672836, 0.38185294, 0.30163915, 0.17374510, 0.04913278,
        0.90404879, 0.25742801, 0.58266467, 0.97663209, 0.79823377,
        0.36437958, 0.15206043, 0.26529938, 0.22690047, 0.05839021,
        0.84721160, 0.18622435, 0.37809403, 0.55706977, 0.49828704,
        0.47659049, 0.24289680, 0.88477595, 0.07807463, 0.56245739,
        0.73490635, 0.21099431, 0.13164942, 0.75840044, 0.66877037,
        0.28988183, 0.44046090, 0.24967434, 0.80048356, 0.26029740,
        0.30416821, 0.64151867, 0.52067892, 0.12880774, 0.85465381,
        0.02690525, 0.19149288, 0.49630295, 0.79682619, 0.43566145,
        0.00288078, 0.81484193, 0.03763639, 0.68529083, 0.01339574,
        0.38405386, 0.30537067, 0.22994703, 0.44000045, 0.27217985,
        0.53831243, 0.02870435, 0.86282045, 0.61831306, 0.09164956,
        0.25609707, 0.07445781, 0.72185784, 0.90058883, 0.30070608,
        0.94476583, 0.56822213, 0.21933909, 0.96772793, 0.80063440,
        0.26307906, 0.31183306, 0.16501252, 0.55436179, 0.68562285,
        0.23829083, 0.86511559, 0.57868991, 0.81888344, 0.20126869,
        0.93172350, 0.66028129, 0.21786948, 0.78515828, 0.10262106,
        0.35390326, 0.79303876, 0.63427924, 0.90479631, 0.31024934,
        0.60635447, 0.56198079, 0.63573813, 0.91854197, 0.99701497,
        0.83085849, 0.31692291, 0.01925964, 0.97446405, 0.98751283,
        0.60944293, 0.13751018, 0.69519957, 0.68956636, 0.56969015,
        0.46440193, 0.88341765, 0.36754434, 0.89223647, 0.39786427,
        0.85055280, 0.12749961, 0.79452122, 0.89449784, 0.14567830,
        0.45716830, 0.74822309, 0.28200437, 0.42546044, 0.17464886,
        0.68308746, 0.65496587, 0.52935411, 0.12736159, 0.61523955,
        0.81590528, 0.63107864, 0.39786553, 0.20102294, 0.53292914,
        0.75485590, 0.59847044, 0.32861691, 0.12125866, 0.58917183,
        0.07638293, 0.86845380, 0.29192617, 0.03989733, 0.52180460,
        0.32503407, 0.64071852, 0.69516575, 0.74254998, 0.54587026,
        0.48713246, 0.32920155, 0.08719954, 0.63497059, 0.54328459,
        0.64178757, 0.45583809, 0.70694291, 0.85212760, 0.86074305,
        0.33163422, 0.85739792, 0.59908488, 0.74566046, 0.72157152
    };

    Integer i;
    std::vector<unsigned long> init(4);
    init[0]=0x123;
    init[1]=0x234;
    init[2]=0x345;
    init[3]=0x456;
    MersenneTwisterUniformRng mt19937(init);

    for (i=0; i<1000; i++) {
        if (referenceLongValues[i] != mt19937.nextInt32()) {
            BOOST_FAIL("Mersenne Twister test failed at index " << i);
        }
    }
    for (i=0; i<1000; i++) {
        Real e = std::fabs(referenceValues[i] -
                             mt19937.next().value);
        if (e > 1.0e-8) {
            BOOST_FAIL("Mersenne Twister test failed at index: " << i << "\n"
                       "error: " << e);
        }
    }

    // check absence of interaction between instances:
    // a) with sequential use
    MersenneTwisterUniformRng mt1(init), mt2(init);
    for (i=0; i<1000; i++)
        mt1.nextInt32();
    for (i=0; i<999; i++)
        mt2.nextInt32();
    if (referenceLongValues[999] != mt2.nextInt32())
        BOOST_FAIL("Detected interaction between Mersenne Twister instances "
                   "during sequential computation");

    // b) with parallel use
    MersenneTwisterUniformRng mt3(init), mt4(init);
    for (i=0; i<999; i++) {
        mt3.nextInt32();
        mt4.nextInt32();
    }
    if (referenceLongValues[999] != mt3.nextInt32() ||
        referenceLongValues[999] != mt4.nextInt32())
        BOOST_FAIL("Detected interaction between Mersenne Twister instances "
                   "during parallel computation");
}


test_suite* MersenneTwisterTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Mersenne twister tests");
    suite->add(QUANTLIB_TEST_CASE(&MersenneTwisterTest::testValues));
    return suite;
}

]]></document_content>
  </document>
  <document index="193">
    <source>mersennetwister.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_mt19937_hpp
#define quantlib_test_mt19937_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MersenneTwisterTest {
  public:
    static void testValues();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="194">
    <source>money.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "money.hpp"
#include "utilities.hpp"
#include <ql/money.hpp>
#include <ql/currencies/europe.hpp>
#include <ql/currencies/america.hpp>
#include <ql/currencies/exchangeratemanager.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void MoneyTest::testNone() {

    BOOST_TEST_MESSAGE("Testing money arithmetic without conversions...");

    Currency EUR = EURCurrency();

    Money m1 = 50000.0 * EUR;
    Money m2 = 100000.0 * EUR;
    Money m3 = 500000.0 * EUR;

    Money::conversionType = Money::NoConversion;

    Money calculated = m1*3.0 + 2.5*m2 - m3/5.0;
    Decimal x = m1.value()*3.0 + 2.5*m2.value() - m3.value()/5.0;
    Money expected(x, EUR);

    if (calculated != expected) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}


void MoneyTest::testBaseCurrency() {

    BOOST_TEST_MESSAGE("Testing money arithmetic with conversion "
                       "to base currency...");

    Currency EUR = EURCurrency(), GBP = GBPCurrency(), USD = USDCurrency();

    Money m1 = 50000.0 * GBP;
    Money m2 = 100000.0 * EUR;
    Money m3 = 500000.0 * USD;

    ExchangeRateManager::instance().clear();
    ExchangeRate eur_usd = ExchangeRate(EUR, USD, 1.2042);
    ExchangeRate eur_gbp = ExchangeRate(EUR, GBP, 0.6612);
    ExchangeRateManager::instance().add(eur_usd);
    ExchangeRateManager::instance().add(eur_gbp);

    Money::conversionType = Money::BaseCurrencyConversion;
    Money::baseCurrency = EUR;

    Money calculated = m1*3.0 + 2.5*m2 - m3/5.0;

    Rounding round = Money::baseCurrency.rounding();
    Decimal x = round(m1.value()*3.0/eur_gbp.rate()) + 2.5*m2.value()
              - round(m3.value()/(5.0*eur_usd.rate()));
    Money expected(x, EUR);

    Money::conversionType = Money::NoConversion;

    if (calculated != expected) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}


void MoneyTest::testAutomated() {

    BOOST_TEST_MESSAGE("Testing money arithmetic with automated conversion...");

    Currency EUR = EURCurrency(), GBP = GBPCurrency(), USD = USDCurrency();

    Money m1 = 50000.0 * GBP;
    Money m2 = 100000.0 * EUR;
    Money m3 = 500000.0 * USD;

    ExchangeRateManager::instance().clear();
    ExchangeRate eur_usd = ExchangeRate(EUR, USD, 1.2042);
    ExchangeRate eur_gbp = ExchangeRate(EUR, GBP, 0.6612);
    ExchangeRateManager::instance().add(eur_usd);
    ExchangeRateManager::instance().add(eur_gbp);

    Money::conversionType = Money::AutomatedConversion;

    Money calculated = (m1*3.0 + 2.5*m2) - m3/5.0;

    Rounding round = m1.currency().rounding();
    Decimal x = m1.value()*3.0 + round(2.5*m2.value()*eur_gbp.rate())
              - round((m3.value()/5.0)*eur_gbp.rate()/eur_usd.rate());
    Money expected(x, GBP);

    Money::conversionType = Money::NoConversion;

    if (calculated != expected) {
        BOOST_FAIL("Wrong result: \n"
                   << "    expected:   " << expected << "\n"
                   << "    calculated: " << calculated);
    }
}

test_suite* MoneyTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Money tests");
    suite->add(QUANTLIB_TEST_CASE(&MoneyTest::testNone));
    suite->add(QUANTLIB_TEST_CASE(&MoneyTest::testBaseCurrency));
    suite->add(QUANTLIB_TEST_CASE(&MoneyTest::testAutomated));
    return suite;
}

]]></document_content>
  </document>
  <document index="195">
    <source>money.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_money_hpp
#define quantlib_test_money_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class MoneyTest {
  public:
    static void testNone();
    static void testBaseCurrency();
    static void testAutomated();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="196">
    <source>noarbsabr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "noarbsabr.hpp"
#include "utilities.hpp"
#include <ql/termstructures/volatility/sabrsmilesection.hpp>
#include <ql/experimental/volatility/noarbsabrsmilesection.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {
void checkD0(const Real sigmaI, const Real beta, const Real rho, const Real nu,
             const Real tau, const unsigned int absorptions) {

    Real forward = 0.03; // does not matter in the end
    Real alpha = sigmaI / std::pow(forward, beta - 1.0);

    QuantLib::detail::D0Interpolator d(forward, tau, alpha, beta, nu, rho);

    if (std::fabs(d() * QuantLib::detail::NoArbSabrModel::nsim - (Real)absorptions) > 0.1)
        BOOST_ERROR("failed to reproduce number of absorptions at sigmaI="
                    << sigmaI << ", beta=" << beta << ", rho=" << rho << ", nu="
                    << nu << " tau=" << tau << ": D0Interpolator says "
                    << d() * QuantLib::detail::NoArbSabrModel::nsim
                    << " while the reference value is " << absorptions);
}
}

void NoArbSabrTest::testAbsorptionMatrix() {

    BOOST_TEST_MESSAGE("Testing no-arbitrage Sabr absorption matrix...");

    // check some points explicitly against the external file's contents

    // sigmaI, beta, rho, nu, tau, absorptions
    checkD0(1,0.01,0.75,0.1,0.25,60342); // upper left corner
    checkD0(0.8,0.01,0.75,0.1,0.25,12148);
    checkD0(0.05,0.01,0.75,0.1,0.25,0);
    checkD0(1,0.01,0.75,0.1,10.0,1890509);
    checkD0(0.8,0.01,0.75,0.1,10.0,1740233);
    checkD0(0.05,0.01,0.75,0.1,10.0,0);
    checkD0(1,0.01,0.75,0.1,30.0,2174176);
    checkD0(0.8,0.01,0.75,0.1,30.0,2090672);
    checkD0(0.05,0.01,0.75,0.1,30.0,31);
    checkD0(0.35,0.10,-0.75,0.1,0.25,0);
    checkD0(0.35,0.10,-0.75,0.1,14.75,1087841);
    checkD0(0.35,0.10,-0.75,0.1,30.0,1406569);
    checkD0(0.24,0.90,0.50,0.8,1.25,27);
    checkD0(0.24,0.90,0.50,0.8,25.75,167541);
    checkD0(0.05,0.90,-0.75,0.8,2.0,17);
    checkD0(0.05,0.90,-0.75,0.8,30.0,42100); // lower right corner

}

void NoArbSabrTest::testConsistencyWithHagan() {

    BOOST_TEST_MESSAGE("Testing consistency of noarb-sabr with Hagan et al (2002)");

    // parameters taken from Doust's paper, figure 3

    Real tau = 1.0;
    Real beta = 0.5;
    Real alpha = 0.026;
    Real rho = -0.1;
    Real nu = 0.4;
    Real f = 0.0488;

    SabrSmileSection sabr(tau, f, {alpha, beta, nu, rho});
    NoArbSabrSmileSection noarbsabr(tau, f, {alpha, beta, nu, rho});

    Real absProb=noarbsabr.model()->absorptionProbability();
    if( absProb > 1E-10 || absProb < 0.0 )
        BOOST_ERROR("absorption probability should be close to zero, but is " << absProb);

    Real strike = 0.0001;
    while (strike < 0.15) {
        // test vanilla prices
        Real sabrPrice = sabr.optionPrice(strike);
        Real noarbsabrPrice = noarbsabr.optionPrice(strike);
        if (std::fabs(sabrPrice - noarbsabrPrice) > 1e-5)
            BOOST_ERROR("incosistent Hagan price ("
                        << sabrPrice << ") and noarb-sabr price ("
                        << noarbsabrPrice << ") at strike " << strike);
        // test digitals
        Real sabrDigital = sabr.digitalOptionPrice(strike);
        Real noarbsabrDigital = noarbsabr.digitalOptionPrice(strike);
        if (std::fabs(sabrDigital - noarbsabrDigital) > 1e-3)
            BOOST_ERROR("incosistent Hagan digital ("
                        << sabrDigital << ") and noarb-sabr digital ("
                        << noarbsabrDigital << ") at strike " << strike);
        // test density
        Real sabrDensity = sabr.density(strike);
        Real noarbsabrDensity = noarbsabr.density(strike);
        if (std::fabs(sabrDensity - noarbsabrDensity) > 1e-0)
            BOOST_ERROR("incosistent Hagan density ("
                        << sabrDensity << ") and noarb-sabr density ("
                        << noarbsabrDensity << ") at strike " << strike);
        strike += 0.0001;
    }

}


test_suite* NoArbSabrTest::suite() {
    auto* suite = BOOST_TEST_SUITE("NoArbSabrModel tests");
    suite->add(QUANTLIB_TEST_CASE(&NoArbSabrTest::testAbsorptionMatrix));
    suite->add(QUANTLIB_TEST_CASE(&NoArbSabrTest::testConsistencyWithHagan));
    return suite;
}
]]></document_content>
  </document>
  <document index="197">
    <source>noarbsabr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_noarbsabr_hpp
#define quantlib_test_noarbsabr_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class NoArbSabrTest {
  public:
    static void testAbsorptionMatrix();
    static void testConsistencyWithHagan();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="198">
    <source>normalclvmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include "normalclvmodel.hpp"
#include "utilities.hpp"
#include <ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/finitedifferences/fdornsteinuhlenbeckvanillaengine.hpp>
#include <ql/experimental/models/normalclvmodel.hpp>
#include <ql/experimental/volatility/sabrvoltermstructure.hpp>
#include <ql/functional.hpp>
#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/randomnumbers/sobolbrownianbridgersg.hpp>
#include <ql/math/statistics/statistics.hpp>
#include <ql/methods/finitedifferences/utilities/bsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <ql/methods/montecarlo/pathgenerator.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/forward/forwardengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/hestonblackvolsurface.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void NormalCLVModelTest::testBSCumlativeDistributionFunction() {
    BOOST_TEST_MESSAGE("Testing Black-Scholes cumulative distribution function"
                       " with constant volatility...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(22, June, 2016);
    const Date maturity = today + Period(6, Months);

    const Real s0 = 100;
    const Real rRate = 0.1;
    const Real qRate = 0.05;
    const Volatility vol = 0.25;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));
    const Handle<YieldTermStructure> qTS(flatRate(today, qRate, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));
    const Handle<BlackVolTermStructure> volTS(flatVol(today, vol, dc));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, volTS));
    const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess;

    const NormalCLVModel m(
        bsProcess, ouProcess, std::vector<Date>(), 5);
    const BSMRNDCalculator rndCalculator(bsProcess);


    const Real tol = 1e5*QL_EPSILON;
    const Time t = dc.yearFraction(today, maturity);
    for (Real x=10; x < 400; x+=10) {
        const Real calculated = m.cdf(maturity, x);
        const Real expected = rndCalculator.cdf(std::log(x), t);

        if (std::fabs(calculated - expected) > tol) {
            BOOST_FAIL("Failed to reproduce CDF for "
                       << "\n    strike:     " << x
                       << "\n    calculated: " << calculated
                       << "\n    expected:   " << expected);
        }
    }
}

void NormalCLVModelTest::testHestonCumlativeDistributionFunction() {
    BOOST_TEST_MESSAGE("Testing Heston cumulative distribution function...");

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(22, June, 2016);
    const Date maturity = today + Period(1, Years);

    const Real s0 = 100;
    const Real v0 = 0.01;
    const Real rRate = 0.1;
    const Real qRate = 0.05;
    const Real kappa = 2.0;
    const Real theta = 0.09;
    const Real sigma = 0.4;
    const Real rho = -0.75;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));
    const Handle<YieldTermStructure> qTS(flatRate(today, qRate, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));

    const ext::shared_ptr<HestonProcess> process(
        ext::make_shared<HestonProcess>(
            rTS, qTS, spot, v0, kappa, theta, sigma, rho));

    const Handle<BlackVolTermStructure> hestonVolTS(
        ext::make_shared<HestonBlackVolSurface>(
            Handle<HestonModel>(ext::make_shared<HestonModel>(process))));

    const NormalCLVModel m(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, hestonVolTS),
        ext::shared_ptr<OrnsteinUhlenbeckProcess>(),
        std::vector<Date>(), 5);

    const HestonRNDCalculator rndCalculator(process);

    const Real tol = 1e-6;
    const Time t = dc.yearFraction(today, maturity);
    for (Real x=10; x < 400; x+=25) {
        const Real calculated = m.cdf(maturity, x);
        const Real expected = rndCalculator.cdf(std::log(x), t);

        if (std::fabs(calculated - expected) > tol) {
            BOOST_FAIL("Failed to reproduce CDF for "
                       << "\n    strike:     " << x
                       << "\n    calculated: " << calculated
                       << "\n    expected:   " << expected);
        }
    }
}



void NormalCLVModelTest::testIllustrative1DExample() {
    BOOST_TEST_MESSAGE(
        "Testing illustrative 1D example of normal CLV model...");

    SavedSettings backup;

    // example taken from:
    // A. Grzelak, 2015, The CLV Framework -
    // A Fresh Look at Efficient Pricing with Smile
    // http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2747541

    const DayCounter dc = Actual360();
    const Date today = Date(22, June, 2016);

    //SABR
    const Real beta = 0.5;
    const Real alpha= 0.2;
    const Real rho  = -0.9;
    const Real gamma= 0.2;

    // Ornstein-Uhlenbeck
    const Real speed = 1.3;
    const Real level = 0.1;
    const Real vol   = 0.25;
    const Real x0    = 1.0;

    const Real s0    = 1.0;
    const Real rRate = 0.03;
    const Real qRate = 0.0;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));
    const Handle<YieldTermStructure> qTS(flatRate(today, qRate, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));

    const Handle<BlackVolTermStructure> sabrVol(
        ext::make_shared<SABRVolTermStructure>(
            alpha, beta, gamma, rho, s0, rRate, today, dc));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, sabrVol));

    const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess(
        ext::make_shared<OrnsteinUhlenbeckProcess>(
            speed, vol, x0, level));

    std::vector<Date> maturityDates = {
        today + Period(18, Days),
        today + Period(90, Days),
        today + Period(180, Days),
        today + Period(360, Days),
        today + Period(720, Days)
    };

    const NormalCLVModel m(bsProcess, ouProcess, maturityDates, 4);
    const ext::function<Real(Real, Real)> g = m.g();

    // test collocation points in x_ij
    std::vector<Date> maturities = { maturityDates[0], maturityDates[2], maturityDates[4] };

    std::vector<std::vector<Real> > x = {
        { 1.070, 0.984, 0.903, 0.817 },
        { 0.879, 0.668, 0.472, 0.261 },
        { 0.528, 0.282, 0.052,-0.194 }
    };

    std::vector<std::vector<Real> > s = {
        {1.104, 1.035, 0.969, 0.895},
        {1.328, 1.122, 0.911, 0.668},
        {1.657, 1.283, 0.854, 0.339}
    };

    std::vector<Real> c = { 2.3344, 0.7420, -0.7420, -2.3344 };

    const Real tol = 0.001;
    for (Size i=0; i < maturities.size(); ++i) {
        const Time t = dc.yearFraction(today, maturities[i]);

        for (Size j=0; j < x.front().size(); ++j) {
            const Real calculatedX = m.collocationPointsX(maturities[i])[j];
            const Real expectedX = x[i][j];

            if (std::fabs(calculatedX - expectedX) > tol) {
                BOOST_FAIL("Failed to reproduce collocation x points for "
                           << "\n    time:       " << maturities[i]
                           << "\n    j           " << j
                           << "\n    calculated: " << calculatedX
                           << "\n    expected:   " << expectedX);
            }

            const Real calculatedS = m.collocationPointsY(maturities[i])[j];
            const Real expectedS = s[i][j];
            if (std::fabs(calculatedS - expectedS) > tol) {
                BOOST_FAIL("Failed to reproduce collocation s points for "
                           << "\n    time:       " << maturities[i]
                           << "\n    j           " << j
                           << "\n    calculated: " << calculatedS
                           << "\n    expected:   " << expectedS);
            }

            const Real expectation
                = ouProcess->expectation(0.0, ouProcess->x0(), t);
            const Real stdDeviation
                = ouProcess->stdDeviation(0.0, ouProcess->x0(), t);

            const Real calculatedG = g(t, expectation + stdDeviation*c[j]);
            if (std::fabs(calculatedG - expectedS) > tol) {
                BOOST_FAIL("Failed to reproduce g values "
                           "at collocation points for "
                           << "\n    time:       " << maturities[i]
                           << "\n    j           " << j
                           << "\n    calculated: " << calculatedG
                           << "\n    expected:   " << expectedS);
            }
        }
    }
}

namespace normal_clv_model_test {
    class CLVModelPayoff : public PlainVanillaPayoff {
      public:
        CLVModelPayoff(Option::Type type, Real strike, ext::function<Real(Real)> g)
        : PlainVanillaPayoff(type, strike), g_(std::move(g)) {}

        Real operator()(Real x) const override { return PlainVanillaPayoff::operator()(g_(x)); }

      private:
        const ext::function<Real(Real)> g_;
    };
}

void NormalCLVModelTest::testMonteCarloBSOptionPricing() {
    BOOST_TEST_MESSAGE("Testing Monte Carlo BS option pricing...");

    using namespace normal_clv_model_test;

    SavedSettings backup;

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(22, June, 2016);
    const Date maturity = today + Period(1, Years);
    const Time t = dc.yearFraction(today, maturity);

    const Real strike = 110;
    const ext::shared_ptr<StrikedTypePayoff> payoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Call, strike);
    const ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturity);

    // Ornstein-Uhlenbeck
    const Real speed = 2.3;
    const Real level = 100;
    const Real sigma = 0.35;
    const Real x0    = 100.0;

    const Real s0        = x0;
    const Volatility vol = 0.25;
    const Real rRate     = 0.10;
    const Real qRate     = 0.04;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));
    const Handle<YieldTermStructure> qTS(flatRate(today, qRate, dc));
    const Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));
    const Handle<BlackVolTermStructure> vTS(flatVol(today, vol, dc));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, vTS));

    const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess(
        ext::make_shared<OrnsteinUhlenbeckProcess>(
            speed, sigma, x0, level));

    std::vector<Date> maturities = { today + Period(6, Months), maturity };

    const NormalCLVModel m(bsProcess, ouProcess, maturities, 8);
    const ext::function<Real(Real, Real)> g = m.g();

    const Size nSims = 32767;
    const LowDiscrepancy::rsg_type ld
        = LowDiscrepancy::make_sequence_generator(1, 23455);

    Statistics stat;
    for (Size i=0; i < nSims; ++i) {
        const Real dw = ld.nextSequence().value.front();

        const Real o_t = ouProcess->evolve(0, x0, t, dw);
        const Real s = g(t, o_t);

        stat.add((*payoff)(s));

    }

    Real calculated = stat.mean() * rTS->discount(maturity);

    VanillaOption option(payoff, exercise);
    option.setPricingEngine(
        ext::make_shared<AnalyticEuropeanEngine>(bsProcess));
    const Real expected = option.NPV();

    const Real tol = 0.01;
    if (std::fabs(calculated - expected) > tol) {
        BOOST_FAIL("Failed to reproduce Monte-Carlo vanilla option price "
                   << "\n    time:       " << maturity
                   << "\n    strike:     " << strike
                   << "\n    calculated: " << calculated
                   << "\n    expected:   " << expected);
    }

    VanillaOption fdmOption(
         ext::make_shared<CLVModelPayoff>(payoff->optionType(), payoff->strike(),
                                          [&](Real _x) { return g(t, _x); }),
         exercise);

    fdmOption.setPricingEngine(
        ext::make_shared<FdOrnsteinUhlenbeckVanillaEngine>(
            ouProcess, rTS.currentLink(), 50, 800));

    calculated = fdmOption.NPV();
    if (std::fabs(calculated - expected) > tol) {
        BOOST_FAIL("Failed to reproduce FDM vanilla option price "
                   << "\n    time:       " << maturity
                   << "\n    strike:     " << strike
                   << "\n    calculated: " << calculated
                   << "\n    expected:   " << expected);
    }
}

void NormalCLVModelTest::testMoustacheGraph() {
    BOOST_TEST_MESSAGE(
        "Testing double no-touch pricing with normal CLV model...");

    SavedSettings backup;

    /*
     The comparison of Black-Scholes and normal CLV prices is derived
     from figure 8.8 in Iain J. Clark's book,
     Foreign Exchange Option Pricing: A Practitioners Guide
    */

    const DayCounter dc = ActualActual(ActualActual::ISDA);
    const Date todaysDate(5, Aug, 2016);
    const Date maturityDate = todaysDate + Period(1, Years);
    const Time maturityTime = dc.yearFraction(todaysDate, maturityDate);

    Settings::instance().evaluationDate() = todaysDate;

    const Real s0 = 100;
    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));
    const Rate r = 0.02;
    const Rate q = 0.01;

    // parameter of the "calibrated" Heston model
    const Real kappa =   1.0;
    const Real theta =   0.06;
    const Real rho   =  -0.8;
    const Real sigma =   0.8;
    const Real v0    =   0.09;

    const Handle<YieldTermStructure> rTS(flatRate(r, dc));
    const Handle<YieldTermStructure> qTS(flatRate(q, dc));

    const ext::shared_ptr<HestonModel> hestonModel(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                rTS, qTS, spot, v0, kappa, theta, sigma, rho)));

    const Handle<BlackVolTermStructure> vTS(
        ext::make_shared<HestonBlackVolSurface>(
            Handle<HestonModel>(hestonModel)));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess =
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, vTS);

    // Ornstein-Uhlenbeck
    const Real speed   = -0.80;
    const Real level   = 100;
    const Real sigmaOU = 0.15;
    const Real x0      = 100;

    const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess(
        ext::make_shared<OrnsteinUhlenbeckProcess>(
            speed, sigmaOU, x0, level));

    const ext::shared_ptr<Exercise> europeanExercise(
        ext::make_shared<EuropeanExercise>(maturityDate));

    VanillaOption vanillaOption(
        ext::make_shared<PlainVanillaPayoff>(Option::Call, s0),
        europeanExercise);

    vanillaOption.setPricingEngine(
        ext::make_shared<AnalyticHestonEngine>(hestonModel));

    const Volatility atmVol = vanillaOption.impliedVolatility(
        vanillaOption.NPV(),
        ext::make_shared<GeneralizedBlackScholesProcess>(spot, qTS, rTS,
            Handle<BlackVolTermStructure>(flatVol(std::sqrt(theta), dc))));

    const ext::shared_ptr<PricingEngine> analyticEngine(
        ext::make_shared<AnalyticDoubleBarrierBinaryEngine>(
            ext::make_shared<GeneralizedBlackScholesProcess>(
                spot, qTS, rTS,
                Handle<BlackVolTermStructure>(flatVol(atmVol, dc)))));


    std::vector<Date> maturities(1, todaysDate + Period(2, Weeks));
    while (maturities.back() < maturityDate)
        maturities.push_back(maturities.back() + Period(2, Weeks));

    const NormalCLVModel m(bsProcess, ouProcess, maturities, 8);
    const ext::function<Real(Real, Real)> g = m.g();

    const Size n = 18;
    Array barrier_lo(n), barrier_hi(n), bsNPV(n);

    const ext::shared_ptr<CashOrNothingPayoff> payoff =
        ext::make_shared<CashOrNothingPayoff>(Option::Call, 0.0, 1.0);

    for (Size i=0; i < n; ++i) {
        const Real dist = 10.0+5.0*i;

        barrier_lo[i] = std::max(s0 - dist, 1e-2);
        barrier_hi[i] = s0 + dist;
        DoubleBarrierOption doubleBarrier(
            DoubleBarrier::KnockOut, barrier_lo[i], barrier_hi[i], 0.0,
            payoff,
            europeanExercise);

        doubleBarrier.setPricingEngine(analyticEngine);
        bsNPV[i] = doubleBarrier.NPV();
    }

    typedef SobolBrownianBridgeRsg rsg_type;
    typedef PathGenerator<rsg_type>::sample_type sample_type;

    const Size factors = 1;
    const Size tSteps = 200;
    const TimeGrid grid(maturityTime, tSteps);

    const ext::shared_ptr<PathGenerator<rsg_type> > pathGenerator =
        ext::make_shared<PathGenerator<rsg_type> >(
            ouProcess, grid, rsg_type(factors, tSteps), false);

    const Size nSims = 100000;
    std::vector<GeneralStatistics> stats(n);
    const DiscountFactor df = rTS->discount(maturityDate);

    for (Size i=0; i < nSims; ++i) {
        std::vector<bool> touch(n, false);

        const sample_type& path = pathGenerator->next();

        Real s;
        for (Size j=1; j <= tSteps; ++j) {
            const Time t = grid.at(j);
            s = g(t, path.value.at(j));

            for (Size u=0; u < n; ++u) {
                if (s <= barrier_lo[u] || s >= barrier_hi[u]) {
                    touch[u] = true;
                }
            }
        }
        for (Size u=0; u < n; ++u) {
            if (touch[u]) {
                stats[u].add(0.0);
            }
            else {
                stats[u].add(df*(*payoff)(s));
            }
        }
    }

    const Real expected[] = {
            0.00931214, 0.0901481, 0.138982, 0.112059, 0.0595901,
            0.0167549, -0.00906787, -0.0206768, -0.0225628, -0.0203593,
            -0.016036, -0.0116629, -0.00728792, -0.00328821,
            -0.000158562, 0.00502041, 0.00347706, 0.00238216, };

    const Real tol = 1e-5;
    for (Size u=0; u < n; ++u) {
        const Real calculated = stats[u].mean() - bsNPV[u];

        if (std::fabs(calculated - expected[u]) > tol) {
            BOOST_FAIL("Failed to reproduce Double no Touch prices"
                   << "\n    time:          " << maturityDate
                   << "\n    barrier lower: " << barrier_lo[u]
                   << "\n    barrier high:  " << barrier_hi[u]
                   << "\n    calculated:    " << calculated
                   << "\n    expected:      " << expected[u]);
        }
    }
}

test_suite* NormalCLVModelTest::experimental(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("NormalCLVModel tests");

    suite->add(QUANTLIB_TEST_CASE(
        &NormalCLVModelTest::testBSCumlativeDistributionFunction));
    suite->add(QUANTLIB_TEST_CASE(
        &NormalCLVModelTest::testHestonCumlativeDistributionFunction));
    suite->add(QUANTLIB_TEST_CASE(
        &NormalCLVModelTest::testIllustrative1DExample));
    suite->add(QUANTLIB_TEST_CASE(
        &NormalCLVModelTest::testMonteCarloBSOptionPricing));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(
            &NormalCLVModelTest::testMoustacheGraph));
    }
    return suite;
}
]]></document_content>
  </document>
  <document index="199">
    <source>normalclvmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_normal_clv_model_hpp
#define quantlib_test_normal_clv_model_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

class NormalCLVModelTest {
   public:
    static void testBSCumlativeDistributionFunction();
    static void testHestonCumlativeDistributionFunction();
    static void testIllustrative1DExample();
    static void testMonteCarloBSOptionPricing();
    static void testMoustacheGraph();
    static boost::unit_test_framework::test_suite* experimental(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="200">
    <source>nthorderderivativeop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "nthorderderivativeop.hpp"
#include "utilities.hpp"

#include <ql/math/comparison.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/math/matrixutilities/bicgstab.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/math/richardsonextrapolation.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/nthorderderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>


#include <numeric>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#include <boost/numeric/ublas/banded.hpp>

#if defined(__clang__) || defined(__GNUC__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-local-typedef"
#endif

#include <boost/numeric/ublas/operation_sparse.hpp>

#if defined(__clang__) || defined(__GNUC__)
#pragma clang diagnostic pop
#endif

#include <boost/numeric/ublas/matrix_proxy.hpp>

void NthOrderDerivativeOpTest::testSparseMatrixApply() {
    BOOST_TEST_MESSAGE("Testing sparse matrix apply...");

    SparseMatrix sm(5,7);

    BOOST_CHECK(sm.size1() == SparseMatrix::size_type(5));
    BOOST_CHECK(sm.size2() == SparseMatrix::size_type(7));

    sm(1,3) = 3.0;

    const Array x(7,0.0,1.0);
    const Array y = prod(sm, x);

    BOOST_CHECK(close_enough(y[0], 0.0));
    BOOST_CHECK(close_enough(y[1], 3.0*3.0));
    BOOST_CHECK(close_enough(y[2], 0.0));
    BOOST_CHECK(close_enough(y[3], 0.0));
    BOOST_CHECK(close_enough(y[4], 0.0));
}

void NthOrderDerivativeOpTest::testFirstOrder2PointsApply() {
    BOOST_TEST_MESSAGE("Testing two points first order "
            "derivative operator apply on an uniform grid...");

    const Real dx = 1/5.0;

    const NthOrderDerivativeOp op(0, 1, 3,
        ext::make_shared<FdmMesherComposite>(
            ext::make_shared<Uniform1dMesher>(0.0, 1.0, 6)));

    const Array x(6,0.0, 1.0);
    const Array y = op.apply(x);

    for (Size i=0; i < x.size(); ++i)
        BOOST_CHECK(close_enough(y[i], 1/dx));
}

void NthOrderDerivativeOpTest::testFirstOrder3PointsOnUniformGrid() {
    BOOST_TEST_MESSAGE("Testing three points first order "
            "derivative operator on an uniform grid...");

    const Real ddx = 1.0/0.2;

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 1, 3,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Uniform1dMesher>(0.0, 1.0, 6))).toMatrix();

    // to reproduce the reference results use
    // http://web.media.mit.edu/~crtaylor/calculator.html

    BOOST_CHECK(close_enough(m(2,0), 0.0));
    BOOST_CHECK(close_enough(m(2,1), -0.5*ddx));
    BOOST_CHECK(m(2,2) < 42*QL_EPSILON);
    BOOST_CHECK(close_enough(m(2,3), 0.5*ddx));
    BOOST_CHECK(close_enough(m(2,4), 0.0));
    BOOST_CHECK(close_enough(m(2,5), 0.0));

    BOOST_CHECK(close_enough(m(0,0), -3.0/2.0*ddx));
    BOOST_CHECK(close_enough(m(0,1), 2.0*ddx));
    BOOST_CHECK(close_enough(m(0,2), -0.5*ddx));
    BOOST_CHECK(close_enough(m(0,3), 0.0));
    BOOST_CHECK(close_enough(m(0,4), 0.0));
    BOOST_CHECK(close_enough(m(0,5), 0.0));

    BOOST_CHECK(close_enough(m(5,0), 0.0));
    BOOST_CHECK(close_enough(m(5,1), 0.0));
    BOOST_CHECK(close_enough(m(5,2), 0.0));
    BOOST_CHECK(close_enough(m(5,3), 0.5*ddx));
    BOOST_CHECK(close_enough(m(5,4), -2.0*ddx));
    BOOST_CHECK(close_enough(m(5,5), 3.0/2.0*ddx));
}

void NthOrderDerivativeOpTest::testFirstOrder5PointsOnUniformGrid() {
    BOOST_TEST_MESSAGE("Testing five points first order "
            "derivative operator on an uniform grid...");

    const Real ddx = 1.0/0.4;

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 1, 5,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Uniform1dMesher>(0.0, 2.0, 6))).toMatrix();

    BOOST_CHECK(close_enough(m(2,0), 1.0/12.0*ddx));
    BOOST_CHECK(close_enough(m(2,1), -2.0/3.0*ddx));
    BOOST_CHECK(m(2,2) < 42*QL_EPSILON);
    BOOST_CHECK(close_enough(m(2,3), 2.0/3.0*ddx));
    BOOST_CHECK(close_enough(m(2,4), -1.0/12.0*ddx));
    BOOST_CHECK(close_enough(m(2,5), 0.0));

    BOOST_CHECK(close_enough(m(0,0), -25.0/12.0*ddx));
    BOOST_CHECK(close_enough(m(0,1), 4.0*ddx));
    BOOST_CHECK(close_enough(m(0,2), -3.0*ddx));
    BOOST_CHECK(close_enough(m(0,3), 4.0/3.0*ddx));
    BOOST_CHECK(close_enough(m(0,4), -0.25*ddx));
    BOOST_CHECK(close_enough(m(0,5), 0.0));

    BOOST_CHECK(close_enough(m(1,0), -0.25*ddx));
    BOOST_CHECK(close_enough(m(1,1), -5.0/6.0*ddx));
    BOOST_CHECK(close_enough(m(1,2), 3.0/2.0*ddx));
    BOOST_CHECK(close_enough(m(1,3), -0.5*ddx));
    BOOST_CHECK(close_enough(m(1,4), 1.0/12.0*ddx));
    BOOST_CHECK(close_enough(m(1,5), 0.0));

    BOOST_CHECK(close_enough(m(4,5), 0.25*ddx));
    BOOST_CHECK(close_enough(m(4,4), 5.0/6.0*ddx));
    BOOST_CHECK(close_enough(m(4,3), -3.0/2.0*ddx));
    BOOST_CHECK(close_enough(m(4,2), 0.5*ddx));
    BOOST_CHECK(close_enough(m(4,1), -1.0/12.0*ddx));
    BOOST_CHECK(close_enough(m(4,0), 0.0));

    BOOST_CHECK(close_enough(m(5,0), 0.0));
    BOOST_CHECK(close_enough(m(5,1), 0.25*ddx));
    BOOST_CHECK(close_enough(m(5,2), -4.0/3.0*ddx));
    BOOST_CHECK(close_enough(m(5,3), 3.0*ddx));
    BOOST_CHECK(close_enough(m(5,4), -4.0*ddx));
    BOOST_CHECK(close_enough(m(5,5), 25.0/12.0*ddx));
}

void NthOrderDerivativeOpTest::testFirstOrder2PointsOnUniformGrid() {
    BOOST_TEST_MESSAGE("Testing two points first order "
            "derivative operator on an uniform grid...");

    const Real ddx = 1.0/0.2;

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 1, 2,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Uniform1dMesher>(0.0, 0.6, 4))).toMatrix();

    BOOST_CHECK(close_enough(m(0,0), -ddx));
    BOOST_CHECK(close_enough(m(0,1), ddx));
    BOOST_CHECK(close_enough(m(0,2), 0.0));
    BOOST_CHECK(close_enough(m(0,3), 0.0));

    BOOST_CHECK(close_enough(m(1,0), -ddx));
    BOOST_CHECK(close_enough(m(1,1), ddx));
    BOOST_CHECK(close_enough(m(1,2), 0.0));
    BOOST_CHECK(close_enough(m(1,3), 0.0));

    BOOST_CHECK(close_enough(m(2,0), 0.0));
    BOOST_CHECK(close_enough(m(2,1), -ddx));
    BOOST_CHECK(close_enough(m(2,2), ddx));
    BOOST_CHECK(close_enough(m(2,3), 0.0));

    BOOST_CHECK(close_enough(m(3,0), 0.0));
    BOOST_CHECK(close_enough(m(3,1), 0.0));
    BOOST_CHECK(close_enough(m(3,2), -ddx));
    BOOST_CHECK(close_enough(m(3,3), ddx));
}

void NthOrderDerivativeOpTest::testFirstOrder4PointsOnUniformGrid() {
    BOOST_TEST_MESSAGE("Testing four points first order "
            "derivative operator on an uniform grid...");

    const Real ddx = 1.0/0.2;

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 1, 4,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Uniform1dMesher>(0.0, 0.6, 4))).toMatrix();

    BOOST_CHECK(close_enough(m(0,0), -11.0/6.0*ddx));
    BOOST_CHECK(close_enough(m(0,1), 3.0*ddx));
    BOOST_CHECK(close_enough(m(0,2), -1.5*ddx));
    BOOST_CHECK(close_enough(m(2,3), 1.0/3.0*ddx));

    BOOST_CHECK(close_enough(m(1,0), -1.0/3.0*ddx));
    BOOST_CHECK(close_enough(m(1,1), -0.5*ddx));
    BOOST_CHECK(close_enough(m(1,2), ddx));
    BOOST_CHECK(close_enough(m(1,3), -1.0/6.0*ddx));

    BOOST_CHECK(close_enough(m(2,0), 1.0/6.0*ddx));
    BOOST_CHECK(close_enough(m(2,1), -ddx));
    BOOST_CHECK(close_enough(m(2,2), 0.5*ddx));
    BOOST_CHECK(close_enough(m(2,3), 1.0/3.0*ddx));

    BOOST_CHECK(close_enough(m(3,0), -1.0/3.0*ddx));
    BOOST_CHECK(close_enough(m(3,1), 1.5*ddx));
    BOOST_CHECK(close_enough(m(3,2), -3.0*ddx));
    BOOST_CHECK(close_enough(m(3,3), 11.0/6.0*ddx));
}

void NthOrderDerivativeOpTest::testFirstOrder2PointsOn2DimUniformGrid() {
    BOOST_TEST_MESSAGE("Testing two points first order "
            "derivative operator on a 2 dimensional uniform grid...");

    const Real ddx = 1.0/0.2;

    const Size xGrid=4;
    const ext::shared_ptr<FdmMesher> mesher =
        ext::make_shared<FdmMesherComposite>(
            ext::make_shared<Uniform1dMesher>(0.0, 1, xGrid),
            ext::make_shared<Uniform1dMesher>(0.0, 0.4, 3));

    const SparseMatrix m = NthOrderDerivativeOp(1, 1, 2, mesher).toMatrix();

    const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
    const FdmLinearOpIterator endIter = layout->end();

    for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
        const Size i = iter.index();
        const Size ix = iter.coordinates()[1];

        switch (ix) {
          case 0:
            BOOST_CHECK(close_enough(m(i, i        ),-ddx));
            BOOST_CHECK(close_enough(m(i, i+  xGrid), ddx));
            BOOST_CHECK(close_enough(m(i, i+2*xGrid), 0.0));
            break;
          case 1:
            BOOST_CHECK(close_enough(m(i, i-  xGrid),-ddx));
            BOOST_CHECK(close_enough(m(i, i        ), ddx));
            BOOST_CHECK(close_enough(m(i, i+2*xGrid), 0.0));
            break;
          case 2:
            BOOST_CHECK(close_enough(m(i, i-2*xGrid), 0.0));
            BOOST_CHECK(close_enough(m(i, i-  xGrid),-ddx));
            BOOST_CHECK(close_enough(m(i, i        ), ddx));
            break;
          default:
            QL_FAIL("inconsistent coordinate");
        }
    }
}

void NthOrderDerivativeOpTest::testSecondOrder3PointsNonUniformGrid() {
    BOOST_TEST_MESSAGE("Testing three points second order "
            "derivative operator on a non-uniform grid...");

    std::vector<Real> xValues(4);
    xValues[0] = 0.5;
    xValues[1] = 1.0;
    xValues[2] = 2.0;
    xValues[3] = 4.0;

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 2, 3,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Predefined1dMesher>(xValues))).toMatrix();

    BOOST_CHECK(close_enough(m(0,0), 8.0/3.0));
    BOOST_CHECK(close_enough(m(0,1), -4.0));
    BOOST_CHECK(close_enough(m(0,2), 4.0/3.0));
    BOOST_CHECK(close_enough(m(0,3), 0.0));

    BOOST_CHECK(close_enough(m(1,0), 8.0/3.0));
    BOOST_CHECK(close_enough(m(1,1), -4.0));
    BOOST_CHECK(close_enough(m(1,2), 4.0/3.0));
    BOOST_CHECK(close_enough(m(1,3), 0.0));

    BOOST_CHECK(close_enough(m(2,0), 0.0));
    BOOST_CHECK(close_enough(m(2,1), 2.0/3.0));
    BOOST_CHECK(close_enough(m(2,2), -1.0));
    BOOST_CHECK(close_enough(m(2,3), 1.0/3.0));

    BOOST_CHECK(close_enough(m(3,0), 0.0));
    BOOST_CHECK(close_enough(m(3,1), 2.0/3.0));
    BOOST_CHECK(close_enough(m(3,2), -1.0));
    BOOST_CHECK(close_enough(m(3,3), 1.0/3.0));
}

void NthOrderDerivativeOpTest::testSecondOrder4PointsNonUniformGrid() {
    BOOST_TEST_MESSAGE("Testing four points second order "
            "derivative operator on a non-uniform grid...");

    std::vector<Real> xValues(5);
    xValues[0] = 0.5;
    xValues[1] = 1.0;
    xValues[2] = 2.0;
    xValues[3] = 4.0;
    xValues[4] = 8.0;

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 2, 4,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Predefined1dMesher>(xValues))).toMatrix();

    BOOST_CHECK(close_enough(m(0,0), 88.0/21.0));
    BOOST_CHECK(close_enough(m(0,1), -140.0/21.0));
    BOOST_CHECK(close_enough(m(0,2), 56.0/21.0));
    BOOST_CHECK(close_enough(m(0,3), -4.0/21.0));
    BOOST_CHECK(close_enough(m(0,4), 0.0));

    BOOST_CHECK(close_enough(m(1,0), 64.0/21.0));
    BOOST_CHECK(close_enough(m(1,1), -98.0/21.0));
    BOOST_CHECK(close_enough(m(1,2), 35.0/21.0));
    BOOST_CHECK(close_enough(m(1,3), -1.0/21.0));
    BOOST_CHECK(close_enough(m(1,4), 0.0));

    BOOST_CHECK(close_enough(m(2,0), 16.0/21.0));
    BOOST_CHECK(close_enough(m(2,1), -2.0/3.0));
    BOOST_CHECK(close_enough(m(2,2), -1.0/3.0));
    BOOST_CHECK(close_enough(m(2,3), 5.0/21.0));
    BOOST_CHECK(close_enough(m(2,4), 0.0));

    BOOST_CHECK(close_enough(m(3,0), 0.0));
    BOOST_CHECK(close_enough(m(3,1), 4.0/21.0));
    BOOST_CHECK(close_enough(m(3,2), -1.0/6.0));
    BOOST_CHECK(close_enough(m(3,3), -1.0/12.0));
    BOOST_CHECK(close_enough(m(3,4), 5.0/84.0));

    BOOST_CHECK(close_enough(m(4,0), 0.0));
    BOOST_CHECK(close_enough(m(4,1), -20.0/21.0));
    BOOST_CHECK(close_enough(m(4,2), 11.0/6.0));
    BOOST_CHECK(close_enough(m(4,3), -13.0/12.0));
    BOOST_CHECK(close_enough(m(4,4), 17.0/84.0));
}

void NthOrderDerivativeOpTest::testThirdOrder4PointsUniformGrid() {
    BOOST_TEST_MESSAGE("Testing four points third order "
            "derivative operator on a uniform grid...");

    const SparseMatrix m =
        NthOrderDerivativeOp(0, 3, 4,
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Uniform1dMesher>(0.0, 0.6, 4))).toMatrix();

    for (Size i=0; i < 4; ++i) {
        BOOST_CHECK(close_enough(m(i,0), -125.0));
        BOOST_CHECK(close_enough(m(i,1), 375.0));
        BOOST_CHECK(close_enough(m(i,2), -375.0));
        BOOST_CHECK(close_enough(m(i,3), 125));
    }
}


namespace {
    struct GridSetup {
        Real alpha;
        Real density;
        bool cellAvg;
        bool midPoint;
        Size nPoints;
        Size tGrid;
        Size yGrid;
        Size vGrid;
        FdmSchemeDesc scheme;
    };

    class FdmHestonNthOrderOp : public FdmLinearOpComposite {
      public:
        FdmHestonNthOrderOp(Size nPoints,
                            const ext::shared_ptr<HestonProcess>& hestonProcess,
                            const ext::shared_ptr<FdmMesher>& mesher,
                            Size direction = 0)
        : vol2_(0.5 * hestonProcess->theta()),
          preconditioner_(
              SecondDerivativeOp(direction, mesher).mult(Array(mesher->layout()->size(), vol2_))) {

            const Array vv(mesher->locations(1));
            Array varianceValues(0.5*vv);

            ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
            FdmLinearOpIterator endIter = layout->end();
            for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
                ++iter) {
                if (   iter.coordinates()[0] == 0
                    || iter.coordinates()[0] == layout->dim()[0]-1) {
                    varianceValues[iter.index()] = 0.0;
                }
            }
            const Size n = mesher->layout()->size();

            using namespace boost::numeric::ublas;
            banded_matrix<Real> v(n, n), u(n, n), rV(n, n);
            for (Size i=0; i < n; ++i) {
                v(i, i) = varianceValues[i];
                u(i, i) = vv[i];
                rV(i, i) = varianceValues[i] - 0.5*hestonProcess->theta();
            }

            const SparseMatrix dx = NthOrderDerivativeOp(0, 1, nPoints, mesher).toMatrix();
            const SparseMatrix dxx = NthOrderDerivativeOp(0, 2, nPoints, mesher).toMatrix();
            const SparseMatrix dv = NthOrderDerivativeOp(1, 1, nPoints, mesher).toMatrix();
            const SparseMatrix dvv = NthOrderDerivativeOp(1, 2, nPoints, mesher).toMatrix();

            const Real kappa = hestonProcess->kappa();
            const Real theta = hestonProcess->theta();
            const Real sigma = hestonProcess->sigma();
            const Real rho = hestonProcess->rho();

            map_ = sparse_prod<SparseMatrix>(-rV, dx)
                + sparse_prod<SparseMatrix>(v, dxx)
                + (0.5*rho*sigma)*sparse_prod<SparseMatrix>(
                    u, sparse_prod<SparseMatrix>(dx, dv)
                        + sparse_prod<SparseMatrix>(dv, dx))
                + (0.5*sigma*sigma)*sparse_prod<SparseMatrix>(u, dvv)
                + kappa*sparse_prod<SparseMatrix>(
                    theta*identity_matrix<Real>(n) - u, dv);
        }

        Disposable<SparseMatrix> toMatrix() const override {
            SparseMatrix tmp(map_);
            return tmp;
        }

        Size size() const override { return 2; }
        void setTime(Time t1, Time t2) override { }

        Disposable<Array> apply(const Array& r) const override {
            return prod(map_, r);
        }

        Disposable<Array> apply_mixed(const Array& r) const override {
            QL_FAIL("operator splitting is not supported");
        }

        Disposable<Array> apply_direction(
            Size direction, const Array& r) const override {
            QL_FAIL("operator splitting is not supported");
        }

        Disposable<Array> solve_splitting(
            Size direction, const Array& r, Real dt) const override {
            QL_FAIL("operator splitting is not supported");
        }

        Disposable<Array> preconditioner(const Array& r, Real dt) const override {
            return preconditioner_.solve_splitting(r, dt, 1.0);
        }

      private:
        Disposable<Array> solve_apply(const Array& r, Real dt) const {
            return r - dt*apply(r);
        }

        const Volatility vol2_;
        SparseMatrix map_;
        TripleBandLinearOp preconditioner_;
    };


    class AvgPayoffFct {
      public:
        AvgPayoffFct(ext::shared_ptr<PlainVanillaPayoff> payoff,
                     Volatility vol, Time T, Real growthFactor)
        : payoff_(std::move(payoff)),
          vol2_(0.5*vol*vol*T),
          growthFactor_(growthFactor) { }

        Real operator()(Real x) const {
            return (*payoff_)(std::exp(x - vol2_)*growthFactor_);
        }

       private:
        const ext::shared_ptr<PlainVanillaPayoff> payoff_;
        const Volatility vol2_;
        const Real growthFactor_;
    };

   class MyInnerValueCalculator : public FdmInnerValueCalculator {
      public:
        MyInnerValueCalculator(ext::shared_ptr<Payoff> payoff,
                               ext::shared_ptr<FdmMesher> mesher,
                               ext::shared_ptr<YieldTermStructure> rTS,
                               ext::shared_ptr<YieldTermStructure> qTS,
                               Volatility vol,
                               Size direction)
        : payoff_(std::move(std::move(payoff))), mesher_(std::move(std::move(mesher))),
          rTS_(std::move(std::move(rTS))), qTS_(std::move(std::move(qTS))), vol_(vol),
          direction_(direction) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t)  override {
            const Real g = mesher_->location(iter, direction_);
            const Real sT = std::exp(g - 0.5*vol_*vol_*t);

            return (*payoff_)(sT);
        }

        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> rTS_, qTS_;
        const Volatility vol_;
        const Size direction_;
    };

    Disposable<Array> priceReport(
        const GridSetup& setup, const Array& strikes) {

        const Date today(2, May, 2018);
        const DayCounter dc = Actual365Fixed();
        const Date maturity = today + Period(1, Years);
        const Time T = dc.yearFraction(today, maturity);

        const ext::shared_ptr<YieldTermStructure> rTS
            = flatRate(today, 0.05, dc);
        const ext::shared_ptr<YieldTermStructure> qTS
            = flatRate(today, 0.0, dc);

        const Real S = 100.0;
        const Volatility vol = 0.2;
        const Real v0 = vol*vol;
        const Real kappa = 1.0;
        const Real theta = vol*vol;
        const Real sig = 0.2;
        const Real rho = -0.75;

        const ext::shared_ptr<HestonProcess> hestonProcess
            = ext::make_shared<HestonProcess>(
                  Handle<YieldTermStructure>(rTS),
                  Handle<YieldTermStructure>(qTS),
                  Handle<Quote>(ext::make_shared<SimpleQuote>(S)),
                  v0, kappa, theta, sig, rho);

        const Real stdDev = vol * std::sqrt(T);
        const DiscountFactor df
            = qTS->discount(maturity)/rTS->discount(maturity);

        const Real y = std::log(S);

        const Real ymin = y - setup.alpha*stdDev;
        const Real ymax = y + setup.alpha*stdDev;

        const Size yGrid = setup.yGrid;
        const Size vGrid = setup.vGrid;

        Array diffs(strikes.size()), fdmPrices(strikes.size());
        for (Size k=0; k < strikes.size(); ++k) {
            const Real strike = strikes[k];
            const Real specialPoint = std::log(strike/df) + 0.5*vol*vol*T;

            const ext::shared_ptr<Fdm1dMesher> mesher1d =
                ext::make_shared<Concentrating1dMesher>(
                    ymin, ymax, yGrid,
                    std::pair<Real, Real>(specialPoint, setup.density));

            std::vector<Real> loc = mesher1d->locations();
            for (Size i = 0; setup.midPoint && i < loc.size()-1; ++i)
                if (loc[i] < specialPoint && loc[i+1]>= specialPoint) {
                    const Real d = loc[i+1] - loc[i];

                    const Real offset = (specialPoint - 0.5*d) - loc[i];

                    for (double& l : loc)
                        l += offset;

                    break;
                }

            const ext::shared_ptr<FdmMesherComposite> mesher =
                ext::make_shared<FdmMesherComposite>(
                    ext::make_shared<Predefined1dMesher>(loc),
                    ext::make_shared<FdmHestonVarianceMesher>(
                        vGrid, hestonProcess, 1.0)
            );

            const Array g = mesher->locations(0);
            const Array sT = Exp(g - 0.5*vol*vol*T)*df;

            Array rhs(mesher->layout()->size());

            const ext::shared_ptr<PlainVanillaPayoff> payoff =
                ext::make_shared<PlainVanillaPayoff>(Option::Put, strike);

            const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
            const FdmLinearOpIterator endIter = layout->end();

            for (FdmLinearOpIterator iter = layout->begin();
                 iter!=endIter; ++iter) {
                const Size idx = iter.index();
                const Size idxm1 = layout->neighbourhood(iter,  0,-1);
                const Size idxp1 = layout->neighbourhood(iter,  0, 1);

                const Size nx = iter.coordinates()[0];

                if (nx != 0 && nx != yGrid-1
                    && setup.cellAvg && (
                        (sT[idx] < strike && sT[idxp1] >= strike)
                     || (sT[idxm1] < strike && sT[idx] >= strike))) {

                    const Real gMin = 0.5*(g[idxm1] + g[idx]);
                    const Real gMax = 0.5*(g[idxp1] + g[idx]);

                    const AvgPayoffFct f(payoff, vol, T, df);

                    rhs[idx] = GaussLobattoIntegral(1000, 1e-12)(
                        f, gMin, gMax)/(gMax - gMin);
                }
                else
                    rhs[idx] = (*payoff)(sT[idx]);
            }

            const ext::shared_ptr<FdmHestonNthOrderOp> heatEqn =
                ext::make_shared<FdmHestonNthOrderOp>(
                    setup.nPoints, hestonProcess, mesher);

            FdmBackwardSolver solver(
              heatEqn,
              FdmBoundaryConditionSet(),
              ext::shared_ptr<FdmStepConditionComposite>(),
              setup.scheme);

            solver.rollback(rhs, T, 0.0, setup.tGrid, 1);

            rhs *= rTS->discount(maturity);

            const std::vector<Real>& x =
                mesher->getFdm1dMeshers()[0]->locations();
            const std::vector<Real>& v =
                mesher->getFdm1dMeshers()[1]->locations();

            Matrix resultValues_(layout->dim()[1], layout->dim()[0]);
            std::copy(rhs.begin(), rhs.end(), resultValues_.begin());

            const ext::shared_ptr<BicubicSpline> interpolation =
                ext::make_shared<BicubicSpline>(
                    x.begin(), x.end(), v.begin(), v.end(), resultValues_);

            const Real fdmPrice = (*interpolation)(y, hestonProcess->v0());

            VanillaOption option(
                ext::make_shared<PlainVanillaPayoff>(Option::Put, strike),
                ext::make_shared<EuropeanExercise>(maturity)
            );
            option.setPricingEngine(
                ext::make_shared<AnalyticHestonEngine>(
                    ext::make_shared<HestonModel>(hestonProcess), 192)
            );
            const Real npv = option.NPV();

            diffs[k] = npv - fdmPrice;
        }

        return diffs;
    }

    class FdmMispricingCostFunction : public CostFunction {
      public:
        FdmMispricingCostFunction(
            const GridSetup& setup, Array strikes)
        : setup_(setup), strikes_(std::move(strikes)) { }

        Disposable<Array> values(const Array& x) const override {
            const GridSetup g = {
                x[0], x[1],
                setup_.cellAvg, setup_.midPoint,
                setup_.nPoints,
                setup_.tGrid, setup_.yGrid, setup_.vGrid,
                setup_.scheme
            };

            try {
                return priceReport(g, strikes_);
            }
            catch (std::exception const&) {
                Array q(2, 1000);
                return q;
            }
        }

      private:
        const GridSetup setup_;
        const Array strikes_;
    };
}

void NthOrderDerivativeOpTest::testHigherOrderHestonOptionPricing() {
    BOOST_TEST_MESSAGE("Testing Heston model option pricing convergence with "
            "higher order finite difference operators...");

    SavedSettings backup;

    const Array strikes = {50, 75, 90, 100, 110, 125, 150, 200};

    const GridSetup initSetup = {
        3.87773, 0.043847, true, false,
        5, 21, 20, 11, FdmSchemeDesc::CrankNicolson()
    };

    const Array initialValues = {initSetup.alpha, initSetup.density};

    FdmMispricingCostFunction costFct(initSetup, strikes);
    NoConstraint noConstraint;

    Problem prob(costFct, noConstraint, initialValues);

    LevenbergMarquardt().minimize(
        prob, EndCriteria(400, 40, 1.0e-4, 1.0e-4, 1.0e-4));

    const GridSetup optimalSetup = {
        prob.currentValue()[0], prob.currentValue()[1],
        initSetup.cellAvg, initSetup.midPoint,
        initSetup.nPoints,
        initSetup.tGrid,
        initSetup.yGrid/2,
        initSetup.vGrid,
        initSetup.scheme
    };

    const Array q = priceReport(optimalSetup, strikes);
    const Real ac = std::sqrt(DotProduct(q, q)/q.size());

    const Array p = priceReport(initSetup, strikes);
    const Real ap = std::sqrt(DotProduct(p, p)/p.size());

    const Real convergence = std::log(ac/ap)*M_LOG2E;

    if (convergence < 3.6) {
        BOOST_ERROR("convergence order is too low"
                << "\n expected convergence: 4.0"
                << "\n measured convergence: " << convergence
                << "\n tolerance           : 0.4");
    }
}


namespace {
    Real priceQuality(Real h) {

        const Array strikes = {100};

        const Size yGrid = Size(1/h);
        const GridSetup setup = {
              5.50966, 0.0130581,
             true, false,
             5, 401, yGrid, 21,
             FdmSchemeDesc::CrankNicolson()
        };

        return  std::fabs(priceReport(setup, strikes)[0]);
    }
}

void NthOrderDerivativeOpTest::testHigherOrderAndRichardsonExtrapolation() {
    BOOST_TEST_MESSAGE(
            "Testing Heston option pricing convergence with "
            "higher order FDM operators and Richardson Extrapolation...");

    SavedSettings backup;

    const Real n1 = priceQuality(1.0/25);
    const Real n3
        = std::fabs(RichardsonExtrapolation(priceQuality, 1.0/25, 4.0)(2.0));

    const Real r2 = std::log(n1/n3)*M_LOG2E;

    if (r2 < 4.9) {
        BOOST_ERROR("convergence order is too low using Richardson extrapolation"
                << "\n expected convergence: 5.0"
                << "\n measured convergence: " << r2
                << "\n tolerance           : 0.1");
    }
}

void NthOrderDerivativeOpTest::testCompareFirstDerivativeOpNonUniformGrid() {
    BOOST_TEST_MESSAGE(
        "Testing with FirstDerivativeOp on a non-uniform grid...");

    Array xValues = Exp(Array(7, 0, 0.1));

    const ext::shared_ptr<Fdm1dMesher> m
        = ext::make_shared<Predefined1dMesher>(
            std::vector<Real>(xValues.begin(), xValues.end()));

    const ext::shared_ptr<FdmMesher> m1d(
        ext::make_shared<FdmMesherComposite>(m));

    const ext::shared_ptr<FirstDerivativeOp> fx
        = ext::make_shared<FirstDerivativeOp>(0, m1d);

    const ext::shared_ptr<NthOrderDerivativeOp> dx
        = ext::make_shared<NthOrderDerivativeOp>(0, 1, 3, m1d);

    const SparseMatrix fm = fx->toMatrix();
    const SparseMatrix dm = dx->toMatrix();

    for (Size i=1; i < m->size()-1; ++i) // different boundary conditions
        for (Size j=0; j < m->size(); ++j)
            BOOST_CHECK(std::fabs(fm(i, j)- dm(i, j)) < 1e-12);
}

void NthOrderDerivativeOpTest::testCompareFirstDerivativeOp2dUniformGrid() {
    BOOST_TEST_MESSAGE(
        "Testing with FirstDerivativeOp on a 2d uniform grid...");

    const ext::shared_ptr<Fdm1dMesher> m1
        = ext::make_shared<Uniform1dMesher>(0.0, 0.6, 5);
    const ext::shared_ptr<Fdm1dMesher> m2
        = ext::make_shared<Uniform1dMesher>(0.0, 1.6, 6);

    const ext::shared_ptr<FdmMesher> mc(
        ext::make_shared<FdmMesherComposite>(m1, m2));

    const ext::shared_ptr<FdmLinearOpLayout> layout = mc->layout();

    const Size n = layout->dim()[0];
    const Size m = layout->dim()[1];

    SparseMatrix fm = FirstDerivativeOp(0, mc).toMatrix();
    SparseMatrix dm = NthOrderDerivativeOp(0, 1, 3, mc).toMatrix();

    for (Size k=0; k < m; ++k) {
        const Size idx = k*n;
        for (Size i=1; i < n-1; ++i)
            for (Size j=0; j < n*m; ++j)
                BOOST_CHECK(std::fabs(fm(idx + i, j) - dm(idx + i, j)) < 1e-12);
    }

    fm = FirstDerivativeOp(1, mc).toMatrix();
    dm = NthOrderDerivativeOp(1, 1, 3, mc).toMatrix();

    for (Size i=n; i < n*(m-1); ++i)
        for (Size j=0; j < n*m; ++j)
            BOOST_CHECK(std::fabs(fm(i, j) - dm(i, j)) < 1e-12);
}

void NthOrderDerivativeOpTest::testMixedSecondOrder9PointsOnUniformGrid() {
    BOOST_TEST_MESSAGE(
            "Testing nine points mixed second order "
            "derivative operator on a uniform grid...");

    const ext::shared_ptr<Fdm1dMesher> m
        = ext::make_shared<Uniform1dMesher>(0.0, 0.6, 5);

    const ext::shared_ptr<FdmMesher> mc(
        ext::make_shared<FdmMesherComposite>(m, m));

    const SparseMatrix cc =
            prod(NthOrderDerivativeOp(0, 1, 3, mc).toMatrix(),
                 NthOrderDerivativeOp(1, 1, 3, mc).toMatrix());

    const SparseMatrix mm = SecondOrderMixedDerivativeOp(0,1,mc).toMatrix();

    const Size n = m->size();

    for (Size i=1; i < n-1; ++i)
        for (Size j=1; j < n-1; ++j) {
            const Size idx = i*n+j;
            for (Size k=1; k < n-1; ++k)
                for (Size l=1; l < n-1; ++l) {
                    const Size kdx = k*n+l;
                    BOOST_CHECK(std::fabs(mm(idx,kdx) - cc(idx,kdx)) < 1e-12);
                }
        }
}


test_suite* NthOrderDerivativeOpTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("NthOrderDerivativeOp tests");

    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testSparseMatrixApply));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testFirstOrder2PointsApply));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testFirstOrder3PointsOnUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testFirstOrder5PointsOnUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testFirstOrder2PointsOnUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testFirstOrder4PointsOnUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testFirstOrder2PointsOn2DimUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testSecondOrder3PointsNonUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testSecondOrder4PointsNonUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testThirdOrder4PointsUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testHigherOrderAndRichardsonExtrapolation));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testCompareFirstDerivativeOpNonUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testCompareFirstDerivativeOp2dUniformGrid));
    suite->add(QUANTLIB_TEST_CASE(
        &NthOrderDerivativeOpTest::testMixedSecondOrder9PointsOnUniformGrid));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&NthOrderDerivativeOpTest::testHigherOrderHestonOptionPricing));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="201">
    <source>nthorderderivativeop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_nth_order_derivative_op_hpp
#define quantlib_test_nth_order_derivative_op_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

class NthOrderDerivativeOpTest {
   public:
    static void testSparseMatrixApply();
    static void testFirstOrder2PointsApply();
    static void testFirstOrder3PointsOnUniformGrid();
    static void testFirstOrder5PointsOnUniformGrid();
    static void testFirstOrder2PointsOnUniformGrid();
    static void testFirstOrder4PointsOnUniformGrid();
    static void testFirstOrder2PointsOn2DimUniformGrid();
    static void testSecondOrder3PointsNonUniformGrid();
    static void testSecondOrder4PointsNonUniformGrid();
    static void testThirdOrder4PointsUniformGrid();
    static void testHigherOrderHestonOptionPricing();
    static void testHigherOrderAndRichardsonExtrapolation();
    static void testCompareFirstDerivativeOpNonUniformGrid();
    static void testCompareFirstDerivativeOp2dUniformGrid();
    static void testMixedSecondOrder9PointsOnUniformGrid();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="202">
    <source>nthtodefault.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "nthtodefault.hpp"
#include "utilities.hpp"
#include <ql/experimental/credit/nthtodefault.hpp>
#include <ql/experimental/credit/constantlosslatentmodel.hpp>
#include <ql/experimental/credit/randomdefaultlatentmodel.hpp>
#include <ql/experimental/credit/integralntdengine.hpp>
#include <ql/experimental/credit/pool.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/pricingengines/credit/integralcdsengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/currencies/europe.hpp>
#include <iostream>
#include <string>

using namespace QuantLib;
using namespace std;
using namespace boost::unit_test_framework;

#ifndef QL_PATCH_SOLARIS

namespace nth_to_default_test {

    struct hwDatum {
        Size rank;
        Real spread[3];
    };

    /* Spread (bp p.a.) to buy protection for the nth to default from
       a basket of 10 names. All pairs have same correlation, 0 in
       column 2, 0.3 in column 3, 0.6 in column 4. Default intensity
       for all names is constant at 0.01, maturity 5 years, equal
       notional amounts.
    */
    hwDatum hwData[] = {
        { 1, { 603, 440, 293 } },
        { 2, {  98, 139, 137 } },
        { 3, {  12,  53,  79 } },
        { 4, {   1,  21,  49 } },
        { 5, {   0,   8,  31 } },
        { 6, {   0,   3,  19 } },
        { 7, {   0,   1,  12 } },
        { 8, {   0,   0,   7 } },
        { 9, {   0,   0,   3 } },
        {10, {   0,   0,   1 } }
    };


    Real hwCorrelation[] = { 0.0, 0.3, 0.6 };


    struct hwDatumDist {
        Size rank;
        Real spread[4];
    };

    // HW Table 3, Nth to Default Basket
    // corr = 0.3
    // NM/NZ
    // rank inf/inf 5/inf inf/5 5/5
    hwDatumDist hwDataDist[] = {
        { 1, { 440, 419, 474, 455 } },
        { 2, { 139, 127, 127, 116 } },
        { 3, {  53,  51,  44,  44 } },
        { 4, {  21,  24,  18,  22 } },
        { 5, {   8,  13,   7,  13 } },
        { 6, {   3,   8,   3,   8 } },
        { 7, {   1,   5,   1,   5 } },
        { 8, {   0,   3,   0,   4 } },
        { 9, {   0,   2,   0,   2 } },
        {10, {   0,   1,   0,   1 } }
    };

}

#endif

void NthToDefaultTest::testGauss() {
    #ifndef QL_PATCH_SOLARIS
    BOOST_TEST_MESSAGE("Testing nth-to-default against Hull-White values "
                       "with Gaussian copula...");

    using namespace nth_to_default_test;

    SavedSettings backup;

    /*************************
     * Tolerances
     */
    Real relTolerance = 0.015; // relative difference
    Real absTolerance = 1; // absolute difference in bp

    Period timeUnit = 1*Weeks; // required to reach accuracy

    Size names = 10;
    QL_REQUIRE (LENGTH(hwData) == names, "hwData length does not match");

    Real rate = 0.05;
    DayCounter dc = Actual365Fixed();
    Compounding cmp = Continuous; // Simple;

    Real recovery = 0.4;
    vector<Real> lambda (names, 0.01);

    Real namesNotional = 100.0;

    Schedule schedule = MakeSchedule().from(Date (1, September, 2006))
                                      .to(Date (1, September, 2011))
                                      .withTenor(3*Months)
                                      .withCalendar(TARGET());

    Date asofDate(31, August, 2006);

    Settings::instance().evaluationDate() = asofDate;

    vector<Date> gridDates = {
        asofDate,
        TARGET().advance (asofDate, Period (1, Years)),
        TARGET().advance (asofDate, Period (5, Years)),
        TARGET().advance (asofDate, Period (7, Years))
    };

    ext::shared_ptr<YieldTermStructure> yieldPtr (
                                   new FlatForward (asofDate, rate, dc, cmp));
    Handle<YieldTermStructure> yieldHandle (yieldPtr);

    vector<Handle<DefaultProbabilityTermStructure> > probabilities;
    Period maxTerm (10, Years);
    for (double i : lambda) {
        Handle<Quote> h(ext::shared_ptr<Quote>(new SimpleQuote(i)));
        ext::shared_ptr<DefaultProbabilityTermStructure> ptr (
                                         new FlatHazardRate(asofDate, h, dc));
        probabilities.emplace_back(ptr);
    }

    ext::shared_ptr<SimpleQuote> simpleQuote (new SimpleQuote(0.0));
    Handle<Quote> correlationHandle (simpleQuote);

    ext::shared_ptr<DefaultLossModel> copula( new 
        ConstantLossModel<GaussianCopulaPolicy>( correlationHandle, 
        std::vector<Real>(names, recovery), 
        LatentModelIntegrationType::GaussianQuadrature, names, 
        GaussianCopulaPolicy::initTraits()));

    /* If you like the action you can price with the simulation engine below
    instead below. But you need at least 1e6 simulations to pass the pricing 
    error tests
    */
    //ext::shared_ptr<GaussianDefProbLM> gLM(
    //    ext::make_shared<GaussianDefProbLM>(correlationHandle, names,
    //    LatentModelIntegrationType::GaussianQuadrature,
    //    // g++ requires this when using make_shared
    //    GaussianCopulaPolicy::initTraits()));
    //Size numSimulations = 1000000;
    //// Size numCoresUsed = 4; use your are in the multithread branch
    //// Sobol, many cores
    //ext::shared_ptr<RandomDefaultLM<GaussianCopulaPolicy> > copula( 
    //    new RandomDefaultLM<GaussianCopulaPolicy>(gLM, 
    //        std::vector<Real>(names, recovery), numSimulations, 1.e-6, 
    //        2863311530));

    // Set up pool and basket
    std::vector<std::string> namesIds;
    for(Size i=0; i<names; i++)
        namesIds.push_back(std::string("Name") + std::to_string(i));

    std::vector<Issuer> issuers;
    for(Size i=0; i<names; i++) {
        std::vector<QuantLib::Issuer::key_curve_pair> curves(1, 
            std::make_pair(NorthAmericaCorpDefaultKey(
                EURCurrency(), QuantLib::SeniorSec,
                Period(), 1. // amount threshold
                ), probabilities[i]));
        issuers.emplace_back(curves);
    }

    ext::shared_ptr<Pool> thePool = ext::make_shared<Pool>();
    for(Size i=0; i<names; i++)
        thePool->add(namesIds[i], issuers[i], NorthAmericaCorpDefaultKey(
                EURCurrency(), QuantLib::SeniorSec, Period(), 1.));

    std::vector<DefaultProbKey> defaultKeys(probabilities.size(), 
        NorthAmericaCorpDefaultKey(EURCurrency(), SeniorSec, Period(), 1.));

    ext::shared_ptr<Basket> basket(new Basket(asofDate, namesIds, 
        std::vector<Real>(names, namesNotional/names), thePool, 0., 1.));

    ext::shared_ptr<PricingEngine> engine(
        new IntegralNtdEngine(timeUnit, yieldHandle));

    vector<NthToDefault> ntd;
    for (Size i = 1; i <= probabilities.size(); i++) {
        ntd.emplace_back(basket, i, Protection::Seller, schedule, 0.0, 0.02, Actual360(),
                         namesNotional * names, true);
        ntd.back().setPricingEngine(engine);
    }

    QL_REQUIRE (LENGTH(hwCorrelation) == 3,
                "correlation length does not match");

    Real diff, maxDiff = 0;

    basket->setLossModel(copula);
    
    for (Size j = 0; j < LENGTH(hwCorrelation); j++) {
        simpleQuote->setValue (hwCorrelation[j]);
        for (Size i = 0; i < ntd.size(); i++) {
            QL_REQUIRE (ntd[i].rank() == hwData[i].rank, "rank does not match");
            QL_REQUIRE (LENGTH(hwCorrelation) == LENGTH(hwData[i].spread),
                        "vector length does not match");
            diff = 1e4 * ntd[i].fairPremium() - hwData[i].spread[j];
            maxDiff = std::max(maxDiff, fabs (diff));
            BOOST_CHECK_MESSAGE (fabs(diff/hwData[i].spread[j]) < relTolerance
                                 || fabs(diff) < absTolerance,
                                 "tolerance " << relTolerance << "|"
                                 << absTolerance << " exceeded");
        }
    }
    #endif
}


void NthToDefaultTest::testStudent() {
    #ifndef QL_PATCH_SOLARIS
    BOOST_TEST_MESSAGE("Testing nth-to-default against Hull-White values "
                       "with Student copula...");

    using namespace nth_to_default_test;

    SavedSettings backup;

    /*************************
     * Tolerances
     */
    Real relTolerance = 0.017; // relative difference
    Real absTolerance = 1; // absolute difference in bp

    Period timeUnit = 1*Weeks; // required to reach accuracy

    Size names = 10;
    QL_REQUIRE (LENGTH(hwDataDist) == names, "hwDataDist length does not match");

    Real rate = 0.05;
    DayCounter dc = Actual365Fixed();
    Compounding cmp = Continuous; // Simple;


    Real recovery = 0.4;
    vector<Real> lambda (names, 0.01);

    Real namesNotional = 100.0;

    Schedule schedule = MakeSchedule().from(Date (1, September, 2006))
                                      .to(Date (1, September, 2011))
                                      .withTenor(3*Months)
                                      .withCalendar(TARGET());

    Date asofDate(31, August, 2006);

    Settings::instance().evaluationDate() = asofDate;

    vector<Date> gridDates {
        asofDate,
        TARGET().advance (asofDate, Period (1, Years)),
        TARGET().advance (asofDate, Period (5, Years)),
        TARGET().advance (asofDate, Period (7, Years))
    };

    ext::shared_ptr<YieldTermStructure> yieldPtr (
                                new FlatForward (asofDate, rate, dc, cmp));
    Handle<YieldTermStructure> yieldHandle (yieldPtr);

    vector<Handle<DefaultProbabilityTermStructure> > probabilities;
    Period maxTerm (10, Years);
    for (double i : lambda) {
        Handle<Quote> h(ext::shared_ptr<Quote>(new SimpleQuote(i)));
        ext::shared_ptr<DefaultProbabilityTermStructure> ptr (
                                         new FlatHazardRate(asofDate, h, dc));
        probabilities.emplace_back(ptr);
    }

    ext::shared_ptr<SimpleQuote> simpleQuote (new SimpleQuote(0.0));
    Handle<Quote> correlationHandle (simpleQuote);

    TCopulaPolicy::initTraits iniT;
    iniT.tOrders = std::vector<QuantLib::Integer>(2,5);
    ext::shared_ptr<DefaultLossModel> copula( new 
        ConstantLossModel<TCopulaPolicy>( correlationHandle, 
        std::vector<Real>(names, recovery), 
        LatentModelIntegrationType::GaussianQuadrature, names, iniT));

    // Set up pool and basket
    std::vector<std::string> namesIds;
    for(Size i=0; i<names; i++)
        namesIds.push_back(std::string("Name") + std::to_string(i));

    std::vector<Issuer> issuers;
    for(Size i=0; i<names; i++) {
        std::vector<QuantLib::Issuer::key_curve_pair> curves(1, 
            std::make_pair(NorthAmericaCorpDefaultKey(
                EURCurrency(), QuantLib::SeniorSec,
                Period(), 1. // amount threshold
                ), probabilities[i]));
        issuers.emplace_back(curves);
    }

    ext::shared_ptr<Pool> thePool = ext::make_shared<Pool>();
    for(Size i=0; i<names; i++)
        thePool->add(namesIds[i], issuers[i], NorthAmericaCorpDefaultKey(
                EURCurrency(), QuantLib::SeniorSec, Period(), 1.));

    std::vector<DefaultProbKey> defaultKeys(probabilities.size(), 
        NorthAmericaCorpDefaultKey(EURCurrency(), SeniorSec, Period(), 1.));

    ext::shared_ptr<Basket> basket(new Basket(asofDate, namesIds, 
        std::vector<Real>(names, namesNotional/names), thePool, 0., 1.));

    ext::shared_ptr<PricingEngine> engine(
        new IntegralNtdEngine(timeUnit, yieldHandle));

    vector<NthToDefault> ntd;
    for (Size i = 1; i <= probabilities.size(); i++) {
        ntd.emplace_back(basket, i, Protection::Seller, schedule, 0.0, 0.02, Actual360(),
                         namesNotional * names, true);
        ntd.back().setPricingEngine(engine);
    }

    QL_REQUIRE (LENGTH(hwCorrelation) == 3,
                "correlation length does not match");

    Real maxDiff = 0;

    basket->setLossModel(copula);

    // This is the necessary code, but a proper hwData for the t copula is needed.
    // Real diff;
    // for (Size j = 0; j < LENGTH(hwCorrelation); j++) {
    //     simpleQuote->setValue (hwCorrelation[j]);
    //     for (Size i = 0; i < ntd.size(); i++) {
    //         QL_REQUIRE (ntd[i].rank() == hwData[i].rank, "rank does not match");
    //         QL_REQUIRE (LENGTH(hwCorrelation) == LENGTH(hwData[i].spread),
    //                     "vector length does not match");
    //         diff = 1e4 * ntd[i].fairPremium() - hwData[i].spread[j];
    //         maxDiff = std::max(maxDiff, fabs (diff));
    //         BOOST_CHECK_MESSAGE (fabs(diff/hwData[i].spread[j]) < relTolerance
    //                              || fabs(diff) < absTolerance,
    //                              "tolerance2 " << relTolerance << "|"
    //                              << absTolerance << " exceeded";
    //     }
    // }

    //instead of this BEGIN
    simpleQuote->setValue (0.3);
    
    for (Size i = 0; i < ntd.size(); i++) {
        QL_REQUIRE (ntd[i].rank() == hwDataDist[i].rank, "rank does not match");

        Real diff = 1e4 * ntd[i].fairPremium() - hwDataDist[i].spread[3];
        maxDiff = std::max(maxDiff, fabs (diff));
        BOOST_CHECK_MESSAGE (fabs(diff / hwDataDist[i].spread[3]) < relTolerance ||
                             fabs(diff) < absTolerance,
                             "tolerance " << relTolerance << "|"
                             << absTolerance << " exceeded" << i << "|"
                             << abs(diff) << "|" << hwDataDist[i].spread[3]);
    }
    //END
    #endif
}

test_suite* NthToDefaultTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Nth-to-default tests");
#ifndef QL_PATCH_SOLARIS
    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&NthToDefaultTest::testGauss));
        suite->add(QUANTLIB_TEST_CASE(&NthToDefaultTest::testStudent));
    }
    #endif
    return suite;
}
]]></document_content>
  </document>
  <document index="203">
    <source>nthtodefault.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_nth_to_default_hpp
#define quantlib_test_nth_to_default_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class NthToDefaultTest {
  public:
    static void testGauss();
    static void testStudent();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="204">
    <source>numericaldifferentiation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "numericaldifferentiation.hpp"
#include "utilities.hpp"

#include <ql/math/matrix.hpp>
#include <ql/math/factorial.hpp>
#include <ql/methods/finitedifferences/operators/numericaldifferentiation.hpp>
#include <cmath>
#include <algorithm>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {
    bool isTheSame(Real a, Real b) {
        const Real eps = 500*QL_EPSILON;

        if (std::fabs(b) < QL_EPSILON)
            return std::fabs(a) < eps;
        else
            return std::fabs((a - b)/b) < eps;
    }

    void checkTwoArraysAreTheSame(const Array& calculated,
                                  const Array& expected) {
        bool correct = (calculated.size() == expected.size())
            && std::equal(calculated.begin(), calculated.end(),
                          expected.begin(), isTheSame);

        if (!correct) {
            BOOST_FAIL("Failed to reproduce expected array"
                        << "\n    calculated: " << calculated
                        << "\n    expected:   " << expected
                        << "\n    difference: " << expected - calculated);
        }
    }

    void singleValueTest(const std::string& comment,
                         Real calculated, Real expected, Real tol) {
        if (std::fabs(calculated - expected) > tol)
            BOOST_FAIL("Failed to reproduce " << comment
                        << " order derivative"
                        << "\n    calculated: " << calculated
                        << "\n      expected: " << expected
                        << "\n     tolerance: " << tol
                        << "\n    difference: "
                        << expected - calculated);
    }
}

void NumericalDifferentiationTest::testTabulatedCentralScheme() {
    BOOST_TEST_MESSAGE("Testing numerical differentiation "
                       "using the central scheme...");
    const ext::function<Real(Real)> f;

    const NumericalDifferentiation::Scheme central
        = NumericalDifferentiation::Central;

    // see http://en.wikipedia.org/wiki/Finite_difference_coefficient
    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 1.0, 3, central).weights(),
        {-0.5, 0.0, 0.5});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 0.5, 3, central).weights(),
        {-1.0, 0.0, 1.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 0.25, 7, central).weights(),
        {-4/60.0, 12/20.0, -12/4.0, 0.0, 12/4.0, -12/20.0, 4/60.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 4, std::pow(0.5, 0.25), 9, central).weights(),
        {14/240.0, -4/5.0, 338/60.0, -244/15.0, 182/8.0, -244/15.0, 338/60.0, -4/5.0, 14/240.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 0.5, 7, central).offsets(),
        {-1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5});
}

void NumericalDifferentiationTest::testTabulatedBackwardScheme() {
    BOOST_TEST_MESSAGE("Testing numerical differentiation "
                       "using the backward scheme...");
    const ext::function<Real(Real)> f;

    const NumericalDifferentiation::Scheme backward
        = NumericalDifferentiation::Backward;

    // see http://en.wikipedia.org/wiki/Finite_difference_coefficient
    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 1.0, 2, backward).weights(),
        {1.0, -1.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 2, 2.0, 4, backward).weights(),
        {2/4.0, -5/4.0, 4/4.0, -1.0/4.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 4, 1.0, 6, backward).weights(),
        {3.0, -14.0, 26.0, -24.0, 11.0, -2.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 2, 0.5, 4, backward).offsets(),
        {0.0, -0.5, -1.0, -1.5});
}


void NumericalDifferentiationTest::testTabulatedForwardScheme() {
    BOOST_TEST_MESSAGE("Testing numerical differentiation "
                       "using the Forward scheme...");
    const ext::function<Real(Real)> f;

    const NumericalDifferentiation::Scheme forward
        = NumericalDifferentiation::Forward;

    // see http://en.wikipedia.org/wiki/Finite_difference_coefficient
    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 1.0, 2, forward).weights(),
        {-1.0, 1.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 0.5, 3, forward).weights(),
        {-6/2.0, 4.0, -2/2.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, 0.5, 7, forward).weights(),
        {-98/20.0, 12.0, -30/2.0, 40/3.0, -30/4.0, 12/5.0, -2/6.0});

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 2, 0.5, 4, forward).offsets(),
        {0.0, 0.5, 1.0, 1.5});
}


void NumericalDifferentiationTest::testIrregularSchemeFirstOrder() {
    BOOST_TEST_MESSAGE("Testing numerical differentiation "
                       "of first order using an irregular scheme...");
    const ext::function<Real(Real)> f;

    const Real h1 = 5e-7;
    const Real h2 = 3e-6;

    const Real alpha = -h2/(h1*(h1+h2));
    const Real gamma =  h1/(h2*(h1+h2));
    const Real beta = -alpha - gamma;

    Array offsets = { -h1, 0.0, h2 };

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 1, offsets).weights(),
        { alpha, beta, gamma });
}

void NumericalDifferentiationTest::testIrregularSchemeSecondOrder() {
    BOOST_TEST_MESSAGE("Testing numerical differentiation "
                       "of second order using an irregular scheme...");
    const ext::function<Real(Real)> f;

    const Real h1 = 2e-7;
    const Real h2 = 8e-8;

    const Real alpha = 2/(h1*(h1+h2));
    const Real gamma = 2/(h2*(h1+h2));
    const Real beta = -alpha - gamma;

    Array offsets = { -h1, 0.0, h2 };

    checkTwoArraysAreTheSame(
        NumericalDifferentiation(f, 2, offsets).weights(),
        {alpha, beta, gamma});
}


void NumericalDifferentiationTest::testDerivativesOfSineFunction() {
    BOOST_TEST_MESSAGE("Testing numerical differentiation"
                       " of sin function...");

    const ext::function<Real(Real)> f = static_cast<Real(*)(Real)>(std::sin);

    const ext::function<Real(Real)> df_central
        = NumericalDifferentiation(f, 1, std::sqrt(QL_EPSILON), 3,
                                   NumericalDifferentiation::Central);

    const ext::function<Real(Real)> df_backward
        = NumericalDifferentiation(f, 1, std::sqrt(QL_EPSILON), 3,
                                   NumericalDifferentiation::Backward);

    const ext::function<Real(Real)> df_forward
        = NumericalDifferentiation(f, 1, std::sqrt(QL_EPSILON), 3,
                                   NumericalDifferentiation::Forward);

    for (Real x=0.0; x < 5.0; x+=0.1) {
        const Real calculatedCentral = df_central(x);
        const Real calculatedBackward = df_backward(x);
        const Real calculatedForward = df_forward(x);
        const Real expected = std::cos(x);

        singleValueTest("central first", calculatedCentral, expected, 1e-8);
        singleValueTest("backward first", calculatedBackward, expected, 1e-6);
        singleValueTest("forward first", calculatedForward, expected, 1e-6);
    }

    const ext::function<Real(Real)> df4_central
        = NumericalDifferentiation(f, 4, 1e-2, 7,
                                   NumericalDifferentiation::Central);
    const ext::function<Real(Real)> df4_backward
        = NumericalDifferentiation(f, 4, 1e-2, 7,
                                   NumericalDifferentiation::Backward);
    const ext::function<Real(Real)> df4_forward
        = NumericalDifferentiation(f, 4, 1e-2, 7,
                                   NumericalDifferentiation::Forward);

    for (Real x=0.0; x < 5.0; x+=0.1) {
        const Real calculatedCentral = df4_central(x);
        const Real calculatedBackward = df4_backward(x);
        const Real calculatedForward = df4_forward(x);
        const Real expected = std::sin(x);

        singleValueTest("central 4th", calculatedCentral, expected, 1e-4);
        singleValueTest("backward 4th", calculatedBackward, expected, 1e-4);
        singleValueTest("forward 4th", calculatedForward, expected, 1e-4);
    }

    const Array offsets = {-0.01, -0.02, 0.03, 0.014, 0.041};
    NumericalDifferentiation df3_irregular(f, 3, offsets);

    checkTwoArraysAreTheSame(df3_irregular.offsets(), offsets);

    for (Real x=0.0; x < 5.0; x+=0.1) {
        const Real calculatedIrregular = df3_irregular(x);
        const Real expected = -std::cos(x);

        singleValueTest("irregular 3th", calculatedIrregular, expected, 5e-5);
    }
}

namespace {
    Disposable<Array> vandermondeCoefficients(
        Size order, Real x, const Array& gridPoints) {

        const Array q = gridPoints - x;
        const Size n = gridPoints.size();

        Matrix m(n, n, 1.0);
        for (Size i=1; i < n; ++i) {
            const Real fact = Factorial::get(i);
            for (Size j=0; j < n; ++j)
                m[i][j] = std::pow(q[j], Integer(i)) / fact;
        }

        Array b(n, 0.0);
        b[order] = 1.0;
        return inverse(m)*b;
    }
}

void NumericalDifferentiationTest::testCoefficientBasedOnVandermonde() {
    BOOST_TEST_MESSAGE("Testing coefficients from numerical differentiation"
                       " by comparison with results from"
                       " Vandermonde matrix inversion...");
    const ext::function<Real(Real)> f;

    for (Natural order=0; order < 5; ++order) {
        for (Natural nGridPoints = order + 1;
            nGridPoints < order + 3; ++nGridPoints) {

            Array gridPoints(nGridPoints);
            for (Natural i=0; i < nGridPoints; ++i) {
                const Real p = Real(i);
                gridPoints[i] = std::sin(p) + std::cos(p); // strange points
            }

            const Real x = 0.3902842; // strange points
            const Array weightsVandermonde
                = vandermondeCoefficients(order, x, gridPoints);
            const NumericalDifferentiation nd(f, order, gridPoints-x);

            checkTwoArraysAreTheSame(gridPoints, nd.offsets() + x);
            checkTwoArraysAreTheSame(weightsVandermonde, nd.weights());
        }
    }
}



test_suite* NumericalDifferentiationTest::suite() {
    auto* suite = BOOST_TEST_SUITE("NumericalDifferentiation tests");

    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testTabulatedCentralScheme));
    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testTabulatedBackwardScheme));
    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testTabulatedForwardScheme));
    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testIrregularSchemeFirstOrder));
    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testIrregularSchemeSecondOrder));
    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testDerivativesOfSineFunction));
    suite->add(QUANTLIB_TEST_CASE(
        &NumericalDifferentiationTest::testCoefficientBasedOnVandermonde));

    return suite;
}


]]></document_content>
  </document>
  <document index="205">
    <source>numericaldifferentiation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_numerical_differentiation_hpp
#define quantlib_test_numerical_differentiation_hpp

#include <boost/test/unit_test.hpp>

class NumericalDifferentiationTest {
  public:
    static void testTabulatedCentralScheme();
    static void testTabulatedBackwardScheme();
    static void testTabulatedForwardScheme();
    static void testIrregularSchemeFirstOrder();
    static void testIrregularSchemeSecondOrder();
    static void testDerivativesOfSineFunction();
    static void testCoefficientBasedOnVandermonde();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="206">
    <source>observable.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "observable.hpp"
#include "utilities.hpp"
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/capfloor/capfloortermvolsurface.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionletadapter.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionlet.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>


using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    class UpdateCounter : public Observer {
      public:
        UpdateCounter() = default;
        void update() override { ++counter_; }
        Size counter() const { return counter_; }

      private:
        Size counter_ = 0;
    };

    class RestoreUpdates {
      public:
        ~RestoreUpdates() {
            ObservableSettings::instance().enableUpdates();
        }
    };

}

void ObservableTest::testObservableSettings() {

    BOOST_TEST_MESSAGE("Testing observable settings...");

    const ext::shared_ptr<SimpleQuote> quote(new SimpleQuote(100.0));
    UpdateCounter updateCounter;

    updateCounter.registerWith(quote);
    if (updateCounter.counter() != 0) {
        BOOST_FAIL("update counter value is not zero");
    }

   quote->setValue(1.0);
   if (updateCounter.counter() != 1) {
       BOOST_FAIL("update counter value is not one");
   }

   ObservableSettings::instance().disableUpdates(false);
   quote->setValue(2.0);
   if (updateCounter.counter() != 1) {
       BOOST_FAIL("update counter value is not one");
   }
   ObservableSettings::instance().enableUpdates();
   if (updateCounter.counter() != 1) {
       BOOST_FAIL("update counter value is not one");
   }

   ObservableSettings::instance().disableUpdates(true);
   quote->setValue(3.0);
   if (updateCounter.counter() != 1) {
       BOOST_FAIL("update counter value is not one");
   }
   ObservableSettings::instance().enableUpdates();
   if (updateCounter.counter() != 2) {
       BOOST_FAIL("update counter value is not two");
   }

   UpdateCounter updateCounter2;
   updateCounter2.registerWith(quote);
   ObservableSettings::instance().disableUpdates(true);
   for (Size i=0; i < 10; ++i) {
       quote->setValue(Real(i));
   }
   if (updateCounter.counter() != 2) {
       BOOST_FAIL("update counter value is not two");
   }
   ObservableSettings::instance().enableUpdates();
   if (updateCounter.counter() != 3 || updateCounter2.counter() != 1) {
       BOOST_FAIL("update counter values are not correct");
   }
}


#ifdef QL_ENABLE_THREAD_SAFE_OBSERVER_PATTERN

#include <boost/atomic.hpp>
#include <boost/thread/locks.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/thread.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>

#include <list>

namespace {

    class MTUpdateCounter : public Observer {
      public:
        MTUpdateCounter() : counter_(0) {
            ++instanceCounter_;
        }
        ~MTUpdateCounter() {
            --instanceCounter_;
        }
        void update() {
            ++counter_;
        }
        int counter() { return counter_; }
        static int instanceCounter() { return instanceCounter_; }

      private:
        boost::atomic<int> counter_;
        static boost::atomic<int> instanceCounter_;
    };

    boost::atomic<int> MTUpdateCounter::instanceCounter_(0);

    class GarbageCollector {
      public:
        GarbageCollector() : terminate_(false) { }

        void addObj(const ext::shared_ptr<MTUpdateCounter>& updateCounter) {
            boost::lock_guard<boost::mutex> lock(mutex_);
            objList.push_back(updateCounter);
        }

        void run() {
            while(!terminate_) {
                Size objListSize;
                {
                    boost::lock_guard<boost::mutex> lock(mutex_);
                    objListSize = objList.size();
                }

                if (objListSize > 20) {
                    // trigger gc
                    while (objListSize > 0) {
                        boost::lock_guard<boost::mutex> lock(mutex_);
                        objList.pop_front();
                        objListSize = objList.size();
                    }
                }

                boost::this_thread::sleep(boost::posix_time::milliseconds(2));
            }
            objList.clear();
        }

        void terminate() {
            terminate_ = true;
        }
      private:
        boost::mutex mutex_;
        boost::atomic<bool> terminate_;

        std::list<ext::shared_ptr<MTUpdateCounter> > objList;
    };
}

void ObservableTest::testAsyncGarbagCollector() {

    BOOST_TEST_MESSAGE("Testing observer pattern with an asynchronous "
                       "garbage collector (JVM/.NET use case)...");

    // This test core dumps if used with the ordinary implementation
    // of the observer pattern (comparable situation
    // in JVM or .NET eco systems).

    const ext::shared_ptr<SimpleQuote> quote(new SimpleQuote(-1.0));

    GarbageCollector gc;
    boost::thread workerThread(&GarbageCollector::run, &gc);

    for (Size i=0; i < 10000; ++i) {
        const ext::shared_ptr<MTUpdateCounter> observer(new MTUpdateCounter);
        observer->registerWith(quote);
        gc.addObj(observer);

        for (Size j=0; j < 10; ++j)
            quote->setValue(Real(j));
    }

    gc.terminate();
    workerThread.join();

    if (MTUpdateCounter::instanceCounter() != 0) {
        BOOST_FAIL("garbage collection does not work.");
    }
}


void ObservableTest::testMultiThreadingGlobalSettings() {
	BOOST_TEST_MESSAGE("Testing observer global settings in a "
		               "multithreading environment...");
	
	const ext::shared_ptr<SimpleQuote> quote(new SimpleQuote(-1.0));

    ObservableSettings::instance().disableUpdates(true);

    GarbageCollector gc;
    boost::thread workerThread(&GarbageCollector::run, &gc);

    typedef std::list<ext::shared_ptr<MTUpdateCounter> > local_list_type;
    local_list_type localList;

    for (Size i=0; i < 4000; ++i) {
        const ext::shared_ptr<MTUpdateCounter> observer(new MTUpdateCounter);
        observer->registerWith(quote);

        if ((i%4) == 0) {
            localList.push_back(observer);
            for (Size j=0; j < 5; ++j)
                quote->setValue(Real(j));
        }
        gc.addObj(observer);
    }

    gc.terminate();
    workerThread.join();

    if (localList.size() != Size(MTUpdateCounter::instanceCounter())) {
        BOOST_FAIL("garbage collection does not work.");
    }

    for (local_list_type::iterator iter = localList.begin();
        iter != localList.end(); ++iter) {
        if ((*iter)->counter() != 0) {
            BOOST_FAIL("notification should have been blocked");
        }
    }

    ObservableSettings::instance().enableUpdates();

    for (local_list_type::iterator iter = localList.begin();
        iter != localList.end(); ++iter) {
        if ((*iter)->counter() != 1) {
            BOOST_FAIL("only one notification should have been sent");
        }
    }
}
#endif

void ObservableTest::testDeepUpdate() {

    SavedSettings backup;
    RestoreUpdates guard;

    Date refDate = Settings::instance().evaluationDate();

    ObservableSettings::instance().disableUpdates(true);

    Handle<YieldTermStructure> yts(
        ext::make_shared<FlatForward>(0, NullCalendar(), 0.02, Actual365Fixed()));
    ext::shared_ptr<IborIndex> ibor = ext::make_shared<Euribor>(3 * Months, yts);
    ext::shared_ptr<SimpleQuote> q = ext::make_shared<SimpleQuote>(0.20);
    std::vector<Real> strikes = {0.01, 0.02};
    std::vector<Date> dates = {refDate + 90, refDate + 180};
    std::vector<std::vector<Handle<Quote> > > quotes = {
        {Handle<Quote>(q), Handle<Quote>(q)},
        {Handle<Quote>(q), Handle<Quote>(q)}
    };

    ext::shared_ptr<StrippedOptionletAdapter> vol =
        ext::make_shared<StrippedOptionletAdapter>(ext::make_shared<StrippedOptionlet>(
            0, NullCalendar(), Unadjusted, ibor, dates, strikes, quotes, Actual365Fixed()));

    Real v1 = vol->volatility(refDate + 100, 0.01);
    q->setValue(0.21);
    Real v2 = vol->volatility(refDate + 100, 0.01);
    vol->update();
    Real v3 = vol->volatility(refDate + 100, 0.01);
    vol->deepUpdate();
    Real v4 = vol->volatility(refDate + 100, 0.01);

    BOOST_CHECK_CLOSE(v1, 0.2, 1E-10);
    BOOST_CHECK_CLOSE(v2, 0.2, 1E-10);
    BOOST_CHECK_CLOSE(v3, 0.2, 1E-10);
    BOOST_CHECK_CLOSE(v4, 0.21, 1E-10);
}

namespace {
	class DummyObserver : public Observer {
	  public:
            DummyObserver() = default;
            void update() override {}
        };
}

void ObservableTest::testEmptyObserverList() {
	BOOST_TEST_MESSAGE("Testing unregisterWith call on empty observer...");

    SavedSettings backup;

    const ext::shared_ptr<DummyObserver> dummyObserver=ext::make_shared<DummyObserver>();
    dummyObserver->unregisterWith(ext::make_shared<SimpleQuote>(10.0));
}

test_suite* ObservableTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Observer tests");

    suite->add(QUANTLIB_TEST_CASE(&ObservableTest::testObservableSettings));

#ifdef QL_ENABLE_THREAD_SAFE_OBSERVER_PATTERN
    suite->add(QUANTLIB_TEST_CASE(&ObservableTest::testAsyncGarbagCollector));
    suite->add(QUANTLIB_TEST_CASE(
        &ObservableTest::testMultiThreadingGlobalSettings));
#endif

    suite->add(QUANTLIB_TEST_CASE(&ObservableTest::testDeepUpdate));
    suite->add(QUANTLIB_TEST_CASE(&ObservableTest::testEmptyObserverList));
    return suite;
}

]]></document_content>
  </document>
  <document index="207">
    <source>observable.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_observer_hpp
#define quantlib_test_observer_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ObservableTest {
  public:
    static void testObservableSettings();
    static void testAsyncGarbagCollector();
    static void testMultiThreadingGlobalSettings();
    static void testDeepUpdate();
    static void testEmptyObserverList();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="208">
    <source>ode.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers
 Copyright (C) 2013 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "ode.hpp"
#include "utilities.hpp"
#include <ql/experimental/math/expm.hpp>
#include <ql/math/ode/adaptiverungekutta.hpp>
#include <complex>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::exp;
using std::sin;

namespace {

    struct ode1 {
        Real operator()(Real x, Real y) const { return y; }
    };

    struct ode2 {
        std::complex<Real> operator()(Real x,
                                      const std::complex<Real>& y) {
            return std::complex<Real>(0.0,1.0)*y;
        }
    };

    struct ode3 {
        Disposable<std::vector<Real> > operator()(Real x,
                                                  const std::vector<Real>& y) {
            std::vector<Real> r(2);
            r[0] = y[1]; r[1] = -y[0];
            return r;
        }
    };

    struct ode4 {
        Disposable<std::vector<std::complex<Real> > > operator()(
                                  const std::complex<Real>& x,
                                  const std::vector<std::complex<Real> >& y) {
            std::vector<std::complex<Real> > r(2);
            r[0] = y[1]; r[1] = -y[0];
            return r;
        }
    };

}

void OdeTest::testAdaptiveRungeKutta() {

    BOOST_TEST_MESSAGE("Testing adaptive Runge Kutta...");

    AdaptiveRungeKutta<Real> rk_real(1E-12,1E-4,0.0);
    AdaptiveRungeKutta<std::complex<Real> > rk_complex(1E-12,1E-4,0.0);
    Real tol1 = 5E-10, tol2 = 2E-12, tol3 = 2E-12, tol4 = 2E-12;

    // f'=f, f(0)=1
    AdaptiveRungeKutta<Real>::OdeFct1d ode1_ = ode1();
    Real y10=1;

    // f'=f, f(0)=i
    AdaptiveRungeKutta<std::complex<Real> >::OdeFct1d ode2_ = ode2();
    std::complex<Real> y20(0.0,1.0);

    // f''=-f, f(0)=0, f'(0)=1
    AdaptiveRungeKutta<Real>::OdeFct ode3_ = ode3();
    std::vector<Real> y30(2); y30[0] = 0.0; y30[1] = 1.0;

    // f''=-f, f(0)=1, f'(0)=i
    AdaptiveRungeKutta<std::complex<Real> >::OdeFct ode4_ = ode4();
    std::vector<std::complex<Real> > y40(2);
    y40[0] = 1.0;
    y40[1] = std::complex<Real>(0.0,1.0);

    Real x=0.0;
    Real y1 = y10;
    std::complex<Real> y2 = y20;
    std::vector<Real> y3 = y30;
    std::vector<std::complex<Real> > y4 = y40;

    while (x<5.0) {
        Real exact1 = exp(x);
        std::complex<Real> exact2 =
            std::exp(std::complex<Real>(0.0,x)) * std::complex<Real>(0.0,1.0);
        Real exact3 = sin(x);
        std::complex<Real> exact4 = std::exp(std::complex<Real>(0.0,x));

        if ( std::fabs( exact1 - y1 ) > tol1 )
            BOOST_FAIL("Error in ode #1: exact solution at x=" << x
                       << " is " << exact1
                       << ", numerical solution is " << y1
                       << " difference " << std::fabs(exact1-y1)
                       << " outside tolerance " << tol1);
        if ( abs( exact2 - y2 ) > tol2 )
            BOOST_FAIL("Error in ode #2: exact solution at x=" << x
                       << " is " << exact2
                       << ", numerical solution is " << y2
                       << " difference " << abs(exact2-y2)
                       << " outside tolerance " << tol2);
        if ( std::fabs( exact3 - y3[0] ) > tol3 )
            BOOST_FAIL("Error in ode #3: exact solution at x=" << x
                       << " is " << exact3
                       << ", numerical solution is " << y3[0]
                       << " difference " << std::fabs(exact3-y3[0])
                       << " outside tolerance " << tol3);
        if ( abs( exact4 - y4[0] ) > tol4 )
            BOOST_FAIL("Error in ode #4: exact solution at x=" << x
                       << " is " << exact4
                       << ", numerical solution is " << y4[0]
                       << " difference " << abs(exact4-y4[0])
                       << " outside tolerance " << tol4);
        x+=0.01;
        y1=rk_real(ode1_,y10,0.0,x);
        y2=rk_complex(ode2_,y20,0.0,x);
        y3=rk_real(ode3_,y30,0.0,x);
        y4=rk_complex(ode4_,y40,0.0,x);
    }
}

namespace {
    Real frobenuiusNorm(const Matrix& m) {
        return std::sqrt(DotProduct((m*transpose(m)).diagonal(),
                                    Array(m.rows(), 1.0)));
    }
}

void OdeTest::testMatrixExponential() {
    BOOST_TEST_MESSAGE("Testing matrix exponential based on ode...");

    // Reference results are taken from
    // http://www.millersville.edu/~bikenaga/linear-algebra/matrix-exponential/matrix-exponential.html

    Matrix m(3, 3);
    m[0][0] = 5; m[0][1] =-6; m[0][2] =-6;
    m[1][0] =-1; m[1][1] = 4; m[1][2] = 2;
    m[2][0] = 3; m[2][1] =-6; m[2][2] =-4;

    const Real tol = 1e-12;

    for (Real t=0.01; t < 11; t+=t) {
        const Matrix calculated = Expm(m, t, tol);

        Matrix expected(3, 3);
        expected[0][0] = -3*std::exp(t)+4*std::exp(2*t);
        expected[0][1] =  6*std::exp(t)-6*std::exp(2*t);
        expected[0][2] =  6*std::exp(t)-6*std::exp(2*t);
        expected[1][0] =    std::exp(t)-  std::exp(2*t);
        expected[1][1] = -2*std::exp(t)+3*std::exp(2*t);
        expected[1][2] = -2*std::exp(t)+2*std::exp(2*t);
        expected[2][0] = -3*std::exp(t)+3*std::exp(2*t);
        expected[2][1] =  6*std::exp(t)-6*std::exp(2*t);
        expected[2][2] =  6*std::exp(t)-5*std::exp(2*t);

        Matrix diff = calculated - expected;
        Real relDiffNorm = frobenuiusNorm(diff)/frobenuiusNorm(expected);

        if ( std::fabs(relDiffNorm) > 100*tol) {
            BOOST_FAIL("Failed to reproduce expected matrix exponential."
                    << "\n rel. difference norm: " << relDiffNorm
                    << "\n tolerance           : " << 100*tol);
        }

        const Matrix negativeTime = Expm((-1)*m, -t, tol);
        diff = negativeTime - expected;
        relDiffNorm = frobenuiusNorm(diff)/frobenuiusNorm(expected);

        if ( std::fabs(relDiffNorm) > 100*tol) {
            BOOST_FAIL("Failed to reproduce expected matrix exponential."
                    << "\n rel. difference norm: " << relDiffNorm
                    << "\n tolerance           : " << 100*tol);
        }

    }
}

void OdeTest::testMatrixExponentialOfZero() {
    BOOST_TEST_MESSAGE("Testing matrix exponential of a zero matrix "
                       "based on ode...");

    Matrix m(3, 3, 0.0);

    const Real tol = 100*QL_EPSILON;
    const Time t=1.0;
    const Matrix calculated = Expm(m, t);

    for (Size i=0; i < calculated.rows(); ++i) {
        for (Size j=0; j < calculated.columns(); ++j) {
            const Real kroneckerDelta = (i==j)? 1.0 : 0.0;
            if (std::fabs(calculated[i][j] -kroneckerDelta) > tol) {
                BOOST_FAIL("Failed to reproduce expected matrix exponential."
                        << "\n tolerance           : " << tol);
            }
        }
    }
}

test_suite* OdeTest::suite() {
    auto* suite = BOOST_TEST_SUITE("ode tests");
    suite->add(QUANTLIB_TEST_CASE(&OdeTest::testAdaptiveRungeKutta));
    suite->add(QUANTLIB_TEST_CASE(&OdeTest::testMatrixExponential));
    suite->add(QUANTLIB_TEST_CASE(&OdeTest::testMatrixExponentialOfZero));
    return suite;
}
]]></document_content>
  </document>
  <document index="209">
    <source>ode.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_ode_hpp
#define quantlib_test_ode_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class OdeTest {
  public:
    static void testAdaptiveRungeKutta();
    static void testMatrixExponential();
    static void testMatrixExponentialOfZero();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="210">
    <source>operators.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "operators.hpp"
#include "utilities.hpp"
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/dzero.hpp>
#include <ql/methods/finitedifferences/dplusdminus.hpp>
#include <ql/methods/finitedifferences/bsmoperator.hpp>
#include <ql/methods/finitedifferences/bsmtermoperator.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;


void OperatorTest::testTridiagonal() {

    BOOST_TEST_MESSAGE("Testing tridiagonal operator...");

    Size n = 8; // can use 3 for easier debugging

    TridiagonalOperator T(n);
    T.setFirstRow(1.0, 2.0);
    T.setMidRows( 0.0, 2.0, 0.0);
    T.setLastRow(      2.0, 1.0);

    Array original(n, 1.0);

    Array intermediate = T.applyTo(original);

    Array final(intermediate);
    T.solveFor(final, final);
    for (Size i=0; i<n; ++i) {
        if (final[i]!=original[i])
            BOOST_FAIL("\n applyTo + solveFor does not equal identity:"
                       "\n            original vector: " << original <<
                       "\n         transformed vector: " << intermediate <<
                       "\n inverse transformed vector: " << final);
    }

    final = Array(n, 0.0);
    Array temp(intermediate);
    T.solveFor(temp, final);
    for (Size i=0; i<n; ++i) {
        if (temp[i]!=intermediate[i])
            BOOST_FAIL("\n solveFor altered rhs:"
                       "\n            original vector: " << original <<
                       "\n         transformed vector: " << intermediate <<
                       "\n altered transformed vector: " << temp <<
                       "\n inverse transformed vector: " << final);
    }
    for (Size i=0; i<n; ++i) {
        if (final[i]!=original[i])
            BOOST_FAIL("\n applyTo + solveFor does not equal identity:"
                       "\n            original vector: " << original <<
                       "\n         transformed vector: " << intermediate <<
                       "\n inverse transformed vector: " << final);
    }

    final = T.solveFor(temp);
    for (Size i=0; i<n; ++i) {
        if (temp[i]!=intermediate[i])
            BOOST_FAIL("\n solveFor altered rhs:"
                       "\n            original vector: " << original <<
                       "\n         transformed vector: " << intermediate <<
                       "\n altered transformed vector: " << temp <<
                       "\n inverse transformed vector: " << final);
    }
    for (Size i=0; i<n; ++i) {
        if (final[i]!=original[i])
            BOOST_FAIL("\n applyTo + solveFor does not equal identity:"
                       "\n            original vector: " << original <<
                       "\n         transformed vector: " << intermediate <<
                       "\n inverse transformed vector: " << final);
    }

    Real delta, error = 0.0, tolerance = 1e-9;
    final = T.SOR(temp, tolerance);
    for (Size i=0; i<n; ++i) {
        delta = final[i]-original[i];
        error += delta * delta;
        if (temp[i]!=intermediate[i])
            BOOST_FAIL("\n SOR altered rhs:"
                       "\n            original vector: " << original <<
                       "\n         transformed vector: " << intermediate <<
                       "\n altered transformed vector: " << temp <<
                       "\n inverse transformed vector: " << final);
    }
    if (error>tolerance)
        BOOST_FAIL("\n applyTo + SOR does not equal identity:"
                   "\n            original vector: " << original <<
                   "\n         transformed vector: " << intermediate <<
                   "\n inverse transformed vector: " << final <<
                   "\n                      error: " << error <<
                   "\n                  tolerance: " << tolerance);
}

void OperatorTest::testConsistency() {

    BOOST_TEST_MESSAGE("Testing differential operators...");

    Real average = 0.0, sigma = 1.0;

    NormalDistribution normal(average,sigma);
    CumulativeNormalDistribution cum(average,sigma);

    Real xMin = average - 4*sigma,
         xMax = average + 4*sigma;
    Size N = 10001;
    // FLOATING_POINT_EXCEPTION
    Real h = (xMax-xMin)/(N-1);

    Array x(N), y(N), yi(N), yd(N), temp(N), diff(N);

    Size i;
    for (i=0; i<N; i++)
        x[i] = xMin+h*i;
    std::transform(x.begin(),x.end(),y.begin(),normal);
    std::transform(x.begin(),x.end(),yi.begin(),cum);
    for (i=0; i<x.size(); i++)
        yd[i] = normal.derivative(x[i]);

    // define the differential operators
    DZero D(N,h);
    DPlusDMinus D2(N,h);

    // check that the derivative of cum is Gaussian
    temp = D.applyTo(yi);
    std::transform(y.begin(),y.end(),temp.begin(),diff.begin(),
                   std::minus<Real>());
    Real e = norm(diff.begin(),diff.end(),h);
    if (e > 1.0e-6) {
        BOOST_FAIL("norm of 1st derivative of cum minus Gaussian: " << e
                   << "\ntolerance exceeded");
    }

    // check that the second derivative of cum is normal.derivative
    temp = D2.applyTo(yi);
    std::transform(yd.begin(),yd.end(),temp.begin(),diff.begin(),
                   std::minus<Real>());
    e = norm(diff.begin(),diff.end(),h);
    if (e > 1.0e-4) {
        BOOST_FAIL("norm of 2nd derivative of cum minus Gaussian derivative: "
                   << e << "\ntolerance exceeded");
    }
}

void OperatorTest::testBSMOperatorConsistency() {
    BOOST_TEST_MESSAGE("Testing consistency of BSM operators...");

    Array grid(10);
    Real price = 20.0;
    Real factor = 1.1;
    Size i;
    for (i = 0; i < grid.size(); i++) {
        grid[i] = price;
        // FLOATING_POINT_EXCEPTION
        price *= factor;
    }
    Real dx = std::log(factor);
    Rate r = 0.05;
    Rate q = 0.01;
    Volatility sigma = 0.5;

    BSMOperator ref(grid.size(), dx, r, q, sigma);

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Date exercise = today + 2*Years;
    Time residualTime = dc.yearFraction(today,exercise);

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, q, dc);
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, r, dc);
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, sigma, dc);
    ext::shared_ptr<GeneralizedBlackScholesProcess> stochProcess(
        new GeneralizedBlackScholesProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));
    BSMTermOperator op2(grid, stochProcess, residualTime);

    Real tolerance = 1.0e-6;

    Array lderror = ref.lowerDiagonal() - op2.lowerDiagonal();
    Array derror = ref.diagonal() - op2.diagonal();
    Array uderror = ref.upperDiagonal() - op2.upperDiagonal();

    for (i=2; i<grid.size()-2; i++) {
        if (std::fabs(lderror[i]) > tolerance ||
            std::fabs(derror[i]) > tolerance ||
            std::fabs(uderror[i]) > tolerance) {
            BOOST_FAIL("inconsistency between BSM operators:\n"
                       << io::ordinal(i) << " row:\n"
                       << "expected:   "
                       << ref.lowerDiagonal()[i] << ", "
                       << ref.diagonal()[i] << ", "
                       << ref.upperDiagonal()[i] << "\n"
                       << "calculated: "
                       << op2.lowerDiagonal()[i] << ", "
                       << op2.diagonal()[i] << ", "
                       << op2.upperDiagonal()[i]);
        }
    }
}


test_suite* OperatorTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Operator tests");
    suite->add(QUANTLIB_TEST_CASE(&OperatorTest::testTridiagonal));
    // FLOATING_POINT_EXCEPTION
    suite->add(QUANTLIB_TEST_CASE(&OperatorTest::testConsistency));
    // FLOATING_POINT_EXCEPTION
    suite->add(QUANTLIB_TEST_CASE(&OperatorTest::testBSMOperatorConsistency));
    return suite;
}

]]></document_content>
  </document>
  <document index="211">
    <source>operators.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_operators_hpp
#define quantlib_test_operators_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class OperatorTest {
  public:
    static void testTridiagonal();
    static void testConsistency();
    static void testBSMOperatorConsistency();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="212">
    <source>optimizers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Franois du Vignaud
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2012 Ralph Schreyer
 Copyright (C) 2012 Mateusz Kapturski

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "optimizers.hpp"
#include "utilities.hpp"
#include <ql/math/optimization/simplex.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/math/optimization/conjugategradient.hpp>
#include <ql/math/optimization/steepestdescent.hpp>
#include <ql/math/optimization/bfgs.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/costfunction.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/optimization/differentialevolution.hpp>
#include <ql/math/optimization/goldstein.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::pow;
using std::cos;

namespace {

    struct NamedOptimizationMethod;

    std::vector<ext::shared_ptr<CostFunction> > costFunctions_;
    std::vector<ext::shared_ptr<Constraint> > constraints_;
    std::vector<Array> initialValues_;
    std::vector<Size> maxIterations_, maxStationaryStateIterations_;
    std::vector<Real> rootEpsilons_, functionEpsilons_, gradientNormEpsilons_;
    std::vector<ext::shared_ptr<EndCriteria> > endCriterias_;
    std::vector<std::vector<NamedOptimizationMethod> > optimizationMethods_;
    std::vector<Array> xMinExpected_, yMinExpected_;

    class OneDimensionalPolynomialDegreeN : public CostFunction {
      public:
        explicit OneDimensionalPolynomialDegreeN(const Array& coefficients)
        : coefficients_(coefficients),
          polynomialDegree_(coefficients.size()-1) {}

        Real value(const Array& x) const override {
            QL_REQUIRE(x.size()==1,"independent variable must be 1 dimensional");
            Real y = 0;
            for (Size i=0; i<=polynomialDegree_; ++i)
                y += coefficients_[i]*std::pow(x[0],static_cast<int>(i));
            return y;
        }

        Disposable<Array> values(const Array& x) const override {
            QL_REQUIRE(x.size()==1,"independent variable must be 1 dimensional");
            Array y(1);
            y[0] = value(x);
            return y;
        }

      private:
        const Array coefficients_;
        const Size polynomialDegree_;
    };


    // The goal of this cost function is simply to call another optimization inside
    // in order to test nested optimizations
    class OptimizationBasedCostFunction : public CostFunction {
      public:
        Real value(const Array&) const override { return 1.0; }

        Disposable<Array> values(const Array&) const override {
            // dummy nested optimization
            Array coefficients(3, 1.0);
            OneDimensionalPolynomialDegreeN oneDimensionalPolynomialDegreeN(coefficients);
            NoConstraint constraint;
            Array initialValues(1, 100.0);
            Problem problem(oneDimensionalPolynomialDegreeN, constraint,
                            initialValues);
            LevenbergMarquardt optimizationMethod;
            //Simplex optimizationMethod(0.1);
            //ConjugateGradient optimizationMethod;
            //SteepestDescent optimizationMethod;
            EndCriteria endCriteria(1000, 100, 1e-5, 1e-5, 1e-5);
            optimizationMethod.minimize(problem, endCriteria);
            // return dummy result
            Array dummy(1,0);
            return dummy;
        }
    };


    enum OptimizationMethodType {simplex,
                                 levenbergMarquardt,
                                 levenbergMarquardt2,
                                 conjugateGradient,
                                 conjugateGradient_goldstein,
                                 steepestDescent,
                                 steepestDescent_goldstein,
                                 bfgs,
                                 bfgs_goldstein};

    std::string optimizationMethodTypeToString(OptimizationMethodType type) {
        switch (type) {
          case simplex:
            return "Simplex";
          case levenbergMarquardt:
            return "Levenberg Marquardt";
          case levenbergMarquardt2:
            return "Levenberg Marquardt (cost function's jacbobian)";
          case conjugateGradient:
            return "Conjugate Gradient";
          case steepestDescent:
            return "Steepest Descent";
          case bfgs:
            return "BFGS";
          case conjugateGradient_goldstein:
              return "Conjugate Gradient (Goldstein line search)";
          case steepestDescent_goldstein:
              return "Steepest Descent (Goldstein line search)";
          case bfgs_goldstein:
              return "BFGS (Goldstein line search)";
          default:
            QL_FAIL("unknown OptimizationMethod type");
        }
    }

    struct NamedOptimizationMethod {
        ext::shared_ptr<OptimizationMethod> optimizationMethod;
        std::string name;
    };


    ext::shared_ptr<OptimizationMethod> makeOptimizationMethod(
                                OptimizationMethodType optimizationMethodType,
                                Real simplexLambda,
                                Real levenbergMarquardtEpsfcn,
                                Real levenbergMarquardtXtol,
                                Real levenbergMarquardtGtol) {
        switch (optimizationMethodType) {
          case simplex:
            return ext::shared_ptr<OptimizationMethod>(
                new Simplex(simplexLambda));
          case levenbergMarquardt:
            return ext::shared_ptr<OptimizationMethod>(
                new LevenbergMarquardt(levenbergMarquardtEpsfcn,
                                       levenbergMarquardtXtol,
                                       levenbergMarquardtGtol));
          case levenbergMarquardt2:
            return ext::shared_ptr<OptimizationMethod>(
                new LevenbergMarquardt(levenbergMarquardtEpsfcn,
                                       levenbergMarquardtXtol,
                                       levenbergMarquardtGtol,
                                       true));
          case conjugateGradient:
            return ext::shared_ptr<OptimizationMethod>(new ConjugateGradient);
          case steepestDescent:
            return ext::shared_ptr<OptimizationMethod>(new SteepestDescent);
          case bfgs:
            return ext::shared_ptr<OptimizationMethod>(new BFGS);
          case conjugateGradient_goldstein:
              return ext::shared_ptr<OptimizationMethod>(new ConjugateGradient(ext::make_shared<GoldsteinLineSearch>()));
          case steepestDescent_goldstein:
              return ext::shared_ptr<OptimizationMethod>(new SteepestDescent(ext::make_shared<GoldsteinLineSearch>()));
          case bfgs_goldstein:
              return ext::shared_ptr<OptimizationMethod>(new BFGS(ext::make_shared<GoldsteinLineSearch>()));
          default:
            QL_FAIL("unknown OptimizationMethod type");
        }
    }


    std::vector<NamedOptimizationMethod> makeOptimizationMethods(
                             const std::vector<OptimizationMethodType>& optimizationMethodTypes,
                             Real simplexLambda,
                             Real levenbergMarquardtEpsfcn,
                             Real levenbergMarquardtXtol,
                             Real levenbergMarquardtGtol) {
        std::vector<NamedOptimizationMethod> results;
        for (auto optimizationMethodType : optimizationMethodTypes) {
            NamedOptimizationMethod namedOptimizationMethod;
            namedOptimizationMethod.optimizationMethod = makeOptimizationMethod(
                optimizationMethodType, simplexLambda, levenbergMarquardtEpsfcn,
                levenbergMarquardtXtol, levenbergMarquardtGtol);
            namedOptimizationMethod.name = optimizationMethodTypeToString(optimizationMethodType);
            results.push_back(namedOptimizationMethod);
        }
        return results;
    }

    Real maxDifference(const Array& a, const Array& b) {
        Array diff = a-b;
        Real maxDiff = 0.0;
        for (double i : diff)
            maxDiff = std::max(maxDiff, std::fabs(i));
        return maxDiff;
    }

    // Set up, for each cost function, all the ingredients for optimization:
    // constraint, initial guess, end criteria, optimization methods.
    void setup() {

        // Cost function n. 1: 1D polynomial of degree 2 (parabolic function y=a*x^2+b*x+c)
        const Real a = 1;   // required a > 0
        const Real b = 1;
        const Real c = 1;
        Array coefficients(3);
        coefficients[0]= c;
        coefficients[1]= b;
        coefficients[2]= a;
        costFunctions_.push_back(ext::shared_ptr<CostFunction>(
            new OneDimensionalPolynomialDegreeN(coefficients)));
        // Set constraint for optimizers: unconstrained problem
        constraints_.push_back(ext::shared_ptr<Constraint>(new NoConstraint()));
        // Set initial guess for optimizer
        Array initialValue(1);
        initialValue[0] = -100;
        initialValues_.push_back(initialValue);
        // Set end criteria for optimizer
        maxIterations_.push_back(10000);                // maxIterations
        maxStationaryStateIterations_.push_back(100);   // MaxStationaryStateIterations
        rootEpsilons_.push_back(1e-8);                  // rootEpsilon
        functionEpsilons_.push_back(1e-8);              // functionEpsilon
        gradientNormEpsilons_.push_back(1e-8);          // gradientNormEpsilon
        endCriterias_.push_back(ext::make_shared<EndCriteria>(
            maxIterations_.back(), maxStationaryStateIterations_.back(),
                            rootEpsilons_.back(), functionEpsilons_.back(),
                            gradientNormEpsilons_.back()));
        // Set optimization methods for optimizer
        std::vector<OptimizationMethodType> optimizationMethodTypes = {
            simplex, levenbergMarquardt, levenbergMarquardt2, conjugateGradient,
            bfgs //, steepestDescent
        };
        Real simplexLambda = 0.1;                   // characteristic search length for simplex
        Real levenbergMarquardtEpsfcn = 1.0e-8;     // parameters specific for Levenberg-Marquardt
        Real levenbergMarquardtXtol   = 1.0e-8;     //
        Real levenbergMarquardtGtol   = 1.0e-8;     //
        optimizationMethods_.push_back(makeOptimizationMethods(
            optimizationMethodTypes,
            simplexLambda, levenbergMarquardtEpsfcn, levenbergMarquardtXtol,
            levenbergMarquardtGtol));
        // Set expected results for optimizer
        Array xMinExpected(1),yMinExpected(1);
        xMinExpected[0] = -b/(2.0*a);
        yMinExpected[0] = -(b*b-4.0*a*c)/(4.0*a);
        xMinExpected_.push_back(xMinExpected);
        yMinExpected_.push_back(yMinExpected);
    }

}


void OptimizersTest::test() {
    BOOST_TEST_MESSAGE("Testing optimizers...");

    setup();

    // Loop over problems (currently there is only 1 problem)
    for (Size i=0; i<costFunctions_.size(); ++i) {
        Problem problem(*costFunctions_[i], *constraints_[i],
                        initialValues_[i]);
        Array initialValues = problem.currentValue();
        // Loop over optimizers
        for (Size j=0; j<(optimizationMethods_[i]).size(); ++j) {
            Real rootEpsilon = endCriterias_[i]->rootEpsilon();
            Size endCriteriaTests = 1;
           // Loop over rootEpsilon
            for (Size k=0; k<endCriteriaTests; ++k) {
                problem.setCurrentValue(initialValues);
                EndCriteria endCriteria(
                            endCriterias_[i]->maxIterations(),
                            endCriterias_[i]->maxStationaryStateIterations(),
                            rootEpsilon,
                            endCriterias_[i]->functionEpsilon(),
                            endCriterias_[i]->gradientNormEpsilon());
                rootEpsilon *= .1;
                EndCriteria::Type endCriteriaResult =
                    optimizationMethods_[i][j].optimizationMethod->minimize(
                    problem, endCriteria);
                Array xMinCalculated = problem.currentValue();
                Array yMinCalculated = problem.values(xMinCalculated);

                // Check optimization results vs known solution
                bool completed;
                switch (endCriteriaResult) {
                  case EndCriteria::None:
                  case EndCriteria::MaxIterations:
                  case EndCriteria::Unknown:
                    completed = false;
                    break;
                  default:
                    completed = true;
                }

                Real xError = maxDifference(xMinCalculated,xMinExpected_[i]);
                Real yError = maxDifference(yMinCalculated,yMinExpected_[i]);

                bool correct = (xError <= endCriteria.rootEpsilon() ||
                                yError <= endCriteria.functionEpsilon());

                if ((!completed) || (!correct))
                    BOOST_ERROR("costFunction # = " << i <<
                                "\nOptimizer: " <<
                                optimizationMethods_[i][j].name <<
                                "\n    function evaluations: " <<
                                problem.functionEvaluation()  <<
                                "\n    gradient evaluations: " <<
                                problem.gradientEvaluation() <<
                                "\n    x expected:           " <<
                                xMinExpected_[i] <<
                                "\n    x calculated:         " <<
                                std::setprecision(9) << xMinCalculated <<
                                "\n    x difference:         " <<
                                xMinExpected_[i]- xMinCalculated <<
                                "\n    rootEpsilon:          " <<
                                std::setprecision(9) <<
                                endCriteria.rootEpsilon() <<
                                "\n    y expected:           " <<
                                yMinExpected_[i] <<
                                "\n    y calculated:         " <<
                                std::setprecision(9) << yMinCalculated <<
                                "\n    y difference:         " <<
                                yMinExpected_[i]- yMinCalculated <<
                                "\n    functionEpsilon:      " <<
                                std::setprecision(9) <<
                                endCriteria.functionEpsilon() <<
                                "\n    endCriteriaResult:    " <<
                                endCriteriaResult);
            }
        }
    }
}


void OptimizersTest::nestedOptimizationTest() {
    BOOST_TEST_MESSAGE("Testing nested optimizations...");
    OptimizationBasedCostFunction optimizationBasedCostFunction;
    NoConstraint constraint;
    Array initialValues(1, 0.0);
    Problem problem(optimizationBasedCostFunction, constraint,
                    initialValues);
    LevenbergMarquardt optimizationMethod;
    //Simplex optimizationMethod(0.1);
    //ConjugateGradient optimizationMethod;
    //SteepestDescent optimizationMethod;
    EndCriteria endCriteria(1000, 100, 1e-5, 1e-5, 1e-5);
    optimizationMethod.minimize(problem, endCriteria);

}

namespace {

    class FirstDeJong : public CostFunction {
      public:
        Disposable<Array> values(const Array& x) const override {
            Array retVal(x.size(),value(x));
            return retVal;
        }
        Real value(const Array& x) const override { return DotProduct(x, x); }
    };

    class SecondDeJong : public CostFunction {
      public:
        Disposable<Array> values(const Array& x) const override {
            Array retVal(x.size(),value(x));
            return retVal;
        }
        Real value(const Array& x) const override {
            return  100.0*(x[0]*x[0]-x[1])*(x[0]*x[0]-x[1])
                  + (1.0-x[0])*(1.0-x[0]);
        }
    };

    class ModThirdDeJong : public CostFunction {
      public:
        Disposable<Array> values(const Array& x) const override {
            Array retVal(x.size(),value(x));
            return retVal;
        }
        Real value(const Array& x) const override {
            Real fx = 0.0;
            for (double i : x) {
                fx += std::floor(i) * std::floor(i);
            }
            return fx;
        }
    };

    class ModFourthDeJong : public CostFunction {
      public:
        ModFourthDeJong()
        : uniformRng_(MersenneTwisterUniformRng(4711)) {
        }
        Disposable<Array> values(const Array& x) const override {
            Array retVal(x.size(),value(x));
            return retVal;
        }
        Real value(const Array& x) const override {
            Real fx = 0.0;
            for (Size i=0; i<x.size(); ++i) {
                fx += (i+1.0)*pow(x[i],4.0) + uniformRng_.nextReal();
            }
            return fx;
        }
        MersenneTwisterUniformRng uniformRng_;
    };

    class Griewangk : public CostFunction {
      public:
        Disposable<Array> values(const Array& x) const override {
            Array retVal(x.size(),value(x));
            return retVal;
        }
        Real value(const Array& x) const override {
            Real fx = 0.0;
            for (double i : x) {
                fx += i * i / 4000.0;
            }
            Real p = 1.0;
            for (Size i=0; i<x.size(); ++i) {
                p *= cos(x[i]/sqrt(i+1.0));
            }
            return fx - p + 1.0;
        }
    };
}

void OptimizersTest::testDifferentialEvolution() {
    BOOST_TEST_MESSAGE("Testing differential evolution...");

    /* Note:
    *
    * The "ModFourthDeJong" doesn't have a well defined optimum because
    * of its noisy part. It just has to be <= 15 in our example.
    * The concrete value might differ for a different input and
    * different random numbers.
    *
    * The "Griewangk" function is an example where the adaptive
    * version of DifferentialEvolution turns out to be more successful.
    */

    DifferentialEvolution::Configuration conf =
        DifferentialEvolution::Configuration()
        .withStepsizeWeight(0.4)
        .withBounds()
        .withCrossoverProbability(0.35)
        .withPopulationMembers(500)
        .withStrategy(DifferentialEvolution::BestMemberWithJitter)
        .withCrossoverType(DifferentialEvolution::Normal)
        .withAdaptiveCrossover()
        .withSeed(3242);
    DifferentialEvolution deOptim(conf);

    DifferentialEvolution::Configuration conf2 =
        DifferentialEvolution::Configuration()
        .withStepsizeWeight(1.8)
        .withBounds()
        .withCrossoverProbability(0.9)
        .withPopulationMembers(1000)
        .withStrategy(DifferentialEvolution::Rand1SelfadaptiveWithRotation)
        .withCrossoverType(DifferentialEvolution::Normal)
        .withAdaptiveCrossover()
        .withSeed(3242);
    DifferentialEvolution deOptim2(conf2);

    std::vector<DifferentialEvolution > diffEvolOptimisers = {
        deOptim,
        deOptim,
        deOptim,
        deOptim,
        deOptim2
    };

    std::vector<ext::shared_ptr<CostFunction> > costFunctions = {
        ext::shared_ptr<CostFunction>(new FirstDeJong),
        ext::shared_ptr<CostFunction>(new SecondDeJong),
        ext::shared_ptr<CostFunction>(new ModThirdDeJong),
        ext::shared_ptr<CostFunction>(new ModFourthDeJong),
        ext::shared_ptr<CostFunction>(new Griewangk)
    };

    std::vector<BoundaryConstraint> constraints = {
        {-10.0, 10.0},
        {-10.0, 10.0},
        {-10.0, 10.0},
        {-10.0, 10.0},
        {-600.0, 600.0}
    };

    std::vector<Array> initialValues = {
        Array(3, 5.0),
        Array(2, 5.0),
        Array(5, 5.0),
        Array(30, 5.0),
        Array(10, 100.0)
    };

    std::vector<EndCriteria> endCriteria = {
        {100, 10, 1e-10, 1e-8, Null<Real>()},
        {100, 10, 1e-10, 1e-8, Null<Real>()},
        {100, 10, 1e-10, 1e-8, Null<Real>()},
        {500, 100, 1e-10, 1e-8, Null<Real>()},
        {1000, 800, 1e-12, 1e-10, Null<Real>()}
    };

    std::vector<Real> minima = {
        0.0,
        0.0,
        0.0,
        10.9639796558,
        0.0
    };

    for (Size i = 0; i < costFunctions.size(); ++i) {
        Problem problem(*costFunctions[i], constraints[i], initialValues[i]);
        diffEvolOptimisers[i].minimize(problem, endCriteria[i]);

        if (i != 3) {
            // stable
            if (std::fabs(problem.functionValue() - minima[i]) > 1e-8) {
                BOOST_ERROR("costFunction # " << i
                            << "\ncalculated: " << problem.functionValue()
                            << "\nexpected:   " << minima[i]);
            }
        } else {
            // this case is unstable due to randomness; we're good as
            // long as the result is below 15
            if (problem.functionValue() > 15) {
                BOOST_ERROR("costFunction # " << i
                            << "\ncalculated: " << problem.functionValue()
                            << "\nexpected:   " << "less than 15");
            }
        }
    }
}

test_suite* OptimizersTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Optimizers tests");

    suite->add(QUANTLIB_TEST_CASE(&OptimizersTest::test));
    suite->add(QUANTLIB_TEST_CASE(&OptimizersTest::nestedOptimizationTest));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(
            &OptimizersTest::testDifferentialEvolution));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="213">
    <source>optimizers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2012 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_optimizers_hpp
#define quantlib_test_optimizers_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

class OptimizersTest {
  public:
    static void test();
    static void nestedOptimizationTest();
    static void testDifferentialEvolution();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="214">
    <source>optionletstripper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2007, 2008 Laurent Hoffmann
 Copyright (C) 2015, 2016 Michael von den Driesch

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "optionletstripper.hpp"
#include "utilities.hpp"
#include <ql/termstructures/volatility/optionlet/optionletstripper1.hpp>
#include <ql/termstructures/volatility/optionlet/optionletstripper2.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionletadapter.hpp>
#include <ql/termstructures/volatility/capfloor/constantcapfloortermvol.hpp>
#include <ql/termstructures/volatility/capfloor/capfloortermvolcurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/instruments/makecapfloor.hpp>
#include <ql/quotes/simplequote.hpp>
#include <algorithm>
#include <iterator>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace optionlet_stripper_test {

struct CommonVars {
        // global data
        Calendar calendar;
        DayCounter dayCounter;

        RelinkableHandle<YieldTermStructure> yieldTermStructure;
        RelinkableHandle< YieldTermStructure > discountingYTS;
        RelinkableHandle< YieldTermStructure > forwardingYTS;

        std::vector<Rate> strikes;
        std::vector<Period> optionTenors;
        Matrix termV;
        std::vector<Rate> atmTermV;
        std::vector<Handle<Quote> > atmTermVolHandle;

        Handle<CapFloorTermVolCurve> capFloorVolCurve;
        Handle<CapFloorTermVolCurve> flatTermVolCurve;

        ext::shared_ptr<CapFloorTermVolSurface> capFloorVolSurface;
        ext::shared_ptr<CapFloorTermVolSurface> flatTermVolSurface;
        ext::shared_ptr< CapFloorTermVolSurface > capFloorVolRealSurface;

        Real accuracy;
        Real tolerance;

        // cleanup
        SavedSettings backup;

        CommonVars() {
            accuracy = 1.0e-6;
            tolerance = 2.5e-8;
        }

        void setTermStructure() {

            calendar = TARGET();
            dayCounter = Actual365Fixed();

            Rate flatFwdRate = 0.04;
            yieldTermStructure.linkTo(
                ext::make_shared<FlatForward>(0,
                                                               calendar,
                                                               flatFwdRate,
                                                               dayCounter));
        }

        void setRealTermStructure() {

            calendar = TARGET();
            dayCounter = Actual365Fixed();

            std::vector< int > datesTmp = {
                42124, 42129, 42143, 42221, 42254, 42282, 42313, 42345,
                42374, 42405, 42465, 42495, 42587, 42681, 42772, 42860, 43227,
                43956, 44321, 44686, 45051, 45418, 45782, 46147, 46512, 47609,
                49436, 51263, 53087, 56739, 60392
            };

            std::vector< Date > dates;
            dates.reserve(datesTmp.size());
            for (int& it : datesTmp)
                dates.emplace_back(it);

            std::vector< Rate > rates = {
                -0.00292, -0.00292, -0.001441, -0.00117, -0.001204,
                -0.001212, -0.001223, -0.001236, -0.001221, -0.001238,
                -0.001262, -0.00125, -0.001256, -0.001233, -0.00118, -0.001108,
                -0.000619, 0.000833, 0.001617, 0.002414, 0.003183, 0.003883,
                0.004514, 0.005074, 0.005606, 0.006856, 0.00813, 0.008709,
                0.009136, 0.009601, 0.009384
            };

            discountingYTS.linkTo(
                ext::make_shared< InterpolatedZeroCurve< Linear > >(
                    dates, rates,
                                                        dayCounter, calendar));

            datesTmp.clear();
            dates.clear();
            rates.clear();

            datesTmp = {
                42124, 42313, 42436, 42556, 42618, 42800, 42830, 42860,
                43227, 43591, 43956, 44321, 44686, 45051, 45418, 45782, 46147,
                46512, 46878, 47245, 47609, 47973, 48339, 48704, 49069, 49436,
                49800, 50165, 50530, 50895, 51263, 51627, 51991, 52356, 52722,
                53087, 54913, 56739, 60392, 64045
            };

            for (int& it : datesTmp)
                dates.emplace_back(it);

            rates = {
                0.000649, 0.000649, 0.000684, 0.000717, 0.000745, 0.000872,
                0.000905, 0.000954, 0.001532, 0.002319, 0.003147, 0.003949,
                0.004743, 0.00551, 0.006198, 0.006798, 0.007339, 0.007832,
                0.008242, 0.008614, 0.008935, 0.009205, 0.009443, 0.009651,
                0.009818, 0.009952, 0.010054, 0.010146, 0.010206, 0.010266,
                0.010315, 0.010365, 0.010416, 0.010468, 0.010519, 0.010571,
                0.010757, 0.010806, 0.010423, 0.010217
            };

            forwardingYTS.linkTo(
                ext::make_shared< InterpolatedZeroCurve< Linear > >(
                    dates, rates, dayCounter, calendar));
        }

        void setFlatTermVolCurve() {

          setTermStructure();

          optionTenors.resize(10);
          for (Size i = 0; i < optionTenors.size(); ++i)
              optionTenors[i] = Period(i + 1, Years);

          Volatility flatVol = .18;

          std::vector<Handle<Quote> >  curveVHandle(optionTenors.size());
          for (Size i=0; i<optionTenors.size(); ++i)
              curveVHandle[i] = Handle<Quote>(ext::shared_ptr<Quote>(new
                                                        SimpleQuote(flatVol)));

          flatTermVolCurve = Handle<CapFloorTermVolCurve>(
              ext::make_shared<CapFloorTermVolCurve>(0, calendar, Following, optionTenors,
                                       curveVHandle, dayCounter));

        }

        void setFlatTermVolSurface() {

            setTermStructure();

            optionTenors.resize(10);
            for (Size i = 0; i < optionTenors.size(); ++i)
                optionTenors[i] = Period(i + 1, Years);

            strikes.resize(10);
            for (Size j = 0; j < strikes.size(); ++j)
                strikes[j] = Real(j + 1) / 100.0;

            Volatility flatVol = .18;
            termV = Matrix(optionTenors.size(), strikes.size(), flatVol);
            flatTermVolSurface = ext::make_shared<CapFloorTermVolSurface>(0, calendar, Following,
                                       optionTenors, strikes,
                                       termV, dayCounter);
        }


        void setCapFloorTermVolCurve() {

          setTermStructure();

          //atm cap volatility curve
          optionTenors = {
              {1, Years},
              {18, Months},
              {2, Years},
              {3, Years},
              {4, Years},
              {5, Years},
              {6, Years},
              {7, Years},
              {8, Years},
              {9, Years},
              {10, Years},
              {12, Years},
              {15, Years},
              {20, Years},
              {25, Years},
              {30, Years}
          };

          //atm capfloor vols from mkt vol matrix using flat yield curve
          atmTermV = {
              0.090304,
              0.12180,
              0.13077,
              0.14832,
              0.15570,
              0.15816,
              0.15932,
              0.16035,
              0.15951,
              0.15855,
              0.15754,
              0.15459,
              0.15163,
              0.14575,
              0.14175,
              0.13889
          };

          atmTermVolHandle.resize(optionTenors.size());
          for (Size i=0; i<optionTenors.size(); ++i) {
            atmTermVolHandle[i] = Handle<Quote>(ext::shared_ptr<Quote>(new
                            SimpleQuote(atmTermV[i])));
          }

          capFloorVolCurve = Handle<CapFloorTermVolCurve>(
            ext::make_shared<CapFloorTermVolCurve>(0, calendar, Following,
                                     optionTenors, atmTermVolHandle,
                                     dayCounter));

         }

        void setCapFloorTermVolSurface() {

            setTermStructure();

            //cap volatility smile matrix
            optionTenors = {
                {1, Years},
                {18, Months},
                {2, Years},
                {3, Years},
                {4, Years},
                {5, Years},
                {6, Years},
                {7, Years},
                {8, Years},
                {9, Years},
                {10, Years},
                {12, Years},
                {15, Years},
                {20, Years},
                {25, Years},
                {30, Years}
            };

            strikes = {
                0.015,
                0.0175,
                0.02,
                0.0225,
                0.025,
                0.03,
                0.035,
                0.04,
                0.05,
                0.06,
                0.07,
                0.08,
                0.1
            };

            termV = Matrix(optionTenors.size(), strikes.size());
            termV[0][0]=0.287;  termV[0][1]=0.274;  termV[0][2]=0.256;  termV[0][3]=0.245;  termV[0][4]=0.227;  termV[0][5]=0.148;  termV[0][6]=0.096;  termV[0][7]=0.09;   termV[0][8]=0.11;   termV[0][9]=0.139;  termV[0][10]=0.166;  termV[0][11]=0.19;   termV[0][12]=0.214;
            termV[1][0]=0.303;  termV[1][1]=0.258;  termV[1][2]=0.22;   termV[1][3]=0.203;  termV[1][4]=0.19;   termV[1][5]=0.153;  termV[1][6]=0.126;  termV[1][7]=0.118;  termV[1][8]=0.147;  termV[1][9]=0.165;  termV[1][10]=0.18;   termV[1][11]=0.192;  termV[1][12]=0.212;
            termV[2][0]=0.303;  termV[2][1]=0.257;  termV[2][2]=0.216;  termV[2][3]=0.196;  termV[2][4]=0.182;  termV[2][5]=0.154;  termV[2][6]=0.134;  termV[2][7]=0.127;  termV[2][8]=0.149;  termV[2][9]=0.166;  termV[2][10]=0.18;   termV[2][11]=0.192;  termV[2][12]=0.212;
            termV[3][0]=0.305;  termV[3][1]=0.266;  termV[3][2]=0.226;  termV[3][3]=0.203;  termV[3][4]=0.19;   termV[3][5]=0.167;  termV[3][6]=0.151;  termV[3][7]=0.144;  termV[3][8]=0.16;   termV[3][9]=0.172;  termV[3][10]=0.183;  termV[3][11]=0.193;  termV[3][12]=0.209;
            termV[4][0]=0.294;  termV[4][1]=0.261;  termV[4][2]=0.216;  termV[4][3]=0.201;  termV[4][4]=0.19;   termV[4][5]=0.171;  termV[4][6]=0.158;  termV[4][7]=0.151;  termV[4][8]=0.163;  termV[4][9]=0.172;  termV[4][10]=0.181;  termV[4][11]=0.188;  termV[4][12]=0.201;
            termV[5][0]=0.276;  termV[5][1]=0.248;  termV[5][2]=0.212;  termV[5][3]=0.199;  termV[5][4]=0.189;  termV[5][5]=0.172;  termV[5][6]=0.16;   termV[5][7]=0.155;  termV[5][8]=0.162;  termV[5][9]=0.17;   termV[5][10]=0.177;  termV[5][11]=0.183;  termV[5][12]=0.195;
            termV[6][0]=0.26;   termV[6][1]=0.237;  termV[6][2]=0.21;   termV[6][3]=0.198;  termV[6][4]=0.188;  termV[6][5]=0.172;  termV[6][6]=0.161;  termV[6][7]=0.156;  termV[6][8]=0.161;  termV[6][9]=0.167;  termV[6][10]=0.173;  termV[6][11]=0.179;  termV[6][12]=0.19;
            termV[7][0]=0.25;   termV[7][1]=0.231;  termV[7][2]=0.208;  termV[7][3]=0.196;  termV[7][4]=0.187;  termV[7][5]=0.172;  termV[7][6]=0.162;  termV[7][7]=0.156;  termV[7][8]=0.16;   termV[7][9]=0.165;  termV[7][10]=0.17;   termV[7][11]=0.175;  termV[7][12]=0.185;
            termV[8][0]=0.244;  termV[8][1]=0.226;  termV[8][2]=0.206;  termV[8][3]=0.195;  termV[8][4]=0.186;  termV[8][5]=0.171;  termV[8][6]=0.161;  termV[8][7]=0.156;  termV[8][8]=0.158;  termV[8][9]=0.162;  termV[8][10]=0.166;  termV[8][11]=0.171;  termV[8][12]=0.18;
            termV[9][0]=0.239;  termV[9][1]=0.222;  termV[9][2]=0.204;  termV[9][3]=0.193;  termV[9][4]=0.185;  termV[9][5]=0.17;   termV[9][6]=0.16;   termV[9][7]=0.155;  termV[9][8]=0.156;  termV[9][9]=0.159;  termV[9][10]=0.163;  termV[9][11]=0.168;  termV[9][12]=0.177;
            termV[10][0]=0.235; termV[10][1]=0.219; termV[10][2]=0.202; termV[10][3]=0.192; termV[10][4]=0.183; termV[10][5]=0.169; termV[10][6]=0.159; termV[10][7]=0.154; termV[10][8]=0.154; termV[10][9]=0.156; termV[10][10]=0.16;  termV[10][11]=0.164; termV[10][12]=0.173;
            termV[11][0]=0.227; termV[11][1]=0.212; termV[11][2]=0.197; termV[11][3]=0.187; termV[11][4]=0.179; termV[11][5]=0.166; termV[11][6]=0.156; termV[11][7]=0.151; termV[11][8]=0.149; termV[11][9]=0.15;  termV[11][10]=0.153; termV[11][11]=0.157; termV[11][12]=0.165;
            termV[12][0]=0.22;  termV[12][1]=0.206; termV[12][2]=0.192; termV[12][3]=0.183; termV[12][4]=0.175; termV[12][5]=0.162; termV[12][6]=0.153; termV[12][7]=0.147; termV[12][8]=0.144; termV[12][9]=0.144; termV[12][10]=0.147; termV[12][11]=0.151; termV[12][12]=0.158;
            termV[13][0]=0.211; termV[13][1]=0.197; termV[13][2]=0.185; termV[13][3]=0.176; termV[13][4]=0.168; termV[13][5]=0.156; termV[13][6]=0.147; termV[13][7]=0.142; termV[13][8]=0.138; termV[13][9]=0.138; termV[13][10]=0.14;  termV[13][11]=0.144; termV[13][12]=0.151;
            termV[14][0]=0.204; termV[14][1]=0.192; termV[14][2]=0.18;  termV[14][3]=0.171; termV[14][4]=0.164; termV[14][5]=0.152; termV[14][6]=0.143; termV[14][7]=0.138; termV[14][8]=0.134; termV[14][9]=0.134; termV[14][10]=0.137; termV[14][11]=0.14;  termV[14][12]=0.148;
            termV[15][0]=0.2;   termV[15][1]=0.187; termV[15][2]=0.176; termV[15][3]=0.167; termV[15][4]=0.16;  termV[15][5]=0.148; termV[15][6]=0.14;  termV[15][7]=0.135; termV[15][8]=0.131; termV[15][9]=0.132; termV[15][10]=0.135; termV[15][11]=0.139; termV[15][12]=0.146;

            capFloorVolSurface = ext::make_shared<CapFloorTermVolSurface>(0, calendar, Following,
                                       optionTenors, strikes,
                                       termV, dayCounter);
        }

        void setRealCapFloorTermVolSurface() {

            setRealTermStructure();

            // cap volatility smile matrix
            optionTenors = {
                {1, Years},
                {18, Months},
                {2, Years},
                {3, Years},
                {4, Years},
                {5, Years},
                {6, Years},
                {7, Years},
                {8, Years},
                {9, Years},
                {10, Years},
                {12, Years},
                {15, Years},
                {20, Years},
                {25, Years},
                {30, Years}
            };
            // 16

            strikes = {
                -0.005,
                -0.0025,
                -0.00125,
                0.0,
                0.00125,
                0.0025,
                0.005,
                0.01,
                0.015,
                0.02,
                0.03,
                0.05,
                0.1
            };
            // 13

            std::vector< Real > rawVols = {
                0.49, 0.39, 0.34, 0.31, 0.34, 0.37, 0.50, 0.75, 0.99, 1.21, 1.64, 2.44, 4.29,
                0.44, 0.36, 0.33, 0.31, 0.33, 0.35,0.45, 0.65, 0.83, 1.00, 1.32, 1.93, 3.30,
                0.40, 0.35, 0.33,0.31, 0.33, 0.34, 0.41, 0.55, 0.69, 0.82, 1.08, 1.56, 2.68,
                0.42, 0.39, 0.38, 0.37, 0.38, 0.39, 0.43, 0.54, 0.64, 0.74,0.94, 1.31, 2.18,
                0.46, 0.43, 0.42, 0.41, 0.42, 0.43, 0.47,0.56, 0.66, 0.75, 0.93, 1.28, 2.07,
                0.49, 0.47, 0.46, 0.45,0.46, 0.47, 0.51, 0.59, 0.68, 0.76, 0.93, 1.25, 1.99,
                0.51, 0.49, 0.49, 0.48, 0.49, 0.50, 0.54, 0.62, 0.70, 0.78, 0.94,1.24, 1.94,
                0.52, 0.51, 0.51, 0.51, 0.52, 0.53, 0.56, 0.63,0.71, 0.79, 0.94, 1.23, 1.89,
                0.53, 0.52, 0.52, 0.52, 0.53,0.54, 0.57, 0.65, 0.72, 0.79, 0.94, 1.21, 1.83,
                0.55, 0.54, 0.54, 0.54, 0.55, 0.56, 0.59, 0.66, 0.72, 0.79, 0.91, 1.15,1.71,
                0.56, 0.56, 0.56, 0.56, 0.57, 0.58, 0.61, 0.67, 0.72,0.78, 0.89, 1.09, 1.59,
                0.59, 0.58, 0.58, 0.59, 0.59, 0.60,0.63, 0.68, 0.73, 0.78, 0.86, 1.03, 1.45,
                0.61, 0.61, 0.61,0.61, 0.62, 0.62, 0.64, 0.69, 0.73, 0.77, 0.85, 1.02, 1.44,
                0.62, 0.62, 0.63, 0.63, 0.64, 0.64, 0.65, 0.69, 0.72, 0.76,0.82, 0.96, 1.32,
                0.62, 0.63, 0.63, 0.63, 0.65, 0.66, 0.66,0.68, 0.72, 0.74, 0.80, 0.93, 1.25,
                0.62, 0.62, 0.62, 0.62,0.66, 0.67, 0.67, 0.67, 0.72, 0.72, 0.78, 0.90, 1.25
            };

            termV = Matrix(optionTenors.size(), strikes.size());
            std::copy(rawVols.begin(), rawVols.end(), termV.begin());
            termV /= 100;

            capFloorVolRealSurface =
                ext::make_shared< CapFloorTermVolSurface >(
                    0, calendar, Following,
                                               optionTenors, strikes, termV,
                                               dayCounter);
        }
};
}

void OptionletStripperTest::testFlatTermVolatilityStripping1() {

    BOOST_TEST_MESSAGE(
        "Testing forward/forward vol stripping from flat term vol "
        "surface using OptionletStripper1 class...");

    using namespace optionlet_stripper_test;

    CommonVars vars;
    Settings::instance().evaluationDate() = Date(28, October, 2013);

    vars.setFlatTermVolSurface();

    ext::shared_ptr<IborIndex> iborIndex(new Euribor6M(vars.yieldTermStructure));

    ext::shared_ptr<OptionletStripper> optionletStripper1(new
        OptionletStripper1(vars.flatTermVolSurface,
                           iborIndex,
                           Null<Rate>(),
                           vars.accuracy));

    ext::shared_ptr<StrippedOptionletAdapter> strippedOptionletAdapter(new
        StrippedOptionletAdapter(optionletStripper1));

    Handle<OptionletVolatilityStructure> vol(strippedOptionletAdapter);

    vol->enableExtrapolation();

    ext::shared_ptr<BlackCapFloorEngine> strippedVolEngine(new
        BlackCapFloorEngine(vars.yieldTermStructure,
                            vol));

    ext::shared_ptr<CapFloor> cap;
    for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {
        for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
            cap = MakeCapFloor(CapFloor::Cap,
                               vars.optionTenors[tenorIndex],
                               iborIndex,
                               vars.strikes[strikeIndex],
                               0*Days)
                  .withPricingEngine(strippedVolEngine);

            Real priceFromStrippedVolatility = cap->NPV();

            ext::shared_ptr<PricingEngine> blackCapFloorEngineConstantVolatility(new
                BlackCapFloorEngine(vars.yieldTermStructure,
                                    vars.termV[tenorIndex][strikeIndex]));

            cap->setPricingEngine(blackCapFloorEngineConstantVolatility);
            Real priceFromConstantVolatility = cap->NPV();

            Real error = std::fabs(priceFromStrippedVolatility - priceFromConstantVolatility);
            if (error>vars.tolerance)
                BOOST_FAIL("\noption tenor:       " << vars.optionTenors[tenorIndex] <<
                           "\nstrike:             " << io::rate(vars.strikes[strikeIndex]) <<
                           "\nstripped vol price: " << io::rate(priceFromStrippedVolatility) <<
                           "\nconstant vol price: " << io::rate(priceFromConstantVolatility) <<
                           "\nerror:              " << io::rate(error) <<
                           "\ntolerance:          " << io::rate(vars.tolerance));
            }
    }
}

void OptionletStripperTest::testTermVolatilityStripping1() {

    BOOST_TEST_MESSAGE(
        "Testing forward/forward vol stripping from non-flat term "
        "vol surface using OptionletStripper1 class...");

    using namespace optionlet_stripper_test;

    CommonVars vars;
    Settings::instance().evaluationDate() = Date(28, October, 2013);

    vars.setCapFloorTermVolSurface();

    ext::shared_ptr<IborIndex> iborIndex(new Euribor6M(vars.yieldTermStructure));

    ext::shared_ptr<OptionletStripper> optionletStripper1(new
        OptionletStripper1(vars.capFloorVolSurface,
                           iborIndex,
                           Null<Rate>(),
                           vars.accuracy));

    ext::shared_ptr<StrippedOptionletAdapter> strippedOptionletAdapter =
        ext::make_shared<StrippedOptionletAdapter>(optionletStripper1);

    Handle<OptionletVolatilityStructure> vol(strippedOptionletAdapter);

    vol->enableExtrapolation();

    ext::shared_ptr<BlackCapFloorEngine> strippedVolEngine(new
        BlackCapFloorEngine(vars.yieldTermStructure,
                            vol));

    ext::shared_ptr<CapFloor> cap;
    for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {
        for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
            cap = MakeCapFloor(CapFloor::Cap,
                               vars.optionTenors[tenorIndex],
                               iborIndex,
                               vars.strikes[strikeIndex],
                               0*Days)
                  .withPricingEngine(strippedVolEngine);

            Real priceFromStrippedVolatility = cap->NPV();

            ext::shared_ptr<PricingEngine> blackCapFloorEngineConstantVolatility(new
                BlackCapFloorEngine(vars.yieldTermStructure,
                                    vars.termV[tenorIndex][strikeIndex]));

            cap->setPricingEngine(blackCapFloorEngineConstantVolatility);
            Real priceFromConstantVolatility = cap->NPV();

            Real error = std::fabs(priceFromStrippedVolatility - priceFromConstantVolatility);
            if (error>vars.tolerance)
                BOOST_FAIL("\noption tenor:       " << vars.optionTenors[tenorIndex] <<
                           "\nstrike:             " << io::rate(vars.strikes[strikeIndex]) <<
                           "\nstripped vol price: " << io::rate(priceFromStrippedVolatility) <<
                           "\nconstant vol price: " << io::rate(priceFromConstantVolatility) <<
                           "\nerror:              " << io::rate(error) <<
                           "\ntolerance:          " << io::rate(vars.tolerance));
            }
    }
}

void OptionletStripperTest::testTermVolatilityStrippingNormalVol() {

    BOOST_TEST_MESSAGE(
        "Testing forward/forward vol stripping from non-flat normal vol term "
        "vol surface for normal vol setup using OptionletStripper1 class...");

    using namespace optionlet_stripper_test;

    CommonVars vars;
    Settings::instance().evaluationDate() = Date(30, April, 2015);

    vars.setRealCapFloorTermVolSurface();

    ext::shared_ptr< IborIndex > iborIndex(new Euribor6M(vars.forwardingYTS));

    ext::shared_ptr< OptionletStripper > optionletStripper1(
        new OptionletStripper1(vars.capFloorVolRealSurface, iborIndex,
                               Null< Rate >(), vars.accuracy, 100,
                               vars.discountingYTS, Normal));

    ext::shared_ptr< StrippedOptionletAdapter > strippedOptionletAdapter =
        ext::make_shared< StrippedOptionletAdapter >(
            optionletStripper1);

    Handle< OptionletVolatilityStructure > vol(strippedOptionletAdapter);

    vol->enableExtrapolation();

    ext::shared_ptr< BachelierCapFloorEngine > strippedVolEngine(
        new BachelierCapFloorEngine(vars.discountingYTS, vol));

    ext::shared_ptr< CapFloor > cap;
    for (Size tenorIndex = 0; tenorIndex < vars.optionTenors.size();
         ++tenorIndex) {
        for (Size strikeIndex = 0; strikeIndex < vars.strikes.size();
             ++strikeIndex) {
            cap = MakeCapFloor(CapFloor::Cap, vars.optionTenors[tenorIndex],
                               iborIndex, vars.strikes[strikeIndex],
                               0 * Days).withPricingEngine(strippedVolEngine);

            Real priceFromStrippedVolatility = cap->NPV();

            ext::shared_ptr< PricingEngine >
                bachelierCapFloorEngineConstantVolatility(
                    new BachelierCapFloorEngine(
                        vars.discountingYTS,
                        vars.termV[tenorIndex][strikeIndex]));

            cap->setPricingEngine(bachelierCapFloorEngineConstantVolatility);
            Real priceFromConstantVolatility = cap->NPV();

            Real error = std::fabs(priceFromStrippedVolatility -
                                   priceFromConstantVolatility);
            if (error > vars.tolerance)
                BOOST_FAIL(
                    "\noption tenor:       "
                    << vars.optionTenors[tenorIndex] << "\nstrike:             "
                    << io::rate(vars.strikes[strikeIndex])
                    << "\nstripped vol price: "
                    << io::rate(priceFromStrippedVolatility)
                    << "\nconstant vol price: "
                    << io::rate(priceFromConstantVolatility)
                    << "\nerror:              " << io::rate(error)
                    << "\ntolerance:          " << io::rate(vars.tolerance));
        }
    }
}

void OptionletStripperTest::testTermVolatilityStrippingShiftedLogNormalVol() {

    BOOST_TEST_MESSAGE(
        "Testing forward/forward vol stripping from non-flat normal vol term "
        "vol surface for normal vol setup using OptionletStripper1 class...");

    using namespace optionlet_stripper_test;

    CommonVars vars;
    Real shift = 0.03;
    Settings::instance().evaluationDate() = Date(30, April, 2015);

    vars.setRealCapFloorTermVolSurface();

    ext::shared_ptr< IborIndex > iborIndex(new Euribor6M(vars.forwardingYTS));

    ext::shared_ptr< OptionletStripper > optionletStripper1(
        new OptionletStripper1(vars.capFloorVolRealSurface, iborIndex,
                               Null< Rate >(), vars.accuracy, 100,
                               vars.discountingYTS, ShiftedLognormal, shift,
                               true));

    ext::shared_ptr< StrippedOptionletAdapter > strippedOptionletAdapter =
        ext::make_shared< StrippedOptionletAdapter >(
            optionletStripper1);

    Handle< OptionletVolatilityStructure > vol(strippedOptionletAdapter);

    vol->enableExtrapolation();

    ext::shared_ptr< BlackCapFloorEngine > strippedVolEngine(
        new BlackCapFloorEngine(vars.discountingYTS, vol));

    ext::shared_ptr< CapFloor > cap;
    for (Size strikeIndex = 0; strikeIndex < vars.strikes.size();
         ++strikeIndex) {
        for (Size tenorIndex = 0; tenorIndex < vars.optionTenors.size();
             ++tenorIndex) {
            cap = MakeCapFloor(CapFloor::Cap, vars.optionTenors[tenorIndex],
                               iborIndex, vars.strikes[strikeIndex],
                               0 * Days).withPricingEngine(strippedVolEngine);

            Real priceFromStrippedVolatility = cap->NPV();

            ext::shared_ptr< PricingEngine >
                blackCapFloorEngineConstantVolatility(new BlackCapFloorEngine(
                    vars.discountingYTS, vars.termV[tenorIndex][strikeIndex],
                    vars.capFloorVolRealSurface->dayCounter(), shift));

            cap->setPricingEngine(blackCapFloorEngineConstantVolatility);
            Real priceFromConstantVolatility = cap->NPV();

            Real error = std::fabs(priceFromStrippedVolatility -
                                   priceFromConstantVolatility);
            if (error > vars.tolerance)
                BOOST_FAIL(
                    "\noption tenor:       "
                    << vars.optionTenors[tenorIndex] << "\nstrike:             "
                    << io::rate(vars.strikes[strikeIndex])
                    << "\nstripped vol price: "
                    << io::rate(priceFromStrippedVolatility)
                    << "\nconstant vol price: "
                    << io::rate(priceFromConstantVolatility)
                    << "\nerror:              " << io::rate(error)
                    << "\ntolerance:          " << io::rate(vars.tolerance));
        }
    }
}

void OptionletStripperTest::testFlatTermVolatilityStripping2() {

  BOOST_TEST_MESSAGE(
        "Testing forward/forward vol stripping from flat term vol "
        "surface using OptionletStripper2 class...");

  using namespace optionlet_stripper_test;

  CommonVars vars;
  Settings::instance().evaluationDate() = Date::todaysDate();

  vars.setFlatTermVolCurve();
  vars.setFlatTermVolSurface();

  ext::shared_ptr<IborIndex> iborIndex(new Euribor6M(vars.yieldTermStructure));

  // optionletstripper1
  ext::shared_ptr<OptionletStripper1> optionletStripper1(new
        OptionletStripper1(vars.flatTermVolSurface,
                           iborIndex,
                           Null<Rate>(),
                           vars.accuracy));

  ext::shared_ptr<StrippedOptionletAdapter> strippedOptionletAdapter1(new
        StrippedOptionletAdapter(optionletStripper1));

  Handle<OptionletVolatilityStructure> vol1(strippedOptionletAdapter1);

  vol1->enableExtrapolation();

  // optionletstripper2
  ext::shared_ptr<OptionletStripper> optionletStripper2(new
        OptionletStripper2(optionletStripper1, vars.flatTermVolCurve));

  ext::shared_ptr<StrippedOptionletAdapter> strippedOptionletAdapter2(new
        StrippedOptionletAdapter(optionletStripper2));

  Handle<OptionletVolatilityStructure> vol2(strippedOptionletAdapter2);

  vol2->enableExtrapolation();

  // consistency check: diff(stripped vol1-stripped vol2)
  for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
    for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {

      Volatility strippedVol1 = vol1->volatility(vars.optionTenors[tenorIndex],
                                                 vars.strikes[strikeIndex], true);

      Volatility strippedVol2 = vol2->volatility(vars.optionTenors[tenorIndex],
                                                 vars.strikes[strikeIndex], true);

      // vol from flat vol surface (for comparison only)
      Volatility flatVol = vars.flatTermVolSurface->volatility(vars.optionTenors[tenorIndex],
                                                               vars.strikes[strikeIndex], true);

    Real error = std::fabs(strippedVol1-strippedVol2);
      if (error>vars.tolerance)
      BOOST_FAIL("\noption tenor:  " << vars.optionTenors[tenorIndex] <<
                 "\nstrike:        " << io::rate(vars.strikes[strikeIndex]) <<
                 "\nstripped vol1: " << io::rate(strippedVol1) <<
                 "\nstripped vol2: " << io::rate(strippedVol2) <<
                 "\nflat vol:      " << io::rate(flatVol) <<
                 "\nerror:         " << io::rate(error) <<
                 "\ntolerance:     " << io::rate(vars.tolerance));
    }
  }

}

void OptionletStripperTest::testTermVolatilityStripping2() {

  BOOST_TEST_MESSAGE(
        "Testing forward/forward vol stripping from non-flat term vol "
        "surface using OptionletStripper2 class...");

  using namespace optionlet_stripper_test;

  CommonVars vars;
  Settings::instance().evaluationDate() = Date::todaysDate();

  vars.setCapFloorTermVolCurve();
  vars.setCapFloorTermVolSurface();

  ext::shared_ptr<IborIndex> iborIndex(new Euribor6M(vars.yieldTermStructure));

  // optionletstripper1
  ext::shared_ptr<OptionletStripper1> optionletStripper1(new
        OptionletStripper1(vars.capFloorVolSurface,
                           iborIndex,
                           Null<Rate>(),
                           vars.accuracy));

  ext::shared_ptr<StrippedOptionletAdapter> strippedOptionletAdapter1 =
        ext::make_shared<StrippedOptionletAdapter>(optionletStripper1);

  Handle<OptionletVolatilityStructure> vol1(strippedOptionletAdapter1);
  vol1->enableExtrapolation();

  // optionletstripper2
  ext::shared_ptr<OptionletStripper> optionletStripper2(new
                OptionletStripper2(optionletStripper1,
                                   vars.capFloorVolCurve));

  ext::shared_ptr<StrippedOptionletAdapter> strippedOptionletAdapter2(new
        StrippedOptionletAdapter(optionletStripper2));

  Handle<OptionletVolatilityStructure> vol2(strippedOptionletAdapter2);
  vol2->enableExtrapolation();

  // consistency check: diff(stripped vol1-stripped vol2)
  for (Size strikeIndex=0; strikeIndex<vars.strikes.size(); ++strikeIndex) {
    for (Size tenorIndex=0; tenorIndex<vars.optionTenors.size(); ++tenorIndex) {

      Volatility strippedVol1 = vol1->volatility(vars.optionTenors[tenorIndex],
                                                 vars.strikes[strikeIndex], true);

      Volatility strippedVol2 = vol2->volatility(vars.optionTenors[tenorIndex],
                                                 vars.strikes[strikeIndex], true);

      // vol from flat vol surface (for comparison only)
      Volatility flatVol = vars.capFloorVolSurface->volatility(vars.optionTenors[tenorIndex],
                                                               vars.strikes[strikeIndex], true);

      Real error = std::fabs(strippedVol1-strippedVol2);
      if (error>vars.tolerance)
      BOOST_FAIL("\noption tenor:  " << vars.optionTenors[tenorIndex] <<
                 "\nstrike:        " << io::rate(vars.strikes[strikeIndex]) <<
                 "\nstripped vol1: " << io::rate(strippedVol1) <<
                 "\nstripped vol2: " << io::rate(strippedVol2) <<
                 "\nflat vol:      " << io::rate(flatVol) <<
                 "\nerror:         " << io::rate(error) <<
                 "\ntolerance:     " << io::rate(vars.tolerance));
    }
  }
}

void OptionletStripperTest::testSwitchStrike() {
    BOOST_TEST_MESSAGE("Testing switch strike level and recalibration of level "
                       "in case of curve relinking...");

    using namespace optionlet_stripper_test;

    CommonVars vars;
    Settings::instance().evaluationDate() = Date(28, October, 2013);
    vars.setCapFloorTermVolSurface();

    RelinkableHandle< YieldTermStructure > yieldTermStructure;
    yieldTermStructure.linkTo(ext::make_shared< FlatForward >(
        0, vars.calendar, 0.03, vars.dayCounter));

    ext::shared_ptr< IborIndex > iborIndex(new Euribor6M(yieldTermStructure));

    ext::shared_ptr< OptionletStripper1 > optionletStripper1(
        new OptionletStripper1(vars.capFloorVolSurface, iborIndex,
                               Null< Rate >(), vars.accuracy));

    Real expected;
    if (!IborCoupon::usingAtParCoupons())
        expected = 0.02981258;
    else
        expected = 0.02981223;

    Real error = std::fabs(optionletStripper1->switchStrike() - expected);
    if (error > vars.tolerance)
        BOOST_FAIL("\nSwitchstrike not correctly computed:  "
                   << "\nexpected switch strike: " << io::rate(expected)
                   << "\ncomputed switch strike: "
                   << io::rate(optionletStripper1->switchStrike())
                   << "\nerror:         " << io::rate(error)
                   << "\ntolerance:     " << io::rate(vars.tolerance));

    yieldTermStructure.linkTo(ext::make_shared< FlatForward >(
        0, vars.calendar, 0.05, vars.dayCounter));

    if (!IborCoupon::usingAtParCoupons())
        expected = 0.0499381;
    else
        expected = 0.0499371;

    error = std::fabs(optionletStripper1->switchStrike() - expected);
    if (error > vars.tolerance)
        BOOST_FAIL("\nSwitchstrike not correctly computed:  "
                   << "\nexpected switch strike: " << io::rate(expected)
                   << "\ncomputed switch strike: "
                   << io::rate(optionletStripper1->switchStrike())
                   << "\nerror:         " << io::rate(error)
                   << "\ntolerance:     " << io::rate(vars.tolerance));
}

test_suite* OptionletStripperTest::suite() {
    auto* suite = BOOST_TEST_SUITE("OptionletStripper Tests");
    suite->add(QUANTLIB_TEST_CASE(
                   &OptionletStripperTest::testFlatTermVolatilityStripping1));
    suite->add(QUANTLIB_TEST_CASE(
                       &OptionletStripperTest::testTermVolatilityStripping1));
    suite->add(QUANTLIB_TEST_CASE(
                   &OptionletStripperTest::testFlatTermVolatilityStripping2));
    suite->add(QUANTLIB_TEST_CASE(
                       &OptionletStripperTest::testTermVolatilityStripping2));
    suite->add(QUANTLIB_TEST_CASE(
                       &OptionletStripperTest::testSwitchStrike));
    suite->add(QUANTLIB_TEST_CASE(
        &OptionletStripperTest::testTermVolatilityStrippingNormalVol));
    suite->add(QUANTLIB_TEST_CASE(
        &OptionletStripperTest::testTermVolatilityStrippingShiftedLogNormalVol));

    return suite;
}
]]></document_content>
  </document>
  <document index="215">
    <source>optionletstripper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2007, 2008 Laurent Hoffmann
 Copyright (C) 2015, 2016 Michael von den Driesch

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_optionletstripper_hpp
#define quantlib_test_optionletstripper_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class OptionletStripperTest {
  public:
    static void testFlatTermVolatilityStripping1();
    static void testTermVolatilityStripping1();
    static void testTermVolatilityStrippingNormalVol();
    static void testTermVolatilityStrippingShiftedLogNormalVol();
    static void testFlatTermVolatilityStripping2();
    static void testTermVolatilityStripping2();
    static void testSwitchStrike();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="216">
    <source>overnightindexedswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "overnightindexedswap.hpp"
#include "utilities.hpp"

#include <ql/termstructures/yield/oisratehelper.hpp>
#include <ql/instruments/makeois.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/ibor/eonia.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/ibor/fedfunds.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/currencies/europe.hpp>
#include <ql/utilities/dataformatters.hpp>

#include <iostream>
#include <iomanip>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::exp;

typedef PiecewiseYieldCurve<Discount,LogLinear> PiecewiseFlatForward;

namespace overnight_indexed_swap_test {

    struct Datum {
        Integer settlementDays;
        Integer n;
        TimeUnit unit;
        Rate rate;
    };

    Datum depositData[] = {
        { 0, 1, Days, 1.10 },
        { 1, 1, Days, 1.10 },
        { 2, 1, Weeks, 1.40 },
        { 2, 2, Weeks, 1.50 },
        { 2, 1, Months, 1.70 },
        { 2, 2, Months, 1.90 },
        { 2, 3, Months, 2.05 },
        { 2, 4, Months, 2.08 },
        { 2, 5, Months, 2.11 },
        { 2, 6, Months, 2.13 }
    };

    Datum eoniaSwapData[] = {
        { 2,  1, Weeks, 1.245 },
        { 2,  2, Weeks, 1.269 },
        { 2,  3, Weeks, 1.277 },
        { 2,  1, Months, 1.281 },
        { 2,  2, Months, 1.18 },
        { 2,  3, Months, 1.143 },
        { 2,  4, Months, 1.125 },
        { 2,  5, Months, 1.116 },
        { 2,  6, Months, 1.111 },
        { 2,  7, Months, 1.109 },
        { 2,  8, Months, 1.111 },
        { 2,  9, Months, 1.117 },
        { 2, 10, Months, 1.129 },
        { 2, 11, Months, 1.141 },
        { 2, 12, Months, 1.153 },
        { 2, 15, Months, 1.218 },
        { 2, 18, Months, 1.308 },
        { 2, 21, Months, 1.407 },
        { 2,  2,  Years, 1.510 },
        { 2,  3,  Years, 1.916 },
        { 2,  4,  Years, 2.254 },
        { 2,  5,  Years, 2.523 },
        { 2,  6,  Years, 2.746 },
        { 2,  7,  Years, 2.934 },
        { 2,  8,  Years, 3.092 },
        { 2,  9,  Years, 3.231 },
        { 2, 10,  Years, 3.380 },
        { 2, 11,  Years, 3.457 },
        { 2, 12,  Years, 3.544 },
        { 2, 15,  Years, 3.702 },
        { 2, 20,  Years, 3.703 },
        { 2, 25,  Years, 3.541 },
        { 2, 30,  Years, 3.369 }
    };

    struct CommonVars {
        // global data
        Date today, settlement;
        Swap::Type type;
        Real nominal;
        Calendar calendar;
        Natural settlementDays;

        Period fixedEoniaPeriod, floatingEoniaPeriod;
        DayCounter fixedEoniaDayCount;
        BusinessDayConvention fixedEoniaConvention, floatingEoniaConvention;
        ext::shared_ptr<Eonia> eoniaIndex;
        RelinkableHandle<YieldTermStructure> eoniaTermStructure;

        Frequency fixedSwapFrequency;
        DayCounter fixedSwapDayCount;
        BusinessDayConvention fixedSwapConvention;
        ext::shared_ptr<IborIndex> swapIndex;
        RelinkableHandle<YieldTermStructure> swapTermStructure;

        // cleanup
        SavedSettings backup;

        // utilities
        ext::shared_ptr<OvernightIndexedSwap>
        makeSwap(Period length,
                 Rate fixedRate,
                 Spread spread,
                 bool telescopicValueDates,
                 Date effectiveDate = Null<Date>(),
                 Natural paymentLag = 0,
                 RateAveraging::Type averagingMethod = RateAveraging::Compound) {
            return MakeOIS(length, eoniaIndex, fixedRate, 0 * Days)
                .withEffectiveDate(effectiveDate == Null<Date>() ? settlement : effectiveDate)
                .withOvernightLegSpread(spread)
                .withNominal(nominal)
                .withPaymentLag(paymentLag)
                .withDiscountingTermStructure(eoniaTermStructure)
                .withTelescopicValueDates(telescopicValueDates)
                .withAveragingMethod(averagingMethod);
        }

        CommonVars() {
            type = Swap::Payer;
            settlementDays = 2;
            nominal = 100.0;
            fixedEoniaConvention = ModifiedFollowing;
            floatingEoniaConvention = ModifiedFollowing;
            fixedEoniaPeriod = 1*Years;
            floatingEoniaPeriod = 1*Years;
            fixedEoniaDayCount = Actual360();
            eoniaIndex = ext::make_shared<Eonia>(eoniaTermStructure);
            fixedSwapConvention = ModifiedFollowing;
            fixedSwapFrequency = Annual;
            fixedSwapDayCount = Thirty360(Thirty360::BondBasis);
            swapIndex = ext::shared_ptr<IborIndex>(new Euribor3M(swapTermStructure));
            calendar = eoniaIndex->fixingCalendar();
            today = Date(5, February, 2009);
            //today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today,settlementDays*Days,Following);
            eoniaTermStructure.linkTo(flatRate(today, 0.05,
                                               Actual365Fixed()));
        }
    };

}


void OvernightIndexedSwapTest::testFairRate() {

    BOOST_TEST_MESSAGE("Testing Eonia-swap calculation of fair fixed rate...");

    using namespace overnight_indexed_swap_test;

    CommonVars vars;

    Period lengths[] = { 1*Years, 2*Years, 5*Years, 10*Years, 20*Years };
    Spread spreads[] = { -0.001, -0.01, 0.0, 0.01, 0.001 };

    for (auto& length : lengths) {
        for (double spread : spreads) {

            ext::shared_ptr<OvernightIndexedSwap> swap = vars.makeSwap(length, 0.0, spread, false);
            ext::shared_ptr<OvernightIndexedSwap> swap2 = vars.makeSwap(length, 0.0, spread, true);
            if(std::fabs(swap->fairRate()-swap2->fairRate()) > 1.0e-10) {
                BOOST_ERROR("fair rates are different:\n"
                            << std::setprecision(2) << "    length: " << length << " \n"
                            << "    floating spread: " << io::rate(spread) << "\n"
                            << std::setprecision(12)
                            << "    fair rate (non telescopic value dates): " << swap->fairRate()
                            << "\n"
                            << "    fair rate (telescopic value dates)    : " << swap2->fairRate());
            }
            swap = vars.makeSwap(length, swap->fairRate(), spread, false);
            if (std::fabs(swap->NPV()) > 1.0e-10) {
                BOOST_ERROR("recalculating with implied rate (non telescopic value dates):\n"
                            << std::setprecision(2) << "    length: " << length << " \n"
                            << "    floating spread: " << io::rate(spread) << "\n"
                            << "    swap value: " << swap->NPV());
            }
            swap = vars.makeSwap(length, swap->fairRate(), spread, true);
            if (std::fabs(swap->NPV()) > 1.0e-10) {
                BOOST_ERROR("recalculating with implied rate (telescopic value dates):\n"
                            << std::setprecision(2) << "    length: " << length << " \n"
                            << "    floating spread: " << io::rate(spread) << "\n"
                            << "    swap value: " << swap->NPV());
            }
        }
    }
}


void OvernightIndexedSwapTest::testFairSpread() {

    BOOST_TEST_MESSAGE("Testing Eonia-swap calculation of "
                       "fair floating spread...");

    using namespace overnight_indexed_swap_test;

    CommonVars vars;

    Period lengths[] = { 1*Years, 2*Years, 5*Years, 10*Years, 20*Years };
    Rate rates[] = { 0.04, 0.05, 0.06, 0.07 };

    for (auto& length : lengths) {
        for (double j : rates) {

            ext::shared_ptr<OvernightIndexedSwap> swap = vars.makeSwap(length, j, 0.0, false);
            ext::shared_ptr<OvernightIndexedSwap> swap2 = vars.makeSwap(length, j, 0.0, true);
            Spread fairSpread = swap->fairSpread();
            Spread fairSpread2 = swap2->fairSpread();
            if(std::fabs(fairSpread-fairSpread2) > 1.0e-10) {
                BOOST_ERROR(
                    "fair spreads are different:\n"
                    << std::setprecision(2) << "\n     length: " << length
                    << "\n fixed rate: " << io::rate(j)
                    << "\nfair spread (non telescopic value dates): " << io::rate(fairSpread)
                    << "\nfair spread (telescopic value dates)    : " << io::rate(fairSpread2));
            }
            swap = vars.makeSwap(length, j, fairSpread, false);
            if (std::fabs(swap->NPV()) > 1.0e-10) {
                BOOST_ERROR("\nrecalculating with implied spread (non telescopic value dates):"
                            << std::setprecision(2) << "\n     length: " << length
                            << "\n fixed rate: " << io::rate(j) << "\nfair spread: "
                            << io::rate(fairSpread) << "\n swap value: " << swap->NPV());
            }
            swap = vars.makeSwap(length, j, fairSpread, true);
            if (std::fabs(swap->NPV()) > 1.0e-10) {
                BOOST_ERROR("\nrecalculating with implied spread (telescopic value dates):"
                            << std::setprecision(2) << "\n     length: " << length
                            << "\n fixed rate: " << io::rate(j) << "\nfair spread: "
                            << io::rate(fairSpread) << "\n swap value: " << swap->NPV());
            }
        }
    }
}

void OvernightIndexedSwapTest::testCachedValue() {

    BOOST_TEST_MESSAGE("Testing Eonia-swap calculation against cached value...");

    using namespace overnight_indexed_swap_test;

    CommonVars vars;

    Settings::instance().evaluationDate() = vars.today;
    vars.settlement =
        vars.calendar.advance(vars.today,vars.settlementDays,Days);
    Real flat = 0.05;
    vars.eoniaTermStructure.linkTo(flatRate(vars.settlement,flat,Actual360()));
    Real fixedRate = exp(flat) - 1;
    ext::shared_ptr<OvernightIndexedSwap> swap = vars.makeSwap(1*Years, fixedRate, 0.0,false);
    ext::shared_ptr<OvernightIndexedSwap> swap2 = vars.makeSwap(1*Years, fixedRate, 0.0,true);
    Real cachedNPV   = 0.001730450147;
    Real tolerance = 1.0e-11;
    if (std::fabs(swap->NPV()-cachedNPV) > tolerance)
        BOOST_ERROR("\nfailed to reproduce cached swap value (non telescopic value dates):" <<
                    std::fixed << std::setprecision(12) <<
                    "\ncalculated: " << swap->NPV() <<
                    "\n  expected: " << cachedNPV <<
                    "\n tolerance:" << tolerance);
    if (std::fabs(swap2->NPV()-cachedNPV) > tolerance)
        BOOST_ERROR("\nfailed to reproduce cached swap value (telescopic value dates):" <<
                    std::fixed << std::setprecision(12) <<
                    "\ncalculated: " << swap->NPV() <<
                    "\n  expected: " << cachedNPV <<
                    "\n tolerance:" << tolerance);
}

namespace overnight_indexed_swap_test {
    void testBootstrap(bool telescopicValueDates,
                       RateAveraging::Type averagingMethod,
                       Real tolerance = 1.0e-8) {

    CommonVars vars;

    Natural paymentLag = 2;

    std::vector<ext::shared_ptr<RateHelper> > eoniaHelpers;

    ext::shared_ptr<IborIndex> euribor3m(new Euribor3M);
    ext::shared_ptr<Eonia> eonia(new Eonia);

    for (auto& i : depositData) {
        Real rate = 0.01 * i.rate;
        ext::shared_ptr<SimpleQuote> simple = ext::make_shared<SimpleQuote>(rate);
        ext::shared_ptr<Quote> quote (simple);
        Period term = i.n * i.unit;
        ext::shared_ptr<RateHelper> helper(new DepositRateHelper(
            Handle<Quote>(quote), term, i.settlementDays, euribor3m->fixingCalendar(),
            euribor3m->businessDayConvention(), euribor3m->endOfMonth(), euribor3m->dayCounter()));

        if (term <= 2*Days)
            eoniaHelpers.push_back(helper);
    }

    for (auto& i : eoniaSwapData) {
        Real rate = 0.01 * i.rate;
        ext::shared_ptr<SimpleQuote> simple = ext::make_shared<SimpleQuote>(rate);
        ext::shared_ptr<Quote> quote (simple);
        Period term = i.n * i.unit;
        ext::shared_ptr<RateHelper> helper(new
                     OISRateHelper(i.settlementDays,
                                   term,
                                   Handle<Quote>(quote),
                                   eonia,
                                   Handle<YieldTermStructure>(),
                                   telescopicValueDates,
                                   paymentLag, 
                                   Following, 
                                   Annual, 
                                   Calendar(), 
                                   0 * Days, 
                                   0.0, 
                                   Pillar::LastRelevantDate, 
                                   Date(), 
                                   averagingMethod));
        eoniaHelpers.push_back(helper);
    }

    ext::shared_ptr<PiecewiseFlatForward> eoniaTS(
        new PiecewiseFlatForward (vars.today, eoniaHelpers, Actual365Fixed()));

    vars.eoniaTermStructure.linkTo(eoniaTS);

    // test curve consistency
    for (auto& i : eoniaSwapData) {
        Rate expected = i.rate / 100;
        Period term = i.n * i.unit;
        // test telescopic value dates (in bootstrap) against non telescopic value dates (swap here)
        ext::shared_ptr<OvernightIndexedSwap> swap =
            vars.makeSwap(term, 0.0, 0.0, false, Null<Date>(), paymentLag, averagingMethod);
        Rate calculated = swap->fairRate();
        Rate error = std::fabs(expected-calculated);

        if (error>tolerance)
            BOOST_FAIL("curve inconsistency:" << std::setprecision(10) <<
                        "\n swap length:     " << term <<
                        "\n quoted rate:     " << expected <<
                        "\n calculated rate: " << calculated <<
                        "\n error:           " << error <<
                        "\n tolerance:       " << tolerance);
    }
} // testBootstrap(telescopicValueDates)
} // anonymous namespace

void OvernightIndexedSwapTest::testBootstrap() {
    BOOST_TEST_MESSAGE("Testing Eonia-swap curve building with daily compounded ON rates...");
    overnight_indexed_swap_test::testBootstrap(false, RateAveraging::Compound);
}

void OvernightIndexedSwapTest::testBootstrapWithArithmeticAverage() {
    BOOST_TEST_MESSAGE("Testing Eonia-swap curve building with arithmetic average ON rates...");
    overnight_indexed_swap_test::testBootstrap(false, RateAveraging::Simple);
}

void OvernightIndexedSwapTest::testBootstrapWithTelescopicDates() {
    BOOST_TEST_MESSAGE(
        "Testing Eonia-swap curve building with telescopic value dates and DCON rates...");
    overnight_indexed_swap_test::testBootstrap(true, RateAveraging::Compound);
}

void OvernightIndexedSwapTest::testBootstrapWithTelescopicDatesAndArithmeticAverage() {
    BOOST_TEST_MESSAGE(
        "Testing Eonia-swap curve building with telescopic value dates and AAON rates...");
    // Given that we are using an approximation that omits
    // the required convexity correction, a lower tolerance
    // is needed.
    overnight_indexed_swap_test::testBootstrap(true, RateAveraging::Simple, 1.0e-5);
}

void OvernightIndexedSwapTest::testSeasonedSwaps() {

    BOOST_TEST_MESSAGE("Testing seasoned Eonia-swap calculation...");

    using namespace overnight_indexed_swap_test;

    CommonVars vars;

    Period lengths[] = { 1*Years, 2*Years, 5*Years, 10*Years, 20*Years };
    Spread spreads[] = { -0.001, -0.01, 0.0, 0.01, 0.001 };

    Date effectiveDate = Date(2, February, 2009);

    vars.eoniaIndex->addFixing(Date(2,February,2009), 0.0010); // fake fixing values
    vars.eoniaIndex->addFixing(Date(3,February,2009), 0.0011);
    vars.eoniaIndex->addFixing(Date(4,February,2009), 0.0012);
    vars.eoniaIndex->addFixing(Date(5,February,2009), 0.0013);

    for (auto& length : lengths) {
        for (double spread : spreads) {

            ext::shared_ptr<OvernightIndexedSwap> swap =
                vars.makeSwap(length, 0.0, spread, false, effectiveDate);
            ext::shared_ptr<OvernightIndexedSwap> swap2 =
                vars.makeSwap(length, 0.0, spread, true, effectiveDate);
            if (std::fabs(swap->NPV() - swap2->NPV()) > 1.0e-10) {
                BOOST_ERROR("swap npv is different:\n"
                            << std::setprecision(2) << "    length: " << length << " \n"
                            << "    floating spread: " << io::rate(spread) << "\n"
                            << "    swap value (non telescopic value dates): " << swap->NPV()
                            << "\n    swap value (telescopic value dates    ): " << swap2->NPV());
            }
        }
    }
}


void OvernightIndexedSwapTest::testBootstrapRegression() {
    BOOST_TEST_MESSAGE("Testing 1.16 regression with OIS bootstrap...");

    using namespace overnight_indexed_swap_test;

    SavedSettings backup;

    Datum data[] = {
        { 0,  1, Days,   0.0066   },
        { 2,  1, Weeks,  0.006445 },
        { 2,  2, Weeks,  0.006455 },
        { 2,  3, Weeks,  0.00645  },
        { 2,  1, Months, 0.00675  },
        { 2,  2, Months, 0.007    },
        { 2,  3, Months, 0.00724  },
        { 2,  4, Months, 0.007533 },
        { 2,  5, Months, 0.00785  },
        { 2,  6, Months, 0.00814  },
        { 2,  9, Months, 0.00889  },
        { 2,  1, Years,  0.00967  },
        { 2,  2, Years,  0.01221  },
        { 2,  3, Years,  0.01413  },
        { 2,  4, Years,  0.01555  },
        { 2,  5, Years,  0.01672  },
        { 2, 10, Years,  0.02005  },
        { 2, 12, Years,  0.0208   },
        { 2, 15, Years,  0.02152  },
        { 2, 20, Years,  0.02215  },
        { 2, 25, Years,  0.02233  },
        { 2, 30, Years,  0.02234  },
        { 2, 40, Years,  0.02233  }
    };

    Settings::instance().evaluationDate() = Date(21, February, 2017);

    std::vector<ext::shared_ptr<RateHelper> > helpers;
    ext::shared_ptr<FedFunds> index(new FedFunds);

    helpers.push_back(
        ext::make_shared<DepositRateHelper>(data[0].rate,
                                            Period(data[0].n, data[0].unit),
                                            index->fixingDays(),
                                            index->fixingCalendar(),
                                            index->businessDayConvention(),
                                            index->endOfMonth(),
                                            index->dayCounter()));

    for (Size i=1; i<LENGTH(data); ++i) {
        helpers.push_back(
            ext::shared_ptr<RateHelper>(
                new OISRateHelper(data[i].settlementDays,
                                  Period(data[i].n, data[i].unit),
                                  Handle<Quote>(ext::make_shared<SimpleQuote>(data[i].rate)),
                                  index,
                                  Handle<YieldTermStructure>(),
                                  false, 2,
                                  Following, Annual, Calendar(), 0*Days, 0.0,
                                  // this bootstrap fails with the default LastRelevantDate choice
                                  Pillar::MaturityDate)));
    }

    PiecewiseYieldCurve<Discount,LogCubic> curve(0, UnitedStates(), helpers, Actual365Fixed(),
                                                 MonotonicLogCubic());

    BOOST_CHECK_NO_THROW(curve.discount(1.0));
}


test_suite* OvernightIndexedSwapTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Overnight-indexed swap tests");
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testFairRate));
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testFairSpread));
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testCachedValue));
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testBootstrap));
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testBootstrapWithArithmeticAverage));
    suite->add(QUANTLIB_TEST_CASE(
        &OvernightIndexedSwapTest::testBootstrapWithTelescopicDates));
    suite->add(QUANTLIB_TEST_CASE(
        &OvernightIndexedSwapTest::testBootstrapWithTelescopicDatesAndArithmeticAverage));
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testSeasonedSwaps));
    suite->add(QUANTLIB_TEST_CASE(&OvernightIndexedSwapTest::testBootstrapRegression));
    return suite;
}
]]></document_content>
  </document>
  <document index="217">
    <source>overnightindexedswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_overnight_indexed_swap_hpp
#define quantlib_test_overnight_indexed_swap_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class OvernightIndexedSwapTest {
  public:
    static void testFairRate();
    static void testFairSpread();
    static void testCachedValue();
    static void testBootstrap();
    static void testBootstrapWithArithmeticAverage();
    static void testBootstrapWithTelescopicDates();
    static void testBootstrapWithTelescopicDatesAndArithmeticAverage();
    static void testSeasonedSwaps();
    static void testBootstrapRegression();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="218">
    <source>pagodaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "pagodaoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/pagodaoption.hpp>
#include <ql/experimental/exoticoptions/mcpagodaengine.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void PagodaOptionTest::testCached() {

    BOOST_TEST_MESSAGE("Testing pagoda option against cached values...");

    Date today = Settings::instance().evaluationDate();

    DayCounter dc = Actual360();
    std::vector<Date> fixingDates;
    for (Size i=1; i<=4; ++i)
        fixingDates.push_back(today+i*90);

    Real roof = 0.20;
    Real fraction = 0.62;

    PagodaOption option(fixingDates, roof, fraction);

    Handle<YieldTermStructure> riskFreeRate(flatRate(today, 0.05, dc));

    std::vector<ext::shared_ptr<StochasticProcess1D> > processes(4);
    processes[0] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.15))),
              Handle<YieldTermStructure>(flatRate(today, 0.01, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.30, dc))));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.20))),
              Handle<YieldTermStructure>(flatRate(today, 0.05, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.35, dc))));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.35))),
              Handle<YieldTermStructure>(flatRate(today, 0.04, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.25, dc))));
    processes[3] = ext::shared_ptr<StochasticProcess1D>(
        new BlackScholesMertonProcess(
              Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.30))),
              Handle<YieldTermStructure>(flatRate(today, 0.03, dc)),
              riskFreeRate,
              Handle<BlackVolTermStructure>(flatVol(today, 0.20, dc))));

    Matrix correlation(4,4);
    correlation[0][0] = 1.00;
                    correlation[0][1] = 0.50;
                                    correlation[0][2] = 0.30;
                                                    correlation[0][3] = 0.10;
    correlation[1][0] = 0.50;
                    correlation[1][1] = 1.00;
                                    correlation[1][2] = 0.20;
                                                    correlation[1][3] = 0.40;
    correlation[2][0] = 0.30;
                    correlation[2][1] = 0.20;
                                    correlation[2][2] = 1.00;
                                                    correlation[2][3] = 0.60;
    correlation[3][0] = 0.10;
                    correlation[3][1] = 0.40;
                                    correlation[3][2] = 0.60;
                                                    correlation[3][3] = 1.00;

    BigNatural seed = 86421;
    Size fixedSamples = 1023;

    ext::shared_ptr<StochasticProcessArray> process(
                          new StochasticProcessArray(processes, correlation));

    option.setPricingEngine(MakeMCPagodaEngine<PseudoRandom>(process)
                            .withSamples(fixedSamples)
                            .withSeed(seed));

    Real value = option.NPV();
    Real storedValue = 0.01221094;
    Real tolerance = 1.0e-8;

    if (std::fabs(value-storedValue) > tolerance)
        BOOST_FAIL(std::setprecision(9)
                   << "    calculated value: " << value << "\n"
                   << "    expected:         " << storedValue);

    Real minimumTol = 1.0e-2;
    tolerance = option.errorEstimate();
    tolerance = std::min<Real>(tolerance/2.0, minimumTol*value);

    option.setPricingEngine(MakeMCPagodaEngine<PseudoRandom>(process)
                            .withAbsoluteTolerance(tolerance)
                            .withSeed(seed));

    option.NPV();
    Real accuracy = option.errorEstimate();
    if (accuracy > tolerance)
        BOOST_FAIL(std::setprecision(10)
                   << "    reached accuracy: " << accuracy << "\n"
                   << "    expected:         " << tolerance);
}


test_suite* PagodaOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Pagoda-option tests");
    suite->add(QUANTLIB_TEST_CASE(&PagodaOptionTest::testCached));
    return suite;
}

]]></document_content>
  </document>
  <document index="219">
    <source>pagodaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_pagoda_option_hpp
#define quantlib_test_pagoda_option_hpp

#include <boost/test/unit_test.hpp>

class PagodaOptionTest {
  public:
    static void testCached();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="220">
    <source>paralleltestrunner.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*
 Examples:
  1. Start with 12 worker processes
     ./quantlib-test-suite --nProc=12 --log_level=message --report_level=short
                           --build_info=yes
  2. If parameter "--nProc" is omitted then the number
     of worker processes will be equal to the number of CPU cores.
 */


#ifndef quantlib_parallel_test_runner_hpp
#define quantlib_parallel_test_runner_hpp

#include <ql/types.hpp>
#include <ql/errors.hpp>

#ifdef VERSION
/* This comes from ./configure, and for some reason it interferes with
   the internals of the unit test library in Boost 1.63. */
#undef VERSION
#endif

#include <boost/thread/thread.hpp>
#include <boost/interprocess/ipc/message_queue.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>

#define BOOST_TEST_NO_MAIN 1
#include <boost/test/included/unit_test.hpp>
#include <boost/algorithm/string.hpp>

#include <map>
#include <list>
#include <sstream>
#include <utility>
#include <fstream>
#include <chrono>
#include <string>
#include <cstring>
#include <cstdlib>

#ifdef BOOST_MSVC
#  define BOOST_LIB_NAME boost_system
#  include <boost/config/auto_link.hpp>
#  undef BOOST_LIB_NAME
#  define BOOST_LIB_NAME boost_thread
#  include <boost/config/auto_link.hpp>
#  undef BOOST_LIB_NAME
#endif

using boost::unit_test::test_results;
using namespace boost::interprocess;
using namespace boost::unit_test_framework;


namespace {
    int worker(const std::string& cmd) {
        return system(cmd.c_str());
    }

    counter_t test_enabled(test_unit_id id) {
        test_case_counter tcc;
        boost::unit_test::traverse_test_tree(id, tcc);

        return tcc.p_count;
    }

    class TestCaseCollector : public test_tree_visitor {
      public:
        typedef std::map<test_unit_id, std::list<test_unit_id> > id_map_t;

        const id_map_t& map() const { return idMap_; }
        test_unit_id testSuiteId() const { return testSuiteId_; }

        bool visit(test_unit const& tu) {
            if (tu.p_parent_id == framework::master_test_suite().p_id) {
                QL_REQUIRE(!tu.p_name.get().compare("QuantLib test suite"),
                     "could not find QuantLib test suite");

                testSuiteId_ = tu.p_id;
            }
            return test_tree_visitor::visit(tu);
        }

        void visit(test_case const& tc) {
            if (test_enabled(tc.p_id) != 0u)
                idMap_[tc.p_parent_id].push_back(tc.p_id);
        }

        std::list<test_unit_id>::size_type numberOfTests() {
            std::list<test_unit_id>::size_type n=0;
            for (id_map_t::const_iterator p_it = idMap_.begin();
                p_it != idMap_.end(); ++p_it) n+=p_it->second.size();

            return n;
        }
      private:
        id_map_t idMap_;
        test_unit_id testSuiteId_;
    };

    class TestCaseReportAggregator : public test_tree_visitor {
      public:
        void test_suite_finish( test_suite const& ts)  {
            results_collect_helper ch( s_rc_impl().m_results_store[ts.p_id], ts );
            traverse_test_tree( ts, ch );
        }
    };

    struct TestCaseId {
        test_unit_id id;
        bool terminate;
    };

    struct RuntimeLog {
        QuantLib::Time time;
        char testCaseName[256];
    };

    struct QualifiedTestResults {
        test_unit_id id;
        test_results results;
    };

    const char* const namesLogMutexName = "named_log_mutex";

    void output_logstream(
        std::ostream& out, std::streambuf* outBuf, std::stringstream& s) {

        static named_mutex mutex(open_or_create, namesLogMutexName);
        scoped_lock<named_mutex> lock(mutex);

        out.flush();
        out.rdbuf(outBuf);

        std::vector<std::string> tok;
        const std::string lines = s.str();
        boost::split(tok, lines, boost::is_any_of("\n"));

        for (std::vector<std::string>::const_iterator iter = tok.begin();
            iter != tok.end(); ++iter) {
            if ((iter->length() != 0u) && (iter->compare("Running 1 test case...") != 0)) {
                out << *iter  << std::endl;
            }
        }

        s.str(std::string());
        out.rdbuf(s.rdbuf());
    }

    std::ostream& log_stream() {
    #if BOOST_VERSION < 106200
        return s_log_impl().stream();
    #else
        return s_log_impl().m_log_formatter_data.front().stream();
    #endif
    }
}


test_suite* init_unit_test_suite(int, char* []);

int main( int argc, char* argv[] )
{
    typedef QuantLib::Time Time;

    const char* const profileFileName = ".unit_test_profile.txt";
    const char* const testUnitIdQueueName = "test_unit_queue";
    const char* const testResultQueueName = "test_result_queue";
    const char* const testRuntimeLogName  = "test_runtime_log_queue";

    const std::string clientModeStr = "--client_mode=true";
    const bool clientMode = (std::string(argv[argc-1]) == clientModeStr);

    message_queue::size_type recvd_size;

    try {
        unsigned int priority;
        if (!clientMode) {
            std::map<std::string, Time> runTimeLog;

            std::ifstream in(profileFileName);
            if (in.good()) {
                // NOLINTNEXTLINE(readability-implicit-bool-conversion)
                for (std::string line; std::getline(in, line);) {
                    std::vector<std::string> tok;
                    boost::split(tok, line, boost::is_any_of(":"));

                    QL_REQUIRE(tok.size() == 2,
                        "every line should consists of two entries");
                    runTimeLog[tok[0]] = std::stod(tok[1]);
                }
            }
            in.close();

            unsigned nProc = boost::thread::hardware_concurrency();

            std::stringstream cmd;
            cmd << "\"" << argv[0] << "\" ";

            std::vector<char*> localArgs(1, argv[0]);

            for( int i = 1; i < argc; ++i ) {
                const std::string arg(argv[i]);

                // check for number of processes
                std::vector<std::string> tok;
                boost::split(tok, arg, boost::is_any_of("="));
                if (tok.size() == 2 && tok[0] == "--nProc") {
                    nProc = std::stoul(tok[1]);
                }
                else if (arg != "--build_info=yes") {
                    cmd << arg << " ";
                    localArgs.push_back(argv[i]);
                }
            }

            cmd << clientModeStr;

            framework::init(init_unit_test_suite,
                            localArgs.size(), &localArgs[0]);
            framework::finalize_setup_phase();

            framework::impl::s_frk_state().deduce_run_status(
                framework::master_test_suite().p_id);

            TestCaseCollector tcc;
            traverse_test_tree(framework::master_test_suite(), tcc , true);

            log_stream() << "Total number of test cases: "
                << tcc.numberOfTests() << std::endl;

            log_stream() << "Total number of worker processes: "
                << nProc << std::endl;

            message_queue::remove(testUnitIdQueueName);
            message_queue mq(create_only, testUnitIdQueueName,
                tcc.numberOfTests() + nProc, sizeof(TestCaseId));

            message_queue::remove(testResultQueueName);
            message_queue rq(create_only, testResultQueueName, nProc,
                sizeof(QualifiedTestResults));

            message_queue::remove(testRuntimeLogName);
            message_queue lq(create_only, testRuntimeLogName, nProc,
                sizeof(RuntimeLog));

            // run root test cases in master process
            const std::list<test_unit_id> qlRoot = (tcc.map().count(tcc.testSuiteId())) != 0u ?
                                                       tcc.map().find(tcc.testSuiteId())->second :
                                                       std::list<test_unit_id>();

            // fork worker processes
            boost::thread_group threadGroup;
            for (unsigned i=0; i < nProc; ++i) {
                threadGroup.create_thread([&]() { worker(cmd.str()); });
            }

            struct mutex_remove {
                ~mutex_remove() { named_mutex::remove(namesLogMutexName); }
            } mutex_remover;

            struct queue_remove {
                explicit queue_remove(const char* name) : name_(name) { }
                ~queue_remove() { message_queue::remove(name_); }

            private:
                const char* const name_;
            } queue_remover1(testUnitIdQueueName),
                queue_remover2(testResultQueueName),
                queue_remover3(testRuntimeLogName);

            std::multimap<Time, test_unit_id> testsSortedByRunTime;

            for (TestCaseCollector::id_map_t::const_iterator
                p_it = tcc.map().begin();
                p_it != tcc.map().end(); ++p_it) {

                if (p_it->first != tcc.testSuiteId()) {
                    for (std::list<test_unit_id>::const_iterator
                        it =  p_it->second.begin();
                        it != p_it->second.end(); ++it) {

                        const std::string name
                            = framework::get(*it, TUT_ANY).p_name;

                        if (runTimeLog.count(name) != 0u) {
                            testsSortedByRunTime.insert(
                                std::make_pair(runTimeLog[name], *it));
                        }
                        else {
                            testsSortedByRunTime.insert(
                                std::make_pair(
                                    std::numeric_limits<Time>::max(), *it));
                        }
                    }
                }
            }

            std::list<test_unit_id> ids;
            for (std::multimap<Time, test_unit_id>::const_iterator
                iter = testsSortedByRunTime.begin();
                iter != testsSortedByRunTime.end(); ++iter) {

                ids.push_front(iter->second);
            }
            QL_REQUIRE(ids.size() + qlRoot.size() == tcc.numberOfTests(),
                "missing test case in distrubtion list");

            testsSortedByRunTime.clear();

            for (std::list<test_unit_id>::const_iterator iter = ids.begin();
                iter != ids.end(); ++iter) {
                const TestCaseId id = { *iter, false };
                mq.send(&id, sizeof(TestCaseId), 0);
            }

            const TestCaseId id = { 0, true };
            for (unsigned i = 0; i < nProc; ++i) {
                mq.send(&id, sizeof(TestCaseId), 0);
            }

            for(unsigned i = 0; i < ids.size(); ++i) {
                QualifiedTestResults remoteResults;

                rq.receive(&remoteResults,
                    sizeof(QualifiedTestResults), recvd_size, priority);

                boost::unit_test::s_rc_impl().m_results_store[remoteResults.id]
                    = remoteResults.results;
            }

            TestCaseReportAggregator tca;
            traverse_test_tree(framework::master_test_suite(), tca , true);

            results_reporter::make_report();

            RuntimeLog log;
            for (unsigned i=0; i < ids.size(); ++i) {
                lq.receive(&log, sizeof(RuntimeLog), recvd_size, priority);
                runTimeLog[std::string(log.testCaseName)] = log.time;
            }

            std::ofstream out(
                profileFileName, std::ios::out | std::ios::trunc);
            out << std::setprecision(6);
            for (std::map<std::string, QuantLib::Time>::const_iterator
                iter = runTimeLog.begin(); iter != runTimeLog.end(); ++iter) {
                out << iter->first << ":" << iter->second << std::endl;
            }
            out.close();

            threadGroup.join_all();
        }
        else {
            std::stringstream logBuf;
            std::streambuf* const oldBuf = log_stream().rdbuf();
            log_stream().rdbuf(logBuf.rdbuf());

            framework::init(init_unit_test_suite, argc-1, argv );
            framework::finalize_setup_phase();

            framework::impl::s_frk_state().deduce_run_status(
                framework::master_test_suite().p_id);

            logBuf.str(std::string());

            message_queue mq(open_only, testUnitIdQueueName);

            TestCaseId id;
            mq.receive(&id, sizeof(TestCaseId), recvd_size, priority);

            typedef std::list<std::pair<std::string, QuantLib::Time> >
                run_time_list_type;
            run_time_list_type runTimeLogs;

            message_queue rq(open_only, testResultQueueName);

            while (!id.terminate) {
                auto startTime = std::chrono::steady_clock::now();

                #if BOOST_VERSION < 106200
                    BOOST_TEST_FOREACH( test_observer*, to,
                        framework::impl::s_frk_state().m_observers )
                        framework::impl::s_frk_state().m_aux_em.vexecute([&](){ to->test_start(1); });

                    framework::impl::s_frk_state().execute_test_tree( id.id );

                    BOOST_TEST_REVERSE_FOREACH( test_observer*, to,
                        framework::impl::s_frk_state().m_observers )
                        to->test_finish();
                #else
                    // works for BOOST_VERSION > 106100, needed for >106500
                    framework::run(id.id, false);
                #endif

                auto stopTime = std::chrono::steady_clock::now();
                double T = std::chrono::duration_cast<std::chrono::microseconds>(stopTime - startTime).count() * 1e-6;
                runTimeLogs.push_back(std::make_pair(
                    framework::get(id.id, TUT_ANY).p_name, T));

                output_logstream(log_stream(), oldBuf, logBuf);

                QualifiedTestResults results
                    = { id.id,
                        boost::unit_test::results_collector.results(id.id) };

                rq.send(&results, sizeof(QualifiedTestResults), 0);

                mq.receive(&id, sizeof(TestCaseId), recvd_size, priority);
            }


            output_logstream(log_stream(), oldBuf, logBuf);
            log_stream().rdbuf(oldBuf);

            RuntimeLog log;
            log.testCaseName[sizeof(log.testCaseName)-1] = '\0';

            message_queue lq(open_only, testRuntimeLogName);
            for (run_time_list_type::const_iterator iter = runTimeLogs.begin();
                iter != runTimeLogs.end(); ++iter) {
                log.time = iter->second;

                std::strncpy(log.testCaseName, iter->first.c_str(),
                    sizeof(log.testCaseName)-1);

                lq.send(&log, sizeof(RuntimeLog), 0);
            }
        }
    }
    catch(QuantLib::Error &ex) {
        std::cerr << "QuantLib exception: " << ex.what() << std::endl;
        return boost::exit_exception_failure;
    }
    catch(interprocess_exception &ex){
        std::cerr << "interprocess exception: " << ex.what() << std::endl;
        return boost::exit_exception_failure;
    }
    catch( framework::nothing_to_test const& ) {
        return boost::exit_success;
    }
    catch( framework::internal_error const& ex ) {
        results_reporter::get_stream()
            << "Boost.Test framework internal error: "
            << ex.what() << std::endl;

        return boost::exit_exception_failure;
    }
    catch( framework::setup_error const& ex ) {
        results_reporter::get_stream() << "Test setup error: "
            << ex.what() << std::endl;

        return boost::exit_exception_failure;
    }
    catch( ... ) {
        results_reporter::get_stream()
            << "Boost.Test framework internal error: unknown reason"
            << std::endl;

        return boost::exit_exception_failure;
    }

    framework::shutdown();

    #if BOOST_VERSION < 106000
    return runtime_config::no_result_code()
    #elif BOOST_VERSION < 106400
    // changed in Boost 1.60
    return !runtime_config::get<bool>( runtime_config::RESULT_CODE )
    #else
    // changed again in Boost 1.64
    return !runtime_config::get<bool>( runtime_config::btrt_result_code )
    #endif
        ? boost::exit_success
        : results_collector.results(
            framework::master_test_suite().p_id ).result_code();
}

#endif
]]></document_content>
  </document>
  <document index="221">
    <source>partialtimebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "partialtimebarrieroption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/partialtimebarrieroption.hpp>
#include <ql/experimental/exoticoptions/analyticpartialtimebarrieroptionengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace partial_time_barrier_option_test {

    struct TestCase {
        Real underlying;
        Real strike;
        Integer days;
        Real result;
    };

}

void PartialTimeBarrierOptionTest::testAnalyticEngine() {
    BOOST_TEST_MESSAGE(
        "Testing analytic engine for partial-time barrier option...");

    using namespace partial_time_barrier_option_test;

    Date today = Settings::instance().evaluationDate();

    Option::Type type = Option::Call;
    DayCounter dc = Actual360();
    Date maturity = today + 360;
    ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturity);
    Real barrier = 100.0;
    Real rebate = 0.0;

    ext::shared_ptr<SimpleQuote> spot = ext::make_shared<SimpleQuote>();
    ext::shared_ptr<SimpleQuote> qRate = ext::make_shared<SimpleQuote>(0.0);
    ext::shared_ptr<SimpleQuote> rRate = ext::make_shared<SimpleQuote>(0.1);
    ext::shared_ptr<SimpleQuote> vol = ext::make_shared<SimpleQuote>(0.25);

    Handle<Quote> underlying(spot);
    Handle<YieldTermStructure> dividendTS(flatRate(today, qRate, dc));
    Handle<YieldTermStructure> riskFreeTS(flatRate(today, rRate, dc));
    Handle<BlackVolTermStructure> blackVolTS(flatVol(today, vol, dc));

    const ext::shared_ptr<BlackScholesMertonProcess> process =
        ext::make_shared<BlackScholesMertonProcess>(underlying,
                                                      dividendTS,
                                                      riskFreeTS,
                                                      blackVolTS);
    ext::shared_ptr<PricingEngine> engine =
        ext::make_shared<AnalyticPartialTimeBarrierOptionEngine>(process);

    TestCase cases[] = {
        {  95.0,  90.0,   1,  0.0393 },
        {  95.0, 110.0,   1,  0.0000 },
        { 105.0,  90.0,   1,  9.8751 },
        { 105.0, 110.0,   1,  6.2303 },

        {  95.0,  90.0,  90,  6.2747 },
        {  95.0, 110.0,  90,  3.7352 },
        { 105.0,  90.0,  90, 15.6324 },
        { 105.0, 110.0,  90,  9.6812 },

        {  95.0,  90.0, 180, 10.3345 },
        {  95.0, 110.0, 180,  5.8712 },
        { 105.0,  90.0, 180, 19.2896 },
        { 105.0, 110.0, 180, 11.6055 },

        {  95.0,  90.0, 270, 13.4342 },
        {  95.0, 110.0, 270,  7.1270 },
        { 105.0,  90.0, 270, 22.0753 },
        { 105.0, 110.0, 270, 12.7342 },

        {  95.0,  90.0, 359, 16.8576 },
        {  95.0, 110.0, 359,  7.5763 },
        { 105.0,  90.0, 359, 25.1488 },
        { 105.0, 110.0, 359, 13.1376 }
    };

    for (auto& i : cases) {
        Date coverEventDate = today + i.days;
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::make_shared<PlainVanillaPayoff>(type, i.strike);
        PartialTimeBarrierOption option(PartialBarrier::DownOut,
                                        PartialBarrier::EndB1,
                                        barrier, rebate,
                                        coverEventDate,
                                        payoff, exercise);
        option.setPricingEngine(engine);

        spot->setValue(i.underlying);
        Real calculated = option.NPV();
        Real expected = i.result;
        Real error = std::fabs(calculated-expected);
        Real tolerance = 1e-4;
        if (error > tolerance)
            BOOST_ERROR("Failed to reproduce partial-time barrier option value"
                        << "\n    expected:   " << expected
                        << "\n    calculated: " << calculated
                        << "\n    error:      " << error);
    }
}


test_suite* PartialTimeBarrierOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Partial-time barrier option tests");

    suite->add(QUANTLIB_TEST_CASE(
                          &PartialTimeBarrierOptionTest::testAnalyticEngine));

    return suite;
}
]]></document_content>
  </document>
  <document index="222">
    <source>partialtimebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_partial_time_barrier_options_hpp
#define quantlib_test_partial_time_barrier_options_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class PartialTimeBarrierOptionTest {
  public:
    static void testAnalyticEngine();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="223">
    <source>pathgenerator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "pathgenerator.hpp"
#include "utilities.hpp"
#include <ql/methods/montecarlo/mctraits.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/geometricbrownianprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/processes/squarerootprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    void testSingle(const ext::shared_ptr<StochasticProcess1D>& process,
                    const std::string& tag, bool brownianBridge,
                    Real expected, Real antithetic) {
        typedef PseudoRandom::rsg_type rsg_type;
        typedef PathGenerator<rsg_type>::sample_type sample_type;

        BigNatural seed = 42;
        Time length = 10;
        Size timeSteps = 12;
        rsg_type rsg = PseudoRandom::make_sequence_generator(timeSteps, seed);
        PathGenerator<rsg_type> generator(process, length, timeSteps,
                                          rsg, brownianBridge);
        Size i;
        for (i=0; i<100; i++)
            generator.next();

        sample_type sample = generator.next();
        Real calculated = sample.value.back();
        Real error = std::fabs(calculated-expected);
        Real tolerance = 2.0e-8;
        if (error > tolerance) {
            BOOST_ERROR("using " << tag << " process "
                        << (brownianBridge ? "with " : "without ")
                        << "brownian bridge:\n"
                        << std::setprecision(13)
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << expected << "\n"
                        << "    error:      " << error << "\n"
                        << "    tolerance:  " << tolerance);
        }

        sample = generator.antithetic();
        calculated = sample.value.back();
        error = std::fabs(calculated-antithetic);
        tolerance = 2.0e-7;
        if (error > tolerance) {
            BOOST_ERROR("using " << tag << " process "
                        << (brownianBridge ? "with " : "without ")
                        << "brownian bridge:\n"
                        << "antithetic sample:\n"
                        << std::setprecision(13)
                        << "    calculated: " << calculated << "\n"
                        << "    expected:   " << antithetic << "\n"
                        << "    error:      " << error << "\n"
                        << "    tolerance:  " << tolerance);
        }

    }

    void testMultiple(const ext::shared_ptr<StochasticProcess>& process,
                      const std::string& tag,
                      Real expected[], Real antithetic[]) {
        typedef PseudoRandom::rsg_type rsg_type;
        typedef MultiPathGenerator<rsg_type>::sample_type sample_type;

        BigNatural seed = 42;
        Time length = 10;
        Size timeSteps = 12;
        Size assets = process->size();
        rsg_type rsg = PseudoRandom::make_sequence_generator(timeSteps*assets,
                                                             seed);
        MultiPathGenerator<rsg_type> generator(process,
                                               TimeGrid(length, timeSteps),
                                               rsg, false);
        Size i, j;
        for (i=0; i<100; i++)
            generator.next();

        sample_type sample = generator.next();
        Array calculated(assets);
        Real error, tolerance = 2.0e-7;
        for (j=0; j<assets; j++)
            calculated[j] = sample.value[j].back();
        for (j=0; j<assets; j++) {
            error = std::fabs(calculated[j]-expected[j]);
            if (error > tolerance) {
                BOOST_ERROR("using " << tag << " process "
                            << "(" << io::ordinal(j+1) << " asset:)\n"
                            << std::setprecision(13)
                            << "    calculated: " << calculated[j] << "\n"
                            << "    expected:   " << expected[j] << "\n"
                            << "    error:      " << error << "\n"
                            << "    tolerance:  " << tolerance);
            }
        }

        sample = generator.antithetic();
        for (j=0; j<assets; j++)
            calculated[j] = sample.value[j].back();
        for (j=0; j<assets; j++) {
            error = std::fabs(calculated[j]-antithetic[j]);
            if (error > tolerance) {
                BOOST_ERROR("using " << tag << " process "
                            << "(" << io::ordinal(j+1) << " asset:)\n"
                            << "antithetic sample:\n"
                            << std::setprecision(13)
                            << "    calculated: " << calculated[j] << "\n"
                            << "    expected:   " << antithetic[j] << "\n"
                            << "    error:      " << error << "\n"
                            << "    tolerance:  " << tolerance);
            }
        }
    }

}


void PathGeneratorTest::testPathGenerator() {

    BOOST_TEST_MESSAGE("Testing 1-D path generation against cached values...");

    SavedSettings backup;

    Settings::instance().evaluationDate() = Date(26,April,2005);

    Handle<Quote> x0(ext::shared_ptr<Quote>(new SimpleQuote(100.0)));
    Handle<YieldTermStructure> r(flatRate(0.05, Actual360()));
    Handle<YieldTermStructure> q(flatRate(0.02, Actual360()));
    Handle<BlackVolTermStructure> sigma(flatVol(0.20, Actual360()));
    // commented values must be used when Halley's correction is enabled
    testSingle(ext::shared_ptr<StochasticProcess1D>(
                                 new BlackScholesMertonProcess(x0,q,r,sigma)),
               "Black-Scholes", false, 26.13784357783, 467.2928561411);
                                    // 26.13784357783, 467.2928562519);
    testSingle(ext::shared_ptr<StochasticProcess1D>(
                                 new BlackScholesMertonProcess(x0,q,r,sigma)),
               "Black-Scholes", true, 60.28215549393, 202.6143139999);
                                   // 60.28215551021, 202.6143139437);

    testSingle(ext::shared_ptr<StochasticProcess1D>(
                       new GeometricBrownianMotionProcess(100.0, 0.03, 0.20)),
               "geometric Brownian", false, 27.62223714065, 483.6026514084);
                                         // 27.62223714065, 483.602651493);

    testSingle(ext::shared_ptr<StochasticProcess1D>(
                                     new OrnsteinUhlenbeckProcess(0.1, 0.20)),
               "Ornstein-Uhlenbeck", false, -0.8372003433557, 0.8372003433557);

    testSingle(ext::shared_ptr<StochasticProcess1D>(
                                 new SquareRootProcess(0.1, 0.1, 0.20, 10.0)),
               "square-root", false, 1.70608664108, 6.024200546031);
}


void PathGeneratorTest::testMultiPathGenerator() {

    BOOST_TEST_MESSAGE("Testing n-D path generation against cached values...");

    SavedSettings backup;

    Settings::instance().evaluationDate() = Date(26,April,2005);

    Handle<Quote> x0(ext::shared_ptr<Quote>(new SimpleQuote(100.0)));
    Handle<YieldTermStructure> r(flatRate(0.05, Actual360()));
    Handle<YieldTermStructure> q(flatRate(0.02, Actual360()));
    Handle<BlackVolTermStructure> sigma(flatVol(0.20, Actual360()));

    Matrix correlation(3,3);
    correlation[0][0] = 1.0; correlation[0][1] = 0.9; correlation[0][2] = 0.7;
    correlation[1][0] = 0.9; correlation[1][1] = 1.0; correlation[1][2] = 0.4;
    correlation[2][0] = 0.7; correlation[2][1] = 0.4; correlation[2][2] = 1.0;

    std::vector<ext::shared_ptr<StochasticProcess1D> > processes(3);
    ext::shared_ptr<StochasticProcess> process;

    processes[0] = ext::shared_ptr<StochasticProcess1D>(
                                 new BlackScholesMertonProcess(x0,q,r,sigma));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
                                 new BlackScholesMertonProcess(x0,q,r,sigma));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
                                 new BlackScholesMertonProcess(x0,q,r,sigma));
    process = ext::shared_ptr<StochasticProcess>(
                           new StochasticProcessArray(processes,correlation));
    // commented values must be used when Halley's correction is enabled
    Real result1[] = {
        188.2235868185,
        270.6713069569,
        113.0431145652 };
    // Real result1[] = {
    //     188.2235869273,
    //     270.6713071508,
    //     113.0431145652 };
    Real result1a[] = {
        64.89105742957,
        45.12494404804,
        108.0475146914 };
    // Real result1a[] = {
    //     64.89105739157,
    //     45.12494401537,
    //     108.0475146914 };
    testMultiple(process, "Black-Scholes", result1, result1a);

    processes[0] = ext::shared_ptr<StochasticProcess1D>(
                       new GeometricBrownianMotionProcess(100.0, 0.03, 0.20));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
                       new GeometricBrownianMotionProcess(100.0, 0.03, 0.20));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
                       new GeometricBrownianMotionProcess(100.0, 0.03, 0.20));
    process = ext::shared_ptr<StochasticProcess>(
                           new StochasticProcessArray(processes,correlation));
    Real result2[] = {
        174.8266131680,
        237.2692443633,
        119.1168555440 };
    // Real result2[] = {
    //     174.8266132344,
    //     237.2692444869,
    //     119.1168555605 };
    Real result2a[] = {
        57.69082393020,
        38.50016862915,
        116.4056510107 };
    // Real result2a[] = {
    //     57.69082387657,
    //     38.50016858691,
    //     116.4056510107 };
    testMultiple(process, "geometric Brownian", result2, result2a);

    processes[0] = ext::shared_ptr<StochasticProcess1D>(
                                     new OrnsteinUhlenbeckProcess(0.1, 0.20));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
                                     new OrnsteinUhlenbeckProcess(0.1, 0.20));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
                                     new OrnsteinUhlenbeckProcess(0.1, 0.20));
    process = ext::shared_ptr<StochasticProcess>(
                           new StochasticProcessArray(processes,correlation));
    Real result3[] = {
        0.2942058437284,
        0.5525006418386,
        0.02650931054575 };
    Real result3a[] = {
        -0.2942058437284,
        -0.5525006418386,
        -0.02650931054575 };
    testMultiple(process, "Ornstein-Uhlenbeck", result3, result3a);

    processes[0] = ext::shared_ptr<StochasticProcess1D>(
                                 new SquareRootProcess(0.1, 0.1, 0.20, 10.0));
    processes[1] = ext::shared_ptr<StochasticProcess1D>(
                                 new SquareRootProcess(0.1, 0.1, 0.20, 10.0));
    processes[2] = ext::shared_ptr<StochasticProcess1D>(
                                 new SquareRootProcess(0.1, 0.1, 0.20, 10.0));
    process = ext::shared_ptr<StochasticProcess>(
                           new StochasticProcessArray(processes,correlation));
    Real result4[] = {
        4.279510844897,
        4.943783503533,
        3.590930385958 };
    Real result4a[] = {
        2.763967737724,
        2.226487196647,
        3.503859264341 };
    testMultiple(process, "square-root", result4, result4a);
}


test_suite* PathGeneratorTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Path generation tests");
    suite->add(QUANTLIB_TEST_CASE(&PathGeneratorTest::testPathGenerator));
    // FLOATING_POINT_EXCEPTION
    suite->add(QUANTLIB_TEST_CASE(&PathGeneratorTest::testMultiPathGenerator));
    return suite;
}

]]></document_content>
  </document>
  <document index="224">
    <source>pathgenerator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_path_generator_hpp
#define quantlib_test_path_generator_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class PathGeneratorTest {
  public:
    static void testPathGenerator();
    static void testMultiPathGenerator();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="225">
    <source>period.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2014 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "period.hpp"
#include "utilities.hpp"
#include "ql/time/period.hpp"

using namespace QuantLib;
using namespace boost::unit_test_framework;

void PeriodTest::testYearsMonthsAlgebra() {

    BOOST_TEST_MESSAGE("Testing period algebra on years/months...");

    Period OneYear(1, Years);
    Period SixMonths(6, Months);
    Period ThreeMonths(3, Months);

    Integer n = 4;
    if (OneYear/n!=ThreeMonths)
        BOOST_ERROR("division error: " << OneYear << "/" << n <<
                    " not equal to " << ThreeMonths);
    n = 2;
    if (OneYear/n!=SixMonths)
        BOOST_ERROR("division error: " << OneYear << "/" << n <<
                    " not equal to " << SixMonths);

    Period sum=ThreeMonths;
    sum+=SixMonths;
    if (sum!=Period(9, Months))
        BOOST_ERROR("sum error: " << ThreeMonths <<
                    " + " << SixMonths <<
                    " != " << Period(9, Months));

    sum+=OneYear;
    if (sum!=Period(21, Months))
        BOOST_ERROR("sum error: " << ThreeMonths <<
                    " + " << SixMonths <<
                    " + " << OneYear <<
                    " != " << Period(21, Months));

    Period TwelveMonths(12, Months);
    if (TwelveMonths.length()!=12)
        BOOST_ERROR("normalization error: TwelveMonths.length()" <<
                    " is " << TwelveMonths.length() <<
                    " instead of 12");
    if (TwelveMonths.units()!=Months)
        BOOST_ERROR("normalization error: TwelveMonths.units()" <<
                    " is " << TwelveMonths.units() <<
                    " instead of " << Months);

    Period NormalizedTwelveMonths(12, Months);
    NormalizedTwelveMonths.normalize();
    if (NormalizedTwelveMonths.length()!=1)
        BOOST_ERROR("normalization error: NormalizedTwelveMonths.length()" <<
                    " is " << NormalizedTwelveMonths.length() <<
                    " instead of 1");
    if (NormalizedTwelveMonths.units()!=Years)
        BOOST_ERROR("normalization error: NormalizedTwelveMonths.units()" <<
                    " is " << NormalizedTwelveMonths.units() <<
                    " instead of " << Years);
}

void PeriodTest::testWeeksDaysAlgebra() {

    BOOST_TEST_MESSAGE("Testing period algebra on weeks/days...");

    Period TwoWeeks(2, Weeks);
    Period OneWeek(1, Weeks);
    Period ThreeDays(3, Days);
    Period OneDay(1, Days);

    Integer n = 2;
    if (TwoWeeks/n!=OneWeek)
        BOOST_ERROR("division error: " << TwoWeeks << "/" << n <<
                    " not equal to " << OneWeek);
    n = 7;
    if (OneWeek/n!=OneDay)
        BOOST_ERROR("division error: " << OneWeek << "/" << n <<
                    " not equal to " << OneDay);

    Period sum=ThreeDays;
    sum+=OneDay;
    if (sum!=Period(4, Days))
        BOOST_ERROR("sum error: " << ThreeDays <<
                    " + " << OneDay <<
                    " != " << Period(4, Days));

    sum+=OneWeek;
    if (sum!=Period(11, Days))
        BOOST_ERROR("sum error: " << ThreeDays <<
                    " + " << OneDay <<
                    " + " << OneWeek <<
                    " != " << Period(11, Days));

    Period SevenDays(7, Days);
    if (SevenDays.length()!=7)
        BOOST_ERROR("normalization error: SevenDays.length()" <<
                    " is " << SevenDays.length() <<
                    " instead of 7");
    if (SevenDays.units()!=Days)
        BOOST_ERROR("normalization error: SevenDays.units()" <<
                    " is " << SevenDays.units() <<
                    " instead of " << Days);
}

test_suite* PeriodTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Period tests");
    suite->add(QUANTLIB_TEST_CASE(&PeriodTest::testYearsMonthsAlgebra));
    suite->add(QUANTLIB_TEST_CASE(&PeriodTest::testWeeksDaysAlgebra));
    return suite;
}

]]></document_content>
  </document>
  <document index="226">
    <source>period.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_period_hpp
#define quantlib_test_period_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class PeriodTest {
  public:
    static void testYearsMonthsAlgebra();
    static void testWeeksDaysAlgebra();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="227">
    <source>piecewiseyieldcurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006, 2008, 2009, 2017 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_piecewise_yield_curve_hpp
#define quantlib_test_piecewise_yield_curve_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class PiecewiseYieldCurveTest {
  public:
    static void testLogCubicDiscountConsistency();
    static void testLogLinearDiscountConsistency();
    static void testLinearDiscountConsistency();

    static void testLinearZeroConsistency();
    static void testSplineZeroConsistency();

    static void testLinearForwardConsistency();
    static void testFlatForwardConsistency();
    static void testSplineForwardConsistency();

    static void testConvexMonotoneForwardConsistency();
    static void testLocalBootstrapConsistency();

    static void testObservability();
    static void testLiborFixing();

    static void testJpyLibor();

    static void testDiscountCopy();
    static void testForwardCopy();
    static void testZeroCopy();

    static void testSwapRateHelperLastRelevantDate();
    static void testSwapRateHelperSpotDate();

    static void testBadPreviousCurve();

    static void testConstructionWithExplicitBootstrap();
    static void testLargeRates();

    static void testGlobalBootstrap();

    static void testIterativeBootstrapRetries();

    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="228">
    <source>piecewisezerospreadedtermstructure.cpp</source>
    <document_content><![CDATA[
/*
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "piecewisezerospreadedtermstructure.hpp"
#include "utilities.hpp"
#include <ql/termstructures/yield/piecewisezerospreadedtermstructure.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/math/interpolations/forwardflatinterpolation.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace piecewise_zero_spreaded_term_structure_test {

    struct Datum {
        Integer n;
        TimeUnit units;
        Rate rate;
    };

    struct CommonVars {
        // common data
        Calendar calendar;
        Natural settlementDays;
        DayCounter dayCount;
        Compounding compounding;
        ext::shared_ptr<YieldTermStructure> termStructure;
        Date today;
        Date settlementDate;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            calendar = TARGET();
            settlementDays = 2;
            today =Date(9,June,2009);
            compounding = Continuous;
            dayCount = Actual360();
            settlementDate = calendar.advance(today,settlementDays,Days);

            Settings::instance().evaluationDate() = today;

            Integer ts[] = { 13,    41,  75,   165,   256 , 345,  524,  703 };
            Rate r[] = { 0.035,0.033,0.034, 0.034, 0.036,0.037,0.039,0.040 };
            std::vector<Rate> rates(1, 0.035);
            std::vector<Date> dates(1, settlementDate);
            for (Size i = 0; i < 8; ++i) {
                dates.push_back(calendar.advance(today,ts[i],Days));
                rates.push_back(r[i]);
            }
            termStructure = ext::make_shared<ZeroCurve>(dates, rates, dayCount);
        }
    };

}

void PiecewiseZeroSpreadedTermStructureTest::testFlatInterpolationLeft() {

    BOOST_TEST_MESSAGE("Testing flat interpolation before the first spreaded date...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 8, Months),
                                     vars.calendar.advance(vars.today, 15, Months)};

    Date interpolationDate = vars.calendar.advance(vars.today, 6, Months);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<PiecewiseZeroSpreadedTermStructure>(
                           Handle<YieldTermStructure>(vars.termStructure),
                           spreads, spreadDates);

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        spread1->value();

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testFlatInterpolationRight() {

    BOOST_TEST_MESSAGE("Testing flat interpolation after the last spreaded date...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 8, Months),
                                     vars.calendar.advance(vars.today, 15, Months)};

    Date interpolationDate = vars.calendar.advance(vars.today, 20, Months);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<PiecewiseZeroSpreadedTermStructure>(
                           Handle<YieldTermStructure>(vars.termStructure),
                           spreads, spreadDates);
    spreadedTermStructure->enableExtrapolation();

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        spread2->value();

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testLinearInterpolationMultipleSpreads() {

    BOOST_TEST_MESSAGE("Testing linear interpolation with more than two spreaded dates...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread3 = ext::make_shared<SimpleQuote>(0.035);
    ext::shared_ptr<SimpleQuote> spread4 = ext::make_shared<SimpleQuote>(0.04);
    std::vector<Handle<Quote> > spreads = {
        Handle<Quote>(spread1), Handle<Quote>(spread2),
        Handle<Quote>(spread3), Handle<Quote>(spread4),
    };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 90, Days),
                                     vars.calendar.advance(vars.today, 150, Days),
                                     vars.calendar.advance(vars.today, 30, Months),
                                     vars.calendar.advance(vars.today, 40, Months)};

    Date interpolationDate = vars.calendar.advance(vars.today, 120, Days);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<PiecewiseZeroSpreadedTermStructure>(
                           Handle<YieldTermStructure>(vars.termStructure),
                           spreads, spreadDates);

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        spread1->value();

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testLinearInterpolation() {

    BOOST_TEST_MESSAGE("Testing linear interpolation between two dates...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 100, Days),
                                     vars.calendar.advance(vars.today, 150, Days)};

    Date interpolationDate = vars.calendar.advance(vars.today, 120, Days);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<InterpolatedPiecewiseZeroSpreadedTermStructure<Linear> >(
                        Handle<YieldTermStructure>(vars.termStructure),
                        spreads, spreadDates);

    Date d0 = vars.calendar.advance(vars.today, 100,  Days);
    Date d1 = vars.calendar.advance(vars.today, 150,  Days);
    Date d2 = vars.calendar.advance(vars.today, 120,  Days);

    Real m = (0.03-0.02)/vars.dayCount.yearFraction(d0,d1);
    Real expectedRate = m * vars.dayCount.yearFraction(d0, d2) + 0.054;

    Time t = vars.dayCount.yearFraction(vars.settlementDate, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testForwardFlatInterpolation() {

    BOOST_TEST_MESSAGE("Testing forward flat interpolation between two dates...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 75, Days),
                                     vars.calendar.advance(vars.today, 260, Days)};

    Date interpolationDate = vars.calendar.advance(vars.today, 100, Days);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<InterpolatedPiecewiseZeroSpreadedTermStructure<ForwardFlat> >(
                        Handle<YieldTermStructure>(vars.termStructure),
                        spreads, spreadDates);

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        spread1->value();

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testBackwardFlatInterpolation() {

    BOOST_TEST_MESSAGE("Testing backward flat interpolation between two dates...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    ext::shared_ptr<SimpleQuote> spread3 = ext::make_shared<SimpleQuote>(0.04);
    std::vector<Handle<Quote> > spreads = {
        Handle<Quote>(spread1), Handle<Quote>(spread2), Handle<Quote>(spread3)
    };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 100, Days),
                                     vars.calendar.advance(vars.today, 200, Days),
                                     vars.calendar.advance(vars.today, 300, Days)};

    Date interpolationDate = vars.calendar.advance(vars.today, 110, Days);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<InterpolatedPiecewiseZeroSpreadedTermStructure<BackwardFlat> >(
                        Handle<YieldTermStructure>(vars.termStructure),
                        spreads, spreadDates);

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        spread2->value();

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testDefaultInterpolation() {

    BOOST_TEST_MESSAGE("Testing default interpolation between two dates...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.02);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 75,  Days),
                                     vars.calendar.advance(vars.today, 160, Days)};

    Date interpolationDate = vars.calendar.advance(vars.today, 100, Days);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<PiecewiseZeroSpreadedTermStructure>(
                               Handle<YieldTermStructure>(vars.termStructure),
                               spreads, spreadDates);

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        spread1->value();

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testSetInterpolationFactory() {

    BOOST_TEST_MESSAGE("Testing factory constructor with additional parameters...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    ext::shared_ptr<SimpleQuote> spread3 = ext::make_shared<SimpleQuote>(0.01);
    std::vector<Handle<Quote> > spreads = {
        Handle<Quote>(spread1), Handle<Quote>(spread2), Handle<Quote>(spread3)
    };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 8,  Months),
                                     vars.calendar.advance(vars.today, 15, Months),
                                     vars.calendar.advance(vars.today, 25, Months)};

    Date interpolationDate = vars.calendar.advance(vars.today, 11, Months);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure;

    Frequency freq = NoFrequency;

    Cubic factory;
    factory = Cubic(CubicInterpolation::Spline, false);

    spreadedTermStructure =
        ext::make_shared<InterpolatedPiecewiseZeroSpreadedTermStructure<Cubic> >(
                               Handle<YieldTermStructure>(vars.termStructure),
                               spreads, spreadDates, vars.compounding,
                               freq, vars.dayCount,factory);

    Time t = vars.dayCount.yearFraction(vars.today, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);

    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        Real(0.026065770863);

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

void PiecewiseZeroSpreadedTermStructureTest::testMaxDate() {

    BOOST_TEST_MESSAGE("Testing term structure max date...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 8,  Months),
                                     vars.calendar.advance(vars.today, 15, Months)};

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<PiecewiseZeroSpreadedTermStructure>(
                        Handle<YieldTermStructure>(vars.termStructure),
                        spreads, spreadDates);

    Date maxDate = spreadedTermStructure->maxDate();

    Date expectedDate =
        std::min(vars.termStructure->maxDate(), spreadDates.back());

    if (maxDate != expectedDate)
        BOOST_ERROR(
            "unable to reproduce max date\n"
            << "    calculated: " << maxDate << "\n"
            << "    expected: "   << expectedDate);

}

void PiecewiseZeroSpreadedTermStructureTest::testQuoteChanging() {

    BOOST_TEST_MESSAGE("Testing quote update...");

    using namespace piecewise_zero_spreaded_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> spread1 = ext::make_shared<SimpleQuote>(0.02);
    ext::shared_ptr<SimpleQuote> spread2 = ext::make_shared<SimpleQuote>(0.03);
    std::vector<Handle<Quote> > spreads = { Handle<Quote>(spread1), Handle<Quote>(spread2) };

    std::vector<Date> spreadDates = {vars.calendar.advance(vars.today, 100,  Days),
                                     vars.calendar.advance(vars.today, 150, Days)};

    Date interpolationDate = vars.calendar.advance(vars.today, 120, Days);

    ext::shared_ptr<ZeroYieldStructure> spreadedTermStructure =
        ext::make_shared<InterpolatedPiecewiseZeroSpreadedTermStructure<BackwardFlat> >(
                        Handle<YieldTermStructure>(vars.termStructure),
                        spreads, spreadDates);

    Time t = vars.dayCount.yearFraction(vars.settlementDate, interpolationDate);
    Rate interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);
    Real tolerance = 1e-9;
    Real expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                        Real(0.03);

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

    spread2->setValue(0.025);

    interpolatedZeroRate = spreadedTermStructure->zeroRate(t,vars.compounding);
    expectedRate = vars.termStructure->zeroRate(t,vars.compounding) +
                   Real(0.025);

    if (std::fabs(interpolatedZeroRate - expectedRate) > tolerance)
        BOOST_ERROR(
            "unable to reproduce interpolated rate\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(interpolatedZeroRate) << "\n"
            << "    expected: "   << io::rate(expectedRate));

}

test_suite* PiecewiseZeroSpreadedTermStructureTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Interpolated piecewise zero spreaded yield curve tests");
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testFlatInterpolationLeft));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testFlatInterpolationRight));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testLinearInterpolationMultipleSpreads));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testLinearInterpolation));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testBackwardFlatInterpolation));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testForwardFlatInterpolation));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testDefaultInterpolation));
    suite->add(QUANTLIB_TEST_CASE(
        &PiecewiseZeroSpreadedTermStructureTest::testSetInterpolationFactory));
    suite->add(QUANTLIB_TEST_CASE(&PiecewiseZeroSpreadedTermStructureTest::testMaxDate));
    suite->add(QUANTLIB_TEST_CASE(&PiecewiseZeroSpreadedTermStructureTest::testQuoteChanging));
    return suite;
}

]]></document_content>
  </document>
  <document index="229">
    <source>piecewisezerospreadedtermstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_piecewise_zero_spreaded_term_structure_hpp
#define quantlib_test_piecewise_zero_spreaded_term_structure_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class PiecewiseZeroSpreadedTermStructureTest {
  public:
    static void testFlatInterpolationLeft();
    static void testFlatInterpolationRight();
    static void testLinearInterpolationMultipleSpreads();
    static void testLinearInterpolation();
    static void testForwardFlatInterpolation();
    static void testBackwardFlatInterpolation();
    static void testDefaultInterpolation();
    static void testSetInterpolationFactory();
    static void testMaxDate();
    static void testQuoteChanging();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="230">
    <source>quantlibbenchmark.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2008, 2010, 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*
 QuantLib Benchmark Suite

 Measures the performance of a preselected set of numerically intensive
 test cases. The overall QuantLib Benchmark Index is given by the average
 performance in mflops.

 The number of floating point operations of a given test case was measured
 using the perfex library, http://user.it.uu.se/~mikpe/linux/perfctr
 and PAPI, http://icl.cs.utk.edu/papi

 Example results: 1. i7 7820X@3.6GHz        :24192.2 mflops
                  2. i7 4702HQ@2.2GHz       : 6524.9 mflops
                  3. i7 870@2.93GHz         : 4759.2 mflops
                  4. Core2 Q9300@2.5Ghz     : 2272.6 mflops
                  5. Core2 Q6600@2.4Ghz     : 1984.0 mflops
                  6. i3 540@3.1Ghz          : 1755.3 mflops
                  7. Raspberry Pi4@1.5GHz   : 1704.2 mflops
                  8. Core2 Dual@2.0Ghz      :  835.9 mflops
                  9. Athlon 64 X2 4400+     :  824.2 mflops
                 10. Cortex-A57@2.0GHz      :  821.7 mflops
                 11. Core2 Dual@2.0Ghz      :  754.1 mflops
                 12. Pentium4 Dual@2.8Ghz   :  423.8 mflops
                 13. Raspberry Pi3@1.2GHz   :  309.2 mflops
                 14. Pentium4@3.0Ghz        :  266.3 mflops
                 15. PentiumIII@1.1Ghz      :  146.2 mflops
                 16. Alpha 2xEV68@833Mhz    :  184.6 mflops
                 17. Wii PowerPC 750@729MHz :   46.1 mflops
                 18. Raspberry Pi ARM@700Mhz:   28.3 mflops
                 19. MIPS R5000@150MHz      :   12.6 mflops
                 20. RISC-V on FPGA@25Mhz   :    2.4 mflops
                 21. Strong ARM@206Mhz      :    1.4 mflops

 Remarks: OS: Linux, static libs
  1. g++-6.3.0 -O3 -ffast-math -march=core-avx2
      Remark: 16 processes
  2. g++-4.8.1 -O3 -ffast-math -march=core-avx2
      Remark: eight processes
  3. gcc-4.6.3, -O3 -ffast-math -mfpmath=sse,387 -march=corei7
      Remark: eight processes
  4. icc-11.0,  -gcc-version=420 -fast -fp-model fast=2 -ipo-jobs2
      Remark: four processes
  5. icc-11.0,  -gcc-version=420 -fast -fp-model fast=2 -ipo-jobs2
      Remark: four processes
  6. gcc-4.4.5, -O3 -ffast-math -mfpmath=sse,387 -msse4.2 -march=core2
      Remark: four processes
  7. gcc-8.3.0, -O3 -ffast-math -mcpu=cortx-a8 -mfpu=neon-fp-armv8
      Remark: four processes
  8. icc-11.0,  -gcc-version=420 -fast -fp-model fast=2 -ipo-jobs2
      Remark: two processes
  9. icc-11.0,  -gcc-version=420 -xSSSE3 -O3 -ipo -no-prec-div -static
                -fp-model fast=2 -ipo-jobs2, Remark: two processes
 10. clang++-6.0.1 -O2, Remark: four processes
 11. gcc-4.2.1, -O3 -ffast-math -mfpmath=sse,387 -msse3 -funroll-all-loops
      Remark: two processes
 12. gcc-4.0.1, -O3 -march=pentium4 -ffast-math
      -mfpmath=sse,387 -msse2 -funroll-all-loops, Remark: two processes
 13. gcc-4.9.2  -O2, Remark: four processes
 14. gcc-4.0.1, -O3 -march=pentium4 -ffast-math
                -mfpmath=sse,387 -msse2 -funroll-all-loops
 15. gcc-4.1.1, -O3 -march=pentium3 -ffast-math
                -mfpmath=sse,387 -msse -funroll-all-loops
 16. gcc-3.3.5, -O3 -mcpu=e67 -funroll-all-loops, Remark: two processes
 17. gcc-4.9.2, -O2 -g on a Nintendo Wii
 18. gcc-4.6.3, -O3
 19. gcc-4-7-4, -O2 on a SGI Indy
 20. gcc-9.2,   -O2 on RISC-V softcore on an Artix7 100T FPGA
 21. gcc-3.4.3, -O2 -g on a Zaurus PDA

  This benchmark is derived from quantlibtestsuite.cpp. Please see the
  copyrights therein.
*/

#include <ql/types.hpp>
#include <ql/version.hpp>
#include <boost/test/unit_test.hpp>
#include <iomanip>
#include <iostream>
#include <list>
#include <string>
#include <utility>
#include <chrono>

/* PAPI code
#include <stdio.h
#include <papi.h>
*/

/* Use BOOST_MSVC instead of _MSC_VER since some other vendors (Metrowerks,
   for example) also #define _MSC_VER
*/
#ifdef BOOST_MSVC
#  include <ql/auto_link.hpp>
#  define BOOST_LIB_NAME boost_unit_test_framework
#  include <boost/config/auto_link.hpp>
#  undef BOOST_LIB_NAME
#endif

#include "utilities.hpp"

#include "americanoption.hpp"
#include "asianoptions.hpp"
#include "barrieroption.hpp"
#include "basketoption.hpp"
#include "batesmodel.hpp"
#include "convertiblebonds.hpp"
#include "digitaloption.hpp"
#include "dividendoption.hpp"
#include "europeanoption.hpp"
#include "fdheston.hpp"
#include "hestonmodel.hpp"
#include "interpolations.hpp"
#include "jumpdiffusion.hpp"
#include "marketmodel_smm.hpp"
#include "marketmodel_cms.hpp"
#include "lowdiscrepancysequences.hpp"
#include "quantooption.hpp"
#include "riskstats.hpp"
#include "shortratemodels.hpp"

using namespace boost::unit_test_framework;


namespace {

    std::list<double> runTimes;

    /* PAPI code
    float real_time, proc_time, mflops;
    long_long lflop, flop=0;
    */

    class TimedCase {
      public:
        typedef void (*fct_ptr)();
        explicit TimedCase(fct_ptr f) : f_(f) {}

        void startMeasurement() const {
            /* PAPI code
               lflop = flop;
               PAPI_flops(&real_time, &proc_time, &flop, &mflops);
            */
        }

        void stopMeasurement() const {
            /* PAPI code
               PAPI_flops(&real_time, &proc_time, &flop, &mflops);
               printf("Real_time: %f Proc_time: %f Total mflop: %f\n",
               real_time, proc_time, (flop-lflop)/1e6);
            */
        }

        void operator()() const {
            startMeasurement();
            auto startTime = std::chrono::steady_clock::now();
            BOOST_CHECK(true); // to prevent no-assertion warning
            f_();
            auto stopTime = std::chrono::steady_clock::now();
            stopMeasurement();
            runTimes.push_back(std::chrono::duration_cast<std::chrono::microseconds>(stopTime - startTime).count() * 1e-6);
        }
      private:
        fct_ptr f_;
    };

    class Benchmark {
      public:
        typedef void (*fct_ptr)();
        Benchmark(std::string name, fct_ptr f, double mflop)
        : f_(f), name_(std::move(name)), mflop_(mflop) {}

        test_case* getTestCase() const {
            #if BOOST_VERSION >= 105900
            return boost::unit_test::make_test_case(f_, name_,
                                                    __FILE__, __LINE__);
            #else
            return boost::unit_test::make_test_case(
                       boost::unit_test::callback0<>(f_), name_);
            #endif
        }
        double getMflop() const {
            return mflop_;
        }
        std::string getName() const {
            return name_;
        }
      private:
        TimedCase f_;
        const std::string name_;
        const double mflop_; // total number of mega floating
                             // point operations (not per sec!)
    };

    std::list<Benchmark> bm;

    void printResults() {
        std::string header = "Benchmark Suite "
        #ifdef BOOST_MSVC
        QL_LIB_NAME;
        #else
        "QuantLib " QL_VERSION;
        #endif

        std::cout << std::endl
                  << std::string(56,'-') << std::endl;
        std::cout << header << std::endl;
        std::cout << std::string(56,'-')
                  << std::endl << std::endl;

        double sum=0;
        std::list<double>::const_iterator iterT = runTimes.begin();
        std::list<Benchmark>::const_iterator iterBM = bm.begin();

        while (iterT != runTimes.end()) {
            const double mflopsPerSec = iterBM->getMflop()/(*iterT);
            std::cout << iterBM->getName()
                      << std::string(42-iterBM->getName().length(),' ') << ":"
                      << std::fixed << std::setw(6) << std::setprecision(1)
                      << mflopsPerSec
                      << " mflops" << std::endl;

            sum+=mflopsPerSec;
            ++iterT;
            ++iterBM;
        }
        std::cout << std::string(56,'-') << std::endl
                  << "QuantLib Benchmark Index                  :"
                  << std::fixed << std::setw(6) << std::setprecision(1)
                  << sum/runTimes.size()
                  << " mflops" << std::endl;
    }
}

#if defined(QL_ENABLE_SESSIONS)
namespace QuantLib {
    ThreadKey sessionId() { return {}; }
}
#endif

test_suite* init_unit_test_suite(int, char*[]) {
    bm.emplace_back("AmericanOption::FdAmericanGreeks", &AmericanOptionTest::testFdAmericanGreeks,
                    518.31);
    bm.emplace_back("AsianOption::MCArithmeticAveragePrice",
                    &AsianOptionTest::testMCDiscreteArithmeticAveragePrice, 5186.13);
    bm.emplace_back("BarrierOption::BabsiriValues", &BarrierOptionTest::testBabsiriValues, 880.8);
    bm.emplace_back("BasketOption::EuroTwoValues", &BasketOptionTest::testEuroTwoValues, 340.04);
    bm.emplace_back("BasketOption::TavellaValues", &BasketOptionTest::testTavellaValues, 933.80);
    bm.emplace_back("BasketOption::OddSamples", &BasketOptionTest::testOddSamples, 642.46);
    bm.emplace_back("BatesModel::DAXCalibration", &BatesModelTest::testDAXCalibration, 1993.35);
    bm.emplace_back("ConvertibleBondTest::testBond", &ConvertibleBondTest::testBond, 159.85);
    bm.emplace_back("DigitalOption::MCCashAtHit", &DigitalOptionTest::testMCCashAtHit, 995.87);
    bm.emplace_back("DividendOption::FdEuropeanGreeks", &DividendOptionTest::testFdEuropeanGreeks,
                    949.52);
    bm.emplace_back("DividendOption::FdAmericanGreeks", &DividendOptionTest::testFdAmericanGreeks,
                    1113.74);
    bm.emplace_back("EuropeanOption::FdMcEngines", &EuropeanOptionTest::testMcEngines, 1988.63);
    bm.emplace_back("EuropeanOption::ImpliedVol", &EuropeanOptionTest::testImpliedVol, 131.51);
    bm.emplace_back("EuropeanOption::FdEngines", &EuropeanOptionTest::testFdEngines, 148.43);
    bm.emplace_back("FdHestonTest::testFdmHestonAmerican", &FdHestonTest::testFdmHestonAmerican,
                    234.21);
    bm.emplace_back("HestonModel::DAXCalibration", &HestonModelTest::testDAXCalibration, 555.19);
    bm.emplace_back("InterpolationTest::testSabrInterpolation",
                    &InterpolationTest::testSabrInterpolation, 2266.06);
    bm.emplace_back("JumpDiffusion::Greeks", &JumpDiffusionTest::testGreeks, 433.77);
    bm.emplace_back("MarketModelCmsTest::testCmSwapsSwaptions",
                    &MarketModelCmsTest::testMultiStepCmSwapsAndSwaptions, 11497.73);
    bm.emplace_back("MarketModelSmmTest::testMultiSmmSwaptions",
                    &MarketModelSmmTest::testMultiStepCoterminalSwapsAndSwaptions, 11244.95);
    bm.emplace_back("QuantoOption::ForwardGreeks", &QuantoOptionTest::testForwardGreeks, 90.98);
    bm.emplace_back("RandomNumber::MersenneTwisterDescrepancy",
                    &LowDiscrepancyTest::testMersenneTwisterDiscrepancy, 951.98);
    bm.emplace_back("RiskStatistics::Results", &RiskStatisticsTest::testResults, 300.28);
    bm.emplace_back("ShortRateModel::Swaps", &ShortRateModelTest::testSwaps, 454.73);

    auto* test = BOOST_TEST_SUITE("QuantLib benchmark suite");

    for (std::list<Benchmark>::const_iterator iter = bm.begin();
         iter != bm.end(); ++iter) {
        test->add(iter->getTestCase());
    }

    test->add(QUANTLIB_TEST_CASE(printResults));

    return test;
}
]]></document_content>
  </document>
  <document index="231">
    <source>quantlibtestsuite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2004, 2005, 2006, 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/types.hpp>
#include <ql/settings.hpp>
#include <ql/utilities/dataparsers.hpp>
#include <ql/version.hpp>

#ifdef QL_ENABLE_PARALLEL_UNIT_TEST_RUNNER
#include "paralleltestrunner.hpp"
#else
#include <boost/test/unit_test.hpp>
#endif

/* Use BOOST_MSVC instead of _MSC_VER since some other vendors (Metrowerks,
   for example) also #define _MSC_VER
*/
#ifdef BOOST_MSVC
#  include <ql/auto_link.hpp>

#ifndef QL_ENABLE_PARALLEL_UNIT_TEST_RUNNER
#  define BOOST_LIB_NAME boost_unit_test_framework
#  include <boost/config/auto_link.hpp>
#  undef BOOST_LIB_NAME
#endif

#endif

#include "utilities.hpp"
#include "speedlevel.hpp"

#include "americanoption.hpp"
#include "andreasenhugevolatilityinterpl.hpp"
#include "amortizingbond.hpp"
#include "array.hpp"
#include "asianoptions.hpp"
#include "assetswap.hpp"
#include "autocovariances.hpp"
#include "barrieroption.hpp"
#include "basismodels.hpp"
#include "basketoption.hpp"
#include "batesmodel.hpp"
#include "bermudanswaption.hpp"
#include "binaryoption.hpp"
#include "blackdeltacalculator.hpp"
#include "blackformula.hpp"
#include "bonds.hpp"
#include "brownianbridge.hpp"
#include "businessdayconventions.hpp"
#include "calendars.hpp"
#include "callablebonds.hpp"
#include "capfloor.hpp"
#include "capflooredcoupon.hpp"
#include "cashflows.hpp"
#include "catbonds.hpp"
#include "cdo.hpp"
#include "cdsoption.hpp"
#include "chooseroption.hpp"
#include "cliquetoption.hpp"
#include "cms.hpp"
#include "cmsspread.hpp"
#include "commodityunitofmeasure.hpp"
#include "compiledboostversion.hpp"
#include "compoundoption.hpp"
#include "convertiblebonds.hpp"
#include "covariance.hpp"
#include "creditdefaultswap.hpp"
#include "creditriskplus.hpp"
#include "crosscurrencyratehelpers.hpp"
#include "currency.hpp"
#include "curvestates.hpp"
#include "dates.hpp"
#include "daycounters.hpp"
#include "defaultprobabilitycurves.hpp"
#include "digitalcoupon.hpp"
#include "digitaloption.hpp"
#include "distributions.hpp"
#include "dividendoption.hpp"
#include "doublebarrieroption.hpp"
#include "doublebinaryoption.hpp"
#include "europeanoption.hpp"
#include "everestoption.hpp"
#include "exchangerate.hpp"
#include "extendedtrees.hpp"
#include "extensibleoptions.hpp"
#include "fastfouriertransform.hpp"
#include "fdheston.hpp"
#include "fdcir.hpp"
#include "fdmlinearop.hpp"
#include "fdcev.hpp"
#include "fdsabr.hpp"
#include "fittedbonddiscountcurve.hpp"
#include "forwardoption.hpp"
#include "forwardrateagreement.hpp"
#include "functions.hpp"
#include "gaussianquadratures.hpp"
#include "garch.hpp"
#include "gjrgarchmodel.hpp"
#include "gsr.hpp"
#include "hestonmodel.hpp"
#include "hestonslvmodel.hpp"
#include "himalayaoption.hpp"
#include "hybridhestonhullwhiteprocess.hpp"
#include "indexes.hpp"
#include "inflation.hpp"
#include "inflationcapfloor.hpp"
#include "inflationcapflooredcoupon.hpp"
#include "inflationcpibond.hpp"
#include "inflationcpicapfloor.hpp"
#include "inflationcpiswap.hpp"
#include "inflationvolatility.hpp"
#include "inflationzciisinterpolation.hpp"
#include "instruments.hpp"
#include "integrals.hpp"
#include "interestrates.hpp"
#include "interpolations.hpp"
#include "jumpdiffusion.hpp"
#include "lazyobject.hpp"
#include "libormarketmodel.hpp"
#include "libormarketmodelprocess.hpp"
#include "linearleastsquaresregression.hpp"
#include "lookbackoptions.hpp"
#include "lowdiscrepancysequences.hpp"
#include "margrabeoption.hpp"
#include "marketmodel.hpp"
#include "marketmodel_smmcapletalphacalibration.hpp"
#include "marketmodel_smmcapletcalibration.hpp"
#include "marketmodel_smmcaplethomocalibration.hpp"
#include "marketmodel_smm.hpp"
#include "marketmodel_cms.hpp"
#include "markovfunctional.hpp"
#include "matrices.hpp"
#include "mclongstaffschwartzengine.hpp"
#include "mersennetwister.hpp"
#include "money.hpp"
#include "noarbsabr.hpp"
#include "normalclvmodel.hpp"
#include "nthorderderivativeop.hpp"
#include "nthtodefault.hpp"
#include "numericaldifferentiation.hpp"
#include "observable.hpp"
#include "ode.hpp"
#include "operators.hpp"
#include "optimizers.hpp"
#include "optionletstripper.hpp"
#include "overnightindexedswap.hpp"
#include "pagodaoption.hpp"
#include "partialtimebarrieroption.hpp"
#include "pathgenerator.hpp"
#include "period.hpp"
#include "piecewiseyieldcurve.hpp"
#include "piecewisezerospreadedtermstructure.hpp"
#include "quantooption.hpp"
#include "quotes.hpp"
#include "rangeaccrual.hpp"
#include "riskneutraldensitycalculator.hpp"
#include "riskstats.hpp"
#include "rngtraits.hpp"
#include "rounding.hpp"
#include "sampledcurve.hpp"
#include "schedule.hpp"
#include "settings.hpp"
#include "shortratemodels.hpp"
#include "sofrfutures.hpp"
#include "solvers.hpp"
#include "spreadoption.hpp"
#include "squarerootclvmodel.hpp"
#include "swingoption.hpp"
#include "stats.hpp"
#include "subperiodcoupons.hpp"
#include "swap.hpp"
#include "swapforwardmappings.hpp"
#include "swaption.hpp"
#include "swaptionvolatilitycube.hpp"
#include "swaptionvolatilitymatrix.hpp"
#include "termstructures.hpp"
#include "timegrid.hpp"
#include "timeseries.hpp"
#include "tqreigendecomposition.hpp"
#include "tracing.hpp"
#include "transformedgrid.hpp"
#include "twoassetbarrieroption.hpp"
#include "twoassetcorrelationoption.hpp"
#include "ultimateforwardtermstructure.hpp"
#include "variancegamma.hpp"
#include "varianceoption.hpp"
#include "varianceswaps.hpp"
#include "volatilitymodels.hpp"
#include "vpp.hpp"
#include "zabr.hpp"
#include "zerocouponswap.hpp"

#include <iostream>
#include <iomanip>
#include <chrono>

using namespace boost::unit_test_framework;

namespace {

    decltype(std::chrono::steady_clock::now()) start;

    void startTimer() {
        start = std::chrono::steady_clock::now();
    }

    void stopTimer() {
        auto stop = std::chrono::steady_clock::now();

        double seconds = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start).count() * 1e-3;
        int hours = int(seconds/3600);
        seconds -= hours * 3600;
        int minutes = int(seconds/60);
        seconds -= minutes * 60;

        std::cout << "\nTests completed in ";
        if (hours > 0)
            std::cout << hours << " h ";
        if (hours > 0 || minutes > 0)
            std::cout << minutes << " m ";
        std::cout << std::fixed << std::setprecision(0)
                  << seconds << " s\n" << std::endl;
    }

    void configure(QuantLib::Date evaluationDate) {
        /* if needed, a subset of the lines below can be
           uncommented and/or changed to run the test suite with a
           different configuration. In the future, we'll need a
           mechanism that doesn't force us to recompile (possibly a
           couple of command-line flags for the test suite?)
        */

        // QuantLib::Settings::instance().includeReferenceDateCashFlows() = true;
        // QuantLib::Settings::instance().includeTodaysCashFlows() = boost::none;

        QuantLib::Settings::instance().evaluationDate() = evaluationDate;
    }

}

#if defined(QL_ENABLE_SESSIONS)
namespace QuantLib {

    ThreadKey sessionId() { return {}; }

}
#endif

QuantLib::Date evaluation_date(int argc, char** argv) {
    /*! Dead simple parser:
        - passing --date=YYYY-MM-DD causes the test suite to run on
          that date;
        - passing --date=today causes it to run on today's date;
        - passing nothing causes it to run on a known date for which
          there should be no date-dependent errors as far as we know.

        Dates that should eventually be checked include:
        - 2015-08-29 causes three tests to fail;
        - 2016-02-29 causes two tests to fail.
    */

    QuantLib::Date knownGoodDefault =
        QuantLib::Date(16, QuantLib::September, 2015);

    for (int i=1; i<argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--date=today")
            return QuantLib::Date::todaysDate();
        else if (arg.substr(0, 7) == "--date=")
            return QuantLib::DateParser::parseISO(arg.substr(7));
    }
    return knownGoodDefault;
}


SpeedLevel speed_level(int argc, char** argv) {
    /*! Again, dead simple parser:
        - passing --slow causes all tests to be run;
        - passing --fast causes most tests to be run, except the slowest;
        - passing --faster causes only the faster tests to be run;
        - passing nothing is the same as --slow
    */

    for (int i=1; i<argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--slow")
            return Slow;
        else if (arg == "--fast")
            return Fast;
        else if (arg == "--faster")
            return Faster;
    }
    return Slow;
}


test_suite* init_unit_test_suite(int, char* []) {

    int argc = boost::unit_test::framework::master_test_suite().argc;
    char **argv = boost::unit_test::framework::master_test_suite().argv;
    configure(evaluation_date(argc, argv));
    SpeedLevel speed = speed_level(argc, argv);

    const QuantLib::Settings& settings = QuantLib::Settings::instance();
    std::ostringstream header;
    header <<
        " Testing "
        #ifdef BOOST_MSVC
        QL_LIB_NAME
        #else
        "QuantLib " QL_VERSION
        #endif
        "\n  QL_EXTRA_SAFETY_CHECKS "
        #ifdef QL_EXTRA_SAFETY_CHECKS
        "  defined"
        #else
        "undefined"
        #endif
        "\n  QL_USE_INDEXED_COUPON "
        #ifdef QL_USE_INDEXED_COUPON
        "   defined"
        #else
        " undefined"
        #endif
        "\n"
           << "evaluation date is " << settings.evaluationDate() << ",\n"
           << (settings.includeReferenceDateEvents()
               ? "reference date events are included,\n"
               : "reference date events are excluded,\n")
           << (settings.includeTodaysCashFlows() == boost::none ?
               "" : (*settings.includeTodaysCashFlows() ?
                     "today's cashflows are included,\n"
                     : "today's cashflows are excluded,\n"))
           << (settings.enforcesTodaysHistoricFixings()
               ? "today's historic fixings are enforced."
               : "today's historic fixings are not enforced.")
           << "\nRunning "
           << (speed == Faster ? "faster" :
               (speed == Fast ?   "fast" : "all"))
           << " tests.";

    std::string rule = std::string(41, '=');

    BOOST_TEST_MESSAGE(rule);
    BOOST_TEST_MESSAGE(header.str());
    BOOST_TEST_MESSAGE(rule);
    auto* test = BOOST_TEST_SUITE("QuantLib test suite");

    test->add(QUANTLIB_TEST_CASE(startTimer));

    test->add(AmericanOptionTest::suite(speed));
    test->add(AndreasenHugeVolatilityInterplTest::suite(speed));
    test->add(ArrayTest::suite());
    test->add(AsianOptionTest::suite(speed));
    test->add(AssetSwapTest::suite()); // fails with QL_USE_INDEXED_COUPON
    test->add(AutocovariancesTest::suite());
    test->add(BarrierOptionTest::suite());
    test->add(BasketOptionTest::suite(speed));
    test->add(BatesModelTest::suite());
    test->add(BermudanSwaptionTest::suite(speed));
    test->add(BinaryOptionTest::suite());
    test->add(BlackFormulaTest::suite());
    test->add(BondTest::suite());
    test->add(BrownianBridgeTest::suite());
    test->add(BusinessDayConventionTest::suite());
    test->add(CalendarTest::suite());
    test->add(CapFloorTest::suite());
    test->add(CapFlooredCouponTest::suite());
    test->add(CashFlowsTest::suite());
    test->add(CliquetOptionTest::suite());
    test->add(CmsTest::suite());
    test->add(CovarianceTest::suite());
    test->add(CPISwapTest::suite());
    test->add(CreditDefaultSwapTest::suite());
    test->add(CrossCurrencyRateHelpersTest::suite());
    test->add(CurrencyTest::suite());
    test->add(CurveStatesTest::suite());
    test->add(DateTest::suite(speed));
    test->add(DayCounterTest::suite());
    test->add(DefaultProbabilityCurveTest::suite());
    test->add(DigitalCouponTest::suite()); // might fail with QL_USE_INDEXED_COUPON
    test->add(DigitalOptionTest::suite());
    test->add(DistributionTest::suite(speed));
    test->add(DividendOptionTest::suite());
    test->add(EuropeanOptionTest::suite());
    test->add(ExchangeRateTest::suite());
    test->add(FastFourierTransformTest::suite());
    test->add(FdHestonTest::suite(speed));
    test->add(FdmLinearOpTest::suite(speed));
    test->add(FdCevTest::suite(speed));
    test->add(FdCIRTest::suite(speed));
    test->add(FdSabrTest::suite(speed));
    test->add(FittedBondDiscountCurveTest::suite());
    test->add(ForwardOptionTest::suite(speed));
    test->add(ForwardRateAgreementTest::suite());
    test->add(FunctionsTest::suite());
    test->add(GARCHTest::suite());
    test->add(GaussianQuadraturesTest::suite());
    test->add(GJRGARCHModelTest::suite(speed));
    test->add(GsrTest::suite());
    test->add(HestonModelTest::suite(speed));
    test->add(HybridHestonHullWhiteProcessTest::suite(speed));
    test->add(IndexTest::suite());
    test->add(InflationTest::suite());
    test->add(InflationCapFloorTest::suite());
    test->add(InflationCapFlooredCouponTest::suite());
    test->add(InflationCPIBondTest::suite());
    test->add(InflationZCIISInterpolationTest::suite());
    test->add(InstrumentTest::suite());
    test->add(IntegralTest::suite());
    test->add(InterestRateTest::suite());
    test->add(InterpolationTest::suite(speed));
    test->add(JumpDiffusionTest::suite());
    test->add(LazyObjectTest::suite());
    test->add(LinearLeastSquaresRegressionTest::suite());
    test->add(LookbackOptionTest::suite(speed));
    test->add(LowDiscrepancyTest::suite());
    test->add(MarketModelTest::suite(speed));
    test->add(MarketModelCmsTest::suite(speed));
    test->add(MarketModelSmmTest::suite(speed));
    test->add(MarketModelSmmCapletAlphaCalibrationTest::suite());
    test->add(MarketModelSmmCapletCalibrationTest::suite());
    test->add(MarketModelSmmCapletHomoCalibrationTest::suite());
    test->add(MarkovFunctionalTest::suite(speed));
    test->add(MatricesTest::suite());
    test->add(MCLongstaffSchwartzEngineTest::suite(speed));
    test->add(MersenneTwisterTest::suite());
    test->add(MoneyTest::suite());
    test->add(NumericalDifferentiationTest::suite());
    test->add(NthOrderDerivativeOpTest::suite(speed));
    test->add(ObservableTest::suite());
    test->add(OdeTest::suite());
    test->add(OperatorTest::suite());
    test->add(OptimizersTest::suite(speed));
    test->add(OptionletStripperTest::suite());
    test->add(OvernightIndexedSwapTest::suite());
    test->add(PathGeneratorTest::suite());
    test->add(PeriodTest::suite());
    test->add(PiecewiseYieldCurveTest::suite());
    test->add(PiecewiseZeroSpreadedTermStructureTest::suite());
    test->add(QuantoOptionTest::suite());
    test->add(QuoteTest::suite());
    test->add(RangeAccrualTest::suite());
    test->add(RiskStatisticsTest::suite());
    test->add(RngTraitsTest::suite());
    test->add(RoundingTest::suite());
    test->add(SampledCurveTest::suite());
    test->add(ScheduleTest::suite());
    test->add(SettingsTest::suite());
    test->add(ShortRateModelTest::suite(speed)); // fails with QL_USE_INDEXED_COUPON
    test->add(SofrFuturesTest::suite());
    test->add(Solver1DTest::suite());
    test->add(StatisticsTest::suite());
    test->add(SubPeriodsCouponTest::suite());
    test->add(SwapTest::suite());
    test->add(SwapForwardMappingsTest::suite());
    test->add(SwaptionTest::suite(speed));
    test->add(SwaptionVolatilityCubeTest::suite());
    test->add(SwaptionVolatilityMatrixTest::suite());
    test->add(TermStructureTest::suite());
    test->add(TimeGridTest::suite());
    test->add(TimeSeriesTest::suite());
    test->add(TqrEigenDecompositionTest::suite());
    test->add(TracingTest::suite());
    test->add(TransformedGridTest::suite());
    test->add(UltimateForwardTermStructureTest::suite());
    test->add(VarianceSwapTest::suite());
    test->add(VolatilityModelsTest::suite());
    test->add(ZeroCouponSwapTest::suite());

    // tests for experimental classes
    test->add(AmortizingBondTest::suite());
    test->add(AsianOptionTest::experimental(speed));
    test->add(BasismodelsTest::suite());
    test->add(BarrierOptionTest::experimental());
    test->add(DoubleBarrierOptionTest::experimental(speed));
    test->add(BlackDeltaCalculatorTest::suite());
    test->add(CallableBondTest::suite());
    test->add(CatBondTest::suite());
    test->add(CdoTest::suite(speed));
    test->add(CdsOptionTest::suite());
    test->add(ChooserOptionTest::suite());
    test->add(CmsSpreadTest::suite());
    test->add(CommodityUnitOfMeasureTest::suite());
    test->add(CompiledBoostVersionTest::suite());
    test->add(CompoundOptionTest::suite());
    test->add(ConvertibleBondTest::suite());
    test->add(CreditRiskPlusTest::suite());
    test->add(DoubleBarrierOptionTest::suite(speed));
    test->add(DoubleBinaryOptionTest::suite());
    test->add(EuropeanOptionTest::experimental());
    test->add(EverestOptionTest::suite());
    test->add(ExtendedTreesTest::suite());
    test->add(ExtensibleOptionsTest::suite());
    test->add(GaussianQuadraturesTest::experimental());
    test->add(HestonModelTest::experimental());
    test->add(HestonSLVModelTest::experimental(speed));
    test->add(HimalayaOptionTest::suite());
    test->add(InflationCPICapFloorTest::suite());
    test->add(InflationVolTest::suite());
    test->add(MargrabeOptionTest::suite());
    test->add(NoArbSabrTest::suite());
    test->add(NormalCLVModelTest::experimental(speed));
    test->add(NthToDefaultTest::suite(speed));
    test->add(PagodaOptionTest::suite());
    test->add(PartialTimeBarrierOptionTest::suite());
    test->add(QuantoOptionTest::experimental());
    test->add(RiskNeutralDensityCalculatorTest::experimental(speed));
    test->add(SpreadOptionTest::suite());
    test->add(SquareRootCLVModelTest::experimental());
    test->add(SwingOptionTest::suite(speed));
    test->add(TwoAssetBarrierOptionTest::suite());
    test->add(TwoAssetCorrelationOptionTest::suite());
    test->add(VarianceGammaTest::suite());
    test->add(VarianceOptionTest::suite());
    test->add(VPPTest::suite(speed));
    test->add(ZabrTest::suite(speed));

    // tests for deprecated classes
    test->add(LiborMarketModelTest::suite(speed));
    test->add(LiborMarketModelProcessTest::suite(speed));

    test->add(QUANTLIB_TEST_CASE(stopTimer));

    return test;
}
]]></document_content>
  </document>
  <document index="232">
    <source>quantooption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2004 StatPro Italia srl
 Copyright (C) 2008 Paul Farrington

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_quanto_option_hpp
#define quantlib_test_quanto_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class QuantoOptionTest {
  public:
    static void testValues();
    static void testGreeks();
    static void testForwardValues();
    static void testForwardGreeks();
    static void testForwardPerformanceValues();
    static void testBarrierValues();
    static void testDoubleBarrierValues();
    static void testFDMQuantoHelper();
    static void testPDEOptionValues();
    static void testAmericanQuantoOption();

    static boost::unit_test_framework::test_suite* suite();
    static boost::unit_test_framework::test_suite* experimental();
};


#endif
]]></document_content>
  </document>
  <document index="233">
    <source>quotes.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "quotes.hpp"
#include "utilities.hpp"
#include <ql/quotes/simplequote.hpp>
#include <ql/quotes/derivedquote.hpp>
#include <ql/quotes/compositequote.hpp>
#include <ql/quotes/forwardvaluequote.hpp>
#include <ql/quotes/impliedstddevquote.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/pricingengines/blackformula.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace quotes_test {

    Real add10(Real x) { return x+10; }
    Real mul10(Real x) { return x*10; }
    Real sub10(Real x) { return x-10; }

    Real add(Real x, Real y) { return x+y; }
    Real mul(Real x, Real y) { return x*y; }
    Real sub(Real x, Real y) { return x-y; }

}


void QuoteTest::testObservable() {

    BOOST_TEST_MESSAGE("Testing observability of quotes...");

    ext::shared_ptr<SimpleQuote> me(new SimpleQuote(0.0));
    Flag f;
    f.registerWith(me);
    me->setValue(3.14);

    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of quote change");

}

void QuoteTest::testObservableHandle() {

    BOOST_TEST_MESSAGE("Testing observability of quote handles...");

    ext::shared_ptr<SimpleQuote> me1(new SimpleQuote(0.0));
    RelinkableHandle<Quote> h(me1);
    Flag f;
    f.registerWith(h);

    me1->setValue(3.14);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of quote change");

    f.lower();
    ext::shared_ptr<SimpleQuote> me2(new SimpleQuote(0.0));
    h.linkTo(me2);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of quote change");

}

void QuoteTest::testDerived() {

    BOOST_TEST_MESSAGE("Testing derived quotes...");

    using namespace quotes_test;

    typedef Real (*unary_f)(Real);
    unary_f funcs[3] = { add10, mul10, sub10 };

    ext::shared_ptr<Quote> me(new SimpleQuote(17.0));
    Handle<Quote> h(me);

    for (auto& func : funcs) {
        DerivedQuote<unary_f> derived(h, func);
        Real x = derived.value(), y = func(me->value());
        if (std::fabs(x-y) > 1.0e-10)
            BOOST_FAIL("derived quote yields " << x << "\n"
                       << "function result is " << y);
    }
}

void QuoteTest::testComposite() {

    BOOST_TEST_MESSAGE("Testing composite quotes...");

    typedef Real (*binary_f)(Real,Real);
    binary_f funcs[3] = { quotes_test::add, quotes_test::mul, quotes_test::sub };

    ext::shared_ptr<Quote> me1(new SimpleQuote(12.0)),
                             me2(new SimpleQuote(13.0));
    Handle<Quote> h1(me1), h2(me2);

    for (auto& func : funcs) {
        CompositeQuote<binary_f> composite(h1, h2, func);
        Real x = composite.value(), y = func(me1->value(), me2->value());
        if (std::fabs(x-y) > 1.0e-10)
            BOOST_FAIL("composite quote yields " << x << "\n"
                       << "function result is " << y);
    }
}

void QuoteTest::testForwardValueQuoteAndImpliedStdevQuote(){
    BOOST_TEST_MESSAGE(
            "Testing forward-value and implied-standard-deviation quotes...");
    Real forwardRate = .05;
    DayCounter dc = ActualActual(ActualActual::ISDA);
    Calendar calendar = TARGET();
    ext::shared_ptr<SimpleQuote> forwardQuote(new SimpleQuote(forwardRate));
    Handle<Quote> forwardHandle(forwardQuote);
    Date evaluationDate = Settings::instance().evaluationDate();
    ext::shared_ptr<YieldTermStructure>yc (new FlatForward(
        evaluationDate, forwardHandle, dc));
    Handle<YieldTermStructure> ycHandle(yc);
    Period euriborTenor(1,Years);
    ext::shared_ptr<Index> euribor(new Euribor(euriborTenor, ycHandle));
    Date fixingDate = calendar.advance(evaluationDate, euriborTenor);
    ext::shared_ptr<ForwardValueQuote> forwardValueQuote( new
        ForwardValueQuote(euribor, fixingDate));
    Rate forwardValue =  forwardValueQuote->value();
    Rate expectedForwardValue = euribor->fixing(fixingDate, true);
    // we test if the forward value given by the quote is consistent
    // with the one directly given by the index
    if (std::fabs(forwardValue-expectedForwardValue) > 1.0e-15)
        BOOST_FAIL("Foward Value Quote quote yields " << forwardValue << "\n"
                   << "expected result is " << expectedForwardValue);
    // then we test the observer/observable chain
    Flag f;
    f.registerWith(forwardValueQuote);
    forwardQuote->setValue(0.04);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of quote change");

    // and we retest if the values are still matching
    forwardValue =  forwardValueQuote->value();
    expectedForwardValue = euribor->fixing(fixingDate, true);
    if (std::fabs(forwardValue-expectedForwardValue) > 1.0e-15)
        BOOST_FAIL("Foward Value Quote quote yields " << forwardValue << "\n"
                   << "expected result is " << expectedForwardValue);
    // we test the ImpliedStdevQuote class
    f.unregisterWith(forwardValueQuote);
    f.lower();
    Real price = 0.02;
    Rate strike = 0.04;
    Volatility guess = .15;
    Real accuracy = 1.0e-6;
    Option::Type optionType = Option::Call;
    ext::shared_ptr<SimpleQuote> priceQuote(new SimpleQuote(price));
    Handle<Quote> priceHandle(priceQuote);
    ext::shared_ptr<ImpliedStdDevQuote> impliedStdevQuote(new
        ImpliedStdDevQuote(optionType, forwardHandle, priceHandle,
                           strike, guess, accuracy));
    Real impliedStdev = impliedStdevQuote->value();
    Real expectedImpliedStdev =
        blackFormulaImpliedStdDev(optionType, strike,
                                  forwardQuote->value(), price,
                                  1.0, 0.0, guess, 1.0e-6);
    if (std::fabs(impliedStdev-expectedImpliedStdev) > 1.0e-15)
        BOOST_FAIL("\nimpliedStdevQuote yields :" << impliedStdev <<
                   "\nexpected result is       :" << expectedImpliedStdev);
    // then we test the observer/observable chain
    ext::shared_ptr<Quote> quote = impliedStdevQuote;
    f.registerWith(quote);
    forwardQuote->setValue(0.05);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of quote change");
    quote->value();
    f.lower();
    quote->value();
    priceQuote->setValue(0.11);
    if (!f.isUp())
        BOOST_FAIL("Observer was not notified of quote change");

}


test_suite* QuoteTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Quote tests");
    suite->add(QUANTLIB_TEST_CASE(&QuoteTest::testObservable));
    suite->add(QUANTLIB_TEST_CASE(&QuoteTest::testObservableHandle));
    suite->add(QUANTLIB_TEST_CASE(&QuoteTest::testDerived));
    suite->add(QUANTLIB_TEST_CASE(&QuoteTest::testComposite));
    suite->add(QUANTLIB_TEST_CASE(
                      &QuoteTest::testForwardValueQuoteAndImpliedStdevQuote));
    return suite;
}

]]></document_content>
  </document>
  <document index="234">
    <source>quotes.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_quotes_hpp
#define quantlib_test_quotes_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class QuoteTest {
  public:
    static void testObservable();
    static void testObservableHandle();
    static void testDerived();
    static void testComposite();
    static void testForwardValueQuoteAndImpliedStdevQuote();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="235">
    <source>rangeaccrual.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_range_accrual_hpp
#define quantlib_test_range_accrual_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class RangeAccrualTest {
  public:
    static void testInfiniteRange();
    static void testPriceMonotonicityWithRespectToLowerStrike();
    static void testPriceMonotonicityWithRespectToUpperStrike();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="236">
    <source>riskneutraldensitycalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015, 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "riskneutraldensitycalculator.hpp"
#include "utilities.hpp"
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/methods/finitedifferences/utilities/bsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/gbsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/localvolrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/hestonblackvolsurface.hpp>
#include <ql/termstructures/volatility/equityfx/localconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/noexceptlocalvolsurface.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/timegrid.hpp>
#include <ql/types.hpp>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void RiskNeutralDensityCalculatorTest::testDensityAgainstOptionPrices() {
    BOOST_TEST_MESSAGE("Testing density against option prices...");

    SavedSettings backup;

    const DayCounter dayCounter = Actual365Fixed();
    const Date todaysDate = Settings::instance().evaluationDate();

    const Real s0 = 100;
    const Handle<Quote> spot(
        ext::make_shared<SimpleQuote>(s0));

    const Rate r = 0.075;
    const Rate q = 0.04;
    const Volatility v = 0.27;

    const Handle<YieldTermStructure> rTS(flatRate(todaysDate, r, dayCounter));

    const Handle<YieldTermStructure> qTS(flatRate(todaysDate, q, dayCounter));

    const ext::shared_ptr<BlackScholesMertonProcess> bsmProcess(
        new BlackScholesMertonProcess(
            spot, qTS, rTS,
            Handle<BlackVolTermStructure>(flatVol(v, dayCounter))));

    const BSMRNDCalculator bsm(bsmProcess);
    const Time times[] = { 0.5, 1.0, 2.0 };
    const Real strikes[] = { 75.0, 100.0, 150.0 };

    for (double t : times) {
        const Volatility stdDev = v * std::sqrt(t);
        const DiscountFactor df = rTS->discount(t);
        const Real fwd = s0*qTS->discount(t)/df;

        for (double strike : strikes) {
            const Real xs = std::log(strike);
            const BlackCalculator blackCalc(
                Option::Put, strike, fwd, stdDev, df);

            const Real tol = 10*std::sqrt(QL_EPSILON);
            const Real calculatedCDF = bsm.cdf(xs, t);
            const Real expectedCDF
                = blackCalc.strikeSensitivity()/df;

            if (std::fabs(calculatedCDF - expectedCDF) > tol) {
                BOOST_FAIL("failed to reproduce Black-Scholes-Merton cdf"
                        << "\n   calculated: " << calculatedCDF
                        << "\n   expected:   " << expectedCDF
                        << "\n   diff:       " << calculatedCDF - expectedCDF
                        << "\n   tol:        " << tol);
            }

            const Real deltaStrike = strike*std::sqrt(QL_EPSILON);

            const Real calculatedPDF = bsm.pdf(xs, t);
            const Real expectedPDF = strike/df*
                (  BlackCalculator(Option::Put, strike+deltaStrike,
                       fwd, stdDev, df).strikeSensitivity()
                 - BlackCalculator(Option::Put, strike - deltaStrike,
                         fwd, stdDev, df).strikeSensitivity())/(2*deltaStrike);

            if (std::fabs(calculatedPDF - expectedPDF) > tol) {
                BOOST_FAIL("failed to reproduce Black-Scholes-Merton pdf"
                        << "\n   calculated: " << calculatedPDF
                        << "\n   expected:   " << expectedPDF
                        << "\n   diff:       " << calculatedPDF - expectedPDF
                        << "\n   tol:        " << tol);
            }
        }
    }
}

void RiskNeutralDensityCalculatorTest::testBSMagainstHestonRND() {
    BOOST_TEST_MESSAGE("Testing Black-Scholes-Merton and Heston densities...");

    SavedSettings backup;

    const DayCounter dayCounter = Actual365Fixed();
    const Date todaysDate = Settings::instance().evaluationDate();

    const Real s0 = 10;
    const Handle<Quote> spot(
        ext::make_shared<SimpleQuote>(s0));

    const Rate r = 0.155;
    const Rate q = 0.0721;
    const Volatility v = 0.27;

    const Real kappa = 1.0;
    const Real theta = v*v;
    const Real rho = -0.75;
    const Real v0 = v*v;
    const Real sigma = 0.0001;

    const Handle<YieldTermStructure> rTS(flatRate(todaysDate, r, dayCounter));

    const Handle<YieldTermStructure> qTS(flatRate(todaysDate, q, dayCounter));

    const ext::shared_ptr<BlackScholesMertonProcess> bsmProcess(
        new BlackScholesMertonProcess(
            spot, qTS, rTS,
            Handle<BlackVolTermStructure>(flatVol(v, dayCounter))));

    const BSMRNDCalculator bsm(bsmProcess);
    const HestonRNDCalculator heston(
        ext::make_shared<HestonProcess>(
            rTS, qTS, spot,
            v0, kappa, theta, sigma, rho), 1e-8);

    const Time times[] = { 0.5, 1.0, 2.0 };
    const Real strikes[] = { 7.5, 10, 15 };
    const Real probs[] = { 1e-6, 0.01, 0.5, 0.99, 1.0-1e-6 };

    for (double t : times) {
        for (double strike : strikes) {
            const Real xs = std::log(strike);

            const Real expectedPDF = bsm.pdf(xs, t);
            const Real calculatedPDF = heston.pdf(xs, t);

            const Real tol = 1e-4;
            if (std::fabs(expectedPDF - calculatedPDF) > tol) {
                BOOST_FAIL("failed to reproduce Black-Scholes-Merton pdf "
                           "with the Heston model"
                        << "\n   calculated: " << calculatedPDF
                        << "\n   expected:   " << expectedPDF
                        << "\n   diff:       " << calculatedPDF - expectedPDF
                        << "\n   tol:        " << tol);
            }

            const Real expectedCDF = bsm.cdf(xs, t);
            const Real calculatedCDF = heston.cdf(xs, t);

            if (std::fabs(expectedCDF - calculatedCDF) > tol) {
                BOOST_FAIL("failed to reproduce Black-Scholes-Merton cdf "
                           "with the Heston model"
                        << "\n   calculated: " << calculatedCDF
                        << "\n   expected:   " << expectedCDF
                        << "\n   diff:       " << calculatedCDF - expectedCDF
                        << "\n   tol:        " << tol);
            }
        }

        for (double prob : probs) {
            const Real expectedInvCDF = bsm.invcdf(prob, t);
            const Real calculatedInvCDF = heston.invcdf(prob, t);

            const Real tol = 1e-3;
            if (std::fabs(expectedInvCDF - calculatedInvCDF) > tol) {
                BOOST_FAIL("failed to reproduce Black-Scholes-Merton "
                        "inverse cdf with the Heston model"
                        << "\n   calculated: " << calculatedInvCDF
                        << "\n   expected:   " << expectedInvCDF
                        << "\n   diff:       " << calculatedInvCDF - expectedInvCDF
                        << "\n   tol:        " << tol);
            }
        }
    }
}

namespace {
    // see Svetlana Borovkova, Ferry J. Permana
    // Implied volatility in oil markets
    // http://www.researchgate.net/publication/46493859_Implied_volatility_in_oil_markets
    class DumasParametricVolSurface : public BlackVolatilityTermStructure {
      public:
        DumasParametricVolSurface(Real b1,
                                  Real b2,
                                  Real b3,
                                  Real b4,
                                  Real b5,
                                  ext::shared_ptr<Quote> spot,
                                  const ext::shared_ptr<YieldTermStructure>& rTS,
                                  ext::shared_ptr<YieldTermStructure> qTS)
        : BlackVolatilityTermStructure(0, NullCalendar(), Following, rTS->dayCounter()), b1_(b1),
          b2_(b2), b3_(b3), b4_(b4), b5_(b5), spot_(std::move(spot)), rTS_(rTS),
          qTS_(std::move(qTS)) {}

        Date maxDate() const override { return Date::maxDate(); }
        Rate minStrike() const override { return 0.0; }
        Rate maxStrike() const override { return QL_MAX_REAL; }

      protected:
        Volatility blackVolImpl(Time t, Real strike) const override {
            QL_REQUIRE(t >= 0.0, "t must be >= 0");

            if (t < QL_EPSILON)
                return b1_;

            const Real fwd = spot_->value()*qTS_->discount(t)/rTS_->discount(t);
            const Real mn = std::log(fwd/strike)/std::sqrt(t);

            return b1_ + b2_*mn + b3_*mn*mn + b4_*t + b5_*mn*t;
        }

      private:
        const Real b1_, b2_, b3_, b4_, b5_;
        const ext::shared_ptr<Quote> spot_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const ext::shared_ptr<YieldTermStructure> qTS_;
    };

    class ProbWeightedPayoff {
      public:
        ProbWeightedPayoff(Time t,
                           ext::shared_ptr<Payoff> payoff,
                           ext::shared_ptr<RiskNeutralDensityCalculator> calc)
        : t_(t), payoff_(std::move(payoff)), calc_(std::move(calc)) {}

        Real operator()(Real x) const {
            return calc_->pdf(x, t_) * (*payoff_)(std::exp(x));
        }

      private:
        const Real t_;
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<RiskNeutralDensityCalculator> calc_;
    };

    Disposable<std::vector<Time> > adaptiveTimeGrid(
        Size maxStepsPerYear, Size minStepsPerYear, Real decay, Time endTime) {
        const Time maxDt = 1.0/maxStepsPerYear;
        const Time minDt = 1.0/minStepsPerYear;

        Time t=0.0;
        std::vector<Time> times(1, t);
        while (t < endTime) {
            const Time dt = maxDt*std::exp(-decay*t)
                          + minDt*(1.0-std::exp(-decay*t));
            t+=dt;
            times.push_back(std::min(endTime, t));
        }

        return times;
    }
}

void RiskNeutralDensityCalculatorTest::testLocalVolatilityRND() {
    BOOST_TEST_MESSAGE("Testing Fokker-Planck forward equation "
                       "for local volatility process to calculate "
                       "risk neutral densities...");

    SavedSettings backup;

    const DayCounter dayCounter = Actual365Fixed();
    const Date todaysDate = Date(28, Dec, 2012);
    Settings::instance().evaluationDate() = todaysDate;

    const Rate r       = 0.015;
    const Rate q       = 0.025;
    const Real s0      = 100;
    const Volatility v = 0.25;

    const ext::shared_ptr<Quote> spot(
        ext::make_shared<SimpleQuote>(s0));
    const ext::shared_ptr<YieldTermStructure> rTS(
        flatRate(todaysDate, r, dayCounter));
    const ext::shared_ptr<YieldTermStructure> qTS(
        flatRate(todaysDate, q, dayCounter));

    const ext::shared_ptr<TimeGrid> timeGrid(new TimeGrid(1.0, 101));

    const ext::shared_ptr<LocalVolRNDCalculator> constVolCalc(
        new LocalVolRNDCalculator(
            spot, rTS, qTS,
            ext::make_shared<LocalConstantVol>(todaysDate, v, dayCounter),
            timeGrid, 201));

    const Real rTol = 0.01, atol = 0.005;
    for (Time t=0.1; t < 0.99; t+=0.015) {
        const Volatility stdDev = v * std::sqrt(t);
        const Real xm = - 0.5 * stdDev * stdDev +
            std::log(s0 * qTS->discount(t)/rTS->discount(t));

        const GaussianDistribution gaussianPDF(xm, stdDev);
        const CumulativeNormalDistribution gaussianCDF(xm, stdDev);
        const InverseCumulativeNormal gaussianInvCDF(xm, stdDev);

        for (Real x = xm - 3*stdDev; x < xm + 3*stdDev; x+=0.05) {
            const Real expectedPDF = gaussianPDF(x);
            const Real calculatedPDF = constVolCalc->pdf(x, t);
            const Real absDiffPDF = std::fabs(expectedPDF - calculatedPDF);

            if (absDiffPDF > atol || absDiffPDF/expectedPDF > rTol) {
                BOOST_FAIL("failed to reproduce forward probability density"
                        << "\n   time:       " << t
                        << "\n   spot        " << std::exp(x)
                        << "\n   calculated: " << calculatedPDF
                        << "\n   expected:   " << expectedPDF
                        << "\n   abs diff:   " << absDiffPDF
                        << "\n   rel diff:   " << absDiffPDF/expectedPDF
                        << "\n   abs tol:    " << atol
                        << "\n   rel tol:    " << rTol);
            }

            const Real expectedCDF =  gaussianCDF(x);
            const Real calculatedCDF = constVolCalc->cdf(x, t);
            const Real absDiffCDF = std::fabs(expectedCDF - calculatedCDF);

            if (absDiffCDF > atol) {
                BOOST_FAIL("failed to reproduce forward "
                        "cumulative probability density"
                        << "\n   time:       " << t
                        << "\n   spot        " << std::exp(x)
                        << "\n   calculated: " << calculatedCDF
                        << "\n   expected:   " << expectedCDF
                        << "\n   abs diff:   " << absDiffCDF
                        << "\n   abs tol:    " << atol);
            }

            const Real expectedX = x;
            const Real calculatedX = constVolCalc->invcdf(expectedCDF, t);
            const Real absDiffX = std::fabs(expectedX - calculatedX);

            if (absDiffX > atol || absDiffX/expectedX > rTol) {
                BOOST_FAIL("failed to reproduce "
                        "inverse cumulative probability density"
                        << "\n   time:       " << t
                        << "\n   spot        " << std::exp(x)
                        << "\n   calculated: " << calculatedX
                        << "\n   expected:   " << expectedX
                        << "\n   abs diff:   " << absDiffX
                        << "\n   abs tol:    " << atol);
            }
        }
    }

    const Time tl = timeGrid->at(timeGrid->size()-5);
    const Real xl = constVolCalc->mesher(tl)->locations().front();
    if (!(   constVolCalc->pdf(xl+0.0001, tl) > 0.0
          && constVolCalc->pdf(xl-0.0001, tl) == 0.0)) {
        BOOST_FAIL("probability outside interpolation range is not zero");
    }

    const Real b1 = 0.25;
    const Real b2 = 0.03;
    const Real b3 = 0.005;
    const Real b4 = -0.02;
    const Real b5 = -0.005;

    const ext::shared_ptr<DumasParametricVolSurface> dumasVolSurface(
        new DumasParametricVolSurface(b1, b2, b3, b4, b5, spot, rTS, qTS));

    const ext::shared_ptr<BlackScholesMertonProcess> bsmProcess(
        new BlackScholesMertonProcess(
            Handle<Quote>(spot),
            Handle<YieldTermStructure>(qTS),
            Handle<YieldTermStructure>(rTS),
            Handle<BlackVolTermStructure>(dumasVolSurface)));

    const ext::shared_ptr<LocalVolTermStructure> localVolSurface
        = ext::make_shared<NoExceptLocalVolSurface>(
              Handle<BlackVolTermStructure>(dumasVolSurface),
              Handle<YieldTermStructure>(rTS),
              Handle<YieldTermStructure>(qTS),
              Handle<Quote>(spot), b1);

    const std::vector<Time> adaptiveGrid
        = adaptiveTimeGrid(400, 50, 5.0, 3.0);

    const ext::shared_ptr<TimeGrid> dumasTimeGrid(
        new TimeGrid(adaptiveGrid.begin(), adaptiveGrid.end()));

    const ext::shared_ptr<LocalVolRNDCalculator> dumasVolCalc(
        new LocalVolRNDCalculator(
            spot, rTS, qTS, localVolSurface, dumasTimeGrid, 401, 0.1, 1e-8));

    const Real strikes[] = { 25, 50, 95, 100, 105, 150, 200, 400 };
    const std::vector<Date> maturities = {
        todaysDate + Period(1, Weeks),   todaysDate + Period(1, Months),
        todaysDate + Period(3, Months),  todaysDate + Period(6, Months),
        todaysDate + Period(12, Months), todaysDate + Period(18, Months),
        todaysDate + Period(2, Years),   todaysDate + Period(3, Years) };


    for (auto maturity : maturities) {
        const Time expiry
            = rTS->dayCounter().yearFraction(todaysDate, maturity);

        const ext::shared_ptr<PricingEngine> engine(
            new FdBlackScholesVanillaEngine(
                bsmProcess, std::max(Size(51), Size(expiry*101)),
                201, 0, FdmSchemeDesc::Douglas(), true, b1));

        const ext::shared_ptr<Exercise> exercise(new EuropeanExercise(maturity));

        for (double strike : strikes) {
            const ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(
                (strike > spot->value()) ? Option::Call : Option::Put, strike));

            VanillaOption option(payoff, exercise);
            option.setPricingEngine(engine);
            const Real expected = option.NPV();

            const Time tx = std::max(dumasTimeGrid->at(1),
                                     dumasTimeGrid->closestTime(expiry));
            const std::vector<Real> x = dumasVolCalc->mesher(tx)->locations();

            const ProbWeightedPayoff probWeightedPayoff(
                expiry, payoff, dumasVolCalc);

            const DiscountFactor df = rTS->discount(expiry);
            const Real calculated =    GaussLobattoIntegral(10000, 1e-10)(
                probWeightedPayoff, x.front(), x.back()) * df;

            const Real absDiff = std::fabs(expected - calculated);

            if (absDiff > 0.5*atol) {
                BOOST_ERROR("failed to reproduce option prices for"
                        << "\n   expiry:     " << expiry
                        << "\n   strike:     " << strike
                        << "\n   expected:   " << expected
                        << "\n   calculated: " << calculated
                        << "\n   diff:       " << absDiff
                        << "\n   abs tol:    " << atol);
            }
        }
    }
}

void RiskNeutralDensityCalculatorTest::testSquareRootProcessRND() {
    BOOST_TEST_MESSAGE("Testing probability density for a square root process...");

    struct SquareRootProcessParams {
        const Real v0, kappa, theta, sigma;
    };

    const SquareRootProcessParams params[]
        = { { 0.17, 1.0, 0.09, 0.5 },
            { 1.0, 0.6, 0.1, 0.75 },
            { 0.005, 0.6, 0.1, 0.05 } };

    for (const auto& param : params) {
        const SquareRootProcessRNDCalculator rndCalculator(param.v0, param.kappa, param.theta,
                                                           param.sigma);

        const Time t = 0.75;
        const Time tInfty = 60.0 / param.kappa;

        const Real tol = 1e-10;
        for (Real v = 1e-5; v < 1.0; v += (v < param.theta) ? 0.005 : 0.1) {

            const Real cdfCalculated = rndCalculator.cdf(v, t);
            const Real cdfExpected = GaussLobattoIntegral(10000, 0.01*tol)(
                [&](Real _x) { return rndCalculator.pdf(_x, t); }, 0, v);

            if (std::fabs(cdfCalculated - cdfExpected) > tol) {
                BOOST_FAIL("failed to calculate cdf"
                        << "\n   t:          " << t
                        << "\n   v:          " << v
                        << "\n   calculated: " << cdfCalculated
                        << "\n   expected:   " << cdfExpected
                        << "\n   diff:       " << cdfCalculated - cdfExpected
                        << "\n   tolerance:  " << tol);
            }

            if (cdfExpected < (1-1e-6) && cdfExpected > 1e-6) {
                const Real vCalculated = rndCalculator.invcdf(cdfCalculated, t);

                if (std::fabs(v - vCalculated) > tol) {
                    BOOST_FAIL("failed to calculate round trip cdf <-> invcdf"
                            << "\n   t:          " << t
                            << "\n   v:          " << v
                            << "\n   cdf:        " << cdfExpected
                            << "\n   calculated: " << vCalculated
                            << "\n   diff:       " << v - vCalculated
                            << "\n   tolerance:  " << tol);
                }
            }

            const Real statPdfCalculated = rndCalculator.pdf(v, tInfty);
            const Real statPdfExpected = rndCalculator.stationary_pdf(v);

            if (std::fabs(statPdfCalculated - statPdfExpected) > tol) {
                BOOST_FAIL("failed to calculate stationary pdf"
                        << "\n   v:          " << v
                        << "\n   calculated: " << statPdfCalculated
                        << "\n   expected:   " << statPdfExpected
                        << "\n   diff:       " << statPdfCalculated - statPdfExpected
                        << "\n   tolerance:  " << tol);
            }

            const Real statCdfCalculated = rndCalculator.cdf(v, tInfty);
            const Real statCdfExpected = rndCalculator.stationary_cdf(v);

            if (std::fabs(statCdfCalculated - statCdfExpected) > tol) {
                BOOST_FAIL("failed to calculate stationary cdf"
                        << "\n   v:          " << v
                        << "\n   calculated: " << statCdfCalculated
                        << "\n   expected:   " << statCdfExpected
                        << "\n   diff:       " << statCdfCalculated - statCdfExpected
                        << "\n   tolerance:  " << tol);
            }
        }

        for (Real q = 1e-5; q < 1.0; q+=0.001) {
            const Real statInvCdfCalculated = rndCalculator.invcdf(q, tInfty);
            const Real statInvCdfExpected = rndCalculator.stationary_invcdf(q);

            if (std::fabs(statInvCdfCalculated - statInvCdfExpected) > tol) {
                BOOST_FAIL("failed to calculate stationary inverse of cdf"
                        << "\n   q:          " << q
                        << "\n   calculated: " << statInvCdfCalculated
                        << "\n   expected:   " << statInvCdfExpected
                        << "\n   diff:       " << statInvCdfCalculated - statInvCdfExpected
                        << "\n   tolerance:  " << tol);
            }
        }
    }
}

void RiskNeutralDensityCalculatorTest::testBlackScholesWithSkew() {
    BOOST_TEST_MESSAGE(
        "Testing probability density for a BSM process "
        "with strike dependent volatility vs local volatility...");

    SavedSettings backup;

    const Date todaysDate = Date(3, Oct, 2016);
    Settings::instance().evaluationDate() = todaysDate;

    const DayCounter dc = Actual365Fixed();
    const Date maturityDate = todaysDate + Period(3, Months);
    const Time maturity = dc.yearFraction(todaysDate, maturityDate);

    // use Heston model to create volatility surface with skew
    const Real r     =  0.08;
    const Real q     =  0.03;
    const Real s0    =  100;
    const Real v0    =  0.06;
    const Real kappa =  1.0;
    const Real theta =  0.06;
    const Real sigma =  0.4;
    const Real rho   = -0.75;

    const Handle<YieldTermStructure> rTS(flatRate(todaysDate, r, dc));
    const Handle<YieldTermStructure> qTS(flatRate(todaysDate, q, dc));
    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));

    const ext::shared_ptr<HestonProcess> hestonProcess(
        ext::make_shared<HestonProcess>(
            rTS, qTS, spot, v0, kappa, theta, sigma, rho));

    const Handle<BlackVolTermStructure> hestonSurface(
        ext::make_shared<HestonBlackVolSurface>(
            Handle<HestonModel>(ext::make_shared<HestonModel>(hestonProcess)),
            AnalyticHestonEngine::AndersenPiterbarg,
            AnalyticHestonEngine::Integration::discreteTrapezoid(64)));

    const ext::shared_ptr<TimeGrid> timeGrid(new TimeGrid(maturity, 51));

    const ext::shared_ptr<LocalVolTermStructure> localVol(
        ext::make_shared<NoExceptLocalVolSurface>(
            hestonSurface, rTS, qTS, spot, std::sqrt(theta)));

    const LocalVolRNDCalculator localVolCalc(
        spot.currentLink(), rTS.currentLink(), qTS.currentLink(), localVol,
        timeGrid, 151, 0.25);

    const HestonRNDCalculator hestonCalc(hestonProcess);

    const GBSMRNDCalculator gbsmCalc(
        ext::make_shared<BlackScholesMertonProcess>(
            spot, qTS, rTS, hestonSurface));

    const Real strikes[] = { 85, 75, 90, 110, 125, 150 };

    for (double strike : strikes) {
        const Real logStrike = std::log(strike);

        const Real expected = hestonCalc.cdf(logStrike, maturity);
        const Real calculatedGBSM = gbsmCalc.cdf(strike, maturity);

        const Real gbsmTol = 1e-5;
        if (std::fabs(expected - calculatedGBSM) > gbsmTol) {
            BOOST_FAIL("failed to match Heston and GBSM cdf"
                    << "\n   t:          " << maturity
                    << "\n   k:          " << strike
                    << "\n   calculated: " << calculatedGBSM
                    << "\n   expected:   " << expected
                    << "\n   diff:       " <<
                        std::fabs(calculatedGBSM - expected)
                    << "\n   tolerance:  " << gbsmTol);
        }

        const Real calculatedLocalVol = localVolCalc.cdf(logStrike, maturity);
        const Real localVolTol = 1e-3;
        if (std::fabs(expected - calculatedLocalVol) > localVolTol) {
            BOOST_FAIL("failed to match Heston and local Volatility cdf"
                    << "\n   t:          " << maturity
                    << "\n   k:          " << strike
                    << "\n   calculated: " << calculatedLocalVol
                    << "\n   expected:   " << expected
                    << "\n   diff:       " <<
                        std::fabs(calculatedLocalVol - expected)
                    << "\n   tolerance:  " << localVolTol);
        }
    }

    for (double strike : strikes) {
        const Real logStrike = std::log(strike);

        const Real expected = hestonCalc.pdf(logStrike, maturity)/strike;
        const Real calculatedGBSM = gbsmCalc.pdf(strike, maturity);

        const Real gbsmTol = 1e-5;
        if (std::fabs(expected - calculatedGBSM) > gbsmTol) {
            BOOST_FAIL("failed to match Heston and GBSM pdf"
                    << "\n   t:          " << maturity
                    << "\n   k:          " << strike
                    << "\n   calculated: " << calculatedGBSM
                    << "\n   expected:   " << expected
                    << "\n   diff:       " <<
                        std::fabs(calculatedGBSM - expected)
                    << "\n   tolerance:  " << gbsmTol);
        }

        const Real calculatedLocalVol
            = localVolCalc.pdf(logStrike, maturity)/strike;
        const Real localVolTol = 1e-4;
        if (std::fabs(expected - calculatedLocalVol) > localVolTol) {
            BOOST_FAIL("failed to match Heston and local Volatility pdf"
                    << "\n   t:          " << maturity
                    << "\n   k:          " << strike
                    << "\n   calculated: " << calculatedLocalVol
                    << "\n   expected:   " << expected
                    << "\n   diff:       " <<
                        std::fabs(calculatedLocalVol - expected)
                    << "\n   tolerance:  " << localVolTol);
        }
    }

    const Real quantiles[] = { 0.05, 0.25, 0.5, 0.75, 0.95 };
    for (double quantile : quantiles) {
        const Real expected = std::exp(hestonCalc.invcdf(quantile, maturity));
        const Real calculatedGBSM = gbsmCalc.invcdf(quantile, maturity);

        const Real gbsmTol = 1e-3;
        if (std::fabs(expected - calculatedGBSM) > gbsmTol) {
            BOOST_FAIL("failed to match Heston and GBSM invcdf"
                    << "\n   t:          " << maturity
                    << "\n   quantile:   " << quantile
                    << "\n   calculated: " << calculatedGBSM
                    << "\n   expected:   " << expected
                    << "\n   diff:       " <<
                        std::fabs(calculatedGBSM - expected)
                    << "\n   tolerance:  " << gbsmTol);
        }

        const Real calculatedLocalVol
            = std::exp(localVolCalc.invcdf(quantile, maturity));
        const Real localVolTol = 0.1;
        if (std::fabs(expected - calculatedLocalVol) > localVolTol) {
            BOOST_FAIL("failed to match Heston and local Volatility invcdf"
                    << "\n   t:          " << maturity
                    << "\n   k:          " << quantile
                    << "\n   calculated: " << calculatedLocalVol
                    << "\n   expected:   " << expected
                    << "\n   diff:       " <<
                        std::fabs(calculatedLocalVol - expected)
                    << "\n   tolerance:  " << localVolTol);
        }
    }
}

void RiskNeutralDensityCalculatorTest::testMassAtZeroCEVProcessRND() {
    BOOST_TEST_MESSAGE("Testing the mass at zero for a "
                       "constant elasticity of variance (CEV) process...");

    const Real f0 = 100.0;
    const Time t = 2.75;

    const std::pair<Real, Real> params[] = {
        {0.1, 1.6},
        {0.01, 2.0},
        {10.0, 0.35},
        {50.0, 0.1}
    };

    const Real tol = 1e-4;

    for (const auto& param : params) {
        const Real alpha = param.first;
        const Real beta = param.second;

        const ext::shared_ptr<CEVRNDCalculator> calculator =
            ext::make_shared<CEVRNDCalculator>(f0, alpha, beta);

        const Real ax = 15.0*std::sqrt(t)*alpha*std::pow(f0, beta);

        const Real calculated = GaussLobattoIntegral(1000, 1e-8)(
            [&](Real _x) { return calculator->pdf(_x, t); }, std::max(QL_EPSILON, f0-ax), f0+ax) +
            calculator->massAtZero(t);

        if (std::fabs(calculated - 1.0) > tol) {
            BOOST_FAIL("failed to reproduce the total probability mass"
                    << "\n   alpha:     " << alpha
                    << "\n   beta:      " << beta
                    << "\n   prob mass: " << calculated
                    << "\n   tolerance: " << tol);
        }
    }
}

void RiskNeutralDensityCalculatorTest::testCEVCDF() {
    BOOST_TEST_MESSAGE("Testing CDF for a "
                       "constant elasticity of variance (CEV) process...");

    const Real f0 = 2.1;
    const Time t = 0.75;

    const Real alpha = 0.1;
    const Real betas[] = { 0.45, 1.25 };

    const Real tol = 1e-6;
    for (Size i = 1; i < LENGTH(betas); ++i) {
        const Real beta = betas[i];
        const ext::shared_ptr<CEVRNDCalculator> calculator =
            ext::make_shared<CEVRNDCalculator>(f0, alpha, beta);

        for (Real x = 1.3; x < 3.1; x+=0.1) {

            const Real cdfValue = calculator->cdf(x, t);
            const Real calculated = calculator->invcdf(cdfValue, t);

            if (std::fabs(x - calculated) > tol) {
                BOOST_FAIL(
                    "failed to reproduce the inverse cumulative probability"
                        << "\n   alpha:     " << alpha
                        << "\n   beta:      " << beta
                        << "\n   x:         " << x
                        << "\n   calculated:" << calculated
                        << "\n   difference:" << x - calculated
                        << "\n   tolerance: " << tol);
            }
        }
    }
}

test_suite* RiskNeutralDensityCalculatorTest::experimental(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Risk neutral density calculator tests");

    suite->add(QUANTLIB_TEST_CASE(
        &RiskNeutralDensityCalculatorTest::testDensityAgainstOptionPrices));
    suite->add(QUANTLIB_TEST_CASE(
        &RiskNeutralDensityCalculatorTest::testBSMagainstHestonRND));
    suite->add(QUANTLIB_TEST_CASE(
        &RiskNeutralDensityCalculatorTest::testLocalVolatilityRND));
    suite->add(QUANTLIB_TEST_CASE(
        &RiskNeutralDensityCalculatorTest::testSquareRootProcessRND));
    suite->add(QUANTLIB_TEST_CASE(
        &RiskNeutralDensityCalculatorTest::testMassAtZeroCEVProcessRND));
    suite->add(QUANTLIB_TEST_CASE(
          &RiskNeutralDensityCalculatorTest::testCEVCDF));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(
            &RiskNeutralDensityCalculatorTest::testBlackScholesWithSkew));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="237">
    <source>riskneutraldensitycalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_risk_neutral_density_calculator_hpp
#define quantlib_test_risk_neutral_density_calculator_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class RiskNeutralDensityCalculatorTest {
  public:
    static void testDensityAgainstOptionPrices();
    static void testBSMagainstHestonRND();
    static void testLocalVolatilityRND();
    static void testSquareRootProcessRND();
    static void testMassAtZeroCEVProcessRND();
    static void testCEVCDF();
    static void testBlackScholesWithSkew();
    static boost::unit_test_framework::test_suite* experimental(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="238">
    <source>riskstats.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "riskstats.hpp"
#include "utilities.hpp"
#include <ql/math/statistics/riskstatistics.hpp>
#include <ql/math/statistics/incrementalstatistics.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <ql/math/comparison.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

typedef GenericGaussianStatistics<IncrementalStatistics>
    IncrementalGaussianStatistics;

void RiskStatisticsTest::testResults() {

    BOOST_TEST_MESSAGE("Testing risk measures...");

    IncrementalGaussianStatistics igs;
    RiskStatistics s;

    Real averages[] = { -100.0, -1.0, 0.0, 1.0, 100.0 };
    Real sigmas[] = { 0.1, 1.0, 100.0 };
    Size i, j, k, N;
    N = Size(std::pow(2.0,16))-1;
    Real dataMin, dataMax;
    std::vector<Real> data(N), weights(N);

    for (i=0; i<LENGTH(averages); i++) {
        for (j=0; j<LENGTH(sigmas); j++) {

            NormalDistribution normal(averages[i],sigmas[j]);
            CumulativeNormalDistribution cumulative(averages[i],sigmas[j]);
            InverseCumulativeNormal inverseCum(averages[i],sigmas[j]);

            SobolRsg rng(1);
            dataMin = QL_MAX_REAL;
            dataMax = QL_MIN_REAL;
            for (k=0; k<N; k++) {
                data[k] = inverseCum(rng.nextSequence().value[0]);
                dataMin = std::min(dataMin, data[k]);
                dataMax = std::max(dataMax, data[k]);
                weights[k]=1.0;
            }

            igs.addSequence(data.begin(),data.end(),weights.begin());
            s.addSequence(data.begin(),data.end(),weights.begin());

            // checks
            Real calculated, expected;
            Real tolerance;

            if (igs.samples() != N)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong number of samples\n"
                           << "    calculated: " << igs.samples() << "\n"
                           << "    expected:   " << N);
            if (s.samples() != N)
                BOOST_FAIL("RiskStatistics: wrong number of samples\n"
                           << "    calculated: " << s.samples() << "\n"
                           << "    expected:   " << N);


            // weightSum()
            tolerance = 1e-10;
            expected = std::accumulate(weights.begin(),weights.end(),Real(0.0));
            calculated = igs.weightSum();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong sum of weights\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.weightSum();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong sum of weights\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // min
            tolerance = 1e-12;
            expected = dataMin;
            calculated = igs.min();
            if (std::fabs(calculated-expected)>tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong minimum value\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.min();
            if (std::fabs(calculated-expected)>tolerance)
                BOOST_FAIL("RiskStatistics: "
                           << "wrong minimum value\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // max
            expected = dataMax;
            calculated = igs.max();
            if (std::fabs(calculated-expected)>tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong maximum value\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.max();
            if (std::fabs(calculated-expected)>tolerance)
                BOOST_FAIL("RiskStatistics: "
                           << "wrong maximum value\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // mean
            expected = averages[i];
            tolerance = (expected == 0.0 ? 1.0e-13 :
                                           std::fabs(expected)*1.0e-13);
            calculated = igs.mean();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong mean value"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.mean();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong mean value"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // variance
            expected = sigmas[j]*sigmas[j];
            tolerance = expected*1.0e-1;
            calculated = igs.variance();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong variance"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.variance();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong variance"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // standardDeviation
            expected = sigmas[j];
            tolerance = expected*1.0e-1;
            calculated = igs.standardDeviation();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong standard deviation"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.standardDeviation();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong standard deviation"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // missing errorEstimate() test

            // skewness
            expected = 0.0;
            tolerance = 1.0e-4;
            calculated = igs.skewness();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong skewness"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.skewness();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong skewness"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // kurtosis
            expected = 0.0;
            tolerance = 1.0e-1;
            calculated = igs.kurtosis();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong kurtosis"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.kurtosis();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong kurtosis"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // percentile
            expected = averages[i];
            tolerance = (expected == 0.0 ? 1.0e-3 :
                                           std::fabs(expected*1.0e-3));
            calculated = igs.gaussianPercentile(0.5);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian percentile"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianPercentile(0.5);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong Gaussian percentile"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.percentile(0.5);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong percentile"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);



            // potential upside
            Real upper_tail = averages[i]+2.0*sigmas[j],
                 lower_tail = averages[i]-2.0*sigmas[j];
            Real twoSigma = cumulative(upper_tail);

            expected = std::max<Real>(upper_tail,0.0);
            tolerance = (expected == 0.0 ? 1.0e-3 :
                                           std::fabs(expected*1.0e-3));
            calculated = igs.gaussianPotentialUpside(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian potential upside"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianPotentialUpside(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong Gaussian potential upside"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.potentialUpside(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong potential upside"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // just to check that GaussianStatistics<StatsHolder> does work
            StatsHolder h(s.mean(), s.standardDeviation());
            GenericGaussianStatistics<StatsHolder> test(h);
            expected = s.gaussianPotentialUpside(twoSigma);
            calculated = test.gaussianPotentialUpside(twoSigma);
            if (!close(calculated,expected))
                BOOST_FAIL("GenericGaussianStatistics<StatsHolder> fails"
                           << std::setprecision(16)
                           << "\n  calculated: " << calculated
                           << "\n  expected: " << expected);

            // value-at-risk
            expected = -std::min<Real>(lower_tail,0.0);
            tolerance = (expected == 0.0 ? 1.0e-3 :
                                           std::fabs(expected*1.0e-3));
            calculated = igs.gaussianValueAtRisk(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian value-at-risk"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianValueAtRisk(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong Gaussian value-at-risk"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.valueAtRisk(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong value-at-risk"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);

            if (averages[i] > 0.0 && sigmas[j] < averages[i]) {
                // no data will miss the targets:
                // skip the rest of this iteration
                igs.reset();
                s.reset();
                continue;
            }


            // expected shortfall
            expected = -std::min<Real>(averages[i]
                                       - sigmas[j]*sigmas[j]
                                       * normal(lower_tail)/(1.0-twoSigma),
                                       0.0);
            tolerance = (expected == 0.0 ? 1.0e-4
                                         : std::fabs(expected)*1.0e-2);
            calculated = igs.gaussianExpectedShortfall(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian expected shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianExpectedShortfall(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong Gaussian expected shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.expectedShortfall(twoSigma);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong expected shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // shortfall
            expected = 0.5;
            tolerance = (expected == 0.0 ? 1.0e-3 :
                                           std::fabs(expected*1.0e-3));
            calculated = igs.gaussianShortfall(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianShortfall(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong Gaussian shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.shortfall(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // average shortfall
            expected = sigmas[j]/std::sqrt(2.0*M_PI)*2.0;
            tolerance = expected*1.0e-3;
            calculated = igs.gaussianAverageShortfall(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian average shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianAverageShortfall(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong Gaussian average shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.averageShortfall(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: wrong average shortfall"
                           << " for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // regret
            expected = sigmas[j]*sigmas[j];
            tolerance = expected*1.0e-1;
            calculated = igs.gaussianRegret(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian regret(" << averages[i] << ") "
                           << "for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.gaussianRegret(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: "
                           << "wrong Gaussian regret(" << averages[i] << ") "
                           << "for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = s.regret(averages[i]);
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("RiskStatistics: "
                           << "wrong regret(" << averages[i] << ") "
                           << "for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);


            // downsideVariance
            expected = s.downsideVariance();
            tolerance = (expected == 0.0 ? 1.0e-3 :
                                           std::fabs(expected*1.0e-3));
            calculated = igs.downsideVariance();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong downside variance"
                           << "for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);
            calculated = igs.gaussianDownsideVariance();
            if (std::fabs(calculated-expected) > tolerance)
                BOOST_FAIL("IncrementalGaussianStatistics: "
                           << "wrong Gaussian downside variance"
                           << "for N(" << averages[i] << ", "
                           << sigmas[j] << ")\n"
                           << std::setprecision(16)
                           << "    calculated: " << calculated << "\n"
                           << "    expected:   " << expected << "\n"
                           << "    tolerance:  " << tolerance);

            // downsideVariance
            if (averages[i]==0.0) {
                expected = sigmas[j]*sigmas[j];
                tolerance = expected*1.0e-3;
                calculated = igs.downsideVariance();
                if (std::fabs(calculated-expected) > tolerance)
                    BOOST_FAIL("IncrementalGaussianStatistics: "
                               << "wrong downside variance"
                               << "for N(" << averages[i] << ", "
                               << sigmas[j] << ")\n"
                               << std::setprecision(16)
                               << "    calculated: " << calculated << "\n"
                               << "    expected:   " << expected << "\n"
                               << "    tolerance:  " << tolerance);
                calculated = igs.gaussianDownsideVariance();
                if (std::fabs(calculated-expected) > tolerance)
                    BOOST_FAIL("IncrementalGaussianStatistics: "
                               << "wrong Gaussian downside variance"
                               << "for N(" << averages[i] << ", "
                               << sigmas[j] << ")\n"
                               << std::setprecision(16)
                               << "    calculated: " << calculated << "\n"
                               << "    expected:   " << expected << "\n"
                               << "    tolerance:  " << tolerance);
                calculated = s.downsideVariance();
                if (std::fabs(calculated-expected) > tolerance)
                    BOOST_FAIL("RiskStatistics: wrong downside variance"
                               << "for N(" << averages[i] << ", "
                               << sigmas[j] << ")\n"
                               << std::setprecision(16)
                               << "    calculated: " << calculated << "\n"
                               << "    expected:   " << expected << "\n"
                               << "    tolerance:  " << tolerance);
                calculated = s.gaussianDownsideVariance();
                if (std::fabs(calculated-expected) > tolerance)
                    BOOST_FAIL("RiskStatistics: wrong Gaussian downside variance"
                               << "for N(" << averages[i] << ", "
                               << sigmas[j] << ")\n"
                               << std::setprecision(16)
                               << "    calculated: " << calculated << "\n"
                               << "    expected:   " << expected << "\n"
                               << "    tolerance:  " << tolerance);
            }

            igs.reset();
            s.reset();

        }
    }
}


test_suite* RiskStatisticsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Risk statistics tests");
    suite->add(QUANTLIB_TEST_CASE(&RiskStatisticsTest::testResults));
    return suite;
}

]]></document_content>
  </document>
  <document index="239">
    <source>riskstats.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_risk_statistics_hpp
#define quantlib_test_risk_statistics_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class RiskStatisticsTest {
  public:
    static void testResults();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="240">
    <source>rngtraits.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl
 Copyright (C) 2004 Walter Penschke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "rngtraits.hpp"
#include "utilities.hpp"
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/comparison.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void RngTraitsTest::testGaussian() {

    BOOST_TEST_MESSAGE("Testing Gaussian pseudo-random number generation...");

    PseudoRandom::rsg_type rsg =
        PseudoRandom::make_sequence_generator(100, 1234);

    const std::vector<Real>& values = rsg.nextSequence().value;
    Real sum = 0.0;
    for (double value : values)
        sum += value;

    Real stored = 4.09916;
    Real tolerance = 1.0e-5;
    if (std::fabs(sum - stored) > tolerance)
        BOOST_FAIL("the sum of the samples does not match the stored value\n"
                   << "    calculated: " << sum << "\n"
                   << "    expected:   " << stored);
}


void RngTraitsTest::testDefaultPoisson() {

    BOOST_TEST_MESSAGE("Testing Poisson pseudo-random number generation...");

    PoissonPseudoRandom::icInstance =
        ext::shared_ptr<InverseCumulativePoisson>();
    PoissonPseudoRandom::rsg_type rsg =
        PoissonPseudoRandom::make_sequence_generator(100, 1234);

    const std::vector<Real>& values = rsg.nextSequence().value;
    Real sum = 0.0;
    for (double value : values)
        sum += value;

    Real stored = 108.0;
    if (!close(sum, stored))
        BOOST_FAIL("the sum of the samples does not match the stored value\n"
                   << "    calculated: " << sum << "\n"
                   << "    expected:   " << stored);
}


void RngTraitsTest::testCustomPoisson() {

    BOOST_TEST_MESSAGE("Testing custom Poisson pseudo-random number generation...");

    PoissonPseudoRandom::icInstance =
        ext::make_shared<InverseCumulativePoisson>(
                                           4.0);
    PoissonPseudoRandom::rsg_type rsg =
        PoissonPseudoRandom::make_sequence_generator(100, 1234);

    const std::vector<Real>& values = rsg.nextSequence().value;
    Real sum = 0.0;
    for (double value : values)
        sum += value;

    Real stored = 409.0;
    if (!close(sum, stored))
        BOOST_FAIL("the sum of the samples does not match the stored value\n"
                   << "    calculated: " << sum << "\n"
                   << "    expected:   " << stored);
}


test_suite* RngTraitsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("RNG traits tests");
    suite->add(QUANTLIB_TEST_CASE(&RngTraitsTest::testGaussian));
    suite->add(QUANTLIB_TEST_CASE(&RngTraitsTest::testDefaultPoisson));
    suite->add(QUANTLIB_TEST_CASE(&RngTraitsTest::testCustomPoisson));
    return suite;
}

]]></document_content>
  </document>
  <document index="241">
    <source>rngtraits.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl
 Copyright (C) 2004 Walter Penschke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_rng_traits_hpp
#define quantlib_test_rng_traits_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class RngTraitsTest {
  public:
    static void testGaussian();
    static void testDefaultPoisson();
    static void testCustomPoisson();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="242">
    <source>rounding.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "rounding.hpp"
#include "utilities.hpp"
#include <ql/math/rounding.hpp>
#include <ql/math/comparison.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace rounding_test {

    struct TestCase {
        Decimal x;
        Integer precision;
        Decimal closest;
        Decimal up;
        Decimal down;
        Decimal floor;
        Decimal ceiling;
    };

    TestCase testData[] = {
        {  0.86313513, 5,  0.86314,  0.86314,  0.86313,  0.86314,  0.86313 },
        {  0.86313,    5,  0.86313,  0.86313,  0.86313,  0.86313,  0.86313 },
        { -7.64555346, 1, -7.6,     -7.7,     -7.6,     -7.6,     -7.6     },
        {  0.13961605, 2,  0.14,     0.14,     0.13,     0.14,     0.13    },
        {  0.14344179, 4,  0.1434,   0.1435,   0.1434,   0.1434,   0.1434  },
        { -4.74315016, 2, -4.74,    -4.75,    -4.74,    -4.74,    -4.74    },
        { -7.82772074, 5, -7.82772, -7.82773, -7.82772, -7.82772, -7.82772 },
        {  2.74137947, 3,  2.741,    2.742,    2.741,    2.741,    2.741   },
        {  2.13056714, 1,  2.1,      2.2,      2.1,      2.1,      2.1     },
        { -1.06228670, 1, -1.1,     -1.1,     -1.0,     -1.0,     -1.1     },
        {  8.29234094, 4,  8.2923,   8.2924,   8.2923,   8.2923,   8.2923  },
        {  7.90185598, 2,  7.90,     7.91,     7.90,     7.90,     7.90    },
        { -0.26738058, 1, -0.3,     -0.3,     -0.2,     -0.2,     -0.3     },
        {  1.78128713, 1,  1.8,      1.8,      1.7,      1.8,      1.7     },
        {  4.23537260, 1,  4.2,      4.3,      4.2,      4.2,      4.2     },
        {  3.64369953, 4,  3.6437,   3.6437,   3.6436,   3.6437,   3.6436  },
        {  6.34542470, 2,  6.35,     6.35,     6.34,     6.35,     6.34    },
        { -0.84754962, 4, -0.8475,  -0.8476,  -0.8475,  -0.8475,  -0.8475  },
        {  4.60998652, 1,  4.6,      4.7,      4.6,      4.6,      4.6     },
        {  6.28794223, 3,  6.288,    6.288,    6.287,    6.288,    6.287   },
        {  7.89428221, 2,  7.89,     7.90,     7.89,     7.89,     7.89    }
    };

}


void RoundingTest::testClosest() {

    BOOST_TEST_MESSAGE("Testing closest decimal rounding...");

    using namespace rounding_test;

    for (auto& i : testData) {
        Integer digits = i.precision;
        ClosestRounding closest(digits);
        Real calculated = closest(i.x);
        Real expected = i.closest;
        if (!close(calculated,expected,1))
            BOOST_ERROR(std::fixed << std::setprecision(8) << "Original number: " << i.x << "\n"
                                   << std::setprecision(digits) << "Expected:        " << expected
                                   << "\n"
                                   << "Calculated:      " << calculated);
    }
}

void RoundingTest::testUp() {

    BOOST_TEST_MESSAGE("Testing upward decimal rounding...");

    using namespace rounding_test;

    for (auto& i : testData) {
        Integer digits = i.precision;
        UpRounding up(digits);
        Real calculated = up(i.x);
        Real expected = i.up;
        if (!close(calculated,expected,1))
            BOOST_ERROR(std::fixed << std::setprecision(8) << "Original number: " << i.x << "\n"
                                   << std::setprecision(digits) << "Expected:        " << expected
                                   << "\n"
                                   << "Calculated:      " << calculated);
    }
}

void RoundingTest::testDown() {

    BOOST_TEST_MESSAGE("Testing downward decimal rounding...");

    using namespace rounding_test;

    for (auto& i : testData) {
        Integer digits = i.precision;
        DownRounding down(digits);
        Real calculated = down(i.x);
        Real expected = i.down;
        if (!close(calculated,expected,1))
            BOOST_ERROR(std::fixed << std::setprecision(8) << "Original number: " << i.x << "\n"
                                   << std::setprecision(digits) << "Expected:        " << expected
                                   << "\n"
                                   << "Calculated:      " << calculated);
    }
}

void RoundingTest::testFloor() {

    BOOST_TEST_MESSAGE("Testing floor decimal rounding...");

    using namespace rounding_test;

    for (auto& i : testData) {
        Integer digits = i.precision;
        FloorTruncation floor(digits);
        Real calculated = floor(i.x);
        Real expected = i.floor;
        if (!close(calculated,expected,1))
            BOOST_ERROR(std::fixed << std::setprecision(8) << "Original number: " << i.x << "\n"
                                   << std::setprecision(digits) << "Expected:        " << expected
                                   << "\n"
                                   << "Calculated:      " << calculated);
    }
}

void RoundingTest::testCeiling() {

    BOOST_TEST_MESSAGE("Testing ceiling decimal rounding...");

    using namespace rounding_test;

    for (auto& i : testData) {
        Integer digits = i.precision;
        CeilingTruncation ceiling(digits);
        Real calculated = ceiling(i.x);
        Real expected = i.ceiling;
        if (!close(calculated,expected,1))
            BOOST_ERROR(std::fixed << std::setprecision(8) << "Original number: " << i.x << "\n"
                                   << std::setprecision(digits) << "Expected:        " << expected
                                   << "\n"
                                   << "Calculated:      " << calculated);
    }
}


test_suite* RoundingTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Rounding tests");
    suite->add(QUANTLIB_TEST_CASE(&RoundingTest::testClosest));
    suite->add(QUANTLIB_TEST_CASE(&RoundingTest::testUp));
    suite->add(QUANTLIB_TEST_CASE(&RoundingTest::testDown));
    suite->add(QUANTLIB_TEST_CASE(&RoundingTest::testFloor));
    suite->add(QUANTLIB_TEST_CASE(&RoundingTest::testCeiling));
    return suite;
}

]]></document_content>
  </document>
  <document index="243">
    <source>rounding.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_rounding_hpp
#define quantlib_test_rounding_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class RoundingTest {
  public:
    static void testClosest();
    static void testUp();
    static void testDown();
    static void testFloor();
    static void testCeiling();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="244">
    <source>sampledcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "sampledcurve.hpp"
#include "utilities.hpp"
#include <ql/math/sampledcurve.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/grid.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace sampled_curve_test {
    class FSquared {
      public:
        Real operator()(Real x) const { return x*x;};
    };
}

void SampledCurveTest::testConstruction() {

    BOOST_TEST_MESSAGE("Testing sampled curve construction...");

    using namespace sampled_curve_test;

    SampledCurve curve(BoundedGrid(-10.0,10.0,100));
    FSquared f2;
    curve.sample(f2);
    Real expected = 100.0;
    if (std::fabs(curve.value(0) - expected) > 1e-5) {
        BOOST_ERROR("function sampling failed");
    }

    curve.value(0) = 2.0;
    if (std::fabs(curve.value(0) - 2.0) > 1e-5) {
        BOOST_ERROR("curve value setting failed");
    }

    Array& value = curve.values();
    value[1] = 3.0;
    if (std::fabs(curve.value(1) - 3.0) > 1e-5) {
        BOOST_ERROR("curve value grid failed");
    }

    curve.shiftGrid(10.0);
    if (std::fabs(curve.gridValue(0) - 0.0) > 1e-5) {
        BOOST_ERROR("sample curve shift grid failed");
    }
    if (std::fabs(curve.value(0) - 2.0) > 1e-5) {
        BOOST_ERROR("sample curve shift grid - value failed");
    }

    curve.sample(f2);
    curve.regrid(BoundedGrid(0.0,20.0,200));
    Real tolerance = 1.0e-2;
    for (Size i=0; i < curve.size(); i++) {
        Real grid = curve.gridValue(i);
        Real value = curve.value(i);
        Real expected = f2(grid);
        if (std::fabs(value - expected) > tolerance) {
            BOOST_ERROR("sample curve regriding failed" <<
                        "\n    at " << io::ordinal(i+1) << " point " << "(x = " << grid << ")" <<
                        "\n    grid value: " << value <<
                        "\n    expected:   " << expected);
        }
    }
}

test_suite* SampledCurveTest::suite() {
    auto* suite = BOOST_TEST_SUITE("sampled curve tests");
    suite->add(QUANTLIB_TEST_CASE(&SampledCurveTest::testConstruction));
    return suite;
}

]]></document_content>
  </document>
  <document index="245">
    <source>sampledcurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_sampled_curve_hpp
#define quantlib_test_sampled_curve_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SampledCurveTest {
  public:
    static void testConstruction();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="246">
    <source>schedule.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "schedule.hpp"
#include "utilities.hpp"
#include <ql/time/schedule.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/japan.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/calendars/weekendsonly.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <map>
#include <vector>

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::make_pair;
using std::map;
using std::pair;
using std::vector;

namespace {

    void check_dates(const Schedule& s,
                     const std::vector<Date>& expected) {
        if (s.size() != expected.size()) {
            BOOST_FAIL("expected " << expected.size() << " dates, "
                       << "found " << s.size());
        }
        for (Size i=0; i<expected.size(); ++i) {
            if (s[i] != expected[i]) {
                BOOST_ERROR("expected " << expected[i]
                            << " at index " << i << ", "
                            "found " << s[i]);
            }
        }
    }

}


void ScheduleTest::testDailySchedule() {
    BOOST_TEST_MESSAGE("Testing schedule with daily frequency...");

    Date startDate = Date(17,January,2012);

    Schedule s =
        MakeSchedule().from(startDate).to(startDate+7)
                      .withCalendar(TARGET())
                      .withFrequency(Daily)
                      .withConvention(Preceding);

    std::vector<Date> expected(6);
    // The schedule should skip Saturday 21st and Sunday 22rd.
    // Previously, it would adjust them to Friday 20th, resulting
    // in three copies of the same date.
    expected[0] = Date(17,January,2012);
    expected[1] = Date(18,January,2012);
    expected[2] = Date(19,January,2012);
    expected[3] = Date(20,January,2012);
    expected[4] = Date(23,January,2012);
    expected[5] = Date(24,January,2012);

    check_dates(s, expected);
}

void ScheduleTest::testEndDateWithEomAdjustment() {
    BOOST_TEST_MESSAGE(
        "Testing end date for schedule with end-of-month adjustment...");

    Schedule s =
        MakeSchedule().from(Date(30,September,2009))
                      .to(Date(15,June,2012))
                      .withCalendar(Japan())
                      .withTenor(6*Months)
                      .withConvention(Following)
                      .withTerminationDateConvention(Following)
                      .forwards()
                      .endOfMonth();

    std::vector<Date> expected(7);
    // The end date is adjusted, so it should also be moved to the end
    // of the month.
    expected[0] = Date(30,September,2009);
    expected[1] = Date(31,March,2010);
    expected[2] = Date(30,September,2010);
    expected[3] = Date(31,March,2011);
    expected[4] = Date(30,September,2011);
    expected[5] = Date(30,March,2012);
    expected[6] = Date(29,June,2012);

    check_dates(s, expected);

    // now with unadjusted termination date...
    s = MakeSchedule().from(Date(30,September,2009))
                      .to(Date(15,June,2012))
                      .withCalendar(Japan())
                      .withTenor(6*Months)
                      .withConvention(Following)
                      .withTerminationDateConvention(Unadjusted)
                      .forwards()
                      .endOfMonth();
    // ...which should leave it alone.
    expected[6] = Date(15,June,2012);

    check_dates(s, expected);
}


void ScheduleTest::testDatesPastEndDateWithEomAdjustment() {
    BOOST_TEST_MESSAGE(
        "Testing that no dates are past the end date with EOM adjustment...");

    Schedule s =
        MakeSchedule().from(Date(28,March,2013))
                      .to(Date(30,March,2015))
                      .withCalendar(TARGET())
                      .withTenor(1*Years)
                      .withConvention(Unadjusted)
                      .withTerminationDateConvention(Unadjusted)
                      .forwards()
                      .endOfMonth();

    std::vector<Date> expected(3);
    expected[0] = Date(31,March,2013);
    expected[1] = Date(31,March,2014);
    // March 31st 2015, coming from the EOM adjustment of March 28th,
    // should be discarded as past the end date.
    expected[2] = Date(30,March,2015);

    check_dates(s, expected);

    // also, the last period should not be regular.
    if (s.isRegular(2))
        BOOST_ERROR("last period should not be regular");
}

void ScheduleTest::testDatesSameAsEndDateWithEomAdjustment() {
    BOOST_TEST_MESSAGE(
        "Testing that next-to-last date same as end date is removed...");

    Schedule s =
        MakeSchedule().from(Date(28,March,2013))
                      .to(Date(31,March,2015))
                      .withCalendar(TARGET())
                      .withTenor(1*Years)
                      .withConvention(Unadjusted)
                      .withTerminationDateConvention(Unadjusted)
                      .forwards()
                      .endOfMonth();

    std::vector<Date> expected(3);
    expected[0] = Date(31,March,2013);
    expected[1] = Date(31,March,2014);
    // March 31st 2015, coming from the EOM adjustment of March 28th,
    // should be discarded as the same as the end date.
    expected[2] = Date(31,March,2015);

    check_dates(s, expected);

    // also, the last period should be regular.
    if (!s.isRegular(2))
        BOOST_ERROR("last period should be regular");
}

void ScheduleTest::testForwardDatesWithEomAdjustment() {
    BOOST_TEST_MESSAGE(
        "Testing that the last date is not adjusted for EOM when "
        "termination date convention is unadjusted...");

    Schedule s =
        MakeSchedule().from(Date(31,August,1996))
                      .to(Date(15,September,1997))
                      .withCalendar(UnitedStates(UnitedStates::GovernmentBond))
                      .withTenor(6*Months)
                      .withConvention(Unadjusted)
                      .withTerminationDateConvention(Unadjusted)
                      .forwards()
                      .endOfMonth();

    std::vector<Date> expected(4);
    expected[0] = Date(31,August,1996);
    expected[1] = Date(28,February,1997);
    expected[2] = Date(31,August,1997);
    expected[3] = Date(15,September,1997);

    check_dates(s, expected);
}

void ScheduleTest::testBackwardDatesWithEomAdjustment() {
    BOOST_TEST_MESSAGE(
        "Testing that the first date is not adjusted for EOM "
        "going backward when termination date convention is unadjusted...");

    Schedule s =
        MakeSchedule().from(Date(22,August,1996))
                      .to(Date(31,August,1997))
                      .withCalendar(UnitedStates(UnitedStates::GovernmentBond))
                      .withTenor(6*Months)
                      .withConvention(Unadjusted)
                      .withTerminationDateConvention(Unadjusted)
                      .backwards()
                      .endOfMonth();

    std::vector<Date> expected(4);
    expected[0] = Date(22,August,1996);
    expected[1] = Date(31,August,1996);
    expected[2] = Date(28,February,1997);
    expected[3] = Date(31,August,1997);

    check_dates(s, expected);
}

void ScheduleTest::testDoubleFirstDateWithEomAdjustment() {
    BOOST_TEST_MESSAGE(
        "Testing that the first date is not duplicated due to "
        "EOM convention when going backwards...");

    Schedule s =
        MakeSchedule().from(Date(22,August,1996))
                      .to(Date(31,August,1997))
                      .withCalendar(UnitedStates(UnitedStates::GovernmentBond))
                      .withTenor(6*Months)
                      .withConvention(Following)
                      .withTerminationDateConvention(Following)
                      .backwards()
                      .endOfMonth();

    std::vector<Date> expected(3);
    expected[0] = Date(30,August,1996);
    expected[1] = Date(28,February,1997);
    expected[2] = Date(29,August,1997);

    check_dates(s, expected);
}

namespace CdsTests {

    Schedule makeCdsSchedule(const Date& from, const Date& to, DateGeneration::Rule rule) {

        return MakeSchedule()
            .from(from)
            .to(to)
            .withCalendar(WeekendsOnly())
            .withTenor(3 * Months)
            .withConvention(Following)
            .withTerminationDateConvention(Unadjusted)
            .withRule(rule);
    }

    typedef map<pair<Date, Period>, pair<Date, Date> > InputData;

    void testCDSConventions(const InputData& inputs, DateGeneration::Rule rule) {

        // Test the generated start and end date against the expected start and end date.
        for (const auto& input : inputs) {

            Date from = input.first.first;
            Period tenor = input.first.second;

            Date maturity = cdsMaturity(from, tenor, rule);
            Date expEnd = input.second.second;
            BOOST_CHECK_EQUAL(maturity, expEnd);

            Schedule s = makeCdsSchedule(from, maturity, rule);

            Date expStart = input.second.first;
            Date start = s.startDate();
            Date end = s.endDate();
            BOOST_CHECK_EQUAL(start, expStart);
            BOOST_CHECK_EQUAL(end, expEnd);
        }
    }
}

void ScheduleTest::testCDS2015Convention() {

    using CdsTests::makeCdsSchedule;

    BOOST_TEST_MESSAGE("Testing CDS2015 semi-annual rolling convention...");

    DateGeneration::Rule rule = DateGeneration::CDS2015;
    Period tenor(5, Years);

    // From September 20th 2016 to March 19th 2017 of the next year, end date is December 20th 2021 for a 5 year CDS.
    // To get the correct schedule, you can first use the cdsMaturity function to get the maturity from the tenor.
    Date tradeDate(12, Dec, 2016);
    Date maturity = cdsMaturity(tradeDate, tenor, rule);
    Date expStart(20, Sep, 2016);
    Date expMaturity(20, Dec, 2021);
    BOOST_CHECK_EQUAL(maturity, expMaturity);
    Schedule s = makeCdsSchedule(tradeDate, maturity, rule);
    BOOST_CHECK_EQUAL(s.startDate(), expStart);
    BOOST_CHECK_EQUAL(s.endDate(), expMaturity);

    // If we just use 12 Dec 2016 + 5Y = 12 Dec 2021 as termination date in the schedule, the schedule constructor can 
    // use any of the allowable CDS dates i.e. 20 Mar, Jun, Sep and Dec. In the constructor, we just use the next one 
    // here i.e. 20 Dec 2021. We get the same results as above.
    maturity = tradeDate + tenor;
    s = makeCdsSchedule(tradeDate, maturity, rule);
    BOOST_CHECK_EQUAL(s.startDate(), expStart);
    BOOST_CHECK_EQUAL(s.endDate(), expMaturity);

    // We do the same tests but with a trade date of 1 Mar 2017. Using cdsMaturity to get maturity date from 5Y tenor, 
    // we get the same maturity as above.
    tradeDate = Date(1, Mar, 2017);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    BOOST_CHECK_EQUAL(maturity, expMaturity);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expStart = Date(20, Dec, 2016);
    BOOST_CHECK_EQUAL(s.startDate(), expStart);
    BOOST_CHECK_EQUAL(s.endDate(), expMaturity);

    // Using 1 Mar 2017 + 5Y = 1 Mar 2022 as termination date in the schedule, the constructor just uses the next 
    // allowable CDS date i.e. 20 Mar 2022. We must update the expected maturity.
    maturity = tradeDate + tenor;
    s = makeCdsSchedule(tradeDate, maturity, rule);
    BOOST_CHECK_EQUAL(s.startDate(), expStart);
    expMaturity = Date(20, Mar, 2022);
    BOOST_CHECK_EQUAL(s.endDate(), expMaturity);

    // From March 20th 2017 to September 19th 2017, end date is June 20th 2022 for a 5 year CDS.
    tradeDate = Date(20, Mar, 2017);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    expStart = Date(20, Mar, 2017);
    expMaturity = Date(20, Jun, 2022);
    BOOST_CHECK_EQUAL(maturity, expMaturity);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    BOOST_CHECK_EQUAL(s.startDate(), expStart);
    BOOST_CHECK_EQUAL(s.endDate(), expMaturity);
}

void ScheduleTest::testCDS2015ConventionGrid() {

    using CdsTests::InputData;

    // Testing against section 11 of ISDA doc FAQs Amending when Single Name CDS roll to new on-the-run contracts
    // December 20, 2015 Go-Live
    BOOST_TEST_MESSAGE("Testing CDS2015 convention against ISDA doc...");

    // Test inputs and expected outputs
    // The map key is a pair with 1st element equal to trade date and 2nd element equal to CDS tenor.
    // The map value is a pair with 1st and 2nd element equal to expected start and end date respectively.
    // The trade dates are from the transition dates in the doc i.e. 20th Mar, Jun, Sep and Dec in 2016 and a day 
    // either side. The tenors are selected tenors from the doc i.e. short quarterly tenors less than 1Y, 1Y and 5Y.
    InputData inputs = {
        { make_pair(Date(19, Mar, 2016), 3 * Months), make_pair(Date(21, Dec, 2015), Date(20, Mar, 2016)) },
        { make_pair(Date(20, Mar, 2016), 3 * Months), make_pair(Date(21, Dec, 2015), Date(20, Sep, 2016)) },
        { make_pair(Date(21, Mar, 2016), 3 * Months), make_pair(Date(21, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(19, Jun, 2016), 3 * Months), make_pair(Date(21, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Jun, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(21, Jun, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(19, Sep, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Sep, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Sep, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Dec, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Dec, 2016), 3 * Months), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Dec, 2016), 3 * Months), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Mar, 2016), 6 * Months), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2016)) },
        { make_pair(Date(20, Mar, 2016), 6 * Months), make_pair(Date(21, Dec, 2015), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Mar, 2016), 6 * Months), make_pair(Date(21, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Jun, 2016), 6 * Months), make_pair(Date(21, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Jun, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Jun, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Sep, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Sep, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Sep, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Dec, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Dec, 2016), 6 * Months), make_pair(Date(20, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Dec, 2016), 6 * Months), make_pair(Date(20, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Mar, 2016), 9 * Months), make_pair(Date(21, Dec, 2015), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Mar, 2016), 9 * Months), make_pair(Date(21, Dec, 2015), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Mar, 2016), 9 * Months), make_pair(Date(21, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Jun, 2016), 9 * Months), make_pair(Date(21, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Jun, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Jun, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Sep, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Sep, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Sep, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Dec, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(20, Dec, 2016), 9 * Months), make_pair(Date(20, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Dec, 2016), 9 * Months), make_pair(Date(20, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Mar, 2016), 1 * Years), make_pair(Date(21, Dec, 2015), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Mar, 2016), 1 * Years), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Mar, 2016), 1 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Jun, 2016), 1 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Jun, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Jun, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Sep, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Sep, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(21, Sep, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(19, Dec, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(20, Dec, 2016), 1 * Years), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(21, Dec, 2016), 1 * Years), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(19, Mar, 2016), 5 * Years), make_pair(Date(21, Dec, 2015), Date(20, Dec, 2020)) },
        { make_pair(Date(20, Mar, 2016), 5 * Years), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2021)) },
        { make_pair(Date(21, Mar, 2016), 5 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(19, Jun, 2016), 5 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(20, Jun, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(21, Jun, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(19, Sep, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(20, Sep, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(21, Sep, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(19, Dec, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(20, Dec, 2016), 5 * Years), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(21, Dec, 2016), 5 * Years), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(20, Mar, 2016), 0 * Months), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2016)) },
        { make_pair(Date(21, Mar, 2016), 0 * Months), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2016)) },
        { make_pair(Date(19, Jun, 2016), 0 * Months), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2016)) },
        { make_pair(Date(20, Sep, 2016), 0 * Months), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Sep, 2016), 0 * Months), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Dec, 2016), 0 * Months), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2016)) }
    };

    CdsTests::testCDSConventions(inputs, DateGeneration::CDS2015);
}

void ScheduleTest::testCDSConventionGrid() {

    using CdsTests::InputData;

    // Testing against section 11 of ISDA doc FAQs Amending when Single Name CDS roll to new on-the-run contracts
    // December 20, 2015 Go-Live. Amended the dates in the doc to the pre-2015 expected maturity dates.
    BOOST_TEST_MESSAGE("Testing CDS convention against ISDA doc...");

    // Test inputs and expected outputs
    // The map key is a pair with 1st element equal to trade date and 2nd element equal to CDS tenor.
    // The map value is a pair with 1st and 2nd element equal to expected start and end date respectively.
    // The trade dates are from the transition dates in the doc i.e. 20th Mar, Jun, Sep and Dec in 2016 and a day 
    // either side. The tenors are selected tenors from the doc i.e. short quarterly tenors less than 1Y, 1Y and 5Y.
    InputData inputs = {
        { make_pair(Date(19, Mar, 2016), 3 * Months), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2016)) },
        { make_pair(Date(20, Mar, 2016), 3 * Months), make_pair(Date(21, Dec, 2015), Date(20, Sep, 2016)) },
        { make_pair(Date(21, Mar, 2016), 3 * Months), make_pair(Date(21, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(19, Jun, 2016), 3 * Months), make_pair(Date(21, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Jun, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Jun, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Sep, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Sep, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Sep, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Dec, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Dec, 2016), 3 * Months), make_pair(Date(20, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Dec, 2016), 3 * Months), make_pair(Date(20, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Mar, 2016), 6 * Months), make_pair(Date(21, Dec, 2015), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Mar, 2016), 6 * Months), make_pair(Date(21, Dec, 2015), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Mar, 2016), 6 * Months), make_pair(Date(21, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Jun, 2016), 6 * Months), make_pair(Date(21, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Jun, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Jun, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Sep, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Sep, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Sep, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Dec, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Dec, 2016), 6 * Months), make_pair(Date(20, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Dec, 2016), 6 * Months), make_pair(Date(20, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Mar, 2016), 9 * Months), make_pair(Date(21, Dec, 2015), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Mar, 2016), 9 * Months), make_pair(Date(21, Dec, 2015), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Mar, 2016), 9 * Months), make_pair(Date(21, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Jun, 2016), 9 * Months), make_pair(Date(21, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Jun, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Jun, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Sep, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Sep, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Sep, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Dec, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(20, Dec, 2016), 9 * Months), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(21, Dec, 2016), 9 * Months), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(19, Mar, 2016), 1 * Years), make_pair(Date(21, Dec, 2015), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Mar, 2016), 1 * Years), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Mar, 2016), 1 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Jun, 2016), 1 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Jun, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Jun, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Sep, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(20, Sep, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(21, Sep, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(19, Dec, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(20, Dec, 2016), 1 * Years), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2018)) },
        { make_pair(Date(21, Dec, 2016), 1 * Years), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2018)) },
        { make_pair(Date(19, Mar, 2016), 5 * Years), make_pair(Date(21, Dec, 2015), Date(20, Mar, 2021)) },
        { make_pair(Date(20, Mar, 2016), 5 * Years), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2021)) },
        { make_pair(Date(21, Mar, 2016), 5 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(19, Jun, 2016), 5 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(20, Jun, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2021)) },
        { make_pair(Date(21, Jun, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2021)) },
        { make_pair(Date(19, Sep, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2021)) },
        { make_pair(Date(20, Sep, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(21, Sep, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(19, Dec, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(20, Dec, 2016), 5 * Years), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2022)) },
        { make_pair(Date(21, Dec, 2016), 5 * Years), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2022)) },
        { make_pair(Date(19, Mar, 2016), 0 * Months), make_pair(Date(21, Dec, 2015), Date(20, Mar, 2016)) },
        { make_pair(Date(20, Mar, 2016), 0 * Months), make_pair(Date(21, Dec, 2015), Date(20, Jun, 2016)) },
        { make_pair(Date(21, Mar, 2016), 0 * Months), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2016)) },
        { make_pair(Date(19, Jun, 2016), 0 * Months), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2016)) },
        { make_pair(Date(20, Jun, 2016), 0 * Months), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(21, Jun, 2016), 0 * Months), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(19, Sep, 2016), 0 * Months), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Sep, 2016), 0 * Months), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Sep, 2016), 0 * Months), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Dec, 2016), 0 * Months), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Dec, 2016), 0 * Months), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Dec, 2016), 0 * Months), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2017)) }
    };

    CdsTests::testCDSConventions(inputs, DateGeneration::CDS);
}

void ScheduleTest::testOldCDSConventionGrid() {

    using CdsTests::InputData;

    // Testing against section 11 of ISDA doc FAQs Amending when Single Name CDS roll to new on-the-run contracts
    // December 20, 2015 Go-Live. Amended the dates in the doc to the pre-2009 expected start and maturity dates.
    BOOST_TEST_MESSAGE("Testing old CDS convention...");

    // Test inputs and expected outputs
    // The map key is a pair with 1st element equal to trade date and 2nd element equal to CDS tenor.
    // The map value is a pair with 1st and 2nd element equal to expected start and end date respectively.
    // The trade dates are from the transition dates in the doc i.e. 20th Mar, Jun, Sep and Dec in 2016 and a day 
    // either side. The tenors are selected tenors from the doc i.e. short quarterly tenors less than 1Y, 1Y and 5Y.
    InputData inputs = {
        { make_pair(Date(19, Mar, 2016), 3 * Months), make_pair(Date(19, Mar, 2016), Date(20, Jun, 2016)) },
        { make_pair(Date(20, Mar, 2016), 3 * Months), make_pair(Date(20, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(21, Mar, 2016), 3 * Months), make_pair(Date(21, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(19, Jun, 2016), 3 * Months), make_pair(Date(19, Jun, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Jun, 2016), 3 * Months), make_pair(Date(20, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Jun, 2016), 3 * Months), make_pair(Date(21, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Sep, 2016), 3 * Months), make_pair(Date(19, Sep, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Sep, 2016), 3 * Months), make_pair(Date(20, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Sep, 2016), 3 * Months), make_pair(Date(21, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Dec, 2016), 3 * Months), make_pair(Date(19, Dec, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Dec, 2016), 3 * Months), make_pair(Date(20, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Dec, 2016), 3 * Months), make_pair(Date(21, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Mar, 2016), 6 * Months), make_pair(Date(19, Mar, 2016), Date(20, Sep, 2016)) },
        { make_pair(Date(20, Mar, 2016), 6 * Months), make_pair(Date(20, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(21, Mar, 2016), 6 * Months), make_pair(Date(21, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(19, Jun, 2016), 6 * Months), make_pair(Date(19, Jun, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Jun, 2016), 6 * Months), make_pair(Date(20, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Jun, 2016), 6 * Months), make_pair(Date(21, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Sep, 2016), 6 * Months), make_pair(Date(19, Sep, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Sep, 2016), 6 * Months), make_pair(Date(20, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Sep, 2016), 6 * Months), make_pair(Date(21, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Dec, 2016), 6 * Months), make_pair(Date(19, Dec, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Dec, 2016), 6 * Months), make_pair(Date(20, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Dec, 2016), 6 * Months), make_pair(Date(21, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Mar, 2016), 9 * Months), make_pair(Date(19, Mar, 2016), Date(20, Dec, 2016)) },
        { make_pair(Date(20, Mar, 2016), 9 * Months), make_pair(Date(20, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(21, Mar, 2016), 9 * Months), make_pair(Date(21, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(19, Jun, 2016), 9 * Months), make_pair(Date(19, Jun, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Jun, 2016), 9 * Months), make_pair(Date(20, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Jun, 2016), 9 * Months), make_pair(Date(21, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Sep, 2016), 9 * Months), make_pair(Date(19, Sep, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Sep, 2016), 9 * Months), make_pair(Date(20, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Sep, 2016), 9 * Months), make_pair(Date(21, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Dec, 2016), 9 * Months), make_pair(Date(19, Dec, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(20, Dec, 2016), 9 * Months), make_pair(Date(20, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(21, Dec, 2016), 9 * Months), make_pair(Date(21, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(19, Mar, 2016), 1 * Years), make_pair(Date(19, Mar, 2016), Date(20, Mar, 2017)) },
        { make_pair(Date(20, Mar, 2016), 1 * Years), make_pair(Date(20, Mar, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(21, Mar, 2016), 1 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(19, Jun, 2016), 1 * Years), make_pair(Date(19, Jun, 2016), Date(20, Jun, 2017)) },
        { make_pair(Date(20, Jun, 2016), 1 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(21, Jun, 2016), 1 * Years), make_pair(Date(21, Jun, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(19, Sep, 2016), 1 * Years), make_pair(Date(19, Sep, 2016), Date(20, Sep, 2017)) },
        { make_pair(Date(20, Sep, 2016), 1 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(21, Sep, 2016), 1 * Years), make_pair(Date(21, Sep, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(19, Dec, 2016), 1 * Years), make_pair(Date(19, Dec, 2016), Date(20, Dec, 2017)) },
        { make_pair(Date(20, Dec, 2016), 1 * Years), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2018)) },
        { make_pair(Date(21, Dec, 2016), 1 * Years), make_pair(Date(21, Dec, 2016), Date(20, Mar, 2018)) },
        { make_pair(Date(19, Mar, 2016), 5 * Years), make_pair(Date(19, Mar, 2016), Date(20, Mar, 2021)) },
        { make_pair(Date(20, Mar, 2016), 5 * Years), make_pair(Date(20, Mar, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(21, Mar, 2016), 5 * Years), make_pair(Date(21, Mar, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(19, Jun, 2016), 5 * Years), make_pair(Date(19, Jun, 2016), Date(20, Jun, 2021)) },
        { make_pair(Date(20, Jun, 2016), 5 * Years), make_pair(Date(20, Jun, 2016), Date(20, Sep, 2021)) },
        { make_pair(Date(21, Jun, 2016), 5 * Years), make_pair(Date(21, Jun, 2016), Date(20, Sep, 2021)) },
        { make_pair(Date(19, Sep, 2016), 5 * Years), make_pair(Date(19, Sep, 2016), Date(20, Sep, 2021)) },
        { make_pair(Date(20, Sep, 2016), 5 * Years), make_pair(Date(20, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(21, Sep, 2016), 5 * Years), make_pair(Date(21, Sep, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(19, Dec, 2016), 5 * Years), make_pair(Date(19, Dec, 2016), Date(20, Dec, 2021)) },
        { make_pair(Date(20, Dec, 2016), 5 * Years), make_pair(Date(20, Dec, 2016), Date(20, Mar, 2022)) },
        { make_pair(Date(21, Dec, 2016), 5 * Years), make_pair(Date(21, Dec, 2016), Date(20, Mar, 2022)) }
    };

    CdsTests::testCDSConventions(inputs, DateGeneration::OldCDS);
}

void ScheduleTest::testCDS2015ConventionSampleDates() {

    BOOST_TEST_MESSAGE("Testing all dates in sample CDS schedule(s) for rule CDS2015...");

    using CdsTests::makeCdsSchedule;

    DateGeneration::Rule rule = DateGeneration::CDS2015;
    Period tenor(1, Years);

    // trade date = Fri 18 Sep 2015.
    Date tradeDate(18, Sep, 2015);
    Date maturity = cdsMaturity(tradeDate, tenor, rule);
    Schedule s = makeCdsSchedule(tradeDate, maturity, rule);
    vector<Date> expDates = {
        Date(22, Jun, 2015), Date(21, Sep, 2015), Date(21, Dec, 2015),
        Date(21, Mar, 2016), Date(20, Jun, 2016)
    };
    check_dates(s, expDates);

    // trade date = Sat 19 Sep 2015, no change.
    tradeDate = Date(19, Sep, 2015);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    check_dates(s, expDates);

    // trade date = Sun 20 Sep 2015. Roll to new maturity. Trade date still before next coupon payment
    // date of Mon 21 Sep 2015, so keep the first period from 22 Jun 2015 to 21 Sep 2015 in schedule.
    tradeDate = Date(20, Sep, 2015);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expDates.emplace_back(20, Sep, 2016);
    expDates.emplace_back(20, Dec, 2016);
    check_dates(s, expDates);

    // trade date = Mon 21 Sep 2015, first period drops out of schedule.
    tradeDate = Date(21, Sep, 2015);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expDates.erase(expDates.begin());
    check_dates(s, expDates);

    // Another sample trade date, Sat 20 Jun 2009.
    tradeDate = Date(20, Jun, 2009);
    maturity = Date(20, Dec, 2009);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    vector<Date> tmp = {
        Date(20, Mar, 2009), Date(22, Jun, 2009), Date(21, Sep, 2009), Date(20, Dec, 2009)
    };
    expDates.assign(tmp.begin(), tmp.end());
    check_dates(s, expDates);

    // Move forward to Sun 21 Jun 2009
    tradeDate = Date(21, Jun, 2009);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    check_dates(s, expDates);

    // Move forward to Mon 22 Jun 2009
    tradeDate = Date(22, Jun, 2009);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expDates.erase(expDates.begin());
    check_dates(s, expDates);
}

void ScheduleTest::testCDSConventionSampleDates() {

    BOOST_TEST_MESSAGE("Testing all dates in sample CDS schedule(s) for rule CDS...");

    using CdsTests::makeCdsSchedule;

    DateGeneration::Rule rule = DateGeneration::CDS;
    Period tenor(1, Years);

    // trade date = Fri 18 Sep 2015.
    Date tradeDate(18, Sep, 2015);
    Date maturity = cdsMaturity(tradeDate, tenor, rule);
    Schedule s = makeCdsSchedule(tradeDate, maturity, rule);
    vector<Date> expDates = {
        Date(22, Jun, 2015), Date(21, Sep, 2015), Date(21, Dec, 2015),
        Date(21, Mar, 2016), Date(20, Jun, 2016), Date(20, Sep, 2016)
    };
    check_dates(s, expDates);

    // trade date = Sat 19 Sep 2015, no change.
    tradeDate = Date(19, Sep, 2015);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    check_dates(s, expDates);

    // trade date = Sun 20 Sep 2015. Roll to new maturity. Trade date still before next coupon payment
    // date of Mon 21 Sep 2015, so keep the first period from 22 Jun 2015 to 21 Sep 2015 in schedule.
    tradeDate = Date(20, Sep, 2015);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expDates.emplace_back(20, Dec, 2016);
    check_dates(s, expDates);

    // trade date = Mon 21 Sep 2015, first period drops out of schedule.
    tradeDate = Date(21, Sep, 2015);
    maturity = cdsMaturity(tradeDate, tenor, rule);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expDates.erase(expDates.begin());
    check_dates(s, expDates);

    // Another sample trade date, Sat 20 Jun 2009.
    tradeDate = Date(20, Jun, 2009);
    maturity = Date(20, Dec, 2009);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    vector<Date> tmp = { Date(20, Mar, 2009), Date(22, Jun, 2009), Date(21, Sep, 2009), Date(20, Dec, 2009) };
    expDates.assign(tmp.begin(), tmp.end());
    check_dates(s, expDates);

    // Move forward to Sun 21 Jun 2009
    tradeDate = Date(21, Jun, 2009);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    check_dates(s, expDates);

    // Move forward to Mon 22 Jun 2009
    tradeDate = Date(22, Jun, 2009);
    s = makeCdsSchedule(tradeDate, maturity, rule);
    expDates.erase(expDates.begin());
    check_dates(s, expDates);
}

void ScheduleTest::testOldCDSConventionSampleDates() {

    BOOST_TEST_MESSAGE("Testing all dates in sample CDS schedule(s) for rule OldCDS...");

    using CdsTests::makeCdsSchedule;

    DateGeneration::Rule rule = DateGeneration::OldCDS;
    Period tenor(1, Years);

    // trade date plus 1D = Fri 18 Sep 2015.
    Date tradeDatePlusOne(18, Sep, 2015);
    Date maturity = cdsMaturity(tradeDatePlusOne, tenor, rule);
    Schedule s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    vector<Date> expDates = {
        Date(18, Sep, 2015), Date(21, Dec, 2015),
        Date(21, Mar, 2016), Date(20, Jun, 2016), Date(20, Sep, 2016)
    };
    check_dates(s, expDates);

    // trade date plus 1D = Sat 19 Sep 2015, no change.
    // OldCDS, schedule start date is not adjusted (kept this).
    expDates[0] = tradeDatePlusOne = Date(19, Sep, 2015);
    maturity = cdsMaturity(tradeDatePlusOne, tenor, rule);
    s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    check_dates(s, expDates);

    // trade date plus 1D = Sun 20 Sep 2015, roll.
    expDates[0] = tradeDatePlusOne = Date(20, Sep, 2015);
    maturity = cdsMaturity(tradeDatePlusOne, tenor, rule);
    s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    expDates.emplace_back(20, Dec, 2016);
    check_dates(s, expDates);

    // trade date plus 1D = Mon 21 Sep 2015, no change.
    expDates[0] = tradeDatePlusOne = Date(21, Sep, 2015);
    maturity = cdsMaturity(tradeDatePlusOne, tenor, rule);
    s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    check_dates(s, expDates);

    // Check the 30 day stub rule by moving closer to the first coupon payment date of Mon 21 Dec 2015.
    // The test here requires long first stub when trade date plus 1D = 21 Nov 2015. The condition in the schedule 
    // generation code is if: effective date + 30D > next 20th _unadjusted_. Not sure if we should refer to the actual 
    // coupon payment date here i.e. the next 20th _adjusted_ when making the decision.

    // 19 Nov 2015 + 30D = 19 Dec 2015 <= 20 Dec 2015 => short front stub.
    expDates[0] = tradeDatePlusOne = Date(19, Nov, 2015);
    s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    check_dates(s, expDates);

    // 20 Nov 2015 + 30D = 20 Dec 2015 <= 20 Dec 2015 => short front stub.
    expDates[0] = tradeDatePlusOne = Date(20, Nov, 2015);
    s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    check_dates(s, expDates);

    // 21 Nov 2015 + 30D = 21 Dec 2015 > 20 Dec 2015 => long front stub.
    // Note that if we reffered to the next coupon payment date of 21 Dec 2015, it would still be short front.
    expDates[0] = tradeDatePlusOne = Date(21, Nov, 2015);
    s = makeCdsSchedule(tradeDatePlusOne, maturity, rule);
    expDates.erase(expDates.begin() + 1);
    check_dates(s, expDates);
}

void ScheduleTest::testCDS2015ZeroMonthsMatured() {

    BOOST_TEST_MESSAGE("Testing 0M tenor for CDS2015 where matured...");

    DateGeneration::Rule rule = DateGeneration::CDS2015;
    Period tenor(0, Months);

    // Move through selected trade dates from 20 Dec 2015 to 20 Dec 2016 checking that the 0M CDS is matured.
    vector<Date> inputs = {
        Date(20, Dec, 2015),
        Date(15, Feb, 2016),
        Date(19, Mar, 2016),
        Date(20, Jun, 2016),
        Date(15, Aug, 2016),
        Date(19, Sep, 2016),
        Date(20, Dec, 2016)
    };

    for (const Date& input: inputs) {
        BOOST_CHECK_EQUAL(cdsMaturity(input, tenor, rule), Null<Date>());
    }
}

void ScheduleTest::testDateConstructor() {
    BOOST_TEST_MESSAGE("Testing the constructor taking a vector of dates and "
                       "possibly additional meta information...");

    std::vector<Date> dates = {Date(16, May, 2015),
                               Date(18, May, 2015),
                               Date(18, May, 2016),
                               Date(31, December, 2017)};

    // schedule without any additional information
    Schedule schedule1(dates);
    if (schedule1.size() != dates.size())
        BOOST_ERROR("schedule1 has size " << schedule1.size() << ", expected "
                                          << dates.size());
    for (Size i = 0; i < dates.size(); ++i)
        if (schedule1[i] != dates[i])
            BOOST_ERROR("schedule1 has " << schedule1[i] << " at position " << i
                                         << ", expected " << dates[i]);
    if (schedule1.calendar() != NullCalendar())
        BOOST_ERROR("schedule1 has calendar " << schedule1.calendar().name()
                                              << ", expected null calendar");
    if (schedule1.businessDayConvention() != Unadjusted)
        BOOST_ERROR("schedule1 has convention "
                    << schedule1.businessDayConvention()
                    << ", expected unadjusted");

    // schedule with metadata
    std::vector<bool> regular = {false, true, false};
    Schedule schedule2(dates, TARGET(), Following, ModifiedPreceding, 1 * Years,
                       DateGeneration::Backward, true, regular);
    for (Size i = 1; i < dates.size(); ++i)
        if (schedule2.isRegular(i) != regular[i - 1])
            BOOST_ERROR("schedule2 has a "
                        << (schedule2.isRegular(i) ? "regular" : "irregular")
                        << " period at position " << i << ", expected "
                        << (regular[i - 1] ? "regular" : "irregular"));
    if (schedule2.calendar() != TARGET())
        BOOST_ERROR("schedule1 has calendar " << schedule2.calendar().name()
                                              << ", expected TARGET");
    if (schedule2.businessDayConvention() != Following)
        BOOST_ERROR("schedule2 has convention "
                    << schedule2.businessDayConvention()
                    << ", expected Following");
    if (schedule2.terminationDateBusinessDayConvention() != ModifiedPreceding)
        BOOST_ERROR("schedule2 has convention "
                    << schedule2.terminationDateBusinessDayConvention()
                    << ", expected Modified Preceding");
    if (schedule2.tenor() != 1 * Years)
        BOOST_ERROR("schedule2 has tenor " << schedule2.tenor()
                                           << ", expected 1Y");
    if (schedule2.rule() != DateGeneration::Backward)
        BOOST_ERROR("schedule2 has rule " << schedule2.rule()
                                          << ", expected Backward");
    if (!schedule2.endOfMonth())
        BOOST_ERROR("schedule2 has end of month flag false, expected true");
}

void ScheduleTest::testFourWeeksTenor() {
    BOOST_TEST_MESSAGE(
        "Testing that a four-weeks tenor works...");

    try {
        Schedule s =
            MakeSchedule().from(Date(13,January,2016))
                          .to(Date(4,May,2016))
                          .withCalendar(TARGET())
                          .withTenor(4*Weeks)
                          .withConvention(Following)
                          .forwards();
    } catch (Error& e) {
        BOOST_ERROR("A four-weeks tenor caused an exception: " << e.what());
    }
}

void ScheduleTest::testScheduleAlwaysHasAStartDate() {
    BOOST_TEST_MESSAGE("Testing that variations of MakeSchedule "
                       "always produce a schedule with a start date...");
    // Attempt to establish whether the first coupoun payment date is
    // always the second element of the constructor.
    Calendar calendar = UnitedStates();
    Schedule schedule = MakeSchedule()
        .from(Date(10, January, 2017))
        .withFirstDate(Date(31, August, 2017))
        .to(Date(28, February, 2026))
        .withFrequency(Semiannual)
        .withCalendar(calendar)
        .withConvention(Unadjusted)
        .backwards().endOfMonth(false);
    QL_ASSERT(schedule.date(0) == Date(10, January, 2017),
              "The first element should always be the start date");
    schedule = MakeSchedule()
        .from(Date(10, January, 2017))
        .to(Date(28, February, 2026))
        .withFrequency(Semiannual)
        .withCalendar(calendar)
        .withConvention(Unadjusted)
        .backwards().endOfMonth(false);
    QL_ASSERT(schedule.date(0) == Date(10, January, 2017),
              "The first element should always be the start date");
    schedule = MakeSchedule()
        .from(Date(31, August, 2017))
        .to(Date(28, February, 2026))
        .withFrequency(Semiannual)
        .withCalendar(calendar)
        .withConvention(Unadjusted)
        .backwards().endOfMonth(false);
    QL_ASSERT(schedule.date(0) == Date(31, August, 2017),
              "The first element should always be the start date");
}

void ScheduleTest::testShortEomSchedule() {
    BOOST_TEST_MESSAGE("Testing short end-of-month schedule...");
    Schedule s;
    // seg-faults in 1.15
    BOOST_REQUIRE_NO_THROW(s = MakeSchedule()
                                   .from(Date(21, Feb, 2019))
                                   .to(Date(28, Feb, 2019))
                                   .withCalendar(TARGET())
                                   .withTenor(1 * Years)
                                   .withConvention(ModifiedFollowing)
                                   .withTerminationDateConvention(ModifiedFollowing)
                                   .backwards()
                                   .endOfMonth(true));
    BOOST_REQUIRE(s.size() == 2);
    BOOST_CHECK(s[0] == Date(21, Feb, 2019));
    BOOST_CHECK(s[1] == Date(28, Feb, 2019));
}

void ScheduleTest::testFirstDateOnMaturity() {
    BOOST_TEST_MESSAGE("Testing schedule with first date on maturity...");
    Schedule schedule = MakeSchedule()
        .from(Date(20, September, 2016))
        .to(Date(20, December, 2016))
        .withFirstDate(Date(20, December, 2016))
        .withFrequency(Quarterly)
        .withCalendar(UnitedStates())
        .withConvention(Unadjusted)
        .backwards();

    std::vector<Date> expected(2);
    expected[0] = Date(20,September,2016);
    expected[1] = Date(20,December,2016);

    check_dates(schedule, expected);

    schedule = MakeSchedule()
        .from(Date(20, September, 2016))
        .to(Date(20, December, 2016))
        .withFirstDate(Date(20, December, 2016))
        .withFrequency(Quarterly)
        .withCalendar(UnitedStates())
        .withConvention(Unadjusted)
        .forwards();

    check_dates(schedule, expected);
}

void ScheduleTest::testNextToLastDateOnStart() {
    BOOST_TEST_MESSAGE("Testing schedule with next-to-last date on start date...");
    Schedule schedule = MakeSchedule()
        .from(Date(20, September, 2016))
        .to(Date(20, December, 2016))
        .withNextToLastDate(Date(20, September, 2016))
        .withFrequency(Quarterly)
        .withCalendar(UnitedStates())
        .withConvention(Unadjusted)
        .backwards();

    std::vector<Date> expected(2);
    expected[0] = Date(20,September,2016);
    expected[1] = Date(20,December,2016);

    check_dates(schedule, expected);

    schedule = MakeSchedule()
        .from(Date(20, September, 2016))
        .to(Date(20, December, 2016))
        .withNextToLastDate(Date(20, September, 2016))
        .withFrequency(Quarterly)
        .withCalendar(UnitedStates())
        .withConvention(Unadjusted)
        .backwards();

    check_dates(schedule, expected);
}

void ScheduleTest::testTruncation() {
    BOOST_TEST_MESSAGE("Testing schedule truncation...");
    Schedule s = MakeSchedule().from(Date(30, September, 2009))
        .to(Date(15, June, 2020))
        .withCalendar(Japan())
        .withTenor(6 * Months)
        .withConvention(Following)
        .withTerminationDateConvention(Following)
        .forwards()
        .endOfMonth();

    Schedule t;
    std::vector<Date> expected;

    // Until
    t = s.until(Date(1, Jan, 2014));
    expected = std::vector<Date>(10);
    expected[0] = Date(30, September, 2009);
    expected[1] = Date(31, March, 2010);
    expected[2] = Date(30, September, 2010);
    expected[3] = Date(31, March, 2011);
    expected[4] = Date(30, September, 2011);
    expected[5] = Date(30, March, 2012);
    expected[6] = Date(28, September, 2012);
    expected[7] = Date(29, March, 2013);
    expected[8] = Date(30, September, 2013);
    expected[9] = Date(1, January, 2014);
    check_dates(t, expected);
    BOOST_CHECK(t.isRegular().back() == false);

    // Until, with truncation date falling on a schedule date
    t = s.until(Date(30, September, 2013));
    expected = std::vector<Date>(9);
    expected[0] = Date(30, September, 2009);
    expected[1] = Date(31, March, 2010);
    expected[2] = Date(30, September, 2010);
    expected[3] = Date(31, March, 2011);
    expected[4] = Date(30, September, 2011);
    expected[5] = Date(30, March, 2012);
    expected[6] = Date(28, September, 2012);
    expected[7] = Date(29, March, 2013);
    expected[8] = Date(30, September, 2013);
    check_dates(t, expected);
    BOOST_CHECK(t.isRegular().back() == true);

    // After
    t = s.after(Date(1, Jan, 2014));
    expected = std::vector<Date>(15);
    expected[0] = Date(1, January, 2014);
    expected[1] = Date(31, March, 2014);
    expected[2] = Date(30, September, 2014);
    expected[3] = Date(31, March, 2015);
    expected[4] = Date(30, September, 2015);
    expected[5] = Date(31, March, 2016);
    expected[6] = Date(30, September, 2016);
    expected[7] = Date(31, March, 2017);
    expected[8] = Date(29, September, 2017);
    expected[9] = Date(30, March, 2018);
    expected[10] = Date(28, September, 2018);
    expected[11] = Date(29, March, 2019);
    expected[12] = Date(30, September, 2019);
    expected[13] = Date(31, March, 2020);
    expected[14] = Date(30, June, 2020);
    check_dates(t, expected);
    BOOST_CHECK(t.isRegular().front() == false);

    // After, with truncation date falling on a schedule date
    t = s.after(Date(28, September, 2018));
    expected = std::vector<Date>(5);
    expected[0] = Date(28, September, 2018);
    expected[1] = Date(29, March, 2019);
    expected[2] = Date(30, September, 2019);
    expected[3] = Date(31, March, 2020);
    expected[4] = Date(30, June, 2020);
    check_dates(t, expected);
    BOOST_CHECK(t.isRegular().front() == true);
}

test_suite* ScheduleTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Schedule tests");
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testDailySchedule));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testEndDateWithEomAdjustment));
    suite->add(QUANTLIB_TEST_CASE(
        &ScheduleTest::testDatesPastEndDateWithEomAdjustment));
    suite->add(QUANTLIB_TEST_CASE(
        &ScheduleTest::testDatesSameAsEndDateWithEomAdjustment));
    suite->add(QUANTLIB_TEST_CASE(
        &ScheduleTest::testForwardDatesWithEomAdjustment));
    suite->add(QUANTLIB_TEST_CASE(
        &ScheduleTest::testBackwardDatesWithEomAdjustment));
    suite->add(QUANTLIB_TEST_CASE(
        &ScheduleTest::testDoubleFirstDateWithEomAdjustment));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testCDS2015Convention));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testCDS2015ConventionGrid));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testCDSConventionGrid));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testOldCDSConventionGrid));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testCDS2015ConventionSampleDates));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testCDSConventionSampleDates));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testOldCDSConventionSampleDates));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testCDS2015ZeroMonthsMatured));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testDateConstructor));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testFourWeeksTenor));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testScheduleAlwaysHasAStartDate));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testShortEomSchedule));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testFirstDateOnMaturity));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testNextToLastDateOnStart));
    suite->add(QUANTLIB_TEST_CASE(&ScheduleTest::testTruncation));
    return suite;
}
]]></document_content>
  </document>
  <document index="247">
    <source>schedule.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_schedule_hpp
#define quantlib_test_schedule_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ScheduleTest {
  public:
    static void testDailySchedule();
    static void testEndDateWithEomAdjustment();
    static void testDatesPastEndDateWithEomAdjustment();
    static void testDatesSameAsEndDateWithEomAdjustment();
    static void testForwardDatesWithEomAdjustment();
    static void testBackwardDatesWithEomAdjustment();
    static void testDoubleFirstDateWithEomAdjustment();
    static void testCDS2015Convention();
    static void testCDS2015ConventionGrid();
    static void testCDSConventionGrid();
    static void testOldCDSConventionGrid();
    static void testCDS2015ConventionSampleDates();
    static void testCDSConventionSampleDates();
    static void testOldCDSConventionSampleDates();
    static void testCDS2015ZeroMonthsMatured();
    static void testDateConstructor();
    static void testFourWeeksTenor();
    static void testScheduleAlwaysHasAStartDate();
    static void testShortEomSchedule();
    static void testFirstDateOnMaturity();
    static void testNextToLastDateOnStart();
    static void testTruncation();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="248">
    <source>settings.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "settings.hpp"
#include "utilities.hpp"
#include <ql/settings.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;


void SettingsTest::testNotificationsOnDateChange() {
    BOOST_TEST_MESSAGE("Testing notifications on evaluation-date change...");

    SavedSettings rollback;

#ifdef QL_HIGH_RESOLUTION_DATE

    Date d1(11, February, 2021, 9, 17, 0);
    Date d2(11, February, 2021, 10, 21, 0);

#else

    Date d1(11, February, 2021);
    Date d2(12, February, 2021);

#endif

    Settings::instance().evaluationDate() = d1;

    Flag flag;
    flag.registerWith(Settings::instance().evaluationDate());

    // Set to same date, no notification
    Settings::instance().evaluationDate() = d1;

    if (flag.isUp())
        BOOST_ERROR("unexpected notification");

    // Set to different date, notification expected
    Settings::instance().evaluationDate() = d2;

    if (!flag.isUp())
        BOOST_ERROR("missing notification");
}

test_suite* SettingsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("SettingsTest tests");
    suite->add(QUANTLIB_TEST_CASE(&SettingsTest::testNotificationsOnDateChange));
    return suite;
}
]]></document_content>
  </document>
  <document index="249">
    <source>settings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_settings_hpp
#define quantlib_test_settings_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SettingsTest {
  public:
    static void testNotificationsOnDateChange();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="250">
    <source>shortratemodels.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2006 Chiara Fornarola
 Copyright (C) 2005 StatPro Italia srl
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "shortratemodels.hpp"
#include "utilities.hpp"
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/models/shortrate/onefactormodels/extendedcoxingersollross.hpp>
#include <ql/models/shortrate/calibrationhelpers/swaptionhelper.hpp>
#include <ql/pricingengines/swaption/jamshidianswaptionengine.hpp>
#include <ql/pricingengines/swap/treeswapengine.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/indexmanager.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/termstructures/yield/discountcurve.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace short_rate_models_test {

    struct CalibrationData {
        Integer start;
        Integer length;
        Volatility volatility;
    };

}


void ShortRateModelTest::testCachedHullWhite() {
    BOOST_TEST_MESSAGE("Testing Hull-White calibration against cached values using swaptions with start delay...");

    using namespace short_rate_models_test;

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    Date today(15, February, 2002);
    Date settlement(19, February, 2002);
    Settings::instance().evaluationDate() = today;
    Handle<YieldTermStructure> termStructure(flatRate(settlement,0.04875825,
                                                      Actual365Fixed()));
    ext::shared_ptr<HullWhite> model(new HullWhite(termStructure));
    CalibrationData data[] = {{ 1, 5, 0.1148 },
                              { 2, 4, 0.1108 },
                              { 3, 3, 0.1070 },
                              { 4, 2, 0.1021 },
                              { 5, 1, 0.1000 }};
    ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));

    ext::shared_ptr<PricingEngine> engine(
                                         new JamshidianSwaptionEngine(model));

    std::vector<ext::shared_ptr<CalibrationHelper> > swaptions;
    for (auto& i : data) {
        ext::shared_ptr<Quote> vol(new SimpleQuote(i.volatility));
        ext::shared_ptr<BlackCalibrationHelper> helper(
            new SwaptionHelper(Period(i.start, Years), Period(i.length, Years), Handle<Quote>(vol),
                               index, Period(1, Years), Thirty360(Thirty360::BondBasis), Actual360(), termStructure));
        helper->setPricingEngine(engine);
        swaptions.push_back(helper);
    }

    // Set up the optimization problem
    // Real simplexLambda = 0.1;
    // Simplex optimizationMethod(simplexLambda);
    LevenbergMarquardt optimizationMethod(1.0e-8,1.0e-8,1.0e-8);
    EndCriteria endCriteria(10000, 100, 1e-6, 1e-8, 1e-8);

    //Optimize
    model->calibrate(swaptions, optimizationMethod, endCriteria);
    EndCriteria::Type ecType = model->endCriteria();

    // Check and print out results
    Real cachedA, cachedSigma;
    if (!IborCoupon::usingAtParCoupons()) {
        cachedA = 0.0463679, cachedSigma = 0.00579831;
    } else {
        cachedA = 0.0464041, cachedSigma = 0.00579912;
    }

    Real tolerance = 1.0e-5;
    Array xMinCalculated = model->params();
    Real yMinCalculated = model->value(xMinCalculated, swaptions);
    Array xMinExpected(2);
    xMinExpected[0]= cachedA;
    xMinExpected[1]= cachedSigma;
    Real yMinExpected = model->value(xMinExpected, swaptions);
    if (std::fabs(xMinCalculated[0]-cachedA) > tolerance
        || std::fabs(xMinCalculated[1]-cachedSigma) > tolerance) {
        BOOST_ERROR("Failed to reproduce cached calibration results:\n"
                    << "calculated: a = " << xMinCalculated[0] << ", "
                    << "sigma = " << xMinCalculated[1] << ", "
                    << "f(a) = " << yMinCalculated << ",\n"
                    << "expected:   a = " << xMinExpected[0] << ", "
                    << "sigma = " << xMinExpected[1] << ", "
                    << "f(a) = " << yMinExpected << ",\n"
                    << "difference: a = " << xMinCalculated[0]-xMinExpected[0] << ", "
                    << "sigma = " << xMinCalculated[1]-xMinExpected[1] << ", "
                    << "f(a) = " << yMinCalculated - yMinExpected << ",\n"
                    << "end criteria = " << ecType );
    }
}

void ShortRateModelTest::testCachedHullWhiteFixedReversion() {
    BOOST_TEST_MESSAGE("Testing Hull-White calibration with fixed reversion against cached values...");

    using namespace short_rate_models_test;

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    Date today(15, February, 2002);
    Date settlement(19, February, 2002);
    Settings::instance().evaluationDate() = today;
    Handle<YieldTermStructure> termStructure(flatRate(settlement,0.04875825,
                                                      Actual365Fixed()));
    ext::shared_ptr<HullWhite> model(new HullWhite(termStructure,0.05,0.01));
    CalibrationData data[] = {{ 1, 5, 0.1148 },
                              { 2, 4, 0.1108 },
                              { 3, 3, 0.1070 },
                              { 4, 2, 0.1021 },
                              { 5, 1, 0.1000 }};
    ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));

    ext::shared_ptr<PricingEngine> engine(
                                         new JamshidianSwaptionEngine(model));

    std::vector<ext::shared_ptr<CalibrationHelper> > swaptions;
    for (auto& i : data) {
        ext::shared_ptr<Quote> vol(new SimpleQuote(i.volatility));
        ext::shared_ptr<BlackCalibrationHelper> helper(
            new SwaptionHelper(Period(i.start, Years), Period(i.length, Years), Handle<Quote>(vol),
                               index, Period(1, Years), Thirty360(Thirty360::BondBasis),
                               Actual360(), termStructure));
        helper->setPricingEngine(engine);
        swaptions.push_back(helper);
    }

    // Set up the optimization problem
    //Real simplexLambda = 0.1;
    //Simplex optimizationMethod(simplexLambda);
    LevenbergMarquardt optimizationMethod;//(1.0e-18,1.0e-18,1.0e-18);
    EndCriteria endCriteria(1000,500,1E-8,1E-8,1E-8);

    //Optimize
    model->calibrate(swaptions, optimizationMethod, endCriteria, Constraint(), std::vector<Real>(),
        HullWhite::FixedReversion());
    EndCriteria::Type ecType = model->endCriteria();

    // Check and print out results
    Real cachedA, cachedSigma;
    if (!IborCoupon::usingAtParCoupons())
        cachedA = 0.05, cachedSigma = 0.00585835;
    else
        cachedA = 0.05, cachedSigma = 0.00585858;

    Real tolerance = 1.0e-5;
    Array xMinCalculated = model->params();
    Real yMinCalculated = model->value(xMinCalculated, swaptions);
    Array xMinExpected(2);
    xMinExpected[0]= cachedA;
    xMinExpected[1]= cachedSigma;
    Real yMinExpected = model->value(xMinExpected, swaptions);
    if (std::fabs(xMinCalculated[0]-cachedA) > tolerance
        || std::fabs(xMinCalculated[1]-cachedSigma) > tolerance) {
        BOOST_ERROR("Failed to reproduce cached calibration results:\n"
                    << "calculated: a = " << xMinCalculated[0] << ", "
                    << "sigma = " << xMinCalculated[1] << ", "
                    << "f(a) = " << yMinCalculated << ",\n"
                    << "expected:   a = " << xMinExpected[0] << ", "
                    << "sigma = " << xMinExpected[1] << ", "
                    << "f(a) = " << yMinExpected << ",\n"
                    << "difference: a = " << xMinCalculated[0]-xMinExpected[0] << ", "
                    << "sigma = " << xMinCalculated[1]-xMinExpected[1] << ", "
                    << "f(a) = " << yMinCalculated - yMinExpected << ",\n"
                    << "end criteria = " << ecType );
    }
}


void ShortRateModelTest::testCachedHullWhite2() {
    BOOST_TEST_MESSAGE("Testing Hull-White calibration against cached "
                       "values using swaptions without start delay...");

    using namespace short_rate_models_test;

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    Date today(15, February, 2002);
    Date settlement(19, February, 2002);
    Settings::instance().evaluationDate() = today;
    Handle<YieldTermStructure> termStructure(flatRate(settlement,0.04875825,
                                                      Actual365Fixed()));
    ext::shared_ptr<HullWhite> model(new HullWhite(termStructure));
    CalibrationData data[] = {{ 1, 5, 0.1148 },
                              { 2, 4, 0.1108 },
                              { 3, 3, 0.1070 },
                              { 4, 2, 0.1021 },
                              { 5, 1, 0.1000 }};
    ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
    ext::shared_ptr<IborIndex> index0(new IborIndex(
        index->familyName(),index->tenor(),0,index->currency(),index->fixingCalendar(),
        index->businessDayConvention(),index->endOfMonth(),index->dayCounter(),termStructure)); // Euribor 6m with zero fixing days

    ext::shared_ptr<PricingEngine> engine(
                                         new JamshidianSwaptionEngine(model));

    std::vector<ext::shared_ptr<CalibrationHelper> > swaptions;
    for (auto& i : data) {
        ext::shared_ptr<Quote> vol(new SimpleQuote(i.volatility));
        ext::shared_ptr<BlackCalibrationHelper> helper(
            new SwaptionHelper(Period(i.start, Years), Period(i.length, Years), Handle<Quote>(vol),
                               index0, Period(1, Years), Thirty360(Thirty360::BondBasis),
                               Actual360(), termStructure));
        helper->setPricingEngine(engine);
        swaptions.push_back(helper);
    }

    // Set up the optimization problem
    // Real simplexLambda = 0.1;
    // Simplex optimizationMethod(simplexLambda);
    LevenbergMarquardt optimizationMethod(1.0e-8,1.0e-8,1.0e-8);
    EndCriteria endCriteria(10000, 100, 1e-6, 1e-8, 1e-8);

    //Optimize
    model->calibrate(swaptions, optimizationMethod, endCriteria);
    EndCriteria::Type ecType = model->endCriteria();

    // Check and print out results
    // The cached values were produced with an older version of the
    // JamshidianEngine not accounting for the delay between option
    // expiry and underlying start
    Real cachedA, cachedSigma;
    if (!IborCoupon::usingAtParCoupons())
        cachedA = 0.0481608, cachedSigma = 0.00582493;
    else
        cachedA = 0.0482063, cachedSigma = 0.00582687;

    Real tolerance = 5.0e-6; 
    Array xMinCalculated = model->params();
    Real yMinCalculated = model->value(xMinCalculated, swaptions);
    Array xMinExpected(2);
    xMinExpected[0]= cachedA;
    xMinExpected[1]= cachedSigma;
    Real yMinExpected = model->value(xMinExpected, swaptions);
    if (std::fabs(xMinCalculated[0]-cachedA) > tolerance
        || std::fabs(xMinCalculated[1]-cachedSigma) > tolerance) {
        BOOST_ERROR("Failed to reproduce cached calibration results:\n"
                    << "calculated: a = " << xMinCalculated[0] << ", "
                    << "sigma = " << xMinCalculated[1] << ", "
                    << "f(a) = " << yMinCalculated << ",\n"
                    << "expected:   a = " << xMinExpected[0] << ", "
                    << "sigma = " << xMinExpected[1] << ", "
                    << "f(a) = " << yMinExpected << ",\n"
                    << "difference: a = " << xMinCalculated[0]-xMinExpected[0] << ", "
                    << "sigma = " << xMinCalculated[1]-xMinExpected[1] << ", "
                    << "f(a) = " << yMinCalculated - yMinExpected << ",\n"
                    << "end criteria = " << ecType );
    }
}

void ShortRateModelTest::testSwaps() {
    BOOST_TEST_MESSAGE("Testing Hull-White swap pricing against known values...");

    SavedSettings backup;
    IndexHistoryCleaner cleaner;

    Date today = Settings::instance().evaluationDate();
    Calendar calendar = TARGET();
    today = calendar.adjust(today);
    Settings::instance().evaluationDate() = today;

    Date settlement = calendar.advance(today,2,Days);

    std::vector<Date> dates = {
        settlement,
        calendar.advance(settlement,1,Weeks),
        calendar.advance(settlement,1,Months),
        calendar.advance(settlement,3,Months),
        calendar.advance(settlement,6,Months),
        calendar.advance(settlement,9,Months),
        calendar.advance(settlement,1,Years),
        calendar.advance(settlement,2,Years),
        calendar.advance(settlement,3,Years),
        calendar.advance(settlement,5,Years),
        calendar.advance(settlement,10,Years),
        calendar.advance(settlement,15,Years)
    };
    std::vector<DiscountFactor> discounts = {
        1.0,
        0.999258,
        0.996704,
        0.990809,
        0.981798,
        0.972570,
        0.963430,
        0.929532,
        0.889267,
        0.803693,
        0.596903,
        0.433022
    };

    Handle<YieldTermStructure> termStructure(
       ext::shared_ptr<YieldTermStructure>(
           new DiscountCurve(dates, discounts, Actual365Fixed())));

    ext::shared_ptr<HullWhite> model(new HullWhite(termStructure));

    Integer start[] = { -3, 0, 3 };
    Integer length[] = { 2, 5, 10 };
    Rate rates[] = { 0.02, 0.04, 0.06 };
    ext::shared_ptr<IborIndex> euribor(new Euribor6M(termStructure));

    ext::shared_ptr<PricingEngine> engine(
                                        new TreeVanillaSwapEngine(model,120));

    Real tolerance;
    if (!IborCoupon::usingAtParCoupons())
        tolerance = 4.0e-3;
    else
        tolerance = 1.0e-8;

    for (Size i=0; i<LENGTH(start); i++) {

        Date startDate = calendar.advance(settlement,start[i],Months);
        if (startDate < today) {
            Date fixingDate = calendar.advance(startDate,-2,Days);
            TimeSeries<Real> pastFixings;
            pastFixings[fixingDate] = 0.03;
            IndexManager::instance().setHistory(euribor->name(),
                                                pastFixings);
        }

        for (Size j=0; j<LENGTH(length); j++) {

            Date maturity = calendar.advance(startDate,length[i],Years);
            Schedule fixedSchedule(startDate, maturity, Period(Annual),
                                   calendar, Unadjusted, Unadjusted,
                                   DateGeneration::Forward, false);
            Schedule floatSchedule(startDate, maturity, Period(Semiannual),
                                   calendar, Following, Following,
                                   DateGeneration::Forward, false);
            for (double rate : rates) {

                VanillaSwap swap(Swap::Payer, 1000000.0, fixedSchedule, rate,
                                 Thirty360(Thirty360::BondBasis),
                                 floatSchedule, euribor, 0.0, Actual360());
                swap.setPricingEngine(ext::shared_ptr<PricingEngine>(
                                   new DiscountingSwapEngine(termStructure)));
                Real expected = swap.NPV();
                swap.setPricingEngine(engine);
                Real calculated = swap.NPV();

                Real error = std::fabs((expected-calculated)/expected);
                if (error > tolerance) {
                    BOOST_ERROR("Failed to reproduce swap NPV:"
                                << std::fixed << std::setprecision(9)
                                << "\n    calculated: " << calculated
                                << "\n    expected:   " << expected
                                << std::scientific
                                << "\n    rel. error: " << error);
                }
            }
        }
    }
}

void ShortRateModelTest::testFuturesConvexityBias() {
    BOOST_TEST_MESSAGE("Testing Hull-White futures convexity bias...");

    // G. Kirikos, D. Novak, "Convexity Conundrums", Risk Magazine, March 1997
    Real futureQuote = 94.0;
    Real a = 0.03;
    Real sigma = 0.015;
    Time t = 5.0;
    Time T = 5.25;

    Rate expectedForward = 0.0573037;
    Real tolerance       = 0.0000001;

    Rate futureImpliedRate = (100.0-futureQuote)/100.0;
    Rate calculatedForward =
        futureImpliedRate - HullWhite::convexityBias(futureQuote,t,T,sigma,a);

    Real error = std::fabs(calculatedForward-expectedForward);

    if (error > tolerance) {
        BOOST_ERROR("Failed to reproduce convexity bias:"
                    << "\ncalculated: " << calculatedForward
                    << "\n  expected: " << expectedForward
                    << std::scientific
                    << "\n     error: " << error
                    << "\n tolerance: " << tolerance);
    }
}

void ShortRateModelTest::testExtendedCoxIngersollRossDiscountFactor() {
    BOOST_TEST_MESSAGE("Testing zero-bond pricing for extended CIR model...");

    SavedSettings backup;
    const Date today = Settings::instance().evaluationDate();

    const Rate rate = 0.1;
    const Handle<YieldTermStructure> rTS(
        flatRate(today, rate, Actual365Fixed()));

    const Time now = 1.5;
    const Time maturity = 2.5;

    const ExtendedCoxIngersollRoss cirModel(rTS, rate, 1.0, 1e-4, rate);

    const Real expected = rTS->discount(maturity)/rTS->discount(now);
    const Real calculated = cirModel.discountBond(now, maturity, rate);

    const Real tol = 1e-6;
    const Real diff = std::fabs(expected-calculated);

    if (diff > tol) {
        BOOST_ERROR("Failed to reproduce zero bound price:"
                    << "\n  calculated: " << calculated
                    << "\n  expected  : " << expected
                    << std::scientific
                    << "\n  difference: " << diff
                    << "\n  tolerance : " << tol);
    }
}

test_suite* ShortRateModelTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Short-rate model tests");

    suite->add(QUANTLIB_TEST_CASE(&ShortRateModelTest::testCachedHullWhite));
    suite->add(QUANTLIB_TEST_CASE(&ShortRateModelTest::testCachedHullWhiteFixedReversion));
    suite->add(QUANTLIB_TEST_CASE(&ShortRateModelTest::testCachedHullWhite2));
    suite->add(QUANTLIB_TEST_CASE(&ShortRateModelTest::testFuturesConvexityBias));
    suite->add(QUANTLIB_TEST_CASE(
        &ShortRateModelTest::testExtendedCoxIngersollRossDiscountFactor));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&ShortRateModelTest::testSwaps));
    }

    return suite;
}

]]></document_content>
  </document>
  <document index="251">
    <source>shortratemodels.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_short_rate_models_hpp
#define quantlib_test_short_rate_models_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ShortRateModelTest {
  public:
    static void testFuturesConvexityBias();
    static void testCachedHullWhite();
    static void testCachedHullWhiteFixedReversion();
    static void testCachedHullWhite2();
    static void testSwaps();
    static void testExtendedCoxIngersollRossDiscountFactor();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="252">
    <source>sofrfutures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "sofrfutures.hpp"
#include "utilities.hpp"
#include <ql/instruments/overnightindexfuture.hpp>
#include <ql/indexes/ibor/sofr.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/overnightindexfutureratehelper.hpp>
#include <iomanip>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    struct SofrQuotes {
        Frequency freq;
        Month month;
        Year year;
        Real price;
        RateAveraging::Type averagingMethod;
    };

}


void SofrFuturesTest::testBootstrap() {
    BOOST_TEST_MESSAGE("Testing bootstrap over SOFR futures...");

    SavedSettings backup;

    Date today = Date(26, October, 2018);
    Settings::instance().evaluationDate() = today;

    const SofrQuotes sofrQuotes[] = {
        {Monthly, Oct, 2018, 97.8175, RateAveraging::Simple},
        {Monthly, Nov, 2018, 97.770, RateAveraging::Simple},
        {Monthly, Dec, 2018, 97.685, RateAveraging::Simple},
        {Monthly, Jan, 2019, 97.595, RateAveraging::Simple},
        {Monthly, Feb, 2019, 97.590, RateAveraging::Simple},
        {Monthly, Mar, 2019, 97.525, RateAveraging::Simple},
        {Quarterly, Mar, 2019, 97.440, RateAveraging::Compound},
        {Quarterly, Jun, 2019, 97.295, RateAveraging::Compound},
        {Quarterly, Sep, 2019, 97.220, RateAveraging::Compound},
        {Quarterly, Dec, 2019, 97.170, RateAveraging::Compound},
        {Quarterly, Mar, 2020, 97.160, RateAveraging::Compound},
        {Quarterly, Jun, 2020, 97.165, RateAveraging::Compound},
        {Quarterly, Sep, 2020, 97.175, RateAveraging::Compound},
    };

    ext::shared_ptr<OvernightIndex> index = ext::make_shared<Sofr>();
    index->addFixing(Date(1, October, 2018), 0.0222);
    index->addFixing(Date(2, October, 2018), 0.022);
    index->addFixing(Date(3, October, 2018), 0.022);
    index->addFixing(Date(4, October, 2018), 0.0218);
    index->addFixing(Date(5, October, 2018), 0.0216);
    index->addFixing(Date(9, October, 2018), 0.0215);
    index->addFixing(Date(10, October, 2018), 0.0215);
    index->addFixing(Date(11, October, 2018), 0.0217);
    index->addFixing(Date(12, October, 2018), 0.0218);
    index->addFixing(Date(15, October, 2018), 0.0221);
    index->addFixing(Date(16, October, 2018), 0.0218);
    index->addFixing(Date(17, October, 2018), 0.0218);
    index->addFixing(Date(18, October, 2018), 0.0219);
    index->addFixing(Date(19, October, 2018), 0.0219);
    index->addFixing(Date(22, October, 2018), 0.0218);
    index->addFixing(Date(23, October, 2018), 0.0217);
    index->addFixing(Date(24, October, 2018), 0.0218);
    index->addFixing(Date(25, October, 2018), 0.0219);

    std::vector<ext::shared_ptr<RateHelper> > helpers;
    for (const auto& sofrQuote : sofrQuotes) {
        helpers.push_back(ext::make_shared<SofrFutureRateHelper>(
            sofrQuote.price, sofrQuote.month, sofrQuote.year, sofrQuote.freq,
            index, 0.0, sofrQuote.averagingMethod));
    }

    ext::shared_ptr<PiecewiseYieldCurve<Discount, Linear> > curve =
        ext::make_shared<PiecewiseYieldCurve<Discount, Linear> >(today, helpers,
                                                                 Actual365Fixed());

    // test curve with one of the futures
    ext::shared_ptr<OvernightIndex> sofr =
        ext::make_shared<Sofr>(Handle<YieldTermStructure>(curve));
    OvernightIndexFuture sf(sofr, Date(20, March, 2019), Date(19, June, 2019));

    Real expected_price = 97.44;
    Real tolerance = 1.0e-9;

    Real error = std::fabs(sf.NPV() - expected_price);
    if (error > tolerance) {
        BOOST_ERROR("sample futures:\n"
                    << std::setprecision(8)
                    << "\n estimated price: " << sf.NPV()
                    << "\n expected price:  " << expected_price
                    << "\n error:           " << error
                    << "\n tolerance:       " << tolerance);
    }
}


test_suite* SofrFuturesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("SOFR futures tests");

    suite->add(QUANTLIB_TEST_CASE(&SofrFuturesTest::testBootstrap));

    return suite;
}
]]></document_content>
  </document>
  <document index="253">
    <source>sofrfutures.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_sofr_futures_hpp
#define quantlib_test_sofr_futures_hpp

#include <boost/test/unit_test.hpp>

class SofrFuturesTest {
  public:
    static void testBootstrap();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="254">
    <source>solvers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "solvers.hpp"
#include "utilities.hpp"
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/solvers1d/bisection.hpp>
#include <ql/math/solvers1d/falseposition.hpp>
#include <ql/math/solvers1d/ridder.hpp>
#include <ql/math/solvers1d/secant.hpp>
#include <ql/math/solvers1d/newton.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/math/solvers1d/finitedifferencenewtonsafe.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    class F1 {
      public:
        Real operator()(Real x) const { return x*x-1.0; }
        Real derivative(Real x) const { return 2.0*x; }
    };

    class F2 {
      public:
        Real operator()(Real x) const { return 1.0-x*x; }
        Real derivative(Real x) const { return -2.0*x; }
    };

    class F3 {
      public:
        Real operator()(Real x) const { return std::atan(x-1); }
        Real derivative(Real x) const { return 1.0 / (1.0+(x-1.0)*(x-1.0)); }
    };

    template <class S, class F>
    void test_not_bracketed(const S& solver, const std::string& name,
                            const F& f, Real guess) {
        Real accuracy[] = { 1.0e-4, 1.0e-6, 1.0e-8 };
        Real expected = 1.0;
        for (double& i : accuracy) {
            Real root = solver.solve(f, i, guess, 0.1);
            if (std::fabs(root - expected) > i) {
                BOOST_FAIL(name << " solver (not bracketed):\n"
                                << "    expected:   " << expected << "\n"
                                << "    calculated: " << root << "\n"
                                << "    accuracy:   " << i);
            }
        }
    }

    template <class S, class F>
    void test_bracketed(const S& solver, const std::string& name,
                        const F& f, Real guess) {
        Real accuracy[] = { 1.0e-4, 1.0e-6, 1.0e-8 };
        Real expected = 1.0;
        for (double& i : accuracy) {
            // guess on the left side of the root, increasing function
            Real root = solver.solve(f, i, guess, 0.0, 2.0);
            if (std::fabs(root - expected) > i) {
                BOOST_FAIL(name << " solver (bracketed):\n"
                                << "    expected:   " << expected << "\n"
                                << "    calculated: " << root << "\n"
                                << "    accuracy:   " << i);
            }
        }
    }

    class Probe {
      public:
        Probe(Real& result, Real offset)
        : result_(result), previous_(result), offset_(offset) {}
        Real operator()(Real x) const {
            result_ = x;
            return previous_ + offset_ - x*x;
        }
        Real derivative(Real x) const { return 2.0*x; }
      private:
        Real& result_;
        Real previous_;
        Real offset_;
    };

    template <class S>
    void test_last_call_with_root(const S& solver, const std::string& name,
                                  bool bracketed,  Real accuracy) {

        Real mins[] = { 3.0, 2.25, 1.5, 1.0 };
        Real maxs[] = { 7.0, 5.75, 4.5, 3.0 };
        Real steps[] = { 0.2, 0.2, 0.1, 0.1 };
        Real offsets[] = { 25.0, 11.0, 5.0, 1.0 };
        Real guesses[] = { 4.5, 4.5, 2.5, 2.5 };
        //Real expected[] = { 5.0, 4.0, 3.0, 2.0 };

        Real argument = 0.0;
        Real result;

        for (Size i=0; i<4; ++i) {
            if (bracketed) {
                result = solver.solve(Probe(argument, offsets[i]), accuracy,
                                      guesses[i], mins[i], maxs[i]);
            } else {
                result = solver.solve(Probe(argument, offsets[i]), accuracy,
                                      guesses[i], steps[i]);
            }

            Real error = std::fabs(result-argument);
            // the solver should have called the function with
            // the very same value it's returning. But the internal
            // 80bit length of the x87 FPU register might lead to
            // a very small glitch when compiled with -mfpmath=387 on gcc
            if (error > 2*QL_EPSILON) {
                BOOST_FAIL(name << " solver ("
                           << (bracketed ? "" : "not ")
                           << "bracketed):\n"
                           << "    index:   " << i << "\n"
                           << "    expected:   " << result << "\n"
                           << "    calculated: " << argument << "\n"
                           << "    error: " << error);
            }
        }
    }        

    template <class S>
    void test_solver(const S& solver, const std::string& name, Real accuracy) {
        // guess on the left side of the root, increasing function
        test_not_bracketed(solver, name, F1(), 0.5);
        test_bracketed(solver, name, F1(), 0.5);
        // guess on the right side of the root, increasing function
        test_not_bracketed(solver, name, F1(), 1.5);
        test_bracketed(solver, name, F1(), 1.5);
        // guess on the left side of the root, decreasing function
        test_not_bracketed(solver, name, F2(), 0.5);
        test_bracketed(solver, name, F2(), 0.5);
        // guess on the right side of the root, decreasing function
        test_not_bracketed(solver, name, F2(), 1.5);
        test_bracketed(solver, name, F2(), 1.5);
        // situation where bisection is used in the finite difference
        // newton solver as the first step and where the initial
        // guess is equal to the next estimate (which causes an infinite
        // derivative if we do not handle this case with special care)
        test_not_bracketed(solver, name, F3(), 1.00001);
        // check that the last function call is made with the root value
        if(accuracy != Null<Real>()) {
            test_last_call_with_root(solver, name, false, accuracy);
            test_last_call_with_root(solver, name, true, accuracy);
        }
    }

}


void Solver1DTest::testBrent() {
    BOOST_TEST_MESSAGE("Testing Brent solver...");
    test_solver(Brent(), "Brent", 1.0e-6);
}

void Solver1DTest::testBisection() {
    BOOST_TEST_MESSAGE("Testing bisection solver...");
    test_solver(Bisection(), "Bisection", 1.0e-6);
}

void Solver1DTest::testFalsePosition() {
    BOOST_TEST_MESSAGE("Testing false-position solver...");
    test_solver(FalsePosition(), "FalsePosition", 1.0e-6);
}

void Solver1DTest::testNewton() {
    BOOST_TEST_MESSAGE("Testing Newton solver...");
    test_solver(Newton(), "Newton", 1.0e-12);
}

void Solver1DTest::testNewtonSafe() {
    BOOST_TEST_MESSAGE("Testing Newton-safe solver...");
    test_solver(NewtonSafe(), "NewtonSafe", 1.0e-9);
}

void Solver1DTest::testFiniteDifferenceNewtonSafe() {
    BOOST_TEST_MESSAGE("Testing finite-difference Newton-safe solver...");
    test_solver(FiniteDifferenceNewtonSafe(), "FiniteDifferenceNewtonSafe", Null<Real>());
}

void Solver1DTest::testRidder() {
    BOOST_TEST_MESSAGE("Testing Ridder solver...");
    test_solver(Ridder(), "Ridder", 1.0e-6);
}

void Solver1DTest::testSecant() {
    BOOST_TEST_MESSAGE("Testing secant solver...");
    test_solver(Secant(), "Secant", 1.0e-6);
}


test_suite* Solver1DTest::suite() {
    auto* suite = BOOST_TEST_SUITE("1-D solver tests");
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testBrent));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testBisection));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testFalsePosition));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testNewton));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testNewtonSafe));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testFiniteDifferenceNewtonSafe));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testRidder));
    suite->add(QUANTLIB_TEST_CASE(&Solver1DTest::testSecant));
    return suite;
}

]]></document_content>
  </document>
  <document index="255">
    <source>solvers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_solvers_hpp
#define quantlib_test_solvers_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class Solver1DTest {
  public:
    static void testBrent();
    static void testBisection();
    static void testFalsePosition();
    static void testNewton();
    static void testNewtonSafe();
    static void testFiniteDifferenceNewtonSafe();
    static void testRidder();
    static void testSecant();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="256">
    <source>speedlevel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_speed_level_hpp
#define quantlib_test_speed_level_hpp

enum SpeedLevel {
    Slow   = 0,
    Fast   = 1,
    Faster = 2
};

#endif

]]></document_content>
  </document>
  <document index="257">
    <source>spreadoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "spreadoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/kirkspreadoptionengine.hpp>
#include <ql/exercise.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;
using namespace std;

//namespace QuantLib {

#undef REPORT_FAILURE
#define REPORT_FAILURE( \
    greekName,  \
    payoff, exercise, \
    expected, calculated, tolerance) \
    BOOST_ERROR( \
    exerciseTypeToString(exercise) \
    << " Spread option with " \
    << payoffTypeToString(payoff) << " payoff:\n" \
    << "    strike:           " << payoff->strike() << "\n" \
    << "    reference date:   " << today << "\n" \
    << "    maturity:         " << exercise->lastDate() << "\n" \
    << "    expected   " << greekName << ": " << expected << "\n" \
    << "    calculated " << greekName << ": " << calculated << "\n" \
    << "    error:            " << std::fabs(expected-calculated) \
    << "\n" \
    << "    tolerance:        " << tolerance);


struct Case {
    Real F1;
    Real F2;
    Real X;
    Rate r;
    Volatility sigma1;
    Volatility sigma2;
    Real rho;
    Natural length;
    Real value;
    Real theta;
};

void SpreadOptionTest::testKirkEngine() {
    BOOST_TEST_MESSAGE("Testing Kirk approximation for spread options...");

    /* The example data below are from "complete guide to option
       pricing formulas", Espen Gaarder Haug, p 60

       Expected values of option theta were calculated using automatic
       differentiation of the pricing function. The engine uses closed-form
       formula */

    Case cases[] = {
        {  28.0,  20.0, 7.0, 0.05, 0.29, 0.36,  0.42, 90,  2.1670,  -3.0431 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.20, -0.5,  36,  4.7530, -25.5905 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.20,  0.0,  36,  3.7970, -20.8841 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.20,  0.5,  36,  2.5537, -14.7260 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.20, -0.5, 180, 10.7517, -10.0847 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.20,  0.0, 180,  8.7020,  -8.2619 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.20,  0.5, 180,  6.0257,  -5.8661 },
        { 122.0, 120.0, 3.0, 0.10, 0.25, 0.20, -0.5,  36,  5.4275, -28.9013 },
        { 122.0, 120.0, 3.0, 0.10, 0.25, 0.20,  0.0,  36,  4.3712, -23.7133 },
        { 122.0, 120.0, 3.0, 0.10, 0.25, 0.20,  0.5,  36,  3.0086, -16.9864 },
        { 122.0, 120.0, 3.0, 0.10, 0.25, 0.20, -0.5, 180, 12.1941, -11.3603 },
        { 122.0, 120.0, 3.0, 0.10, 0.25, 0.20,  0.0, 180,  9.9340,  -9.3589 },
        { 122.0, 120.0, 3.0, 0.10, 0.25, 0.20,  0.5, 180,  7.0067,  -6.7463 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.25, -0.5,  36,  5.4061, -28.7963 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.25,  0.0,  36,  4.3451, -23.5848 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.25,  0.5,  36,  2.9723, -16.8060 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.25, -0.5, 180, 12.1483, -11.3200 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.25,  0.0, 180,  9.8780,  -9.3091 },
        { 122.0, 120.0, 3.0, 0.10, 0.20, 0.25,  0.5, 180,  6.9284,  -6.6761 }
    };

    for (auto& i : cases) {

        // First step: preparing the test values
        // Useful dates
        DayCounter dc = Actual360();
        Date today = Date::todaysDate();
        Date exerciseDate = today + i.length;

        // Futures values
        ext::shared_ptr<SimpleQuote> F1(new SimpleQuote(i.F1));
        ext::shared_ptr<SimpleQuote> F2(new SimpleQuote(i.F2));

        // Risk-free interest rate
        Rate riskFreeRate = i.r;
        ext::shared_ptr<YieldTermStructure> forwardRate =
            flatRate(today,riskFreeRate,dc);

        // Correlation
        ext::shared_ptr<Quote> rho(new SimpleQuote(i.rho));

        // Volatilities
        Volatility vol1 = i.sigma1;
        Volatility vol2 = i.sigma2;
        ext::shared_ptr<BlackVolTermStructure> volTS1 =
            flatVol(today,vol1,dc);
        ext::shared_ptr<BlackVolTermStructure> volTS2 =
            flatVol(today,vol2,dc);

        // Black-Scholes Processes
        // The BlackProcess is the relevant class for futures contracts
        ext::shared_ptr<BlackProcess> stochProcess1(
                     new BlackProcess(Handle<Quote>(F1),
                                      Handle<YieldTermStructure>(forwardRate),
                                      Handle<BlackVolTermStructure>(volTS1)));

        ext::shared_ptr<BlackProcess> stochProcess2(
                     new BlackProcess(Handle<Quote>(F2),
                                      Handle<YieldTermStructure>(forwardRate),
                                      Handle<BlackVolTermStructure>(volTS2)));

        // Creating the pricing engine
        ext::shared_ptr<PricingEngine> engine(
                      new KirkSpreadOptionEngine(stochProcess1, stochProcess2,
                                                 Handle<Quote>(rho)));

        // Finally, create the option:
        Option::Type type = Option::Call;
        Real strike = i.X;
        ext::shared_ptr<PlainVanillaPayoff> payoff(
                                        new PlainVanillaPayoff(type, strike));
        ext::shared_ptr<Exercise> exercise(
                                          new EuropeanExercise(exerciseDate));

        SpreadOption option(payoff, exercise);
        option.setPricingEngine(engine);

        // And test the data
        Real value = option.NPV();
        Real theta = option.theta();
        Real tolerance = 1e-4;

        if (std::fabs(value - i.value) > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, i.value, value, tolerance);
        }

        if (std::fabs(theta - i.theta) > tolerance) {
            REPORT_FAILURE("theta", payoff, exercise, i.theta, theta, tolerance);
        }
    }
}

test_suite* SpreadOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Spread option tests");

    suite->add(QUANTLIB_TEST_CASE(&SpreadOptionTest::testKirkEngine));

    return suite;
}

]]></document_content>
  </document>
  <document index="258">
    <source>spreadoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_spread_option_hpp
#define quantlib_test_spread_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SpreadOptionTest {
  public:
    static void testKirkEngine();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="259">
    <source>squarerootclvmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include "utilities.hpp"
#include "squarerootclvmodel.hpp"
#include <ql/quotes/simplequote.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/math/statistics/statistics.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/randomnumbers/sobolbrownianbridgersg.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/processes/squarerootprocess.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/forward/forwardengine.hpp>
#include <ql/methods/montecarlo/pathgenerator.hpp>
#include <ql/termstructures/volatility/equityfx/hestonblackvolsurface.hpp>
#include <ql/termstructures/volatility/equityfx/noexceptlocalvolsurface.hpp>
#include <ql/experimental/models/squarerootclvmodel.hpp>
#include <ql/experimental/models/hestonslvfdmmodel.hpp>
#include <ql/experimental/processes/hestonslvprocess.hpp>
#include <ql/experimental/finitedifferences/fdhestondoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.hpp>
#include <ql/experimental/volatility/sabrvoltermstructure.hpp>

#if defined(__GNUC__) && !defined(__clang__) && BOOST_VERSION > 106300
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#endif
#include <boost/math/distributions/non_central_chi_squared.hpp>
#if defined(__GNUC__) && !defined(__clang__) && BOOST_VERSION > 106300
#pragma GCC diagnostic pop
#endif

#include <set>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;


namespace square_root_clv_model {
    class CLVModelPayoff : public PlainVanillaPayoff {
      public:
        CLVModelPayoff(Option::Type type, Real strike, ext::function<Real(Real)> g)
        : PlainVanillaPayoff(type, strike), g_(std::move(g)) {}

        Real operator()(Real x) const override { return PlainVanillaPayoff::operator()(g_(x)); }

      private:
        const ext::function<Real(Real)> g_;
    };

    typedef boost::math::non_central_chi_squared_distribution<Real>
        chi_squared_type;
}


void SquareRootCLVModelTest::testSquareRootCLVVanillaPricing() {
    BOOST_TEST_MESSAGE(
        "Testing vanilla option pricing with square-root kernel process...");

    using namespace square_root_clv_model;

    SavedSettings backup;

    const Date todaysDate(5, Oct, 2016);
    Settings::instance().evaluationDate() = todaysDate;

    const DayCounter dc = ActualActual(ActualActual::ISDA);
    const Date maturityDate = todaysDate + Period(3, Months);
    const Time maturity = dc.yearFraction(todaysDate, maturityDate);

    const Real s0 = 100;
    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));

    const Rate r = 0.08;
    const Rate q = 0.03;
    const Volatility vol = 0.3;

    const Handle<YieldTermStructure> rTS(flatRate(r, dc));
    const Handle<YieldTermStructure> qTS(flatRate(q, dc));
    const Handle<BlackVolTermStructure> volTS(flatVol(todaysDate, vol, dc));
    const Real fwd = s0*qTS->discount(maturity)/rTS->discount(maturity);

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, volTS));

    const Real kappa       = 1.0;
    const Real theta       = 0.06;
    const Volatility sigma = 0.2;
    const Real x0          = 0.09;

    const ext::shared_ptr<SquareRootProcess> sqrtProcess(
        ext::make_shared<SquareRootProcess>(theta, kappa, sigma, x0));

    const std::vector<Date> maturityDates(1, maturityDate);

    const SquareRootCLVModel model(
        bsProcess, sqrtProcess, maturityDates, 14, 1-1e-14, 1e-14);

    const Array x = model.collocationPointsX(maturityDate);
    const Array y = model.collocationPointsY(maturityDate);

    const LagrangeInterpolation g(x.begin(), x.end(), y.begin());

    const Real df  = 4*theta*kappa/(sigma*sigma);
    const Real ncp = 4*kappa*std::exp(-kappa*maturity)
            / (sigma*sigma*(1-std::exp(-kappa*maturity)))*sqrtProcess->x0();

    const chi_squared_type dist(df, ncp);
        
    const Real strikes[] = { 50, 75, 100, 125, 150, 200 };
    for (double strike : strikes) {
        const Option::Type optionType = (strike > fwd) ? Option::Call : Option::Put;

        const Real expected = BlackCalculator(
            optionType, strike, fwd,
            std::sqrt(volTS->blackVariance(maturity, strike)),
            rTS->discount(maturity)).value();

        const CLVModelPayoff clvModelPayoff(optionType, strike, g);

        const ext::function<Real(Real)> f = [&](Real xi) {
            return clvModelPayoff(xi) * boost::math::pdf(dist, xi);
        };

        const Real calculated = GaussLobattoIntegral(1000, 1e-6)(
            f, x.front(), x.back()) * rTS->discount(maturity);

        const Real tol = 5e-3;
        if (std::fabs(expected - calculated) > tol) {
            BOOST_FAIL("failed to reproduce option SquaredCLVMOdel prices"
                    << "\n    time:       " << maturityDate
                    << "\n    strike:     " << strike
                    << "\n    expected:   " << expected
                    << "\n    calculated: " << calculated);
        }
    }
}

void SquareRootCLVModelTest::testSquareRootCLVMappingFunction() {
    BOOST_TEST_MESSAGE(
        "Testing mapping function of the square-root kernel process...");

    using namespace square_root_clv_model;

    SavedSettings backup;

    const Date todaysDate(16, Oct, 2016);
    Settings::instance().evaluationDate() = todaysDate;
    const Date maturityDate = todaysDate + Period(1, Years);

    const DayCounter dc = Actual365Fixed();

    const Real s0 = 100;
    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));

    const Rate r = 0.05;
    const Rate q = 0.02;

    const Handle<YieldTermStructure> rTS(flatRate(r, dc));
    const Handle<YieldTermStructure> qTS(flatRate(q, dc));

    //SABR
    const Real beta =  0.95;
    const Real alpha=  0.2;
    const Real rho  = -0.9;
    const Real gamma=  0.8;

    const Handle<BlackVolTermStructure> sabrVol(
        ext::make_shared<SABRVolTermStructure>(
            alpha, beta, gamma, rho, s0, r, todaysDate, dc));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, sabrVol));

    std::vector<Date> calibrationDates(1, todaysDate + Period(3, Months));
    calibrationDates.reserve(Size(daysBetween(todaysDate, maturityDate)/7 + 1));
    while (calibrationDates.back() < maturityDate)
        calibrationDates.push_back(calibrationDates.back() + Period(1, Weeks));

    // sqrt process
    const Real kappa       = 1.0;
    const Real theta       = 0.09;
    const Volatility sigma = 0.2;
    const Real x0          = 0.09;

    const ext::shared_ptr<SquareRootProcess> sqrtProcess(
        ext::make_shared<SquareRootProcess>(theta, kappa, sigma, x0));

    const SquareRootCLVModel model(
        bsProcess, sqrtProcess, calibrationDates, 14, 1-1e-10, 1e-10);

    const ext::function<Real(Time, Real)> g = model.g();

    const Real strikes[] = { 80, 100, 120 };
    const Size offsets[] = { 92, 182, 183, 184, 185, 186, 365 };
    for (unsigned long offset : offsets) {
        const Date m = todaysDate + Period(offset, Days);
        const Time t = dc.yearFraction(todaysDate, m);

        const Real df  = 4*theta*kappa/(sigma*sigma);
        const Real ncp = 4*kappa*std::exp(-kappa*t)
                / (sigma*sigma*(1-std::exp(-kappa*t)))*sqrtProcess->x0();

        const chi_squared_type dist(df, ncp);

        const Real fwd = s0*qTS->discount(m)/rTS->discount(m);

        for (double strike : strikes) {
            const Option::Type optionType = (strike > fwd) ? Option::Call : Option::Put;

            const Real expected = BlackCalculator(
                optionType, strike, fwd,
                std::sqrt(sabrVol->blackVariance(m, strike)),
                rTS->discount(m)).value();

            const CLVModelPayoff clvModelPayoff(optionType, strike, [&](Real x) { return g(t, x); });

            const ext::function<Real(Real)> f = [&](Real xi) {
                return clvModelPayoff(xi) * boost::math::pdf(dist, xi);
            };

            const Array x = model.collocationPointsX(m);
            const Real calculated = GaussLobattoIntegral(1000, 1e-3)(
                f, x.front(), x.back()) * rTS->discount(m);

            const Real tol = 0.075;

            if (std::fabs(expected) > 0.01
                    && std::fabs((calculated - expected)/calculated) > tol) {
                BOOST_FAIL("failed to reproduce option SquaredCLVMOdel prices"
                        << "\n    time:       " << m
                        << "\n    strike:     " << strike
                        << "\n    expected:   " << expected
                        << "\n    calculated: " << calculated);
            }
        }
    }
}

namespace square_root_clv_model {
    class SquareRootCLVCalibrationFunction : public CostFunction {
      public:
        SquareRootCLVCalibrationFunction(Array strikes,
                                         const std::vector<Date>& resetDates,
                                         const std::vector<Date>& maturityDates,
                                         ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
                                         Array refVols,
                                         Size nScenarios = 10000)
        : strikes_(std::move(strikes)), resetDates_(resetDates), maturityDates_(maturityDates),
          bsProcess_(std::move(bsProcess)), refVols_(std::move(refVols)), nScenarios_(nScenarios) {
            std::set<Date> c(resetDates.begin(), resetDates.end());
            c.insert(maturityDates.begin(), maturityDates.end());
            calibrationDates_.insert(
                calibrationDates_.begin(), c.begin(), c.end());
        }

        Real value(const Array& params) const override {
            const Array diff = values(params);

            Real retVal = 0.0;
            for (double i : diff)
                retVal += i * i;

            return retVal;
        }

        Disposable<Array> values(const Array& params) const override {
            const Real theta = params[0];
            const Real kappa = params[1];
            const Real sigma = params[2];
            const Real x0    = params[3];

            const ext::shared_ptr<SimpleQuote> vol(
                ext::make_shared<SimpleQuote>(0.1));

            const Handle<YieldTermStructure> rTS(bsProcess_->riskFreeRate());
            const Handle<YieldTermStructure> qTS(bsProcess_->dividendYield());
            const Handle<Quote> spot(ext::make_shared<SimpleQuote>(
                bsProcess_->x0()));

            const ext::shared_ptr<PricingEngine> fwdEngine(
                ext::make_shared<ForwardVanillaEngine<AnalyticEuropeanEngine> >(
                    ext::make_shared<GeneralizedBlackScholesProcess>(
                        spot, qTS, rTS,
                        Handle<BlackVolTermStructure>(
                            flatVol(rTS->referenceDate(), vol,
                                    rTS->dayCounter())))));

            const ext::shared_ptr<SquareRootProcess> sqrtProcess(
                ext::make_shared<SquareRootProcess>(theta, kappa, sigma, x0));

            const SquareRootCLVModel clvSqrtModel(
                bsProcess_, sqrtProcess, calibrationDates_,
                14, 1-1e-14, 1e-14);

            const ext::function<Real(Time, Real)> gSqrt = clvSqrtModel.g();

            Array retVal(resetDates_.size()*strikes_.size());

            for (Size i=0, n=resetDates_.size(); i < n; ++i) {
                const Date resetDate = resetDates_[i];
                const Date maturityDate = maturityDates_[i];

                const Time t0 = bsProcess_->time(resetDate);
                const Time t1 = bsProcess_->time(maturityDate);

                const Real df  = 4*theta*kappa/(sigma*sigma);
                const Real ncp = 4*kappa*std::exp(-kappa*t0)
                    / (sigma*sigma*(1-std::exp(-kappa*t0)))*x0;

                typedef boost::math::non_central_chi_squared_distribution<Real>
                    chi_squared_type;

                const chi_squared_type dist(df, ncp);

                const Real ncp1 = 4*kappa*std::exp(-kappa*(t1-t0))
                    / (sigma*sigma*(1-std::exp(-kappa*(t1-t0))));

                const LowDiscrepancy::ursg_type ursg = LowDiscrepancy::ursg_type(2, 1235UL);

                std::vector<GeneralStatistics> stats(strikes_.size());

                for (Size j=0; j < nScenarios_; ++j) {
                    const std::vector<Real>& path = ursg.nextSequence().value;

                    const Real x1 = boost::math::quantile(dist, path[0]);
                    const Real u1 =
                        sigma*sigma*(1-std::exp(-kappa*t0))/(4*kappa)*x1;

                    const Real x2 = boost::math::quantile(
                        chi_squared_type(df, ncp1*u1), path[1]);
                    const Real u2 =
                        sigma*sigma*(1-std::exp(-kappa*(t1-t0)))/(4*kappa)*x2;
                    const Real X2 =
                        u2*4*kappa/(sigma*sigma*(1-std::exp(-kappa*t1)));

                    const Real s1 = gSqrt(t0, x1);
                    const Real s2 = gSqrt(t1, X2);

                    for (Size k=0; k < strikes_.size(); ++k) {
                        const Real strike = strikes_[k];

                        const Real payoff = (strike < 1.0)
                            ?  s1 * std::max(0.0, strike - s2/s1)
                            :  s1 * std::max(0.0, s2/s1 - strike);

                        stats[k].add(payoff);
                    }
                }

                const ext::shared_ptr<Exercise> exercise(
                    ext::make_shared<EuropeanExercise>(maturityDate));

                const DiscountFactor dF(
                    bsProcess_->riskFreeRate()->discount(maturityDate));

                for (Size k=0; k < strikes_.size(); ++k) {
                    const Real strike = strikes_[k];
                    const Real npv = stats[k].mean() * dF;

                    const ext::shared_ptr<StrikedTypePayoff> payoff(
                        ext::make_shared<PlainVanillaPayoff>(
                            (strike < 1.0) ? Option::Put : Option::Call, strike));

                    const ext::shared_ptr<ForwardVanillaOption> fwdOption(
                        ext::make_shared<ForwardVanillaOption>(
                            strike, resetDate, payoff, exercise));

                    const Volatility implVol =
                        QuantLib::detail::ImpliedVolatilityHelper::calculate(
                            *fwdOption, *fwdEngine, *vol, npv, 1e-8, 200, 1e-4, 2.0);

                    const Size idx = k + i*strikes_.size();
                    retVal[idx] = implVol - refVols_[idx];
                }
            }

            return retVal;
        }


      private:
        const Array strikes_;
        const std::vector<Date> resetDates_, maturityDates_;
        const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess_;
        const Array refVols_;
        const Size nScenarios_;

        std::vector<Date> calibrationDates_;
    };

    class NonZeroConstraint : public Constraint {
      private:
        class Impl : public Constraint::Impl {
          public:
            bool test(const Array& params) const override {
                const Real theta = params[0];
                const Real kappa = params[1];
                const Real sigma = params[2];
                const Real x0    = params[3];

                return (sigma >= 0.001 && kappa > 1e-6 && theta > 0.001
                        && x0 > 1e-4);
            }

            Array upperBound(const Array& params) const override {
                const Real upper[] = { 1.0, 1.0, 1.0, 2.0 };

                return Array(upper, upper + 4);
            }

            Array lowerBound(const Array& params) const override {
                const Real lower[] = { 0.001, 0.001, 0.001, 1e-4 };

                return Array(lower, lower + 4);
            }
        };

      public:
        NonZeroConstraint()
        : Constraint(ext::make_shared<NonZeroConstraint::Impl>()) {}
    };
}

void SquareRootCLVModelTest::testForwardSkew() {
    BOOST_TEST_MESSAGE(
        "Testing forward skew dynamics with square-root kernel process...");

    using namespace square_root_clv_model;

    SavedSettings backup;

    const Date todaysDate(16, Oct, 2016);
    Settings::instance().evaluationDate() = todaysDate;
    const Date endDate = todaysDate + Period(4, Years);

    const DayCounter dc = Actual365Fixed();

    // Heston model is used to generate an arbitrage free volatility surface
    const Real s0    =  100;
    const Real r     =  0.1;
    const Real q     =  0.05;
    const Real v0    =  0.09;
    const Real kappa =  1.0;
    const Real theta =  0.09;
    const Real sigma =  0.3;
    const Real rho   = -0.75;

    const Handle<Quote> spot(ext::make_shared<SimpleQuote>(s0));
    const Handle<YieldTermStructure> rTS(flatRate(r, dc));
    const Handle<YieldTermStructure> qTS(flatRate(q, dc));

    const ext::shared_ptr<HestonModel> hestonModel(
        ext::make_shared<HestonModel>(
            ext::make_shared<HestonProcess>(
                rTS, qTS, spot, v0, kappa, theta, sigma, rho)));

    const Handle<BlackVolTermStructure> blackVol(
        ext::make_shared<HestonBlackVolSurface>(
            Handle<HestonModel>(hestonModel)));

    const Handle<LocalVolTermStructure> localVol(
        ext::make_shared<NoExceptLocalVolSurface>(
                blackVol, rTS, qTS, spot, std::sqrt(theta)));

    const Real sTheta = 0.389302;
    const Real sKappa = 0.1101849;
    const Real sSigma = 0.275368;
    const Real sX0    = 0.466809;

    const ext::shared_ptr<SquareRootProcess> sqrtProcess(
        ext::make_shared<SquareRootProcess>(
            sTheta, sKappa, sSigma, sX0));

    const ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
        ext::make_shared<GeneralizedBlackScholesProcess>(
            spot, qTS, rTS, blackVol));

    std::vector<Date> calibrationDates(1, todaysDate + Period(6, Months));
    while (calibrationDates.back() < endDate)
        calibrationDates.push_back(calibrationDates.back() + Period(3, Months));

    std::set<Date> clvCalibrationDates(
        calibrationDates.begin(), calibrationDates.end());

    Date tmpDate = todaysDate + Period(1, Days);
    while (tmpDate < todaysDate + Period(1, Years)) {
        clvCalibrationDates.insert(tmpDate);
        tmpDate += Period(1, Weeks);
    }

    const SquareRootCLVModel clvSqrtModel(
        bsProcess,
        sqrtProcess,
        std::vector<Date>(
            clvCalibrationDates.begin(), clvCalibrationDates.end()),
        14, 1-1e-14, 1e-14);

    const ext::function<Real(Time, Real)> gSqrt = clvSqrtModel.g();

    const ext::shared_ptr<SimpleQuote> vol(
        ext::make_shared<SimpleQuote>(0.1));

    const ext::shared_ptr<PricingEngine> fwdEngine(
        ext::make_shared<ForwardVanillaEngine<AnalyticEuropeanEngine> >(
            ext::make_shared<GeneralizedBlackScholesProcess>(
                spot, qTS, rTS,
                Handle<BlackVolTermStructure>(flatVol(todaysDate, vol, dc)))));


    // forward skew of the Heston-SLV model
    std::vector<Time> mandatoryTimes;
    mandatoryTimes.reserve(calibrationDates.size());
    for (auto& calibrationDate : calibrationDates)
        mandatoryTimes.push_back(dc.yearFraction(todaysDate, calibrationDate));

    const Size tSteps = 200;
    const TimeGrid grid(mandatoryTimes.begin(), mandatoryTimes.end(), tSteps);

    std::vector<Date> resetDates, maturityDates;
    std::vector<Size> resetIndices, maturityIndices;
    for (Size i=0, n = calibrationDates.size()-2; i < n; ++i) {
        resetDates.push_back(calibrationDates[i]);
        maturityDates.push_back(calibrationDates[i+2]);

        const Time resetTime    = mandatoryTimes[i];
        const Time maturityTime = mandatoryTimes[i+2];

        resetIndices.push_back(grid.closestIndex(resetTime)-1);
        maturityIndices.push_back(grid.closestIndex(maturityTime)-1);
    }

    const Real strikes[] = {
        0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2,
        1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0
    };

    const Size nScenarios = 20000;
    Array refVols(resetIndices.size()*LENGTH(strikes));

    // finite difference calibration of Heston SLV model

    // define Heston Stochastic Local Volatility model
    const Real eta = 0.25;
    const Real corr = -0.0;

    const ext::shared_ptr<HestonProcess> hestonProcess4slv(
        ext::make_shared<HestonProcess>(
            rTS, qTS, spot, v0, kappa, theta, eta*sigma, corr));

    const Handle<HestonModel> hestonModel4slv(
        ext::make_shared<HestonModel>(hestonProcess4slv));

    const HestonSLVFokkerPlanckFdmParams logParams = {
        301, 601, 1000, 30, 2.0, 0, 2,
        0.1, 1e-4, 10000,
        1e-5, 1e-5, 0.0000025, 1.0, 0.1, 0.9, 1e-5,
        FdmHestonGreensFct::Gaussian,
        FdmSquareRootFwdOp::Log,
        FdmSchemeDesc::ModifiedCraigSneyd()
    };

    const ext::shared_ptr<LocalVolTermStructure> leverageFctFDM =
        HestonSLVFDMModel(localVol, hestonModel4slv, endDate, logParams).
            leverageFunction();

    //  calibrating to forward volatility dynamics

    const ext::shared_ptr<HestonSLVProcess> fdmSlvProcess(
        ext::make_shared<HestonSLVProcess>(
            hestonProcess4slv, leverageFctFDM));

    std::vector<std::vector<GeneralStatistics> > slvStats(
        calibrationDates.size()-2,
            std::vector<GeneralStatistics>(LENGTH(strikes)));

    typedef SobolBrownianBridgeRsg rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;

    const Size factors = fdmSlvProcess->factors();

    const ext::shared_ptr<MultiPathGenerator<rsg_type> > pathGen(
        ext::make_shared<MultiPathGenerator<rsg_type> >(
            fdmSlvProcess, grid, rsg_type(factors, grid.size()-1), false));

    for (Size k=0; k < nScenarios; ++k) {
        const sample_type& path = pathGen->next();

        for (Size i=0, n=resetIndices.size(); i < n; ++i) {
            const Real S_t1 = path.value[0][resetIndices[i]];
            const Real S_T1 = path.value[0][maturityIndices[i]];

            for (Size j=0; j < LENGTH(strikes); ++j) {
                const Real strike = strikes[j];
                    slvStats[i][j].add((strike < 1.0)
                        ? S_t1 * std::max(0.0, strike - S_T1/S_t1)
                        : S_t1 * std::max(0.0, S_T1/S_t1 - strike));
            }

        }
    }

    for (Size i=0, n=resetIndices.size(); i < n; ++i) {
        const Date resetDate = calibrationDates[i];
        const Date maturityDate(calibrationDates[i+2]);
        const DiscountFactor df = rTS->discount(maturityDate);

        const ext::shared_ptr<Exercise> exercise(
            ext::make_shared<EuropeanExercise>(maturityDate));

        for (Size j=0; j < LENGTH(strikes); ++j) {
            const Real strike = strikes[j];
            const Real npv = slvStats[i][j].mean()*df;

            const ext::shared_ptr<StrikedTypePayoff> payoff(
                ext::make_shared<PlainVanillaPayoff>(
                    (strike < 1.0) ? Option::Put : Option::Call, strike));

            const ext::shared_ptr<ForwardVanillaOption> fwdOption(
                ext::make_shared<ForwardVanillaOption>(
                    strike, resetDate, payoff, exercise));

            const Volatility implVol =
                QuantLib::detail::ImpliedVolatilityHelper::calculate(
                    *fwdOption, *fwdEngine, *vol, npv, 1e-8, 200, 1e-4, 2.0);

            const Size idx = j + i*LENGTH(strikes);
            refVols[idx] = implVol;
        }
    }

    SquareRootCLVCalibrationFunction costFunction(
        Array(strikes, strikes+LENGTH(strikes)),
        resetDates,
        maturityDates,
        bsProcess,
        refVols,
        nScenarios);

    NonZeroConstraint nonZeroConstraint;

    CompositeConstraint constraint(
        nonZeroConstraint,
        HestonModel::FellerConstraint());

    Array params(4);
    params[0] = sTheta; params[1] = sKappa;
    params[2] = sSigma; params[3] = sX0;


    //    Optimization would take too long
    //
    //    Problem prob(costFunction, nonZeroConstraint, params);
    //
    //    Simplex simplex(0.05);
    //    simplex.minimize(prob, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8));

    const Real tol = 0.5;
    const Real costValue = costFunction.value(params);

    if (costValue > tol) {
        BOOST_FAIL("failed to reproduce small cost function value"
                << "\n    value:       " << costValue
                << "\n    tolerance:   " << tol);
    }

    const Date maturityDate = todaysDate + Period(1, Years);
    const Time maturityTime = bsProcess->time(maturityDate);

    const ext::shared_ptr<Exercise> europeanExercise(
        ext::make_shared<EuropeanExercise>(maturityDate));

    VanillaOption vanillaATMOption(
        ext::make_shared<PlainVanillaPayoff>(Option::Call,
            s0*qTS->discount(maturityDate)/rTS->discount(maturityDate)),
        europeanExercise);

    vanillaATMOption.setPricingEngine(
        ext::make_shared<AnalyticHestonEngine>(hestonModel));

    const Volatility atmVol = vanillaATMOption.impliedVolatility(
        vanillaATMOption.NPV(),
        ext::make_shared<GeneralizedBlackScholesProcess>(spot, qTS, rTS,
            Handle<BlackVolTermStructure>(flatVol(std::sqrt(theta), dc))));

    const ext::shared_ptr<PricingEngine> analyticEngine(
        ext::make_shared<AnalyticDoubleBarrierBinaryEngine>(
            ext::make_shared<GeneralizedBlackScholesProcess>(
                spot, qTS, rTS,
                Handle<BlackVolTermStructure>(flatVol(atmVol, dc)))));

    const ext::shared_ptr<PricingEngine> fdSLVEngine(
        ext::make_shared<FdHestonDoubleBarrierEngine>(
            hestonModel4slv.currentLink(),
            51, 201, 51, 1,
            FdmSchemeDesc::Hundsdorfer(), leverageFctFDM));

    const Size n = 16;
    Array barrier_lo(n), barrier_hi(n), bsNPV(n), slvNPV(n);

    const ext::shared_ptr<CashOrNothingPayoff> payoff =
        ext::make_shared<CashOrNothingPayoff>(Option::Call, 0.0, 1.0);

    for (Size i=0; i < n; ++i) {
        const Real dist = 20.0+5.0*i;

        barrier_lo[i] = std::max(s0 - dist, 1e-2);
        barrier_hi[i] = s0 + dist;
        DoubleBarrierOption doubleBarrier(
            DoubleBarrier::KnockOut, barrier_lo[i], barrier_hi[i], 0.0,
            payoff,
            europeanExercise);

        doubleBarrier.setPricingEngine(analyticEngine);
        bsNPV[i] = doubleBarrier.NPV();

        doubleBarrier.setPricingEngine(fdSLVEngine);
        slvNPV[i] = doubleBarrier.NPV();
    }


    const TimeGrid bGrid(maturityTime, tSteps);

    const PseudoRandom::ursg_type ursg = PseudoRandom::ursg_type(tSteps, 1235UL);

    std::vector<GeneralStatistics> stats(n);

    const Real df = 4*sTheta*sKappa/(sSigma*sSigma);

    for (Size i=0; i < nScenarios; ++i) {
        std::vector<bool> touch(n, false);

        const std::vector<Real>& path = ursg.nextSequence().value;

        Real x = sX0;

        for (Size j=0; j < tSteps; ++j) {
            const Time t0 = bGrid.at(j);
            const Time t1 = bGrid.at(j+1);

            const Real ncp = 4*sKappa*std::exp(-sKappa*(t1-t0))
                / (sSigma*sSigma*(1-std::exp(-sKappa*(t1-t0))))*x;

            const boost::math::non_central_chi_squared_distribution<Real>
                dist(df, ncp);

            const Real u = boost::math::quantile(dist, path[j]);

            x = sSigma*sSigma*(1-std::exp(-sKappa*(t1-t0)))/(4*sKappa) * u;

            const Real X = x*4*sKappa/(sSigma*sSigma*(1-std::exp(-sKappa*t1)));

            const Real s = gSqrt(t1, X);

            if (t1 > 0.05) {
                for (Size u=0; u < n; ++u) {
                    if (s <= barrier_lo[u] || s >= barrier_hi[u]) {
                        touch[u] = true;
                    }
                }
            }
        }
        for (Size u=0; u < n; ++u) {
            if (touch[u]) {
                stats[u].add(0.0);
            }
            else {
                stats[u].add(rTS->discount(maturityDate));
            }
        }
    }


    for (Size u=0; u < n; ++u) {
        const Real calculated = stats[u].mean();
        const Real error = stats[u].errorEstimate();
        const Real expected = slvNPV[u];

        const Real tol = 2.35*error;

        if (std::fabs(calculated-expected) > tol) {
            BOOST_FAIL("failed to reproduce CLV double no touch barrier price"
                    << "\n    CLV value:   " << calculated
                    << "\n    error    :   " << error
                    << "\n    SLV value: " << expected);
        }
    }
}

 
test_suite* SquareRootCLVModelTest::experimental() {
    auto* suite = BOOST_TEST_SUITE("SquareRootCLVModel tests");

    suite->add(QUANTLIB_TEST_CASE(
        &SquareRootCLVModelTest::testSquareRootCLVVanillaPricing));

    suite->add(QUANTLIB_TEST_CASE(
        &SquareRootCLVModelTest::testSquareRootCLVMappingFunction));

//    this test takes very long
//    suite->add(QUANTLIB_TEST_CASE(
//        &SquareRootCLVModelTest::testForwardSkew));

    return suite;
}
]]></document_content>
  </document>
  <document index="260">
    <source>squarerootclvmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_square_root_clv_model_hpp
#define quantlib_test_square_root_clv_model_hpp

#include <boost/test/unit_test.hpp>


class SquareRootCLVModelTest {
   public:
    static void testSquareRootCLVVanillaPricing();
    static void testSquareRootCLVMappingFunction();
    static void testForwardSkew();
    static boost::unit_test_framework::test_suite* experimental();
};

#endif
]]></document_content>
  </document>
  <document index="261">
    <source>stats.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2005 Gary Kennedy
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "stats.hpp"
#include "utilities.hpp"
#include <ql/math/statistics/statistics.hpp>
#include <ql/math/statistics/incrementalstatistics.hpp>
#include <ql/math/statistics/gaussianstatistics.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/math/statistics/convergencestatistics.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/randomnumbers/inversecumulativerng.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/comparison.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    Real data[] =    { 3.0, 4.0, 5.0, 2.0, 3.0, 4.0, 5.0, 6.0, 4.0, 7.0 };
    Real weights[] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 };

    template <class S>
    void check(const std::string& name) {

        S s;
        for (Size i=0; i<LENGTH(data); i++)
            s.add(data[i],weights[i]);

        Real calculated, expected;
        Real tolerance;

        if (s.samples() != LENGTH(data))
            BOOST_FAIL(name << ": wrong number of samples\n"
                       << "    calculated: " << s.samples() << "\n"
                       << "    expected:   " << LENGTH(data));

        expected = std::accumulate(weights,weights+LENGTH(weights),Real(0.0));
        calculated = s.weightSum();
        if (calculated != expected)
            BOOST_FAIL(name << ": wrong sum of weights\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = *std::min_element(data,data+LENGTH(data));
        calculated = s.min();
        if (calculated != expected)
            BOOST_FAIL(name << ": wrong minimum value\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = *std::max_element(data,data+LENGTH(data));
        calculated = s.max();
        if (calculated != expected)
            BOOST_FAIL(name << ": wrong maximum value\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = 4.3;
        tolerance = 1.0e-9;
        calculated = s.mean();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL(name << ": wrong mean value\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = 2.23333333333;
        calculated = s.variance();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL(name << ": wrong variance\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = 1.4944341181;
        calculated = s.standardDeviation();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL(name << ": wrong standard deviation\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = 0.359543071407;
        calculated = s.skewness();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL(name << ": wrong skewness\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);

        expected = -0.151799637209;
        calculated = s.kurtosis();
        if (std::fabs(calculated-expected) > tolerance)
            BOOST_FAIL(name << ": wrong kurtosis\n"
                       << "    calculated: " << calculated << "\n"
                       << "    expected:   " << expected);
    }

}


void StatisticsTest::testStatistics() {

    BOOST_TEST_MESSAGE("Testing statistics...");

    check<IncrementalStatistics>(
        std::string("IncrementalStatistics"));
    check<Statistics>(std::string("Statistics"));
}


namespace {

    template <class S>
    void checkSequence(const std::string& name, Size dimension) {

        GenericSequenceStatistics<S> ss(dimension);
        Size i;
        for (i = 0; i<LENGTH(data); i++) {
            std::vector<Real> temp(dimension, data[i]);
            ss.add(temp, weights[i]);
        }

        std::vector<Real> calculated;
        Real expected, tolerance;

        if (ss.samples() != LENGTH(data))
            BOOST_FAIL("SequenceStatistics<" << name << ">: "
                       << "wrong number of samples\n"
                       << "    calculated: " << ss.samples() << "\n"
                       << "    expected:   " << LENGTH(data));

        expected = std::accumulate(weights,weights+LENGTH(weights),Real(0.0));
        if (ss.weightSum() != expected)
            BOOST_FAIL("SequenceStatistics<" << name << ">: "
                       << "wrong sum of weights\n"
                       << "    calculated: " << ss.weightSum() << "\n"
                       << "    expected:   " << expected);

        expected = *std::min_element(data,data+LENGTH(data));
        calculated = ss.min();
        for (i=0; i<dimension; i++) {
            if (calculated[i] != expected)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong minimum value\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }

        expected = *std::max_element(data,data+LENGTH(data));
        calculated = ss.max();
        for (i=0; i<dimension; i++) {
            if (calculated[i] != expected)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong maximun value\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }

        expected = 4.3;
        tolerance = 1.0e-9;
        calculated = ss.mean();
        for (i=0; i<dimension; i++) {
            if (std::fabs(calculated[i]-expected) > tolerance)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong mean value\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }

        expected = 2.23333333333;
        calculated = ss.variance();
        for (i=0; i<dimension; i++) {
            if (std::fabs(calculated[i]-expected) > tolerance)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong variance\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }

        expected = 1.4944341181;
        calculated = ss.standardDeviation();
        for (i=0; i<dimension; i++) {
            if (std::fabs(calculated[i]-expected) > tolerance)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong standard deviation\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }

        expected = 0.359543071407;
        calculated = ss.skewness();
        for (i=0; i<dimension; i++) {
            if (std::fabs(calculated[i]-expected) > tolerance)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong skewness\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }

        expected = -0.151799637209;
        calculated = ss.kurtosis();
        for (i=0; i<dimension; i++) {
            if (std::fabs(calculated[i]-expected) > tolerance)
                BOOST_FAIL("SequenceStatistics<" << name << ">: "
                           << io::ordinal(i+1) << " dimension: "
                           << "wrong kurtosis\n"
                           << "    calculated: " << calculated[i] << "\n"
                           << "    expected:   " << expected);
        }
    }

}


void StatisticsTest::testSequenceStatistics() {

    BOOST_TEST_MESSAGE("Testing sequence statistics...");

    checkSequence<IncrementalStatistics>(
        std::string("IncrementalStatistics"),5);
    checkSequence<Statistics>(std::string("Statistics"),5);
}


namespace {

    template <class S>
    void checkConvergence(const std::string& name) {

        ConvergenceStatistics<S> stats;

        stats.add(1.0);
        stats.add(2.0);
        stats.add(3.0);
        stats.add(4.0);
        stats.add(5.0);
        stats.add(6.0);
        stats.add(7.0);
        stats.add(8.0);

        const Size expectedSize1 = 3;
        Size calculatedSize = stats.convergenceTable().size();
        if (calculatedSize != expectedSize1)
            BOOST_FAIL("ConvergenceStatistics<" << name << ">: "
                       << "\nwrong convergence-table size"
                       << "\n    calculated: " << calculatedSize
                       << "\n    expected:   " << expectedSize1);

        const Real expectedValue1 = 4.0;
        const Real tolerance = 1.0e-9;
        Real calculatedValue = stats.convergenceTable().back().second;
        if (std::fabs(calculatedValue-expectedValue1) > tolerance)
            BOOST_FAIL("wrong last value in convergence table"
                       << "\n    calculated: " << calculatedValue
                       << "\n    expected:   " << expectedValue1);

        const Size expectedSampleSize1 = 7;
        Size calculatedSamples = stats.convergenceTable().back().first;
        if (calculatedSamples != expectedSampleSize1)
            BOOST_FAIL("wrong number of samples in convergence table"
                       << "\n    calculated: " << calculatedSamples
                       << "\n    expected:   " << expectedSampleSize1);

        stats.reset();
        stats.add(1.0);
        stats.add(2.0);
        stats.add(3.0);
        stats.add(4.0);

        const Size expectedSize2 = 2;
        calculatedSize = stats.convergenceTable().size();
        if (calculatedSize != expectedSize2)
            BOOST_FAIL("wrong convergence-table size"
                       << "\n    calculated: " << calculatedSize
                       << "\n    expected:   " << expectedSize2);

        const Real expectedValue2 = 2.0;
        calculatedValue = stats.convergenceTable().back().second;
        if (std::fabs(calculatedValue-expectedValue2) > tolerance)
            BOOST_FAIL("wrong last value in convergence table"
                       << "\n    calculated: " << calculatedValue
                       << "\n    expected:   " << expectedValue2);

        const Size expectedSampleSize2 = 3;
        calculatedSamples = stats.convergenceTable().back().first;
        if (calculatedSamples != expectedSampleSize2)
            BOOST_FAIL("wrong number of samples in convergence table"
                       << "\n    calculated: " << calculatedSamples
                       << "\n    expected:   " << expectedSampleSize2);
    }

}


void StatisticsTest::testConvergenceStatistics() {

    BOOST_TEST_MESSAGE("Testing convergence statistics...");

    checkConvergence<IncrementalStatistics>(
                              std::string("IncrementalStatistics"));
    checkConvergence<Statistics>(std::string("Statistics"));
}

#define TEST_INC_STAT(expr, expected)                                          \
    if (!close_enough(expr, expected))                                         \
        BOOST_ERROR(std::setprecision(16)                                      \
                    << std::scientific << #expr << " (" << expr                \
                    << ") can not be reproduced against cached result ("       \
                    << expected << ")");

void StatisticsTest::testIncrementalStatistics() {

    BOOST_TEST_MESSAGE("Testing incremental statistics...");

    // With QuantLib 1.7 IncrementalStatistics was changed to
    // a wrapper to the boost accumulator library. This is
    // a test of the new implementation against results from
    // the old one.

    MersenneTwisterUniformRng mt(42);

    IncrementalStatistics stat;

    for (Size i = 0; i < 500000; ++i) {
        Real x = 2.0 * (mt.nextReal() - 0.5) * 1234.0;
        Real w = mt.nextReal();
        stat.add(x, w);
    }

    if (stat.samples() != 500000)
        BOOST_ERROR("stat.samples()  (" << stat.samples()
                    << ") can not be reproduced against cached result ("
                    << 500000 << ")");
    TEST_INC_STAT(stat.weightSum(), 2.5003623600676749e+05);
    TEST_INC_STAT(stat.mean(), 4.9122325964293845e-01);
    TEST_INC_STAT(stat.variance(),  5.0706503959683329e+05);
    TEST_INC_STAT(stat.standardDeviation(),  7.1208499464378076e+02);
    TEST_INC_STAT(stat.errorEstimate(), 1.0070402569876076e+00);
    TEST_INC_STAT(stat.skewness(), -1.7360169326720038e-03);
    TEST_INC_STAT(stat.kurtosis(), -1.1990742562085395e+00);
    TEST_INC_STAT(stat.min(), -1.2339945045639761e+03);
    TEST_INC_STAT(stat.max(),  1.2339958308008499e+03);
    TEST_INC_STAT(stat.downsideVariance(), 5.0786776146975247e+05);
    TEST_INC_STAT(stat.downsideDeviation(),  7.1264841364431061e+02);

    // This is a test for numerical stability,
    // where the old implementation fails

    InverseCumulativeRng<MersenneTwisterUniformRng,InverseCumulativeNormal> normal_gen(mt);

    IncrementalStatistics stat2;

    for (Size i = 0; i < 500000; ++i) {
        Real x = normal_gen.next().value * 1E-1 + 1E8;
        Real w = 1.0;
        stat2.add(x, w);
    }

    Real tol = 1E-5;

    if(std::fabs( stat2.variance() - 1E-2 ) > tol)
        BOOST_ERROR("variance (" << stat2.variance()
                                 << ") out of expected range " << 1E-2 << " +- "
                                 << tol);
}

test_suite* StatisticsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Statistics tests");
    suite->add(QUANTLIB_TEST_CASE(&StatisticsTest::testStatistics));
    suite->add(QUANTLIB_TEST_CASE(&StatisticsTest::testSequenceStatistics));
    suite->add(QUANTLIB_TEST_CASE(&StatisticsTest::testConvergenceStatistics));
    suite->add(QUANTLIB_TEST_CASE(&StatisticsTest::testIncrementalStatistics));
    return suite;
}
]]></document_content>
  </document>
  <document index="262">
    <source>stats.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2005 Gary Kennedy
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_statistics_hpp
#define quantlib_test_statistics_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class StatisticsTest {
  public:
    static void testStatistics();
    static void testSequenceStatistics();
    static void testConvergenceStatistics();
    static void testIncrementalStatistics();
    static boost::unit_test_framework::test_suite* suite();
};


#endif

]]></document_content>
  </document>
  <document index="263">
    <source>subperiodcoupons.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "subperiodcoupons.hpp"
#include "utilities.hpp"
#include <ql/cashflows/subperiodcoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/time/calendars/target.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace subperiodcoupons_test {

    struct CommonVars {

        Date today, settlement;
        Calendar calendar;
        Natural settlementDays;
        DayCounter dayCount;
        BusinessDayConvention businessConvention;

        ext::shared_ptr<IborIndex> euribor;
        RelinkableHandle<YieldTermStructure> euriborHandle;

        // cleanup
        SavedSettings backup;
        // utilities

        CommonVars() {
            settlementDays = 2;
            calendar = TARGET();
            dayCount = Actual365Fixed();
            businessConvention = ModifiedFollowing;

            euribor = ext::shared_ptr<IborIndex>(new Euribor6M(euriborHandle));
            euribor->addFixing(Date(10, February, 2021), 0.0085);

            today = calendar.adjust(Date(15, March, 2021));
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today, settlementDays, Days);

            euriborHandle.linkTo(flatRate(settlement, 0.007, dayCount));
        }

        Leg createIborLeg(const Date& start, const Date& end, Spread spread) {
            Schedule sch = MakeSchedule()
                               .from(start)
                               .to(end)
                               .withTenor(euribor->tenor())
                               .withCalendar(euribor->fixingCalendar())
                               .withConvention(euribor->businessDayConvention())
                               .backwards();
            return IborLeg(sch, euribor)
                .withNotionals(1.0)
                .withSpreads(spread)
                .withExCouponPeriod(2 * Days, calendar, businessConvention)
                .withPaymentLag(1)
                .withFixingDays(settlementDays);
        }

        ext::shared_ptr<CashFlow> createSubPeriodsCoupon(const Date& start,
                                                         const Date& end,
                                                         Spread rateSpread = 0.0,
                                                         Spread couponSpread = 0.0,
                                                         RateAveraging::Type averaging = RateAveraging::Compound) {
            Calendar paymentCalendar = euribor->fixingCalendar();
            BusinessDayConvention paymentBdc = euribor->businessDayConvention();
            Date paymentDate = paymentCalendar.advance(end, 1 * Days, paymentBdc);
            Date exCouponDate = paymentCalendar.advance(paymentDate, -2 * Days, paymentBdc);
            ext::shared_ptr<FloatingRateCoupon> cpn(new SubPeriodsCoupon(
                paymentDate, 1.0, start, end, settlementDays, euribor, 1.0, couponSpread,
                rateSpread, Date(), Date(), DayCounter(), exCouponDate));
            bool useCompoundedRate = (averaging == RateAveraging::Compound);
            if (useCompoundedRate)
                cpn->setPricer(
                    ext::shared_ptr<FloatingRateCouponPricer>(new CompoundingRatePricer()));
            else
                cpn->setPricer(
                    ext::shared_ptr<FloatingRateCouponPricer>(new AveragingRatePricer()));
            return cpn;
        }

        SubPeriodsLeg createSubPeriodsLeg(const Date& start,
                                          const Date& end,
                                          const Period& cpnFrequency,
                                          Spread rateSpread = 0.0,
                                          Spread couponSpread = 0.0,
                                          RateAveraging::Type averaging = RateAveraging::Compound) {
            Schedule sch = MakeSchedule()
                               .from(start)
                               .to(end)
                               .withTenor(cpnFrequency)
                               .withCalendar(euribor->fixingCalendar())
                               .withConvention(euribor->businessDayConvention())
                               .backwards();
            return SubPeriodsLeg(sch, euribor)
                .withNotionals(1.0)
                .withExCouponPeriod(2 * Days, calendar, businessConvention)
                .withPaymentLag(1)
                .withFixingDays(settlementDays)
                .withRateSpreads(rateSpread)
                .withCouponSpreads(couponSpread)
                .withAveragingMethod(averaging);
        }
    };

    Real sumIborLegPayments(const Leg& leg)
    {
        Real payments = 0.0;
        std::for_each(leg.begin(), leg.end(), [&payments](const ext::shared_ptr<CashFlow>& cf) {
            payments += cf->amount();
        });
        return payments;
    }

    Real compoundedIborLegPayment(const Leg& leg) {
        Real compound = 1.0;
        std::for_each(leg.begin(), leg.end(), [&compound](const ext::shared_ptr<CashFlow>& cf) {
            auto cpn = ext::dynamic_pointer_cast<IborCoupon>(cf);
            Real yearFraction = cpn->accrualPeriod();
            Rate fixing = cpn->indexFixing();
            compound *= (1.0 + yearFraction * (fixing + cpn->spread()));
        });
        return (compound - 1.0);
    }

    Real averagedIborLegPayment(const Leg& leg) {
        Real acc = 0.0;
        std::for_each(leg.begin(), leg.end(), [&acc](const ext::shared_ptr<CashFlow>& cf) {
            auto cpn = ext::dynamic_pointer_cast<IborCoupon>(cf);
            Real yearFraction = cpn->accrualPeriod();
            Rate fixing = cpn->indexFixing();
            acc += yearFraction * (fixing + cpn->spread());
        });
        return acc;
    }
}

void testSinglePeriodCouponReplication(const Date& start,
                                       const Date& end,
                                       Spread rateSpread,
                                       RateAveraging::Type averaging) {
    using namespace subperiodcoupons_test;
    CommonVars vars;

    Leg iborLeg = vars.createIborLeg(start, end, rateSpread);
    Spread couponSpread = 0.0;
    ext::shared_ptr<CashFlow> subPeriodCpn =
        vars.createSubPeriodsCoupon(start, end, rateSpread, couponSpread, averaging);

    Real tolerance = 1.0e-14;

    Real actualPayment = subPeriodCpn->amount();
    Real expectedPayment = sumIborLegPayments(iborLeg);

    if (std::fabs(actualPayment - expectedPayment) > tolerance)
        BOOST_ERROR("unable to replicate single period coupon payment\n"
                    << std::setprecision(5) << "    calculated:    " << actualPayment << "\n"
                    << "    expected:    " << expectedPayment << "\n"
                    << "    start:    " << start << "\n"
                    << "    end:    " << end << "\n");
}

void testMultipleCompoundedSubPeriodsCouponReplication(const Date& start,
                                                       const Date& end,
                                                       Spread rateSpread) {
    using namespace subperiodcoupons_test;
    CommonVars vars;

    Leg iborLeg = vars.createIborLeg(start, end, rateSpread);

    Spread couponSpread = 0.0;
    ext::shared_ptr<CashFlow> subPeriodCpn = vars.createSubPeriodsCoupon(
        start, end, rateSpread, couponSpread, RateAveraging::Compound);

    const Real tolerance = 1.0e-14;

    Real actualPayment = subPeriodCpn->amount();
    Real expectedPayment = compoundedIborLegPayment(iborLeg);

    if (std::fabs(actualPayment - expectedPayment) > tolerance)
        BOOST_ERROR("unable to replicate compounded multiple sub-period coupon payment\n"
                    << std::setprecision(5) << "    calculated:    " << actualPayment << "\n"
                    << "    expected:    " << expectedPayment << "\n"
                    << "    start:    " << start << "\n"
                    << "    end:    " << end << "\n");
}

void testMultipleAveragedSubPeriodsCouponReplication(const Date& start,
                                                     const Date& end,
                                                     Spread rateSpread) {
    using namespace subperiodcoupons_test;
    CommonVars vars;

    Leg iborLeg = vars.createIborLeg(start, end, rateSpread);
    
    Spread couponSpread = 0.0;
    ext::shared_ptr<CashFlow> subPeriodCpn = vars.createSubPeriodsCoupon(
        start, end, rateSpread, couponSpread, RateAveraging::Simple);

    const Real tolerance = 1.0e-14;

    Real actualPayment = subPeriodCpn->amount();
    Real expectedPayment = averagedIborLegPayment(iborLeg);

    if (std::fabs(actualPayment - expectedPayment) > tolerance)
        BOOST_ERROR("unable to replicate averaged multiple sub-period coupon payment\n"
                    << std::setprecision(5) << "    calculated:    " << actualPayment << "\n"
                    << "    expected:    " << expectedPayment << "\n"
                    << "    start:    " << start << "\n"
                    << "    end:    " << end << "\n");
}

void testSubPeriodsLegReplication(RateAveraging::Type averaging) {
    using namespace subperiodcoupons_test;
    CommonVars vars;

    Date start(18, March, 2021);
    Date end(18, March, 2022);

    Spread rateSpread = 0.001;
    Spread couponSpread = 0.002;

    ext::shared_ptr<CashFlow> subPeriodCpn =
        vars.createSubPeriodsCoupon(start, end, rateSpread, couponSpread, averaging);

    Leg subPeriodLeg =
        vars.createSubPeriodsLeg(start, end, 1 * Years, rateSpread, couponSpread, averaging);

    const Real tolerance = 1.0e-14;

    Real actualPayment = 0.0;
    // Only one cash flow is expected with this parametrization
    std::for_each(
        subPeriodLeg.begin(), subPeriodLeg.end(),
        [&actualPayment](const ext::shared_ptr<CashFlow>& cf) { actualPayment += cf->amount(); });
    Real expectedPayment = subPeriodCpn->amount();

    if (std::fabs(actualPayment - expectedPayment) > tolerance)
        BOOST_ERROR("unable to replicate sub-period leg payments\n"
                    << std::setprecision(5) << "    calculated:    " << actualPayment << "\n"
                    << "    expected:    " << expectedPayment << "\n"
                    << "    averaging:    " << averaging << "\n");
}

void SubPeriodsCouponTest::testRegularSinglePeriodForwardStartingCoupon() {
    BOOST_TEST_MESSAGE("Testing regular single period forward starting coupon...");

    Date start(15, April, 2021);
    Date end(15, October, 2021);

    Spread spread = 0.001;
    // For a single sub-period averaging method should not matter.
    testSinglePeriodCouponReplication(start, end, spread, RateAveraging::Compound);
    testSinglePeriodCouponReplication(start, end, spread, RateAveraging::Simple);
}

void SubPeriodsCouponTest::testRegularSinglePeriodCouponAfterFixing() {
    BOOST_TEST_MESSAGE("Testing regular single period coupon after fixing...");

    Date start(12, February, 2021);
    Date end(12, August, 2021);

    Spread spread = 0.001;
    // For a single sub-period averaging method should not matter.
    testSinglePeriodCouponReplication(start, end, spread, RateAveraging::Compound);
    testSinglePeriodCouponReplication(start, end, spread, RateAveraging::Simple);
}

void SubPeriodsCouponTest::testIrregularSinglePeriodCouponAfterFixing() {
    BOOST_TEST_MESSAGE("Testing irregular single period coupon after fixing...");

    Date start(12, February, 2021);
    Date end(12, June, 2021);

    Spread spread = 0.001;
    // For a single sub-period averaging method should not matter.
    testSinglePeriodCouponReplication(start, end, spread, RateAveraging::Compound);
    testSinglePeriodCouponReplication(start, end, spread, RateAveraging::Simple);
}

void SubPeriodsCouponTest::testRegularCompoundedForwardStartingCouponWithMultipleSubPeriods() {
    BOOST_TEST_MESSAGE("Testing regular forward starting coupon with multiple compounded sub-periods...");

    Date start(15, April, 2021);
    Date end(15, April, 2022);

    Spread spread = 0.001;
    testMultipleCompoundedSubPeriodsCouponReplication(start, end, spread);
}

void SubPeriodsCouponTest::testRegularAveragedForwardStartingCouponWithMultipleSubPeriods() {
    BOOST_TEST_MESSAGE("Testing regular forward starting coupon with multiple averaged sub-periods...");

    Date start(15, April, 2021);
    Date end(15, April, 2022);

    Spread spread = 0.001;
    testMultipleAveragedSubPeriodsCouponReplication(start, end, spread);
}

void SubPeriodsCouponTest::testExCouponCashFlow() {
    BOOST_TEST_MESSAGE("Testing ex-coupon cash flow...");

    using namespace subperiodcoupons_test;
    CommonVars vars;

    Date start(12, February, 2021);
    Date end(17, March, 2021);

    std::vector<ext::shared_ptr<CashFlow> > cfs{vars.createSubPeriodsCoupon(start, end)};

    Real npv = CashFlows::npv(cfs, **vars.euriborHandle, false, vars.settlement, vars.settlement);

    const Real tolerance = 1.0e-14;

    if (std::fabs(npv) > tolerance)
        BOOST_ERROR("cash flow was expected to go ex-coupon\n"
                    << std::setprecision(5) << "    calculated:    " << npv << "\n"
                    << "    expected:    " << 0.0 << "\n"
                    << "    start:    " << start << "\n"
                    << "    end:    " << end << "\n");
}

void SubPeriodsCouponTest::testSubPeriodsLegCashFlows() {
    BOOST_TEST_MESSAGE(
        "Testing sub-periods leg replication...");

    testSubPeriodsLegReplication(RateAveraging::Compound);
    testSubPeriodsLegReplication(RateAveraging::Simple);
}

void SubPeriodsCouponTest::testSubPeriodsLegConsistencyChecks() {
    BOOST_TEST_MESSAGE("Testing sub-periods leg consistency checks...");

    using namespace subperiodcoupons_test;
    CommonVars vars;

    Date start(18, March, 2021);
    Date end(18, March, 2031);

    SubPeriodsLeg subPeriodLeg =
        vars.createSubPeriodsLeg(start, end, 1 * Years);

    BOOST_CHECK_THROW(
        Leg l0(vars.createSubPeriodsLeg(start, end, 1 * Years).withNotionals(std::vector<Real>())),
        Error);
    BOOST_CHECK_THROW(Leg l1(vars.createSubPeriodsLeg(start, end, 1 * Years)
                                 .withNotionals(std::vector<Real>(11, 1.0))),
                      Error);
    BOOST_CHECK_THROW(Leg l2(vars.createSubPeriodsLeg(start, end, 1 * Years)
                                 .withFixingDays(std::vector<Natural>(11, 2))),
                      Error);
    BOOST_CHECK_THROW(Leg l3(vars.createSubPeriodsLeg(start, end, 1 * Years).withGearings(0.0)),
                      Error);
    BOOST_CHECK_THROW(Leg l4(vars.createSubPeriodsLeg(start, end, 1 * Years)
                                 .withGearings(std::vector<Real>(11, 1.0))),
                      Error);
    BOOST_CHECK_THROW(Leg l5(vars.createSubPeriodsLeg(start, end, 1 * Years)
                                 .withCouponSpreads(std::vector<Spread>(11, 0.0))),
                      Error);
    BOOST_CHECK_THROW(Leg l6(vars.createSubPeriodsLeg(start, end, 1 * Years)
                                 .withRateSpreads(std::vector<Spread>(11, 0.0))),
                      Error);
}

test_suite* SubPeriodsCouponTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Sub-period coupons tests");

    suite->add(
        QUANTLIB_TEST_CASE(&SubPeriodsCouponTest::testRegularSinglePeriodForwardStartingCoupon));
    suite->add(QUANTLIB_TEST_CASE(&SubPeriodsCouponTest::testRegularSinglePeriodCouponAfterFixing));
    suite->add(
        QUANTLIB_TEST_CASE(&SubPeriodsCouponTest::testIrregularSinglePeriodCouponAfterFixing));
    suite->add(QUANTLIB_TEST_CASE(
        &SubPeriodsCouponTest::testRegularCompoundedForwardStartingCouponWithMultipleSubPeriods));
    suite->add(QUANTLIB_TEST_CASE(
        &SubPeriodsCouponTest::testRegularAveragedForwardStartingCouponWithMultipleSubPeriods));
    suite->add(QUANTLIB_TEST_CASE(&SubPeriodsCouponTest::testExCouponCashFlow));
    suite->add(QUANTLIB_TEST_CASE(&SubPeriodsCouponTest::testSubPeriodsLegCashFlows));
    suite->add(QUANTLIB_TEST_CASE(&SubPeriodsCouponTest::testSubPeriodsLegConsistencyChecks));

    return suite;
}
]]></document_content>
  </document>
  <document index="264">
    <source>subperiodcoupons.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_subperiodcoupons_hpp
#define quantlib_test_subperiodcoupons_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SubPeriodsCouponTest {
  public:
    static void testRegularSinglePeriodForwardStartingCoupon();
    static void testRegularSinglePeriodCouponAfterFixing();
    static void testIrregularSinglePeriodCouponAfterFixing();
    static void testRegularCompoundedForwardStartingCouponWithMultipleSubPeriods();
    static void testRegularAveragedForwardStartingCouponWithMultipleSubPeriods();
    static void testExCouponCashFlow();
    static void testSubPeriodsLegCashFlows();
    static void testSubPeriodsLegConsistencyChecks();

    static boost::unit_test_framework::test_suite* suite();
};

#endif]]></document_content>
  </document>
  <document index="265">
    <source>swap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "swap.hpp"
#include "utilities.hpp"
#include <ql/instruments/vanillaswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/currencies/europe.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace swap_test {

    struct CommonVars {
        // global data
        Date today, settlement;
        Swap::Type type;
        Real nominal;
        Calendar calendar;
        BusinessDayConvention fixedConvention, floatingConvention;
        Frequency fixedFrequency, floatingFrequency;
        DayCounter fixedDayCount;
        ext::shared_ptr<IborIndex> index;
        Natural settlementDays;
        RelinkableHandle<YieldTermStructure> termStructure;

        // cleanup
        SavedSettings backup;
        
        // utilities
        ext::shared_ptr<VanillaSwap>
        makeSwap(Integer length, Rate fixedRate, Spread floatingSpread) const {
            Date maturity = calendar.advance(settlement,length,Years,
                                             floatingConvention);
            Schedule fixedSchedule(settlement,maturity,Period(fixedFrequency),
                                   calendar,fixedConvention,fixedConvention,
                                   DateGeneration::Forward,false);
            Schedule floatSchedule(settlement,maturity,
                                   Period(floatingFrequency),
                                   calendar,floatingConvention,
                                   floatingConvention,
                                   DateGeneration::Forward,false);
            ext::shared_ptr<VanillaSwap> swap(
                new VanillaSwap(type, nominal,
                                fixedSchedule, fixedRate, fixedDayCount,
                                floatSchedule, index, floatingSpread,
                                index->dayCounter()));
            swap->setPricingEngine(ext::shared_ptr<PricingEngine>(
                                  new DiscountingSwapEngine(termStructure)));
            return swap;
        }

        CommonVars() {
            type = Swap::Payer;
            settlementDays = 2;
            nominal = 100.0;
            fixedConvention = Unadjusted;
            floatingConvention = ModifiedFollowing;
            fixedFrequency = Annual;
            floatingFrequency = Semiannual;
            fixedDayCount = Thirty360(Thirty360::BondBasis);
            index = ext::shared_ptr<IborIndex>(new
                Euribor(Period(floatingFrequency), termStructure));
            calendar = index->fixingCalendar();
            today = calendar.adjust(Settings::instance().evaluationDate());
            settlement = calendar.advance(today,settlementDays,Days);
            termStructure.linkTo(flatRate(settlement,0.05,Actual365Fixed()));
        }
    };

}


void SwapTest::testFairRate() {

    BOOST_TEST_MESSAGE("Testing vanilla-swap calculation of fair fixed rate...");

    using namespace swap_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 5, 10, 20 };
    Spread spreads[] = { -0.001, -0.01, 0.0, 0.01, 0.001 };

    for (int& length : lengths) {
        for (double spread : spreads) {

            ext::shared_ptr<VanillaSwap> swap = vars.makeSwap(length, 0.0, spread);
            swap = vars.makeSwap(length, swap->fairRate(), spread);
            if (std::fabs(swap->NPV()) > 1.0e-10) {
                BOOST_ERROR("recalculating with implied rate:\n"
                            << std::setprecision(2) << "    length: " << length << " years\n"
                            << "    floating spread: " << io::rate(spread) << "\n"
                            << "    swap value: " << swap->NPV());
            }
        }
    }
}

void SwapTest::testFairSpread() {

    BOOST_TEST_MESSAGE("Testing vanilla-swap calculation of "
                       "fair floating spread...");

    using namespace swap_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 5, 10, 20 };
    Rate rates[] = { 0.04, 0.05, 0.06, 0.07 };

    for (int& length : lengths) {
        for (double j : rates) {

            ext::shared_ptr<VanillaSwap> swap = vars.makeSwap(length, j, 0.0);
            swap = vars.makeSwap(length, j, swap->fairSpread());
            if (std::fabs(swap->NPV()) > 1.0e-10) {
                BOOST_ERROR("recalculating with implied spread:\n"
                            << std::setprecision(2) << "    length: " << length << " years\n"
                            << "    fixed rate: " << io::rate(j) << "\n"
                            << "    swap value: " << swap->NPV());
            }
        }
    }
}

void SwapTest::testRateDependency() {

    BOOST_TEST_MESSAGE("Testing vanilla-swap dependency on fixed rate...");

    using namespace swap_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 5, 10, 20 };
    Spread spreads[] = { -0.001, -0.01, 0.0, 0.01, 0.001 };
    Rate rates[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };

    for (int& length : lengths) {
        for (double spread : spreads) {
            // store the results for different rates...
            std::vector<Real> swap_values;
            for (double rate : rates) {
                ext::shared_ptr<VanillaSwap> swap = vars.makeSwap(length, rate, spread);
                swap_values.push_back(swap->NPV());
            }
            // and check that they go the right way
            auto it = std::adjacent_find(swap_values.begin(), swap_values.end(), std::less<Real>());
            if (it != swap_values.end()) {
                Size n = it - swap_values.begin();
                BOOST_ERROR("NPV is increasing with the fixed rate in a swap: \n"
                            << "    length: " << length << " years\n"
                            << "    value:  " << swap_values[n]
                            << " paying fixed rate: " << io::rate(rates[n]) << "\n"
                            << "    value:  " << swap_values[n + 1]
                            << " paying fixed rate: " << io::rate(rates[n + 1]));
            }
        }
    }
}

void SwapTest::testSpreadDependency() {

    BOOST_TEST_MESSAGE("Testing vanilla-swap dependency on floating spread...");

    using namespace swap_test;

    CommonVars vars;

    Integer lengths[] = { 1, 2, 5, 10, 20 };
    Rate rates[] = { 0.04, 0.05, 0.06, 0.07 };
    Spread spreads[] = { -0.01, -0.002, -0.001, 0.0, 0.001, 0.002, 0.01 };

    for (int& length : lengths) {
        for (double j : rates) {
            // store the results for different spreads...
            std::vector<Real> swap_values;
            for (double spread : spreads) {
                ext::shared_ptr<VanillaSwap> swap = vars.makeSwap(length, j, spread);
                swap_values.push_back(swap->NPV());
            }
            // and check that they go the right way
            auto it =
                std::adjacent_find(swap_values.begin(), swap_values.end(), std::greater<Real>());
            if (it != swap_values.end()) {
                Size n = it - swap_values.begin();
                BOOST_ERROR("NPV is decreasing with the floating spread in a swap: \n"
                            << "    length: " << length << " years\n"
                            << "    value:  " << swap_values[n]
                            << " receiving spread: " << io::rate(spreads[n]) << "\n"
                            << "    value:  " << swap_values[n + 1]
                            << " receiving spread: " << io::rate(spreads[n + 1]));
            }
        }
    }
}

void SwapTest::testInArrears() {

    BOOST_TEST_MESSAGE("Testing in-arrears swap calculation...");

    using namespace swap_test;

    CommonVars vars;

    /* See Hull, 4th ed., page 550
       Note: the calculation in the book is wrong (work out the
       adjustment and you'll get 0.05 + 0.000115 T1)
    */

    Date maturity = vars.today + 5*Years;
    Calendar calendar = NullCalendar();
    Schedule schedule(vars.today, maturity,Period(Annual),calendar,
                      Following,Following,
                      DateGeneration::Forward,false);
    DayCounter dayCounter = SimpleDayCounter();
    std::vector<Real> nominals(1, 100000000.0);
    ext::shared_ptr<IborIndex> index(new IborIndex("dummy", 1*Years, 0,
                                             EURCurrency(), calendar,
                                             Following, false, dayCounter,
                                             vars.termStructure));
    Rate oneYear = 0.05;
    Rate r = std::log(1.0+oneYear);
    vars.termStructure.linkTo(flatRate(vars.today,r,dayCounter));


    std::vector<Rate> coupons(1, oneYear);
    Leg fixedLeg = FixedRateLeg(schedule)
        .withNotionals(nominals)
        .withCouponRates(coupons, dayCounter);

    std::vector<Real> gearings;
    std::vector<Rate> spreads;
    Natural fixingDays = 0;

    Volatility capletVolatility = 0.22;
    Handle<OptionletVolatilityStructure> vol(
        ext::shared_ptr<OptionletVolatilityStructure>(new
            ConstantOptionletVolatility(vars.today, NullCalendar(), Following,
                                        capletVolatility, dayCounter)));
    ext::shared_ptr<IborCouponPricer> pricer(new
        BlackIborCouponPricer(vol));

    Leg floatingLeg = IborLeg(schedule, index)
        .withNotionals(nominals)
        .withPaymentDayCounter(dayCounter)
        .withFixingDays(fixingDays)
        .withGearings(gearings)
        .withSpreads(spreads)
        .inArrears();
    setCouponPricer(floatingLeg, pricer);

    Swap swap(floatingLeg,fixedLeg);
    swap.setPricingEngine(ext::shared_ptr<PricingEngine>(
                              new DiscountingSwapEngine(vars.termStructure)));

    Decimal storedValue = -144813.0;
    Real tolerance = 1.0;

    if (std::fabs(swap.NPV()-storedValue) > tolerance)
        BOOST_ERROR("Wrong NPV calculation:\n"
                    << "    expected:   " << storedValue << "\n"
                    << "    calculated: " << swap.NPV());
}

void SwapTest::testCachedValue() {

    BOOST_TEST_MESSAGE("Testing vanilla-swap calculation against cached value...");

    using namespace swap_test;

    CommonVars vars;

    vars.today = Date(17,June,2002);
    Settings::instance().evaluationDate() = vars.today;
    vars.settlement =
        vars.calendar.advance(vars.today,vars.settlementDays,Days);
    vars.termStructure.linkTo(flatRate(vars.settlement,0.05,Actual365Fixed()));

    ext::shared_ptr<VanillaSwap> swap = vars.makeSwap(10, 0.06, 0.001);

    if (swap->numberOfLegs() != 2)
        BOOST_ERROR("failed to return correct number of legs:\n"
                    << std::fixed << std::setprecision(12)
                    << "    calculated: " << swap->numberOfLegs() << "\n"
                    << "    expected:   " << 2);

    Real cachedNPV;  
    if (IborCoupon::usingAtParCoupons())
        cachedNPV = -5.872863313209;
    else
        cachedNPV = -5.872342992212;

    if (std::fabs(swap->NPV()-cachedNPV) > 1.0e-11)
        BOOST_ERROR("failed to reproduce cached swap value:\n"
                    << std::fixed << std::setprecision(12)
                    << "    calculated: " << swap->NPV() << "\n"
                    << "    expected:   " << cachedNPV);
}


test_suite* SwapTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Swap tests");
    suite->add(QUANTLIB_TEST_CASE(&SwapTest::testFairRate));
    suite->add(QUANTLIB_TEST_CASE(&SwapTest::testFairSpread));
    suite->add(QUANTLIB_TEST_CASE(&SwapTest::testRateDependency));
    suite->add(QUANTLIB_TEST_CASE(&SwapTest::testSpreadDependency));
    suite->add(QUANTLIB_TEST_CASE(&SwapTest::testInArrears));
    suite->add(QUANTLIB_TEST_CASE(&SwapTest::testCachedValue));
    return suite;
}

]]></document_content>
  </document>
  <document index="266">
    <source>swap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swap_hpp
#define quantlib_test_swap_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SwapTest {
  public:
    static void testFairRate();
    static void testFairSpread();
    static void testRateDependency();
    static void testSpreadDependency();
    static void testInArrears();
    static void testCachedValue();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="267">
    <source>swapforwardmappings.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2007 Ferdinando Ametrano
Copyright (C) 2006 Franois du Vignaud

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "swapforwardmappings.hpp"
#include "utilities.hpp"
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/pricingengines/blackcalculator.hpp>

#include <ql/models/marketmodels/products/multistep/multistepswaption.hpp>

#if defined(BOOST_MSVC)
#include <float.h>
//namespace { unsigned int u = _controlfp(_EM_INEXACT, _MCW_EM); }
#endif

using namespace QuantLib;
using namespace boost::unit_test_framework;

using std::fabs;
using std::sqrt;

namespace {

    class MarketModelData{
    public:
        MarketModelData();
        const std::vector<Time>& rateTimes(){return rateTimes_;}
        const std::vector<Rate>& forwards(){return forwards_;}
        const std::vector<Volatility>& volatilities(){return volatilities_;}
        const std::vector<Rate>& displacements(){return displacements_;}
        const std::vector<DiscountFactor>& discountFactors(){return discountFactors_;}
        Size nbRates() const { return nbRates_; }

      private:
        std::vector<Time> rateTimes_, accruals_;
        std::vector<Rate> forwards_;
        std::vector<Spread> displacements_;
        std::vector<Volatility> volatilities_;
        std::vector<DiscountFactor> discountFactors_;
        Size nbRates_;
    };

    MarketModelData::MarketModelData(){
        // Times
        Calendar calendar = NullCalendar();
        Date todaysDate = Settings::instance().evaluationDate();
        Date endDate = todaysDate + 9*Years; // change back
        Schedule dates(todaysDate, endDate, Period(Semiannual),
            calendar, Following, Following, DateGeneration::Backward, false);
        nbRates_ = dates.size()-2;
        rateTimes_ = std::vector<Time>(nbRates_+1);
        //paymentTimes_ = std::vector<Time>(rateTimes_.size()-1);
        accruals_ = std::vector<Time>(nbRates_);
        DayCounter dayCounter = SimpleDayCounter();
        for (Size i=1; i<nbRates_+2; ++i)
            rateTimes_[i-1] = dayCounter.yearFraction(todaysDate, dates[i]);

        displacements_ = std::vector<Rate>(nbRates_, .0);

        forwards_ = std::vector<Rate>(nbRates_);
        discountFactors_ = std::vector<Rate>(nbRates_+1);
        discountFactors_[0] = 1.0; // .95; fdv1-> WHY ???????
        for (Size i=0; i<nbRates_; ++i){
            forwards_[i] = 0.03 + 0.0010*i;
            accruals_[i] = rateTimes_[i+1] - rateTimes_[i];
            discountFactors_[i+1] = discountFactors_[i]
            /(1+forwards_[i]*accruals_[i]);
        }
        Volatility mktVols[] = {0.15541283,
            0.18719678,
            0.20890740,
            0.22318179,
            0.23212717,
            0.23731450,
            0.23988649,
            0.24066384,
            0.24023111,
            0.23900189,
            0.23726699,
            0.23522952,
            0.23303022,
            0.23076564,
            0.22850101,
            0.22627951,
            0.22412881,
            0.22206569,
            0.22009939
            /*
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2,
            0.2
            */

        };
        volatilities_ = std::vector<Volatility>(nbRates_);
        for (Size i = 0; i < volatilities_.size(); ++i)
            volatilities_[i] =   mktVols[i];//.0;
    }

    ext::shared_ptr<SequenceStatisticsInc>
    simulate(const std::vector<Real>& todaysDiscounts,
             const ext::shared_ptr<MarketModelEvolver>& evolver,
             const MarketModelMultiProduct& product) {
        Size paths_;
#ifdef _DEBUG
        paths_ = 127;// //
#else
        paths_ = 32767; //262144-1; // //; // 2^15-1
#endif

        Size initialNumeraire = evolver->numeraires().front();
        Real initialNumeraireValue = todaysDiscounts[initialNumeraire];

        AccountingEngine engine(evolver, product, initialNumeraireValue);
        ext::shared_ptr<SequenceStatisticsInc> stats(new
            SequenceStatisticsInc(product.numberOfProducts()));
        engine.multiplePathValues(*stats, paths_);
        return stats;
    }

    MultiStepCoterminalSwaptions makeMultiStepCoterminalSwaptions(
        const std::vector<Time>& rateTimes, Real strike ){
            std::vector<Time> paymentTimes(rateTimes.begin(), rateTimes.end()-1);
            std::vector<ext::shared_ptr<StrikedTypePayoff> > payoffs(paymentTimes.size());
            for (auto& payoff : payoffs) {
                payoff = ext::shared_ptr<StrikedTypePayoff>(
                    new PlainVanillaPayoff(Option::Call, strike));
            }
            return MultiStepCoterminalSwaptions (rateTimes,
                paymentTimes, payoffs);

    }

}


void SwapForwardMappingsTest::testForwardSwapJacobians()
{
    {
        BOOST_TEST_MESSAGE("Testing forward-rate coinitial-swap Jacobian...");
        MarketModelData marketData;
        const std::vector<Time>& rateTimes = marketData.rateTimes();
        const std::vector<Rate>& forwards = marketData.forwards();
        const Size nbRates = marketData.nbRates();
        LMMCurveState lmmCurveState(rateTimes);
        lmmCurveState.setOnForwardRates(forwards);

        Real bumpSize = 1e-8;

        std::vector<Rate> bumpedForwards(forwards);

        Matrix coinitialJacobian(nbRates,nbRates);

        for (Size i=0; i < nbRates; ++i)
            for (Size j=0; j < nbRates; ++j)
            {
                bumpedForwards = forwards;
                bumpedForwards[j]+= bumpSize;
                lmmCurveState.setOnForwardRates(bumpedForwards);
                Real upRate = lmmCurveState.cmSwapRate(0,i+1);
                bumpedForwards[j]-= 2.0*bumpSize;
                lmmCurveState.setOnForwardRates(bumpedForwards);
                Real downRate = lmmCurveState.cmSwapRate(0,i+1);
                Real deriv = (upRate-downRate)/(2.0*bumpSize);
                coinitialJacobian[i][j] = deriv;

            }

        Matrix modelJacobian(SwapForwardMappings::coinitialSwapForwardJacobian(lmmCurveState));

        Real errorTolerance = 1e-5;


        for (Size i=0; i < nbRates; ++i)
            for (Size j=0; j < nbRates; ++j)
                if( fabs(modelJacobian[i][j]-coinitialJacobian[i][j]) > errorTolerance)
                {
                    BOOST_TEST_MESSAGE("rate " << i
                                       << ", sensitivity "  <<  j
                                       << ", formula value " << modelJacobian[i][j]
                                       << " bumping value " << coinitialJacobian[i][j]
                                       <<  "\n");

                    BOOST_ERROR("test failed");
                }
    }

    {

        BOOST_TEST_MESSAGE("Testing forward-rate constant-maturity swap Jacobian...");
        MarketModelData marketData;
        const std::vector<Time>& rateTimes = marketData.rateTimes();
        const std::vector<Rate>& forwards = marketData.forwards();
        const Size nbRates = marketData.nbRates();
        LMMCurveState lmmCurveState(rateTimes);
        lmmCurveState.setOnForwardRates(forwards);

        Real bumpSize = 1e-8;

        for( Size spanningForwards = 1; spanningForwards < nbRates; ++spanningForwards)
        {

            std::vector<Rate> bumpedForwards(forwards);

            Matrix cmsJacobian(nbRates,nbRates);

            for (Size i=0; i < nbRates; ++i)
                for (Size j=0; j < nbRates; ++j)
                {
                    bumpedForwards = forwards;
                    bumpedForwards[j]+= bumpSize;
                    lmmCurveState.setOnForwardRates(bumpedForwards);
                    Real upRate = lmmCurveState.cmSwapRate(i,spanningForwards);
                    bumpedForwards[j]-= 2.0*bumpSize;
                    lmmCurveState.setOnForwardRates(bumpedForwards);
                    Real downRate = lmmCurveState.cmSwapRate(i,spanningForwards);
                    Real deriv = (upRate-downRate)/(2.0*bumpSize);
                    cmsJacobian[i][j] = deriv;

                }

            Matrix modelJacobian(SwapForwardMappings::cmSwapForwardJacobian(lmmCurveState, spanningForwards));

            Real errorTolerance = 1e-5;


            for (Size i=0; i < nbRates; ++i)
                for (Size j=0; j < nbRates; ++j)
                    if( fabs(modelJacobian[i][j]-cmsJacobian[i][j]) > errorTolerance)
                    {
                        BOOST_TEST_MESSAGE(
                                           "rate " << i
                                           << ", sensitivity "  <<  j
                                           << ", formula value " << modelJacobian[i][j]
                                           << " bumping value " << cmsJacobian[i][j]
                                           <<  "\n");

                        BOOST_ERROR("test failed");

                    }
        }

    }
}


void SwapForwardMappingsTest::testForwardCoterminalMappings() {

    BOOST_TEST_MESSAGE("Testing forward-rate coterminal-swap mappings...");
    MarketModelData marketData;
    const std::vector<Time>& rateTimes = marketData.rateTimes();
    const std::vector<Rate>& forwards = marketData.forwards();
    const Size nbRates = marketData.nbRates();
    LMMCurveState lmmCurveState(rateTimes);
    lmmCurveState.setOnForwardRates(forwards);

    const Real longTermCorr=0.5;
    const Real beta = .2;
    Real strike = .03;
    MultiStepCoterminalSwaptions product
        = makeMultiStepCoterminalSwaptions(rateTimes, strike);

    const EvolutionDescription& evolution = product.evolution();
    const Size numberOfFactors = nbRates;
    Spread displacement = marketData.displacements().front();
    Matrix jacobian =
        SwapForwardMappings::coterminalSwapZedMatrix(
        lmmCurveState, displacement);

    Matrix correlations = exponentialCorrelations(evolution.rateTimes(),
        longTermCorr,
        beta);
    ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
        TimeHomogeneousForwardCorrelation(correlations,
        rateTimes));
    ext::shared_ptr<MarketModel> smmMarketModel(new
        FlatVol(marketData.volatilities(),
        corr,
        evolution,
        numberOfFactors,
        lmmCurveState.coterminalSwapRates(),
        marketData.displacements()));

    ext::shared_ptr<MarketModel>
        lmmMarketModel(new CotSwapToFwdAdapter(smmMarketModel));

    SobolBrownianGeneratorFactory generatorFactory(SobolBrownianGenerator::Diagonal);
    std::vector<Size> numeraires(nbRates,
        nbRates);
    ext::shared_ptr<MarketModelEvolver> evolver(new LogNormalFwdRatePc
        (lmmMarketModel, generatorFactory, numeraires));

    ext::shared_ptr<SequenceStatisticsInc> stats =
        simulate(marketData.discountFactors(), evolver, product);
    std::vector<Real> results = stats->mean();
    std::vector<Real> errors = stats->errorEstimate();

    const std::vector<DiscountFactor>& todaysDiscounts = marketData.discountFactors();
    const std::vector<Rate>& todaysCoterminalSwapRates = lmmCurveState.coterminalSwapRates();
    for (Size i=0; i<nbRates; ++i) {
        const Matrix& cotSwapsCovariance = smmMarketModel->totalCovariance(i);
        //Matrix cotSwapsCovariance= jacobian * forwardsCovariance * transpose(jacobian);
        //Time expiry = rateTimes[i];
        ext::shared_ptr<PlainVanillaPayoff> payoff(
            new PlainVanillaPayoff(Option::Call, strike+displacement));
        //const std::vector<Time>&  taus = lmmCurveState.rateTaus();
        Real expectedSwaption = BlackCalculator(payoff,
            todaysCoterminalSwapRates[i]+displacement,
            std::sqrt(cotSwapsCovariance[i][i]),
            lmmCurveState.coterminalSwapAnnuity(i,i) *
            todaysDiscounts[i]).value();
        if (fabs(expectedSwaption-results[i]) > 0.0001)
            BOOST_ERROR(
            "expected\t" << expectedSwaption <<
            "\tLMM\t" << results[i]
        << "\tstdev:\t" << errors[i] <<
            "\t" <<std::fabs(results[i]- expectedSwaption)/errors[i]);
    }
}

void SwapForwardMappingsTest::testSwaptionImpliedVolatility() 
{

    BOOST_TEST_MESSAGE("Testing implied swaption vol in LMM using HW approximation...");
    MarketModelData marketData;
    const std::vector<Time>& rateTimes = marketData.rateTimes();
    const std::vector<Rate>& forwards = marketData.forwards();
    const Size nbRates = marketData.nbRates();
    LMMCurveState lmmCurveState(rateTimes);
    lmmCurveState.setOnForwardRates(forwards);

    const Real longTermCorr=0.5;
    const Real beta = .2;
    Real strike = .03;

    for (Size startIndex = 1; startIndex+2 < nbRates; startIndex = startIndex+5)
    {
        
        Size endIndex = nbRates-2;

        ext::shared_ptr<StrikedTypePayoff> payoff(new   
            PlainVanillaPayoff(Option::Call, strike));
        MultiStepSwaption product(rateTimes, startIndex, endIndex,payoff );

        const EvolutionDescription& evolution = product.evolution();
        const Size numberOfFactors = nbRates;
        Spread displacement = marketData.displacements().front();
        Matrix jacobian =
            SwapForwardMappings::coterminalSwapZedMatrix(
            lmmCurveState, displacement);

        Matrix correlations = exponentialCorrelations(evolution.rateTimes(),
            longTermCorr,
            beta);
        ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
            TimeHomogeneousForwardCorrelation(correlations,
            rateTimes));
        ext::shared_ptr<MarketModel> lmmMarketModel(new
            FlatVol(marketData.volatilities(),
            corr,
            evolution,
            numberOfFactors,
            lmmCurveState.forwardRates(),
            marketData.displacements()));


        SobolBrownianGeneratorFactory generatorFactory(SobolBrownianGenerator::Diagonal);
        std::vector<Size> numeraires(nbRates,
            nbRates);
        ext::shared_ptr<MarketModelEvolver> evolver(new LogNormalFwdRatePc
            (lmmMarketModel, generatorFactory, numeraires));

        ext::shared_ptr<SequenceStatisticsInc> stats =
            simulate(marketData.discountFactors(), evolver, product);
        std::vector<Real> results = stats->mean();
        std::vector<Real> errors = stats->errorEstimate();


        Real estimatedImpliedVol = SwapForwardMappings::swaptionImpliedVolatility(*lmmMarketModel,startIndex,endIndex);

        Real swapRate = lmmCurveState.cmSwapRate(startIndex,endIndex-startIndex);
        Real swapAnnuity = lmmCurveState.cmSwapAnnuity(startIndex,startIndex,endIndex-startIndex)*marketData.discountFactors()[startIndex];

        ext::shared_ptr<PlainVanillaPayoff> payoffDis( new PlainVanillaPayoff(Option::Call, strike+displacement));

        Real expectedSwaption = BlackCalculator(payoffDis,
            swapRate+displacement, estimatedImpliedVol *sqrt(rateTimes[startIndex]),
            swapAnnuity).value();

        Real error = expectedSwaption - results[0];
        Real errorInSds = error/errors[0];
        if (fabs(errorInSds) > 3.5 )
            BOOST_ERROR(
            "expected\t" << expectedSwaption <<
            "\tLMM\t" << results[0]
        << "\tstdev:\t" << errors[0] <<
            "\t" <<errorInSds);
    }

}



test_suite* SwapForwardMappingsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("swap-forward mappings tests");

    suite->add(QUANTLIB_TEST_CASE(
        &SwapForwardMappingsTest::testSwaptionImpliedVolatility));

    suite->add(QUANTLIB_TEST_CASE(
        &SwapForwardMappingsTest::testForwardSwapJacobians));
    // suite->add(QUANTLIB_TEST_CASE(
    //     &SwapForwardMappingsTest::testForwardCoterminalMappings));
    return suite;
}

]]></document_content>
  </document>
  <document index="268">
    <source>swapforwardmappings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swaps_forward_mappings_hpp
#define quantlib_test_swaps_forward_mappings_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SwapForwardMappingsTest {
  public:
      
    static void testSwaptionImpliedVolatility();
    static void testForwardSwapJacobians();
    static void testForwardCoterminalMappings();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="269">
    <source>swaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2007, 2008 StatPro Italia srl
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "swaption.hpp"
#include "utilities.hpp"
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/schedule.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace swaption_test {

    Period exercises[] = { 1*Years, 2*Years, 3*Years,
                           5*Years, 7*Years, 10*Years };
    Period lengths[] = { 1*Years, 2*Years, 3*Years,
                         5*Years, 7*Years, 10*Years,
                         15*Years, 20*Years };
    Swap::Type type[] = { Swap::Receiver, Swap::Payer };

    struct CommonVars {
        // global data
        Date today, settlement;
        Real nominal;
        Calendar calendar;

        BusinessDayConvention fixedConvention;
        Frequency fixedFrequency;
        DayCounter fixedDayCount;

        BusinessDayConvention floatingConvention;
        Period floatingTenor;
        ext::shared_ptr<IborIndex> index;

        Natural settlementDays;
        RelinkableHandle<YieldTermStructure> termStructure;

        // cleanup
        SavedSettings backup;

        // utilities
        ext::shared_ptr<Swaption> makeSwaption(
            const ext::shared_ptr<VanillaSwap>& swap,
            const Date& exercise,
            Volatility volatility,
            Settlement::Type settlementType = Settlement::Physical,
            Settlement::Method settlementMethod = Settlement::PhysicalOTC,
            BlackSwaptionEngine::CashAnnuityModel model = BlackSwaptionEngine::SwapRate) const {
            Handle<Quote> vol(ext::shared_ptr<Quote>(
                                                new SimpleQuote(volatility)));
            ext::shared_ptr<PricingEngine> engine(new BlackSwaptionEngine(
                termStructure, vol, Actual365Fixed(), 0.0, model));

            ext::shared_ptr<Swaption> result(new
                Swaption(swap,
                         ext::shared_ptr<Exercise>(
                                              new EuropeanExercise(exercise)),
                         settlementType, settlementMethod));
            result->setPricingEngine(engine);
            return result;
        }

        ext::shared_ptr<PricingEngine> makeEngine(
            Volatility volatility,
            BlackSwaptionEngine::CashAnnuityModel model = BlackSwaptionEngine::SwapRate) const {
            Handle<Quote> h(ext::shared_ptr<Quote>(new SimpleQuote(volatility)));
            return ext::shared_ptr<PricingEngine>(
                new BlackSwaptionEngine(termStructure, h, Actual365Fixed(), 0.0, model));
        }

        CommonVars() {
            settlementDays = 2;
            nominal = 1000000.0;
            fixedConvention = Unadjusted;
            fixedFrequency = Annual;
            fixedDayCount = Thirty360(Thirty360::BondBasis);

            index = ext::shared_ptr<IborIndex>(new Euribor6M(termStructure));
            floatingConvention = index->businessDayConvention();
            floatingTenor = index->tenor();
            calendar = index->fixingCalendar();
            today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today,settlementDays,Days);
            termStructure.linkTo(flatRate(settlement,0.05,Actual365Fixed()));
        }
    };

}


void SwaptionTest::testStrikeDependency() {

    BOOST_TEST_MESSAGE("Testing swaption dependency on strike...");

    using namespace swaption_test;

    CommonVars vars;

    Rate strikes[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };

    for (auto& exercise : exercises) {
        for (auto& length : lengths) {
            for (auto& k : type) {
                Date exerciseDate = vars.calendar.advance(vars.today, exercise);
                Date startDate =
                    vars.calendar.advance(exerciseDate,
                                          vars.settlementDays,Days);
                // store the results for different rates...
                std::vector<Real> values;
                std::vector<Real> values_cash;
                Volatility vol = 0.20;
                for (double strike : strikes) {
                    ext::shared_ptr<VanillaSwap> swap =
                        MakeVanillaSwap(length, vars.index, strike)
                            .withEffectiveDate(startDate)
                            .withFixedLegTenor(1 * Years)
                            .withFixedLegDayCount(vars.fixedDayCount)
                            .withFloatingLegSpread(0.0)
                            .withType(k);
                    ext::shared_ptr<Swaption> swaption =
                        vars.makeSwaption(swap,exerciseDate,vol);
                    // FLOATING_POINT_EXCEPTION
                    values.push_back(swaption->NPV());
                    ext::shared_ptr<Swaption> swaption_cash =
                        vars.makeSwaption(swap,exerciseDate,vol,
                                          Settlement::Cash, Settlement::ParYieldCurve);
                    values_cash.push_back(swaption_cash->NPV());
                }
                // and check that they go the right way
                if (k == Swap::Payer) {
                    auto it = std::adjacent_find(values.begin(), values.end(), std::less<Real>());
                    if (it != values.end()) {
                        Size n = it - values.begin();
                        BOOST_ERROR("NPV of Payer swaption with delivery settlement"
                                    "is increasing with the strike:"
                                    << "\noption tenor: " << exercise << "\noption date:  "
                                    << exerciseDate << "\nvolatility:   " << io::rate(vol)
                                    << "\nswap tenor:   " << length << "\nvalue:        "
                                    << values[n] << " at strike: " << io::rate(strikes[n])
                                    << "\nvalue:        " << values[n + 1]
                                    << " at strike: " << io::rate(strikes[n + 1]));
                    }
                    auto it_cash = std::adjacent_find(values_cash.begin(), values_cash.end(),
                                                      std::less<Real>());
                    if (it_cash != values_cash.end()) {
                        Size n = it_cash - values_cash.begin();
                        BOOST_ERROR("NPV of Payer swaption with cash settlement"
                                    "is increasing with the strike:"
                                    << "\noption tenor: " << exercise << "\noption date:  "
                                    << exerciseDate << "\nvolatility:   " << io::rate(vol)
                                    << "\nswap tenor:   " << length << "\nvalue:        "
                                    << values_cash[n] << " at strike: " << io::rate(strikes[n])
                                    << "\nvalue:        " << values_cash[n + 1]
                                    << " at strike: " << io::rate(strikes[n + 1]));
                    }
                } else {
                    auto it =
                        std::adjacent_find(values.begin(), values.end(), std::greater<Real>());
                    if (it != values.end()) {
                        Size n = it - values.begin();
                        BOOST_ERROR("NPV of Receiver swaption with delivery settlement"
                                    "is increasing with the strike:"
                                    << "\noption tenor: " << exercise << "\noption date:  "
                                    << exerciseDate << "\nvolatility:   " << io::rate(vol)
                                    << "\nswap tenor:   " << length << "\nvalue:        "
                                    << values[n] << " at strike: " << io::rate(strikes[n])
                                    << "\nvalue:        " << values[n + 1]
                                    << " at strike: " << io::rate(strikes[n + 1]));
                    }
                    auto it_cash = std::adjacent_find(values_cash.begin(), values_cash.end(),
                                                      std::greater<Real>());
                    if (it_cash != values_cash.end()) {
                        Size n = it_cash - values_cash.begin();
                        BOOST_ERROR("NPV of Receiver swaption with cash settlement"
                                    "is increasing with the strike:"
                                    << "\noption tenor: " << exercise << "\noption date:  "
                                    << exerciseDate << "\nvolatility:   " << io::rate(vol)
                                    << "\nswap tenor:   " << length << "\nvalue:        "
                                    << values_cash[n] << " at strike: " << io::rate(strikes[n])
                                    << "\nvalue:        " << values_cash[n + 1]
                                    << " at strike: " << io::rate(strikes[n + 1]));
                    }
                }
            }
        }
    }
}

void SwaptionTest::testSpreadDependency() {

    BOOST_TEST_MESSAGE("Testing swaption dependency on spread...");

    using namespace swaption_test;

    CommonVars vars;

    Spread spreads[] = { -0.002, -0.001, 0.0, 0.001, 0.002 };

    for (auto exercise : exercises) {
        for (auto& length : lengths) {
            for (auto& k : type) {
                Date exerciseDate = vars.calendar.advance(vars.today, exercise);
                Date startDate =
                    vars.calendar.advance(exerciseDate,
                                          vars.settlementDays,Days);
                // store the results for different rates...
                std::vector<Real> values;
                std::vector<Real> values_cash;
                for (double spread : spreads) {
                    ext::shared_ptr<VanillaSwap> swap =
                        MakeVanillaSwap(length, vars.index, 0.06)
                            .withFixedLegTenor(1 * Years)
                            .withFixedLegDayCount(vars.fixedDayCount)
                            .withEffectiveDate(startDate)
                            .withFloatingLegSpread(spread)
                            .withType(k);
                    ext::shared_ptr<Swaption> swaption =
                        vars.makeSwaption(swap,exerciseDate,0.20);
                    // FLOATING_POINT_EXCEPTION
                    values.push_back(swaption->NPV());
                    ext::shared_ptr<Swaption> swaption_cash =
                        vars.makeSwaption(swap,exerciseDate,0.20,
                                          Settlement::Cash, Settlement::ParYieldCurve);
                    values_cash.push_back(swaption_cash->NPV());
                }
                // and check that they go the right way
                if (k == Swap::Payer) {
                    auto it =
                        std::adjacent_find(values.begin(), values.end(), std::greater<Real>());
                    if (it != values.end()) {
                        Size n = it - values.begin();
                        BOOST_ERROR("NPV is decreasing with the spread "
                                    << "in a payer swaption (physical delivered):"
                                    << "\nexercise date: " << exerciseDate << "\nlength:        "
                                    << length << "\nvalue:         " << values[n] << " for spread: "
                                    << io::rate(spreads[n]) << "\nvalue:         " << values[n + 1]
                                    << " for spread: " << io::rate(spreads[n + 1]));
                    }
                    auto it_cash = std::adjacent_find(values_cash.begin(), values_cash.end(),
                                                      std::greater<Real>());
                    if (it_cash != values_cash.end()) {
                        Size n = it_cash - values_cash.begin();
                        BOOST_ERROR("NPV is decreasing with the spread "
                                    << "in a payer swaption (cash delivered):"
                                    << "\nexercise date: " << exerciseDate << "\nlength: " << length
                                    << "\nvalue:  " << values_cash[n] << " for spread: "
                                    << io::rate(spreads[n]) << "\nvalue:  " << values_cash[n + 1]
                                    << " for spread: " << io::rate(spreads[n + 1]));
                    }
                } else {
                    auto it = std::adjacent_find(values.begin(), values.end(), std::less<Real>());
                    if (it != values.end()) {
                        Size n = it - values.begin();
                        BOOST_ERROR("NPV is increasing with the spread "
                                    << "in a receiver swaption (physical delivered):"
                                       "\nexercise date: "
                                    << exerciseDate << "\nlength: " << length << "\nvalue:  "
                                    << values[n] << " for spread: " << io::rate(spreads[n])
                                    << "\nvalue:  " << values[n + 1]
                                    << " for spread: " << io::rate(spreads[n + 1]));
                    }
                    auto it_cash = std::adjacent_find(values_cash.begin(), values_cash.end(),
                                                      std::less<Real>());
                    if (it_cash != values_cash.end()) {
                        Size n = it_cash - values_cash.begin();
                        BOOST_ERROR("NPV is increasing with the spread "
                                    << "in a receiver swaption (cash delivered):"
                                       "\nexercise date: "
                                    << exerciseDate << "\nlength: " << length << "\nvalue:  "
                                    << values_cash[n] << " for spread: " << io::rate(spreads[n])
                                    << "\nvalue:  " << values_cash[n + 1]
                                    << " for spread: " << io::rate(spreads[n + 1]));
                    }
                }
            }
        }
    }
}

void SwaptionTest::testSpreadTreatment() {

    BOOST_TEST_MESSAGE("Testing swaption treatment of spread...");

    using namespace swaption_test;

    CommonVars vars;

    Spread spreads[] = { -0.002, -0.001, 0.0, 0.001, 0.002 };

    for (auto exercise : exercises) {
        for (auto& length : lengths) {
            for (auto& k : type) {
                Date exerciseDate = vars.calendar.advance(vars.today, exercise);
                Date startDate =
                    vars.calendar.advance(exerciseDate,
                                          vars.settlementDays,Days);
                for (double spread : spreads) {
                    ext::shared_ptr<VanillaSwap> swap =
                        MakeVanillaSwap(length, vars.index, 0.06)
                            .withFixedLegTenor(1 * Years)
                            .withFixedLegDayCount(vars.fixedDayCount)
                            .withEffectiveDate(startDate)
                            .withFloatingLegSpread(spread)
                            .withType(k);
                    // FLOATING_POINT_EXCEPTION
                    Spread correction = spread * swap->floatingLegBPS() / swap->fixedLegBPS();
                    ext::shared_ptr<VanillaSwap> equivalentSwap =
                        MakeVanillaSwap(length, vars.index, 0.06 + correction)
                            .withFixedLegTenor(1 * Years)
                            .withFixedLegDayCount(vars.fixedDayCount)
                            .withEffectiveDate(startDate)
                            .withFloatingLegSpread(0.0)
                            .withType(k);
                    ext::shared_ptr<Swaption> swaption1 =
                        vars.makeSwaption(swap,exerciseDate,0.20);
                    ext::shared_ptr<Swaption> swaption2 =
                        vars.makeSwaption(equivalentSwap,exerciseDate,0.20);
                    ext::shared_ptr<Swaption> swaption1_cash =
                        vars.makeSwaption(swap,exerciseDate,0.20,
                                          Settlement::Cash, Settlement::ParYieldCurve);
                    ext::shared_ptr<Swaption> swaption2_cash =
                        vars.makeSwaption(equivalentSwap,exerciseDate,0.20,
                                          Settlement::Cash, Settlement::ParYieldCurve);
                    if (std::fabs(swaption1->NPV()-swaption2->NPV()) > 1.0e-6)
                        BOOST_ERROR("wrong spread treatment:"
                                    << "\nexercise: " << exerciseDate << "\nlength:   " << length
                                    << "\ntype      " << k << "\nspread:   " << io::rate(spread)
                                    << "\noriginal swaption value:   " << swaption1->NPV()
                                    << "\nequivalent swaption value: " << swaption2->NPV());

                    if (std::fabs(swaption1_cash->NPV()-swaption2_cash->NPV()) > 1.0e-6)
                        BOOST_ERROR("wrong spread treatment:"
                                    << "\nexercise date: " << exerciseDate << "\nlength: " << length
                                    << "\npay " << (k ? "fixed" : "floating")
                                    << "\nspread: " << io::rate(spread)
                                    << "\nvalue of original swaption:   " << swaption1_cash->NPV()
                                    << "\nvalue of equivalent swaption: " << swaption2_cash->NPV());
                }
            }
        }
    }
}

void SwaptionTest::testCachedValue() {

    BOOST_TEST_MESSAGE("Testing swaption value against cached value...");

    using namespace swaption_test;

    CommonVars vars;

    vars.today = Date(13, March, 2002);
    vars.settlement = Date(15, March, 2002);
    Settings::instance().evaluationDate() = vars.today;
    vars.termStructure.linkTo(flatRate(vars.settlement, 0.05, Actual365Fixed()));
    Date exerciseDate = vars.calendar.advance(vars.settlement, 5*Years);
    Date startDate = vars.calendar.advance(exerciseDate,
                                           vars.settlementDays, Days);
    ext::shared_ptr<VanillaSwap> swap =
        MakeVanillaSwap(10*Years, vars.index, 0.06)
        .withEffectiveDate(startDate)
        .withFixedLegTenor(1*Years)
        .withFixedLegDayCount(vars.fixedDayCount);

    ext::shared_ptr<Swaption> swaption =
        vars.makeSwaption(swap, exerciseDate, 0.20);

    Real cachedNPV;
    if (IborCoupon::usingAtParCoupons())
        cachedNPV = 0.036418158579;
    else
        cachedNPV = 0.036421429684;

    // FLOATING_POINT_EXCEPTION
    if (std::fabs(swaption->NPV()-cachedNPV) > 1.0e-12)
        BOOST_ERROR("failed to reproduce cached swaption value:\n" <<
                    std::fixed << std::setprecision(12) <<
                    "\ncalculated: " << swaption->NPV() <<
                    "\nexpected:   " << cachedNPV);
}

void SwaptionTest::testVega() {

    BOOST_TEST_MESSAGE("Testing swaption vega...");

    using namespace swaption_test;

    CommonVars vars;

    Settlement::Type types[] = { Settlement::Physical, Settlement::Cash };
    Settlement::Method methods[] = { Settlement::PhysicalOTC, Settlement::ParYieldCurve };
    Rate strikes[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.01, 0.20, 0.30, 0.70, 0.90 };
    Volatility shift = 1e-8;
    for (auto& exercise : exercises) {
        Date exerciseDate = vars.calendar.advance(vars.today, exercise);
        Date startDate = vars.calendar.advance(exerciseDate,
                                           vars.settlementDays*Days);
        for (auto& length : lengths) {
            for (double strike : strikes) {
                for (Size h=0; h<LENGTH(type); h++) {
                    ext::shared_ptr<VanillaSwap> swap =
                        MakeVanillaSwap(length, vars.index, strike)
                            .withEffectiveDate(startDate)
                            .withFixedLegTenor(1 * Years)
                            .withFixedLegDayCount(vars.fixedDayCount)
                            .withFloatingLegSpread(0.0)
                            .withType(type[h]);
                    for (double vol : vols) {
                        ext::shared_ptr<Swaption> swaption =
                            vars.makeSwaption(swap, exerciseDate, vol, types[h], methods[h]);
                        // FLOATING_POINT_EXCEPTION
                        ext::shared_ptr<Swaption> swaption1 = vars.makeSwaption(
                            swap, exerciseDate, vol - shift, types[h], methods[h]);
                        ext::shared_ptr<Swaption> swaption2 = vars.makeSwaption(
                            swap, exerciseDate, vol + shift, types[h], methods[h]);

                        Real swaptionNPV = swaption->NPV();
                        Real numericalVegaPerPoint =
                            (swaption2->NPV()-swaption1->NPV())/(200.0*shift);
                        // check only relevant vega
                        if (numericalVegaPerPoint/swaptionNPV>1.0e-7) {
                            Real analyticalVegaPerPoint =
                                swaption->result<Real>("vega")/100.0;
                            Real discrepancy = std::fabs(analyticalVegaPerPoint
                                - numericalVegaPerPoint);
                            discrepancy /= numericalVegaPerPoint;
                            Real tolerance = 0.015;
                            if (discrepancy > tolerance)
                                BOOST_FAIL("failed to compute swaption vega:"
                                           << "\n  option tenor:    " << exercise
                                           << "\n  volatility:      " << io::rate(vol)
                                           << "\n  option type:     " << swaption->type()
                                           << "\n  swap tenor:      " << length
                                           << "\n  strike:          " << io::rate(strike)
                                           << "\n  settlement:      " << types[h]
                                           << "\n  nominal:         "
                                           << swaption->underlyingSwap()->nominal()
                                           << "\n  npv:             " << swaptionNPV
                                           << "\n  calculated vega: " << analyticalVegaPerPoint
                                           << "\n  expected vega:   " << numericalVegaPerPoint
                                           << "\n  discrepancy:     " << io::rate(discrepancy)
                                           << "\n  tolerance:       " << io::rate(tolerance));
                        }
                    }
                }
            }
        }
    }
}



void SwaptionTest::testCashSettledSwaptions() {

    BOOST_TEST_MESSAGE("Testing cash settled swaptions modified annuity...");

    using namespace swaption_test;

    CommonVars vars;

    Rate strike = 0.05;

    for (auto exercise : exercises) {
        for (auto length : lengths) {

            Date exerciseDate = vars.calendar.advance(vars.today, exercise);
            Date startDate = vars.calendar.advance(exerciseDate,
                                                   vars.settlementDays,Days);
            Date maturity = vars.calendar.advance(startDate, length, vars.floatingConvention);
            Schedule floatSchedule(startDate, maturity, vars.floatingTenor,
                                   vars.calendar,vars.floatingConvention,
                                   vars.floatingConvention,
                                   DateGeneration::Forward, false);
            // Swap with fixed leg conventions: Business Days = Unadjusted, DayCount = 30/360
            Schedule fixedSchedule_u(startDate, maturity,
                                     Period(vars.fixedFrequency),
                                     vars.calendar, Unadjusted, Unadjusted,
                                     DateGeneration::Forward, true);
            ext::shared_ptr<VanillaSwap> swap_u360(
                new VanillaSwap(type[0], vars.nominal,
                                fixedSchedule_u,strike,Thirty360(Thirty360::BondBasis),
                                floatSchedule,vars.index,0.0,
                                vars.index->dayCounter()));

            // Swap with fixed leg conventions: Business Days = Unadjusted, DayCount = Act/365
            ext::shared_ptr<VanillaSwap> swap_u365(
                new VanillaSwap(type[0],vars.nominal,
                                fixedSchedule_u,strike,Actual365Fixed(),
                                floatSchedule,vars.index,0.0,
                                vars.index->dayCounter()));

            // Swap with fixed leg conventions: Business Days = Modified Following, DayCount = 30/360
            Schedule fixedSchedule_a(startDate,maturity,
                                     Period(vars.fixedFrequency),
                                     vars.calendar,ModifiedFollowing,
                                     ModifiedFollowing,
                                     DateGeneration::Forward, true);
            ext::shared_ptr<VanillaSwap> swap_a360(
                new VanillaSwap(type[0],vars.nominal,
                                fixedSchedule_a,strike,Thirty360(Thirty360::BondBasis),
                                floatSchedule,vars.index,0.0,
                                vars.index->dayCounter()));

            // Swap with fixed leg conventions: Business Days = Modified Following, DayCount = Act/365
            ext::shared_ptr<VanillaSwap> swap_a365(
                new VanillaSwap(type[0],vars.nominal,
                                fixedSchedule_a,strike,Actual365Fixed(),
                                floatSchedule,vars.index,0.0,
                                vars.index->dayCounter()));

            ext::shared_ptr<PricingEngine> swapEngine(
                               new DiscountingSwapEngine(vars.termStructure));

            swap_u360->setPricingEngine(swapEngine);
            swap_a360->setPricingEngine(swapEngine);
            swap_u365->setPricingEngine(swapEngine);
            swap_a365->setPricingEngine(swapEngine);

            const Leg& swapFixedLeg_u360 = swap_u360->fixedLeg();
            const Leg& swapFixedLeg_a360 = swap_a360->fixedLeg();
            const Leg& swapFixedLeg_u365 = swap_u365->fixedLeg();
            const Leg& swapFixedLeg_a365 = swap_a365->fixedLeg();

            // FlatForward curves
            // FLOATING_POINT_EXCEPTION
            Handle<YieldTermStructure> termStructure_u360(
                ext::shared_ptr<YieldTermStructure>(
                    new FlatForward(vars.settlement,swap_u360->fairRate(),
                                    Thirty360(Thirty360::BondBasis),Compounded,
                                    vars.fixedFrequency)));
            Handle<YieldTermStructure> termStructure_a360(
                ext::shared_ptr<YieldTermStructure>(
                    new FlatForward(vars.settlement,swap_a360->fairRate(),
                                    Thirty360(Thirty360::BondBasis),Compounded,
                                    vars.fixedFrequency)));
            Handle<YieldTermStructure> termStructure_u365(
                ext::shared_ptr<YieldTermStructure>(
                    new FlatForward(vars.settlement,swap_u365->fairRate(),
                                    Actual365Fixed(),Compounded,
                                    vars.fixedFrequency)));
            Handle<YieldTermStructure> termStructure_a365(
                ext::shared_ptr<YieldTermStructure>(
                    new FlatForward(vars.settlement,swap_a365->fairRate(),
                                    Actual365Fixed(),Compounded,
                                    vars.fixedFrequency)));

            // Annuity calculated by swap method fixedLegBPS().
            // Fixed leg conventions: Unadjusted, 30/360
            Real annuity_u360 = swap_u360->fixedLegBPS() / 0.0001;
            annuity_u360 = swap_u360->type()==Swap::Payer ?
                -annuity_u360 : annuity_u360;
            // Fixed leg conventions: ModifiedFollowing, act/365
            Real annuity_a365 = swap_a365->fixedLegBPS() / 0.0001;
            annuity_a365 = swap_a365->type()==Swap::Payer ?
                -annuity_a365 : annuity_a365;
            // Fixed leg conventions: ModifiedFollowing, 30/360
            Real annuity_a360 = swap_a360->fixedLegBPS() / 0.0001;
            annuity_a360 = swap_a360->type()==Swap::Payer ?
                -annuity_a360 : annuity_a360;
            // Fixed leg conventions: Unadjusted, act/365
            Real annuity_u365 = swap_u365->fixedLegBPS() / 0.0001;
            annuity_u365 = swap_u365->type()==Swap::Payer ?
                -annuity_u365 : annuity_u365;

            // Calculation of Modified Annuity (cash settlement)
            // Fixed leg conventions of swap: unadjusted, 30/360
            Real cashannuity_u360 = 0.;
            Size i;
            for (i=0; i<swapFixedLeg_u360.size(); i++) {
                cashannuity_u360 += swapFixedLeg_u360[i]->amount()/strike
                                  * termStructure_u360->discount(
                                    swapFixedLeg_u360[i]->date());
            }
            // Fixed leg conventions of swap: unadjusted, act/365
            Real cashannuity_u365 = 0.;
            for (i=0; i<swapFixedLeg_u365.size(); i++) {
                cashannuity_u365 += swapFixedLeg_u365[i]->amount()/strike
                                  * termStructure_u365->discount(
                                    swapFixedLeg_u365[i]->date());
            }
            // Fixed leg conventions of swap: modified following, 30/360
            Real cashannuity_a360 = 0.;
            for (i=0; i<swapFixedLeg_a360.size(); i++) {
                cashannuity_a360 += swapFixedLeg_a360[i]->amount()/strike
                                  * termStructure_a360->discount(
                                    swapFixedLeg_a360[i]->date());
            }
            // Fixed leg conventions of swap: modified following, act/365
            Real cashannuity_a365 = 0.;
            for (i=0; i<swapFixedLeg_a365.size(); i++) {
                cashannuity_a365 += swapFixedLeg_a365[i]->amount()/strike
                                  * termStructure_a365->discount(
                                    swapFixedLeg_a365[i]->date());
            }

            // Swaptions: underlying swap fixed leg conventions:
            // unadjusted, 30/360

            // Physical settled swaption
            ext::shared_ptr<Swaption> swaption_p_u360 =
                vars.makeSwaption(swap_u360,exerciseDate,0.20);
            Real value_p_u360 = swaption_p_u360->NPV();
            // Cash settled swaption
            ext::shared_ptr<Swaption> swaption_c_u360 =
                vars.makeSwaption(swap_u360,exerciseDate,0.20,
                                  Settlement::Cash, Settlement::ParYieldCurve);
            Real value_c_u360 = swaption_c_u360->NPV();
            // the NPV's ratio must be equal to annuities ratio
            Real npv_ratio_u360 = value_c_u360 / value_p_u360;
            Real annuity_ratio_u360 = cashannuity_u360 / annuity_u360;

            // Swaptions: underlying swap fixed leg conventions:
            // modified following, act/365

            // Physical settled swaption
            ext::shared_ptr<Swaption> swaption_p_a365 =
                vars.makeSwaption(swap_a365,exerciseDate,0.20);
            Real value_p_a365 = swaption_p_a365->NPV();
            // Cash settled swaption
            ext::shared_ptr<Swaption> swaption_c_a365 =
                vars.makeSwaption(swap_a365,exerciseDate,0.20,
                                  Settlement::Cash, Settlement::ParYieldCurve);
            Real value_c_a365 = swaption_c_a365->NPV();
            // the NPV's ratio must be equal to annuities ratio
            Real npv_ratio_a365 = value_c_a365 / value_p_a365;
            Real annuity_ratio_a365 =  cashannuity_a365 / annuity_a365;

            // Swaptions: underlying swap fixed leg conventions:
            // modified following, 30/360

            // Physical settled swaption
            ext::shared_ptr<Swaption> swaption_p_a360 =
                vars.makeSwaption(swap_a360,exerciseDate,0.20);
            Real value_p_a360 = swaption_p_a360->NPV();
            // Cash settled swaption
            ext::shared_ptr<Swaption> swaption_c_a360 =
                vars.makeSwaption(swap_a360,exerciseDate,0.20,
                                  Settlement::Cash, Settlement::ParYieldCurve);
            Real value_c_a360 = swaption_c_a360->NPV();
            // the NPV's ratio must be equal to annuities ratio
            Real npv_ratio_a360 = value_c_a360 / value_p_a360;
            Real annuity_ratio_a360 =  cashannuity_a360 / annuity_a360;

            // Swaptions: underlying swap fixed leg conventions:
            // unadjusted, act/365

            // Physical settled swaption
            ext::shared_ptr<Swaption> swaption_p_u365 =
                vars.makeSwaption(swap_u365,exerciseDate,0.20);
            Real value_p_u365 = swaption_p_u365->NPV();
            // Cash settled swaption
            ext::shared_ptr<Swaption> swaption_c_u365 =
                vars.makeSwaption(swap_u365,exerciseDate,0.20,
                                  Settlement::Cash, Settlement::ParYieldCurve);
            Real value_c_u365 = swaption_c_u365->NPV();
            // the NPV's ratio must be equal to annuities ratio
            Real npv_ratio_u365 = value_c_u365 / value_p_u365;
            Real annuity_ratio_u365 =  cashannuity_u365 / annuity_u365;

            if (std::fabs(annuity_ratio_u360-npv_ratio_u360)>1e-10 ) {
                BOOST_ERROR("\n"
                            << "    The npv's ratio must be equal to "
                            << " annuities ratio"
                            << "\n"
                               "    Swaption "
                            << exercises[i].units() << "y x " << length.units() << "y"
                            << " (underlying swap fixed leg Unadjusted, 30/360)"
                            << "\n"
                            << "    Today           : " << vars.today << "\n"
                            << "    Settlement date : " << vars.settlement << "\n"
                            << "    Exercise date   : " << exerciseDate << "\n"
                            << "    Swap start date : " << startDate << "\n"
                            << "    Swap end date   : " << maturity << "\n"
                            << "    physical delivered swaption npv : " << value_p_u360 << "\t\t\t"
                            << "    annuity : " << annuity_u360 << "\n"
                            << "    cash delivered swaption npv :     " << value_c_u360 << "\t\t\t"
                            << "    annuity : " << cashannuity_u360 << "\n"
                            << "    npv ratio : " << npv_ratio_u360 << "\n"
                            << "    annuity ratio : " << annuity_ratio_u360 << "\n"
                            << "    difference : " << (annuity_ratio_u360 - npv_ratio_u360));
            }
            if (std::fabs(annuity_ratio_a365-npv_ratio_a365)>1e-10) {
                BOOST_ERROR("\n"
                            << "    The npv's ratio must be equal to "
                            << " annuities ratio"
                            << "\n"
                               "    Swaption "
                            << exercises[i].units() << "y x " << length.units() << "y"
                            << " (underlying swap fixed leg Modified Following, act/365"
                            << "\n"
                            << "    Today           : " << vars.today << "\n"
                            << "    Settlement date : " << vars.settlement << "\n"
                            << "    Exercise date   : " << exerciseDate << "\n"
                            << "    Swap start date : " << startDate << "\n"
                            << "    Swap end date   : " << maturity << "\n"
                            << "    physical delivered swaption npv : " << value_p_a365 << "\t\t\t"
                            << "    annuity : " << annuity_a365 << "\n"
                            << "    cash delivered swaption npv :     " << value_c_a365 << "\t\t\t"
                            << "    annuity : " << cashannuity_a365 << "\n"
                            << "    npv ratio : " << npv_ratio_a365 << "\n"
                            << "    annuity ratio : " << annuity_ratio_a365 << "\n"
                            << "    difference : " << (annuity_ratio_a365 - npv_ratio_a365));
                }
            if (std::fabs(annuity_ratio_a360-npv_ratio_a360)>1e-10) {
                BOOST_ERROR("\n"
                            << "    The npv's ratio must be equal to "
                            << " annuities ratio"
                            << "\n"
                               "    Swaption "
                            << exercises[i].units() << "y x " << length.units() << "y"
                            << " (underlying swap fixed leg Unadjusted, 30/360)"
                            << "\n"
                            << "    Today           : " << vars.today << "\n"
                            << "    Settlement date : " << vars.settlement << "\n"
                            << "    Exercise date   : " << exerciseDate << "\n"
                            << "    Swap start date : " << startDate << "\n"
                            << "    Swap end date   : " << maturity << "\n"
                            << "    physical delivered swaption npv : " << value_p_a360 << "\t\t\t"
                            << "    annuity : " << annuity_a360 << "\n"
                            << "    cash delivered swaption npv :     " << value_c_a360 << "\t\t\t"
                            << "    annuity : " << cashannuity_a360 << "\n"
                            << "    npv ratio : " << npv_ratio_a360 << "\n"
                            << "    annuity ratio : " << annuity_ratio_a360 << "\n"
                            << "    difference : " << (annuity_ratio_a360 - npv_ratio_a360));
            }
            if (std::fabs(annuity_ratio_u365-npv_ratio_u365)>1e-10) {
                BOOST_ERROR("\n"
                            << "    The npv's ratio must be equal to "
                            << " annuities ratio"
                            << "\n"
                               "    Swaption "
                            << exercises[i].units() << "y x " << length.units() << "y"
                            << " (underlying swap fixed leg Unadjusted, act/365)"
                            << "\n"
                            << "    Today           : " << vars.today << "\n"
                            << "    Settlement date : " << vars.settlement << "\n"
                            << "    Exercise date   : " << exerciseDate << "\n"
                            << "    Swap start date : " << startDate << "\n"
                            << "    Swap end date   : " << maturity << "\n"
                            << "    physical delivered swaption npv : " << value_p_u365 << "\t\t\t"
                            << "    annuity : " << annuity_u365 << "\n"
                            << "    cash delivered swaption npv :     " << value_c_u365 << "\t\t\t"
                            << "    annuity : " << cashannuity_u365 << "\n"
                            << "    npv ratio : " << npv_ratio_u365 << "\n"
                            << "    annuity ratio : " << annuity_ratio_u365 << "\n"
                            << "    difference : " << (annuity_ratio_u365 - npv_ratio_u365));
            }
        }
    }
}



void SwaptionTest::testImpliedVolatility() {

    BOOST_TEST_MESSAGE("Testing implied volatility for swaptions...");

    using namespace swaption_test;

    CommonVars vars;

    Size maxEvaluations = 100;
    Real tolerance = 1.0e-08;

    Settlement::Type types[] = { Settlement::Physical, Settlement::Cash };
    Settlement::Method methods[] = { Settlement::PhysicalOTC, Settlement::ParYieldCurve };
    // test data
    Rate strikes[] = { 0.02, 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.01, 0.05, 0.10, 0.20, 0.30, 0.70, 0.90 };

    for (auto& exercise : exercises) {
        for (auto& length : lengths) {
            Date exerciseDate = vars.calendar.advance(vars.today, exercise);
            Date startDate = vars.calendar.advance(exerciseDate,
                                                   vars.settlementDays, Days);

            for (double& strike : strikes) {
                for (auto& k : type) {
                    ext::shared_ptr<VanillaSwap> swap =
                        MakeVanillaSwap(length, vars.index, strike)
                            .withEffectiveDate(startDate)
                            .withFixedLegTenor(1 * Years)
                            .withFixedLegDayCount(vars.fixedDayCount)
                            .withFloatingLegSpread(0.0)
                            .withType(k);
                    for (Size h=0; h<LENGTH(types); h++) {
                        for (double vol : vols) {
                            ext::shared_ptr<Swaption> swaption =
                                vars.makeSwaption(swap, exerciseDate, vol, types[h], methods[h],
                                                  BlackSwaptionEngine::DiscountCurve);
                            // Black price
                            Real value = swaption->NPV();
                            Volatility implVol = 0.0;
                            try {
                                implVol =
                                  swaption->impliedVolatility(value,
                                                              vars.termStructure,
                                                              0.10,
                                                              tolerance,
                                                              maxEvaluations,
                                                              1.0e-7,
                                                              4.0,
                                                              ShiftedLognormal,
                                                              0.0);
                            } catch (std::exception& e) {
                                // couldn't bracket?
                                swaption->setPricingEngine(vars.makeEngine(0.0, BlackSwaptionEngine::DiscountCurve));
                                Real value2 = swaption->NPV();
                                if (std::fabs(value-value2) < tolerance) {
                                    // ok, just skip:
                                    continue;
                                }
                                // otherwise, report error
                                BOOST_ERROR("implied vol failure: "
                                            << exercise << "x" << length << " " << k
                                            << "\nsettlement: " << types[h] << "\nstrike      "
                                            << strike
                                            << "\natm level:  " << io::rate(swap->fairRate())
                                            << "\nvol:        " << io::volatility(vol)
                                            << "\nprice:      " << value << "\n"
                                            << e.what());
                            }
                            if (std::fabs(implVol - vol) > tolerance) {
                                // the difference might not matter
                                swaption->setPricingEngine(vars.makeEngine(implVol, BlackSwaptionEngine::DiscountCurve));
                                Real value2 = swaption->NPV();
                                if (std::fabs(value-value2) > tolerance) {
                                    BOOST_ERROR("implied vol failure: "
                                                << exercise << "x" << length << " " << k
                                                << "\nsettlement:    " << types[h]
                                                << "\nstrike         " << strike
                                                << "\natm level:     " << io::rate(swap->fairRate())
                                                << "\nvol:           " << io::volatility(vol)
                                                << "\nprice:         " << value
                                                << "\nimplied vol:   " << io::volatility(implVol)
                                                << "\nimplied price: " << value2);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

template <typename Engine>
ext::shared_ptr<Engine> makeConstVolEngine(
    const Handle<YieldTermStructure> &discountCurve,
    Volatility volatility)
{
    Handle<Quote> h(ext::make_shared<SimpleQuote>(volatility));
    return ext::make_shared<Engine>(discountCurve, h);
}

template <typename Engine>
void checkSwaptionDelta(bool useBachelierVol)
{
    using namespace swaption_test;

    CommonVars vars;
    Date today = vars.today;
    Calendar calendar = vars.calendar;

    const Real bump = 1.e-4;
    const Real epsilon = 1.e-10;
    
    RelinkableHandle<YieldTermStructure> projectionCurveHandle;
    
    const Real projectionRate = 0.01;
    RelinkableHandle<Quote> projectionQuoteHandle;

    ext::shared_ptr<YieldTermStructure> projectionCurve = ext::make_shared<FlatForward>(
        today, projectionQuoteHandle, Actual365Fixed());
    projectionCurveHandle.linkTo(projectionCurve);

    Handle<YieldTermStructure> discountHandle(ext::make_shared<FlatForward>(
            today, 
            Handle<Quote>(ext::make_shared<SimpleQuote>(0.0085)), 
            Actual365Fixed()));
    ext::shared_ptr<DiscountingSwapEngine> swapEngine = ext::make_shared<DiscountingSwapEngine>(
        discountHandle);
    
    ext::shared_ptr<IborIndex> idx = ext::make_shared<Euribor6M>(projectionCurveHandle);
    
    Settlement::Type types[] = { Settlement::Physical, Settlement::Cash };
    Settlement::Method methods[] = { Settlement::PhysicalOTC, Settlement::CollateralizedCashPrice};
    
    Rate strikes[] = { 0.03, 0.04, 0.05, 0.06, 0.07 };
    Volatility vols[] = { 0.0, 0.10, 0.20, 0.30, 0.70, 0.90 };

    for (double vol : vols) {
        for (auto exercise : exercises) {
            for (auto& length : lengths) {
                for (double& strike : strikes) {
                    for (Size h=0; h<LENGTH(type); h++) {
                        Volatility volatility = useBachelierVol ? vol / 100.0 : vol;
                        ext::shared_ptr<Engine> swaptionEngine = makeConstVolEngine<Engine>(
                            discountHandle, volatility);

                        Date exerciseDate = calendar.advance(today, exercise);
                        Date startDate = calendar.advance(exerciseDate, 2*Days);
                        projectionQuoteHandle.linkTo(ext::make_shared<SimpleQuote>(projectionRate));

                        ext::shared_ptr<VanillaSwap> underlying =
                            MakeVanillaSwap(length, idx, strike)
                                .withEffectiveDate(startDate)
                                .withFixedLegTenor(1 * Years)
                                .withFixedLegDayCount(Thirty360(Thirty360::BondBasis))
                                .withFloatingLegSpread(0.0)
                                .withType(type[h]);
                        underlying->setPricingEngine(swapEngine);
                        
                        Real fairRate = underlying->fairRate();

                        ext::shared_ptr<Swaption> swaption = ext::make_shared<Swaption>(
                            underlying, 
                            ext::make_shared<EuropeanExercise>(exerciseDate), 
                            types[h], 
                            methods[h]);
                        swaption->setPricingEngine(swaptionEngine);

                        Real value = swaption->NPV();
                        Real delta = swaption->result<Real>("delta") * bump;

                        projectionQuoteHandle.linkTo(ext::make_shared<SimpleQuote>(
                            projectionRate + bump));
    
                        Real bumpedFairRate = underlying->fairRate();
                        Real bumpedValue = swaption->NPV();
                        Real bumpedDelta = swaption->result<Real>("delta") * bump;

                        Real deltaBump = bumpedFairRate - fairRate;
                        Real approxDelta = (bumpedValue - value) / deltaBump * bump;
    
                        Real lowerBound = std::min(delta, bumpedDelta) - epsilon;
                        Real upperBound = std::max(delta, bumpedDelta) + epsilon;

                        /*! Based on the Mean Value Theorem, the below inequality
                            should hold for any function that is monotonic in the
                            area of the bump.
                        */
                        bool checkIsCorrect = (lowerBound < approxDelta) && (approxDelta < upperBound);
                        
                        if (!checkIsCorrect)
                            BOOST_FAIL(
                                "failed to compute swaption delta:"
                                << "\n  option tenor:     " << exerciseDate
                                << "\n  volatility:       " << io::rate(volatility)
                                << "\n  option type:      " << swaption->type()
                                << "\n  swap tenor:       " << length << "\n  strike:           "
                                << strike << "\n  settlement:       " << types[h]
                                << "\n  method:           " << methods[h]
                                << "\n  nominal:          " << swaption->underlyingSwap()->nominal()
                                << "\n  npv:              " << value << "\n  calculated delta: "
                                << delta << "\n  expected delta:   " << approxDelta);
                    }
                }
            }
        }
    }
}

void SwaptionTest::testSwaptionDeltaInBlackModel() {

    BOOST_TEST_MESSAGE("Testing swaption delta in Black model...");

    checkSwaptionDelta<BlackSwaptionEngine>(false);
}

void SwaptionTest::testSwaptionDeltaInBachelierModel() {

    BOOST_TEST_MESSAGE("Testing swaption delta in Bachelier model...");

    checkSwaptionDelta<BachelierSwaptionEngine>(true);
}

test_suite* SwaptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Swaption tests");

    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testCashSettledSwaptions));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testStrikeDependency));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testSpreadDependency));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testSpreadTreatment));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testCachedValue));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testVega));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testSwaptionDeltaInBlackModel));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testSwaptionDeltaInBachelierModel));   

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(&SwaptionTest::testImpliedVolatility));
    };

    return suite;
}
]]></document_content>
  </document>
  <document index="270">
    <source>swaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swaption_hpp
#define quantlib_test_swaption_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SwaptionTest {
  public:
    static void testStrikeDependency();
    static void testSpreadDependency();
    static void testSpreadTreatment();
    static void testCachedValue();
    static void testCashSettledSwaptions();
    static void testImpliedVolatility();
    static void testVega();
    static void testSwaptionDeltaInBlackModel();
    static void testSwaptionDeltaInBachelierModel();

    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="271">
    <source>swaptionvolatilitycube.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006, 2008 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "swaptionvolatilitycube.hpp"
#include "swaptionvolstructuresutilities.hpp"
#include "utilities.hpp"
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube2.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube1.hpp>
#include <ql/termstructures/volatility/swaption/spreadedswaptionvol.hpp>
#include <ql/termstructures/volatility/sabrsmilesection.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace swaption_volatility_cube_test {

    struct CommonVars {
        // global data
        SwaptionMarketConventions conventions;
        AtmVolatility atm;
        RelinkableHandle<SwaptionVolatilityStructure> atmVolMatrix;
        VolatilityCube cube;

        RelinkableHandle<YieldTermStructure> termStructure;

        ext::shared_ptr<SwapIndex> swapIndexBase, shortSwapIndexBase;
        bool vegaWeighedSmileFit;

        // cleanup
        SavedSettings backup;

        // utilities
        void makeAtmVolTest(const SwaptionVolatilityCube& volCube,
                            Real tolerance) {

            for (auto& option : atm.tenors.options) {
                for (auto& swap : atm.tenors.swaps) {
                    Rate strike = volCube.atmStrike(option, swap);
                    Volatility expVol = atmVolMatrix->volatility(option, swap, strike, true);
                    Volatility actVol = volCube.volatility(option, swap, strike, true);
                    Volatility error = std::abs(expVol - actVol);
                    if (error > tolerance)
                        BOOST_ERROR("\nrecovery of atm vols failed:"
                                    "\nexpiry time = "
                                    << option << "\nswap length = " << swap
                                    << "\n atm strike = " << io::rate(strike)
                                    << "\n   exp. vol = " << io::volatility(expVol)
                                    << "\n actual vol = " << io::volatility(actVol)
                                    << "\n      error = " << io::volatility(error)
                                    << "\n  tolerance = " << tolerance);
                }
            }
        }

        void makeVolSpreadsTest(const SwaptionVolatilityCube& volCube,
                                Real tolerance) {

            for (Size i=0; i<cube.tenors.options.size(); i++) {
              for (Size j=0; j<cube.tenors.swaps.size(); j++) {
                for (Size k=0; k<cube.strikeSpreads.size(); k++) {
                  Rate atmStrike = volCube.atmStrike(cube.tenors.options[i],
                                                     cube.tenors.swaps[j]);
                  Volatility atmVol =
                      atmVolMatrix->volatility(cube.tenors.options[i],
                                               cube.tenors.swaps[j],
                                               atmStrike, true);
                  Volatility vol =
                      volCube.volatility(cube.tenors.options[i],
                                         cube.tenors.swaps[j],
                                         atmStrike+cube.strikeSpreads[k], true);
                  Volatility spread = vol-atmVol;
                  Volatility expVolSpread =
                      cube.volSpreads[i*cube.tenors.swaps.size()+j][k];
                  Volatility error = std::abs(expVolSpread-spread);
                  if (error>tolerance)
                      BOOST_FAIL("\nrecovery of smile vol spreads failed:"
                                 "\n    option tenor = " << cube.tenors.options[i] <<
                                 "\n      swap tenor = " << cube.tenors.swaps[j] <<
                                 "\n      atm strike = " << io::rate(atmStrike) <<
                                 "\n   strike spread = " << io::rate(cube.strikeSpreads[k]) <<
                                 "\n         atm vol = " << io::volatility(atmVol) <<
                                 "\n      smiled vol = " << io::volatility(vol) <<
                                 "\n      vol spread = " << io::volatility(spread) <<
                                 "\n exp. vol spread = " << io::volatility(expVolSpread) <<
                                 "\n           error = " << io::volatility(error) <<
                                 "\n       tolerance = " << tolerance);
                }
              }
            }
        }

        CommonVars() {

            conventions.setConventions();

            // ATM swaptionvolmatrix
            atm.setMarketData();

            atmVolMatrix = RelinkableHandle<SwaptionVolatilityStructure>(
                ext::shared_ptr<SwaptionVolatilityStructure>(new
                    SwaptionVolatilityMatrix(conventions.calendar,
                                             conventions.optionBdc,
                                             atm.tenors.options,
                                             atm.tenors.swaps,
                                             atm.volsHandle,
                                             conventions.dayCounter)));
            // Swaptionvolcube
            cube.setMarketData();

            termStructure.linkTo(flatRate(0.05, Actual365Fixed()));

            swapIndexBase = ext::shared_ptr<SwapIndex>(new
                EuriborSwapIsdaFixA(2*Years, termStructure));
            shortSwapIndexBase = ext::shared_ptr<SwapIndex>(new
                EuriborSwapIsdaFixA(1*Years, termStructure));

            vegaWeighedSmileFit=false;
        }
    };

}


void SwaptionVolatilityCubeTest::testAtmVols() {

    BOOST_TEST_MESSAGE("Testing swaption volatility cube (atm vols)...");

    using namespace swaption_volatility_cube_test;

    CommonVars vars;

    SwaptionVolCube2 volCube(vars.atmVolMatrix,
                             vars.cube.tenors.options,
                             vars.cube.tenors.swaps,
                             vars.cube.strikeSpreads,
                             vars.cube.volSpreadsHandle,
                             vars.swapIndexBase,
                             vars.shortSwapIndexBase,
                             vars.vegaWeighedSmileFit);

    Real tolerance = 1.0e-16;
    vars.makeAtmVolTest(volCube, tolerance);
}

void SwaptionVolatilityCubeTest::testSmile() {

    BOOST_TEST_MESSAGE("Testing swaption volatility cube (smile)...");

    using namespace swaption_volatility_cube_test;

    CommonVars vars;

    SwaptionVolCube2 volCube(vars.atmVolMatrix,
                             vars.cube.tenors.options,
                             vars.cube.tenors.swaps,
                             vars.cube.strikeSpreads,
                             vars.cube.volSpreadsHandle,
                             vars.swapIndexBase,
                             vars.shortSwapIndexBase,
                             vars.vegaWeighedSmileFit);

    Real tolerance = 1.0e-16;
    vars.makeVolSpreadsTest(volCube, tolerance);
}

void SwaptionVolatilityCubeTest::testSabrVols() {

    BOOST_TEST_MESSAGE("Testing swaption volatility cube (sabr interpolation)...");

    using namespace swaption_volatility_cube_test;

    CommonVars vars;

    std::vector<std::vector<Handle<Quote> > >
        parametersGuess(vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size());
    for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
        parametersGuess[i] = std::vector<Handle<Quote> >(4);
        parametersGuess[i][0] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.2)));
        parametersGuess[i][1] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.5)));
        parametersGuess[i][2] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.4)));
        parametersGuess[i][3] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.0)));
    }
    std::vector<bool> isParameterFixed(4, false);

    SwaptionVolCube1 volCube(vars.atmVolMatrix,
                             vars.cube.tenors.options,
                             vars.cube.tenors.swaps,
                             vars.cube.strikeSpreads,
                             vars.cube.volSpreadsHandle,
                             vars.swapIndexBase,
                             vars.shortSwapIndexBase,
                             vars.vegaWeighedSmileFit,
                             parametersGuess,
                             isParameterFixed,
                             true);
    Real tolerance = 3.0e-4;
    vars.makeAtmVolTest(volCube, tolerance);

    tolerance = 12.0e-4;
    vars.makeVolSpreadsTest(volCube, tolerance);
}

void SwaptionVolatilityCubeTest::testSpreadedCube() {

    BOOST_TEST_MESSAGE("Testing spreaded swaption volatility cube...");

    using namespace swaption_volatility_cube_test;

    CommonVars vars;

    std::vector<std::vector<Handle<Quote> > >
        parametersGuess(vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size());
    for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
        parametersGuess[i] = std::vector<Handle<Quote> >(4);
        parametersGuess[i][0] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.2)));
        parametersGuess[i][1] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.5)));
        parametersGuess[i][2] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.4)));
        parametersGuess[i][3] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.0)));
    }
    std::vector<bool> isParameterFixed(4, false);

    Handle<SwaptionVolatilityStructure> volCube( ext::shared_ptr<SwaptionVolatilityStructure>(new
        SwaptionVolCube1(vars.atmVolMatrix,
                         vars.cube.tenors.options,
                         vars.cube.tenors.swaps,
                         vars.cube.strikeSpreads,
                         vars.cube.volSpreadsHandle,
                         vars.swapIndexBase,
                         vars.shortSwapIndexBase,
                         vars.vegaWeighedSmileFit,
                         parametersGuess,
                         isParameterFixed,
                         true)));

    ext::shared_ptr<SimpleQuote> spread (new SimpleQuote(0.0001));
    Handle<Quote> spreadHandle(spread);
    ext::shared_ptr<SwaptionVolatilityStructure> spreadedVolCube(new
        SpreadedSwaptionVolatility(volCube, spreadHandle));
    std::vector<Real> strikes;
    for (Size k=1; k<100; k++)
        strikes.push_back(k*.01);
    for (Size i=0; i<vars.cube.tenors.options.size(); i++) {
        for (Size j=0; j<vars.cube.tenors.swaps.size(); j++) {
            ext::shared_ptr<SmileSection> smileSectionByCube =
                volCube->smileSection(vars.cube.tenors.options[i], vars.cube.tenors.swaps[j]);
            ext::shared_ptr<SmileSection> smileSectionBySpreadedCube =
                spreadedVolCube->smileSection(vars.cube.tenors.options[i], vars.cube.tenors.swaps[j]);
            for (double strike : strikes) {
                Real diff = spreadedVolCube->volatility(vars.cube.tenors.options[i],
                                                        vars.cube.tenors.swaps[j], strike) -
                            volCube->volatility(vars.cube.tenors.options[i],
                                                vars.cube.tenors.swaps[j], strike);
                if (std::fabs(diff-spread->value())>1e-16)
                    BOOST_ERROR("\ndiff!=spread in volatility method:"
                                "\nexpiry time = " << vars.cube.tenors.options[i] <<
                                "\nswap length = " << vars.cube.tenors.swaps[j] <<
                                "\n atm strike = " << io::rate(strike) <<
                                "\ndiff = " << diff <<
                                "\nspread = " << spread->value());

                diff = smileSectionBySpreadedCube->volatility(strike)
                       - smileSectionByCube->volatility(strike);
                if (std::fabs(diff-spread->value())>1e-16)
                    BOOST_ERROR("\ndiff!=spread in smile section method:"
                                "\nexpiry time = " << vars.cube.tenors.options[i] <<
                                "\nswap length = " << vars.cube.tenors.swaps[j] <<
                                "\n atm strike = " << io::rate(strike) <<
                                "\ndiff = " << diff <<
                                "\nspread = " << spread->value());
            }
        }
    }

    //testing observability
    Flag f;
    f.registerWith(spreadedVolCube);
    volCube->update();
    if(!f.isUp())
        BOOST_ERROR("SpreadedSwaptionVolatilityStructure "
                    << "does not propagate notifications");
    f.lower();
    spread->setValue(.001);
    if(!f.isUp())
        BOOST_ERROR("SpreadedSwaptionVolatilityStructure "
                    << "does not propagate notifications");
}


void SwaptionVolatilityCubeTest::testObservability() {
    BOOST_TEST_MESSAGE("Testing volatility cube observability...");

    using namespace swaption_volatility_cube_test;

    CommonVars vars;

    std::vector<std::vector<Handle<Quote> > >
        parametersGuess(vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size());
    for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
        parametersGuess[i] = std::vector<Handle<Quote> >(4);
        parametersGuess[i][0] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.2)));
        parametersGuess[i][1] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.5)));
        parametersGuess[i][2] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.4)));
        parametersGuess[i][3] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.0)));
    }
    std::vector<bool> isParameterFixed(4, false);

    std::string description;
    ext::shared_ptr<SwaptionVolCube1> volCube1_0, volCube1_1;
    // VolCube created before change of reference date
    volCube1_0 = ext::shared_ptr<SwaptionVolCube1>(new SwaptionVolCube1(vars.atmVolMatrix,
                                                                vars.cube.tenors.options,
                                                                vars.cube.tenors.swaps,
                                                                vars.cube.strikeSpreads,
                                                                vars.cube.volSpreadsHandle,
                                                                vars.swapIndexBase,
                                                                vars.shortSwapIndexBase,
                                                                vars.vegaWeighedSmileFit,
                                                                parametersGuess,
                                                                isParameterFixed,
                                                                true));

    Date referenceDate = Settings::instance().evaluationDate();
    Settings::instance().evaluationDate() =
        vars.conventions.calendar.advance(referenceDate, Period(1, Days),
                                          vars.conventions.optionBdc);

    // VolCube created after change of reference date
    volCube1_1 = ext::shared_ptr<SwaptionVolCube1>(new SwaptionVolCube1(vars.atmVolMatrix,
                                                                vars.cube.tenors.options,
                                                                vars.cube.tenors.swaps,
                                                                vars.cube.strikeSpreads,
                                                                vars.cube.volSpreadsHandle,
                                                                vars.swapIndexBase,
                                                                vars.shortSwapIndexBase,
                                                                vars.vegaWeighedSmileFit,
                                                                parametersGuess,
                                                                isParameterFixed,
                                                                true));
    Rate dummyStrike = 0.03;
    for (Size i=0;i<vars.cube.tenors.options.size(); i++ ) {
        for (Size j=0; j<vars.cube.tenors.swaps.size(); j++) {
            for (Size k=0; k<vars.cube.strikeSpreads.size(); k++) {

                Volatility v0 = volCube1_0->volatility(vars.cube.tenors.options[i],
                                                       vars.cube.tenors.swaps[j],
                                                       dummyStrike + vars.cube.strikeSpreads[k],
                                                       false);
                Volatility v1 = volCube1_1->volatility(vars.cube.tenors.options[i],
                                                       vars.cube.tenors.swaps[j],
                                                       dummyStrike + vars.cube.strikeSpreads[k],
                                                       false);
                if (std::fabs(v0 - v1) > 1e-14)
                    BOOST_ERROR(description <<
                                " option tenor = " << vars.cube.tenors.options[i] <<
                                " swap tenor = " << vars.cube.tenors.swaps[j] <<
                                " strike = " << io::rate(dummyStrike+vars.cube.strikeSpreads[k])<<
                                "  v0 = " << io::volatility(v0) <<
                                "  v1 = " << io::volatility(v1) <<
                                "  error = " << std::fabs(v1-v0));
            }
        }
    }

    Settings::instance().evaluationDate() = referenceDate;

    ext::shared_ptr<SwaptionVolCube2> volCube2_0, volCube2_1;
    // VolCube created before change of reference date
    volCube2_0 = ext::make_shared<SwaptionVolCube2>(vars.atmVolMatrix,
                                                                vars.cube.tenors.options,
                                                                vars.cube.tenors.swaps,
                                                                vars.cube.strikeSpreads,
                                                                vars.cube.volSpreadsHandle,
                                                                vars.swapIndexBase,
                                                                vars.shortSwapIndexBase,
                                                                vars.vegaWeighedSmileFit);
    Settings::instance().evaluationDate() =
        vars.conventions.calendar.advance(referenceDate, Period(1, Days),
                                          vars.conventions.optionBdc);

    // VolCube created after change of reference date
    volCube2_1 = ext::make_shared<SwaptionVolCube2>(vars.atmVolMatrix,
                                                                vars.cube.tenors.options,
                                                                vars.cube.tenors.swaps,
                                                                vars.cube.strikeSpreads,
                                                                vars.cube.volSpreadsHandle,
                                                                vars.swapIndexBase,
                                                                vars.shortSwapIndexBase,
                                                                vars.vegaWeighedSmileFit);

    for (Size i=0;i<vars.cube.tenors.options.size(); i++ ) {
        for (Size j=0; j<vars.cube.tenors.swaps.size(); j++) {
            for (Size k=0; k<vars.cube.strikeSpreads.size(); k++) {

                Volatility v0 = volCube2_0->volatility(vars.cube.tenors.options[i],
                                                       vars.cube.tenors.swaps[j],
                                                       dummyStrike + vars.cube.strikeSpreads[k],
                                                       false);
                Volatility v1 = volCube2_1->volatility(vars.cube.tenors.options[i],
                                                       vars.cube.tenors.swaps[j],
                                                       dummyStrike + vars.cube.strikeSpreads[k],
                                                       false);
                if (std::fabs(v0 - v1) > 1e-14)
                    BOOST_ERROR(description <<
                                " option tenor = " << vars.cube.tenors.options[i] <<
                                " swap tenor = " << vars.cube.tenors.swaps[j] <<
                                " strike = " << io::rate(dummyStrike+vars.cube.strikeSpreads[k])<<
                                "  v0 = " << io::volatility(v0) <<
                                "  v1 = " << io::volatility(v1) <<
                                "  error = " << std::fabs(v1-v0));
            }
        }
    }

    Settings::instance().evaluationDate() = referenceDate;
}

void SwaptionVolatilityCubeTest::testSabrParameters() {
    BOOST_TEST_MESSAGE("Testing interpolation of SABR smile sections...");

    using namespace swaption_volatility_cube_test;

    CommonVars vars;

    std::vector<std::vector<Handle<Quote> > >
        parametersGuess(vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size());
    for (Size i=0; i<vars.cube.tenors.options.size()*vars.cube.tenors.swaps.size(); i++) {
        parametersGuess[i] = std::vector<Handle<Quote> >(4);
        parametersGuess[i][0] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.2)));
        parametersGuess[i][1] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.5)));
        parametersGuess[i][2] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.4)));
        parametersGuess[i][3] =
            Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(0.0)));
    }
    std::vector<bool> isParameterFixed(4, false);

    SwaptionVolCube1 volCube(vars.atmVolMatrix,
                             vars.cube.tenors.options,
                             vars.cube.tenors.swaps,
                             vars.cube.strikeSpreads,
                             vars.cube.volSpreadsHandle,
                             vars.swapIndexBase,
                             vars.shortSwapIndexBase,
                             vars.vegaWeighedSmileFit,
                             parametersGuess,
                             isParameterFixed,
                             true);

    SwaptionVolatilityStructure* volStructure = &volCube;
    Real tolerance = 1.0e-4;

    //Interpolating between two SmileSection objects

    //First section: maturity = 10Y, tenor = 2Y
    ext::shared_ptr<SmileSection> smileSection1 = volStructure->smileSection(Period(10,Years), Period(2,Years));

    //Second section: maturity = 10Y, tenor = 4Y
    ext::shared_ptr<SmileSection> smileSection2 = volStructure->smileSection(Period(10,Years), Period(4,Years));

    //Third section in the middle: maturity = 10Y, tenor = 3Y
    ext::shared_ptr<SmileSection> smileSection3 = volStructure->smileSection(Period(10,Years), Period(3,Years));

    //test alpha interpolation
    Real alpha1 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection1)->alpha();
    Real alpha2 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection2)->alpha();
    Real alpha3 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection3)->alpha();
    Real alpha12 = 0.5*(alpha1+alpha2);
    if (std::abs(alpha3 - alpha12) > tolerance) {
             BOOST_ERROR("\nChecking interpolation of alpha parameters:"
                         "\nexpected = " << alpha12 <<
                         "\nobserved = " << alpha3);
    }

    //test beta interpolation
     Real beta1 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection1)->beta();
     Real beta2 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection2)->beta();
     Real beta3 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection3)->beta();
     Real beta12 = 0.5*(beta1+beta2);
     if (std::abs(beta3 - beta12) > tolerance) {
              BOOST_ERROR("\nChecking interpolation of beta parameters:"
                          "\nexpected = " << beta12 <<
                          "\nobserved = " << beta3);
     }

     //test rho interpolation
       Real rho1 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection1)->rho();
       Real rho2 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection2)->rho();
       Real rho3 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection3)->rho();
       Real rho12 = 0.5*(rho1+rho2);
       if (std::abs(rho3 - rho12) > tolerance) {
                BOOST_ERROR("\nChecking interpolation of rho parameters:"
                            "\nexpected = " << rho12 <<
                            "\nobserved = " << rho3);
       }

       //test nu interpolation
         Real nu1 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection1)->nu();
         Real nu2 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection2)->nu();
         Real nu3 = ext::dynamic_pointer_cast<SabrSmileSection>(smileSection3)->nu();
         Real nu12 = 0.5*(nu1+nu2);
         if (std::abs(nu3 - nu12) > tolerance) {
                  BOOST_ERROR("\nChecking interpolation of nu parameters:"
                              "\nexpected = " << nu12 <<
                              "\nobserved = " << nu3);
         }

         //test forward interpolation
           Real forward1 = smileSection1->atmLevel();
           Real forward2 = smileSection2->atmLevel();
           Real forward3 = smileSection3->atmLevel();
           Real forward12 = 0.5*(forward1+forward2);
           if (std::abs(forward3 - forward12) > tolerance) {
                    BOOST_ERROR("\nChecking interpolation of forward parameters:"
                                "\nexpected = " << forward12 <<
                                "\nobserved = " << forward3);
           }

}


test_suite* SwaptionVolatilityCubeTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Swaption Volatility Cube tests");

    // SwaptionVolCubeByLinear reproduces ATM vol with machine precision
    suite->add(QUANTLIB_TEST_CASE(&SwaptionVolatilityCubeTest::testAtmVols));
    // SwaptionVolCubeByLinear reproduces smile spreads with machine precision
    suite->add(QUANTLIB_TEST_CASE(&SwaptionVolatilityCubeTest::testSmile));

    // SwaptionVolCubeBySabr reproduces ATM vol with given tolerance
    // SwaptionVolCubeBySabr reproduces smile spreads with given tolerance
    suite->add(QUANTLIB_TEST_CASE(&SwaptionVolatilityCubeTest::testSabrVols));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionVolatilityCubeTest::testSpreadedCube));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionVolatilityCubeTest::testObservability));
    suite->add(QUANTLIB_TEST_CASE(&SwaptionVolatilityCubeTest::testSabrParameters));


    return suite;
}



]]></document_content>
  </document>
  <document index="272">
    <source>swaptionvolatilitycube.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swaption_volatility_cube_hpp
#define quantlib_test_swaption_volatility_cube_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SwaptionVolatilityCubeTest {
  public:
    static void testAtmVols();
    static void testSmile();
    static void testSabrVols();
    static void testSpreadedCube();
    static void testObservability();
    static void testSabrParameters();

    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="273">
    <source>swaptionvolatilitymatrix.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2008 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2007 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "swaptionvolatilitymatrix.hpp"
#include "swaptionvolstructuresutilities.hpp"
#include "utilities.hpp"
#include <ql/utilities/dataformatters.hpp>
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/instruments/makeswaption.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/math/comparison.hpp>
#include <string>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace swaption_volatility_matrix_test {

    struct CommonVars {
        // global data
        Date referenceDate;
        SwaptionMarketConventions conventions;
        AtmVolatility atm;
        RelinkableHandle<YieldTermStructure> termStructure;
        RelinkableHandle<SwaptionVolatilityStructure> atmVolMatrix;
        Real tolerance;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            conventions.setConventions();
            atm.setMarketData();
            Settings::instance().evaluationDate() =
                conventions.calendar.adjust(Date::todaysDate());
            atmVolMatrix = RelinkableHandle<SwaptionVolatilityStructure>(
                ext::shared_ptr<SwaptionVolatilityStructure>(new
                    SwaptionVolatilityMatrix(conventions.calendar,
                                             conventions.optionBdc,
                                             atm.tenors.options,
                                             atm.tenors.swaps,
                                             atm.volsHandle,
                                             conventions.dayCounter)));
            termStructure.linkTo(
                ext::shared_ptr<YieldTermStructure>(new
                    FlatForward(0, conventions.calendar,
                                0.05, Actual365Fixed())));
        }

        // utilities
        void makeObservabilityTest(
                const std::string& description,
                const ext::shared_ptr<SwaptionVolatilityStructure>& vol,
                bool mktDataFloating,
                bool referenceDateFloating) {
            Rate dummyStrike = .02;
            Date referenceDate = Settings::instance().evaluationDate();
            Volatility initialVol = vol->volatility(
                        referenceDate + atm.tenors.options[0],
                        atm.tenors.swaps[0], dummyStrike, false);
            // testing evaluation date change ...
            Settings::instance().evaluationDate() =
                referenceDate - Period(1, Years);
            Volatility newVol =  vol->volatility(
                        referenceDate + atm.tenors.options[0],
                        atm.tenors.swaps[0], dummyStrike, false);
            Settings::instance().evaluationDate() = referenceDate;
            if (referenceDateFloating && (initialVol == newVol))
                BOOST_ERROR(description <<
                            " the volatility should change when the reference date is changed !");
            if (!referenceDateFloating && (initialVol != newVol))
                BOOST_ERROR(description <<
                            " the volatility should not change when the reference date is changed !");

            // test market data change...
            if (mktDataFloating){
                Volatility initialVolatility = atm.volsHandle[0][0]->value();
                ext::dynamic_pointer_cast<SimpleQuote>(
                              atm.volsHandle[0][0].currentLink())->setValue(10);
                newVol = vol->volatility(
                    referenceDate + atm.tenors.options[0],
                    atm.tenors.swaps[0], dummyStrike, false);
                ext::dynamic_pointer_cast<SimpleQuote>(
                    atm.volsHandle[0][0].currentLink())
                    ->setValue(initialVolatility);
                if (initialVol == newVol)
                    BOOST_ERROR(description << " the volatility should change when"
                                " the market data is changed !");
            }
        }

        void makeCoherenceTest(
                const std::string& description,
                const ext::shared_ptr<SwaptionVolatilityDiscrete>& vol) {

            for (Size i=0; i<atm.tenors.options.size(); ++i) {
                Date optionDate =
                    vol->optionDateFromTenor(atm.tenors.options[i]);
                if (optionDate!=vol->optionDates()[i])
                    BOOST_FAIL(
                         "optionDateFromTenor failure for " <<
                         description << ":"
                         "\n       option tenor: " << atm.tenors.options[i] <<
                         "\nactual option date : " << optionDate <<
                         "\n  exp. option date : " << vol->optionDates()[i]);
                Time optionTime = vol->timeFromReference(optionDate);
                if (!close(optionTime,vol->optionTimes()[i]))
                    BOOST_FAIL(
                         "timeFromReference failure for " <<
                         description << ":"
                         "\n       option tenor: " << atm.tenors.options[i] <<
                         "\n       option date : " << optionDate <<
                         "\nactual option time : " << optionTime <<
                         "\n  exp. option time : " << vol->optionTimes()[i]);
            }

            ext::shared_ptr<BlackSwaptionEngine> engine(new
                BlackSwaptionEngine(termStructure,
                                    Handle<SwaptionVolatilityStructure>(vol)));

            for (Size j=0; j<atm.tenors.swaps.size(); j++) {
                Time swapLength = vol->swapLength(atm.tenors.swaps[j]);
                if (!close(swapLength,years(atm.tenors.swaps[j])))
                    BOOST_FAIL("convertSwapTenor failure for " <<
                               description << ":"
                               "\n        swap tenor : " << atm.tenors.swaps[j] <<
                               "\n actual swap length: " << swapLength <<
                               "\n   exp. swap length: " << years(atm.tenors.swaps[j]));

                ext::shared_ptr<SwapIndex> swapIndex(new
                    EuriborSwapIsdaFixA(atm.tenors.swaps[j], termStructure));

                for (Size i=0; i<atm.tenors.options.size(); ++i) {
                    Real error, tolerance = 1.0e-16;
                    Volatility actVol, expVol = atm.vols[i][j];

                    actVol = vol->volatility(atm.tenors.options[i],
                                             atm.tenors.swaps[j], 0.05, true);
                    error = std::abs(expVol-actVol);
                    if (error>tolerance)
                        BOOST_FAIL(
                              "recovery of atm vols failed for " <<
                              description << ":"
                              "\noption tenor = " << atm.tenors.options[i] <<
                              "\n swap length = " << atm.tenors.swaps[j] <<
                              "\nexpected vol = " << io::volatility(expVol) <<
                              "\n  actual vol = " << io::volatility(actVol) <<
                              "\n       error = " << io::volatility(error) <<
                              "\n   tolerance = " << tolerance);

                    Date optionDate =
                        vol->optionDateFromTenor(atm.tenors.options[i]);
                    actVol = vol->volatility(optionDate,
                                             atm.tenors.swaps[j], 0.05, true);
                    error = std::abs(expVol-actVol);
                    if (error>tolerance)
                        BOOST_FAIL(
                             "recovery of atm vols failed for " <<
                             description << ":"
                             "\noption tenor: " << atm.tenors.options[i] <<
                             "\noption date : " << optionDate <<
                             "\n  swap tenor: " << atm.tenors.swaps[j] <<
                             "\n   exp. vol: " << io::volatility(expVol) <<
                             "\n actual vol: " << io::volatility(actVol) <<
                             "\n      error: " << io::volatility(error) <<
                             "\n  tolerance: " << tolerance);

                    Time optionTime = vol->timeFromReference(optionDate);
                    actVol = vol->volatility(optionTime, swapLength,
                                             0.05, true);
                    error = std::abs(expVol-actVol);
                    if (error>tolerance)
                        BOOST_FAIL(
                             "recovery of atm vols failed for " <<
                             description << ":"
                             "\noption tenor: " << atm.tenors.options[i] <<
                             "\noption time : " << optionTime <<
                             "\n  swap tenor: " << atm.tenors.swaps[j] <<
                             "\n swap length: " << swapLength <<
                             "\n    exp. vol: " << io::volatility(expVol) <<
                             "\n  actual vol: " << io::volatility(actVol) <<
                             "\n       error: " << io::volatility(error) <<
                             "\n   tolerance: " << tolerance);

                    // ATM swaption
                    Swaption swaption =
                        MakeSwaption(swapIndex, atm.tenors.options[i])
                        .withPricingEngine(engine);

                    Date exerciseDate = swaption.exercise()->dates().front();
                    if (exerciseDate!=vol->optionDates()[i])
                        BOOST_FAIL(
                             "\noptionDateFromTenor mismatch for " <<
                             description << ":"
                             "\n      option tenor: " << atm.tenors.options[i] <<
                             "\nactual option date: " << exerciseDate <<
                             "\n  exp. option date: " << vol->optionDates()[i]);

                    Date start = swaption.underlyingSwap()->startDate();
                    Date end = swaption.underlyingSwap()->maturityDate();
                    Time swapLength2 = vol->swapLength(start, end);
                    if (!close(swapLength2,swapLength))
                        BOOST_FAIL("\nswapLength failure for " <<
                                   description << ":"
                                   "\n   exp. swap length: " << swapLength <<
                                   "\n actual swap length: " << swapLength2 <<
                                   "\n        swap tenor : " << atm.tenors.swaps[j] <<
                                   "\n  swap index tenor : " << swapIndex->tenor() <<
                                   "\n        option date: " << exerciseDate <<
                                   "\n         start date: " << start <<
                                   "\n      maturity date: " << end
                                   );

                    Real npv = swaption.NPV();
                    actVol = swaption.impliedVolatility(npv, termStructure,
                                                        expVol*0.98, 1e-6,
                                                        100, 10.0e-7, 4.0,
                                                        ShiftedLognormal, 0.0);
                    error = std::abs(expVol-actVol);
                    Real tolerance2 = 0.000001;
                    if (error>tolerance2)
                        BOOST_FAIL(
                             "recovery of atm vols through BlackSwaptionEngine failed for " <<
                             description << ":"
                             "\noption tenor: " << atm.tenors.options[i] <<
                             "\noption time : " << optionTime <<
                             "\n  swap tenor: " << atm.tenors.swaps[j] <<
                             "\n swap length: " << swapLength <<
                             "\n   exp. vol: " << io::volatility(expVol) <<
                             "\n actual vol: " << io::volatility(actVol) <<
                             "\n      error: " << io::volatility(error) <<
                             "\n  tolerance: " << tolerance2);
                }
            }
        }
    };

}


void SwaptionVolatilityMatrixTest::testSwaptionVolMatrixObservability() {

    BOOST_TEST_MESSAGE("Testing swaption volatility matrix observability...");

    using namespace swaption_volatility_matrix_test;

    CommonVars vars;

    ext::shared_ptr<SwaptionVolatilityMatrix> vol;
    std::string description;

    //floating reference date, floating market data
    description = "floating reference date, floating market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeObservabilityTest(description, vol, true, true);

    //fixed reference date, floating market data
    description = "fixed reference date, floating market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(Settings::instance().evaluationDate(),
                                 vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeObservabilityTest(description, vol, true, false);

    // floating reference date, fixed market data
    description = "floating reference date, fixed market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeObservabilityTest(description, vol, false, true);

    // fixed reference date, fixed market data
    description = "fixed reference date, fixed market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(Settings::instance().evaluationDate(),
                                 vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeObservabilityTest(description, vol, false, false);

   // fixed reference date and fixed market data, option dates
        //SwaptionVolatilityMatrix(const Date& referenceDate,
        //                         const std::vector<Date>& exerciseDates,
        //                         const std::vector<Period>& swapTenors,
        //                         const Matrix& volatilities,
        //                         const DayCounter& dayCounter);
}


void SwaptionVolatilityMatrixTest::testSwaptionVolMatrixCoherence() {

    BOOST_TEST_MESSAGE("Testing swaption volatility matrix...");

    using namespace swaption_volatility_matrix_test;

    CommonVars vars;

    ext::shared_ptr<SwaptionVolatilityMatrix> vol;
    std::string description;

    //floating reference date, floating market data
    description = "floating reference date, floating market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeCoherenceTest(description, vol);

    //fixed reference date, floating market data
    description = "fixed reference date, floating market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(Settings::instance().evaluationDate(),
                                 vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeCoherenceTest(description, vol);

    // floating reference date, fixed market data
    description = "floating reference date, fixed market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeCoherenceTest(description, vol);

    // fixed reference date, fixed market data
    description = "fixed reference date, fixed market data";
    vol = ext::make_shared<SwaptionVolatilityMatrix>(Settings::instance().evaluationDate(),
                                 vars.conventions.calendar,
                                 vars.conventions.optionBdc,
                                 vars.atm.tenors.options,
                                 vars.atm.tenors.swaps,
                                 vars.atm.volsHandle,
                                 vars.conventions.dayCounter);
    vars.makeCoherenceTest(description, vol);
}

test_suite* SwaptionVolatilityMatrixTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Swaption Volatility Matrix tests");

    suite->add(QUANTLIB_TEST_CASE(
              &SwaptionVolatilityMatrixTest::testSwaptionVolMatrixCoherence));

    suite->add(QUANTLIB_TEST_CASE(
          &SwaptionVolatilityMatrixTest::testSwaptionVolMatrixObservability));

    return suite;
}
]]></document_content>
  </document>
  <document index="274">
    <source>swaptionvolatilitymatrix.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swaption_volatility_matrix_hpp
#define quantlib_test_swaption_volatility_matrix_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SwaptionVolatilityMatrixTest {
  public:
    static void testSwaptionVolMatrixCoherence();
    static void testSwaptionVolMatrixObservability();
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="275">
    <source>swaptionvolstructuresutilities.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swaption_volatility_structures_utilities_hpp
#define quantlib_test_swaption_volatility_structures_utilities_hpp

#include <ql/time/period.hpp>
#include <ql/math/matrix.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolmatrix.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <iostream>
#include <vector>

namespace QuantLib {

    struct SwaptionTenors {
        std::vector<Period> options;
        std::vector<Period> swaps;
    };
    struct SwaptionMarketConventions {
        Calendar calendar;
        BusinessDayConvention optionBdc;
        DayCounter dayCounter;
        void setConventions() {
            calendar = TARGET();
            optionBdc = ModifiedFollowing;
            dayCounter = Actual365Fixed();
        }
    };
    struct AtmVolatility {
        SwaptionTenors tenors;
        Matrix vols;
        std::vector<std::vector<Handle<Quote> > > volsHandle;
        void setMarketData() {
            tenors.options.resize(6);
            tenors.options[0] = Period(1, Months);
            tenors.options[1] = Period(6, Months);
            tenors.options[2] = Period(1, Years);
            tenors.options[3] = Period(5, Years);
            tenors.options[4] = Period(10, Years);
            tenors.options[5] = Period(30, Years);
            tenors.swaps.resize(4);
            tenors.swaps[0] = Period(1, Years);
            tenors.swaps[1] = Period(5, Years);
            tenors.swaps[2] = Period(10, Years);
            tenors.swaps[3] = Period(30, Years);
            vols = Matrix(tenors.options.size(), tenors.swaps.size());
            vols[0][0]=0.1300; vols[0][1]=0.1560; vols[0][2]=0.1390; vols[0][3]=0.1220;
            vols[1][0]=0.1440; vols[1][1]=0.1580; vols[1][2]=0.1460; vols[1][3]=0.1260;
            vols[2][0]=0.1600; vols[2][1]=0.1590; vols[2][2]=0.1470; vols[2][3]=0.1290;
            vols[3][0]=0.1640; vols[3][1]=0.1470; vols[3][2]=0.1370; vols[3][3]=0.1220;
            vols[4][0]=0.1400; vols[4][1]=0.1300; vols[4][2]=0.1250; vols[4][3]=0.1100;
            vols[5][0]=0.1130; vols[5][1]=0.1090; vols[5][2]=0.1070; vols[5][3]=0.0930;
            volsHandle.resize(tenors.options.size());
            for (Size i=0; i<tenors.options.size(); i++){
                volsHandle[i].resize(tenors.swaps.size());
                for (Size j=0; j<tenors.swaps.size(); j++)
                    // every handle must be reassigned, as the ones created by
                    // default are all linked together.
                    volsHandle[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                        SimpleQuote(vols[i][j])));
            }
        };
    };
    struct VolatilityCube {
        SwaptionTenors tenors;
        Matrix volSpreads;
        std::vector<std::vector<Handle<Quote> > > volSpreadsHandle;
        std::vector<Spread> strikeSpreads;
        void setMarketData() {
            tenors.options.resize(3);
            tenors.options[0] = Period(1, Years);
            tenors.options[1] = Period(10, Years);
            tenors.options[2] = Period(30, Years);
            tenors.swaps.resize(3);
            tenors.swaps[0] = Period(2, Years);
            tenors.swaps[1] = Period(10, Years);
            tenors.swaps[2] = Period(30, Years);
            strikeSpreads.resize(5);
            strikeSpreads[0] = -0.020;
            strikeSpreads[1] = -0.005;
            strikeSpreads[2] = +0.000;
            strikeSpreads[3] = +0.005;
            strikeSpreads[4] = +0.020;
            volSpreads = Matrix(tenors.options.size()*tenors.swaps.size(), strikeSpreads.size());
            volSpreads[0][0] = 0.0599; volSpreads[0][1] = 0.0049;
            volSpreads[0][2] = 0.0000;
            volSpreads[0][3] =-0.0001; volSpreads[0][4] = 0.0127;
            volSpreads[1][0] = 0.0729; volSpreads[1][1] = 0.0086;
            volSpreads[1][2] = 0.0000;
            volSpreads[1][3] =-0.0024; volSpreads[1][4] = 0.0098;
            volSpreads[2][0] = 0.0738; volSpreads[2][1] = 0.0102;
            volSpreads[2][2] = 0.0000;
            volSpreads[2][3] =-0.0039; volSpreads[2][4] = 0.0065;
            volSpreads[3][0] = 0.0465; volSpreads[3][1] = 0.0063;
            volSpreads[3][2] = 0.0000;
            volSpreads[3][3] =-0.0032; volSpreads[3][4] =-0.0010;
            volSpreads[4][0] = 0.0558; volSpreads[4][1] = 0.0084;
            volSpreads[4][2] = 0.0000;
            volSpreads[4][3] =-0.0050; volSpreads[4][4] =-0.0057;
            volSpreads[5][0] = 0.0576; volSpreads[5][1] = 0.0083;
            volSpreads[5][2] = 0.0000;
            volSpreads[5][3] =-0.0043; volSpreads[5][4] = -0.0014;
            volSpreads[6][0] = 0.0437; volSpreads[6][1] = 0.0059;
            volSpreads[6][2] = 0.0000;
            volSpreads[6][3] =-0.0030; volSpreads[6][4] =-0.0006;
            volSpreads[7][0] = 0.0533; volSpreads[7][1] = 0.0078;
            volSpreads[7][2] = 0.0000;
            volSpreads[7][3] =-0.0045; volSpreads[7][4] =-0.0046;
            volSpreads[8][0] = 0.0545; volSpreads[8][1] = 0.0079;
            volSpreads[8][2] = 0.0000;
            volSpreads[8][3] =-0.0042; volSpreads[8][4] =-0.0020;
            volSpreadsHandle = std::vector<std::vector<Handle<Quote> > >(tenors.options.size()*tenors.swaps.size());
            for (Size i=0; i<tenors.options.size()*tenors.swaps.size(); i++){
                volSpreadsHandle[i] = std::vector<Handle<Quote> >(strikeSpreads.size());
                for (Size j=0; j<strikeSpreads.size(); j++) {
                    // every handle must be reassigned, as the ones created by
                    // default are all linked together.
                    volSpreadsHandle[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                        SimpleQuote(volSpreads[i][j])));
                }
            }
        };
    };


 /*   static void setupCubeUtilities() {
        conventions_.calendar = TARGET();
        conventions_.optionBdc = Following;
        conventions_.dayCounter = Actual365Fixed();
        atm_.setMarketData();
        cube_.setMarketData();
        atmVolMatrix_ = RelinkableHandle<SwaptionVolatilityStructure>(
            ext::shared_ptr<SwaptionVolatilityStructure>(new
                SwaptionVolatilityMatrix(conventions_.calendar,
                                         atm_.tenors.options,
                                         atm_.tenors.swaps,
                                         atm_.volsHandle,
                                         conventions_.dayCounter,
                                         conventions_.optionBdc)));
    }*/

}

#endif
]]></document_content>
  </document>
  <document index="276">
    <source>swingoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "swingoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/finitedifferences/fdextoujumpvanillaengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoujumpswingengine.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/factorial.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/richardsonextrapolation.hpp>
#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdsimplebsswingengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <utility>


using namespace QuantLib;
using namespace boost::unit_test_framework;


namespace swing_option_test {
    ext::shared_ptr<ExtOUWithJumpsProcess> createKlugeProcess() {
        Array x0(2);
        x0[0] = 3.0; x0[1] = 0.0;

        const Real beta = 5.0;
        const Real eta  = 2.0;
        const Real jumpIntensity = 1.0;
        const Real speed = 1.0;
        const Real volatility = 2.0;

        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess(
            new ExtendedOrnsteinUhlenbeckProcess(speed, volatility, x0[0],
                                                 constant<Real, Real>(x0[0])));
        return ext::make_shared<ExtOUWithJumpsProcess>(
            ouProcess, x0[1], beta, jumpIntensity, eta);
    }
}

void SwingOptionTest::testExtendedOrnsteinUhlenbeckProcess() {

    BOOST_TEST_MESSAGE("Testing extended Ornstein-Uhlenbeck process...");

    SavedSettings backup;

    const Real speed = 2.5;
    const Volatility vol = 0.70;
    const Real level = 1.43;

    ExtendedOrnsteinUhlenbeckProcess::Discretization discr[] = {
        ExtendedOrnsteinUhlenbeckProcess::MidPoint,
        ExtendedOrnsteinUhlenbeckProcess::Trapezodial,
        ExtendedOrnsteinUhlenbeckProcess::GaussLobatto};

    ext::function<Real (Real)> f[] 
        = { constant<Real, Real>(level),
            add<Real>(1.0),
            static_cast<Real(*)(Real)>(std::sin) }; 

    for (Size n=0; n < LENGTH(f); ++n) {
        ExtendedOrnsteinUhlenbeckProcess refProcess(
            speed, vol, 0.0, f[n], 
            ExtendedOrnsteinUhlenbeckProcess::GaussLobatto, 1e-6);

        for (Size i=0; i < LENGTH(discr)-1; ++i) {
            ExtendedOrnsteinUhlenbeckProcess eouProcess(
                                      speed, vol, 0.0, f[n], discr[i]);

            const Time T = 10;
            const Size nTimeSteps = 10000;

            const Time dt = T/nTimeSteps;
            Time t  = 0.0;
            Real q = 0.0;
            Real p = 0.0;

            PseudoRandom::rng_type rng(PseudoRandom::urng_type(1234U));

            for (Size j=0; j < nTimeSteps; ++j) {
                const Real dw = rng.next().value;
                q=eouProcess.evolve(t,q,dt,dw);
                p=refProcess.evolve(t,p,dt,dw);

                if (std::fabs(q-p) > 1e-6) {
                    BOOST_FAIL("invalid process evaluation " 
                                << n << " " << i << " " << j << " " << q-p);
                }
                t+=dt;
            }
        }
    }
}



void SwingOptionTest::testFdmExponentialJump1dMesher() {

    BOOST_TEST_MESSAGE("Testing finite difference mesher for the Kluge model...");

    SavedSettings backup;

    Array x(2, 1.0);
    const Real beta = 100.0;
    const Real eta  = 1.0/0.4;
    const Real jumpIntensity = 4.0;
    const Size dummySteps  = 2;

    ExponentialJump1dMesher mesher(dummySteps, beta, jumpIntensity, eta);

    ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess(
        new ExtendedOrnsteinUhlenbeckProcess(1.0, 1.0, x[0],
                                             constant<Real, Real>(1.0)));
    ext::shared_ptr<ExtOUWithJumpsProcess> jumpProcess(
        new ExtOUWithJumpsProcess(ouProcess, x[1], beta, jumpIntensity, eta));

    const Time dt = 1.0/(10.0*beta);
    const Size n = 1000000;

    std::vector<Real> path(n);
    PseudoRandom::rng_type mt(PseudoRandom::urng_type(123));
    Array dw(3);
    for (Size i=0; i < n; ++i) {
        dw[0] = mt.next().value;
        dw[1] = mt.next().value;
        dw[2] = mt.next().value;
        path[i] = (x = jumpProcess->evolve(0.0, x, dt, dw))[1];
    }
    std::sort(path.begin(), path.end());

    const Real relTol1 = 2e-3;
    const Real relTol2 = 2e-2;
    const Real threshold = 0.9;

    for (Real x=1e-12; x < 1.0; x*=10) {
        const Real v = mesher.jumpSizeDistribution(x);

        auto iter = std::lower_bound(path.begin(), path.end(), x);
        const Real q = std::distance(path.begin(), iter)/Real(n);
        QL_REQUIRE(std::fabs(q - v) < relTol1
                   || ((v < threshold) && std::fabs(q-v) < relTol2),
                    "can not reproduce jump distribution");
    }
}

void SwingOptionTest::testExtOUJumpVanillaEngine() {

    BOOST_TEST_MESSAGE("Testing finite difference pricer for the Kluge model...");

    using namespace swing_option_test;

    SavedSettings backup;

    ext::shared_ptr<ExtOUWithJumpsProcess> jumpProcess = createKlugeProcess();

    const Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    const DayCounter dc = ActualActual(ActualActual::ISDA);
    const Date maturityDate = today + Period(12, Months);
    const Time maturity = dc.yearFraction(today, maturityDate);

    const Rate irRate = 0.1;
    ext::shared_ptr<YieldTermStructure> rTS(flatRate(today, irRate, dc));
    ext::shared_ptr<StrikedTypePayoff> payoff(
                                     new PlainVanillaPayoff(Option::Call, 30));
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(maturityDate));

    ext::shared_ptr<PricingEngine> engine(
                 new FdExtOUJumpVanillaEngine(jumpProcess, rTS, 25, 200, 50));

    VanillaOption option(payoff, exercise);
    option.setPricingEngine(engine);
    const Real fdNPV = option.NPV();

    const Size steps = 100;
    const Size nrTrails = 200000;
    TimeGrid grid(maturity, steps);

    typedef PseudoRandom::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;
    rsg_type rsg = PseudoRandom::make_sequence_generator(
                    jumpProcess->factors()*(grid.size()-1), BigNatural(421));

    GeneralStatistics npv;
    MultiPathGenerator<rsg_type> generator(jumpProcess, grid, rsg, false);

    for (Size n=0; n < nrTrails; ++n) {
        sample_type path = generator.next();

        const Real x = path.value[0].back();
        const Real y = path.value[1].back();

        const Real cashflow = (*payoff)(std::exp(x+y));
        npv.add(cashflow*rTS->discount(maturity));
    }

    const Real mcNPV = npv.mean();
    const Real mcError = npv.errorEstimate();

    if ( std::fabs(fdNPV - mcNPV) > 3.0*mcError) {
        BOOST_ERROR("Failed to reproduce FD and MC prices"
                    << "\n    FD NPV: " << fdNPV
                    << "\n    MC NPV: " << mcNPV
                    << " +/- " << mcError);
    }
}

void SwingOptionTest::testFdBSSwingOption() {

    BOOST_TEST_MESSAGE("Testing Black-Scholes vanilla swing option pricing...");

    SavedSettings backup;

    Date settlementDate = Date::todaysDate();
    Settings::instance().evaluationDate() = settlementDate;
    DayCounter dayCounter = ActualActual(ActualActual::ISDA);
    Date maturityDate = settlementDate + Period(12, Months);

    Real strike = 30;
    ext::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(Option::Put, strike));
    ext::shared_ptr<StrikedTypePayoff> forward(
        new VanillaForwardPayoff(Option::Put, strike));

    std::vector<Date> exerciseDates(1, settlementDate+Period(1, Months));
    while (exerciseDates.back() < maturityDate) {
        exerciseDates.push_back(exerciseDates.back()+Period(1, Months));
    }

    ext::shared_ptr<SwingExercise> swingExercise(
                                            new SwingExercise(exerciseDates));

    Handle<YieldTermStructure> riskFreeTS(flatRate(0.14, dayCounter));
    Handle<YieldTermStructure> dividendTS(flatRate(0.02, dayCounter));
    Handle<BlackVolTermStructure> volTS(
                                    flatVol(settlementDate, 0.4, dayCounter));

    Handle<Quote> s0(ext::shared_ptr<Quote>(new SimpleQuote(30.0)));

    ext::shared_ptr<BlackScholesMertonProcess> process(
            new BlackScholesMertonProcess(s0, dividendTS, riskFreeTS, volTS));
    ext::shared_ptr<PricingEngine> engine(
                                new FdSimpleBSSwingEngine(process, 50, 200));
    
    VanillaOption bermudanOption(payoff, swingExercise);
    bermudanOption.setPricingEngine(ext::shared_ptr<PricingEngine>(
                          new FdBlackScholesVanillaEngine(process, 50, 200)));
    const Real bermudanOptionPrices = bermudanOption.NPV();
    
    for (Size i=0; i < exerciseDates.size(); ++i) {
        const Size exerciseRights = i+1;
        
        VanillaSwingOption swingOption(forward, swingExercise,
        		                       0, exerciseRights);
        swingOption.setPricingEngine(engine);
        const Real swingOptionPrice = swingOption.NPV();

        const Real upperBound = exerciseRights*bermudanOptionPrices;

        if (swingOptionPrice - upperBound > 0.01) {
            BOOST_ERROR("Failed to reproduce upper bounds"
                        << "\n    upper Bound: " << upperBound
                        << "\n    Price:       " << swingOptionPrice
                        << "\n    diff:        " << swingOptionPrice - upperBound);
        }
        
        Real lowerBound = 0.0;
        for (Size j=exerciseDates.size()-i-1; j < exerciseDates.size(); ++j) {
            VanillaOption europeanOption(payoff, ext::shared_ptr<Exercise>(
                                     new EuropeanExercise(exerciseDates[j])));
            europeanOption.setPricingEngine(
                ext::shared_ptr<PricingEngine>(
                                          new AnalyticEuropeanEngine(process)));
            lowerBound += europeanOption.NPV();
        }

        if (lowerBound - swingOptionPrice > 4e-2) {
            BOOST_ERROR("Failed to reproduce lower bounds"
                        << "\n    lower Bound: " << lowerBound
                        << "\n    Price:       " << swingOptionPrice
                        << "\n    diff:        " << lowerBound - swingOptionPrice);
        }
    }
}


void SwingOptionTest::testExtOUJumpSwingOption() {

    BOOST_TEST_MESSAGE("Testing simple swing option pricing for Kluge model...");

    using namespace swing_option_test;

    SavedSettings backup;

    Date settlementDate = Date::todaysDate();
    Settings::instance().evaluationDate() = settlementDate;
    DayCounter dayCounter = ActualActual(ActualActual::ISDA);
    Date maturityDate = settlementDate + Period(12, Months);

    Real strike = 30;
    ext::shared_ptr<StrikedTypePayoff> payoff(
        new PlainVanillaPayoff(Option::Put, strike));
    ext::shared_ptr<StrikedTypePayoff> forward(
        new VanillaForwardPayoff(Option::Put, strike));

    std::vector<Date> exerciseDates(1, settlementDate+Period(1, Months));
    while (exerciseDates.back() < maturityDate) {
        exerciseDates.push_back(exerciseDates.back()+Period(1, Months));
    }
    ext::shared_ptr<SwingExercise> swingExercise(
                                            new SwingExercise(exerciseDates));

    std::vector<Time> exerciseTimes(exerciseDates.size());
    for (Size i=0; i < exerciseTimes.size(); ++i) {
        exerciseTimes[i]
                 = dayCounter.yearFraction(settlementDate, exerciseDates[i]);
    }

    TimeGrid grid(exerciseTimes.begin(), exerciseTimes.end(), 60);
    std::vector<Size> exerciseIndex(exerciseDates.size());
    for (Size i=0; i < exerciseIndex.size(); ++i) {
        exerciseIndex[i] = grid.closestIndex(exerciseTimes[i]);
    }

    ext::shared_ptr<ExtOUWithJumpsProcess> jumpProcess = createKlugeProcess();

    const Rate irRate = 0.1;
    ext::shared_ptr<YieldTermStructure> rTS(
                                flatRate(settlementDate, irRate, dayCounter));

    ext::shared_ptr<PricingEngine> swingEngine(
                new FdSimpleExtOUJumpSwingEngine(jumpProcess, rTS, 25, 50, 25));

    ext::shared_ptr<PricingEngine> vanillaEngine(
                new FdExtOUJumpVanillaEngine(jumpProcess, rTS, 25, 50, 25));

    VanillaOption bermudanOption(payoff, swingExercise);
    bermudanOption.setPricingEngine(vanillaEngine);
    const Real bermudanOptionPrices = bermudanOption.NPV();

    const Size nrTrails = 16000;
    typedef PseudoRandom::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;
    rsg_type rsg = PseudoRandom::make_sequence_generator(
                    jumpProcess->factors()*(grid.size()-1), BigNatural(421));

    MultiPathGenerator<rsg_type> generator(jumpProcess, grid, rsg, false);

    for (Size i=0; i < exerciseDates.size(); ++i) {
        const Size exerciseRights = i+1;

        VanillaSwingOption swingOption(forward, swingExercise,
                                       0, exerciseRights);
        swingOption.setPricingEngine(swingEngine);
        const Real swingOptionPrice = swingOption.NPV();

        const Real upperBound = exerciseRights*bermudanOptionPrices;

        if (swingOptionPrice - upperBound > 2e-2) {
            BOOST_ERROR("Failed to reproduce upper bounds"
                        << "\n    upper Bound: " << upperBound
                        << "\n    Price:       " << swingOptionPrice);
        }

        Real lowerBound = 0.0;
        for (Size j=exerciseDates.size()-i-1; j < exerciseDates.size(); ++j) {
            VanillaOption europeanOption(payoff, ext::shared_ptr<Exercise>(
                                     new EuropeanExercise(exerciseDates[j])));
            europeanOption.setPricingEngine(
                ext::shared_ptr<PricingEngine>(vanillaEngine));
            lowerBound += europeanOption.NPV();
        }

        if (lowerBound - swingOptionPrice > 2e-2) {
            BOOST_ERROR("Failed to reproduce lower bounds"
                       << "\n    lower Bound: " << lowerBound
                       << "\n    Price:       " << swingOptionPrice);
        }

        // use MC plus perfect forecast to find an upper bound
        GeneralStatistics npv;
        for (Size n=0; n < nrTrails; ++n) {
            sample_type path = generator.next();

            std::vector<Real> exerciseValues(exerciseTimes.size());
            for (Size k=0; k < exerciseTimes.size(); ++k) {
                const Real x = path.value[0][exerciseIndex[k]];
                const Real y = path.value[1][exerciseIndex[k]];
                const Real s = std::exp(x+y);

                exerciseValues[k] =(*payoff)(s)*rTS->discount(exerciseDates[k]);
            }
            std::sort(exerciseValues.begin(), exerciseValues.end(),
                      std::greater<Real>());

            Real npCashFlows
                = std::accumulate(exerciseValues.begin(),
                                  exerciseValues.begin()+exerciseRights, Real(0.0));
            npv.add(npCashFlows);
        }

        const Real mcUpperBound = npv.mean();
        const Real mcErrorUpperBound = npv.errorEstimate();
        if (swingOptionPrice - mcUpperBound > 2.36*mcErrorUpperBound) {
            BOOST_ERROR("Failed to reproduce mc upper bounds"
                       << "\n    mc upper Bound: " << mcUpperBound
                       << "\n    Price:          " << swingOptionPrice);
        }
    }
}

namespace swing_option_test {
    class SwingPdePricing {
      public:
        typedef FdSimpleExtOUJumpSwingEngine::Shape Shape;

        SwingPdePricing(ext::shared_ptr<ExtOUWithJumpsProcess> process,
                        ext::shared_ptr<VanillaOption> option,
                        ext::shared_ptr<Shape> shape)
        : process_(std::move(process)), option_(std::move(option)), shape_(std::move(shape)) {}

        Real operator()(Real x) const {
            const ext::shared_ptr<YieldTermStructure> rTS(
                flatRate(0.0, Actual365Fixed()));

            const Size gridX = 200;
            const Size gridY = 100;
            const Size gridT = 100;

            option_->setPricingEngine(
                ext::make_shared<FdExtOUJumpVanillaEngine>(
                    process_, rTS,
                    Size(gridT/x), Size(gridX/x), Size(gridY/x), shape_));

            return option_->NPV();
        }

      private:
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<VanillaOption> option_;
        const ext::shared_ptr<Shape> shape_;
    };
}

void SwingOptionTest::testKlugeChFVanillaPricing() {
    BOOST_TEST_MESSAGE("Testing Kluge PDE Vanilla Pricing in"
            " comparison to moment matching...");

    using namespace swing_option_test;

    SavedSettings backup;

    Date settlementDate = Date(22, November, 2019);
    Settings::instance().evaluationDate() = settlementDate;
    DayCounter dayCounter = Actual365Fixed();
    Date maturityDate = settlementDate + Period(6, Months);
    const Time t = dayCounter.yearFraction(settlementDate, maturityDate);

    const Real f0 = 30;

    const Real x0 = 0.0;
    const Real y0 = 0.0;

    const Real beta = 5.0;
    const Real eta  = 5.0;
    const Real lambda = 4.0;
    const Real alpha = 4.0;
    const Real sig = 1.0;

    const ext::shared_ptr<ExtOUWithJumpsProcess> klugeProcess =
        ext::make_shared<ExtOUWithJumpsProcess>(
            ext::make_shared<ExtendedOrnsteinUhlenbeckProcess>(
                    alpha, sig, x0, constant<Real, Real>(0.0)),
            y0, beta, lambda, eta);

    const Real strike = f0;

    const ext::shared_ptr<VanillaOption> option =
        ext::make_shared<VanillaOption>(
            ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
            ext::make_shared<EuropeanExercise>(maturityDate));

    typedef FdSimpleExtOUJumpSwingEngine::Shape Shape;
    const ext::shared_ptr<Shape> shape(ext::make_shared<Shape>());

    const Real ps = std::log(f0)
        - sig*sig/(4*alpha)*(1-std::exp(-2*alpha*t))
        - lambda/beta*std::log((eta-std::exp(-beta*t))/(eta-1.0));

    shape->push_back(Shape::value_type(t, ps));

    const Real expected =
        RichardsonExtrapolation(
            SwingPdePricing(klugeProcess, option, shape), 4.0)(2.0, 1.5);

    const Real stdDev = std::sqrt((((2 - 2*std::exp(-2*beta*t))*lambda)
            /(beta*eta*eta) + ((1 - std::exp(-2*alpha*t))*sig*sig)/alpha)/2.);

    const Real bsNPV = blackFormula(Option::Call, strike, f0, stdDev);

    const Real g1 = ((2 - 2*std::exp(-3*beta*t))*lambda)/(beta*eta*eta*eta)
        / (stdDev*stdDev*stdDev);

    const Real g2 = 3*(std::exp((alpha + beta)*t)
        *  square<Real>()(2*alpha*std::exp(2*alpha*t)*(-1 + std::exp(2*beta*t))
                  *lambda + beta*std::exp(2*beta*t)*(-1 + std::exp(2*alpha*t))
                  *eta*eta*sig*sig)
            + 16*alpha*alpha*beta*std::exp((5*alpha + 3*beta)*t)*lambda
                *std::sinh(2*beta*t))
        / (4.*alpha*alpha*beta*beta
                *std::exp(5*(alpha + beta)*t)*eta*eta*eta*eta)
        / (stdDev*stdDev*stdDev*stdDev) - 3.0;

    const Real d = (std::log(f0/strike) + 0.5*stdDev*stdDev)/stdDev;

    // Jurczenko E., Maillet B. and Negrea B.,
    // Multi-Moment Approximate Option Pricing Models:
    // A General Comparison (Part 1)
    // https://papers.ssrn.com/sol3/papers.cfm?abstract_id=300922
    const NormalDistribution n;
    const Real q3 = 1/Factorial::get(3)*f0*stdDev*(2*stdDev - d)*n(d);
    const Real q4 = 1/Factorial::get(4)*f0*stdDev*(d*d - 3*d*stdDev - 1)*n(d);
    const Real q5 = 10/Factorial::get(6)*f0*stdDev*(
        d*d*d*d - 5*d*d*d*stdDev - 6*d*d + 15*d*stdDev + 3)*n(d);

    // Corrado C. and T. Su, (1996-b),
    // Skewness and Kurtosis in S&P 500 IndexReturns Implied by Option Prices,
    // Journal of Financial Research 19 (2), 175-192.
    const Real ccs3 = bsNPV + g1*q3;
    const Real ccs4 = ccs3 + g2*q4;

    // Rubinstein M., (1998), Edgeworth Binomial Trees,
    // Journal of Derivatives 5 (3), 20-27.
    const Real cr = ccs4 + g1*g1*q5;

    const Volatility expectedImplVol = blackFormulaImpliedStdDevLiRS(
        Option::Call, strike, f0, expected, 1.0)/std::sqrt(t);

    const Volatility bsImplVol = blackFormulaImpliedStdDevLiRS(
        Option::Call, strike, f0, bsNPV, 1.0)/std::sqrt(t);

    const Volatility ccs3ImplVol = blackFormulaImpliedStdDevLiRS(
        Option::Call, strike, f0, ccs3, 1.0)/std::sqrt(t);

    const Volatility ccs4ImplVol = blackFormulaImpliedStdDevLiRS(
        Option::Call, strike, f0, ccs4, 1.0)/std::sqrt(t);

    const Volatility crImplVol = blackFormulaImpliedStdDevLiRS(
        Option::Call, strike, f0, cr, 1.0)/std::sqrt(t);

    const Real tol[] = {0.01, 0.0075, 0.005, 0.004};
    const std::string methods[] = {
        "Second Order", "Third Order", "Fourth Order", "Rubinstein"};

    const Real calculated[] = {bsImplVol, ccs3ImplVol, ccs4ImplVol, crImplVol};

    for (Size i=0; i < 4; ++i) {
        const Real diff = std::fabs(calculated[i] - expectedImplVol);
        if (diff > tol[i]) {
            BOOST_ERROR("failed to reproduce vanilla option implied volatility "
                    "with moment matching"
                    << "\n    calculated: " << calculated[i]
                    << "\n    expected:   " << expectedImplVol
                    << "\n    difference: " << diff
                    << "\n    tolerance:  " << tol[i]
                    << "\n    method:     " << methods[i]);
        }
    }
}

test_suite* SwingOptionTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Swing-Option Test");

    suite->add(QUANTLIB_TEST_CASE(
        &SwingOptionTest::testExtendedOrnsteinUhlenbeckProcess));
    suite->add(QUANTLIB_TEST_CASE(&SwingOptionTest::testFdBSSwingOption));
    suite->add(QUANTLIB_TEST_CASE(
                          &SwingOptionTest::testFdmExponentialJump1dMesher));
    suite->add(QUANTLIB_TEST_CASE(
                          &SwingOptionTest::testKlugeChFVanillaPricing));

    if (speed <= Fast) {
        suite->add(QUANTLIB_TEST_CASE(
            &SwingOptionTest::testExtOUJumpVanillaEngine));
        suite->add(QUANTLIB_TEST_CASE(
            &SwingOptionTest::testExtOUJumpSwingOption));
    }

    return suite;
}


]]></document_content>
  </document>
  <document index="277">
    <source>swingoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_swing_option_hpp
#define quantlib_test_swing_option_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class SwingOptionTest {
  public:
    static void testExtendedOrnsteinUhlenbeckProcess();
    static void testFdBSSwingOption();
    static void testExtOUJumpSwingOption();
    static void testFdmExponentialJump1dMesher();
    static void testExtOUJumpVanillaEngine();
    static void testKlugeChFVanillaPricing();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="278">
    <source>termstructures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "termstructures.hpp"
#include "utilities.hpp"
#include <ql/termstructures/yield/compositezeroyieldstructure.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/impliedtermstructure.hpp>
#include <ql/termstructures/yield/forwardspreadedtermstructure.hpp>
#include <ql/termstructures/yield/zerospreadedtermstructure.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/math/comparison.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/currency.hpp>
#include <ql/utilities/dataformatters.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace term_structures_test {

    struct Datum {
        Integer n;
        TimeUnit units;
        Rate rate;
    };

    struct CommonVars {
        // common data
        Calendar calendar;
        Natural settlementDays;
        ext::shared_ptr<YieldTermStructure> termStructure;
        ext::shared_ptr<YieldTermStructure> dummyTermStructure;

        // cleanup
        SavedSettings backup;

        // setup
        CommonVars() {
            calendar = TARGET();
            settlementDays = 2;
            Date today = calendar.adjust(Date::todaysDate());
            Settings::instance().evaluationDate() = today;
            Date settlement = calendar.advance(today,settlementDays,Days);
            Datum depositData[] = {
                { 1, Months, 4.581 },
                { 2, Months, 4.573 },
                { 3, Months, 4.557 },
                { 6, Months, 4.496 },
                { 9, Months, 4.490 }
            };
            Datum swapData[] = {
                {  1, Years, 4.54 },
                {  5, Years, 4.99 },
                { 10, Years, 5.47 },
                { 20, Years, 5.89 },
                { 30, Years, 5.96 }
            };
            Size deposits = LENGTH(depositData),
                swaps = LENGTH(swapData);

            std::vector<ext::shared_ptr<RateHelper> > instruments(
                                                              deposits+swaps);
            for (Size i=0; i<deposits; i++) {
                instruments[i] = ext::shared_ptr<RateHelper>(new
                    DepositRateHelper(depositData[i].rate/100,
                                      depositData[i].n*depositData[i].units,
                                      settlementDays, calendar,
                                      ModifiedFollowing, true,
                                      Actual360()));
            }
            ext::shared_ptr<IborIndex> index(new IborIndex("dummy",
                                                             6*Months,
                                                             settlementDays,
                                                             Currency(),
                                                             calendar,
                                                             ModifiedFollowing,
                                                             false,
                                                             Actual360()));
            for (Size i=0; i<swaps; ++i) {
                instruments[i+deposits] = ext::shared_ptr<RateHelper>(new
                    SwapRateHelper(swapData[i].rate/100,
                                   swapData[i].n*swapData[i].units,
                                   calendar,
                                   Annual, Unadjusted, Thirty360(Thirty360::BondBasis),
                                   index));
            }
            termStructure = ext::shared_ptr<YieldTermStructure>(new
                PiecewiseYieldCurve<Discount,LogLinear>(settlement,
                                                        instruments, Actual360()));
            dummyTermStructure = ext::shared_ptr<YieldTermStructure>(new
                PiecewiseYieldCurve<Discount,LogLinear>(settlement,
                                                        instruments, Actual360()));
        }
    };

    Real sub(Real x, Real y) { return x - y; }
}

void TermStructureTest::testReferenceChange() {

    BOOST_TEST_MESSAGE("Testing term structure against evaluation date change...");

    using namespace term_structures_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> flatRate (new SimpleQuote);
    Handle<Quote> flatRateHandle(flatRate);
    vars.termStructure = ext::shared_ptr<YieldTermStructure>(
                          new FlatForward(vars.settlementDays, NullCalendar(),
                                          flatRateHandle, Actual360()));
    Date today = Settings::instance().evaluationDate();
    flatRate->setValue(.03);
    Integer days[] = { 10, 30, 60, 120, 360, 720 };
    Size i;

    std::vector<DiscountFactor> expected(LENGTH(days));
    for (i=0; i<LENGTH(days); i++)
        expected[i] = vars.termStructure->discount(today+days[i]);

    Settings::instance().evaluationDate() = today+30;
    std::vector<DiscountFactor> calculated(LENGTH(days));
    for (i=0; i<LENGTH(days); i++)
        calculated[i] = vars.termStructure->discount(today+30+days[i]);

    for (i=0; i<LENGTH(days); i++) {
        if (!close(expected[i],calculated[i]))
            BOOST_ERROR("\n  Discount at " << days[i] << " days:\n"
                        << std::setprecision(12)
                        << "    before date change: " << expected[i] << "\n"
                        << "    after date change:  " << calculated[i]);
    }
}


void TermStructureTest::testImplied() {

    BOOST_TEST_MESSAGE("Testing consistency of implied term structure...");

    using namespace term_structures_test;

    CommonVars vars;

    Real tolerance = 1.0e-10;
    Date today = Settings::instance().evaluationDate();
    Date newToday = today + 3*Years;
    Date newSettlement = vars.calendar.advance(newToday,
                                               vars.settlementDays,Days);
    Date testDate = newSettlement + 5*Years;
    ext::shared_ptr<YieldTermStructure> implied(
        new ImpliedTermStructure(Handle<YieldTermStructure>(vars.termStructure),
                                 newSettlement));
    DiscountFactor baseDiscount = vars.termStructure->discount(newSettlement);
    DiscountFactor discount = vars.termStructure->discount(testDate);
    DiscountFactor impliedDiscount = implied->discount(testDate);
    if (std::fabs(discount - baseDiscount*impliedDiscount) > tolerance)
        BOOST_ERROR(
            "unable to reproduce discount from implied curve\n"
            << std::fixed << std::setprecision(10)
            << "    calculated: " << baseDiscount*impliedDiscount << "\n"
            << "    expected:   " << discount);
}

void TermStructureTest::testImpliedObs() {

    BOOST_TEST_MESSAGE("Testing observability of implied term structure...");

    using namespace term_structures_test;

    CommonVars vars;

    Date today = Settings::instance().evaluationDate();
    Date newToday = today + 3*Years;
    Date newSettlement = vars.calendar.advance(newToday,
                                               vars.settlementDays,Days);
    RelinkableHandle<YieldTermStructure> h;
    ext::shared_ptr<YieldTermStructure> implied(
                                  new ImpliedTermStructure(h, newSettlement));
    Flag flag;
    flag.registerWith(implied);
    h.linkTo(vars.termStructure);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of term structure change");
}

void TermStructureTest::testFSpreaded() {

    BOOST_TEST_MESSAGE("Testing consistency of forward-spreaded term structure...");

    using namespace term_structures_test;

    CommonVars vars;

    Real tolerance = 1.0e-10;
    ext::shared_ptr<Quote> me(new SimpleQuote(0.01));
    Handle<Quote> mh(me);
    ext::shared_ptr<YieldTermStructure> spreaded(
        new ForwardSpreadedTermStructure(
            Handle<YieldTermStructure>(vars.termStructure),mh));
    Date testDate = vars.termStructure->referenceDate() + 5*Years;
    DayCounter tsdc  = vars.termStructure->dayCounter();
    DayCounter sprdc = spreaded->dayCounter();
    Rate forward = vars.termStructure->forwardRate(testDate, testDate, tsdc,
                                                   Continuous, NoFrequency);
    Rate spreadedForward = spreaded->forwardRate(testDate, testDate, sprdc,
                                                 Continuous, NoFrequency);
    if (std::fabs(forward - (spreadedForward-me->value())) > tolerance)
        BOOST_ERROR(
            "unable to reproduce forward from spreaded curve\n"
            << std::setprecision(10)
            << "    calculated: "
            << io::rate(spreadedForward-me->value()) << "\n"
            << "    expected:   " << io::rate(forward));
}

void TermStructureTest::testFSpreadedObs() {

    BOOST_TEST_MESSAGE("Testing observability of forward-spreaded "
                       "term structure...");

    using namespace term_structures_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> me(new SimpleQuote(0.01));
    Handle<Quote> mh(me);
    RelinkableHandle<YieldTermStructure> h; //(vars.dummyTermStructure);
    ext::shared_ptr<YieldTermStructure> spreaded(
        new ForwardSpreadedTermStructure(h,mh));
    Flag flag;
    flag.registerWith(spreaded);
    h.linkTo(vars.termStructure);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of term structure change");
    flag.lower();
    me->setValue(0.005);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of spread change");
}

void TermStructureTest::testZSpreaded() {

    BOOST_TEST_MESSAGE("Testing consistency of zero-spreaded term structure...");

    using namespace term_structures_test;

    CommonVars vars;

    Real tolerance = 1.0e-10;
    ext::shared_ptr<Quote> me(new SimpleQuote(0.01));
    Handle<Quote> mh(me);
    ext::shared_ptr<YieldTermStructure> spreaded(
        new ZeroSpreadedTermStructure(
            Handle<YieldTermStructure>(vars.termStructure),mh));
    Date testDate = vars.termStructure->referenceDate() + 5*Years;
    DayCounter rfdc  = vars.termStructure->dayCounter();
    Rate zero = vars.termStructure->zeroRate(testDate, rfdc,
                                             Continuous, NoFrequency);
    Rate spreadedZero = spreaded->zeroRate(testDate, rfdc,
                                           Continuous, NoFrequency);
    if (std::fabs(zero - (spreadedZero-me->value())) > tolerance)
        BOOST_ERROR(
            "unable to reproduce zero yield from spreaded curve\n"
            << std::setprecision(10)
            << "    calculated: " << io::rate(spreadedZero-me->value()) << "\n"
            << "    expected:   " << io::rate(zero));
}

void TermStructureTest::testZSpreadedObs() {

    BOOST_TEST_MESSAGE("Testing observability of zero-spreaded term structure...");

    using namespace term_structures_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> me(new SimpleQuote(0.01));
    Handle<Quote> mh(me);
    RelinkableHandle<YieldTermStructure> h(vars.dummyTermStructure);

    ext::shared_ptr<YieldTermStructure> spreaded(
        new ZeroSpreadedTermStructure(h,mh));
    Flag flag;
    flag.registerWith(spreaded);
    h.linkTo(vars.termStructure);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of term structure change");
    flag.lower();
    me->setValue(0.005);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of spread change");
}

void TermStructureTest::testCreateWithNullUnderlying() {
    BOOST_TEST_MESSAGE(
        "Testing that a zero-spreaded curve can be created with "
        "a null underlying curve...");

    using namespace term_structures_test;

    CommonVars vars;

    Handle<Quote> spread(ext::shared_ptr<Quote>(new SimpleQuote(0.01)));
    RelinkableHandle<YieldTermStructure> underlying;
    // this shouldn't throw
    ext::shared_ptr<YieldTermStructure> spreaded(
        new ZeroSpreadedTermStructure(underlying,spread));
    // if we do this, the curve can work.
    underlying.linkTo(vars.termStructure);
    // check that we can use it
    spreaded->referenceDate();
}

void TermStructureTest::testLinkToNullUnderlying() {
    BOOST_TEST_MESSAGE(
        "Testing that an underlying curve can be relinked to "
        "a null underlying curve...");

    using namespace term_structures_test;

    CommonVars vars;

    Handle<Quote> spread(ext::shared_ptr<Quote>(new SimpleQuote(0.01)));
    RelinkableHandle<YieldTermStructure> underlying(vars.termStructure);
    ext::shared_ptr<YieldTermStructure> spreaded(
        new ZeroSpreadedTermStructure(underlying,spread));
    // check that we can use it
    spreaded->referenceDate();
    // if we do this, the curve can't work anymore. But it shouldn't
    // throw as long as we don't try to use it.
    underlying.linkTo(ext::shared_ptr<YieldTermStructure>());
}

void TermStructureTest::testCompositeZeroYieldStructures() {
    BOOST_TEST_MESSAGE(
        "Testing composite zero yield structures...");

    using namespace term_structures_test;

    SavedSettings backup;
    Settings::instance().evaluationDate() = Date(10, Nov, 2017);

    // First curve
    std::vector<Date> dates = {Date(10, Nov, 2017), Date(13, Nov, 2017), Date(12, Feb, 2018),
                               Date(10, May, 2018), Date(10, Aug, 2018), Date(12, Nov, 2018),
                               Date(21, Dec, 2018), Date(15, Jan, 2020), Date(31, Mar, 2021),
                               Date(28, Feb, 2023), Date(21, Dec, 2026), Date(31, Jan, 2030),
                               Date(28, Feb, 2031), Date(31, Mar, 2036), Date(28, Feb, 2041),
                               Date(28, Feb, 2048), Date(31, Dec, 2141)};

    std::vector<Rate> rates = {0.0655823213132524, 0.0655823213132524, 0.0699455024156877,
                               0.0799107139233497, 0.0813931951022577, 0.0841615820666691,
                               0.0501297919004145, 0.0823483583439658, 0.0860720030924466,
                               0.0922887604375688, 0.10588902278996,   0.117021968693922,
                               0.109824660896137,  0.109231572878364,  0.119218123236241,
                               0.128647300167664,  0.0506086995288751};

    ext::shared_ptr<YieldTermStructure> termStructure1 = ext::shared_ptr<YieldTermStructure>(
        new ForwardCurve(dates, rates, Actual365Fixed(), NullCalendar()));

    // Second curve
    dates = {Date(10, Nov, 2017), Date(13, Nov, 2017), Date(11, Dec, 2017), Date(12, Feb, 2018),
             Date(10, May, 2018), Date(31, Jan, 2022), Date(7, Dec, 2023),  Date(31, Jan, 2025),
             Date(31, Mar, 2028), Date(7, Dec, 2033),  Date(1, Feb, 2038),  Date(2, Apr, 2046),
             Date(2, Jan, 2051),  Date(31, Dec, 2141)};

    rates = {0.056656806197189,  0.056656806197189,  0.0419541633454473, 0.0286681050019797,
             0.0148840226959593, 0.0246680238374363, 0.0255349067810599, 0.0298907184711927,
             0.0263943927922053, 0.0291924526539802, 0.0270049276163556, 0.028775807327614,
             0.0293567711641792, 0.010518655099659};

    ext::shared_ptr<YieldTermStructure> termStructure2 = ext::shared_ptr<YieldTermStructure>(
        new ForwardCurve(dates, rates, Actual365Fixed(), NullCalendar()));

    typedef Real(*binary_f)(Real, Real);

    ext::shared_ptr<YieldTermStructure> compoundCurve = ext::shared_ptr<YieldTermStructure>(
        new CompositeZeroYieldStructure<binary_f>(Handle<YieldTermStructure>(termStructure1), Handle<YieldTermStructure>(termStructure2), sub));

    // Expected values
    dates = {Date(10, Nov, 2017), Date(15, Dec, 2017), Date(15, Jun, 2018), Date(15, Sep, 2029),
             Date(15, Sep, 2038), Date(15, Mar, 2046), Date(15, Dec, 2141)};

    rates = {0.00892551511527986, 0.0278755322562788, 0.0512001768603456, 0.0729941474263546,
             0.0778333309498459,  0.0828451659139004, 0.0503573807521742};

    Real tolerance = 1.0e-10;
    for (Size i = 0; i < dates.size(); ++i) {
        Rate actual = compoundCurve->zeroRate(dates[i], Actual365Fixed(), Continuous).rate();
        Rate expected = rates[i];

        if (std::fabs(actual - expected) > tolerance)
            BOOST_ERROR(
                "unable to reproduce zero yield rate from composite input curve\n"
                << std::fixed << std::setprecision(10)
                << "    calculated: " << actual << "\n"
                << "    expected:   " << expected);
    }
}

test_suite* TermStructureTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Term structure tests");
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testReferenceChange));
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testImplied));
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testImpliedObs));
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testFSpreaded));
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testFSpreadedObs));
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testZSpreaded));
    suite->add(QUANTLIB_TEST_CASE(&TermStructureTest::testZSpreadedObs));
    suite->add(QUANTLIB_TEST_CASE(
                         &TermStructureTest::testCreateWithNullUnderlying));
    suite->add(QUANTLIB_TEST_CASE(
                             &TermStructureTest::testLinkToNullUnderlying));
    suite->add(QUANTLIB_TEST_CASE(
                    &TermStructureTest::testCompositeZeroYieldStructures));
    return suite;
}

]]></document_content>
  </document>
  <document index="279">
    <source>termstructures.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_term_structures_hpp
#define quantlib_test_term_structures_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TermStructureTest {
  public:
    static void testReferenceChange();
    static void testImplied();
    static void testImpliedObs();
    static void testFSpreaded();
    static void testFSpreadedObs();
    static void testZSpreaded();
    static void testZSpreadedObs();
    static void testCreateWithNullUnderlying();
    static void testLinkToNullUnderlying();
    static void testCompositeZeroYieldStructures();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="280">
    <source>timegrid.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
This file is part of QuantLib, a free - software / open - source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software : you can redistribute it and/or modify it
under the terms of the QuantLib license.You should have received a
copy of the license along with this program; if not, please email
<quantlib - dev@lists.sf.net>.The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.See the license for more details.
*/

#include "ql/timegrid.hpp"
#include "timegrid.hpp"
#include "utilities.hpp"

#include <iostream>
#include <vector>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void TimeGridTest::testConstructorAdditionalSteps()
{
    BOOST_TEST_MESSAGE("Testing TimeGrid construction with additional steps...");

    const TimeGrid tg = {{1.0, 2.0, 4.0}, 8};

    // Expect 8 evenly sized steps over the interval [0, 4].
    std::vector<Time> expected_times = {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0};

    BOOST_CHECK_EQUAL_COLLECTIONS(tg.begin(), tg.end(), expected_times.begin(),
                                  expected_times.end());
}

void TimeGridTest::testConstructorMandatorySteps()
{
    BOOST_TEST_MESSAGE("Testing TimeGrid construction with only mandatory points...");

    const TimeGrid tg = {0.0, 1.0, 2.0, 4.0};

    // Time grid must include all times from passed iterator.
    // Further no additional times can be added.
    std::vector<Time> expected_times = {0.0, 1.0, 2.0, 4.0};

    BOOST_CHECK_EQUAL_COLLECTIONS(
        tg.begin(), tg.end(), expected_times.begin(), expected_times.end());
}

void TimeGridTest::testConstructorEvenSteps()
{
    BOOST_TEST_MESSAGE("Testing TimeGrid construction with n evenly spaced points...");
    
    Time end_time = 10;
    Size steps = 5;
    const TimeGrid tg(end_time, steps);

    std::vector<Time> expected_times = {0.0, 2.0, 4.0, 6.0, 8.0, 10.0};
    
    BOOST_CHECK_EQUAL_COLLECTIONS(
        tg.begin(), tg.end(), expected_times.begin(), expected_times.end()
    );
}

void TimeGridTest::testConstructorEmptyIterator()
{
    BOOST_TEST_MESSAGE(
        "Testing that the TimeGrid constructor raises an error for empty iterators..."
    );
    
    const std::vector<Time> times;
    BOOST_CHECK_THROW(const TimeGrid tg(times.begin(), times.end()), Error);
}

void TimeGridTest::testConstructorNegativeValuesInIterator()
{
    BOOST_TEST_MESSAGE("Testing that the TimeGrid constructor raises an error for negative time values...");
    
    std::vector<Time> times = {-3.0, 1.0, 4.0, 5.0};
    BOOST_CHECK_THROW(const TimeGrid tg(times.begin(), times.end()), Error);
}

void TimeGridTest::testClosestIndex()
{
    BOOST_TEST_MESSAGE("Testing that the returned index is closest to the requested time...");

    const TimeGrid tg = {1.0, 2.0, 5.0};
    const Size expected_index = 3;
    
    QL_ASSERT(tg.closestIndex(4) == expected_index,
              "Expected index: " << expected_index << ", which does not match " <<
              "the returned index: " << tg.closestIndex(4));
}

void TimeGridTest::testClosestTime()
{
    BOOST_TEST_MESSAGE("Testing that the returned time matches the requested index...");
    const TimeGrid tg = {1.0, 2.0, 5.0};
    const Size expected_time = 5;
    
    QL_ASSERT(tg.closestTime(4) == expected_time,
              "Expected time of: " << expected_time << ", which does not match " <<
              "the returned time: " << tg.closestTime(4));
}

void TimeGridTest::testMandatoryTimes()
{
    BOOST_TEST_MESSAGE("Testing that mandatory times are recalled correctly...");
    std::vector<Time> test_times = {1.0, 2.0, 4.0};
    const TimeGrid tg(test_times.begin(), test_times.end(), 8);
    
    // Mandatory times are those provided by the original iterator.
    const std::vector<Time>& tg_mandatory_times = tg.mandatoryTimes();
    BOOST_CHECK_EQUAL_COLLECTIONS(
        tg_mandatory_times.begin(), tg_mandatory_times.end(),
        test_times.begin(), test_times.end());
}

test_suite* TimeGridTest::suite()
{
    auto* suite = BOOST_TEST_SUITE("Timegrid tests");

    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testConstructorAdditionalSteps));
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testConstructorMandatorySteps));
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testConstructorEvenSteps));
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testConstructorEmptyIterator));
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testConstructorNegativeValuesInIterator));
    
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testClosestIndex));
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testClosestTime));
    suite->add(QUANTLIB_TEST_CASE(&TimeGridTest::testMandatoryTimes));
    
    return suite;
}
]]></document_content>
  </document>
  <document index="281">
    <source>timegrid.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
This file is part of QuantLib, a free - software / open - source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software : you can redistribute it and/or modify it
under the terms of the QuantLib license.You should have received a
copy of the license along with this program; if not, please email
<quantlib - dev@lists.sf.net>.The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.See the license for more details.
*/

#ifndef quantlib_test_time_grid_hpp
#define quantlib_test_time_grid_hpp

#include <boost/test/unit_test.hpp>

class TimeGridTest {
public:
    static void testConstructorAdditionalSteps();
    static void testConstructorMandatorySteps();
    static void testConstructorEvenSteps();
    static void testConstructorEmptyIterator();
    static void testConstructorNegativeValuesInIterator();
    
    static void testClosestIndex();
    static void testClosestTime();
    static void testMandatoryTimes();
    
    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
  <document index="282">
    <source>timeseries.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2010 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "timeseries.hpp"
#include "utilities.hpp"
#include <ql/timeseries.hpp>
#include <ql/prices.hpp>
#include <ql/time/calendars/unitedstates.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif

#include <boost/unordered_map.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

using namespace QuantLib;
using namespace boost::unit_test_framework;

void TimeSeriesTest::testConstruction() {

    BOOST_TEST_MESSAGE("Testing time series construction...");

    TimeSeries<Real> ts;
    ts[Date(25, March, 2005)] = 1.2;
    ts[Date(29, March, 2005)] = 2.3;
    ts[Date(15, March, 2005)] = 0.3;

    auto cur = ts.begin();
    if (cur->first != Date(15, March, 2005)) {
        BOOST_ERROR("date does not match");
    }
    if (cur->second != 0.3) {
        BOOST_ERROR("value does not match");
    }

    ts[Date(15, March, 2005)] = 4.0;
    cur = ts.begin();
    if (cur->second != 4.0) {
        BOOST_ERROR("replaced value does not match" << cur->second << "\n");
    }

    ts[Date(15, March, 2005)] = 3.5;

    if (cur->second != 3.5) {
        BOOST_ERROR("set value operator not match" << cur->second << "\n");
    }
}

void TimeSeriesTest::testIntervalPrice() {
    BOOST_TEST_MESSAGE("Testing time series interval price...");

    std::vector<Date> date = {Date(25, March, 2005), Date(29, March, 2005)};

    std::vector<Real> open = {1.3, 2.3},
                      close = {2.3, 3.4},
                      high = {3.4, 3.5},
                      low = {3.4, 3.2};

    TimeSeries<IntervalPrice> tsiq = IntervalPrice::makeSeries(date,
                                                               open,
                                                               close,
                                                               high,
                                                               low);
}

void TimeSeriesTest::testIterators() {
    BOOST_TEST_MESSAGE("Testing time series iterators...");

    std::vector<Date> dates = {Date(25, March, 2005),
                               Date(29, March, 2005),
                               Date(15, March, 2005)};

    std::vector<Real> prices = {25, 23, 20};

    TimeSeries<Real> ts(dates.begin(), dates.end(), prices.begin());

    // projection iterators

    std::copy(ts.cbegin_time(), ts.cend_time(), dates.begin());
    if (dates[0] != Date(15, March, 2005)) {
        BOOST_ERROR("date does not match");
    }

    std::copy(ts.cbegin_values(), ts.cend_values(), prices.begin());
    if (prices[0] != 20) {
        BOOST_ERROR("value does not match");
    }

    dates = ts.dates(); 
    if (dates[0] != Date(15, March, 2005)) {
        BOOST_ERROR("date does not match");
    }

    prices = ts.values();
    if (prices[0] != 20) {
        BOOST_ERROR("value does not match");
    }

    // unordered container
    typedef TimeSeries<int, boost::unordered_map<Date, int> >
                                                          TimeSeriesUnordered;
    TimeSeriesUnordered ts1;
    Date d0(25, March, 2005), d1(25, April, 2005), d = d0;
    UnitedStates calendar(UnitedStates::NYSE);
    for (int i = 0; d < d1; ++i, d = calendar.advance(d, 1, Days)) {
        ts1[d] = i;
    }

    d = d0;
    for (int i = 0; d < d1; ++i, d = calendar.advance(d, 1, Days)) {
        if (ts1[d] != int(i)) {
            BOOST_ERROR("value does not match");
        }
    }

    // reverse iterators

    std::vector<std::pair<Date,Real> > data(prices.size());
    std::copy(ts.crbegin(), ts.crend(), data.begin());
    if (data[2].second != 20) {
        BOOST_ERROR("value does not match");
    }
    if (data[2].first != Date(15, March, 2005)) {
        BOOST_ERROR("date does not match");
    }

    std::copy(ts.crbegin_time(), ts.crend_time(), dates.begin());
    if (dates[0] != Date(29, March, 2005)) {
        BOOST_ERROR("date does not match");
    }

    std::copy(ts.crbegin_values(), ts.crend_values(), prices.begin());
    if (prices[0] != 23) {
        BOOST_ERROR("value does not match");
    }

    // The following should not compile:
    // std::transform(ts1.crbegin(), ts1.crend(), prices.begin(),
    //                TimeSeriesUnordered::get_value);
    // std::copy(ts1.crbegin_values(), ts1.crend_values(), prices.begin());
    // ts1.lastDate();

    // last date 
    if (ts.lastDate() != Date(29, March, 2005)) {
        BOOST_ERROR("lastDate does not match");
    }
}

test_suite* TimeSeriesTest::suite() {
    auto* suite = BOOST_TEST_SUITE("time series tests");
    suite->add(QUANTLIB_TEST_CASE(&TimeSeriesTest::testConstruction));
    suite->add(QUANTLIB_TEST_CASE(&TimeSeriesTest::testIntervalPrice));
    suite->add(QUANTLIB_TEST_CASE(&TimeSeriesTest::testIterators));
    return suite;
}

]]></document_content>
  </document>
  <document index="283">
    <source>timeseries.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_time_series_hpp
#define quantlib_test_time_series_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TimeSeriesTest {
  public:
    static void testConstruction();
    static void testIntervalPrice();
    static void testIterators();
    static boost::unit_test_framework::test_suite* suite();
    
};


#endif
]]></document_content>
  </document>
  <document index="284">
    <source>tqreigendecomposition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "tqreigendecomposition.hpp"
#include "utilities.hpp"
#include <ql/math/matrixutilities/tqreigendecomposition.hpp>

using namespace QuantLib;
using boost::unit_test_framework::test_suite;

void TqrEigenDecompositionTest::testEigenValueDecomposition() {
    BOOST_TEST_MESSAGE("Testing TQR eigenvalue decomposition...");

    Array diag(5);
    Array sub(4,1);
    diag[0]=11; diag[1]=7; diag[2]=6; diag[3]=2; diag[4]=0;
    Real ev[5] = {11.2467832217139119,
                  7.4854967362908535,
                  5.5251516080277518,
                  2.1811760273123308,
                  -0.4386075933448487};

    TqrEigenDecomposition tqre(diag, sub,
                               TqrEigenDecomposition::WithoutEigenVector);
    for (Size i=0; i < diag.size(); ++i) {
        const Real expected(ev[i]);
        const Real calculated(tqre.eigenvalues()[i]);
        Real tolerance = 1.0e-10;
        if (std::fabs(expected-calculated) > tolerance) {
            BOOST_FAIL(std::string("wrong eigenvalue \n")
                       << "calculated: "
                       << calculated
                       <<" expected  : "
                       << expected);
        }
    }
}

void TqrEigenDecompositionTest::testZeroOffDiagEigenValues() {
    BOOST_TEST_MESSAGE("Testing TQR zero-off-diagonal eigenvalues...");

    Array diag(5);
    Array sub(4,1);
    sub[0] =sub[2]=0;
    diag[0]=12; diag[1]=9; diag[2]=6; diag[3]=3; diag[4]=0;

    TqrEigenDecomposition tqre1(diag, sub);

    sub[0]=sub[2]=1e-14;
    TqrEigenDecomposition tqre2(diag, sub);

    for (Size i=0; i < diag.size(); ++i) {
        const Real expected(tqre2.eigenvalues()[i]);
        const Real calculated(tqre1.eigenvalues()[i]);
        Real tolerance = 1.0e-10;
        if (std::fabs(expected-calculated) > tolerance) {
            BOOST_FAIL(std::string("wrong eigenvalue \n")
                       << "calculated: "
                       << calculated
                       << " expected  : "
                       << expected);
        }
    }
}

void TqrEigenDecompositionTest::testEigenVectorDecomposition() {
    BOOST_TEST_MESSAGE("Testing TQR eigenvector decomposition...");

    Array diag(2,1);
    Array sub(1,1);

    TqrEigenDecomposition tqre(diag, sub);
    Real tolerance = 1.0e-10;

    if (std::fabs(0.25 + tqre.eigenvectors()[0][0]
                       * tqre.eigenvectors()[0][1]
                       * tqre.eigenvectors()[1][0]
                       * tqre.eigenvectors()[1][1]) > tolerance) {
        BOOST_FAIL("wrong eigenvector");
    }
}

test_suite* TqrEigenDecompositionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("TQR eigendecomposition tests");
    suite->add(QUANTLIB_TEST_CASE(
                   &TqrEigenDecompositionTest::testEigenValueDecomposition));
    suite->add(QUANTLIB_TEST_CASE(
                   &TqrEigenDecompositionTest::testZeroOffDiagEigenValues));
    suite->add(QUANTLIB_TEST_CASE(
                   &TqrEigenDecompositionTest::testEigenVectorDecomposition));
    return suite;
}

]]></document_content>
  </document>
  <document index="285">
    <source>tqreigendecomposition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_tqr_eigen_decomposition_hpp
#define quantlib_test_tqr_eigen_decomposition_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TqrEigenDecompositionTest {
  public:
    static void testEigenValueDecomposition();
    static void testZeroOffDiagEigenValues();
    static void testEigenVectorDecomposition();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="286">
    <source>tracing.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "tracing.hpp"
#include "utilities.hpp"
#include <ql/utilities/tracing.hpp>
#include <sstream>
#include <iostream>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    class TestCaseCleaner {
      public:
        TestCaseCleaner() = default;
        ~TestCaseCleaner() {
            QL_TRACE_ON(std::cerr);
        }
    };

    void testTraceOutput(bool enable,
#if defined(QL_ENABLE_TRACING)
                         const std::string& result) {
#else
                         const std::string&) {
#endif

        TestCaseCleaner cleaner;

        std::ostringstream output;
        if (enable)
            QL_TRACE_ENABLE;
        else
            QL_TRACE_DISABLE;
        QL_TRACE_ON(output);
        int i = 42;
        QL_TRACE_VARIABLE(i);
        i++;

        #if defined(QL_ENABLE_TRACING)
        std::string expected = result;
        #else
        std::string expected;
        #endif
        if (output.str() != expected) {
            BOOST_FAIL("wrong trace:\n"
                       "    expected:\n"
                       "\""+ expected + "\"\n"
                       "    written:\n"
                       "\""+ output.str() + "\"");
        }
    }

}


void TracingTest::testOutput() {

    BOOST_TEST_MESSAGE("Testing tracing...");

    testTraceOutput(false, "");
    testTraceOutput(true,  "trace[0]: i = 42\n");
}


test_suite* TracingTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Tracing tests");

    suite->add(QUANTLIB_TEST_CASE(&TracingTest::testOutput));
    return suite;
}

]]></document_content>
  </document>
  <document index="287">
    <source>tracing.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_tracing_hpp
#define quantlib_test_tracing_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TracingTest {
  public:
    static void testOutput();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="288">
    <source>transformedgrid.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "transformedgrid.hpp"
#include "utilities.hpp"
#include <ql/math/transformedgrid.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/grid.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

class PlusOne {
public:
    Real operator()(Real x) const { return x+1;};
};

void TransformedGridTest::testConstruction() {

    BOOST_TEST_MESSAGE("Testing transformed grid construction...");

    PlusOne p1;
    Array grid = BoundedGrid(0, 100, 100);
    TransformedGrid tg(grid, p1);
    if (std::fabs(tg.grid(0) - 0.0) > 1e-5) {
        BOOST_ERROR("grid creation failed");
    }

    if (std::fabs(tg.transformedGrid(0) - 1.0) > 1e-5)
        BOOST_ERROR("grid transformation failed");
}

test_suite* TransformedGridTest::suite() {
    auto* suite = BOOST_TEST_SUITE("transformed grid");
    suite->add(QUANTLIB_TEST_CASE(&TransformedGridTest::testConstruction));
    return suite;
}

]]></document_content>
  </document>
  <document index="289">
    <source>transformedgrid.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_transformed_grid_hpp
#define quantlib_test_transformed_grid_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TransformedGridTest {
  public:
    static void testConstruction();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="290">
    <source>twoassetbarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "twoassetbarrieroption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/twoassetbarrieroption.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetbarrierengine.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace {

    struct OptionData {
        Barrier::Type barrierType;
        Option::Type type;
        Real barrier;
        Real strike;
        Real s1;       // spot
        Rate q1;       // dividend
        Volatility v1; // volatility
        Real s2;
        Rate q2;
        Volatility v2;
        Real correlation;
        Rate r;        // risk-free rate
        Real result;   // result
    };

}


void TwoAssetBarrierOptionTest::testHaugValues() {

    BOOST_TEST_MESSAGE("Testing two-asset barrier options against Haug's values...");

    OptionData values[] = {
        /* The data below are from
          "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
        */
        { Barrier::DownOut, Option::Call, 95, 90,
          100.0, 0.0, 0.2, 100.0, 0.0, 0.2, 0.5, 0.08, 6.6592 },
        { Barrier::UpOut, Option::Call, 105, 90,
          100.0, 0.0, 0.2, 100.0, 0.0, 0.2, -0.5, 0.08, 4.6670 },
        { Barrier::DownOut, Option::Put, 95, 90,
          100.0, 0.0, 0.2, 100.0, 0.0, 0.2, -0.5, 0.08, 0.6184 },
        { Barrier::UpOut, Option::Put, 105, 100,
          100.0, 0.0, 0.2, 100.0, 0.0, 0.2, 0.0, 0.08, 0.8246 }
    };

    DayCounter dc = Actual360();
    Calendar calendar = TARGET();
    Date today = Date::todaysDate();
    Date maturity = today + 180;
    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(maturity));

    ext::shared_ptr<SimpleQuote> r(new SimpleQuote);
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, r, dc);

    ext::shared_ptr<SimpleQuote> s1(new SimpleQuote);
    ext::shared_ptr<SimpleQuote> q1(new SimpleQuote);
    ext::shared_ptr<YieldTermStructure> qTS1 = flatRate(today, q1, dc);
    ext::shared_ptr<SimpleQuote> vol1(new SimpleQuote);
    ext::shared_ptr<BlackVolTermStructure> volTS1 = flatVol(today, vol1, dc);

    ext::shared_ptr<BlackScholesMertonProcess> process1(
        new BlackScholesMertonProcess(Handle<Quote>(s1),
                                      Handle<YieldTermStructure>(qTS1),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS1)));

    ext::shared_ptr<SimpleQuote> s2(new SimpleQuote);
    ext::shared_ptr<SimpleQuote> q2(new SimpleQuote);
    ext::shared_ptr<YieldTermStructure> qTS2 = flatRate(today, q2, dc);
    ext::shared_ptr<SimpleQuote> vol2(new SimpleQuote);
    ext::shared_ptr<BlackVolTermStructure> volTS2 = flatVol(today, vol2, dc);

    ext::shared_ptr<BlackScholesMertonProcess> process2(
        new BlackScholesMertonProcess(Handle<Quote>(s2),
                                      Handle<YieldTermStructure>(qTS2),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS2)));

    ext::shared_ptr<SimpleQuote> rho(new SimpleQuote);

    ext::shared_ptr<PricingEngine> engine(
                       new AnalyticTwoAssetBarrierEngine(process1, process2,
                                                         Handle<Quote>(rho)));

    for (auto& value : values) {

        s1->setValue(value.s1);
        q1->setValue(value.q1);
        vol1->setValue(value.v1);

        s2->setValue(value.s2);
        q2->setValue(value.q2);
        vol2->setValue(value.v2);

        rho->setValue(value.correlation);

        r->setValue(value.r);

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));

        TwoAssetBarrierOption barrierOption(value.barrierType, value.barrier, payoff, exercise);
        barrierOption.setPricingEngine(engine);

        Real calculated = barrierOption.NPV();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        Real tolerance = 4.0e-3;
        if (error > tolerance) {
            BOOST_ERROR("failed to reproduce expected price"
                        << "\n    expected:   " << expected
                        << "\n    calculated: " << calculated
                        << "\n    tolerance:  " << tolerance
                        << "\n    error:      " << error);
        }
    }
}

test_suite* TwoAssetBarrierOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Two-asset barrier option tests");
    suite->add(QUANTLIB_TEST_CASE(&TwoAssetBarrierOptionTest::testHaugValues));
    return suite;
}
]]></document_content>
  </document>
  <document index="291">
    <source>twoassetbarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_two_asset_barrier_option_hpp
#define quantlib_test_two_asset_barrier_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TwoAssetBarrierOptionTest {
  public:
    static void testHaugValues();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="292">
    <source>twoassetcorrelationoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "twoassetcorrelationoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/exoticoptions/twoassetcorrelationoption.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetcorrelationengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/time/daycounters/actual360.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void TwoAssetCorrelationOptionTest::testAnalyticEngine() {
    BOOST_TEST_MESSAGE(
        "Testing analytic engine for two-asset correlation option...");

    Date today = Settings::instance().evaluationDate();
    DayCounter dc = Actual360();

    Option::Type type = Option::Call;
    Real strike1 = 50.0;
    Real strike2 = 70.0;
    Date exDate = today + 180;

    ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(exDate);

    TwoAssetCorrelationOption option(type, strike1, strike2, exercise);

    Handle<Quote> underlying1(ext::make_shared<SimpleQuote>(52.0));
    Handle<Quote> underlying2(ext::make_shared<SimpleQuote>(65.0));
    Handle<YieldTermStructure> dividendTS1(flatRate(today, 0.0, dc));
    Handle<YieldTermStructure> dividendTS2(flatRate(today, 0.0, dc));
    Handle<YieldTermStructure> riskFreeTS(flatRate(today, 0.1, dc));
    Handle<BlackVolTermStructure> blackVolTS1(flatVol(today, 0.2, dc));
    Handle<BlackVolTermStructure> blackVolTS2(flatVol(today, 0.3, dc));
    Handle<Quote> correlation(ext::make_shared<SimpleQuote>(0.75));

    ext::shared_ptr<BlackScholesMertonProcess> process1 =
        ext::make_shared<BlackScholesMertonProcess>(underlying1,
                                                      dividendTS1,
                                                      riskFreeTS,
                                                      blackVolTS1);

    ext::shared_ptr<BlackScholesMertonProcess> process2 =
        ext::make_shared<BlackScholesMertonProcess>(underlying2,
                                                      dividendTS2,
                                                      riskFreeTS,
                                                      blackVolTS2);

    option.setPricingEngine(
          ext::make_shared<AnalyticTwoAssetCorrelationEngine>(process1,
                                                                process2,
                                                                correlation));

    Real calculated = option.NPV();
    Real expected = 4.7073;
    Real error = std::fabs(calculated-expected);
    Real tolerance = 1e-4;
    if (error > tolerance)
        BOOST_ERROR("Failed to reproduce holder-extensible option value"
                    << "\n    expected:   " << expected
                    << "\n    calculated: " << calculated
                    << "\n    error:      " << error);
}

test_suite* TwoAssetCorrelationOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Two-asset correlation option tests");

    suite->add(QUANTLIB_TEST_CASE(
       &TwoAssetCorrelationOptionTest::testAnalyticEngine));

    return suite;
}
]]></document_content>
  </document>
  <document index="293">
    <source>twoassetcorrelationoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_two_asset_correlation_options_hpp
#define quantlib_test_two_asset_correlation_options_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class TwoAssetCorrelationOptionTest {
  public:
    static void testAnalyticEngine();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="294">
    <source>ultimateforwardtermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "ultimateforwardtermstructure.hpp"
#include "utilities.hpp"
#include <ql/currencies/europe.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/math/interpolations/loginterpolation.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/termstructures/yield/ultimateforwardtermstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace ultimate_forward_term_structure_test {

    struct Datum {
        Integer n;
        TimeUnit units;
        Rate rate;
    };

    struct LLFRWeight {
        Time ttm;
        Real weight;
    };

    struct CommonVars {
        Date today, settlement;
        Calendar calendar;
        Natural settlementDays;
        Currency ccy;
        BusinessDayConvention businessConvention;
        DayCounter dayCount;
        Frequency fixedFrequency;
        Period floatingTenor;

        ext::shared_ptr<IborIndex> index;
        RelinkableHandle<YieldTermStructure> ftkCurveHandle;

        ext::shared_ptr<Quote> ufrRate;
        Period fsp;
        Real alpha;

        // cleanup
        SavedSettings backup;
        // utilities

        CommonVars() {
            settlementDays = 2;
            businessConvention = Unadjusted;
            dayCount = SimpleDayCounter();
            calendar = NullCalendar();
            ccy = EURCurrency();
            fixedFrequency = Annual;
            floatingTenor = 6 * Months;

            index = ext::shared_ptr<IborIndex>(
                new IborIndex("FTK_IDX", floatingTenor, settlementDays, ccy, calendar,
                              businessConvention, false, dayCount, ftkCurveHandle));

            /* Data source: https://fred.stlouisfed.org/
               Note that these rates are used as a proxy.

               In order to fully replicate the rates published by the Dutch Central Bank
               (with the required accuracy) one needs to use Bloomberg CMPL BID Euribor 6m swap
               rates as stated in the documentation: https://www.toezicht.dnb.nl */
            Datum swapData[] = {{1, Years, -0.00315}, {2, Years, -0.00205}, {3, Years, -0.00144},
                                {4, Years, -0.00068}, {5, Years, 0.00014},  {6, Years, 0.00103},
                                {7, Years, 0.00194},  {8, Years, 0.00288},  {9, Years, 0.00381},
                                {10, Years, 0.00471}, {12, Years, 0.0063},  {15, Years, 0.00808},
                                {20, Years, 0.00973}, {25, Years, 0.01035}, {30, Years, 0.01055},
                                {40, Years, 0.0103},  {50, Years, 0.0103}};

            InterestRate ufr(0.023, dayCount, Compounded, Annual);
            ufrRate = ext::shared_ptr<Quote>(
                new SimpleQuote(ufr.equivalentRate(Continuous, Annual, 1.0)));
            fsp = 20 * Years;
            alpha = 0.1;

            today = calendar.adjust(Date(29, March, 2019));
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today, settlementDays, Days);

            Size nInstruments = LENGTH(swapData);
            std::vector<ext::shared_ptr<RateHelper> > instruments(nInstruments);
            for (Size i = 0; i < nInstruments; i++) {
                instruments[i] = ext::shared_ptr<RateHelper>(new SwapRateHelper(
                    swapData[i].rate, Period(swapData[i].n, swapData[i].units), calendar,
                    fixedFrequency, businessConvention, dayCount, index));
            }

            ext::shared_ptr<YieldTermStructure> ftkCurve(
                new PiecewiseYieldCurve<Discount, LogLinear>(settlement, instruments, dayCount));
            ftkCurve->enableExtrapolation();
            ftkCurveHandle.linkTo(ftkCurve);
        }
    };

    ext::shared_ptr<Quote> calculateLLFR(const Handle<YieldTermStructure>& ts, const Period& fsp) {
        DayCounter dc = ts->dayCounter();
        Real omega = 8.0 / 15.0;
        Time cutOff = ts->timeFromReference(ts->referenceDate() + fsp);

        LLFRWeight llfrWeights[] = {{25.0, 1.0}, {30.0, 0.5}, {40.0, 0.25}, {50.0, 0.125}};
        Size nWeights = LENGTH(llfrWeights);
        Rate llfr = 0.0;
        for (Size j = 0; j < nWeights; j++) {
            LLFRWeight w = llfrWeights[j];
            llfr += w.weight * ts->forwardRate(cutOff, w.ttm, Continuous, NoFrequency, true);
        }
        return ext::shared_ptr<Quote>(new SimpleQuote(omega * llfr));
    }

    Rate calculateExtrapolatedForward(Time t, Time fsp, Rate llfr, Rate ufr, Real alpha) {
        Time deltaT = t - fsp;
        Real beta = (1.0 - std::exp(-alpha * deltaT)) / (alpha * deltaT);
        return ufr + (llfr - ufr) * beta;
    }
}

void UltimateForwardTermStructureTest::testDutchCentralBankRates() {
    BOOST_TEST_MESSAGE("Testing DNB replication of UFR zero annually compounded rates...");

    using namespace ultimate_forward_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<Quote> llfr = calculateLLFR(vars.ftkCurveHandle, vars.fsp);

    ext::shared_ptr<YieldTermStructure> ufrTs(
        new UltimateForwardTermStructure(vars.ftkCurveHandle, Handle<Quote>(llfr),
                                         Handle<Quote>(vars.ufrRate), vars.fsp, vars.alpha));

    // Official annually compounded zero rates published
    // by the Dutch Central Bank: https://statistiek.dnb.nl/
    Datum expectedZeroes[] = {{10, Years, 0.00477}, {20, Years, 0.01004}, {30, Years, 0.01223},
                              {40, Years, 0.01433}, {50, Years, 0.01589}, {60, Years, 0.01702},
                              {70, Years, 0.01785}, {80, Years, 0.01849}, {90, Years, 0.01899},
                              {100, Years, 0.01939}};

    Real tolerance = 1.0e-4;
    Size nRates = LENGTH(expectedZeroes);

    for (Size i = 0; i < nRates; ++i) {
        Period p = expectedZeroes[i].n * expectedZeroes[i].units;
        Date maturity = vars.settlement + p;

        Rate actual = ufrTs->zeroRate(maturity, vars.dayCount, Compounded, Annual).rate();
        Rate expected = expectedZeroes[i].rate;

        if (std::fabs(actual - expected) > tolerance)
            BOOST_ERROR("unable to reproduce zero yield rate from the UFR curve\n"
                        << std::setprecision(5) 
                        << "    calculated: " << actual << "\n"
                        << "    expected:   " << expected << "\n"
                        << "    tenor:       " << p << "\n");
    }
}

void UltimateForwardTermStructureTest::testExtrapolatedForward() {
    BOOST_TEST_MESSAGE("Testing continuous forward rates in extrapolation region...");

    using namespace ultimate_forward_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<Quote> llfr(new SimpleQuote(0.0125));

    ext::shared_ptr<YieldTermStructure> ufrTs(
        new UltimateForwardTermStructure(vars.ftkCurveHandle, Handle<Quote>(llfr),
                                         Handle<Quote>(vars.ufrRate), vars.fsp, vars.alpha));
    Time cutOff = ufrTs->timeFromReference(ufrTs->referenceDate() + vars.fsp);

    Period tenors[] = {
        20 * Years, 30 * Years, 40 * Years, 50 * Years,  60 * Years,
        70 * Years, 80 * Years, 90 * Years, 100 * Years,
    };

    Size nTenors = LENGTH(tenors);

    for (Size i = 0; i < nTenors; ++i) {
        Date maturity = vars.settlement + tenors[i];
        Time t = ufrTs->timeFromReference(maturity);

        Rate actual = ufrTs->forwardRate(cutOff, t, Continuous, NoFrequency, true).rate();
        Rate expected = calculateExtrapolatedForward(t, cutOff, llfr->value(),
                                                     vars.ufrRate->value(), vars.alpha);

        Real tolerance = 1.0e-10;
        if (std::fabs(actual - expected) > tolerance)
            BOOST_ERROR("unable to replicate the forward rate from the UFR curve\n"
                        << std::setprecision(5) 
                        << "    calculated: " << actual << "\n"
                        << "    expected:   " << expected << "\n"
                        << "    tenor:       " << tenors[i] << "\n");
    }
}

void UltimateForwardTermStructureTest::testZeroRateAtFirstSmoothingPoint() {
    BOOST_TEST_MESSAGE("Testing zero rate on the first smoothing point...");

    using namespace ultimate_forward_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<Quote> llfr(new SimpleQuote(0.0125));

    ext::shared_ptr<YieldTermStructure> ufrTs(
        new UltimateForwardTermStructure(vars.ftkCurveHandle, Handle<Quote>(llfr),
                                         Handle<Quote>(vars.ufrRate), vars.fsp, vars.alpha));
    Time cutOff = ufrTs->timeFromReference(ufrTs->referenceDate() + vars.fsp);

    Rate actual = ufrTs->zeroRate(cutOff, Continuous, NoFrequency, true).rate();
    Rate expected = vars.ftkCurveHandle->zeroRate(cutOff, Continuous, NoFrequency, true).rate();

    Real tolerance = 1.0e-10;
    if (std::fabs(actual - expected) > tolerance)
        BOOST_ERROR("unable to replicate the zero rate on the First Smoothing Point\n"
                    << std::setprecision(5) 
                    << "    calculated: " << actual << "\n"
                    << "    expected:   " << expected << "\n"
                    << "    FSP:       " << vars.fsp << "\n");
}

void UltimateForwardTermStructureTest::testThatInspectorsEqualToBaseCurve() {
    BOOST_TEST_MESSAGE("Testing UFR curve inspectors...");

    using namespace ultimate_forward_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<Quote> llfr(new SimpleQuote(0.0125));

    ext::shared_ptr<YieldTermStructure> ufrTs(
        new UltimateForwardTermStructure(vars.ftkCurveHandle, Handle<Quote>(llfr),
                                         Handle<Quote>(vars.ufrRate), vars.fsp, vars.alpha));

    if (ufrTs->dayCounter() != vars.ftkCurveHandle->dayCounter())
        BOOST_ERROR("different day counter on the UFR curve than on the base curve\n"
                    << "    UFR curve: " << ufrTs->dayCounter() << "\n"
                    << "    base curve:   " << vars.ftkCurveHandle->dayCounter() << "\n");

    if (ufrTs->referenceDate() != vars.ftkCurveHandle->referenceDate())
        BOOST_ERROR("different reference date on the UFR curve than on the base curve\n"
                    << "    UFR curve: " << ufrTs->referenceDate() << "\n"
                    << "    base curve:   " << vars.ftkCurveHandle->referenceDate() << "\n");

    if (ufrTs->maxDate() == vars.ftkCurveHandle->maxDate())
        BOOST_ERROR("same max date on the UFR curve as on the base curve\n"
                    << "    UFR curve: " << ufrTs->maxDate() << "\n"
                    << "    base curve:   " << vars.ftkCurveHandle->maxDate() << "\n");

    if (ufrTs->maxTime() == vars.ftkCurveHandle->maxTime())
        BOOST_ERROR("same max time on the UFR curve as on the base curve\n"
                    << "    UFR curve: " << ufrTs->maxTime() << "\n"
                    << "    base curve:   " << vars.ftkCurveHandle->maxTime() << "\n");
}

void UltimateForwardTermStructureTest::testExceptionWhenFspLessOrEqualZero() {
    BOOST_TEST_MESSAGE("Testing exception when the first smoothing point is less than or equal to zero...");

    using namespace ultimate_forward_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<Quote> llfr(new SimpleQuote(0.0125));

    BOOST_CHECK_THROW(
        ext::shared_ptr<YieldTermStructure> ufrTsZeroPeriod(
            new UltimateForwardTermStructure(vars.ftkCurveHandle, Handle<Quote>(llfr),
                                             Handle<Quote>(vars.ufrRate), 0 * Years, vars.alpha)),
        Error);

    BOOST_CHECK_THROW(
        ext::shared_ptr<YieldTermStructure> ufrTsNegativePeriod(
            new UltimateForwardTermStructure(vars.ftkCurveHandle, Handle<Quote>(llfr),
                                             Handle<Quote>(vars.ufrRate), -1 * Years, vars.alpha)),
        Error);
}

void UltimateForwardTermStructureTest::testObservability() {
    BOOST_TEST_MESSAGE("Testing observability of the UFR curve...");

    using namespace ultimate_forward_term_structure_test;

    CommonVars vars;

    ext::shared_ptr<SimpleQuote> llfr(new SimpleQuote(0.0125));
    Handle<Quote> llfr_quote(llfr);
    ext::shared_ptr<SimpleQuote> ufr(new SimpleQuote(0.02));
    Handle<Quote> ufr_handle(ufr);
    ext::shared_ptr<YieldTermStructure> ufrTs(new UltimateForwardTermStructure(
        vars.ftkCurveHandle, llfr_quote, ufr_handle, vars.fsp, vars.alpha));

    Flag flag;
    flag.registerWith(ufrTs);
    llfr->setValue(0.012);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of LLFR change.");
    flag.lower();
    ufr->setValue(0.019);
    if (!flag.isUp())
        BOOST_ERROR("Observer was not notified of UFR change.");
}

test_suite* UltimateForwardTermStructureTest::suite() {
    auto* suite = BOOST_TEST_SUITE("UFR term structure tests");

    suite->add(QUANTLIB_TEST_CASE(&UltimateForwardTermStructureTest::testDutchCentralBankRates));
    suite->add(QUANTLIB_TEST_CASE(&UltimateForwardTermStructureTest::testExtrapolatedForward));
    suite->add(
        QUANTLIB_TEST_CASE(&UltimateForwardTermStructureTest::testZeroRateAtFirstSmoothingPoint));
    suite->add(
        QUANTLIB_TEST_CASE(&UltimateForwardTermStructureTest::testThatInspectorsEqualToBaseCurve));
    suite->add(
        QUANTLIB_TEST_CASE(&UltimateForwardTermStructureTest::testExceptionWhenFspLessOrEqualZero));
    suite->add(QUANTLIB_TEST_CASE(&UltimateForwardTermStructureTest::testObservability));
    return suite;
}
]]></document_content>
  </document>
  <document index="295">
    <source>ultimateforwardtermstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_ultimate_forward_term_structure_hpp
#define quantlib_test_ultimate_forward_term_structure_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class UltimateForwardTermStructureTest {
  public:
    static void testDutchCentralBankRates();
    static void testExtrapolatedForward();
    static void testZeroRateAtFirstSmoothingPoint();
    static void testThatInspectorsEqualToBaseCurve();
    static void testExceptionWhenFspLessOrEqualZero();
    static void testObservability();

    static boost::unit_test_framework::test_suite* suite();
};


#endif]]></document_content>
  </document>
  <document index="296">
    <source>utilities.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "utilities.hpp"
#include <ql/instruments/payoffs.hpp>
#include <ql/indexes/indexmanager.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/calendars/nullcalendar.hpp>

#define CHECK_DOWNCAST(Derived,Description) { \
    ext::shared_ptr<Derived> hd = ext::dynamic_pointer_cast<Derived>(h); \
    if (hd) \
        return Description; \
}

namespace QuantLib {

    std::string payoffTypeToString(const ext::shared_ptr<Payoff>& h) {

        CHECK_DOWNCAST(PlainVanillaPayoff, "plain-vanilla");
        CHECK_DOWNCAST(CashOrNothingPayoff, "cash-or-nothing");
        CHECK_DOWNCAST(AssetOrNothingPayoff, "asset-or-nothing");
        CHECK_DOWNCAST(SuperSharePayoff, "super-share");
        CHECK_DOWNCAST(SuperFundPayoff, "super-fund");
        CHECK_DOWNCAST(PercentageStrikePayoff, "percentage-strike");
        CHECK_DOWNCAST(GapPayoff, "gap");
        CHECK_DOWNCAST(FloatingTypePayoff, "floating-type");

        QL_FAIL("unknown payoff type");
    }


    std::string exerciseTypeToString(const ext::shared_ptr<Exercise>& h) {

        CHECK_DOWNCAST(EuropeanExercise, "European");
        CHECK_DOWNCAST(AmericanExercise, "American");
        CHECK_DOWNCAST(BermudanExercise, "Bermudan");

        QL_FAIL("unknown exercise type");
    }


    ext::shared_ptr<YieldTermStructure>
    flatRate(const Date& today,
             const ext::shared_ptr<Quote>& forward,
             const DayCounter& dc) {
        return ext::shared_ptr<YieldTermStructure>(
                          new FlatForward(today, Handle<Quote>(forward), dc));
    }

    ext::shared_ptr<YieldTermStructure>
    flatRate(const Date& today, Rate forward, const DayCounter& dc) {
        return flatRate(
               today, ext::shared_ptr<Quote>(new SimpleQuote(forward)), dc);
    }

    ext::shared_ptr<YieldTermStructure>
    flatRate(const ext::shared_ptr<Quote>& forward,
             const DayCounter& dc) {
        return ext::shared_ptr<YieldTermStructure>(
              new FlatForward(0, NullCalendar(), Handle<Quote>(forward), dc));
    }

    ext::shared_ptr<YieldTermStructure>
    flatRate(Rate forward, const DayCounter& dc) {
        return flatRate(ext::shared_ptr<Quote>(new SimpleQuote(forward)),
                        dc);
    }


    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const Date& today,
            const ext::shared_ptr<Quote>& vol,
            const DayCounter& dc) {
        return ext::shared_ptr<BlackVolTermStructure>(new
            BlackConstantVol(today, NullCalendar(), Handle<Quote>(vol), dc));
    }

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const Date& today, Volatility vol,
            const DayCounter& dc) {
        return flatVol(today,
                       ext::shared_ptr<Quote>(new SimpleQuote(vol)),
                       dc);
    }

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const ext::shared_ptr<Quote>& vol,
            const DayCounter& dc) {
        return ext::shared_ptr<BlackVolTermStructure>(new
            BlackConstantVol(0, NullCalendar(), Handle<Quote>(vol), dc));
    }

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(Volatility vol,
            const DayCounter& dc) {
        return flatVol(ext::shared_ptr<Quote>(new SimpleQuote(vol)), dc);
    }


    Real relativeError(Real x1, Real x2, Real reference) {
        if (reference != 0.0)
            return std::fabs(x1-x2)/reference;
        else
            // fall back to absolute error
            return std::fabs(x1-x2);
    }


    IndexHistoryCleaner::~IndexHistoryCleaner() {
        IndexManager::instance().clearHistories();
    }

}
]]></document_content>
  </document>
  <document index="297">
    <source>utilities.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_utilities_hpp
#define quantlib_test_utilities_hpp

#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/quote.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/functional.hpp>
#include <boost/test/unit_test.hpp>
#if BOOST_VERSION < 105900
#include <boost/test/floating_point_comparison.hpp>
#else
#include <boost/test/tools/floating_point_comparison.hpp>
#endif
#include <cmath>
#include <iomanip>
#include <numeric>
#include <string>
#include <utility>
#include <vector>

// This makes it easier to use array literals (for new code, use std::vector though)
#define LENGTH(a) (sizeof(a)/sizeof(a[0]))

#define QUANTLIB_TEST_CASE(f) BOOST_TEST_CASE(QuantLib::detail::quantlib_test_case(f))

namespace QuantLib {

    namespace detail {

        // used to avoid no-assertion messages in Boost 1.35
        class quantlib_test_case {
            ext::function<void()> test_;
          public:
            template <class F>
            explicit quantlib_test_case(F test) : test_(test) {}
            void operator()() const {
                Date before = Settings::instance().evaluationDate();
                BOOST_CHECK(true);
                test_();
                Date after = Settings::instance().evaluationDate();
                if (before != after)
                    BOOST_ERROR("Evaluation date not reset"
                                << "\n  before: " << before
                                << "\n  after:  " << after);
            }
            #if BOOST_VERSION <= 105300
            // defined to avoid unused-variable warnings. It doesn't
            // work after Boost 1.53 because the functions were
            // overloaded and the address can't be resolved.
            void _use_check(
                    const void* = &boost::test_tools::check_is_close,
                    const void* = &boost::test_tools::check_is_small) const {}
            #endif
        };

    }

    std::string payoffTypeToString(const ext::shared_ptr<Payoff>&);
    std::string exerciseTypeToString(const ext::shared_ptr<Exercise>&);


    ext::shared_ptr<YieldTermStructure>
    flatRate(const Date& today,
             const ext::shared_ptr<Quote>& forward,
             const DayCounter& dc);

    ext::shared_ptr<YieldTermStructure>
    flatRate(const Date& today,
             Rate forward,
             const DayCounter& dc);

    ext::shared_ptr<YieldTermStructure>
    flatRate(const ext::shared_ptr<Quote>& forward,
             const DayCounter& dc);

    ext::shared_ptr<YieldTermStructure>
    flatRate(Rate forward,
             const DayCounter& dc);


    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const Date& today,
            const ext::shared_ptr<Quote>& volatility,
            const DayCounter& dc);

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const Date& today,
            Volatility volatility,
            const DayCounter& dc);

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const ext::shared_ptr<Quote>& volatility,
            const DayCounter& dc);

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(Volatility volatility,
            const DayCounter& dc);


    Real relativeError(Real x1, Real x2, Real reference);

    //bool checkAbsError(Real x1, Real x2, Real tolerance){
    //    return std::fabs(x1 - x2) < tolerance;
    //};

    class Flag : public QuantLib::Observer {
      private:
        bool up_ = false;

      public:
        Flag() = default;
        void raise() { up_ = true; }
        void lower() { up_ = false; }
        bool isUp() const { return up_; }
        void update() override { raise(); }
    };

    template<class Iterator>
    Real norm(const Iterator& begin, const Iterator& end, Real h) {
        // squared values
        std::vector<Real> f2(end-begin);
        std::transform(begin,end,begin,f2.begin(),
                       std::multiplies<Real>());
        // numeric integral of f^2
        Real I = h * (std::accumulate(f2.begin(),f2.end(),Real(0.0))
                      - 0.5*f2.front() - 0.5*f2.back());
        return std::sqrt(I);
    }


    inline Integer timeToDays(Time t, Integer daysPerYear = 360) {
        return Integer(std::lround(t * daysPerYear));
    }


    // this cleans up index-fixing histories when destroyed
    class IndexHistoryCleaner {
      public:
        IndexHistoryCleaner() = default;
        ~IndexHistoryCleaner();
    };


    // Allow streaming vectors to error messages.

    // The standard forbids defining new overloads in the std
    // namespace, so we have to use a wrapper instead of overloading
    // operator<< to send a vector to the stream directly.
    // Defining the overload outside the std namespace wouldn't work
    // with Boost streams because of ADT name lookup rules.

    template <class T>
    struct vector_streamer {
        explicit vector_streamer(std::vector<T> v) : v(std::move(v)) {}
        std::vector<T> v;
    };

    template <class T>
    vector_streamer<T> to_stream(const std::vector<T>& v) {
        return vector_streamer<T>(v);
    }

    template <class T>
    std::ostream& operator<<(std::ostream& out, const vector_streamer<T>& s) {
        out << "{ ";
        if (!s.v.empty()) {
            for (size_t n=0; n<s.v.size()-1; ++n)
                out << s.v[n] << ", ";
            out << s.v.back();
        }
        out << " }";
        return out;
    }


}


#endif
]]></document_content>
  </document>
  <document index="298">
    <source>variancegamma.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill
Copyright (C) 2018 Roy Zywina

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "variancegamma.hpp"
#include "utilities.hpp"
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/experimental/variancegamma/analyticvariancegammaengine.hpp>
#include <ql/experimental/variancegamma/fftvariancegammaengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, sigma, \
    nu, theta, expected, calculated, \
    error, tolerance) \
    BOOST_FAIL(exerciseTypeToString(exercise) << " " \
    << payoff->optionType() << " option with " \
    << payoffTypeToString(payoff) << " payoff:\n" \
    << "    underlying value: " << s << "\n" \
    << "    strike:           " << payoff->strike() <<"\n" \
    << "    dividend yield:   " << io::rate(q) << "\n" \
    << "    risk-free rate:   " << io::rate(r) << "\n" \
    << "    reference date:   " << today << "\n" \
    << "    maturity:         " << exercise->lastDate() << "\n" \
    << "    sigma:            " << sigma << "\n" \
    << "    nu:               " << nu << "\n" \
    << "    theta:            " << theta << "\n\n" \
    << "    expected   " << greekName << ": " << expected << "\n" \
    << "    calculated " << greekName << ": " << calculated << "\n"\
    << "    error:            " << error << "\n" \
    << "    tolerance:        " << tolerance);

namespace {

    struct VarianceGammaProcessData {
        Real s;        // spot
        Rate q;        // dividend
        Rate r;        // risk-free rate
        Real sigma;
        Real nu;
        Real theta;

    };

    struct VarianceGammaOptionData {
        Option::Type type;
        Real strike;
        Time t;        // time to maturity
    };
}


void VarianceGammaTest::testVarianceGamma() {

    BOOST_TEST_MESSAGE("Testing variance-gamma model for European options...");

    SavedSettings backup;

    VarianceGammaProcessData processes[] = {
    //    spot,    q,    r,sigma,   nu, theta
        { 6000, 0.00, 0.05, 0.20, 0.05, -0.50 },
        { 6000, 0.02, 0.05, 0.15, 0.01, -0.50 }
    };

    VarianceGammaOptionData options[] = {
    //            type,strike,  t
        { Option::Call, 5550, 1.0},
        { Option::Call, 5600, 1.0},
        { Option::Call, 5650, 1.0},
        { Option::Call, 5700, 1.0},
        { Option::Call, 5750, 1.0},
        { Option::Call, 5800, 1.0},
        { Option::Call, 5850, 1.0},
        { Option::Call, 5900, 1.0},
        { Option::Call, 5950, 1.0},
        { Option::Call, 6000, 1.0},
        { Option::Call, 6050, 1.0},
        { Option::Call, 6100, 1.0},
        { Option::Call, 6150, 1.0},
        { Option::Call, 6200, 1.0},
        { Option::Call, 6250, 1.0},
        { Option::Call, 6300, 1.0},
        { Option::Call, 6350, 1.0},
        { Option::Call, 6400, 1.0},
        { Option::Call, 6450, 1.0},
        { Option::Call, 6500, 1.0},
        { Option::Call, 6550, 1.0},
        { Option::Put,  5550, 1.0}
    };

    Real results[LENGTH(processes)][LENGTH(options)] = {
        {
            955.1637, 922.7529, 890.9872, 859.8739, 829.4197, 799.6303, 770.5104, 742.0640,
            714.2943, 687.2032, 660.7921, 635.0613, 610.0103, 585.6379, 561.9416, 538.9186,
            516.5649, 494.8760, 473.8464, 453.4700, 433.7400, 234.4870
        },
        {
            732.8705, 698.5542, 665.1404, 632.6498, 601.1002, 570.5068, 540.8824, 512.2367,
            484.5766, 457.9064, 432.2273, 407.5381, 383.8346, 361.1102, 339.3559, 318.5599,
            298.7087, 279.7864, 261.7751, 244.6552, 228.4057, 130.9974
        }
    };

    Real tol = 0.01;

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();

    for (Size i=0; i<LENGTH(processes); i++) {
        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(processes[i].s));
        ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(processes[i].q));
        ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
        ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(processes[i].r));
        ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

        ext::shared_ptr<VarianceGammaProcess> stochProcess(
            new VarianceGammaProcess(Handle<Quote>(spot),
            Handle<YieldTermStructure>(qTS),
            Handle<YieldTermStructure>(rTS),
            processes[i].sigma,
            processes[i].nu,
            processes[i].theta));

        // Analytic engine
        ext::shared_ptr<PricingEngine> analyticEngine(
            new VarianceGammaEngine(stochProcess));

        // FFT engine
        ext::shared_ptr<FFTVarianceGammaEngine> fftEngine(
            new FFTVarianceGammaEngine(stochProcess));

        // which requires a list of options
        std::vector<ext::shared_ptr<Instrument> > optionList;

        std::vector<ext::shared_ptr<StrikedTypePayoff> > payoffs;
        for (Size j=0; j<LENGTH(options); j++)
        {
            Date exDate = today + timeToDays(options[j].t);
            ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));

            ext::shared_ptr<StrikedTypePayoff> payoff(new
                PlainVanillaPayoff(options[j].type, options[j].strike));
            payoffs.push_back(payoff);

            // Test analytic engine
            ext::shared_ptr<EuropeanOption> option(new EuropeanOption(payoff, exercise));
            option->setPricingEngine(analyticEngine);

            Real calculated = option->NPV();
            Real expected = results[i][j];
            Real error = std::fabs(calculated-expected);

            if (error>tol) {
                REPORT_FAILURE("analytic value", payoff, exercise,
                    processes[i].s, processes[i].q, processes[i].r,
                    today, processes[i].sigma, processes[i].nu,
                    processes[i].theta, expected, calculated,
                    error, tol);  
            }
            optionList.push_back(option);
        }

        // Test FFT engine
        // FFT engine is extremely efficient when sent a list of options to calculate first
        fftEngine->precalculate(optionList);
        for (Size j=0; j<LENGTH(options); j++)
        {
            ext::shared_ptr<VanillaOption> option = ext::static_pointer_cast<VanillaOption>(optionList[j]);
            option->setPricingEngine(fftEngine);

            Real calculated = option->NPV();
            Real expected = results[i][j];
            Real error = std::fabs(calculated-expected);
            if (error>tol) {
                ext::shared_ptr<StrikedTypePayoff> payoff = 
                    ext::dynamic_pointer_cast<StrikedTypePayoff>(option->payoff());
                REPORT_FAILURE("fft value", payoff, option->exercise(),
                    processes[i].s, processes[i].q, processes[i].r,
                    today, processes[i].sigma, processes[i].nu,
                    processes[i].theta, expected, calculated,
                    error, tol);
            }
        }
    }
}

void VarianceGammaTest::testSingularityAtZero() {

    BOOST_TEST_MESSAGE(
        "Testing variance-gamma model integration around zero...");

    SavedSettings backup;

    Real stock = 100;
    Real strike = 98;
    Volatility sigma = 0.12;
    Real mu = -0.14;
    Real kappa = 0.2;

    Date valuation(1,Jan,2017);
    Date maturity(10,Jan,2017);
    DayCounter discountCounter = Thirty360(Thirty360::BondBasis);

    Settings::instance().evaluationDate() = valuation;

    ext::shared_ptr<Exercise> exercise =
        ext::make_shared<EuropeanExercise>(maturity);
    ext::shared_ptr<StrikedTypePayoff> payoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Call, strike);
    VanillaOption option(payoff, exercise);

    Handle<YieldTermStructure> dividend(
             ext::make_shared<FlatForward>(valuation,0.0,discountCounter));
    Handle<YieldTermStructure> disc(
             ext::make_shared<FlatForward>(valuation,0.05,discountCounter));
    Handle<Quote> S0(ext::make_shared<SimpleQuote>(stock));
    ext::shared_ptr<QuantLib::VarianceGammaProcess> process =
        ext::make_shared<VarianceGammaProcess>(S0, dividend, disc,
                                                 sigma, kappa, mu);

    option.setPricingEngine(ext::make_shared<VarianceGammaEngine>(process));
    // without the fix, the call below goes into an infinite loop,
    // which is hard to test for.  We're just happy to see the test
    // case finish, hence the lack of an assertion.
    option.NPV();
}


test_suite* VarianceGammaTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Variance Gamma tests");

    suite->add(QUANTLIB_TEST_CASE(&VarianceGammaTest::testVarianceGamma));
    suite->add(QUANTLIB_TEST_CASE(&VarianceGammaTest::testSingularityAtZero));
    return suite;
}
]]></document_content>
  </document>
  <document index="299">
    <source>variancegamma.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2010 Adrian O' Neill
Copyright (C) 2018 Roy Zywina

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_variance_gamma_hpp
#define quantlib_test_variance_gamma_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
comment block of the corresponding class */

class VarianceGammaTest {
public:
    static void testVarianceGamma();
    static void testSingularityAtZero();
    static boost::unit_test_framework::test_suite* suite();
};


#endif

]]></document_content>
  </document>
  <document index="300">
    <source>varianceoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "varianceoption.hpp"
#include "utilities.hpp"
#include <ql/experimental/varianceoption/varianceoption.hpp>
#include <ql/experimental/varianceoption/integralhestonvarianceoptionengine.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/quotes/simplequote.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void VarianceOptionTest::testIntegralHeston() {

    BOOST_TEST_MESSAGE("Testing variance option with integral Heston engine...");

    DayCounter dc = Actual360();
    Date today = Settings::instance().evaluationDate();

    Handle<Quote> s0(ext::make_shared<SimpleQuote>(1.0));
    Handle<YieldTermStructure> qTS;
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(today, rRate, dc));

    Real v0 = 2.0;
    Real kappa = 2.0;
    Real theta = 0.01;
    Real sigma = 0.1;
    Real rho = -0.5;

    ext::shared_ptr<HestonProcess> process(new HestonProcess(rTS, qTS, s0,
                                                               v0, kappa, theta,
                                                               sigma, rho));
    ext::shared_ptr<PricingEngine> engine(
                               new IntegralHestonVarianceOptionEngine(process));

    Real strike = 0.05;
    Real nominal = 1.0;
    Time T = 1.5;
    Date exDate = today + int(360*T);

    ext::shared_ptr<Payoff> payoff(new PlainVanillaPayoff(Option::Call,
                                                            strike));

    VarianceOption varianceOption1(payoff, nominal, today, exDate);
    varianceOption1.setPricingEngine(engine);

    Real calculated = varianceOption1.NPV();
    Real expected = 0.9104619;
    Real error = std::fabs(calculated-expected);
    if (error>1.0e-7) {
        BOOST_ERROR(
                 "Failed to reproduce variance-option price:"
                 << "\n    expected:   " << std::setprecision(7) << expected
                 << "\n    calculated: " << std::setprecision(7) << calculated
                 << "\n    error:      " << error);
    }


    v0 = 1.5;
    kappa = 2.0;
    theta = 0.01;
    sigma = 0.1;
    rho = -0.5;

    process = ext::make_shared<HestonProcess>(
               rTS, qTS, s0, v0, kappa, theta, sigma, rho);
    engine = ext::shared_ptr<PricingEngine>(
                               new IntegralHestonVarianceOptionEngine(process));

    strike = 0.7;
    nominal = 1.0;
    T = 1.0;
    exDate = today + int(360*T);

    payoff = ext::shared_ptr<Payoff>(new PlainVanillaPayoff(Option::Put,
                                                              strike));

    VarianceOption varianceOption2(payoff, nominal, today, exDate);
    varianceOption2.setPricingEngine(engine);

    calculated = varianceOption2.NPV();
    expected = 0.0466796;
    error = std::fabs(calculated-expected);
    if (error>1.0e-7) {
        BOOST_ERROR(
                 "Failed to reproduce variance-option price:"
                 << "\n    expected:   " << std::setprecision(7) << expected
                 << "\n    calculated: " << std::setprecision(7) << calculated
                 << "\n    error:      " << error);
    }

}

test_suite* VarianceOptionTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Variance option tests");

    suite->add(QUANTLIB_TEST_CASE(&VarianceOptionTest::testIntegralHeston));
    return suite;
}

]]></document_content>
  </document>
  <document index="301">
    <source>varianceoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_variance_option_hpp
#define quantlib_test_variance_option_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class VarianceOptionTest {
  public:
    static void testIntegralHeston();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="302">
    <source>varianceswaps.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "varianceswaps.hpp"
#include "utilities.hpp"
#include <ql/quotes/simplequote.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/instruments/varianceswap.hpp>
#include <ql/pricingengines/forward/replicatingvarianceswapengine.hpp>
#include <ql/pricingengines/forward/mcvarianceswapengine.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancecurve.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancesurface.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/processes/blackscholesprocess.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, isLong, varStrike, nominal, s, q, r, today, \
                       exDate, v, expected, calculated, error, tolerance) \
    BOOST_ERROR( \
        " variance swap with " \
        << "    underlying value: " << s << "\n" \
        << "    strike:           " << varStrike << "\n" \
        << "    nominal:          " << nominal << "\n" \
        << "    dividend yield:   " << io::rate(q) << "\n" \
        << "    risk-free rate:   " << io::rate(r) << "\n" \
        << "    reference date:   " << today << "\n" \
        << "    maturity:         " << exDate << "\n" \
        << "    volatility:       " << io::volatility(v) << "\n\n" \
        << "    expected   " << greekName << ": " << expected << "\n" \
        << "    calculated " << greekName << ": " << calculated << "\n"\
        << "    error:            " << error << "\n" \
        << "    tolerance:        " << tolerance);


namespace {

    struct MCVarianceSwapData {
        Position::Type type;
        Real varStrike;
        Real nominal;
        Real s;         // spot
        Rate q;         // dividend
        Rate r;         // risk-free rate
        Time t1;        // intermediate time
        Time t;         // time to maturity
        Volatility v1;  // volatility at t1
        Volatility v;   // volatility at t
        Real result;    // result
        Real tol;       // tolerance
    };

    struct ReplicatingVarianceSwapData {
        Position::Type type;
        Real varStrike;
        Real nominal;
        Real s;         // spot
        Rate q;         // dividend
        Rate r;         // risk-free rate
        Time t;         // time to maturity
        Volatility v;   // volatility at t
        Real result;    // result
        Real tol;       // tolerance
    };

    struct Datum {
        Option::Type type;
        Real strike;
        Volatility v;
    };

}


void VarianceSwapTest::testReplicatingVarianceSwap() {

    BOOST_TEST_MESSAGE("Testing variance swap with replicating cost engine...");

    ReplicatingVarianceSwapData values[] = {

        // data from "A Guide to Volatility and Variance Swaps",
        //   Derman, Kamal & Zou, 1999
        //   with maturity t corrected from 0.25 to 0.246575
        //   corresponding to Jan 1, 1999 to Apr 1, 1999

        //type, varStrike, nominal,     s,    q,    r,        t,    v,  result, tol
        {   Position::Long,      0.04,   50000, 100.0, 0.00, 0.05, 0.246575, 0.20, 0.04189, 1.0e-4}

    };

    Datum replicatingOptionData[] = {

        // data from "A Guide to Volatility and Variance Swaps",
        //   Derman, Kamal & Zou, 1999

        //Option::Type, strike, v
        { Option::Put,   50,  0.30 },
        { Option::Put,   55,  0.29 },
        { Option::Put,   60,  0.28 },
        { Option::Put,   65,  0.27 },
        { Option::Put,   70,  0.26 },
        { Option::Put,   75,  0.25 },
        { Option::Put,   80,  0.24 },
        { Option::Put,   85,  0.23 },
        { Option::Put,   90,  0.22 },
        { Option::Put,   95,  0.21 },
        { Option::Put,  100,  0.20 },
        { Option::Call, 100,  0.20 },
        { Option::Call, 105,  0.19 },
        { Option::Call, 110,  0.18 },
        { Option::Call, 115,  0.17 },
        { Option::Call, 120,  0.16 },
        { Option::Call, 125,  0.15 },
        { Option::Call, 130,  0.14 },
        { Option::Call, 135,  0.13 }
    };

    DayCounter dc = Actual365Fixed();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t, 365);
        std::vector<Date> dates(1);
        dates[0] = exDate;

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);

        Size options = LENGTH(replicatingOptionData);
        std::vector<Real> callStrikes, putStrikes, callVols, putVols;

        // Assumes ascending strikes and same min call and max put strikes
        Size j;
        for (j=0; j<options; j++) {
            if (replicatingOptionData[j].type == Option::Call) {
                callStrikes.push_back(replicatingOptionData[j].strike);
                callVols.push_back(replicatingOptionData[j].v);
            } else if (replicatingOptionData[j].type == Option::Put) {
                putStrikes.push_back(replicatingOptionData[j].strike);
                putVols.push_back(replicatingOptionData[j].v);
            } else {
                QL_FAIL("unknown option type");
            }
        }

        Matrix vols(options-1, 1);
        std::vector<Real> strikes;
        for (j=0; j<putVols.size(); j++) {
            vols[j][0] = putVols[j];
            strikes.push_back(putStrikes[j]);
        }

        for (Size k=1; k<callVols.size(); k++) {
            Size j = putVols.size()-1;
            vols[j+k][0] = callVols[k];
            strikes.push_back(callStrikes[k]);
        }

        ext::shared_ptr<BlackVolTermStructure> volTS(new
            BlackVarianceSurface(today, NullCalendar(),
                                 dates, strikes, vols, dc));

        ext::shared_ptr<GeneralizedBlackScholesProcess> stochProcess(
                             new BlackScholesMertonProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));


        ext::shared_ptr<PricingEngine> engine(
                          new ReplicatingVarianceSwapEngine(stochProcess, 5.0,
                                                            callStrikes,
                                                            putStrikes));

        VarianceSwap varianceSwap(value.type, value.varStrike, value.nominal, today, exDate);
        varianceSwap.setPricingEngine(engine);

        Real calculated = varianceSwap.variance();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol)
            REPORT_FAILURE("value", values[i].type, value.varStrike, value.nominal, value.s,
                           value.q, value.r, today, exDate, value.v, expected, calculated, error,
                           value.tol);
    }
}


void VarianceSwapTest::testMCVarianceSwap() {

    BOOST_TEST_MESSAGE("Testing variance swap with Monte Carlo engine...");

    MCVarianceSwapData values[] = {

        // data from "A Guide to Volatility and Variance Swaps",
        //   Derman, Kamal & Zou, 1999
        //   with maturity t corrected from 0.25 to 0.246575
        //   corresponding to Jan 1, 1999 to Apr 1, 1999

        // exercising code using BlackVarianceCurve because BlackVarianceSurface is unreliable
        // Result should be v*v for arbitrary t1 and v1 (as long as 0<=t1<t and 0<=v1<v)

        //type, varStrike, nominal,     s,    q,    r,  t1,     t,     v1,    v, result, tol
        {   Position::Long,      0.04,   50000, 100.0, 0.00, 0.05, 0.1, 0.246575, 0.1, 0.20,   0.04, 3.0e-4}

    };


    DayCounter dc = Actual365Fixed();
    Date today = Date::todaysDate();

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    std::vector<Volatility> vols(2);
    std::vector<Date> dates(2);

    for (auto& value : values) {
        Date exDate = today + timeToDays(value.t, 365);
        Date intermDate = today + timeToDays(value.t1, 365);
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exDate));
        dates[0] = intermDate;
        dates[1] = exDate;

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vols[0] = value.v1;
        vols[1] = value.v;

        ext::shared_ptr<BlackVolTermStructure> volTS(
                        new BlackVarianceCurve(today, dates, vols, dc, true));

        ext::shared_ptr<GeneralizedBlackScholesProcess> stochProcess(
                    new BlackScholesMertonProcess(
                                       Handle<Quote>(spot),
                                       Handle<YieldTermStructure>(qTS),
                                       Handle<YieldTermStructure>(rTS),
                                       Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine;
        engine =
            MakeMCVarianceSwapEngine<PseudoRandom>(stochProcess)
            .withStepsPerYear(250)
            .withSamples(1023)
            .withSeed(42);

        VarianceSwap varianceSwap(value.type, value.varStrike, value.nominal, today, exDate);
        varianceSwap.setPricingEngine(engine);

        Real calculated = varianceSwap.variance();
        Real expected = value.result;
        Real error = std::fabs(calculated-expected);
        if (error > value.tol)
            REPORT_FAILURE("value", values[i].type, value.varStrike, value.nominal, value.s,
                           value.q, value.r, today, exDate, value.v, expected, calculated, error,
                           value.tol);
    }
}

test_suite* VarianceSwapTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Variance swap tests");

    suite->add(QUANTLIB_TEST_CASE(
                             &VarianceSwapTest::testReplicatingVarianceSwap));
    suite->add(QUANTLIB_TEST_CASE(&VarianceSwapTest::testMCVarianceSwap));
    return suite;
}

]]></document_content>
  </document>
  <document index="303">
    <source>varianceswaps.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_variance_swaps_hpp
#define quantlib_test_variance_swaps_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class VarianceSwapTest {
  public:
    static void testReplicatingVarianceSwap();
    static void testMCVarianceSwap();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="304">
    <source>volatilitymodels.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "volatilitymodels.hpp"
#include "utilities.hpp"
#include <ql/volatilitymodel.hpp>
#include <ql/models/volatility/constantestimator.hpp>
#include <ql/models/volatility/simplelocalestimator.hpp>
#include <ql/models/volatility/garmanklass.hpp>
#include <ql/timeseries.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void VolatilityModelsTest::testConstruction() {

    BOOST_TEST_MESSAGE("Testing volatility model construction...");

    TimeSeries<Real> ts;
    ts[Date(25, March, 2005)] = 1.2;
    ts[Date(29, March, 2005)] = 2.3;
    ts[Date(15, March, 2005)] = 0.3;

    SimpleLocalEstimator sle(1/360.0);
    TimeSeries<Volatility> locale = sle.calculate(ts);

    ConstantEstimator ce(1);
    TimeSeries<Volatility> sv = ce.calculate(locale);
    sv.begin();
}

test_suite* VolatilityModelsTest::suite() {
    auto* suite = BOOST_TEST_SUITE("volatility models tests");
    suite->add(QUANTLIB_TEST_CASE(&VolatilityModelsTest::testConstruction));
    return suite;
}

]]></document_content>
  </document>
  <document index="305">
    <source>volatilitymodels.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_volatility_models_hpp
#define quantlib_test_volatility_models_hpp

#include <boost/test/unit_test.hpp>

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class VolatilityModelsTest {
  public:
    static void testConstruction();
    static boost::unit_test_framework::test_suite* suite();
};


#endif
]]></document_content>
  </document>
  <document index="306">
    <source>vpp.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "vpp.hpp"
#include "utilities.hpp"
#include <ql/experimental/finitedifferences/dynprogvppintrinsicvalueengine.hpp>
#include <ql/experimental/finitedifferences/fdklugeextouspreadengine.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextouop.hpp>
#include <ql/experimental/finitedifferences/fdmspreadpayoffinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepconditionfactory.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoustorageengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleklugeextouvppengine.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/experimental/processes/gemanroncoroniprocess.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/instruments/vanillastorageoption.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/generallinearleastsquares.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/zerocurve.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <deque>
#include <utility>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace vpp_test {
    ext::shared_ptr<ExtOUWithJumpsProcess> createKlugeProcess() {
        Array x0(2);
        x0[0] = 3.0; x0[1] = 0.0;

        const Real beta = 5.0;
        const Real eta  = 2.0;
        const Real jumpIntensity = 1.0;
        const Real speed = 1.0;
        const Real volatility = 2.0;

        ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess(
            new ExtendedOrnsteinUhlenbeckProcess(speed, volatility, x0[0],
                                                 constant<Real, Real>(x0[0])));
        return ext::make_shared<ExtOUWithJumpsProcess>(
            ouProcess, x0[1], beta,
                                      jumpIntensity, eta);
    }

    class linear {
        Real alpha, beta;
      public:
        linear(Real alpha, Real beta) : alpha(alpha), beta(beta) {}
        Real operator()(Real x) const {
            return alpha + beta*x;
        }
    };

}


void VPPTest::testGemanRoncoroniProcess() {

    BOOST_TEST_MESSAGE("Testing Geman-Roncoroni process...");

    /* Example induced by H. Geman, A. Roncoroni,
       "Understanding the Fine Structure of Electricity Prices",
       http://papers.ssrn.com/sol3/papers.cfm?abstract_id=638322
       Results are verified against the authors MatLab-Code.
       http://semeq.unipmn.it/files/Ch19_spark_spread.zip
    */

    using namespace vpp_test;

    SavedSettings backup;

    const Date today = Date(18, December, 2011);
    Settings::instance().evaluationDate() = today;
    const DayCounter dc = ActualActual(ActualActual::ISDA);

    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, 0.03, dc);

    const Real x0     = 3.3;
    const Real beta   = 0.05;
    const Real alpha  = 3.1;
    const Real gamma  = -0.09;
    const Real delta  = 0.07;
    const Real eps    = -0.40;
    const Real zeta   = -0.40;
    const Real d      = 1.6;
    const Real k      = 1.0;
    const Real tau    = 0.5;
    const Real sig2   = 10.0;
    const Real a      =-7.0;
    const Real b      =-0.3;
    const Real theta1 = 35.0;
    const Real theta2 = 9.0;
    const Real theta3 = 0.10;
    const Real psi    = 1.9;

    ext::shared_ptr<GemanRoncoroniProcess> grProcess(
                new GemanRoncoroniProcess(x0, alpha, beta, gamma, delta,
                                          eps, zeta, d, k, tau, sig2, a, b,
                                          theta1, theta2, theta3, psi));


    const Real speed     = 5.0;
    const Volatility vol = std::sqrt(1.4);
    const Real betaG     = 0.08;
    const Real alphaG    = 1.0;
    const Real x0G       = 1.1;

    ext::function<Real (Real)> f = vpp_test::linear(alphaG, betaG);

    ext::shared_ptr<StochasticProcess1D> eouProcess(
        new ExtendedOrnsteinUhlenbeckProcess(speed, vol, x0G, f,
                           ExtendedOrnsteinUhlenbeckProcess::Trapezodial));

    std::vector<ext::shared_ptr<StochasticProcess1D> > processes = {grProcess, eouProcess};

    Matrix correlation(2, 2, 1.0);
    correlation[0][1] = correlation[1][0] = 0.25;

    ext::shared_ptr<StochasticProcess> pArray(
                           new StochasticProcessArray(processes, correlation));

    const Time T = 10.0;
    const Size stepsPerYear = 250;
    const Size steps = Size(T*Real(stepsPerYear));

    TimeGrid grid(T, steps);

    typedef PseudoRandom::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;
    rsg_type rsg = PseudoRandom::make_sequence_generator(
                               pArray->size()*(grid.size()-1), BigNatural(421));

    GeneralStatistics npv, onTime;
    MultiPathGenerator<rsg_type> generator(pArray, grid, rsg, false);

    const Real heatRate = 8.0;
    const Size nrTrails = 250;

    for (Size n=0; n < nrTrails; ++n) {
        Real plantValue = 0.0;
        sample_type path = generator.next();

        for (Size i=1; i <= steps; ++i) {
            const Time t = Real(i)/stepsPerYear;
            const DiscountFactor df = rTS->discount(t);

            const Real fuelPrice         = std::exp(path.value[1][i]);
            const Real electricityPrice = std::exp(path.value[0][i]);

            const Real sparkSpread = electricityPrice - heatRate*fuelPrice;
            plantValue += std::max(0.0, sparkSpread)*df;
            onTime.add((sparkSpread > 0.0) ? 1.0 : 0.0);
        }

        npv.add(plantValue);
    }

    const Real expectedNPV = 12500;
    const Real calculatedNPV = npv.mean();
    const Real errorEstimateNPV = npv.errorEstimate();

    if (std::fabs(calculatedNPV - expectedNPV) > 3.0*errorEstimateNPV) {
        BOOST_ERROR("Failed to reproduce cached price with MC engine"
                    << "\n    calculated: " << calculatedNPV
                    << "\n    expected:   " << expectedNPV
                    << " +/- " << errorEstimateNPV);
    }

    const Real expectedOnTime = 0.43;
    const Real calculatedOnTime = onTime.mean();
    const Real errorEstimateOnTime
        = std::sqrt(calculatedOnTime*(1-calculatedOnTime))/nrTrails;

    if (std::fabs(calculatedOnTime - expectedOnTime)>3.0*errorEstimateOnTime) {
        BOOST_ERROR("Failed to reproduce cached price with MC engine"
                    << "\n    calculated: " << calculatedNPV
                    << "\n    expected:   " << expectedNPV
                    << " +/- " << errorEstimateNPV);
    }
}

void VPPTest::testSimpleExtOUStorageEngine() {

    BOOST_TEST_MESSAGE("Testing simple-storage option based on ext. OU model...");

    SavedSettings backup;

    Date settlementDate = Date(18, December, 2011);
    Settings::instance().evaluationDate() = settlementDate;
    DayCounter dayCounter = ActualActual(ActualActual::ISDA);
    Date maturityDate = settlementDate + Period(12, Months);

    std::vector<Date> exerciseDates(1, settlementDate+Period(1, Days));
    while (exerciseDates.back() < maturityDate) {
        exerciseDates.push_back(exerciseDates.back()+Period(1, Days));
    }
    ext::shared_ptr<BermudanExercise> bermudanExercise(
                                        new BermudanExercise(exerciseDates));

    const Real x0 = 3.0;
    const Real speed = 1.0;
    const Real volatility = 0.5;
    const Rate irRate = 0.1;

    ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess(
        new ExtendedOrnsteinUhlenbeckProcess(speed, volatility, x0,
                                             constant<Real, Real>(x0)));

    ext::shared_ptr<YieldTermStructure> rTS(
                                flatRate(settlementDate, irRate, dayCounter));

    ext::shared_ptr<PricingEngine> storageEngine(
               new FdSimpleExtOUStorageEngine(ouProcess, rTS, 1, 25));

    VanillaStorageOption storageOption(bermudanExercise, 50, 0, 1);

    storageOption.setPricingEngine(storageEngine);

    const Real expected = 69.5755;
    const Real calculated = storageOption.NPV();

    if (std::fabs(expected - calculated) > 5e-2) {
        BOOST_ERROR("Failed to reproduce cached values" <<
                    "\n calculated: " << calculated <<
                    "\n   expected: " << expected);
    }
}


void VPPTest::testKlugeExtOUSpreadOption() {

    BOOST_TEST_MESSAGE("Testing simple Kluge ext-Ornstein-Uhlenbeck spread option...");

    using namespace vpp_test;

    SavedSettings backup;

    Date settlementDate = Date(18, December, 2011);
    Settings::instance().evaluationDate() = settlementDate;

    DayCounter dayCounter = ActualActual(ActualActual::ISDA);
    Date maturityDate = settlementDate + Period(1, Years);
    Time maturity = dayCounter.yearFraction(settlementDate, maturityDate);

    const Real speed     = 1.0;
    const Volatility vol = std::sqrt(1.4);
    const Real betaG     = 0.0;
    const Real alphaG    = 3.0;
    const Real x0G       = 3.0;

    const Rate irRate      = 0.0;
    const Real heatRate    = 2.0;
    const Real rho         = 0.5;

    ext::shared_ptr<ExtOUWithJumpsProcess>
                                           klugeProcess = createKlugeProcess();
    ext::function<Real (Real)> f = vpp_test::linear(alphaG, betaG);

    ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> extOUProcess(
        new ExtendedOrnsteinUhlenbeckProcess(speed, vol, x0G, f,
                           ExtendedOrnsteinUhlenbeckProcess::Trapezodial));

    ext::shared_ptr<YieldTermStructure> rTS(
                                flatRate(settlementDate, irRate, dayCounter));

    ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess(
                    new KlugeExtOUProcess(rho, klugeProcess, extOUProcess));


    ext::shared_ptr<Payoff> payoff(new PlainVanillaPayoff(Option::Call, 0.0));

    Array spreadFactors(2);
    spreadFactors[0] = 1.0; spreadFactors[1] = -heatRate;
    ext::shared_ptr<BasketPayoff> basketPayoff(
                               new AverageBasketPayoff(payoff, spreadFactors));

    ext::shared_ptr<Exercise> exercise(new EuropeanExercise(maturityDate));

    BasketOption option(basketPayoff, exercise);
    option.setPricingEngine(ext::shared_ptr<PricingEngine>(
        new FdKlugeExtOUSpreadEngine(klugeOUProcess, rTS,
                                     5, 200, 50, 20)));

    TimeGrid grid(maturity, 50);
    typedef PseudoRandom::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;

    rsg_type rsg = PseudoRandom::make_sequence_generator(
        klugeOUProcess->factors() * (grid.size() - 1), 1234UL);

    MultiPathGenerator<rsg_type> generator(klugeOUProcess, grid, rsg, false);


    GeneralStatistics npv;
    const Size nTrails = 20000;
    for (Size i=0; i < nTrails; ++i) {
        const sample_type& path = generator.next();

        Array p(2);
        p[0] = path.value[0].back() + path.value[1].back();
        p[1] = path.value[2].back();
        npv.add((*basketPayoff)(Exp(p)));
    }

    const Real calculated = option.NPV();
    const Real expectedMC = npv.mean();
    const Real mcError = npv.errorEstimate();
    if (std::fabs(expectedMC - calculated) > 3*mcError) {
            BOOST_ERROR("Failed to reproduce referenc values"
                       << "\n    calculated:   " << calculated
                       << "\n    expected(MC): " << expectedMC
                       << "\n    mc error    : " << mcError);

    }
}

namespace vpp_test {
    // for a "real" gas and power forward curve
    // please see. e.g. http://www.kyos.com/?content=64
    const std::vector<Real> fuelPrices = {
                              20.74,21.65,20.78,21.58,21.43,20.82,22.02,21.52,
                              21.02,21.46,21.75,20.69,22.16,20.38,20.82,20.68,
                              20.57,21.92,22.04,20.45,20.75,21.92,20.53,20.67,
                              20.88,21.02,20.82,21.67,21.82,22.12,20.45,20.74,
                              22.39,20.95,21.71,20.70,20.94,21.59,22.33,21.13,
                              21.50,21.42,20.56,21.23,21.37,21.90,20.62,21.17,
                              21.86,22.04,22.05,21.00,20.70,21.12,21.26,22.40,
                              21.31,22.24,21.96,21.02,21.71,20.48,21.36,21.75,
                              21.90,20.44,21.26,22.29,20.34,21.79,21.66,21.50,
                              20.76,20.27,20.84,20.24,21.97,20.52,20.98,21.40,
                              20.39,20.71,20.78,20.30,21.56,21.72,20.27,21.57,
                              21.82,20.57,21.33,20.51,22.32,21.99,20.57,22.11,
                              21.56,22.24,20.62,21.70,21.11,21.19,21.79,20.46,
                              22.21,20.82,20.52,22.29,20.71,21.45,22.40,20.63,
                              20.95,21.97,22.20,20.67,21.01,22.25,20.76,21.33,
                              20.49,20.33,21.94,20.64,20.99,21.09,20.97,22.17,
                              20.72,22.06,20.86,21.40,21.75,20.78,21.79,20.47,
                              21.19,21.60,20.75,21.36,21.61,20.37,21.67,20.28,
                              22.33,21.37,21.33,20.87,21.25,22.01,22.08,20.81,
                              20.70,21.84,21.82,21.68,21.24,22.36,20.83,20.64,
                              21.03,20.57,22.34,20.96,21.54,21.26,21.43,22.39};

    const std::vector<Real> powerPrices = {
                              40.40,36.71,31.87,25.81,31.61,35.00,46.22,60.68,
                              42.45,38.01,33.84,29.79,31.84,38.53,49.23,59.92,
                              43.85,37.47,34.89,29.99,30.85,29.19,29.25,38.67,
                              36.90,25.93,22.12,20.19,17.19,19.29,13.51,18.14,
                              33.76,30.48,25.63,18.01,23.86,32.41,48.56,64.69,
                              38.42,39.31,32.73,29.97,31.41,35.02,46.85,58.12,
                              39.14,35.42,32.61,28.76,29.41,35.83,46.73,61.41,
                              61.01,59.43,60.43,66.29,62.79,62.66,57.66,51.63,
                              62.18,60.53,61.94,64.86,59.57,58.15,53.74,48.36,
                              45.64,51.21,51.54,50.79,54.50,49.92,41.58,39.81,
                              28.86,37.42,39.78,42.36,45.67,36.84,33.91,28.75,
                              62.97,63.84,62.91,68.77,64.33,61.95,59.12,54.89,
                              63.62,60.90,66.57,69.51,64.71,59.89,57.28,57.10,
                              65.09,63.82,67.52,70.51,65.59,59.36,58.22,54.64,
                              52.17,53.02,57.12,53.50,53.16,49.21,52.21,40.96,
                              49.01,47.94,49.89,53.83,52.96,50.33,51.72,46.99,
                              39.06,47.99,47.91,52.35,48.51,47.39,50.45,43.66,
                              25.62,35.76,42.76,46.51,45.62,46.79,48.76,41.00,
                              52.65,55.57,57.67,56.79,55.15,54.74,50.31,47.49,
                              53.72,55.62,55.89,58.11,54.46,52.92,49.61,44.68,
                              51.59,57.44,56.50,55.12,57.22,54.61,49.92,45.20};
}

void VPPTest::testVPPIntrinsicValue() {

    BOOST_TEST_MESSAGE("Testing VPP step condition...");

    using namespace vpp_test;

    SavedSettings backup;

    const Date today = Date(18, December, 2011);
    const DayCounter dc = ActualActual(ActualActual::ISDA);
    Settings::instance().evaluationDate() = today;

    // vpp parameters
    const Real pMin           = 8;
    const Real pMax           = 40;
    const Size tMinUp         = 2;
    const Size tMinDown       = 2;
    const Real startUpFuel    = 20;
    const Real startUpFixCost = 100;
    const Real fuelCostAddon    = 3.0;

    const ext::shared_ptr<SwingExercise> exercise(new SwingExercise(today, today + 6, 3600U));

    // Expected values are calculated using mixed integer programming
    // based on the gnu linear programming toolkit. For details please see:
    // http://spanderen.de/
    //        2011/06/23/vpp-pricing-ii-mixed-integer-linear-programming/
    const Real efficiency[] = { 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.9 };
    const Real expected[] = { 0.0, 2056.04, 11145.577778, 26452.04,
                              44512.461818, 62000.626667, 137591.911111};

    for (Size i=0; i < LENGTH(efficiency); ++i) {
        const Real heatRate = 1.0/efficiency[i];

        VanillaVPPOption option(heatRate, pMin, pMax, tMinUp, tMinDown,
                                startUpFuel, startUpFixCost, exercise);

        option.setPricingEngine(ext::shared_ptr<PricingEngine>(
            new DynProgVPPIntrinsicValueEngine(fuelPrices, powerPrices,
                                               fuelCostAddon, flatRate(0.0, dc))));

        const Real calculated = option.NPV();

        if (std::fabs(expected[i] - calculated) > 1e-4) {
            BOOST_ERROR("Failed to reproduce reference values"
                       << "\n    calculated: " << calculated
                       << "\n    expected:   " << expected[i]);

        }
    }
}

namespace vpp_test {

    class PathFuelPrice : public FdmInnerValueCalculator {
      public:
        typedef FdSimpleKlugeExtOUVPPEngine::Shape Shape;

        PathFuelPrice(const MultiPathGenerator<PseudoRandom>::sample_type::value_type& path,
                      ext::shared_ptr<Shape> shape)
        : path_(path), shape_(std::move(shape)) {}
        Real innerValue(const FdmLinearOpIterator&, Time t) override {
            QL_REQUIRE(t-std::sqrt(QL_EPSILON) <=  shape_->back().first,
                        "invalid time");

            const Size i = Size(t * 365U * 24U);
            const Real f = std::lower_bound(shape_->begin(), shape_->end(),
                std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;

            return std::exp(path_[2][i] + f);
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const MultiPathGenerator<PseudoRandom>::sample_type::value_type& path_;
        const ext::shared_ptr<Shape> shape_;
    };

    class PathSparkSpreadPrice : public FdmInnerValueCalculator {
      public:
        typedef FdSimpleKlugeExtOUVPPEngine::Shape Shape;

        PathSparkSpreadPrice(Real heatRate,
                             const MultiPathGenerator<PseudoRandom>::sample_type::value_type& path,
                             ext::shared_ptr<Shape> fuelShape,
                             ext::shared_ptr<Shape> powerShape)
        : heatRate_(heatRate), path_(path), fuelShape_(std::move(fuelShape)),
          powerShape_(std::move(powerShape)) {}

        Real innerValue(const FdmLinearOpIterator&, Time t) override {
            QL_REQUIRE(t-std::sqrt(QL_EPSILON) <=  powerShape_->back().first,
                        "invalid time");

            const Size i = Size(t * 365U * 24U);
            const Real f = std::lower_bound(
                powerShape_->begin(), powerShape_->end(),
                std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;
            const Real g = std::lower_bound(
                fuelShape_->begin(),fuelShape_->end(),
                std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;

            return std::exp(f + path_[0][i]+path_[1][i])
                    - heatRate_*std::exp(g + path_[2][i]);
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const Real heatRate_;
        const MultiPathGenerator<PseudoRandom>::sample_type::value_type& path_;
        const ext::shared_ptr<Shape> fuelShape_;
        const ext::shared_ptr<Shape> powerShape_;
    };
}


namespace vpp_test {
    ext::shared_ptr<KlugeExtOUProcess> createKlugeExtOUProcess() {
        // model definition
        const Real beta         = 200;
        const Real eta          = 1.0/0.2;
        const Real lambda       = 4.0;
        const Real alpha        = 7.0;
        const Real volatility_x = 1.4;
        const Real kappa        = 4.45;
        const Real volatility_u = std::sqrt(1.3);
        const Real rho          = 0.7;

        Array x0(2);
        x0[0] = 0.0; x0[1] = 0.0;

        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess(
            new ExtendedOrnsteinUhlenbeckProcess(alpha, volatility_x, x0[0],
                                                 constant<Real, Real>(x0[0])));
        const ext::shared_ptr<ExtOUWithJumpsProcess> lnPowerProcess(
            new ExtOUWithJumpsProcess(ouProcess, x0[1], beta, lambda, eta));

        const Real u=0.0;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> lnGasProcess(
            new ExtendedOrnsteinUhlenbeckProcess(kappa, volatility_u, u,
                                                 constant<Real, Real>(u)));

        ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess(
            new KlugeExtOUProcess(rho, lnPowerProcess, lnGasProcess));

        return klugeOUProcess;
    }
}


void VPPTest::testVPPPricing() {
    BOOST_TEST_MESSAGE("Testing VPP pricing using perfect foresight or FDM...");

    using namespace vpp_test;

    SavedSettings backup;

    const Date today = Date(18, December, 2011);
    const DayCounter dc = ActualActual(ActualActual::ISDA);
    Settings::instance().evaluationDate() = today;

    // vpp parameter
    const Real heatRate       = 2.5;
    const Real pMin           = 8;
    const Real pMax           = 40;
    const Size tMinUp         = 6;
    const Size tMinDown       = 2;
    const Real startUpFuel    = 20;
    const Real startUpFixCost = 100;

    const ext::shared_ptr<SwingExercise> exercise(new SwingExercise(today, today + 6, 3600U));

    VanillaVPPOption vppOption(heatRate, pMin, pMax, tMinUp, tMinDown,
                               startUpFuel, startUpFixCost, exercise);

    const ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess
        = createKlugeExtOUProcess();
    const ext::shared_ptr<ExtOUWithJumpsProcess> lnPowerProcess
        = klugeOUProcess->getKlugeProcess();
    const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> ouProcess
        = lnPowerProcess->getExtendedOrnsteinUhlenbeckProcess();
    const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> lnGasProcess
        = klugeOUProcess->getExtOUProcess();

    const Real beta         = lnPowerProcess->beta();
    const Real eta          = lnPowerProcess->eta();
    const Real lambda       = lnPowerProcess->jumpIntensity();
    const Real alpha        = ouProcess->speed();
    const Real volatility_x = ouProcess->volatility();
    const Real kappa        = lnGasProcess->speed();
    const Real volatility_u = lnGasProcess->volatility();

    const Rate irRate       = 0.00;
    const Real fuelCostAddon  = 3.0;

    const ext::shared_ptr<YieldTermStructure> rTS
        = flatRate(today, irRate, dc);

    const Size nHours = powerPrices.size();

    typedef FdSimpleKlugeExtOUVPPEngine::Shape Shape;
    ext::shared_ptr<Shape> fuelShape(new Shape(nHours));
    ext::shared_ptr<Shape> powerShape(new Shape(nHours));

    for (Size i=0; i < nHours; ++i) {
        const Time t = (i+1)/(365*24.);

        const Real fuelPrice = fuelPrices[i];
        const Real gs = std::log(fuelPrice)-square<Real>()(volatility_u)
                               /(4*kappa)*(1-std::exp(-2*kappa*t));
        (*fuelShape)[i] = Shape::value_type(t, gs);

        const Real powerPrice = powerPrices[i];
        const Real ps = std::log(powerPrice)-square<Real>()(volatility_x)
                 /(4*alpha)*(1-std::exp(-2*alpha*t))
                -lambda/beta*std::log((eta-std::exp(-beta*t))/(eta-1.0));

        (*powerShape)[i] = Shape::value_type(t, ps);
    }

    // Test: intrinsic value
    vppOption.setPricingEngine(ext::shared_ptr<PricingEngine>(
        new DynProgVPPIntrinsicValueEngine(fuelPrices, powerPrices,
                                           fuelCostAddon, flatRate(0.0, dc))));

    const Real intrinsic = vppOption.NPV();
    const Real expectedIntrinsic = 2056.04;
    if (std::fabs(intrinsic - expectedIntrinsic) > 0.1) {
        BOOST_ERROR("Failed to reproduce intrinsic value"
                   << "\n    calculated: " << intrinsic
                   << "\n    expected  : " << expectedIntrinsic);
    }

    // Test: finite difference price
    const ext::shared_ptr<PricingEngine> engine(
        new FdSimpleKlugeExtOUVPPEngine(klugeOUProcess, rTS,
                                        fuelShape, powerShape, fuelCostAddon,
                                        1, 25, 11, 10));

    vppOption.setPricingEngine(engine);

    const Real fdmPrice = vppOption.NPV();
    const Real expectedFdmPrice = 5217.68;
    if (std::fabs(fdmPrice - expectedFdmPrice) > 0.1) {
       BOOST_ERROR("Failed to reproduce finite difference price"
                   << "\n    calculated: " << fdmPrice
                   << "\n    expected  : " << expectedFdmPrice);
    }

    // Test: Monte-Carlo perfect foresight price
    VanillaVPPOption::arguments args;
    vppOption.setupArguments(&args);

    const FdmVPPStepConditionFactory stepConditionFactory(args);

    const ext::shared_ptr<FdmMesher> oneDimMesher(new FdmMesherComposite(
        stepConditionFactory.stateMesher()));
    const Size nStates = oneDimMesher->layout()->dim()[0];

    const FdmVPPStepConditionMesher vppMesh = {0U, oneDimMesher};

    const TimeGrid grid(dc.yearFraction(today, exercise->lastDate()+1),
                        exercise->dates().size());
    typedef PseudoRandom::rsg_type rsg_type;
    typedef MultiPathGenerator<rsg_type>::sample_type sample_type;

    rsg_type rsg = PseudoRandom::make_sequence_generator(
        klugeOUProcess->factors() * (grid.size() - 1), 1234UL);
    MultiPathGenerator<rsg_type> generator(klugeOUProcess, grid, rsg, false);

    GeneralStatistics npv;
    const Size nTrails = 2500;

    for (Size i=0; i < nTrails; ++i) {
        const sample_type& path = generator.next();
        const ext::shared_ptr<FdmVPPStepCondition> stepCondition(
            stepConditionFactory.build(
                vppMesh, fuelCostAddon,
                ext::shared_ptr<FdmInnerValueCalculator>(
                    new PathFuelPrice(path.value, fuelShape)),
                ext::shared_ptr<FdmInnerValueCalculator>(
                    new PathSparkSpreadPrice(heatRate, path.value,
                                             fuelShape, powerShape))));

        Array state(nStates, 0.0);
        for (Size j=exercise->dates().size(); j > 0; --j) {
            stepCondition->applyTo(state, grid.at(j));
            state*=rTS->discount(grid.at(j))/rTS->discount(grid.at(j-1));
        }

        npv.add(state.back());
    }
    Real npvMC = npv.mean();
    Real errorMC = npv.errorEstimate();
    const Real expectedMC = 5250.0;
    if (std::fabs(npvMC-expectedMC) > 3*errorMC) {
        BOOST_ERROR("Failed to reproduce Monte-Carlo price"
                   << "\n    calculated: " << npvMC
                   << "\n    error     ; " << errorMC
                   << "\n    expected  : " << expectedMC);
    }
    npv.reset();

    // Test: Longstaff Schwartz least squares Monte-Carlo
    // implementation is not strictly correct but saves some coding
    const Size nCalibrationTrails = 1000U;
    std::vector<sample_type> calibrationPaths;
    std::vector<ext::shared_ptr<FdmVPPStepCondition> > stepConditions;
    std::vector<ext::shared_ptr<FdmInnerValueCalculator> > sparkSpreads;

    sparkSpreads.reserve(nCalibrationTrails);
    stepConditions.reserve(nCalibrationTrails);
    calibrationPaths.reserve(nCalibrationTrails);

    for (Size i=0; i < nCalibrationTrails; ++i) {
        calibrationPaths.push_back(generator.next());

        sparkSpreads.push_back(ext::shared_ptr<FdmInnerValueCalculator>(
            new PathSparkSpreadPrice(heatRate, calibrationPaths.back().value,
                                     fuelShape, powerShape)));
        stepConditions.push_back(stepConditionFactory.build(
            vppMesh, fuelCostAddon,
            ext::shared_ptr<FdmInnerValueCalculator>(
                new PathFuelPrice(calibrationPaths.back().value, fuelShape)),
            sparkSpreads.back()));
    }


    const FdmLinearOpIterator iter = oneDimMesher->layout()->begin();

    // prices of all calibration paths for all states
    std::vector<Array> prices(nCalibrationTrails, Array(nStates, 0.0));

    // regression coefficients for all states and all exercise dates
    std::vector<std::vector<Array> > coeff(
        nStates, std::vector<Array>(exercise->dates().size(), Array()));

    // regression functions
    const Size dim = 1U;
    std::vector<ext::function<Real(Array)> > v(
        LsmBasisSystem::multiPathBasisSystem(dim, 5U, LsmBasisSystem::Monomial));

    for (Size i = exercise->dates().size(); i > 0U; --i) {
        const Time t = grid.at(i);

        std::vector<Array> x(nCalibrationTrails, Array(dim));

        for (Size j=0; j < nCalibrationTrails; ++j) {
            x[j][0] = sparkSpreads[j]->innerValue(iter, t);
        }

        for (Size k=0; k < nStates; ++k) {
            std::vector<Real> y(nCalibrationTrails);

            for (Size j=0; j < nCalibrationTrails; ++j) {
                y[j] = prices[j][k];
            }
            coeff[k][i-1] = GeneralLinearLeastSquares(x, y, v).coefficients();

            for (Size j=0; j < nCalibrationTrails; ++j) {
                prices[j][k] = 0.0;
                for (Size l=0; l < v.size(); ++l) {
                    prices[j][k] += coeff[k][i-1][l]*v[l](x[j]);
                }
            }
        }

        for (Size j=0; j < nCalibrationTrails; ++j) {
            stepConditions[j]->applyTo(prices[j], grid.at(i));
        }
    }

    Real tmpValue = 0.0;
    for (Size i=0; i < nTrails; ++i) {
        Array x(dim), state(nStates, 0.0), contState(nStates, 0.0);

        const sample_type& path = (i % 2) != 0U ? generator.antithetic() : generator.next();

        const ext::shared_ptr<FdmInnerValueCalculator> fuelPrices(
            new PathFuelPrice(path.value, fuelShape));

        const ext::shared_ptr<FdmInnerValueCalculator> sparkSpreads(
            new PathSparkSpreadPrice(heatRate, path.value,
                                     fuelShape, powerShape));

        for (Size j = exercise->dates().size(); j > 0U; --j) {
            const Time t = grid.at(j);
            const Real fuelPrice = fuelPrices->innerValue(iter, t);
            const Real sparkSpread = sparkSpreads->innerValue(iter, t);
            const Real startUpCost
                    = startUpFixCost + (fuelPrice + fuelCostAddon)*startUpFuel;

            x[0] = sparkSpread;
            for (Size k=0; k < nStates; ++k) {
                contState[k] = 0.0;
                for (Size l=0; l < v.size(); ++l) {
                    contState[k] += coeff[k][j-1][l]*v[l](x);
                }
            }

            const Real pMinFlow = pMin*(sparkSpread - heatRate*fuelCostAddon);
            const Real pMaxFlow = pMax*(sparkSpread - heatRate*fuelCostAddon);

            // rollback continuation states and the path states
            for (Size i=0; i < 2*tMinUp; ++i) {
                if (i < tMinUp) {
                    state[i]    += pMinFlow;
                    contState[i]+= pMinFlow;
                }
                else {
                    state[i]    += pMaxFlow;
                    contState[i]+= pMaxFlow;
                }
            }

            // dynamic programming using the continuation values
            Array retVal(nStates);
            for (Size i=0; i < tMinUp-1; ++i) {
                retVal[i] = retVal[tMinUp + i]
                          = (contState[i+1] > contState[tMinUp + i+1])?
                                          state[i+1] : state[tMinUp + i+1];
            }

            if (contState[2*tMinUp] >=
                std::max(contState[tMinUp-1], contState[2*tMinUp-1])) {
                retVal[tMinUp-1] = retVal[2*tMinUp-1] = state[2*tMinUp];
            }
            else if (contState[tMinUp-1] >= contState[2*tMinUp-1]) {
                retVal[tMinUp-1] = retVal[2*tMinUp-1] = state[tMinUp-1];
            }
            else {
                retVal[tMinUp-1] = retVal[2*tMinUp-1] = state[2*tMinUp-1];
            }

            for (Size i=0; i < tMinDown-1; ++i) {
                retVal[2*tMinUp + i] = state[2*tMinUp + i+1];
            }

            if (contState.back() >=
                std::max(contState.front(), contState[tMinUp]) - startUpCost) {
                retVal.back() = state.back();
            }
            else if (contState.front() >  contState[tMinUp]) {
                retVal.back() = state.front()-startUpCost;
            }
            else {
                retVal.back() = state[tMinUp]-startUpCost;
            }
            state = retVal;
        }
        tmpValue+=0.5*state.back();
        if ((i % 2) != 0U) {
            npv.add(tmpValue, 1.0);
            tmpValue = 0.0;
        }
    }

    npvMC = npv.mean();
    errorMC = npv.errorEstimate();
    if (std::fabs(npvMC-fdmPrice) > 3*errorMC) {
        BOOST_ERROR("Failed to reproduce Least Square Monte-Carlo price"
                   << "\n    calculated   : " << npvMC
                   << "\n    error        : " << errorMC
                   << "\n    expected FDM : " << fdmPrice);
    }
}

void VPPTest::testKlugeExtOUMatrixDecomposition() {
    BOOST_TEST_MESSAGE("Testing KlugeExtOU matrix decomposition...");

    using namespace vpp_test;

    SavedSettings backup;

    const Date today = Date(18, December, 2011);
    Settings::instance().evaluationDate() = today;

    const ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess
        = createKlugeExtOUProcess();

    const Size xGrid = 50;
    const Size yGrid = 20;
    const Size uGrid = 20;
    const Time maturity = 1;

    const ext::shared_ptr<ExtOUWithJumpsProcess> klugeProcess
        = klugeOUProcess->getKlugeProcess();
    const ext::shared_ptr<StochasticProcess1D> ouProcess
        = klugeProcess->getExtendedOrnsteinUhlenbeckProcess();

    const ext::shared_ptr<FdmMesher> mesher(
        new FdmMesherComposite(
            ext::shared_ptr<Fdm1dMesher>(
                new FdmSimpleProcess1dMesher(xGrid, ouProcess, maturity)),
            ext::shared_ptr<Fdm1dMesher>(
                new ExponentialJump1dMesher(yGrid,
                                            klugeProcess->beta(),
                                            klugeProcess->jumpIntensity(),
                                            klugeProcess->eta())),
            ext::shared_ptr<Fdm1dMesher>(
                new FdmSimpleProcess1dMesher(uGrid,
                                             klugeOUProcess->getExtOUProcess(),
                                             maturity))));

    const ext::shared_ptr<FdmLinearOpComposite> op(
        new FdmKlugeExtOUOp(mesher, klugeOUProcess,
                            flatRate(today, 0.0, ActualActual(ActualActual::ISDA)),
                            FdmBoundaryConditionSet(), 16));
    op->setTime(0.1, 0.2);

    Array x(mesher->layout()->size());

    PseudoRandom::rng_type rng(PseudoRandom::urng_type(12345UL));
    for (double& i : x) {
        i = rng.next().value;
    }

    const Real tol = 1e-9;
    const Array applyExpected = op->apply(x);
    const Array applyExpectedMixed = op->apply_mixed(x);

    const std::vector<SparseMatrix> matrixDecomp(op->toMatrixDecomp());
    const Array applyCalculated = prod(op->toMatrix(), x);
    const Array applyCalculatedMixed = prod(matrixDecomp.back(), x);

    for (Size i=0; i < x.size(); ++i) {
        const Real diffApply = std::fabs(applyExpected[i]-applyCalculated[i]);
        if (diffApply > tol && diffApply > std::fabs(applyExpected[i])*tol) {
            BOOST_ERROR("Failed to reproduce apply operation" <<
                     "\n    expected  : " << applyExpected[i] <<
                     "\n    calculated: " << applyCalculated[i] <<
                     "\n    diff      : " << diffApply);
        }

        const Real diffMixed = std::fabs(applyExpectedMixed[i]-applyCalculatedMixed[i]);
        if (diffMixed > tol && diffMixed > std::fabs(applyExpected[i])*tol) {
            BOOST_ERROR("Failed to reproduce apply operation" <<
                     "\n    expected  : " << applyExpectedMixed[i] <<
                     "\n    calculated: " << applyCalculatedMixed[i] <<
                     "\n    diff      : " << diffMixed);
        }
    }


    for (Size i=0; i < 3; ++i) {
        const Array applyExpectedDir = op->apply_direction(i, x);
        const Array applyCalculatedDir = prod(matrixDecomp[i], x);

        for (Size j=0; j < x.size(); ++j) {
            const Real diff
                = std::fabs((applyExpectedDir[j] - applyCalculatedDir[j]));

            if (diff > tol && diff > std::fabs(applyExpectedDir[j]*tol)) {
                BOOST_ERROR("Failed to reproduce apply operation" <<
                         "\n    expected  : " << applyExpectedDir[i] <<
                         "\n    calculated: " << applyCalculatedDir[i] <<
                         "\n    diff : " << diff);
            }
        }
    }
}


test_suite* VPPTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("VPP Test");

    suite->add(QUANTLIB_TEST_CASE(&VPPTest::testGemanRoncoroniProcess));
    suite->add(QUANTLIB_TEST_CASE(&VPPTest::testSimpleExtOUStorageEngine));
    suite->add(QUANTLIB_TEST_CASE(&VPPTest::testKlugeExtOUSpreadOption));
    suite->add(QUANTLIB_TEST_CASE(&VPPTest::testVPPIntrinsicValue));
    suite->add(QUANTLIB_TEST_CASE(
        &VPPTest::testKlugeExtOUMatrixDecomposition));

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&VPPTest::testVPPPricing));
    }

    return suite;
}


]]></document_content>
  </document>
  <document index="307">
    <source>vpp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_vpp_hpp
#define quantlib_test_vpp_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class VPPTest {
  public:
    static void testGemanRoncoroniProcess();
    static void testSimpleExtOUStorageEngine();
    static void testKlugeExtOUSpreadOption();
    static void testVPPIntrinsicValue();
    static void testVPPPricing();
    static void testKlugeExtOUMatrixDecomposition();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};

#endif
]]></document_content>
  </document>
  <document index="308">
    <source>zabr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "zabr.hpp"
#include "utilities.hpp"
#include <ql/termstructures/volatility/sabrsmilesection.hpp>
#include <ql/experimental/volatility/zabrsmilesection.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

void ZabrTest::testConsistency() {

    Real tol = 1E-4;

    Real alpha = 0.08;
    Real beta = 0.70;
    Real nu = 0.20;
    Real rho = -0.30;
    Real tau = 5.0;
    Real forward = 0.03;

    SabrSmileSection sabr(tau, forward,
                          {alpha, beta, nu, rho});

    ZabrSmileSection<ZabrShortMaturityLognormal> zabr0(tau, forward,
                                                       {alpha, beta, nu, rho, 1.0});

    ZabrSmileSection<ZabrShortMaturityNormal> zabr1(tau, forward,
                                                    {alpha, beta, nu, rho, 1.0});

    ZabrSmileSection<ZabrLocalVolatility> zabr2(tau, forward,
                                                {alpha, beta, nu, rho, 1.0});

    // for full finite prices reduce the number of intermediate points here
    // below the recommended value to speed up the test
    ZabrSmileSection<ZabrFullFd> zabr3(tau, forward,
                                       {alpha, beta, nu, rho, 1.0},
                                       std::vector<Real>(), 2);

    Real k = 0.0001;
    while (k <= 0.70) {
        Real c0 = sabr.optionPrice(k);
        Real z0 = zabr0.optionPrice(k);
        Real z1 = zabr1.optionPrice(k);
        Real z2 = zabr2.optionPrice(k);
        Real z3 = zabr3.optionPrice(k);
        if (std::fabs(z0 - c0) > tol)
            BOOST_ERROR("Zabr short maturity lognormal expansion price "
                          "("
                          << z0 << ") deviates from Sabr Hagan 2002 price "
                                   "by " << (z0 - c0));
        if (std::fabs(z1 - c0) > tol)
            BOOST_ERROR("Zabr short maturity normal expansion price "
                          "("
                          << z1 << ") deviates from Sabr Hagan 2002 price "
                                   "by " << (z1 - c0));
        if (std::fabs(z2 - c0) > tol)
            BOOST_ERROR("Zabr local volatility price "
                          "("
                          << z2 << ") deviates from Sabr Hagan 2002 price "
                                   "by " << (z2 - c0));
        if (std::fabs(z3 - c0) > tol)
            BOOST_ERROR("Zabr full finite difference price "
                          "("
                          << z3 << ") deviates from Sabr Hagan 2002 price "
                                   "by " << (z3 - c0));
        k += 0.0001;
    }
}

test_suite *ZabrTest::suite(SpeedLevel speed) {
    auto* suite = BOOST_TEST_SUITE("Zabr model tests");

    if (speed == Slow) {
        suite->add(QUANTLIB_TEST_CASE(&ZabrTest::testConsistency));
    }

    return suite;
}
]]></document_content>
  </document>
  <document index="309">
    <source>zabr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_zabr_hpp
#define quantlib_test_zabr_hpp

#include <boost/test/unit_test.hpp>
#include "speedlevel.hpp"

/* remember to document new and/or updated tests in the Doxygen
   comment block of the corresponding class */

class ZabrTest {
  public:
    static void testConsistency();
    static boost::unit_test_framework::test_suite* suite(SpeedLevel);
};


#endif
]]></document_content>
  </document>
  <document index="310">
    <source>zerocouponswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "zerocouponswap.hpp"
#include "utilities.hpp"
#include <ql/instruments/zerocouponswap.hpp>
#include <ql/cashflows/subperiodcoupon.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/time/calendars/target.hpp>

using namespace QuantLib;
using namespace boost::unit_test_framework;

namespace zerocouponswap_test {

    struct CommonVars {

        Date today, settlement;
        Calendar calendar;
        Natural settlementDays, paymentDelay;
        DayCounter dayCount;
        BusinessDayConvention businessConvention;
        Real baseNominal, finalPayment;

        ext::shared_ptr<IborIndex> euribor;
        RelinkableHandle<YieldTermStructure> euriborHandle;
        ext::shared_ptr<PricingEngine> discountEngine;

        // cleanup
        SavedSettings backup;
        // utilities

        CommonVars() {
            settlementDays = 2;
            paymentDelay = 1;
            calendar = TARGET();
            dayCount = Actual365Fixed();
            businessConvention = ModifiedFollowing;
            baseNominal = 1.0e6;
            finalPayment = 1.2e6;

            euribor = ext::shared_ptr<IborIndex>(new Euribor6M(euriborHandle));
            euribor->addFixing(Date(10, February, 2021), 0.0085);

            today = calendar.adjust(Date(15, March, 2021));
            Settings::instance().evaluationDate() = today;
            settlement = calendar.advance(today, settlementDays, Days);

            euriborHandle.linkTo(flatRate(settlement, 0.007, dayCount));
            discountEngine =
                ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(euriborHandle));
        }

        ext::shared_ptr<CashFlow> createSubPeriodsCoupon(const Date& start, const Date& end) const {
            Date paymentDate = calendar.advance(end, paymentDelay * Days, businessConvention);
            ext::shared_ptr<FloatingRateCoupon> cpn(new SubPeriodsCoupon(
                paymentDate, baseNominal, start, end, settlementDays, euribor));
            cpn->setPricer(
                    ext::shared_ptr<FloatingRateCouponPricer>(new CompoundingRatePricer()));
            return cpn;
        }

        ext::shared_ptr<ZeroCouponSwap> createZCSwap(Swap::Type type,
                                                     const Date& start,
                                                     const Date& end,
                                                     Real baseNominal,
                                                     Real finalPayment) {
            auto swap = ext::make_shared<ZeroCouponSwap>(type, baseNominal, start, end, finalPayment, 
                                                         euribor, calendar, businessConvention,
                                                         paymentDelay);
            swap->setPricingEngine(discountEngine);
            return swap;
        }

        ext::shared_ptr<ZeroCouponSwap> createZCSwap(Swap::Type type,
                                                     const Date& start,
                                                     const Date& end,
                                                     Real finalPayment) {
            return createZCSwap(type, start, end, baseNominal, finalPayment);
        }

        ext::shared_ptr<ZeroCouponSwap> createZCSwap(Swap::Type type,
                                                     const Date& start,
                                                     const Date& end) {
            return createZCSwap(type, start, end, finalPayment);
        }

        ext::shared_ptr<ZeroCouponSwap> createZCSwap(const Date& start, 
                                                     const Date& end, 
                                                     Rate fixedRate) {
            auto swap = ext::make_shared<ZeroCouponSwap>(Swap::Receiver, baseNominal, 
                                                         start, end, fixedRate, dayCount, euribor,
                                                         calendar, businessConvention, paymentDelay);
            swap->setPricingEngine(discountEngine);
            return swap;
        }
    };

    void checkReplicationOfZeroCouponSwapNPV(const Date& start,
                                             const Date& end,
                                             Swap::Type type = Swap::Receiver) {
        CommonVars vars;
        const Real tolerance = 1.0e-8;

        auto zcSwap = vars.createZCSwap(type, start, end);

        Real actualNPV = zcSwap->NPV();
        Real actualFixedLegNPV = zcSwap->fixedLegNPV();
        Real actualFloatLegNPV = zcSwap->floatingLegNPV();

        Date paymentDate =
            vars.calendar.advance(end, vars.paymentDelay * Days, vars.businessConvention);
        Real discountAtPayment =
            paymentDate < vars.settlement ? 0.0 : vars.euriborHandle->discount(paymentDate);
        Real expectedFixedLegNPV = -type * discountAtPayment * vars.finalPayment;

        auto subPeriodCpn = vars.createSubPeriodsCoupon(start, end);
        Real expectedFloatLegNPV =
            paymentDate < vars.settlement ? 0.0 : type * discountAtPayment * subPeriodCpn->amount();

        Real expectedNPV = expectedFloatLegNPV + expectedFixedLegNPV;

        if ((std::fabs(actualNPV - expectedNPV) > tolerance) ||
            (std::fabs(actualFixedLegNPV - expectedFixedLegNPV) > tolerance) ||
            (std::fabs(actualFloatLegNPV - expectedFloatLegNPV) > tolerance))
            BOOST_ERROR("unable to replicate NPVs of zero coupon swap and its legs\n"
                        << "    actual NPV:    " << actualNPV << "\n"
                        << "    expected NPV:    " << expectedNPV << "\n"
                        << "    actual fixed leg NPV:    " << actualFixedLegNPV << "\n"
                        << "    expected fixed leg NPV:    " << expectedFixedLegNPV << "\n"
                        << "    actual float leg NPV:    " << actualFloatLegNPV << "\n"
                        << "    expected float leg NPV:    " << expectedFloatLegNPV << "\n"
                        << "    start:    " << start << "\n"
                        << "    end:    " << end << "\n"
                        << "    type:    " << type << "\n");
    }

    void checkFairFixedPayment(const Date& start,
                               const Date& end,
                               Swap::Type type) {
        CommonVars vars;
        const Real tolerance = 1.0e-8;

        auto zcSwap = vars.createZCSwap(type, start, end);
        Real fairFixedPayment = zcSwap->fairFixedPayment();
        auto parZCSwap = vars.createZCSwap(type, start, end, fairFixedPayment);
        Real parZCSwapNPV = parZCSwap->NPV();

        if ((std::fabs(parZCSwapNPV) > tolerance))
            BOOST_ERROR("unable to replicate fair fixed payment\n"
                        << "    actual NPV:    " << parZCSwapNPV << "\n"
                        << "    expected NPV:    0.0\n"
                        << "    fair fixed payment:    " << fairFixedPayment << "\n"
                        << "    start:    " << start << "\n"
                        << "    end:    " << end << "\n"
                        << "    type:    " << type << "\n");
    }

    void checkFairFixedRate(const Date& start, const Date& end, Swap::Type type) {
        CommonVars vars;
        const Real tolerance = 1.0e-8;

        auto zcSwap = vars.createZCSwap(type, start, end);
        Rate fairFixedRate = zcSwap->fairFixedRate(vars.dayCount);
        auto parZCSwap = vars.createZCSwap(start, end, fairFixedRate);
        Real parZCSwapNPV = parZCSwap->NPV();

        if ((std::fabs(parZCSwapNPV) > tolerance))
            BOOST_ERROR("unable to replicate fair fixed rate\n"
                        << "    actual NPV:    " << parZCSwapNPV << "\n"
                        << "    expected NPV:    0.0\n"
                        << "    fair fixed rate:    " << fairFixedRate << "\n"
                        << "    start:    " << start << "\n"
                        << "    end:    " << end << "\n"
                        << "    type:    " << type << "\n");
    }
}

void ZeroCouponSwapTest::testInstrumentValuation() {
    BOOST_TEST_MESSAGE("Testing zero coupon swap valuation...");
    
    using namespace zerocouponswap_test;

    // Ongoing instrument
    checkReplicationOfZeroCouponSwapNPV(Date(12, February, 2021), Date(12, February, 2041),
                                        Swap::Receiver);
    // Forward starting instrument
    checkReplicationOfZeroCouponSwapNPV(Date(15, April, 2021), Date(12, February, 2041), 
                                        Swap::Payer);

    // Expired instrument
    checkReplicationOfZeroCouponSwapNPV(Date(12, February, 2000), Date(12, February, 2020));
}

void ZeroCouponSwapTest::testFairFixedPayment() {
    BOOST_TEST_MESSAGE("Testing fair fixed payment...");
    
    using namespace zerocouponswap_test;

    // Ongoing instrument
    checkFairFixedPayment(Date(12, February, 2021), Date(12, February, 2041),
                          Swap::Receiver);

    // Spot starting instrument
    checkFairFixedPayment(Date(17, March, 2021), Date(12, February, 2041), 
                          Swap::Payer);
}

void ZeroCouponSwapTest::testFairFixedRate() {
    BOOST_TEST_MESSAGE("Testing fair fixed rate...");

    using namespace zerocouponswap_test;

    // Ongoing instrument
    checkFairFixedRate(Date(12, February, 2021), Date(12, February, 2041),
                       Swap::Receiver);

    // Spot starting instrument
    checkFairFixedRate(Date(17, March, 2021), Date(12, February, 2041), Swap::Payer);
}

void ZeroCouponSwapTest::testFixedPaymentFromRate() {
    BOOST_TEST_MESSAGE("Testing fixed payment calculation from rate...");

    using namespace zerocouponswap_test;
    
    CommonVars vars;
    const Real tolerance = 1.0e-8;
    const Rate fixedRate = 0.01;

    Date start(12, February, 2021);
    Date end(12, February, 2041);

    auto zcSwap = vars.createZCSwap(start, end, fixedRate);
    Real actualFxdPmt = zcSwap->fixedPayment();

    Time T = vars.dayCount.yearFraction(start, end);
    Real expectedFxdPmt = zcSwap->baseNominal() * (std::pow(1.0 + fixedRate, T) - 1.0);

    if ((std::fabs(actualFxdPmt - expectedFxdPmt) > tolerance))
        BOOST_ERROR("unable to replicate fixed payment from rate\n"
                    << "    actual fixed payment:    " << actualFxdPmt << "\n"
                    << "    expected fixed payment:    " << expectedFxdPmt << "\n"
                    << "    start:    " << start << "\n"
                    << "    end:    " << end << "\n");
}

void ZeroCouponSwapTest::testArgumentsValidation() {
    BOOST_TEST_MESSAGE("Testing arguments validation...");

    using namespace zerocouponswap_test;

    CommonVars vars;

    Date start(12, February, 2021);
    Date end(12, February, 2041);

    // Negative base nominal
    BOOST_CHECK_THROW(vars.createZCSwap(Swap::Payer, start, end, -1.0e6, 1.0e6),
                      Error);

    // Start date after end date
    BOOST_CHECK_THROW(vars.createZCSwap(end, start, 0.01), Error);
}

void ZeroCouponSwapTest::testExpectedCashFlowsInLegs() {
    BOOST_TEST_MESSAGE("Testing expected cash flows in legs...");

    using namespace zerocouponswap_test;

    CommonVars vars;
    const Real tolerance = 1.0e-8;

    Date start(12, February, 2021);
    Date end(12, February, 2041);

    auto zcSwap = vars.createZCSwap(start, end, 0.01);
    auto fixedCashFlow = zcSwap->fixedLeg()[0];
    auto floatingCashFlow = zcSwap->floatingLeg()[0];

    Date paymentDate =
        vars.calendar.advance(end, vars.paymentDelay * Days, vars.businessConvention);
    auto subPeriodCpn = vars.createSubPeriodsCoupon(start, end);

    if ((std::fabs(fixedCashFlow->amount() - zcSwap->fixedPayment()) > tolerance) ||
        (fixedCashFlow->date() != paymentDate))
        BOOST_ERROR("unable to replicate fixed leg\n"
                    << "    actual amount:    " << fixedCashFlow->amount() << "\n"
                    << "    expected amount:    " << zcSwap->fixedPayment() << "\n"
                    << "    actual payment date:    " << fixedCashFlow->date() << "\n"
                    << "    expected payment date:    " << paymentDate << "\n");

    if ((std::fabs(floatingCashFlow->amount() - subPeriodCpn->amount()) > tolerance) ||
        (floatingCashFlow->date() != paymentDate))
        BOOST_ERROR("unable to replicate floating leg\n"
                    << "    actual amount:    " << floatingCashFlow->amount() << "\n"
                    << "    expected amount:    " << subPeriodCpn->amount() << "\n"
                    << "    actual payment date:    " << floatingCashFlow->date() << "\n"
                    << "    expected payment date:    " << paymentDate << "\n");
}

test_suite* ZeroCouponSwapTest::suite() {
    auto* suite = BOOST_TEST_SUITE("Zero coupon swap tests");

    suite->add(QUANTLIB_TEST_CASE(&ZeroCouponSwapTest::testInstrumentValuation));
    suite->add(QUANTLIB_TEST_CASE(&ZeroCouponSwapTest::testFairFixedPayment));
    suite->add(QUANTLIB_TEST_CASE(&ZeroCouponSwapTest::testFairFixedRate));
    suite->add(QUANTLIB_TEST_CASE(&ZeroCouponSwapTest::testFixedPaymentFromRate));
    suite->add(QUANTLIB_TEST_CASE(&ZeroCouponSwapTest::testArgumentsValidation));
    suite->add(QUANTLIB_TEST_CASE(&ZeroCouponSwapTest::testExpectedCashFlowsInLegs));

    return suite;
}
]]></document_content>
  </document>
  <document index="311">
    <source>zerocouponswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_zerocouponswap_hpp
#define quantlib_test_zerocouponswap_hpp

#include <boost/test/unit_test.hpp>

class ZeroCouponSwapTest {
  public:
    static void testInstrumentValuation();
    static void testFairFixedPayment();
    static void testFairFixedRate();
    static void testFixedPaymentFromRate();
    static void testArgumentsValidation();
    static void testExpectedCashFlowsInLegs();

    static boost::unit_test_framework::test_suite* suite();
};

#endif
]]></document_content>
  </document>
</documents>